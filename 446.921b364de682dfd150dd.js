(self["webpackChunkbase_env"] = self["webpackChunkbase_env"] || []).push([[446],{

/***/ 739:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "_": () => (/* binding */ Draggable)
/* harmony export */ });
/* unused harmony export default */
/* harmony import */ var _utils_matrix_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(708);
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  subClass.__proto__ = superClass;
}
/*!
 * Draggable 3.10.4
 * https://greensock.com
 *
 * @license Copyright 2008-2022, GreenSock. All rights reserved.
 * Subject to the terms at https://greensock.com/standard-license or for
 * Club GreenSock members, the agreement issued with that membership.
 * @author: Jack Doyle, jack@greensock.com
 */

/* eslint-disable */




var gsap,
    _win,
    _doc,
    _docElement,
    _body,
    _tempDiv,
    _placeholderDiv,
    _coreInitted,
    _checkPrefix,
    _toArray,
    _supportsPassive,
    _isTouchDevice,
    _touchEventLookup,
    _dragCount,
    _isMultiTouching,
    _isAndroid,
    InertiaPlugin,
    _defaultCursor,
    _supportsPointer,
    _windowExists = function _windowExists() {
  return typeof window !== "undefined";
},
    _getGSAP = function _getGSAP() {
  return gsap || _windowExists() && (gsap = window.gsap) && gsap.registerPlugin && gsap;
},
    _isFunction = function _isFunction(value) {
  return typeof value === "function";
},
    _isObject = function _isObject(value) {
  return _typeof(value) === "object";
},
    _isUndefined = function _isUndefined(value) {
  return typeof value === "undefined";
},
    _emptyFunc = function _emptyFunc() {
  return false;
},
    _transformProp = "transform",
    _transformOriginProp = "transformOrigin",
    _round = function _round(value) {
  return Math.round(value * 10000) / 10000;
},
    _isArray = Array.isArray,
    _createElement = function _createElement(type, ns) {
  var e = _doc.createElementNS ? _doc.createElementNS((ns || "http://www.w3.org/1999/xhtml").replace(/^https/, "http"), type) : _doc.createElement(type); //some servers swap in https for http in the namespace which can break things, making "style" inaccessible.

  return e.style ? e : _doc.createElement(type); //some environments won't allow access to the element's style when created with a namespace in which case we default to the standard createElement() to work around the issue. Also note that when GSAP is embedded directly inside an SVG file, createElement() won't allow access to the style object in Firefox (see https://greensock.com/forums/topic/20215-problem-using-tweenmax-in-standalone-self-containing-svg-file-err-cannot-set-property-csstext-of-undefined/).
},
    _RAD2DEG = 180 / Math.PI,
    _bigNum = 1e20,
    _identityMatrix = new _utils_matrix_js__WEBPACK_IMPORTED_MODULE_0__/* .Matrix2D */ .G9(),
    _getTime = Date.now || function () {
  return new Date().getTime();
},
    _renderQueue = [],
    _lookup = {},
    //when a Draggable is created, the target gets a unique _gsDragID property that allows gets associated with the Draggable instance for quick lookups in Draggable.get(). This avoids circular references that could cause gc problems.
_lookupCount = 0,
    _clickableTagExp = /^(?:a|input|textarea|button|select)$/i,
    _lastDragTime = 0,
    _temp1 = {},
    // a simple object we reuse and populate (usually x/y properties) to conserve memory and improve performance.
_windowProxy = {},
    //memory/performance optimization - we reuse this object during autoScroll to store window-related bounds/offsets.
_copy = function _copy(obj, factor) {
  var copy = {},
      p;

  for (p in obj) {
    copy[p] = factor ? obj[p] * factor : obj[p];
  }

  return copy;
},
    _extend = function _extend(obj, defaults) {
  for (var p in defaults) {
    if (!(p in obj)) {
      obj[p] = defaults[p];
    }
  }

  return obj;
},
    _setTouchActionForAllDescendants = function _setTouchActionForAllDescendants(elements, value) {
  var i = elements.length,
      children;

  while (i--) {
    value ? elements[i].style.touchAction = value : elements[i].style.removeProperty("touch-action");
    children = elements[i].children;
    children && children.length && _setTouchActionForAllDescendants(children, value);
  }
},
    _renderQueueTick = function _renderQueueTick() {
  return _renderQueue.forEach(function (func) {
    return func();
  });
},
    _addToRenderQueue = function _addToRenderQueue(func) {
  _renderQueue.push(func);

  if (_renderQueue.length === 1) {
    gsap.ticker.add(_renderQueueTick);
  }
},
    _renderQueueTimeout = function _renderQueueTimeout() {
  return !_renderQueue.length && gsap.ticker.remove(_renderQueueTick);
},
    _removeFromRenderQueue = function _removeFromRenderQueue(func) {
  var i = _renderQueue.length;

  while (i--) {
    if (_renderQueue[i] === func) {
      _renderQueue.splice(i, 1);
    }
  }

  gsap.to(_renderQueueTimeout, {
    overwrite: true,
    delay: 15,
    duration: 0,
    onComplete: _renderQueueTimeout,
    data: "_draggable"
  }); //remove the "tick" listener only after the render queue is empty for 15 seconds (to improve performance). Adding/removing it constantly for every click/touch wouldn't deliver optimal speed, and we also don't want the ticker to keep calling the render method when things are idle for long periods of time (we want to improve battery life on mobile devices).
},
    _setDefaults = function _setDefaults(obj, defaults) {
  for (var p in defaults) {
    if (!(p in obj)) {
      obj[p] = defaults[p];
    }
  }

  return obj;
},
    _addListener = function _addListener(element, type, func, capture) {
  if (element.addEventListener) {
    var touchType = _touchEventLookup[type];
    capture = capture || (_supportsPassive ? {
      passive: false
    } : null);
    element.addEventListener(touchType || type, func, capture);
    touchType && type !== touchType && element.addEventListener(type, func, capture); //some browsers actually support both, so must we. But pointer events cover all.
  }
},
    _removeListener = function _removeListener(element, type, func) {
  if (element.removeEventListener) {
    var touchType = _touchEventLookup[type];
    element.removeEventListener(touchType || type, func);
    touchType && type !== touchType && element.removeEventListener(type, func);
  }
},
    _preventDefault = function _preventDefault(event) {
  event.preventDefault && event.preventDefault();
  event.preventManipulation && event.preventManipulation(); //for some Microsoft browsers
},
    _hasTouchID = function _hasTouchID(list, ID) {
  var i = list.length;

  while (i--) {
    if (list[i].identifier === ID) {
      return true;
    }
  }
},
    _onMultiTouchDocumentEnd = function _onMultiTouchDocumentEnd(event) {
  _isMultiTouching = event.touches && _dragCount < event.touches.length;

  _removeListener(event.target, "touchend", _onMultiTouchDocumentEnd);
},
    _onMultiTouchDocument = function _onMultiTouchDocument(event) {
  _isMultiTouching = event.touches && _dragCount < event.touches.length;

  _addListener(event.target, "touchend", _onMultiTouchDocumentEnd);
},
    _getDocScrollTop = function _getDocScrollTop(doc) {
  return _win.pageYOffset || doc.scrollTop || doc.documentElement.scrollTop || doc.body.scrollTop || 0;
},
    _getDocScrollLeft = function _getDocScrollLeft(doc) {
  return _win.pageXOffset || doc.scrollLeft || doc.documentElement.scrollLeft || doc.body.scrollLeft || 0;
},
    _addScrollListener = function _addScrollListener(e, callback) {
  _addListener(e, "scroll", callback);

  if (!_isRoot(e.parentNode)) {
    _addScrollListener(e.parentNode, callback);
  }
},
    _removeScrollListener = function _removeScrollListener(e, callback) {
  _removeListener(e, "scroll", callback);

  if (!_isRoot(e.parentNode)) {
    _removeScrollListener(e.parentNode, callback);
  }
},
    _isRoot = function _isRoot(e) {
  return !!(!e || e === _docElement || e.nodeType === 9 || e === _doc.body || e === _win || !e.nodeType || !e.parentNode);
},
    _getMaxScroll = function _getMaxScroll(element, axis) {
  var dim = axis === "x" ? "Width" : "Height",
      scroll = "scroll" + dim,
      client = "client" + dim;
  return Math.max(0, _isRoot(element) ? Math.max(_docElement[scroll], _body[scroll]) - (_win["inner" + dim] || _docElement[client] || _body[client]) : element[scroll] - element[client]);
},
    _recordMaxScrolls = function _recordMaxScrolls(e, skipCurrent) {
  //records _gsMaxScrollX and _gsMaxScrollY properties for the element and all ancestors up the chain so that we can cap it, otherwise dragging beyond the edges with autoScroll on can endlessly scroll.
  var x = _getMaxScroll(e, "x"),
      y = _getMaxScroll(e, "y");

  if (_isRoot(e)) {
    e = _windowProxy;
  } else {
    _recordMaxScrolls(e.parentNode, skipCurrent);
  }

  e._gsMaxScrollX = x;
  e._gsMaxScrollY = y;

  if (!skipCurrent) {
    e._gsScrollX = e.scrollLeft || 0;
    e._gsScrollY = e.scrollTop || 0;
  }
},
    _setStyle = function _setStyle(element, property, value) {
  var style = element.style;

  if (!style) {
    return;
  }

  if (_isUndefined(style[property])) {
    property = _checkPrefix(property, element) || property;
  }

  if (value == null) {
    style.removeProperty && style.removeProperty(property.replace(/([A-Z])/g, "-$1").toLowerCase());
  } else {
    style[property] = value;
  }
},
    _getComputedStyle = function _getComputedStyle(element) {
  return _win.getComputedStyle(element instanceof Element ? element : element.host || (element.parentNode || {}).host || element);
},
    //the "host" stuff helps to accommodate ShadowDom objects.
_tempRect = {},
    //reuse to reduce garbage collection tasks
_parseRect = function _parseRect(e) {
  //accepts a DOM element, a mouse event, or a rectangle object and returns the corresponding rectangle with left, right, width, height, top, and bottom properties
  if (e === _win) {
    _tempRect.left = _tempRect.top = 0;
    _tempRect.width = _tempRect.right = _docElement.clientWidth || e.innerWidth || _body.clientWidth || 0;
    _tempRect.height = _tempRect.bottom = (e.innerHeight || 0) - 20 < _docElement.clientHeight ? _docElement.clientHeight : e.innerHeight || _body.clientHeight || 0;
    return _tempRect;
  }

  var doc = e.ownerDocument || _doc,
      r = !_isUndefined(e.pageX) ? {
    left: e.pageX - _getDocScrollLeft(doc),
    top: e.pageY - _getDocScrollTop(doc),
    right: e.pageX - _getDocScrollLeft(doc) + 1,
    bottom: e.pageY - _getDocScrollTop(doc) + 1
  } : !e.nodeType && !_isUndefined(e.left) && !_isUndefined(e.top) ? e : _toArray(e)[0].getBoundingClientRect();

  if (_isUndefined(r.right) && !_isUndefined(r.width)) {
    r.right = r.left + r.width;
    r.bottom = r.top + r.height;
  } else if (_isUndefined(r.width)) {
    //some browsers don't include width and height properties. We can't just set them directly on r because some browsers throw errors, so create a new generic object.
    r = {
      width: r.right - r.left,
      height: r.bottom - r.top,
      right: r.right,
      left: r.left,
      bottom: r.bottom,
      top: r.top
    };
  }

  return r;
},
    _dispatchEvent = function _dispatchEvent(target, type, callbackName) {
  var vars = target.vars,
      callback = vars[callbackName],
      listeners = target._listeners[type],
      result;

  if (_isFunction(callback)) {
    result = callback.apply(vars.callbackScope || target, vars[callbackName + "Params"] || [target.pointerEvent]);
  }

  if (listeners && target.dispatchEvent(type) === false) {
    result = false;
  }

  return result;
},
    _getBounds = function _getBounds(target, context) {
  //accepts any of the following: a DOM element, jQuery object, selector text, or an object defining bounds as {top, left, width, height} or {minX, maxX, minY, maxY}. Returns an object with left, top, width, and height properties.
  var e = _toArray(target)[0],
      top,
      left,
      offset;

  if (!e.nodeType && e !== _win) {
    if (!_isUndefined(target.left)) {
      offset = {
        x: 0,
        y: 0
      }; //_getOffsetTransformOrigin(context); //the bounds should be relative to the origin

      return {
        left: target.left - offset.x,
        top: target.top - offset.y,
        width: target.width,
        height: target.height
      };
    }

    left = target.min || target.minX || target.minRotation || 0;
    top = target.min || target.minY || 0;
    return {
      left: left,
      top: top,
      width: (target.max || target.maxX || target.maxRotation || 0) - left,
      height: (target.max || target.maxY || 0) - top
    };
  }

  return _getElementBounds(e, context);
},
    _point1 = {},
    //we reuse to minimize garbage collection tasks.
_getElementBounds = function _getElementBounds(element, context) {
  context = _toArray(context)[0];
  var isSVG = element.getBBox && element.ownerSVGElement,
      doc = element.ownerDocument || _doc,
      left,
      right,
      top,
      bottom,
      matrix,
      p1,
      p2,
      p3,
      p4,
      bbox,
      width,
      height,
      cs,
      contextParent;

  if (element === _win) {
    top = _getDocScrollTop(doc);
    left = _getDocScrollLeft(doc);
    right = left + (doc.documentElement.clientWidth || element.innerWidth || doc.body.clientWidth || 0);
    bottom = top + ((element.innerHeight || 0) - 20 < doc.documentElement.clientHeight ? doc.documentElement.clientHeight : element.innerHeight || doc.body.clientHeight || 0); //some browsers (like Firefox) ignore absolutely positioned elements, and collapse the height of the documentElement, so it could be 8px, for example, if you have just an absolutely positioned div. In that case, we use the innerHeight to resolve this.
  } else if (context === _win || _isUndefined(context)) {
    return element.getBoundingClientRect();
  } else {
    left = top = 0;

    if (isSVG) {
      bbox = element.getBBox();
      width = bbox.width;
      height = bbox.height;
    } else {
      if (element.viewBox && (bbox = element.viewBox.baseVal)) {
        left = bbox.x || 0;
        top = bbox.y || 0;
        width = bbox.width;
        height = bbox.height;
      }

      if (!width) {
        cs = _getComputedStyle(element);
        bbox = cs.boxSizing === "border-box";
        width = (parseFloat(cs.width) || element.clientWidth || 0) + (bbox ? 0 : parseFloat(cs.borderLeftWidth) + parseFloat(cs.borderRightWidth));
        height = (parseFloat(cs.height) || element.clientHeight || 0) + (bbox ? 0 : parseFloat(cs.borderTopWidth) + parseFloat(cs.borderBottomWidth));
      }
    }

    right = width;
    bottom = height;
  }

  if (element === context) {
    return {
      left: left,
      top: top,
      width: right - left,
      height: bottom - top
    };
  }

  matrix = (0,_utils_matrix_js__WEBPACK_IMPORTED_MODULE_0__/* .getGlobalMatrix */ .M9)(context, true).multiply((0,_utils_matrix_js__WEBPACK_IMPORTED_MODULE_0__/* .getGlobalMatrix */ .M9)(element));
  p1 = matrix.apply({
    x: left,
    y: top
  });
  p2 = matrix.apply({
    x: right,
    y: top
  });
  p3 = matrix.apply({
    x: right,
    y: bottom
  });
  p4 = matrix.apply({
    x: left,
    y: bottom
  });
  left = Math.min(p1.x, p2.x, p3.x, p4.x);
  top = Math.min(p1.y, p2.y, p3.y, p4.y);
  contextParent = context.parentNode || {};
  return {
    left: left + (contextParent.scrollLeft || 0),
    top: top + (contextParent.scrollTop || 0),
    width: Math.max(p1.x, p2.x, p3.x, p4.x) - left,
    height: Math.max(p1.y, p2.y, p3.y, p4.y) - top
  };
},
    _parseInertia = function _parseInertia(draggable, snap, max, min, factor, forceZeroVelocity) {
  var vars = {},
      a,
      i,
      l;

  if (snap) {
    if (factor !== 1 && snap instanceof Array) {
      //some data must be altered to make sense, like if the user passes in an array of rotational values in degrees, we must convert it to radians. Or for scrollLeft and scrollTop, we invert the values.
      vars.end = a = [];
      l = snap.length;

      if (_isObject(snap[0])) {
        //if the array is populated with objects, like points ({x:100, y:200}), make copies before multiplying by the factor, otherwise we'll mess up the originals and the user may reuse it elsewhere.
        for (i = 0; i < l; i++) {
          a[i] = _copy(snap[i], factor);
        }
      } else {
        for (i = 0; i < l; i++) {
          a[i] = snap[i] * factor;
        }
      }

      max += 1.1; //allow 1.1 pixels of wiggle room when snapping in order to work around some browser inconsistencies in the way bounds are reported which can make them roughly a pixel off. For example, if "snap:[-$('#menu').width(), 0]" was defined and #menu had a wrapper that was used as the bounds, some browsers would be one pixel off, making the minimum -752 for example when snap was [-753,0], thus instead of snapping to -753, it would snap to 0 since -753 was below the minimum.

      min -= 1.1;
    } else if (_isFunction(snap)) {
      vars.end = function (value) {
        var result = snap.call(draggable, value),
            copy,
            p;

        if (factor !== 1) {
          if (_isObject(result)) {
            copy = {};

            for (p in result) {
              copy[p] = result[p] * factor;
            }

            result = copy;
          } else {
            result *= factor;
          }
        }

        return result; //we need to ensure that we can scope the function call to the Draggable instance itself so that users can access important values like maxX, minX, maxY, minY, x, and y from within that function.
      };
    } else {
      vars.end = snap;
    }
  }

  if (max || max === 0) {
    vars.max = max;
  }

  if (min || min === 0) {
    vars.min = min;
  }

  if (forceZeroVelocity) {
    vars.velocity = 0;
  }

  return vars;
},
    _isClickable = function _isClickable(element) {
  //sometimes it's convenient to mark an element as clickable by adding a data-clickable="true" attribute (in which case we won't preventDefault() the mouse/touch event). This method checks if the element is an <a>, <input>, or <button> or has an onclick or has the data-clickable or contentEditable attribute set to true (or any of its parent elements).
  var data;
  return !element || !element.getAttribute || element === _body ? false : (data = element.getAttribute("data-clickable")) === "true" || data !== "false" && (element.onclick || _clickableTagExp.test(element.nodeName + "") || element.getAttribute("contentEditable") === "true") ? true : _isClickable(element.parentNode);
},
    _setSelectable = function _setSelectable(elements, selectable) {
  var i = elements.length,
      e;

  while (i--) {
    e = elements[i];
    e.ondragstart = e.onselectstart = selectable ? null : _emptyFunc;
    gsap.set(e, {
      lazy: true,
      userSelect: selectable ? "text" : "none"
    });
  }
},
    _isFixed = function _isFixed(element) {
  if (_getComputedStyle(element).position === "fixed") {
    return true;
  }

  element = element.parentNode;

  if (element && element.nodeType === 1) {
    // avoid document fragments which will throw an error.
    return _isFixed(element);
  }
},
    _supports3D,
    _addPaddingBR,
    //The ScrollProxy class wraps an element's contents into another div (we call it "content") that we either add padding when necessary or apply a translate3d() transform in order to overscroll (scroll past the boundaries). This allows us to simply set the scrollTop/scrollLeft (or top/left for easier reverse-axis orientation, which is what we do in Draggable) and it'll do all the work for us. For example, if we tried setting scrollTop to -100 on a normal DOM element, it wouldn't work - it'd look the same as setting it to 0, but if we set scrollTop of a ScrollProxy to -100, it'll give the correct appearance by either setting paddingTop of the wrapper to 100 or applying a 100-pixel translateY.
ScrollProxy = function ScrollProxy(element, vars) {
  element = gsap.utils.toArray(element)[0];
  vars = vars || {};
  var content = document.createElement("div"),
      style = content.style,
      node = element.firstChild,
      offsetTop = 0,
      offsetLeft = 0,
      prevTop = element.scrollTop,
      prevLeft = element.scrollLeft,
      scrollWidth = element.scrollWidth,
      scrollHeight = element.scrollHeight,
      extraPadRight = 0,
      maxLeft = 0,
      maxTop = 0,
      elementWidth,
      elementHeight,
      contentHeight,
      nextNode,
      transformStart,
      transformEnd;

  if (_supports3D && vars.force3D !== false) {
    transformStart = "translate3d(";
    transformEnd = "px,0px)";
  } else if (_transformProp) {
    transformStart = "translate(";
    transformEnd = "px)";
  }

  this.scrollTop = function (value, force) {
    if (!arguments.length) {
      return -this.top();
    }

    this.top(-value, force);
  };

  this.scrollLeft = function (value, force) {
    if (!arguments.length) {
      return -this.left();
    }

    this.left(-value, force);
  };

  this.left = function (value, force) {
    if (!arguments.length) {
      return -(element.scrollLeft + offsetLeft);
    }

    var dif = element.scrollLeft - prevLeft,
        oldOffset = offsetLeft;

    if ((dif > 2 || dif < -2) && !force) {
      //if the user interacts with the scrollbar (or something else scrolls it, like the mouse wheel), we should kill any tweens of the ScrollProxy.
      prevLeft = element.scrollLeft;
      gsap.killTweensOf(this, {
        left: 1,
        scrollLeft: 1
      });
      this.left(-prevLeft);

      if (vars.onKill) {
        vars.onKill();
      }

      return;
    }

    value = -value; //invert because scrolling works in the opposite direction

    if (value < 0) {
      offsetLeft = value - 0.5 | 0;
      value = 0;
    } else if (value > maxLeft) {
      offsetLeft = value - maxLeft | 0;
      value = maxLeft;
    } else {
      offsetLeft = 0;
    }

    if (offsetLeft || oldOffset) {
      if (!this._skip) {
        style[_transformProp] = transformStart + -offsetLeft + "px," + -offsetTop + transformEnd;
      }

      if (offsetLeft + extraPadRight >= 0) {
        style.paddingRight = offsetLeft + extraPadRight + "px";
      }
    }

    element.scrollLeft = value | 0;
    prevLeft = element.scrollLeft; //don't merge this with the line above because some browsers adjust the scrollLeft after it's set, so in order to be 100% accurate in tracking it, we need to ask the browser to report it.
  };

  this.top = function (value, force) {
    if (!arguments.length) {
      return -(element.scrollTop + offsetTop);
    }

    var dif = element.scrollTop - prevTop,
        oldOffset = offsetTop;

    if ((dif > 2 || dif < -2) && !force) {
      //if the user interacts with the scrollbar (or something else scrolls it, like the mouse wheel), we should kill any tweens of the ScrollProxy.
      prevTop = element.scrollTop;
      gsap.killTweensOf(this, {
        top: 1,
        scrollTop: 1
      });
      this.top(-prevTop);

      if (vars.onKill) {
        vars.onKill();
      }

      return;
    }

    value = -value; //invert because scrolling works in the opposite direction

    if (value < 0) {
      offsetTop = value - 0.5 | 0;
      value = 0;
    } else if (value > maxTop) {
      offsetTop = value - maxTop | 0;
      value = maxTop;
    } else {
      offsetTop = 0;
    }

    if (offsetTop || oldOffset) {
      if (!this._skip) {
        style[_transformProp] = transformStart + -offsetLeft + "px," + -offsetTop + transformEnd;
      }
    }

    element.scrollTop = value | 0;
    prevTop = element.scrollTop;
  };

  this.maxScrollTop = function () {
    return maxTop;
  };

  this.maxScrollLeft = function () {
    return maxLeft;
  };

  this.disable = function () {
    node = content.firstChild;

    while (node) {
      nextNode = node.nextSibling;
      element.appendChild(node);
      node = nextNode;
    }

    if (element === content.parentNode) {
      //in case disable() is called when it's already disabled.
      element.removeChild(content);
    }
  };

  this.enable = function () {
    node = element.firstChild;

    if (node === content) {
      return;
    }

    while (node) {
      nextNode = node.nextSibling;
      content.appendChild(node);
      node = nextNode;
    }

    element.appendChild(content);
    this.calibrate();
  };

  this.calibrate = function (force) {
    var widthMatches = element.clientWidth === elementWidth,
        cs,
        x,
        y;
    prevTop = element.scrollTop;
    prevLeft = element.scrollLeft;

    if (widthMatches && element.clientHeight === elementHeight && content.offsetHeight === contentHeight && scrollWidth === element.scrollWidth && scrollHeight === element.scrollHeight && !force) {
      return; //no need to recalculate things if the width and height haven't changed.
    }

    if (offsetTop || offsetLeft) {
      x = this.left();
      y = this.top();
      this.left(-element.scrollLeft);
      this.top(-element.scrollTop);
    }

    cs = _getComputedStyle(element); //first, we need to remove any width constraints to see how the content naturally flows so that we can see if it's wider than the containing element. If so, we've got to record the amount of overage so that we can apply that as padding in order for browsers to correctly handle things. Then we switch back to a width of 100% (without that, some browsers don't flow the content correctly)

    if (!widthMatches || force) {
      style.display = "block";
      style.width = "auto";
      style.paddingRight = "0px";
      extraPadRight = Math.max(0, element.scrollWidth - element.clientWidth); //if the content is wider than the container, we need to add the paddingLeft and paddingRight in order for things to behave correctly.

      if (extraPadRight) {
        extraPadRight += parseFloat(cs.paddingLeft) + (_addPaddingBR ? parseFloat(cs.paddingRight) : 0);
      }
    }

    style.display = "inline-block";
    style.position = "relative";
    style.overflow = "visible";
    style.verticalAlign = "top";
    style.boxSizing = "content-box";
    style.width = "100%";
    style.paddingRight = extraPadRight + "px"; //some browsers neglect to factor in the bottom padding when calculating the scrollHeight, so we need to add that padding to the content when that happens. Allow a 2px margin for error

    if (_addPaddingBR) {
      style.paddingBottom = cs.paddingBottom;
    }

    elementWidth = element.clientWidth;
    elementHeight = element.clientHeight;
    scrollWidth = element.scrollWidth;
    scrollHeight = element.scrollHeight;
    maxLeft = element.scrollWidth - elementWidth;
    maxTop = element.scrollHeight - elementHeight;
    contentHeight = content.offsetHeight;
    style.display = "block";

    if (x || y) {
      this.left(x);
      this.top(y);
    }
  };

  this.content = content;
  this.element = element;
  this._skip = false;
  this.enable();
},
    _initCore = function _initCore(required) {
  if (_windowExists() && document.body) {
    var nav = window && window.navigator;
    _win = window;
    _doc = document;
    _docElement = _doc.documentElement;
    _body = _doc.body;
    _tempDiv = _createElement("div");
    _supportsPointer = !!window.PointerEvent;
    _placeholderDiv = _createElement("div");
    _placeholderDiv.style.cssText = "visibility:hidden;height:1px;top:-1px;pointer-events:none;position:relative;clear:both;cursor:grab";
    _defaultCursor = _placeholderDiv.style.cursor === "grab" ? "grab" : "move";
    _isAndroid = nav && nav.userAgent.toLowerCase().indexOf("android") !== -1; //Android handles touch events in an odd way and it's virtually impossible to "feature test" so we resort to UA sniffing

    _isTouchDevice = "ontouchstart" in _docElement && "orientation" in _win || nav && (nav.MaxTouchPoints > 0 || nav.msMaxTouchPoints > 0);

    _addPaddingBR = function () {
      //this function is in charge of analyzing browser behavior related to padding. It sets the _addPaddingBR to true if the browser doesn't normally factor in the bottom or right padding on the element inside the scrolling area, and it sets _addPaddingLeft to true if it's a browser that requires the extra offset (offsetLeft) to be added to the paddingRight (like Opera).
      var div = _createElement("div"),
          child = _createElement("div"),
          childStyle = child.style,
          parent = _body,
          val;

      childStyle.display = "inline-block";
      childStyle.position = "relative";
      div.style.cssText = child.innerHTML = "width:90px;height:40px;padding:10px;overflow:auto;visibility:hidden";
      div.appendChild(child);
      parent.appendChild(div);
      val = child.offsetHeight + 18 > div.scrollHeight; //div.scrollHeight should be child.offsetHeight + 20 because of the 10px of padding on each side, but some browsers ignore one side. We allow a 2px margin of error.

      parent.removeChild(div);
      return val;
    }();

    _touchEventLookup = function (types) {
      //we create an object that makes it easy to translate touch event types into their "pointer" counterparts if we're in a browser that uses those instead. Like IE10 uses "MSPointerDown" instead of "touchstart", for example.
      var standard = types.split(","),
          converted = ("onpointerdown" in _tempDiv ? "pointerdown,pointermove,pointerup,pointercancel" : "onmspointerdown" in _tempDiv ? "MSPointerDown,MSPointerMove,MSPointerUp,MSPointerCancel" : types).split(","),
          obj = {},
          i = 4;

      while (--i > -1) {
        obj[standard[i]] = converted[i];
        obj[converted[i]] = standard[i];
      } //to avoid problems in iOS 9, test to see if the browser supports the "passive" option on addEventListener().


      try {
        _docElement.addEventListener("test", null, Object.defineProperty({}, "passive", {
          get: function get() {
            _supportsPassive = 1;
          }
        }));
      } catch (e) {}

      return obj;
    }("touchstart,touchmove,touchend,touchcancel");

    _addListener(_doc, "touchcancel", _emptyFunc); //some older Android devices intermittently stop dispatching "touchmove" events if we don't listen for "touchcancel" on the document. Very strange indeed.


    _addListener(_win, "touchmove", _emptyFunc); //works around Safari bugs that still allow the page to scroll even when we preventDefault() on the touchmove event.


    _body && _body.addEventListener("touchstart", _emptyFunc); //works around Safari bug: https://greensock.com/forums/topic/21450-draggable-in-iframe-on-mobile-is-buggy/

    _addListener(_doc, "contextmenu", function () {
      for (var p in _lookup) {
        if (_lookup[p].isPressed) {
          _lookup[p].endDrag();
        }
      }
    });

    gsap = _coreInitted = _getGSAP();
  }

  if (gsap) {
    InertiaPlugin = gsap.plugins.inertia;
    _checkPrefix = gsap.utils.checkPrefix;
    _transformProp = _checkPrefix(_transformProp);
    _transformOriginProp = _checkPrefix(_transformOriginProp);
    _toArray = gsap.utils.toArray;
    _supports3D = !!_checkPrefix("perspective");
  } else if (required) {
    console.warn("Please gsap.registerPlugin(Draggable)");
  }
};

var EventDispatcher = /*#__PURE__*/function () {
  function EventDispatcher(target) {
    this._listeners = {};
    this.target = target || this;
  }

  var _proto = EventDispatcher.prototype;

  _proto.addEventListener = function addEventListener(type, callback) {
    var list = this._listeners[type] || (this._listeners[type] = []);

    if (!~list.indexOf(callback)) {
      list.push(callback);
    }
  };

  _proto.removeEventListener = function removeEventListener(type, callback) {
    var list = this._listeners[type],
        i = list && list.indexOf(callback) || -1;
    i > -1 && list.splice(i, 1);
  };

  _proto.dispatchEvent = function dispatchEvent(type) {
    var _this = this;

    var result;
    (this._listeners[type] || []).forEach(function (callback) {
      return callback.call(_this, {
        type: type,
        target: _this.target
      }) === false && (result = false);
    });
    return result; //if any of the callbacks return false, pass that along.
  };

  return EventDispatcher;
}();

var Draggable = /*#__PURE__*/function (_EventDispatcher) {
  _inheritsLoose(Draggable, _EventDispatcher);

  function Draggable(target, vars) {
    var _this2;

    _this2 = _EventDispatcher.call(this) || this;
    _coreInitted || _initCore(1);
    target = _toArray(target)[0]; //in case the target is a selector object or selector text

    if (!InertiaPlugin) {
      InertiaPlugin = gsap.plugins.inertia;
    }

    _this2.vars = vars = _copy(vars || {});
    _this2.target = target;
    _this2.x = _this2.y = _this2.rotation = 0;
    _this2.dragResistance = parseFloat(vars.dragResistance) || 0;
    _this2.edgeResistance = isNaN(vars.edgeResistance) ? 1 : parseFloat(vars.edgeResistance) || 0;
    _this2.lockAxis = vars.lockAxis;
    _this2.autoScroll = vars.autoScroll || 0;
    _this2.lockedAxis = null;
    _this2.allowEventDefault = !!vars.allowEventDefault;
    gsap.getProperty(target, "x"); // to ensure that transforms are instantiated.

    var type = (vars.type || "x,y").toLowerCase(),
        xyMode = ~type.indexOf("x") || ~type.indexOf("y"),
        rotationMode = type.indexOf("rotation") !== -1,
        xProp = rotationMode ? "rotation" : xyMode ? "x" : "left",
        yProp = xyMode ? "y" : "top",
        allowX = !!(~type.indexOf("x") || ~type.indexOf("left") || type === "scroll"),
        allowY = !!(~type.indexOf("y") || ~type.indexOf("top") || type === "scroll"),
        minimumMovement = vars.minimumMovement || 2,
        self = _assertThisInitialized(_this2),
        triggers = _toArray(vars.trigger || vars.handle || target),
        killProps = {},
        dragEndTime = 0,
        checkAutoScrollBounds = false,
        autoScrollMarginTop = vars.autoScrollMarginTop || 40,
        autoScrollMarginRight = vars.autoScrollMarginRight || 40,
        autoScrollMarginBottom = vars.autoScrollMarginBottom || 40,
        autoScrollMarginLeft = vars.autoScrollMarginLeft || 40,
        isClickable = vars.clickableTest || _isClickable,
        clickTime = 0,
        gsCache = target._gsap || gsap.core.getCache(target),
        isFixed = _isFixed(target),
        getPropAsNum = function getPropAsNum(property, unit) {
      return parseFloat(gsCache.get(target, property, unit));
    },
        ownerDoc = target.ownerDocument || _doc,
        enabled,
        scrollProxy,
        startPointerX,
        startPointerY,
        startElementX,
        startElementY,
        hasBounds,
        hasDragCallback,
        hasMoveCallback,
        maxX,
        minX,
        maxY,
        minY,
        touch,
        touchID,
        rotationOrigin,
        dirty,
        old,
        snapX,
        snapY,
        snapXY,
        isClicking,
        touchEventTarget,
        matrix,
        interrupted,
        allowNativeTouchScrolling,
        touchDragAxis,
        isDispatching,
        clickDispatch,
        trustedClickDispatch,
        isPreventingDefault,
        innerMatrix,
        onContextMenu = function onContextMenu(e) {
      //used to prevent long-touch from triggering a context menu.
      // (self.isPressed && e.which < 2) && self.endDrag() // previously ended drag when context menu was triggered, but instead we should just stop propagation and prevent the default event behavior.
      _preventDefault(e);

      e.stopImmediatePropagation && e.stopImmediatePropagation();
      return false;
    },
        //this method gets called on every tick of TweenLite.ticker which allows us to synchronize the renders to the core engine (which is typically synchronized with the display refresh via requestAnimationFrame). This is an optimization - it's better than applying the values inside the "mousemove" or "touchmove" event handler which may get called many times inbetween refreshes.
    render = function render(suppressEvents) {
      if (self.autoScroll && self.isDragging && (checkAutoScrollBounds || dirty)) {
        var e = target,
            autoScrollFactor = self.autoScroll * 15,
            //multiplying by 15 just gives us a better "feel" speed-wise.
        parent,
            isRoot,
            rect,
            pointerX,
            pointerY,
            changeX,
            changeY,
            gap;
        checkAutoScrollBounds = false;
        _windowProxy.scrollTop = _win.pageYOffset != null ? _win.pageYOffset : ownerDoc.documentElement.scrollTop != null ? ownerDoc.documentElement.scrollTop : ownerDoc.body.scrollTop;
        _windowProxy.scrollLeft = _win.pageXOffset != null ? _win.pageXOffset : ownerDoc.documentElement.scrollLeft != null ? ownerDoc.documentElement.scrollLeft : ownerDoc.body.scrollLeft;
        pointerX = self.pointerX - _windowProxy.scrollLeft;
        pointerY = self.pointerY - _windowProxy.scrollTop;

        while (e && !isRoot) {
          //walk up the chain and sense wherever the pointer is within 40px of an edge that's scrollable.
          isRoot = _isRoot(e.parentNode);
          parent = isRoot ? _windowProxy : e.parentNode;
          rect = isRoot ? {
            bottom: Math.max(_docElement.clientHeight, _win.innerHeight || 0),
            right: Math.max(_docElement.clientWidth, _win.innerWidth || 0),
            left: 0,
            top: 0
          } : parent.getBoundingClientRect();
          changeX = changeY = 0;

          if (allowY) {
            gap = parent._gsMaxScrollY - parent.scrollTop;

            if (gap < 0) {
              changeY = gap;
            } else if (pointerY > rect.bottom - autoScrollMarginBottom && gap) {
              checkAutoScrollBounds = true;
              changeY = Math.min(gap, autoScrollFactor * (1 - Math.max(0, rect.bottom - pointerY) / autoScrollMarginBottom) | 0);
            } else if (pointerY < rect.top + autoScrollMarginTop && parent.scrollTop) {
              checkAutoScrollBounds = true;
              changeY = -Math.min(parent.scrollTop, autoScrollFactor * (1 - Math.max(0, pointerY - rect.top) / autoScrollMarginTop) | 0);
            }

            if (changeY) {
              parent.scrollTop += changeY;
            }
          }

          if (allowX) {
            gap = parent._gsMaxScrollX - parent.scrollLeft;

            if (gap < 0) {
              changeX = gap;
            } else if (pointerX > rect.right - autoScrollMarginRight && gap) {
              checkAutoScrollBounds = true;
              changeX = Math.min(gap, autoScrollFactor * (1 - Math.max(0, rect.right - pointerX) / autoScrollMarginRight) | 0);
            } else if (pointerX < rect.left + autoScrollMarginLeft && parent.scrollLeft) {
              checkAutoScrollBounds = true;
              changeX = -Math.min(parent.scrollLeft, autoScrollFactor * (1 - Math.max(0, pointerX - rect.left) / autoScrollMarginLeft) | 0);
            }

            if (changeX) {
              parent.scrollLeft += changeX;
            }
          }

          if (isRoot && (changeX || changeY)) {
            _win.scrollTo(parent.scrollLeft, parent.scrollTop);

            setPointerPosition(self.pointerX + changeX, self.pointerY + changeY);
          }

          e = parent;
        }
      }

      if (dirty) {
        var x = self.x,
            y = self.y;

        if (rotationMode) {
          self.deltaX = x - parseFloat(gsCache.rotation);
          self.rotation = x;
          gsCache.rotation = x + "deg";
          gsCache.renderTransform(1, gsCache);
        } else {
          if (scrollProxy) {
            if (allowY) {
              self.deltaY = y - scrollProxy.top();
              scrollProxy.top(y);
            }

            if (allowX) {
              self.deltaX = x - scrollProxy.left();
              scrollProxy.left(x);
            }
          } else if (xyMode) {
            if (allowY) {
              self.deltaY = y - parseFloat(gsCache.y);
              gsCache.y = y + "px";
            }

            if (allowX) {
              self.deltaX = x - parseFloat(gsCache.x);
              gsCache.x = x + "px";
            }

            gsCache.renderTransform(1, gsCache);
          } else {
            if (allowY) {
              self.deltaY = y - parseFloat(target.style.top || 0);
              target.style.top = y + "px";
            }

            if (allowX) {
              self.deltaX = x - parseFloat(target.style.left || 0);
              target.style.left = x + "px";
            }
          }
        }

        if (hasDragCallback && !suppressEvents && !isDispatching) {
          isDispatching = true; //in case onDrag has an update() call (avoid endless loop)

          if (_dispatchEvent(self, "drag", "onDrag") === false) {
            if (allowX) {
              self.x -= self.deltaX;
            }

            if (allowY) {
              self.y -= self.deltaY;
            }

            render(true);
          }

          isDispatching = false;
        }
      }

      dirty = false;
    },
        //copies the x/y from the element (whether that be transforms, top/left, or ScrollProxy's top/left) to the Draggable's x and y (and rotation if necessary) properties so that they reflect reality and it also (optionally) applies any snapping necessary. This is used by the InertiaPlugin tween in an onUpdate to ensure things are synced and snapped.
    syncXY = function syncXY(skipOnUpdate, skipSnap) {
      var x = self.x,
          y = self.y,
          snappedValue,
          cs;

      if (!target._gsap) {
        //just in case the _gsap cache got wiped, like if the user called clearProps on the transform or something (very rare).
        gsCache = gsap.core.getCache(target);
      }

      gsCache.uncache && gsap.getProperty(target, "x"); // trigger a re-cache

      if (xyMode) {
        self.x = parseFloat(gsCache.x);
        self.y = parseFloat(gsCache.y);
      } else if (rotationMode) {
        self.x = self.rotation = parseFloat(gsCache.rotation);
      } else if (scrollProxy) {
        self.y = scrollProxy.top();
        self.x = scrollProxy.left();
      } else {
        self.y = parseFloat(target.style.top || (cs = _getComputedStyle(target)) && cs.top) || 0;
        self.x = parseFloat(target.style.left || (cs || {}).left) || 0;
      }

      if ((snapX || snapY || snapXY) && !skipSnap && (self.isDragging || self.isThrowing)) {
        if (snapXY) {
          _temp1.x = self.x;
          _temp1.y = self.y;
          snappedValue = snapXY(_temp1);

          if (snappedValue.x !== self.x) {
            self.x = snappedValue.x;
            dirty = true;
          }

          if (snappedValue.y !== self.y) {
            self.y = snappedValue.y;
            dirty = true;
          }
        }

        if (snapX) {
          snappedValue = snapX(self.x);

          if (snappedValue !== self.x) {
            self.x = snappedValue;

            if (rotationMode) {
              self.rotation = snappedValue;
            }

            dirty = true;
          }
        }

        if (snapY) {
          snappedValue = snapY(self.y);

          if (snappedValue !== self.y) {
            self.y = snappedValue;
          }

          dirty = true;
        }
      }

      dirty && render(true);

      if (!skipOnUpdate) {
        self.deltaX = self.x - x;
        self.deltaY = self.y - y;

        _dispatchEvent(self, "throwupdate", "onThrowUpdate");
      }
    },
        buildSnapFunc = function buildSnapFunc(snap, min, max, factor) {
      if (min == null) {
        min = -_bigNum;
      }

      if (max == null) {
        max = _bigNum;
      }

      if (_isFunction(snap)) {
        return function (n) {
          var edgeTolerance = !self.isPressed ? 1 : 1 - self.edgeResistance; //if we're tweening, disable the edgeTolerance because it's already factored into the tweening values (we don't want to apply it multiple times)

          return snap.call(self, n > max ? max + (n - max) * edgeTolerance : n < min ? min + (n - min) * edgeTolerance : n) * factor;
        };
      }

      if (_isArray(snap)) {
        return function (n) {
          var i = snap.length,
              closest = 0,
              absDif = _bigNum,
              val,
              dif;

          while (--i > -1) {
            val = snap[i];
            dif = val - n;

            if (dif < 0) {
              dif = -dif;
            }

            if (dif < absDif && val >= min && val <= max) {
              closest = i;
              absDif = dif;
            }
          }

          return snap[closest];
        };
      }

      return isNaN(snap) ? function (n) {
        return n;
      } : function () {
        return snap * factor;
      };
    },
        buildPointSnapFunc = function buildPointSnapFunc(snap, minX, maxX, minY, maxY, radius, factor) {
      radius = radius && radius < _bigNum ? radius * radius : _bigNum; //so we don't have to Math.sqrt() in the functions. Performance optimization.

      if (_isFunction(snap)) {
        return function (point) {
          var edgeTolerance = !self.isPressed ? 1 : 1 - self.edgeResistance,
              x = point.x,
              y = point.y,
              result,
              dx,
              dy; //if we're tweening, disable the edgeTolerance because it's already factored into the tweening values (we don't want to apply it multiple times)

          point.x = x = x > maxX ? maxX + (x - maxX) * edgeTolerance : x < minX ? minX + (x - minX) * edgeTolerance : x;
          point.y = y = y > maxY ? maxY + (y - maxY) * edgeTolerance : y < minY ? minY + (y - minY) * edgeTolerance : y;
          result = snap.call(self, point);

          if (result !== point) {
            point.x = result.x;
            point.y = result.y;
          }

          if (factor !== 1) {
            point.x *= factor;
            point.y *= factor;
          }

          if (radius < _bigNum) {
            dx = point.x - x;
            dy = point.y - y;

            if (dx * dx + dy * dy > radius) {
              point.x = x;
              point.y = y;
            }
          }

          return point;
        };
      }

      if (_isArray(snap)) {
        return function (p) {
          var i = snap.length,
              closest = 0,
              minDist = _bigNum,
              x,
              y,
              point,
              dist;

          while (--i > -1) {
            point = snap[i];
            x = point.x - p.x;
            y = point.y - p.y;
            dist = x * x + y * y;

            if (dist < minDist) {
              closest = i;
              minDist = dist;
            }
          }

          return minDist <= radius ? snap[closest] : p;
        };
      }

      return function (n) {
        return n;
      };
    },
        calculateBounds = function calculateBounds() {
      var bounds, targetBounds, snap, snapIsRaw;
      hasBounds = false;

      if (scrollProxy) {
        scrollProxy.calibrate();
        self.minX = minX = -scrollProxy.maxScrollLeft();
        self.minY = minY = -scrollProxy.maxScrollTop();
        self.maxX = maxX = self.maxY = maxY = 0;
        hasBounds = true;
      } else if (!!vars.bounds) {
        bounds = _getBounds(vars.bounds, target.parentNode); //could be a selector/jQuery object or a DOM element or a generic object like {top:0, left:100, width:1000, height:800} or {minX:100, maxX:1100, minY:0, maxY:800}

        if (rotationMode) {
          self.minX = minX = bounds.left;
          self.maxX = maxX = bounds.left + bounds.width;
          self.minY = minY = self.maxY = maxY = 0;
        } else if (!_isUndefined(vars.bounds.maxX) || !_isUndefined(vars.bounds.maxY)) {
          bounds = vars.bounds;
          self.minX = minX = bounds.minX;
          self.minY = minY = bounds.minY;
          self.maxX = maxX = bounds.maxX;
          self.maxY = maxY = bounds.maxY;
        } else {
          targetBounds = _getBounds(target, target.parentNode);
          self.minX = minX = Math.round(getPropAsNum(xProp, "px") + bounds.left - targetBounds.left);
          self.minY = minY = Math.round(getPropAsNum(yProp, "px") + bounds.top - targetBounds.top);
          self.maxX = maxX = Math.round(minX + (bounds.width - targetBounds.width));
          self.maxY = maxY = Math.round(minY + (bounds.height - targetBounds.height));
        }

        if (minX > maxX) {
          self.minX = maxX;
          self.maxX = maxX = minX;
          minX = self.minX;
        }

        if (minY > maxY) {
          self.minY = maxY;
          self.maxY = maxY = minY;
          minY = self.minY;
        }

        if (rotationMode) {
          self.minRotation = minX;
          self.maxRotation = maxX;
        }

        hasBounds = true;
      }

      if (vars.liveSnap) {
        snap = vars.liveSnap === true ? vars.snap || {} : vars.liveSnap;
        snapIsRaw = _isArray(snap) || _isFunction(snap);

        if (rotationMode) {
          snapX = buildSnapFunc(snapIsRaw ? snap : snap.rotation, minX, maxX, 1);
          snapY = null;
        } else {
          if (snap.points) {
            snapXY = buildPointSnapFunc(snapIsRaw ? snap : snap.points, minX, maxX, minY, maxY, snap.radius, scrollProxy ? -1 : 1);
          } else {
            if (allowX) {
              snapX = buildSnapFunc(snapIsRaw ? snap : snap.x || snap.left || snap.scrollLeft, minX, maxX, scrollProxy ? -1 : 1);
            }

            if (allowY) {
              snapY = buildSnapFunc(snapIsRaw ? snap : snap.y || snap.top || snap.scrollTop, minY, maxY, scrollProxy ? -1 : 1);
            }
          }
        }
      }
    },
        onThrowComplete = function onThrowComplete() {
      self.isThrowing = false;

      _dispatchEvent(self, "throwcomplete", "onThrowComplete");
    },
        onThrowInterrupt = function onThrowInterrupt() {
      self.isThrowing = false;
    },
        animate = function animate(inertia, forceZeroVelocity) {
      var snap, snapIsRaw, tween, overshootTolerance;

      if (inertia && InertiaPlugin) {
        if (inertia === true) {
          snap = vars.snap || vars.liveSnap || {};
          snapIsRaw = _isArray(snap) || _isFunction(snap);
          inertia = {
            resistance: (vars.throwResistance || vars.resistance || 1000) / (rotationMode ? 10 : 1)
          };

          if (rotationMode) {
            inertia.rotation = _parseInertia(self, snapIsRaw ? snap : snap.rotation, maxX, minX, 1, forceZeroVelocity);
          } else {
            if (allowX) {
              inertia[xProp] = _parseInertia(self, snapIsRaw ? snap : snap.points || snap.x || snap.left, maxX, minX, scrollProxy ? -1 : 1, forceZeroVelocity || self.lockedAxis === "x");
            }

            if (allowY) {
              inertia[yProp] = _parseInertia(self, snapIsRaw ? snap : snap.points || snap.y || snap.top, maxY, minY, scrollProxy ? -1 : 1, forceZeroVelocity || self.lockedAxis === "y");
            }

            if (snap.points || _isArray(snap) && _isObject(snap[0])) {
              inertia.linkedProps = xProp + "," + yProp;
              inertia.radius = snap.radius; //note: we also disable liveSnapping while throwing if there's a "radius" defined, otherwise it looks weird to have the item thrown past a snapping point but live-snapping mid-tween. We do this by altering the onUpdateParams so that "skipSnap" parameter is true for syncXY.
            }
          }
        }

        self.isThrowing = true;
        overshootTolerance = !isNaN(vars.overshootTolerance) ? vars.overshootTolerance : vars.edgeResistance === 1 ? 0 : 1 - self.edgeResistance + 0.2;

        if (!inertia.duration) {
          inertia.duration = {
            max: Math.max(vars.minDuration || 0, "maxDuration" in vars ? vars.maxDuration : 2),
            min: !isNaN(vars.minDuration) ? vars.minDuration : overshootTolerance === 0 || _isObject(inertia) && inertia.resistance > 1000 ? 0 : 0.5,
            overshoot: overshootTolerance
          };
        }

        self.tween = tween = gsap.to(scrollProxy || target, {
          inertia: inertia,
          data: "_draggable",
          onComplete: onThrowComplete,
          onInterrupt: onThrowInterrupt,
          onUpdate: vars.fastMode ? _dispatchEvent : syncXY,
          onUpdateParams: vars.fastMode ? [self, "onthrowupdate", "onThrowUpdate"] : snap && snap.radius ? [false, true] : []
        });

        if (!vars.fastMode) {
          if (scrollProxy) {
            scrollProxy._skip = true; // Microsoft browsers have a bug that causes them to briefly render the position incorrectly (it flashes to the end state when we seek() the tween even though we jump right back to the current position, and this only seems to happen when we're affecting both top and left), so we set a _suspendTransforms flag to prevent it from actually applying the values in the ScrollProxy.
          }

          tween.render(1e9, true, true); // force to the end. Remember, the duration will likely change upon initting because that's when InertiaPlugin calculates it.

          syncXY(true, true);
          self.endX = self.x;
          self.endY = self.y;

          if (rotationMode) {
            self.endRotation = self.x;
          }

          tween.play(0);
          syncXY(true, true);

          if (scrollProxy) {
            scrollProxy._skip = false; //Microsoft browsers have a bug that causes them to briefly render the position incorrectly (it flashes to the end state when we seek() the tween even though we jump right back to the current position, and this only seems to happen when we're affecting both top and left), so we set a _suspendTransforms flag to prevent it from actually applying the values in the ScrollProxy.
          }
        }
      } else if (hasBounds) {
        self.applyBounds();
      }
    },
        updateMatrix = function updateMatrix(shiftStart) {
      var start = matrix,
          p;
      matrix = (0,_utils_matrix_js__WEBPACK_IMPORTED_MODULE_0__/* .getGlobalMatrix */ .M9)(target.parentNode, true);

      if (shiftStart && self.isPressed && !matrix.equals(start || new _utils_matrix_js__WEBPACK_IMPORTED_MODULE_0__/* .Matrix2D */ .G9())) {
        //if the matrix changes WHILE the element is pressed, we must adjust the startPointerX and startPointerY accordingly, so we invert the original matrix and figure out where the pointerX and pointerY were in the global space, then apply the new matrix to get the updated coordinates.
        p = start.inverse().apply({
          x: startPointerX,
          y: startPointerY
        });
        matrix.apply(p, p);
        startPointerX = p.x;
        startPointerY = p.y;
      }

      if (matrix.equals(_identityMatrix)) {
        //if there are no transforms, we can optimize performance by not factoring in the matrix
        matrix = null;
      }
    },
        recordStartPositions = function recordStartPositions() {
      var edgeTolerance = 1 - self.edgeResistance,
          offsetX = isFixed ? _getDocScrollLeft(ownerDoc) : 0,
          offsetY = isFixed ? _getDocScrollTop(ownerDoc) : 0,
          parsedOrigin,
          x,
          y;
      updateMatrix(false);
      _point1.x = self.pointerX - offsetX;
      _point1.y = self.pointerY - offsetY;
      matrix && matrix.apply(_point1, _point1);
      startPointerX = _point1.x; //translate to local coordinate system

      startPointerY = _point1.y;

      if (dirty) {
        setPointerPosition(self.pointerX, self.pointerY);
        render(true);
      }

      innerMatrix = (0,_utils_matrix_js__WEBPACK_IMPORTED_MODULE_0__/* .getGlobalMatrix */ .M9)(target);

      if (scrollProxy) {
        calculateBounds();
        startElementY = scrollProxy.top();
        startElementX = scrollProxy.left();
      } else {
        //if the element is in the process of tweening, don't force snapping to occur because it could make it jump. Imagine the user throwing, then before it's done, clicking on the element in its inbetween state.
        if (isTweening()) {
          syncXY(true, true);
          calculateBounds();
        } else {
          self.applyBounds();
        }

        if (rotationMode) {
          parsedOrigin = target.ownerSVGElement ? [gsCache.xOrigin - target.getBBox().x, gsCache.yOrigin - target.getBBox().y] : (_getComputedStyle(target)[_transformOriginProp] || "0 0").split(" ");
          rotationOrigin = self.rotationOrigin = (0,_utils_matrix_js__WEBPACK_IMPORTED_MODULE_0__/* .getGlobalMatrix */ .M9)(target).apply({
            x: parseFloat(parsedOrigin[0]) || 0,
            y: parseFloat(parsedOrigin[1]) || 0
          });
          syncXY(true, true);
          x = self.pointerX - rotationOrigin.x - offsetX;
          y = rotationOrigin.y - self.pointerY + offsetY;
          startElementX = self.x; //starting rotation (x always refers to rotation in type:"rotation", measured in degrees)

          startElementY = self.y = Math.atan2(y, x) * _RAD2DEG;
        } else {
          //parent = !isFixed && target.parentNode;
          //startScrollTop = parent ? parent.scrollTop || 0 : 0;
          //startScrollLeft = parent ? parent.scrollLeft || 0 : 0;
          startElementY = getPropAsNum(yProp, "px"); //record the starting top and left values so that we can just add the mouse's movement to them later.

          startElementX = getPropAsNum(xProp, "px");
        }
      }

      if (hasBounds && edgeTolerance) {
        if (startElementX > maxX) {
          startElementX = maxX + (startElementX - maxX) / edgeTolerance;
        } else if (startElementX < minX) {
          startElementX = minX - (minX - startElementX) / edgeTolerance;
        }

        if (!rotationMode) {
          if (startElementY > maxY) {
            startElementY = maxY + (startElementY - maxY) / edgeTolerance;
          } else if (startElementY < minY) {
            startElementY = minY - (minY - startElementY) / edgeTolerance;
          }
        }
      }

      self.startX = startElementX = _round(startElementX);
      self.startY = startElementY = _round(startElementY);
    },
        isTweening = function isTweening() {
      return self.tween && self.tween.isActive();
    },
        removePlaceholder = function removePlaceholder() {
      if (_placeholderDiv.parentNode && !isTweening() && !self.isDragging) {
        //_placeholderDiv just props open auto-scrolling containers so they don't collapse as the user drags left/up. We remove it after dragging (and throwing, if necessary) finishes.
        _placeholderDiv.parentNode.removeChild(_placeholderDiv);
      }
    },
        //called when the mouse is pressed (or touch starts)
    onPress = function onPress(e, force) {
      var i;

      if (!enabled || self.isPressed || !e || (e.type === "mousedown" || e.type === "pointerdown") && !force && _getTime() - clickTime < 30 && _touchEventLookup[self.pointerEvent.type]) {
        //when we DON'T preventDefault() in order to accommodate touch-scrolling and the user just taps, many browsers also fire a mousedown/mouseup sequence AFTER the touchstart/touchend sequence, thus it'd result in two quick "click" events being dispatched. This line senses that condition and halts it on the subsequent mousedown.
        isPreventingDefault && e && enabled && _preventDefault(e); // in some browsers, we must listen for multiple event types like touchstart, pointerdown, mousedown. The first time this function is called, we record whether or not we _preventDefault() so that on duplicate calls, we can do the same if necessary.

        return;
      }

      interrupted = isTweening();
      self.pointerEvent = e;

      if (_touchEventLookup[e.type]) {
        //note: on iOS, BOTH touchmove and mousemove are dispatched, but the mousemove has pageY and pageX of 0 which would mess up the calculations and needlessly hurt performance.
        touchEventTarget = ~e.type.indexOf("touch") ? e.currentTarget || e.target : ownerDoc; //pointer-based touches (for Microsoft browsers) don't remain locked to the original target like other browsers, so we must use the document instead. The event type would be "MSPointerDown" or "pointerdown".

        _addListener(touchEventTarget, "touchend", onRelease);

        _addListener(touchEventTarget, "touchmove", onMove); // possible future change if PointerEvents are more standardized: https://developer.mozilla.org/en-US/docs/Web/API/Element/setPointerCapture


        _addListener(touchEventTarget, "touchcancel", onRelease);

        _addListener(ownerDoc, "touchstart", _onMultiTouchDocument);
      } else {
        touchEventTarget = null;

        _addListener(ownerDoc, "mousemove", onMove); //attach these to the document instead of the box itself so that if the user's mouse moves too quickly (and off of the box), things still work.

      }

      touchDragAxis = null;

      if (!_supportsPointer || !touchEventTarget) {
        _addListener(ownerDoc, "mouseup", onRelease);

        e && e.target && _addListener(e.target, "mouseup", onRelease); //we also have to listen directly on the element because some browsers don't bubble up the event to the _doc on elements with contentEditable="true"
      }

      isClicking = isClickable.call(self, e.target) && vars.dragClickables === false && !force;

      if (isClicking) {
        _addListener(e.target, "change", onRelease); //in some browsers, when you mousedown on a <select> element, no mouseup gets dispatched! So we listen for a "change" event instead.


        _dispatchEvent(self, "pressInit", "onPressInit");

        _dispatchEvent(self, "press", "onPress");

        _setSelectable(triggers, true); //accommodates things like inputs and elements with contentEditable="true" (otherwise user couldn't drag to select text)


        isPreventingDefault = false;
        return;
      }

      allowNativeTouchScrolling = !touchEventTarget || allowX === allowY || self.vars.allowNativeTouchScrolling === false || self.vars.allowContextMenu && e && (e.ctrlKey || e.which > 2) ? false : allowX ? "y" : "x"; //note: in Chrome, right-clicking (for a context menu) fires onPress and it doesn't have the event.which set properly, so we must look for event.ctrlKey. If the user wants to allow context menus we should of course sense it here and not allow native touch scrolling.

      isPreventingDefault = !allowNativeTouchScrolling && !self.allowEventDefault;

      if (isPreventingDefault) {
        _preventDefault(e);

        _addListener(_win, "touchforcechange", _preventDefault); //works around safari bug: https://greensock.com/forums/topic/21450-draggable-in-iframe-on-mobile-is-buggy/

      }

      if (e.changedTouches) {
        //touch events store the data slightly differently
        e = touch = e.changedTouches[0];
        touchID = e.identifier;
      } else if (e.pointerId) {
        touchID = e.pointerId; //for some Microsoft browsers
      } else {
        touch = touchID = null;
      }

      _dragCount++;

      _addToRenderQueue(render); //causes the Draggable to render on each "tick" of TweenLite.ticker (performance optimization - updating values in a mousemove can cause them to happen too frequently, like multiple times between frame redraws which is wasteful, and it also prevents values from updating properly in IE8)


      startPointerY = self.pointerY = e.pageY; //record the starting x and y so that we can calculate the movement from the original in _onMouseMove

      startPointerX = self.pointerX = e.pageX;

      _dispatchEvent(self, "pressInit", "onPressInit");

      if (allowNativeTouchScrolling || self.autoScroll) {
        _recordMaxScrolls(target.parentNode);
      }

      if (target.parentNode && self.autoScroll && !scrollProxy && !rotationMode && target.parentNode._gsMaxScrollX && !_placeholderDiv.parentNode && !target.getBBox) {
        //add a placeholder div to prevent the parent container from collapsing when the user drags the element left.
        _placeholderDiv.style.width = target.parentNode.scrollWidth + "px";
        target.parentNode.appendChild(_placeholderDiv);
      }

      recordStartPositions();
      self.tween && self.tween.kill();
      self.isThrowing = false;
      gsap.killTweensOf(scrollProxy || target, killProps, true); //in case the user tries to drag it before the last tween is done.

      scrollProxy && gsap.killTweensOf(target, {
        scrollTo: 1
      }, true); //just in case the original target's scroll position is being tweened somewhere else.

      self.tween = self.lockedAxis = null;

      if (vars.zIndexBoost || !rotationMode && !scrollProxy && vars.zIndexBoost !== false) {
        target.style.zIndex = Draggable.zIndex++;
      }

      self.isPressed = true;
      hasDragCallback = !!(vars.onDrag || self._listeners.drag);
      hasMoveCallback = !!(vars.onMove || self._listeners.move);

      if (vars.cursor !== false || vars.activeCursor) {
        i = triggers.length;

        while (--i > -1) {
          gsap.set(triggers[i], {
            cursor: vars.activeCursor || vars.cursor || (_defaultCursor === "grab" ? "grabbing" : _defaultCursor)
          });
        }
      }

      _dispatchEvent(self, "press", "onPress");
    },
        //called every time the mouse/touch moves
    onMove = function onMove(e) {
      var originalEvent = e,
          touches,
          pointerX,
          pointerY,
          i,
          dx,
          dy;

      if (!enabled || _isMultiTouching || !self.isPressed || !e) {
        isPreventingDefault && e && enabled && _preventDefault(e); // in some browsers, we must listen for multiple event types like touchmove, pointermove, mousemove. The first time this function is called, we record whether or not we _preventDefault() so that on duplicate calls, we can do the same if necessary.

        return;
      }

      self.pointerEvent = e;
      touches = e.changedTouches;

      if (touches) {
        //touch events store the data slightly differently
        e = touches[0];

        if (e !== touch && e.identifier !== touchID) {
          //Usually changedTouches[0] will be what we're looking for, but in case it's not, look through the rest of the array...(and Android browsers don't reuse the event like iOS)
          i = touches.length;

          while (--i > -1 && (e = touches[i]).identifier !== touchID && e.target !== target) {} // Some Android devices dispatch a touchstart AND pointerdown initially, and then only pointermove thus the touchID may not match because it was grabbed from the touchstart event whereas the pointer event is the one that the browser dispatches for move, so if the event target matches this Draggable's target, let it through.


          if (i < 0) {
            return;
          }
        }
      } else if (e.pointerId && touchID && e.pointerId !== touchID) {
        //for some Microsoft browsers, we must attach the listener to the doc rather than the trigger so that when the finger moves outside the bounds of the trigger, things still work. So if the event we're receiving has a pointerId that doesn't match the touchID, ignore it (for multi-touch)
        return;
      }

      if (touchEventTarget && allowNativeTouchScrolling && !touchDragAxis) {
        //Android browsers force us to decide on the first "touchmove" event if we should allow the default (scrolling) behavior or preventDefault(). Otherwise, a "touchcancel" will be fired and then no "touchmove" or "touchend" will fire during the scrolling (no good).
        _point1.x = e.pageX - (isFixed ? _getDocScrollLeft(ownerDoc) : 0);
        _point1.y = e.pageY - (isFixed ? _getDocScrollTop(ownerDoc) : 0);
        matrix && matrix.apply(_point1, _point1);
        pointerX = _point1.x;
        pointerY = _point1.y;
        dx = Math.abs(pointerX - startPointerX);
        dy = Math.abs(pointerY - startPointerY);

        if (dx !== dy && (dx > minimumMovement || dy > minimumMovement) || _isAndroid && allowNativeTouchScrolling === touchDragAxis) {
          touchDragAxis = dx > dy && allowX ? "x" : "y";

          if (allowNativeTouchScrolling && touchDragAxis !== allowNativeTouchScrolling) {
            _addListener(_win, "touchforcechange", _preventDefault); // prevents native touch scrolling from taking over if the user started dragging in the other direction in iOS Safari

          }

          if (self.vars.lockAxisOnTouchScroll !== false && allowX && allowY) {
            self.lockedAxis = touchDragAxis === "x" ? "y" : "x";
            _isFunction(self.vars.onLockAxis) && self.vars.onLockAxis.call(self, originalEvent);
          }

          if (_isAndroid && allowNativeTouchScrolling === touchDragAxis) {
            onRelease(originalEvent);
            return;
          }
        }
      }

      if (!self.allowEventDefault && (!allowNativeTouchScrolling || touchDragAxis && allowNativeTouchScrolling !== touchDragAxis) && originalEvent.cancelable !== false) {
        _preventDefault(originalEvent);

        isPreventingDefault = true;
      } else if (isPreventingDefault) {
        isPreventingDefault = false;
      }

      if (self.autoScroll) {
        checkAutoScrollBounds = true;
      }

      setPointerPosition(e.pageX, e.pageY, hasMoveCallback);
    },
        setPointerPosition = function setPointerPosition(pointerX, pointerY, invokeOnMove) {
      var dragTolerance = 1 - self.dragResistance,
          edgeTolerance = 1 - self.edgeResistance,
          prevPointerX = self.pointerX,
          prevPointerY = self.pointerY,
          prevStartElementY = startElementY,
          prevX = self.x,
          prevY = self.y,
          prevEndX = self.endX,
          prevEndY = self.endY,
          prevEndRotation = self.endRotation,
          prevDirty = dirty,
          xChange,
          yChange,
          x,
          y,
          dif,
          temp;
      self.pointerX = pointerX;
      self.pointerY = pointerY;

      if (isFixed) {
        pointerX -= _getDocScrollLeft(ownerDoc);
        pointerY -= _getDocScrollTop(ownerDoc);
      }

      if (rotationMode) {
        y = Math.atan2(rotationOrigin.y - pointerY, pointerX - rotationOrigin.x) * _RAD2DEG;
        dif = self.y - y;

        if (dif > 180) {
          startElementY -= 360;
          self.y = y;
        } else if (dif < -180) {
          startElementY += 360;
          self.y = y;
        }

        if (self.x !== startElementX || Math.abs(startElementY - y) > minimumMovement) {
          self.y = y;
          x = startElementX + (startElementY - y) * dragTolerance;
        } else {
          x = startElementX;
        }
      } else {
        if (matrix) {
          temp = pointerX * matrix.a + pointerY * matrix.c + matrix.e;
          pointerY = pointerX * matrix.b + pointerY * matrix.d + matrix.f;
          pointerX = temp;
        }

        yChange = pointerY - startPointerY;
        xChange = pointerX - startPointerX;

        if (yChange < minimumMovement && yChange > -minimumMovement) {
          yChange = 0;
        }

        if (xChange < minimumMovement && xChange > -minimumMovement) {
          xChange = 0;
        }

        if ((self.lockAxis || self.lockedAxis) && (xChange || yChange)) {
          temp = self.lockedAxis;

          if (!temp) {
            self.lockedAxis = temp = allowX && Math.abs(xChange) > Math.abs(yChange) ? "y" : allowY ? "x" : null;

            if (temp && _isFunction(self.vars.onLockAxis)) {
              self.vars.onLockAxis.call(self, self.pointerEvent);
            }
          }

          if (temp === "y") {
            yChange = 0;
          } else if (temp === "x") {
            xChange = 0;
          }
        }

        x = _round(startElementX + xChange * dragTolerance);
        y = _round(startElementY + yChange * dragTolerance);
      }

      if ((snapX || snapY || snapXY) && (self.x !== x || self.y !== y && !rotationMode)) {
        if (snapXY) {
          _temp1.x = x;
          _temp1.y = y;
          temp = snapXY(_temp1);
          x = _round(temp.x);
          y = _round(temp.y);
        }

        if (snapX) {
          x = _round(snapX(x));
        }

        if (snapY) {
          y = _round(snapY(y));
        }
      }

      if (hasBounds) {
        if (x > maxX) {
          x = maxX + Math.round((x - maxX) * edgeTolerance);
        } else if (x < minX) {
          x = minX + Math.round((x - minX) * edgeTolerance);
        }

        if (!rotationMode) {
          if (y > maxY) {
            y = Math.round(maxY + (y - maxY) * edgeTolerance);
          } else if (y < minY) {
            y = Math.round(minY + (y - minY) * edgeTolerance);
          }
        }
      }

      if (self.x !== x || self.y !== y && !rotationMode) {
        if (rotationMode) {
          self.endRotation = self.x = self.endX = x;
          dirty = true;
        } else {
          if (allowY) {
            self.y = self.endY = y;
            dirty = true; //a flag that indicates we need to render the target next time the TweenLite.ticker dispatches a "tick" event (typically on a requestAnimationFrame) - this is a performance optimization (we shouldn't render on every move because sometimes many move events can get dispatched between screen refreshes, and that'd be wasteful to render every time)
          }

          if (allowX) {
            self.x = self.endX = x;
            dirty = true;
          }
        }

        if (!invokeOnMove || _dispatchEvent(self, "move", "onMove") !== false) {
          if (!self.isDragging && self.isPressed) {
            self.isDragging = true;

            _dispatchEvent(self, "dragstart", "onDragStart");
          }
        } else {
          //revert because the onMove returned false!
          self.pointerX = prevPointerX;
          self.pointerY = prevPointerY;
          startElementY = prevStartElementY;
          self.x = prevX;
          self.y = prevY;
          self.endX = prevEndX;
          self.endY = prevEndY;
          self.endRotation = prevEndRotation;
          dirty = prevDirty;
        }
      }
    },
        //called when the mouse/touch is released
    onRelease = function onRelease(e, force) {
      if (!enabled || !self.isPressed || e && touchID != null && !force && (e.pointerId && e.pointerId !== touchID && e.target !== target || e.changedTouches && !_hasTouchID(e.changedTouches, touchID))) {
        //for some Microsoft browsers, we must attach the listener to the doc rather than the trigger so that when the finger moves outside the bounds of the trigger, things still work. So if the event we're receiving has a pointerId that doesn't match the touchID, ignore it (for multi-touch)
        isPreventingDefault && e && enabled && _preventDefault(e); // in some browsers, we must listen for multiple event types like touchend, pointerup, mouseup. The first time this function is called, we record whether or not we _preventDefault() so that on duplicate calls, we can do the same if necessary.

        return;
      }

      self.isPressed = false;
      var originalEvent = e,
          wasDragging = self.isDragging,
          isContextMenuRelease = self.vars.allowContextMenu && e && (e.ctrlKey || e.which > 2),
          placeholderDelayedCall = gsap.delayedCall(0.001, removePlaceholder),
          touches,
          i,
          syntheticEvent,
          eventTarget,
          syntheticClick;

      if (touchEventTarget) {
        _removeListener(touchEventTarget, "touchend", onRelease);

        _removeListener(touchEventTarget, "touchmove", onMove);

        _removeListener(touchEventTarget, "touchcancel", onRelease);

        _removeListener(ownerDoc, "touchstart", _onMultiTouchDocument);
      } else {
        _removeListener(ownerDoc, "mousemove", onMove);
      }

      _removeListener(_win, "touchforcechange", _preventDefault);

      if (!_supportsPointer || !touchEventTarget) {
        _removeListener(ownerDoc, "mouseup", onRelease);

        e && e.target && _removeListener(e.target, "mouseup", onRelease);
      }

      dirty = false;

      if (wasDragging) {
        dragEndTime = _lastDragTime = _getTime();
        self.isDragging = false;
      }

      if (isClicking && !isContextMenuRelease) {
        if (e) {
          _removeListener(e.target, "change", onRelease);

          self.pointerEvent = originalEvent;
        }

        _setSelectable(triggers, false);

        _dispatchEvent(self, "release", "onRelease");

        _dispatchEvent(self, "click", "onClick");

        isClicking = false;
        return;
      }

      _removeFromRenderQueue(render);

      i = triggers.length;

      while (--i > -1) {
        _setStyle(triggers[i], "cursor", vars.cursor || (vars.cursor !== false ? _defaultCursor : null));
      }

      _dragCount--;

      if (e) {
        touches = e.changedTouches;

        if (touches) {
          //touch events store the data slightly differently
          e = touches[0];

          if (e !== touch && e.identifier !== touchID) {
            //Usually changedTouches[0] will be what we're looking for, but in case it's not, look through the rest of the array...(and Android browsers don't reuse the event like iOS)
            i = touches.length;

            while (--i > -1 && (e = touches[i]).identifier !== touchID && e.target !== target) {}

            if (i < 0) {
              return;
            }
          }
        }

        self.pointerEvent = originalEvent;
        self.pointerX = e.pageX;
        self.pointerY = e.pageY;
      }

      if (isContextMenuRelease && originalEvent) {
        _preventDefault(originalEvent);

        isPreventingDefault = true;

        _dispatchEvent(self, "release", "onRelease");
      } else if (originalEvent && !wasDragging) {
        isPreventingDefault = false;

        if (interrupted && (vars.snap || vars.bounds)) {
          //otherwise, if the user clicks on the object while it's animating to a snapped position, and then releases without moving 3 pixels, it will just stay there (it should animate/snap)
          animate(vars.inertia || vars.throwProps);
        }

        _dispatchEvent(self, "release", "onRelease");

        if ((!_isAndroid || originalEvent.type !== "touchmove") && originalEvent.type.indexOf("cancel") === -1) {
          //to accommodate native scrolling on Android devices, we have to immediately call onRelease() on the first touchmove event, but that shouldn't trigger a "click".
          _dispatchEvent(self, "click", "onClick");

          if (_getTime() - clickTime < 300) {
            _dispatchEvent(self, "doubleclick", "onDoubleClick");
          }

          eventTarget = originalEvent.target || target; //old IE uses srcElement

          clickTime = _getTime();

          syntheticClick = function syntheticClick() {
            // some browsers (like Firefox) won't trust script-generated clicks, so if the user tries to click on a video to play it, for example, it simply won't work. Since a regular "click" event will most likely be generated anyway (one that has its isTrusted flag set to true), we must slightly delay our script-generated click so that the "real"/trusted one is prioritized. Remember, when there are duplicate events in quick succession, we suppress all but the first one. Some browsers don't even trigger the "real" one at all, so our synthetic one is a safety valve that ensures that no matter what, a click event does get dispatched.
            if (clickTime !== clickDispatch && self.enabled() && !self.isPressed && !originalEvent.defaultPrevented) {
              if (eventTarget.click) {
                //some browsers (like mobile Safari) don't properly trigger the click event
                eventTarget.click();
              } else if (ownerDoc.createEvent) {
                syntheticEvent = ownerDoc.createEvent("MouseEvents");
                syntheticEvent.initMouseEvent("click", true, true, _win, 1, self.pointerEvent.screenX, self.pointerEvent.screenY, self.pointerX, self.pointerY, false, false, false, false, 0, null);
                eventTarget.dispatchEvent(syntheticEvent);
              }
            }
          };

          if (!_isAndroid && !originalEvent.defaultPrevented) {
            //iOS Safari requires the synthetic click to happen immediately or else it simply won't work, but Android doesn't play nice.
            gsap.delayedCall(0.05, syntheticClick); //in addition to the iOS bug workaround, there's a Firefox issue with clicking on things like a video to play, so we must fake a click event in a slightly delayed fashion. Previously, we listened for the "click" event with "capture" false which solved the video-click-to-play issue, but it would allow the "click" event to be dispatched twice like if you were using a jQuery.click() because that was handled in the capture phase, thus we had to switch to the capture phase to avoid the double-dispatching, but do the delayed synthetic click. Don't fire it too fast (like 0.00001) because we want to give the native event a chance to fire first as it's "trusted".
          }
        }
      } else {
        animate(vars.inertia || vars.throwProps); //will skip if inertia/throwProps isn't defined or InertiaPlugin isn't loaded.

        if (!self.allowEventDefault && originalEvent && (vars.dragClickables !== false || !isClickable.call(self, originalEvent.target)) && wasDragging && (!allowNativeTouchScrolling || touchDragAxis && allowNativeTouchScrolling === touchDragAxis) && originalEvent.cancelable !== false) {
          isPreventingDefault = true;

          _preventDefault(originalEvent);
        } else {
          isPreventingDefault = false;
        }

        _dispatchEvent(self, "release", "onRelease");
      }

      isTweening() && placeholderDelayedCall.duration(self.tween.duration()); //sync the timing so that the placeholder DIV gets

      wasDragging && _dispatchEvent(self, "dragend", "onDragEnd");
      return true;
    },
        updateScroll = function updateScroll(e) {
      if (e && self.isDragging && !scrollProxy) {
        var parent = e.target || target.parentNode,
            deltaX = parent.scrollLeft - parent._gsScrollX,
            deltaY = parent.scrollTop - parent._gsScrollY;

        if (deltaX || deltaY) {
          if (matrix) {
            startPointerX -= deltaX * matrix.a + deltaY * matrix.c;
            startPointerY -= deltaY * matrix.d + deltaX * matrix.b;
          } else {
            startPointerX -= deltaX;
            startPointerY -= deltaY;
          }

          parent._gsScrollX += deltaX;
          parent._gsScrollY += deltaY;
          setPointerPosition(self.pointerX, self.pointerY);
        }
      }
    },
        onClick = function onClick(e) {
      //this was a huge pain in the neck to align all the various browsers and their behaviors. Chrome, Firefox, Safari, Opera, Android, and Microsoft Edge all handle events differently! Some will only trigger native behavior (like checkbox toggling) from trusted events. Others don't even support isTrusted, but require 2 events to flow through before triggering native behavior. Edge treats everything as trusted but also mandates that 2 flow through to trigger the correct native behavior.
      var time = _getTime(),
          recentlyClicked = time - clickTime < 100,
          recentlyDragged = time - dragEndTime < 50,
          alreadyDispatched = recentlyClicked && clickDispatch === clickTime,
          defaultPrevented = self.pointerEvent && self.pointerEvent.defaultPrevented,
          alreadyDispatchedTrusted = recentlyClicked && trustedClickDispatch === clickTime,
          trusted = e.isTrusted || e.isTrusted == null && recentlyClicked && alreadyDispatched; //note: Safari doesn't support isTrusted, and it won't properly execute native behavior (like toggling checkboxes) on the first synthetic "click" event - we must wait for the 2nd and treat it as trusted (but stop propagation at that point). Confusing, I know. Don't you love cross-browser compatibility challenges?


      if ((alreadyDispatched || recentlyDragged && self.vars.suppressClickOnDrag !== false) && e.stopImmediatePropagation) {
        e.stopImmediatePropagation();
      }

      if (recentlyClicked && !(self.pointerEvent && self.pointerEvent.defaultPrevented) && (!alreadyDispatched || trusted && !alreadyDispatchedTrusted)) {
        //let the first click pass through unhindered. Let the next one only if it's trusted, then no more (stop quick-succession ones)
        if (trusted && alreadyDispatched) {
          trustedClickDispatch = clickTime;
        }

        clickDispatch = clickTime;
        return;
      }

      if (self.isPressed || recentlyDragged || recentlyClicked) {
        if (!trusted || !e.detail || !recentlyClicked || defaultPrevented) {
          _preventDefault(e);
        }
      }

      if (!recentlyClicked && !recentlyDragged) {
        // for script-triggered event dispatches, like element.click()
        e && e.target && (self.pointerEvent = e);

        _dispatchEvent(self, "click", "onClick");
      }
    },
        localizePoint = function localizePoint(p) {
      return matrix ? {
        x: p.x * matrix.a + p.y * matrix.c + matrix.e,
        y: p.x * matrix.b + p.y * matrix.d + matrix.f
      } : {
        x: p.x,
        y: p.y
      };
    };

    old = Draggable.get(target);
    old && old.kill(); // avoids duplicates (an element can only be controlled by one Draggable)
    //give the user access to start/stop dragging...

    _this2.startDrag = function (event, align) {
      var r1, r2, p1, p2;
      onPress(event || self.pointerEvent, true); //if the pointer isn't on top of the element, adjust things accordingly

      if (align && !self.hitTest(event || self.pointerEvent)) {
        r1 = _parseRect(event || self.pointerEvent);
        r2 = _parseRect(target);
        p1 = localizePoint({
          x: r1.left + r1.width / 2,
          y: r1.top + r1.height / 2
        });
        p2 = localizePoint({
          x: r2.left + r2.width / 2,
          y: r2.top + r2.height / 2
        });
        startPointerX -= p1.x - p2.x;
        startPointerY -= p1.y - p2.y;
      }

      if (!self.isDragging) {
        self.isDragging = true;

        _dispatchEvent(self, "dragstart", "onDragStart");
      }
    };

    _this2.drag = onMove;

    _this2.endDrag = function (e) {
      return onRelease(e || self.pointerEvent, true);
    };

    _this2.timeSinceDrag = function () {
      return self.isDragging ? 0 : (_getTime() - dragEndTime) / 1000;
    };

    _this2.timeSinceClick = function () {
      return (_getTime() - clickTime) / 1000;
    };

    _this2.hitTest = function (target, threshold) {
      return Draggable.hitTest(self.target, target, threshold);
    };

    _this2.getDirection = function (from, diagonalThreshold) {
      //from can be "start" (default), "velocity", or an element
      var mode = from === "velocity" && InertiaPlugin ? from : _isObject(from) && !rotationMode ? "element" : "start",
          xChange,
          yChange,
          ratio,
          direction,
          r1,
          r2;

      if (mode === "element") {
        r1 = _parseRect(self.target);
        r2 = _parseRect(from);
      }

      xChange = mode === "start" ? self.x - startElementX : mode === "velocity" ? InertiaPlugin.getVelocity(target, xProp) : r1.left + r1.width / 2 - (r2.left + r2.width / 2);

      if (rotationMode) {
        return xChange < 0 ? "counter-clockwise" : "clockwise";
      } else {
        diagonalThreshold = diagonalThreshold || 2;
        yChange = mode === "start" ? self.y - startElementY : mode === "velocity" ? InertiaPlugin.getVelocity(target, yProp) : r1.top + r1.height / 2 - (r2.top + r2.height / 2);
        ratio = Math.abs(xChange / yChange);
        direction = ratio < 1 / diagonalThreshold ? "" : xChange < 0 ? "left" : "right";

        if (ratio < diagonalThreshold) {
          if (direction !== "") {
            direction += "-";
          }

          direction += yChange < 0 ? "up" : "down";
        }
      }

      return direction;
    };

    _this2.applyBounds = function (newBounds, sticky) {
      var x, y, forceZeroVelocity, e, parent, isRoot;

      if (newBounds && vars.bounds !== newBounds) {
        vars.bounds = newBounds;
        return self.update(true, sticky);
      }

      syncXY(true);
      calculateBounds();

      if (hasBounds && !isTweening()) {
        x = self.x;
        y = self.y;

        if (x > maxX) {
          x = maxX;
        } else if (x < minX) {
          x = minX;
        }

        if (y > maxY) {
          y = maxY;
        } else if (y < minY) {
          y = minY;
        }

        if (self.x !== x || self.y !== y) {
          forceZeroVelocity = true;
          self.x = self.endX = x;

          if (rotationMode) {
            self.endRotation = x;
          } else {
            self.y = self.endY = y;
          }

          dirty = true;
          render(true);

          if (self.autoScroll && !self.isDragging) {
            _recordMaxScrolls(target.parentNode);

            e = target;
            _windowProxy.scrollTop = _win.pageYOffset != null ? _win.pageYOffset : ownerDoc.documentElement.scrollTop != null ? ownerDoc.documentElement.scrollTop : ownerDoc.body.scrollTop;
            _windowProxy.scrollLeft = _win.pageXOffset != null ? _win.pageXOffset : ownerDoc.documentElement.scrollLeft != null ? ownerDoc.documentElement.scrollLeft : ownerDoc.body.scrollLeft;

            while (e && !isRoot) {
              //walk up the chain and sense wherever the scrollTop/scrollLeft exceeds the maximum.
              isRoot = _isRoot(e.parentNode);
              parent = isRoot ? _windowProxy : e.parentNode;

              if (allowY && parent.scrollTop > parent._gsMaxScrollY) {
                parent.scrollTop = parent._gsMaxScrollY;
              }

              if (allowX && parent.scrollLeft > parent._gsMaxScrollX) {
                parent.scrollLeft = parent._gsMaxScrollX;
              }

              e = parent;
            }
          }
        }

        if (self.isThrowing && (forceZeroVelocity || self.endX > maxX || self.endX < minX || self.endY > maxY || self.endY < minY)) {
          animate(vars.inertia || vars.throwProps, forceZeroVelocity);
        }
      }

      return self;
    };

    _this2.update = function (applyBounds, sticky, ignoreExternalChanges) {
      if (sticky && self.isPressed) {
        // in case the element was repositioned in the document flow, thus its x/y may be identical but its position is actually quite different.
        var m = (0,_utils_matrix_js__WEBPACK_IMPORTED_MODULE_0__/* .getGlobalMatrix */ .M9)(target),
            p = innerMatrix.apply({
          x: self.x - startElementX,
          y: self.y - startElementY
        }),
            m2 = (0,_utils_matrix_js__WEBPACK_IMPORTED_MODULE_0__/* .getGlobalMatrix */ .M9)(target.parentNode, true);
        m2.apply({
          x: m.e - p.x,
          y: m.f - p.y
        }, p);
        self.x -= p.x - m2.e;
        self.y -= p.y - m2.f;
        render(true);
        recordStartPositions();
      }

      var x = self.x,
          y = self.y;
      updateMatrix(!sticky);

      if (applyBounds) {
        self.applyBounds();
      } else {
        dirty && ignoreExternalChanges && render(true);
        syncXY(true);
      }

      if (sticky) {
        setPointerPosition(self.pointerX, self.pointerY);
        dirty && render(true);
      }

      if (self.isPressed && !sticky && (allowX && Math.abs(x - self.x) > 0.01 || allowY && Math.abs(y - self.y) > 0.01 && !rotationMode)) {
        recordStartPositions();
      }

      if (self.autoScroll) {
        _recordMaxScrolls(target.parentNode, self.isDragging);

        checkAutoScrollBounds = self.isDragging;
        render(true); //in case reparenting occurred.

        _removeScrollListener(target, updateScroll);

        _addScrollListener(target, updateScroll);
      }

      return self;
    };

    _this2.enable = function (type) {
      var setVars = {
        lazy: true
      },
          id,
          i,
          trigger;

      if (vars.cursor !== false) {
        setVars.cursor = vars.cursor || _defaultCursor;
      }

      if (gsap.utils.checkPrefix("touchCallout")) {
        setVars.touchCallout = "none";
      }

      if (type !== "soft") {
        _setTouchActionForAllDescendants(triggers, allowX === allowY ? "none" : vars.allowNativeTouchScrolling && target.scrollHeight === target.clientHeight === (target.scrollWidth === target.clientHeight) || vars.allowEventDefault ? "manipulation" : allowX ? "pan-y" : "pan-x"); // Some browsers like Internet Explorer will fire a pointercancel event when the user attempts to drag when touchAction is "manipulate" because it's perceived as a pan. If the element has scrollable content in only one direction, we should use pan-x or pan-y accordingly so that the pointercancel doesn't prevent dragging.


        i = triggers.length;

        while (--i > -1) {
          trigger = triggers[i];
          _supportsPointer || _addListener(trigger, "mousedown", onPress);

          _addListener(trigger, "touchstart", onPress);

          _addListener(trigger, "click", onClick, true); //note: used to pass true for capture but it prevented click-to-play-video functionality in Firefox.


          gsap.set(trigger, setVars);

          if (trigger.getBBox && trigger.ownerSVGElement) {
            // a bug in chrome doesn't respect touch-action on SVG elements - it only works if we set it on the parent SVG.
            gsap.set(trigger.ownerSVGElement, {
              touchAction: allowX === allowY ? "none" : vars.allowNativeTouchScrolling || vars.allowEventDefault ? "manipulation" : allowX ? "pan-y" : "pan-x"
            });
          }

          vars.allowContextMenu || _addListener(trigger, "contextmenu", onContextMenu);
        }

        _setSelectable(triggers, false);
      }

      _addScrollListener(target, updateScroll);

      enabled = true;

      if (InertiaPlugin && type !== "soft") {
        InertiaPlugin.track(scrollProxy || target, xyMode ? "x,y" : rotationMode ? "rotation" : "top,left");
      }

      target._gsDragID = id = "d" + _lookupCount++;
      _lookup[id] = self;

      if (scrollProxy) {
        scrollProxy.enable();
        scrollProxy.element._gsDragID = id;
      }

      (vars.bounds || rotationMode) && recordStartPositions();
      vars.bounds && self.applyBounds();
      return self;
    };

    _this2.disable = function (type) {
      var dragging = self.isDragging,
          i = triggers.length,
          trigger;

      while (--i > -1) {
        _setStyle(triggers[i], "cursor", null);
      }

      if (type !== "soft") {
        _setTouchActionForAllDescendants(triggers, null);

        i = triggers.length;

        while (--i > -1) {
          trigger = triggers[i];

          _setStyle(trigger, "touchCallout", null);

          _removeListener(trigger, "mousedown", onPress);

          _removeListener(trigger, "touchstart", onPress);

          _removeListener(trigger, "click", onClick);

          _removeListener(trigger, "contextmenu", onContextMenu);
        }

        _setSelectable(triggers, true);

        if (touchEventTarget) {
          _removeListener(touchEventTarget, "touchcancel", onRelease);

          _removeListener(touchEventTarget, "touchend", onRelease);

          _removeListener(touchEventTarget, "touchmove", onMove);
        }

        _removeListener(ownerDoc, "mouseup", onRelease);

        _removeListener(ownerDoc, "mousemove", onMove);
      }

      _removeScrollListener(target, updateScroll);

      enabled = false;
      InertiaPlugin && type !== "soft" && InertiaPlugin.untrack(scrollProxy || target, xyMode ? "x,y" : rotationMode ? "rotation" : "top,left");
      scrollProxy && scrollProxy.disable();

      _removeFromRenderQueue(render);

      self.isDragging = self.isPressed = isClicking = false;
      dragging && _dispatchEvent(self, "dragend", "onDragEnd");
      return self;
    };

    _this2.enabled = function (value, type) {
      return arguments.length ? value ? self.enable(type) : self.disable(type) : enabled;
    };

    _this2.kill = function () {
      self.isThrowing = false;
      self.tween && self.tween.kill();
      self.disable();
      gsap.set(triggers, {
        clearProps: "userSelect"
      });
      delete _lookup[target._gsDragID];
      return self;
    };

    if (~type.indexOf("scroll")) {
      scrollProxy = _this2.scrollProxy = new ScrollProxy(target, _extend({
        onKill: function onKill() {
          //ScrollProxy's onKill() gets called if/when the ScrollProxy senses that the user interacted with the scroll position manually (like using the scrollbar). IE9 doesn't fire the "mouseup" properly when users drag the scrollbar of an element, so this works around that issue.
          self.isPressed && onRelease(null);
        }
      }, vars)); //a bug in many Android devices' stock browser causes scrollTop to get forced back to 0 after it is altered via JS, so we set overflow to "hidden" on mobile/touch devices (they hide the scroll bar anyway). That works around the bug. (This bug is discussed at https://code.google.com/p/android/issues/detail?id=19625)

      target.style.overflowY = allowY && !_isTouchDevice ? "auto" : "hidden";
      target.style.overflowX = allowX && !_isTouchDevice ? "auto" : "hidden";
      target = scrollProxy.content;
    }

    if (rotationMode) {
      killProps.rotation = 1;
    } else {
      if (allowX) {
        killProps[xProp] = 1;
      }

      if (allowY) {
        killProps[yProp] = 1;
      }
    }

    gsCache.force3D = "force3D" in vars ? vars.force3D : true; //otherwise, normal dragging would be in 2D and then as soon as it's released and there's an inertia tween, it'd jump to 3D which can create an initial jump due to the work the browser must to do layerize it.

    _this2.enable();

    return _this2;
  }

  Draggable.register = function register(core) {
    gsap = core;

    _initCore();
  };

  Draggable.create = function create(targets, vars) {
    _coreInitted || _initCore(true);
    return _toArray(targets).map(function (target) {
      return new Draggable(target, vars);
    });
  };

  Draggable.get = function get(target) {
    return _lookup[(_toArray(target)[0] || {})._gsDragID];
  };

  Draggable.timeSinceDrag = function timeSinceDrag() {
    return (_getTime() - _lastDragTime) / 1000;
  };

  Draggable.hitTest = function hitTest(obj1, obj2, threshold) {
    if (obj1 === obj2) {
      return false;
    }

    var r1 = _parseRect(obj1),
        r2 = _parseRect(obj2),
        top = r1.top,
        left = r1.left,
        right = r1.right,
        bottom = r1.bottom,
        width = r1.width,
        height = r1.height,
        isOutside = r2.left > right || r2.right < left || r2.top > bottom || r2.bottom < top,
        overlap,
        area,
        isRatio;

    if (isOutside || !threshold) {
      return !isOutside;
    }

    isRatio = (threshold + "").indexOf("%") !== -1;
    threshold = parseFloat(threshold) || 0;
    overlap = {
      left: Math.max(left, r2.left),
      top: Math.max(top, r2.top)
    };
    overlap.width = Math.min(right, r2.right) - overlap.left;
    overlap.height = Math.min(bottom, r2.bottom) - overlap.top;

    if (overlap.width < 0 || overlap.height < 0) {
      return false;
    }

    if (isRatio) {
      threshold *= 0.01;
      area = overlap.width * overlap.height;
      return area >= width * height * threshold || area >= r2.width * r2.height * threshold;
    }

    return overlap.width > threshold && overlap.height > threshold;
  };

  return Draggable;
}(EventDispatcher);

_setDefaults(Draggable.prototype, {
  pointerX: 0,
  pointerY: 0,
  startX: 0,
  startY: 0,
  deltaX: 0,
  deltaY: 0,
  isDragging: false,
  isPressed: false
});

Draggable.zIndex = 1000;
Draggable.version = "3.10.4";
_getGSAP() && gsap.registerPlugin(Draggable);


/***/ }),

/***/ 591:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  "X": () => (/* binding */ MotionPathPlugin)
});

// UNUSED EXPORTS: default

;// CONCATENATED MODULE: ./node_modules/gsap/utils/paths.js
/*!
 * paths 3.10.4
 * https://greensock.com
 *
 * Copyright 2008-2022, GreenSock. All rights reserved.
 * Subject to the terms at https://greensock.com/standard-license or for
 * Club GreenSock members, the agreement issued with that membership.
 * @author: Jack Doyle, jack@greensock.com
*/

/* eslint-disable */
var _svgPathExp = /[achlmqstvz]|(-?\d*\.?\d*(?:e[\-+]?\d+)?)[0-9]/ig,
    _numbersExp = /(?:(-)?\d*\.?\d*(?:e[\-+]?\d+)?)[0-9]/ig,
    _scientific = /[\+\-]?\d*\.?\d+e[\+\-]?\d+/ig,
    _selectorExp = /(^[#\.][a-z]|[a-y][a-z])/i,
    _DEG2RAD = Math.PI / 180,
    _RAD2DEG = 180 / Math.PI,
    _sin = Math.sin,
    _cos = Math.cos,
    _abs = Math.abs,
    _sqrt = Math.sqrt,
    _atan2 = Math.atan2,
    _largeNum = 1e8,
    _isString = function _isString(value) {
  return typeof value === "string";
},
    _isNumber = function _isNumber(value) {
  return typeof value === "number";
},
    _isUndefined = function _isUndefined(value) {
  return typeof value === "undefined";
},
    _temp = {},
    _temp2 = {},
    _roundingNum = 1e5,
    _wrapProgress = function _wrapProgress(progress) {
  return Math.round((progress + _largeNum) % 1 * _roundingNum) / _roundingNum || (progress < 0 ? 0 : 1);
},
    //if progress lands on 1, the % will make it 0 which is why we || 1, but not if it's negative because it makes more sense for motion to end at 0 in that case.
_round = function _round(value) {
  return Math.round(value * _roundingNum) / _roundingNum || 0;
},
    _roundPrecise = function _roundPrecise(value) {
  return Math.round(value * 1e10) / 1e10 || 0;
},
    _splitSegment = function _splitSegment(rawPath, segIndex, i, t) {
  var segment = rawPath[segIndex],
      shift = t === 1 ? 6 : subdivideSegment(segment, i, t);

  if (shift && shift + i + 2 < segment.length) {
    rawPath.splice(segIndex, 0, segment.slice(0, i + shift + 2));
    segment.splice(0, i + shift);
    return 1;
  }
},
    _getSampleIndex = function _getSampleIndex(samples, length, progress) {
  // slightly slower way than doing this (when there's no lookup): segment.lookup[progress < 1 ? ~~(length / segment.minLength) : segment.lookup.length - 1] || 0;
  var l = samples.length,
      i = ~~(progress * l);

  if (samples[i] > length) {
    while (--i && samples[i] > length) {}

    i < 0 && (i = 0);
  } else {
    while (samples[++i] < length && i < l) {}
  }

  return i < l ? i : l - 1;
},
    _reverseRawPath = function _reverseRawPath(rawPath, skipOuter) {
  var i = rawPath.length;
  skipOuter || rawPath.reverse();

  while (i--) {
    rawPath[i].reversed || reverseSegment(rawPath[i]);
  }
},
    _copyMetaData = function _copyMetaData(source, copy) {
  copy.totalLength = source.totalLength;

  if (source.samples) {
    //segment
    copy.samples = source.samples.slice(0);
    copy.lookup = source.lookup.slice(0);
    copy.minLength = source.minLength;
    copy.resolution = source.resolution;
  } else if (source.totalPoints) {
    //rawPath
    copy.totalPoints = source.totalPoints;
  }

  return copy;
},
    //pushes a new segment into a rawPath, but if its starting values match the ending values of the last segment, it'll merge it into that same segment (to reduce the number of segments)
_appendOrMerge = function _appendOrMerge(rawPath, segment) {
  var index = rawPath.length,
      prevSeg = rawPath[index - 1] || [],
      l = prevSeg.length;

  if (index && segment[0] === prevSeg[l - 2] && segment[1] === prevSeg[l - 1]) {
    segment = prevSeg.concat(segment.slice(2));
    index--;
  }

  rawPath[index] = segment;
},
    _bestDistance;
/* TERMINOLOGY
 - RawPath - an array of arrays, one for each Segment. A single RawPath could have multiple "M" commands, defining Segments (paths aren't always connected).
 - Segment - an array containing a sequence of Cubic Bezier coordinates in alternating x, y, x, y format. Starting anchor, then control point 1, control point 2, and ending anchor, then the next control point 1, control point 2, anchor, etc. Uses less memory than an array with a bunch of {x, y} points.
 - Bezier - a single cubic Bezier with a starting anchor, two control points, and an ending anchor.
 - the variable "t" is typically the position along an individual Bezier path (time) and it's NOT linear, meaning it could accelerate/decelerate based on the control points whereas the "p" or "progress" value is linearly mapped to the whole path, so it shouldn't really accelerate/decelerate based on control points. So a progress of 0.2 would be almost exactly 20% along the path. "t" is ONLY in an individual Bezier piece.
 */
//accepts basic selector text, a path instance, a RawPath instance, or a Segment and returns a RawPath (makes it easy to homogenize things). If an element or selector text is passed in, it'll also cache the value so that if it's queried again, it'll just take the path data from there instead of parsing it all over again (as long as the path data itself hasn't changed - it'll check).


function getRawPath(value) {
  value = _isString(value) && _selectorExp.test(value) ? document.querySelector(value) || value : value;
  var e = value.getAttribute ? value : 0,
      rawPath;

  if (e && (value = value.getAttribute("d"))) {
    //implements caching
    if (!e._gsPath) {
      e._gsPath = {};
    }

    rawPath = e._gsPath[value];
    return rawPath && !rawPath._dirty ? rawPath : e._gsPath[value] = stringToRawPath(value);
  }

  return !value ? console.warn("Expecting a <path> element or an SVG path data string") : _isString(value) ? stringToRawPath(value) : _isNumber(value[0]) ? [value] : value;
} //copies a RawPath WITHOUT the length meta data (for speed)

function copyRawPath(rawPath) {
  var a = [],
      i = 0;

  for (; i < rawPath.length; i++) {
    a[i] = _copyMetaData(rawPath[i], rawPath[i].slice(0));
  }

  return _copyMetaData(rawPath, a);
}
function reverseSegment(segment) {
  var i = 0,
      y;
  segment.reverse(); //this will invert the order y, x, y, x so we must flip it back.

  for (; i < segment.length; i += 2) {
    y = segment[i];
    segment[i] = segment[i + 1];
    segment[i + 1] = y;
  }

  segment.reversed = !segment.reversed;
}

var _createPath = function _createPath(e, ignore) {
  var path = document.createElementNS("http://www.w3.org/2000/svg", "path"),
      attr = [].slice.call(e.attributes),
      i = attr.length,
      name;
  ignore = "," + ignore + ",";

  while (--i > -1) {
    name = attr[i].nodeName.toLowerCase(); //in Microsoft Edge, if you don't set the attribute with a lowercase name, it doesn't render correctly! Super weird.

    if (ignore.indexOf("," + name + ",") < 0) {
      path.setAttributeNS(null, name, attr[i].nodeValue);
    }
  }

  return path;
},
    _typeAttrs = {
  rect: "rx,ry,x,y,width,height",
  circle: "r,cx,cy",
  ellipse: "rx,ry,cx,cy",
  line: "x1,x2,y1,y2"
},
    _attrToObj = function _attrToObj(e, attrs) {
  var props = attrs ? attrs.split(",") : [],
      obj = {},
      i = props.length;

  while (--i > -1) {
    obj[props[i]] = +e.getAttribute(props[i]) || 0;
  }

  return obj;
}; //converts an SVG shape like <circle>, <rect>, <polygon>, <polyline>, <ellipse>, etc. to a <path>, swapping it in and copying the attributes to match.


function paths_convertToPath(element, swap) {
  var type = element.tagName.toLowerCase(),
      circ = 0.552284749831,
      data,
      x,
      y,
      r,
      ry,
      path,
      rcirc,
      rycirc,
      points,
      w,
      h,
      x2,
      x3,
      x4,
      x5,
      x6,
      y2,
      y3,
      y4,
      y5,
      y6,
      attr;

  if (type === "path" || !element.getBBox) {
    return element;
  }

  path = _createPath(element, "x,y,width,height,cx,cy,rx,ry,r,x1,x2,y1,y2,points");
  attr = _attrToObj(element, _typeAttrs[type]);

  if (type === "rect") {
    r = attr.rx;
    ry = attr.ry || r;
    x = attr.x;
    y = attr.y;
    w = attr.width - r * 2;
    h = attr.height - ry * 2;

    if (r || ry) {
      //if there are rounded corners, render cubic beziers
      x2 = x + r * (1 - circ);
      x3 = x + r;
      x4 = x3 + w;
      x5 = x4 + r * circ;
      x6 = x4 + r;
      y2 = y + ry * (1 - circ);
      y3 = y + ry;
      y4 = y3 + h;
      y5 = y4 + ry * circ;
      y6 = y4 + ry;
      data = "M" + x6 + "," + y3 + " V" + y4 + " C" + [x6, y5, x5, y6, x4, y6, x4 - (x4 - x3) / 3, y6, x3 + (x4 - x3) / 3, y6, x3, y6, x2, y6, x, y5, x, y4, x, y4 - (y4 - y3) / 3, x, y3 + (y4 - y3) / 3, x, y3, x, y2, x2, y, x3, y, x3 + (x4 - x3) / 3, y, x4 - (x4 - x3) / 3, y, x4, y, x5, y, x6, y2, x6, y3].join(",") + "z";
    } else {
      data = "M" + (x + w) + "," + y + " v" + h + " h" + -w + " v" + -h + " h" + w + "z";
    }
  } else if (type === "circle" || type === "ellipse") {
    if (type === "circle") {
      r = ry = attr.r;
      rycirc = r * circ;
    } else {
      r = attr.rx;
      ry = attr.ry;
      rycirc = ry * circ;
    }

    x = attr.cx;
    y = attr.cy;
    rcirc = r * circ;
    data = "M" + (x + r) + "," + y + " C" + [x + r, y + rycirc, x + rcirc, y + ry, x, y + ry, x - rcirc, y + ry, x - r, y + rycirc, x - r, y, x - r, y - rycirc, x - rcirc, y - ry, x, y - ry, x + rcirc, y - ry, x + r, y - rycirc, x + r, y].join(",") + "z";
  } else if (type === "line") {
    data = "M" + attr.x1 + "," + attr.y1 + " L" + attr.x2 + "," + attr.y2; //previously, we just converted to "Mx,y Lx,y" but Safari has bugs that cause that not to render properly when using a stroke-dasharray that's not fully visible! Using a cubic bezier fixes that issue.
  } else if (type === "polyline" || type === "polygon") {
    points = (element.getAttribute("points") + "").match(_numbersExp) || [];
    x = points.shift();
    y = points.shift();
    data = "M" + x + "," + y + " L" + points.join(",");

    if (type === "polygon") {
      data += "," + x + "," + y + "z";
    }
  }

  path.setAttribute("d", rawPathToString(path._gsRawPath = stringToRawPath(data)));

  if (swap && element.parentNode) {
    element.parentNode.insertBefore(path, element);
    element.parentNode.removeChild(element);
  }

  return path;
} //returns the rotation (in degrees) at a particular progress on a rawPath (the slope of the tangent)

function getRotationAtProgress(rawPath, progress) {
  var d = getProgressData(rawPath, progress >= 1 ? 1 - 1e-9 : progress ? progress : 1e-9);
  return getRotationAtBezierT(d.segment, d.i, d.t);
}

function getRotationAtBezierT(segment, i, t) {
  var a = segment[i],
      b = segment[i + 2],
      c = segment[i + 4],
      x;
  a += (b - a) * t;
  b += (c - b) * t;
  a += (b - a) * t;
  x = b + (c + (segment[i + 6] - c) * t - b) * t - a;
  a = segment[i + 1];
  b = segment[i + 3];
  c = segment[i + 5];
  a += (b - a) * t;
  b += (c - b) * t;
  a += (b - a) * t;
  return _round(_atan2(b + (c + (segment[i + 7] - c) * t - b) * t - a, x) * _RAD2DEG);
}

function sliceRawPath(rawPath, start, end) {
  end = _isUndefined(end) ? 1 : _roundPrecise(end) || 0; // we must round to avoid issues like 4.15 / 8 = 0.8300000000000001 instead of 0.83 or 2.8 / 5 = 0.5599999999999999 instead of 0.56 and if someone is doing a loop like start: 2.8 / 0.5, end: 2.8 / 0.5 + 1.

  start = _roundPrecise(start) || 0;
  var loops = Math.max(0, ~~(_abs(end - start) - 1e-8)),
      path = copyRawPath(rawPath);

  if (start > end) {
    start = 1 - start;
    end = 1 - end;

    _reverseRawPath(path);

    path.totalLength = 0;
  }

  if (start < 0 || end < 0) {
    var offset = Math.abs(~~Math.min(start, end)) + 1;
    start += offset;
    end += offset;
  }

  path.totalLength || cacheRawPathMeasurements(path);
  var wrap = end > 1,
      s = getProgressData(path, start, _temp, true),
      e = getProgressData(path, end, _temp2),
      eSeg = e.segment,
      sSeg = s.segment,
      eSegIndex = e.segIndex,
      sSegIndex = s.segIndex,
      ei = e.i,
      si = s.i,
      sameSegment = sSegIndex === eSegIndex,
      sameBezier = ei === si && sameSegment,
      wrapsBehind,
      sShift,
      eShift,
      i,
      copy,
      totalSegments,
      l,
      j;

  if (wrap || loops) {
    wrapsBehind = eSegIndex < sSegIndex || sameSegment && ei < si || sameBezier && e.t < s.t;

    if (_splitSegment(path, sSegIndex, si, s.t)) {
      sSegIndex++;

      if (!wrapsBehind) {
        eSegIndex++;

        if (sameBezier) {
          e.t = (e.t - s.t) / (1 - s.t);
          ei = 0;
        } else if (sameSegment) {
          ei -= si;
        }
      }
    }

    if (Math.abs(1 - (end - start)) < 1e-5) {
      eSegIndex = sSegIndex - 1;
    } else if (!e.t && eSegIndex) {
      eSegIndex--;
    } else if (_splitSegment(path, eSegIndex, ei, e.t) && wrapsBehind) {
      sSegIndex++;
    }

    if (s.t === 1) {
      sSegIndex = (sSegIndex + 1) % path.length;
    }

    copy = [];
    totalSegments = path.length;
    l = 1 + totalSegments * loops;
    j = sSegIndex;
    l += (totalSegments - sSegIndex + eSegIndex) % totalSegments;

    for (i = 0; i < l; i++) {
      _appendOrMerge(copy, path[j++ % totalSegments]);
    }

    path = copy;
  } else {
    eShift = e.t === 1 ? 6 : subdivideSegment(eSeg, ei, e.t);

    if (start !== end) {
      sShift = subdivideSegment(sSeg, si, sameBezier ? s.t / e.t : s.t);
      sameSegment && (eShift += sShift);
      eSeg.splice(ei + eShift + 2);
      (sShift || si) && sSeg.splice(0, si + sShift);
      i = path.length;

      while (i--) {
        //chop off any extra segments
        (i < sSegIndex || i > eSegIndex) && path.splice(i, 1);
      }
    } else {
      eSeg.angle = getRotationAtBezierT(eSeg, ei + eShift, 0); //record the value before we chop because it'll be impossible to determine the angle after its length is 0!

      ei += eShift;
      s = eSeg[ei];
      e = eSeg[ei + 1];
      eSeg.length = eSeg.totalLength = 0;
      eSeg.totalPoints = path.totalPoints = 8;
      eSeg.push(s, e, s, e, s, e, s, e);
    }
  }

  path.totalLength = 0;
  return path;
} //measures a Segment according to its resolution (so if segment.resolution is 6, for example, it'll take 6 samples equally across each Bezier) and create/populate a "samples" Array that has the length up to each of those sample points (always increasing from the start) as well as a "lookup" array that's broken up according to the smallest distance between 2 samples. This gives us a very fast way of looking up a progress position rather than looping through all the points/Beziers. You can optionally have it only measure a subset, starting at startIndex and going for a specific number of beziers (remember, there are 3 x/y pairs each, for a total of 6 elements for each Bezier). It will also populate a "totalLength" property, but that's not generally super accurate because by default it'll only take 6 samples per Bezier. But for performance reasons, it's perfectly adequate for measuring progress values along the path. If you need a more accurate totalLength, either increase the resolution or use the more advanced bezierToPoints() method which keeps adding points until they don't deviate by more than a certain precision value.

function measureSegment(segment, startIndex, bezierQty) {
  startIndex = startIndex || 0;

  if (!segment.samples) {
    segment.samples = [];
    segment.lookup = [];
  }

  var resolution = ~~segment.resolution || 12,
      inc = 1 / resolution,
      endIndex = bezierQty ? startIndex + bezierQty * 6 + 1 : segment.length,
      x1 = segment[startIndex],
      y1 = segment[startIndex + 1],
      samplesIndex = startIndex ? startIndex / 6 * resolution : 0,
      samples = segment.samples,
      lookup = segment.lookup,
      min = (startIndex ? segment.minLength : _largeNum) || _largeNum,
      prevLength = samples[samplesIndex + bezierQty * resolution - 1],
      length = startIndex ? samples[samplesIndex - 1] : 0,
      i,
      j,
      x4,
      x3,
      x2,
      xd,
      xd1,
      y4,
      y3,
      y2,
      yd,
      yd1,
      inv,
      t,
      lengthIndex,
      l,
      segLength;
  samples.length = lookup.length = 0;

  for (j = startIndex + 2; j < endIndex; j += 6) {
    x4 = segment[j + 4] - x1;
    x3 = segment[j + 2] - x1;
    x2 = segment[j] - x1;
    y4 = segment[j + 5] - y1;
    y3 = segment[j + 3] - y1;
    y2 = segment[j + 1] - y1;
    xd = xd1 = yd = yd1 = 0;

    if (_abs(x4) < .01 && _abs(y4) < .01 && _abs(x2) + _abs(y2) < .01) {
      //dump points that are sufficiently close (basically right on top of each other, making a bezier super tiny or 0 length)
      if (segment.length > 8) {
        segment.splice(j, 6);
        j -= 6;
        endIndex -= 6;
      }
    } else {
      for (i = 1; i <= resolution; i++) {
        t = inc * i;
        inv = 1 - t;
        xd = xd1 - (xd1 = (t * t * x4 + 3 * inv * (t * x3 + inv * x2)) * t);
        yd = yd1 - (yd1 = (t * t * y4 + 3 * inv * (t * y3 + inv * y2)) * t);
        l = _sqrt(yd * yd + xd * xd);

        if (l < min) {
          min = l;
        }

        length += l;
        samples[samplesIndex++] = length;
      }
    }

    x1 += x4;
    y1 += y4;
  }

  if (prevLength) {
    prevLength -= length;

    for (; samplesIndex < samples.length; samplesIndex++) {
      samples[samplesIndex] += prevLength;
    }
  }

  if (samples.length && min) {
    segment.totalLength = segLength = samples[samples.length - 1] || 0;
    segment.minLength = min;

    if (segLength / min < 9999) {
      // if the lookup would require too many values (memory problem), we skip this and instead we use a loop to lookup values directly in the samples Array
      l = lengthIndex = 0;

      for (i = 0; i < segLength; i += min) {
        lookup[l++] = samples[lengthIndex] < i ? ++lengthIndex : lengthIndex;
      }
    }
  } else {
    segment.totalLength = samples[0] = 0;
  }

  return startIndex ? length - samples[startIndex / 2 - 1] : length;
}

function cacheRawPathMeasurements(rawPath, resolution) {
  var pathLength, points, i;

  for (i = pathLength = points = 0; i < rawPath.length; i++) {
    rawPath[i].resolution = ~~resolution || 12; //steps per Bezier curve (anchor, 2 control points, to anchor)

    points += rawPath[i].length;
    pathLength += measureSegment(rawPath[i]);
  }

  rawPath.totalPoints = points;
  rawPath.totalLength = pathLength;
  return rawPath;
} //divide segment[i] at position t (value between 0 and 1, progress along that particular cubic bezier segment that starts at segment[i]). Returns how many elements were spliced into the segment array (either 0 or 6)

function subdivideSegment(segment, i, t) {
  if (t <= 0 || t >= 1) {
    return 0;
  }

  var ax = segment[i],
      ay = segment[i + 1],
      cp1x = segment[i + 2],
      cp1y = segment[i + 3],
      cp2x = segment[i + 4],
      cp2y = segment[i + 5],
      bx = segment[i + 6],
      by = segment[i + 7],
      x1a = ax + (cp1x - ax) * t,
      x2 = cp1x + (cp2x - cp1x) * t,
      y1a = ay + (cp1y - ay) * t,
      y2 = cp1y + (cp2y - cp1y) * t,
      x1 = x1a + (x2 - x1a) * t,
      y1 = y1a + (y2 - y1a) * t,
      x2a = cp2x + (bx - cp2x) * t,
      y2a = cp2y + (by - cp2y) * t;
  x2 += (x2a - x2) * t;
  y2 += (y2a - y2) * t;
  segment.splice(i + 2, 4, _round(x1a), //first control point
  _round(y1a), _round(x1), //second control point
  _round(y1), _round(x1 + (x2 - x1) * t), //new fabricated anchor on line
  _round(y1 + (y2 - y1) * t), _round(x2), //third control point
  _round(y2), _round(x2a), //fourth control point
  _round(y2a));
  segment.samples && segment.samples.splice(i / 6 * segment.resolution | 0, 0, 0, 0, 0, 0, 0, 0);
  return 6;
} // returns an object {path, segment, segIndex, i, t}

function getProgressData(rawPath, progress, decoratee, pushToNextIfAtEnd) {
  decoratee = decoratee || {};
  rawPath.totalLength || cacheRawPathMeasurements(rawPath);

  if (progress < 0 || progress > 1) {
    progress = _wrapProgress(progress);
  }

  var segIndex = 0,
      segment = rawPath[0],
      samples,
      resolution,
      length,
      min,
      max,
      i,
      t;

  if (!progress) {
    t = i = segIndex = 0;
    segment = rawPath[0];
  } else if (progress === 1) {
    t = 1;
    segIndex = rawPath.length - 1;
    segment = rawPath[segIndex];
    i = segment.length - 8;
  } else {
    if (rawPath.length > 1) {
      //speed optimization: most of the time, there's only one segment so skip the recursion.
      length = rawPath.totalLength * progress;
      max = i = 0;

      while ((max += rawPath[i++].totalLength) < length) {
        segIndex = i;
      }

      segment = rawPath[segIndex];
      min = max - segment.totalLength;
      progress = (length - min) / (max - min) || 0;
    }

    samples = segment.samples;
    resolution = segment.resolution; //how many samples per cubic bezier chunk

    length = segment.totalLength * progress;
    i = segment.lookup.length ? segment.lookup[~~(length / segment.minLength)] || 0 : _getSampleIndex(samples, length, progress);
    min = i ? samples[i - 1] : 0;
    max = samples[i];

    if (max < length) {
      min = max;
      max = samples[++i];
    }

    t = 1 / resolution * ((length - min) / (max - min) + i % resolution);
    i = ~~(i / resolution) * 6;

    if (pushToNextIfAtEnd && t === 1) {
      if (i + 6 < segment.length) {
        i += 6;
        t = 0;
      } else if (segIndex + 1 < rawPath.length) {
        i = t = 0;
        segment = rawPath[++segIndex];
      }
    }
  }

  decoratee.t = t;
  decoratee.i = i;
  decoratee.path = rawPath;
  decoratee.segment = segment;
  decoratee.segIndex = segIndex;
  return decoratee;
}

function getPositionOnPath(rawPath, progress, includeAngle, point) {
  var segment = rawPath[0],
      result = point || {},
      samples,
      resolution,
      length,
      min,
      max,
      i,
      t,
      a,
      inv;

  if (progress < 0 || progress > 1) {
    progress = _wrapProgress(progress);
  }

  if (rawPath.length > 1) {
    //speed optimization: most of the time, there's only one segment so skip the recursion.
    length = rawPath.totalLength * progress;
    max = i = 0;

    while ((max += rawPath[i++].totalLength) < length) {
      segment = rawPath[i];
    }

    min = max - segment.totalLength;
    progress = (length - min) / (max - min) || 0;
  }

  samples = segment.samples;
  resolution = segment.resolution;
  length = segment.totalLength * progress;
  i = segment.lookup.length ? segment.lookup[progress < 1 ? ~~(length / segment.minLength) : segment.lookup.length - 1] || 0 : _getSampleIndex(samples, length, progress);
  min = i ? samples[i - 1] : 0;
  max = samples[i];

  if (max < length) {
    min = max;
    max = samples[++i];
  }

  t = 1 / resolution * ((length - min) / (max - min) + i % resolution) || 0;
  inv = 1 - t;
  i = ~~(i / resolution) * 6;
  a = segment[i];
  result.x = _round((t * t * (segment[i + 6] - a) + 3 * inv * (t * (segment[i + 4] - a) + inv * (segment[i + 2] - a))) * t + a);
  result.y = _round((t * t * (segment[i + 7] - (a = segment[i + 1])) + 3 * inv * (t * (segment[i + 5] - a) + inv * (segment[i + 3] - a))) * t + a);

  if (includeAngle) {
    result.angle = segment.totalLength ? getRotationAtBezierT(segment, i, t >= 1 ? 1 - 1e-9 : t ? t : 1e-9) : segment.angle || 0;
  }

  return result;
} //applies a matrix transform to RawPath (or a segment in a RawPath) and returns whatever was passed in (it transforms the values in the array(s), not a copy).

function transformRawPath(rawPath, a, b, c, d, tx, ty) {
  var j = rawPath.length,
      segment,
      l,
      i,
      x,
      y;

  while (--j > -1) {
    segment = rawPath[j];
    l = segment.length;

    for (i = 0; i < l; i += 2) {
      x = segment[i];
      y = segment[i + 1];
      segment[i] = x * a + y * c + tx;
      segment[i + 1] = x * b + y * d + ty;
    }
  }

  rawPath._dirty = 1;
  return rawPath;
} // translates SVG arc data into a segment (cubic beziers). Angle is in degrees.

function arcToSegment(lastX, lastY, rx, ry, angle, largeArcFlag, sweepFlag, x, y) {
  if (lastX === x && lastY === y) {
    return;
  }

  rx = _abs(rx);
  ry = _abs(ry);

  var angleRad = angle % 360 * _DEG2RAD,
      cosAngle = _cos(angleRad),
      sinAngle = _sin(angleRad),
      PI = Math.PI,
      TWOPI = PI * 2,
      dx2 = (lastX - x) / 2,
      dy2 = (lastY - y) / 2,
      x1 = cosAngle * dx2 + sinAngle * dy2,
      y1 = -sinAngle * dx2 + cosAngle * dy2,
      x1_sq = x1 * x1,
      y1_sq = y1 * y1,
      radiiCheck = x1_sq / (rx * rx) + y1_sq / (ry * ry);

  if (radiiCheck > 1) {
    rx = _sqrt(radiiCheck) * rx;
    ry = _sqrt(radiiCheck) * ry;
  }

  var rx_sq = rx * rx,
      ry_sq = ry * ry,
      sq = (rx_sq * ry_sq - rx_sq * y1_sq - ry_sq * x1_sq) / (rx_sq * y1_sq + ry_sq * x1_sq);

  if (sq < 0) {
    sq = 0;
  }

  var coef = (largeArcFlag === sweepFlag ? -1 : 1) * _sqrt(sq),
      cx1 = coef * (rx * y1 / ry),
      cy1 = coef * -(ry * x1 / rx),
      sx2 = (lastX + x) / 2,
      sy2 = (lastY + y) / 2,
      cx = sx2 + (cosAngle * cx1 - sinAngle * cy1),
      cy = sy2 + (sinAngle * cx1 + cosAngle * cy1),
      ux = (x1 - cx1) / rx,
      uy = (y1 - cy1) / ry,
      vx = (-x1 - cx1) / rx,
      vy = (-y1 - cy1) / ry,
      temp = ux * ux + uy * uy,
      angleStart = (uy < 0 ? -1 : 1) * Math.acos(ux / _sqrt(temp)),
      angleExtent = (ux * vy - uy * vx < 0 ? -1 : 1) * Math.acos((ux * vx + uy * vy) / _sqrt(temp * (vx * vx + vy * vy)));

  isNaN(angleExtent) && (angleExtent = PI); //rare edge case. Math.cos(-1) is NaN.

  if (!sweepFlag && angleExtent > 0) {
    angleExtent -= TWOPI;
  } else if (sweepFlag && angleExtent < 0) {
    angleExtent += TWOPI;
  }

  angleStart %= TWOPI;
  angleExtent %= TWOPI;

  var segments = Math.ceil(_abs(angleExtent) / (TWOPI / 4)),
      rawPath = [],
      angleIncrement = angleExtent / segments,
      controlLength = 4 / 3 * _sin(angleIncrement / 2) / (1 + _cos(angleIncrement / 2)),
      ma = cosAngle * rx,
      mb = sinAngle * rx,
      mc = sinAngle * -ry,
      md = cosAngle * ry,
      i;

  for (i = 0; i < segments; i++) {
    angle = angleStart + i * angleIncrement;
    x1 = _cos(angle);
    y1 = _sin(angle);
    ux = _cos(angle += angleIncrement);
    uy = _sin(angle);
    rawPath.push(x1 - controlLength * y1, y1 + controlLength * x1, ux + controlLength * uy, uy - controlLength * ux, ux, uy);
  } //now transform according to the actual size of the ellipse/arc (the beziers were noramlized, between 0 and 1 on a circle).


  for (i = 0; i < rawPath.length; i += 2) {
    x1 = rawPath[i];
    y1 = rawPath[i + 1];
    rawPath[i] = x1 * ma + y1 * mc + cx;
    rawPath[i + 1] = x1 * mb + y1 * md + cy;
  }

  rawPath[i - 2] = x; //always set the end to exactly where it's supposed to be

  rawPath[i - 1] = y;
  return rawPath;
} //Spits back a RawPath with absolute coordinates. Each segment starts with a "moveTo" command (x coordinate, then y) and then 2 control points (x, y, x, y), then anchor. The goal is to minimize memory and maximize speed.


function stringToRawPath(d) {
  var a = (d + "").replace(_scientific, function (m) {
    var n = +m;
    return n < 0.0001 && n > -0.0001 ? 0 : n;
  }).match(_svgPathExp) || [],
      //some authoring programs spit out very small numbers in scientific notation like "1e-5", so make sure we round that down to 0 first.
  path = [],
      relativeX = 0,
      relativeY = 0,
      twoThirds = 2 / 3,
      elements = a.length,
      points = 0,
      errorMessage = "ERROR: malformed path: " + d,
      i,
      j,
      x,
      y,
      command,
      isRelative,
      segment,
      startX,
      startY,
      difX,
      difY,
      beziers,
      prevCommand,
      flag1,
      flag2,
      line = function line(sx, sy, ex, ey) {
    difX = (ex - sx) / 3;
    difY = (ey - sy) / 3;
    segment.push(sx + difX, sy + difY, ex - difX, ey - difY, ex, ey);
  };

  if (!d || !isNaN(a[0]) || isNaN(a[1])) {
    console.log(errorMessage);
    return path;
  }

  for (i = 0; i < elements; i++) {
    prevCommand = command;

    if (isNaN(a[i])) {
      command = a[i].toUpperCase();
      isRelative = command !== a[i]; //lower case means relative
    } else {
      //commands like "C" can be strung together without any new command characters between.
      i--;
    }

    x = +a[i + 1];
    y = +a[i + 2];

    if (isRelative) {
      x += relativeX;
      y += relativeY;
    }

    if (!i) {
      startX = x;
      startY = y;
    } // "M" (move)


    if (command === "M") {
      if (segment) {
        if (segment.length < 8) {
          //if the path data was funky and just had a M with no actual drawing anywhere, skip it.
          path.length -= 1;
        } else {
          points += segment.length;
        }
      }

      relativeX = startX = x;
      relativeY = startY = y;
      segment = [x, y];
      path.push(segment);
      i += 2;
      command = "L"; //an "M" with more than 2 values gets interpreted as "lineTo" commands ("L").
      // "C" (cubic bezier)
    } else if (command === "C") {
      if (!segment) {
        segment = [0, 0];
      }

      if (!isRelative) {
        relativeX = relativeY = 0;
      } //note: "*1" is just a fast/short way to cast the value as a Number. WAAAY faster in Chrome, slightly slower in Firefox.


      segment.push(x, y, relativeX + a[i + 3] * 1, relativeY + a[i + 4] * 1, relativeX += a[i + 5] * 1, relativeY += a[i + 6] * 1);
      i += 6; // "S" (continuation of cubic bezier)
    } else if (command === "S") {
      difX = relativeX;
      difY = relativeY;

      if (prevCommand === "C" || prevCommand === "S") {
        difX += relativeX - segment[segment.length - 4];
        difY += relativeY - segment[segment.length - 3];
      }

      if (!isRelative) {
        relativeX = relativeY = 0;
      }

      segment.push(difX, difY, x, y, relativeX += a[i + 3] * 1, relativeY += a[i + 4] * 1);
      i += 4; // "Q" (quadratic bezier)
    } else if (command === "Q") {
      difX = relativeX + (x - relativeX) * twoThirds;
      difY = relativeY + (y - relativeY) * twoThirds;

      if (!isRelative) {
        relativeX = relativeY = 0;
      }

      relativeX += a[i + 3] * 1;
      relativeY += a[i + 4] * 1;
      segment.push(difX, difY, relativeX + (x - relativeX) * twoThirds, relativeY + (y - relativeY) * twoThirds, relativeX, relativeY);
      i += 4; // "T" (continuation of quadratic bezier)
    } else if (command === "T") {
      difX = relativeX - segment[segment.length - 4];
      difY = relativeY - segment[segment.length - 3];
      segment.push(relativeX + difX, relativeY + difY, x + (relativeX + difX * 1.5 - x) * twoThirds, y + (relativeY + difY * 1.5 - y) * twoThirds, relativeX = x, relativeY = y);
      i += 2; // "H" (horizontal line)
    } else if (command === "H") {
      line(relativeX, relativeY, relativeX = x, relativeY);
      i += 1; // "V" (vertical line)
    } else if (command === "V") {
      //adjust values because the first (and only one) isn't x in this case, it's y.
      line(relativeX, relativeY, relativeX, relativeY = x + (isRelative ? relativeY - relativeX : 0));
      i += 1; // "L" (line) or "Z" (close)
    } else if (command === "L" || command === "Z") {
      if (command === "Z") {
        x = startX;
        y = startY;
        segment.closed = true;
      }

      if (command === "L" || _abs(relativeX - x) > 0.5 || _abs(relativeY - y) > 0.5) {
        line(relativeX, relativeY, x, y);

        if (command === "L") {
          i += 2;
        }
      }

      relativeX = x;
      relativeY = y; // "A" (arc)
    } else if (command === "A") {
      flag1 = a[i + 4];
      flag2 = a[i + 5];
      difX = a[i + 6];
      difY = a[i + 7];
      j = 7;

      if (flag1.length > 1) {
        // for cases when the flags are merged, like "a8 8 0 018 8" (the 0 and 1 flags are WITH the x value of 8, but it could also be "a8 8 0 01-8 8" so it may include x or not)
        if (flag1.length < 3) {
          difY = difX;
          difX = flag2;
          j--;
        } else {
          difY = flag2;
          difX = flag1.substr(2);
          j -= 2;
        }

        flag2 = flag1.charAt(1);
        flag1 = flag1.charAt(0);
      }

      beziers = arcToSegment(relativeX, relativeY, +a[i + 1], +a[i + 2], +a[i + 3], +flag1, +flag2, (isRelative ? relativeX : 0) + difX * 1, (isRelative ? relativeY : 0) + difY * 1);
      i += j;

      if (beziers) {
        for (j = 0; j < beziers.length; j++) {
          segment.push(beziers[j]);
        }
      }

      relativeX = segment[segment.length - 2];
      relativeY = segment[segment.length - 1];
    } else {
      console.log(errorMessage);
    }
  }

  i = segment.length;

  if (i < 6) {
    //in case there's odd SVG like a M0,0 command at the very end.
    path.pop();
    i = 0;
  } else if (segment[0] === segment[i - 2] && segment[1] === segment[i - 1]) {
    segment.closed = true;
  }

  path.totalPoints = points + i;
  return path;
} //populates the points array in alternating x/y values (like [x, y, x, y...] instead of individual point objects [{x, y}, {x, y}...] to conserve memory and stay in line with how we're handling segment arrays

function bezierToPoints(x1, y1, x2, y2, x3, y3, x4, y4, threshold, points, index) {
  var x12 = (x1 + x2) / 2,
      y12 = (y1 + y2) / 2,
      x23 = (x2 + x3) / 2,
      y23 = (y2 + y3) / 2,
      x34 = (x3 + x4) / 2,
      y34 = (y3 + y4) / 2,
      x123 = (x12 + x23) / 2,
      y123 = (y12 + y23) / 2,
      x234 = (x23 + x34) / 2,
      y234 = (y23 + y34) / 2,
      x1234 = (x123 + x234) / 2,
      y1234 = (y123 + y234) / 2,
      dx = x4 - x1,
      dy = y4 - y1,
      d2 = _abs((x2 - x4) * dy - (y2 - y4) * dx),
      d3 = _abs((x3 - x4) * dy - (y3 - y4) * dx),
      length;

  if (!points) {
    points = [x1, y1, x4, y4];
    index = 2;
  }

  points.splice(index || points.length - 2, 0, x1234, y1234);

  if ((d2 + d3) * (d2 + d3) > threshold * (dx * dx + dy * dy)) {
    length = points.length;
    bezierToPoints(x1, y1, x12, y12, x123, y123, x1234, y1234, threshold, points, index);
    bezierToPoints(x1234, y1234, x234, y234, x34, y34, x4, y4, threshold, points, index + 2 + (points.length - length));
  }

  return points;
}
/*
function getAngleBetweenPoints(x0, y0, x1, y1, x2, y2) { //angle between 3 points in radians
	var dx1 = x1 - x0,
		dy1 = y1 - y0,
		dx2 = x2 - x1,
		dy2 = y2 - y1,
		dx3 = x2 - x0,
		dy3 = y2 - y0,
		a = dx1 * dx1 + dy1 * dy1,
		b = dx2 * dx2 + dy2 * dy2,
		c = dx3 * dx3 + dy3 * dy3;
	return Math.acos( (a + b - c) / _sqrt(4 * a * b) );
},
*/
//pointsToSegment() doesn't handle flat coordinates (where y is always 0) the way we need (the resulting control points are always right on top of the anchors), so this function basically makes the control points go directly up and down, varying in length based on the curviness (more curvy, further control points)

function flatPointsToSegment(points, curviness) {
  if (curviness === void 0) {
    curviness = 1;
  }

  var x = points[0],
      y = 0,
      segment = [x, y],
      i = 2;

  for (; i < points.length; i += 2) {
    segment.push(x, y, points[i], y = (points[i] - x) * curviness / 2, x = points[i], -y);
  }

  return segment;
} //points is an array of x/y points, like [x, y, x, y, x, y]

function pointsToSegment(points, curviness) {
  //points = simplifyPoints(points, tolerance);
  _abs(points[0] - points[2]) < 1e-4 && _abs(points[1] - points[3]) < 1e-4 && (points = points.slice(2)); // if the first two points are super close, dump the first one.

  var l = points.length - 2,
      x = +points[0],
      y = +points[1],
      nextX = +points[2],
      nextY = +points[3],
      segment = [x, y, x, y],
      dx2 = nextX - x,
      dy2 = nextY - y,
      closed = Math.abs(points[l] - x) < 0.001 && Math.abs(points[l + 1] - y) < 0.001,
      prevX,
      prevY,
      i,
      dx1,
      dy1,
      r1,
      r2,
      r3,
      tl,
      mx1,
      mx2,
      mxm,
      my1,
      my2,
      mym;

  if (closed) {
    // if the start and end points are basically on top of each other, close the segment by adding the 2nd point to the end, and the 2nd-to-last point to the beginning (we'll remove them at the end, but this allows the curvature to look perfect)
    points.push(nextX, nextY);
    nextX = x;
    nextY = y;
    x = points[l - 2];
    y = points[l - 1];
    points.unshift(x, y);
    l += 4;
  }

  curviness = curviness || curviness === 0 ? +curviness : 1;

  for (i = 2; i < l; i += 2) {
    prevX = x;
    prevY = y;
    x = nextX;
    y = nextY;
    nextX = +points[i + 2];
    nextY = +points[i + 3];

    if (x === nextX && y === nextY) {
      continue;
    }

    dx1 = dx2;
    dy1 = dy2;
    dx2 = nextX - x;
    dy2 = nextY - y;
    r1 = _sqrt(dx1 * dx1 + dy1 * dy1); // r1, r2, and r3 correlate x and y (and z in the future). Basically 2D or 3D hypotenuse

    r2 = _sqrt(dx2 * dx2 + dy2 * dy2);
    r3 = _sqrt(Math.pow(dx2 / r2 + dx1 / r1, 2) + Math.pow(dy2 / r2 + dy1 / r1, 2));
    tl = (r1 + r2) * curviness * 0.25 / r3;
    mx1 = x - (x - prevX) * (r1 ? tl / r1 : 0);
    mx2 = x + (nextX - x) * (r2 ? tl / r2 : 0);
    mxm = x - (mx1 + ((mx2 - mx1) * (r1 * 3 / (r1 + r2) + 0.5) / 4 || 0));
    my1 = y - (y - prevY) * (r1 ? tl / r1 : 0);
    my2 = y + (nextY - y) * (r2 ? tl / r2 : 0);
    mym = y - (my1 + ((my2 - my1) * (r1 * 3 / (r1 + r2) + 0.5) / 4 || 0));

    if (x !== prevX || y !== prevY) {
      segment.push(_round(mx1 + mxm), // first control point
      _round(my1 + mym), _round(x), // anchor
      _round(y), _round(mx2 + mxm), // second control point
      _round(my2 + mym));
    }
  }

  x !== nextX || y !== nextY || segment.length < 4 ? segment.push(_round(nextX), _round(nextY), _round(nextX), _round(nextY)) : segment.length -= 2;

  if (segment.length === 2) {
    // only one point!
    segment.push(x, y, x, y, x, y);
  } else if (closed) {
    segment.splice(0, 6);
    segment.length = segment.length - 6;
  }

  return segment;
} //returns the squared distance between an x/y coordinate and a segment between x1/y1 and x2/y2

function pointToSegDist(x, y, x1, y1, x2, y2) {
  var dx = x2 - x1,
      dy = y2 - y1,
      t;

  if (dx || dy) {
    t = ((x - x1) * dx + (y - y1) * dy) / (dx * dx + dy * dy);

    if (t > 1) {
      x1 = x2;
      y1 = y2;
    } else if (t > 0) {
      x1 += dx * t;
      y1 += dy * t;
    }
  }

  return Math.pow(x - x1, 2) + Math.pow(y - y1, 2);
}

function simplifyStep(points, first, last, tolerance, simplified) {
  var maxSqDist = tolerance,
      firstX = points[first],
      firstY = points[first + 1],
      lastX = points[last],
      lastY = points[last + 1],
      index,
      i,
      d;

  for (i = first + 2; i < last; i += 2) {
    d = pointToSegDist(points[i], points[i + 1], firstX, firstY, lastX, lastY);

    if (d > maxSqDist) {
      index = i;
      maxSqDist = d;
    }
  }

  if (maxSqDist > tolerance) {
    index - first > 2 && simplifyStep(points, first, index, tolerance, simplified);
    simplified.push(points[index], points[index + 1]);
    last - index > 2 && simplifyStep(points, index, last, tolerance, simplified);
  }
} //points is an array of x/y values like [x, y, x, y, x, y]


function simplifyPoints(points, tolerance) {
  var prevX = parseFloat(points[0]),
      prevY = parseFloat(points[1]),
      temp = [prevX, prevY],
      l = points.length - 2,
      i,
      x,
      y,
      dx,
      dy,
      result,
      last;
  tolerance = Math.pow(tolerance || 1, 2);

  for (i = 2; i < l; i += 2) {
    x = parseFloat(points[i]);
    y = parseFloat(points[i + 1]);
    dx = prevX - x;
    dy = prevY - y;

    if (dx * dx + dy * dy > tolerance) {
      temp.push(x, y);
      prevX = x;
      prevY = y;
    }
  }

  temp.push(parseFloat(points[l]), parseFloat(points[l + 1]));
  last = temp.length - 2;
  result = [temp[0], temp[1]];
  simplifyStep(temp, 0, last, tolerance, result);
  result.push(temp[last], temp[last + 1]);
  return result;
}

function getClosestProgressOnBezier(iterations, px, py, start, end, slices, x0, y0, x1, y1, x2, y2, x3, y3) {
  var inc = (end - start) / slices,
      best = 0,
      t = start,
      x,
      y,
      d,
      dx,
      dy,
      inv;
  _bestDistance = _largeNum;

  while (t <= end) {
    inv = 1 - t;
    x = inv * inv * inv * x0 + 3 * inv * inv * t * x1 + 3 * inv * t * t * x2 + t * t * t * x3;
    y = inv * inv * inv * y0 + 3 * inv * inv * t * y1 + 3 * inv * t * t * y2 + t * t * t * y3;
    dx = x - px;
    dy = y - py;
    d = dx * dx + dy * dy;

    if (d < _bestDistance) {
      _bestDistance = d;
      best = t;
    }

    t += inc;
  }

  return iterations > 1 ? getClosestProgressOnBezier(iterations - 1, px, py, Math.max(best - inc, 0), Math.min(best + inc, 1), slices, x0, y0, x1, y1, x2, y2, x3, y3) : best;
}

function getClosestData(rawPath, x, y, slices) {
  //returns an object with the closest j, i, and t (j is the segment index, i is the index of the point in that segment, and t is the time/progress along that bezier)
  var closest = {
    j: 0,
    i: 0,
    t: 0
  },
      bestDistance = _largeNum,
      i,
      j,
      t,
      segment;

  for (j = 0; j < rawPath.length; j++) {
    segment = rawPath[j];

    for (i = 0; i < segment.length; i += 6) {
      t = getClosestProgressOnBezier(1, x, y, 0, 1, slices || 20, segment[i], segment[i + 1], segment[i + 2], segment[i + 3], segment[i + 4], segment[i + 5], segment[i + 6], segment[i + 7]);

      if (bestDistance > _bestDistance) {
        bestDistance = _bestDistance;
        closest.j = j;
        closest.i = i;
        closest.t = t;
      }
    }
  }

  return closest;
} //subdivide a Segment closest to a specific x,y coordinate

function subdivideSegmentNear(x, y, segment, slices, iterations) {
  var l = segment.length,
      bestDistance = _largeNum,
      bestT = 0,
      bestSegmentIndex = 0,
      t,
      i;
  slices = slices || 20;
  iterations = iterations || 3;

  for (i = 0; i < l; i += 6) {
    t = getClosestProgressOnBezier(1, x, y, 0, 1, slices, segment[i], segment[i + 1], segment[i + 2], segment[i + 3], segment[i + 4], segment[i + 5], segment[i + 6], segment[i + 7]);

    if (bestDistance > _bestDistance) {
      bestDistance = _bestDistance;
      bestT = t;
      bestSegmentIndex = i;
    }
  }

  t = getClosestProgressOnBezier(iterations, x, y, bestT - 0.05, bestT + 0.05, slices, segment[bestSegmentIndex], segment[bestSegmentIndex + 1], segment[bestSegmentIndex + 2], segment[bestSegmentIndex + 3], segment[bestSegmentIndex + 4], segment[bestSegmentIndex + 5], segment[bestSegmentIndex + 6], segment[bestSegmentIndex + 7]);
  subdivideSegment(segment, bestSegmentIndex, t);
  return bestSegmentIndex + 6;
}
/*
Takes any of the following and converts it to an all Cubic Bezier SVG data string:
- A <path> data string like "M0,0 L2,4 v20,15 H100"
- A RawPath, like [[x, y, x, y, x, y, x, y][[x, y, x, y, x, y, x, y]]
- A Segment, like [x, y, x, y, x, y, x, y]

Note: all numbers are rounded down to the closest 0.001 to minimize memory, maximize speed, and avoid odd numbers like 1e-13
*/

function rawPathToString(rawPath) {
  if (_isNumber(rawPath[0])) {
    //in case a segment is passed in instead
    rawPath = [rawPath];
  }

  var result = "",
      l = rawPath.length,
      sl,
      s,
      i,
      segment;

  for (s = 0; s < l; s++) {
    segment = rawPath[s];
    result += "M" + _round(segment[0]) + "," + _round(segment[1]) + " C";
    sl = segment.length;

    for (i = 2; i < sl; i++) {
      result += _round(segment[i++]) + "," + _round(segment[i++]) + " " + _round(segment[i++]) + "," + _round(segment[i++]) + " " + _round(segment[i++]) + "," + _round(segment[i]) + " ";
    }

    if (segment.closed) {
      result += "z";
    }
  }

  return result;
}
/*
// takes a segment with coordinates [x, y, x, y, ...] and converts the control points into angles and lengths [x, y, angle, length, angle, length, x, y, angle, length, ...] so that it animates more cleanly and avoids odd breaks/kinks. For example, if you animate from 1 o'clock to 6 o'clock, it'd just go directly/linearly rather than around. So the length would be very short in the middle of the tween.
export function cpCoordsToAngles(segment, copy) {
	var result = copy ? segment.slice(0) : segment,
		x, y, i;
	for (i = 0; i < segment.length; i+=6) {
		x = segment[i+2] - segment[i];
		y = segment[i+3] - segment[i+1];
		result[i+2] = Math.atan2(y, x);
		result[i+3] = Math.sqrt(x * x + y * y);
		x = segment[i+6] - segment[i+4];
		y = segment[i+7] - segment[i+5];
		result[i+4] = Math.atan2(y, x);
		result[i+5] = Math.sqrt(x * x + y * y);
	}
	return result;
}

// takes a segment that was converted with cpCoordsToAngles() to have angles and lengths instead of coordinates for the control points, and converts it BACK into coordinates.
export function cpAnglesToCoords(segment, copy) {
	var result = copy ? segment.slice(0) : segment,
		length = segment.length,
		rnd = 1000,
		angle, l, i, j;
	for (i = 0; i < length; i+=6) {
		angle = segment[i+2];
		l = segment[i+3]; //length
		result[i+2] = (((segment[i] + Math.cos(angle) * l) * rnd) | 0) / rnd;
		result[i+3] = (((segment[i+1] + Math.sin(angle) * l) * rnd) | 0) / rnd;
		angle = segment[i+4];
		l = segment[i+5]; //length
		result[i+4] = (((segment[i+6] - Math.cos(angle) * l) * rnd) | 0) / rnd;
		result[i+5] = (((segment[i+7] - Math.sin(angle) * l) * rnd) | 0) / rnd;
	}
	return result;
}

//adds an "isSmooth" array to each segment and populates it with a boolean value indicating whether or not it's smooth (the control points have basically the same slope). For any smooth control points, it converts the coordinates into angle (x, in radians) and length (y) and puts them into the same index value in a smoothData array.
export function populateSmoothData(rawPath) {
	let j = rawPath.length,
		smooth, segment, x, y, x2, y2, i, l, a, a2, isSmooth, smoothData;
	while (--j > -1) {
		segment = rawPath[j];
		isSmooth = segment.isSmooth = segment.isSmooth || [0, 0, 0, 0];
		smoothData = segment.smoothData = segment.smoothData || [0, 0, 0, 0];
		isSmooth.length = 4;
		l = segment.length - 2;
		for (i = 6; i < l; i += 6) {
			x = segment[i] - segment[i - 2];
			y = segment[i + 1] - segment[i - 1];
			x2 = segment[i + 2] - segment[i];
			y2 = segment[i + 3] - segment[i + 1];
			a = _atan2(y, x);
			a2 = _atan2(y2, x2);
			smooth = (Math.abs(a - a2) < 0.09);
			if (smooth) {
				smoothData[i - 2] = a;
				smoothData[i + 2] = a2;
				smoothData[i - 1] = _sqrt(x * x + y * y);
				smoothData[i + 3] = _sqrt(x2 * x2 + y2 * y2);
			}
			isSmooth.push(smooth, smooth, 0, 0, smooth, smooth);
		}
		//if the first and last points are identical, check to see if there's a smooth transition. We must handle this a bit differently due to their positions in the array.
		if (segment[l] === segment[0] && segment[l+1] === segment[1]) {
			x = segment[0] - segment[l-2];
			y = segment[1] - segment[l-1];
			x2 = segment[2] - segment[0];
			y2 = segment[3] - segment[1];
			a = _atan2(y, x);
			a2 = _atan2(y2, x2);
			if (Math.abs(a - a2) < 0.09) {
				smoothData[l-2] = a;
				smoothData[2] = a2;
				smoothData[l-1] = _sqrt(x * x + y * y);
				smoothData[3] = _sqrt(x2 * x2 + y2 * y2);
				isSmooth[l-2] = isSmooth[l-1] = true; //don't change indexes 2 and 3 because we'll trigger everything from the END, and this will optimize file size a bit.
			}
		}
	}
	return rawPath;
}
export function pointToScreen(svgElement, point) {
	if (arguments.length < 2) { //by default, take the first set of coordinates in the path as the point
		let rawPath = getRawPath(svgElement);
		point = svgElement.ownerSVGElement.createSVGPoint();
		point.x = rawPath[0][0];
		point.y = rawPath[0][1];
	}
	return point.matrixTransform(svgElement.getScreenCTM());
}

*/
// EXTERNAL MODULE: ./node_modules/gsap/utils/matrix.js
var matrix = __webpack_require__(708);
;// CONCATENATED MODULE: ./node_modules/gsap/MotionPathPlugin.js
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

/*!
 * MotionPathPlugin 3.10.4
 * https://greensock.com
 *
 * @license Copyright 2008-2022, GreenSock. All rights reserved.
 * Subject to the terms at https://greensock.com/standard-license or for
 * Club GreenSock members, the agreement issued with that membership.
 * @author: Jack Doyle, jack@greensock.com
*/

/* eslint-disable */



var _xProps = "x,translateX,left,marginLeft,xPercent".split(","),
    _yProps = "y,translateY,top,marginTop,yPercent".split(","),
    MotionPathPlugin_DEG2RAD = Math.PI / 180,
    gsap,
    PropTween,
    _getUnit,
    _toArray,
    _getGSAP = function _getGSAP() {
  return gsap || typeof window !== "undefined" && (gsap = window.gsap) && gsap.registerPlugin && gsap;
},
    _populateSegmentFromArray = function _populateSegmentFromArray(segment, values, property, mode) {
  //mode: 0 = x but don't fill y yet, 1 = y, 2 = x and fill y with 0.
  var l = values.length,
      si = mode === 2 ? 0 : mode,
      i = 0,
      v;

  for (; i < l; i++) {
    segment[si] = v = parseFloat(values[i][property]);
    mode === 2 && (segment[si + 1] = 0);
    si += 2;
  }

  return segment;
},
    _getPropNum = function _getPropNum(target, prop, unit) {
  return parseFloat(target._gsap.get(target, prop, unit || "px")) || 0;
},
    _relativize = function _relativize(segment) {
  var x = segment[0],
      y = segment[1],
      i;

  for (i = 2; i < segment.length; i += 2) {
    x = segment[i] += x;
    y = segment[i + 1] += y;
  }
},
    // feed in an array of quadratic bezier points like [{x: 0, y: 0}, ...] and it'll convert it to cubic bezier
// _quadToCubic = points => {
// 	let cubic = [],
// 		l = points.length - 1,
// 		i = 1,
// 		a, b, c;
// 	for (; i < l; i+=2) {
// 		a = points[i-1];
// 		b = points[i];
// 		c = points[i+1];
// 		cubic.push(a, {x: (2 * b.x + a.x) / 3, y: (2 * b.y + a.y) / 3}, {x: (2 * b.x + c.x) / 3, y: (2 * b.y + c.y) / 3});
// 	}
// 	cubic.push(points[l]);
// 	return cubic;
// },
_segmentToRawPath = function _segmentToRawPath(plugin, segment, target, x, y, slicer, vars, unitX, unitY) {
  if (vars.type === "cubic") {
    segment = [segment];
  } else {
    vars.fromCurrent !== false && segment.unshift(_getPropNum(target, x, unitX), y ? _getPropNum(target, y, unitY) : 0);
    vars.relative && _relativize(segment);
    var pointFunc = y ? pointsToSegment : flatPointsToSegment;
    segment = [pointFunc(segment, vars.curviness)];
  }

  segment = slicer(_align(segment, target, vars));

  _addDimensionalPropTween(plugin, target, x, segment, "x", unitX);

  y && _addDimensionalPropTween(plugin, target, y, segment, "y", unitY);
  return cacheRawPathMeasurements(segment, vars.resolution || (vars.curviness === 0 ? 20 : 12)); //when curviness is 0, it creates control points right on top of the anchors which makes it more sensitive to resolution, thus we change the default accordingly.
},
    _emptyFunc = function _emptyFunc(v) {
  return v;
},
    _numExp = /[-+\.]*\d+\.?(?:e-|e\+)?\d*/g,
    _originToPoint = function _originToPoint(element, origin, parentMatrix) {
  // origin is an array of normalized values (0-1) in relation to the width/height, so [0.5, 0.5] would be the center. It can also be "auto" in which case it will be the top left unless it's a <path>, when it will start at the beginning of the path itself.
  var m = (0,matrix/* getGlobalMatrix */.M9)(element),
      x = 0,
      y = 0,
      svg;

  if ((element.tagName + "").toLowerCase() === "svg") {
    svg = element.viewBox.baseVal;
    svg.width || (svg = {
      width: +element.getAttribute("width"),
      height: +element.getAttribute("height")
    });
  } else {
    svg = origin && element.getBBox && element.getBBox();
  }

  if (origin && origin !== "auto") {
    x = origin.push ? origin[0] * (svg ? svg.width : element.offsetWidth || 0) : origin.x;
    y = origin.push ? origin[1] * (svg ? svg.height : element.offsetHeight || 0) : origin.y;
  }

  return parentMatrix.apply(x || y ? m.apply({
    x: x,
    y: y
  }) : {
    x: m.e,
    y: m.f
  });
},
    _getAlignMatrix = function _getAlignMatrix(fromElement, toElement, fromOrigin, toOrigin) {
  var parentMatrix = (0,matrix/* getGlobalMatrix */.M9)(fromElement.parentNode, true, true),
      m = parentMatrix.clone().multiply((0,matrix/* getGlobalMatrix */.M9)(toElement)),
      fromPoint = _originToPoint(fromElement, fromOrigin, parentMatrix),
      _originToPoint2 = _originToPoint(toElement, toOrigin, parentMatrix),
      x = _originToPoint2.x,
      y = _originToPoint2.y,
      p;

  m.e = m.f = 0;

  if (toOrigin === "auto" && toElement.getTotalLength && toElement.tagName.toLowerCase() === "path") {
    p = toElement.getAttribute("d").match(_numExp) || [];
    p = m.apply({
      x: +p[0],
      y: +p[1]
    });
    x += p.x;
    y += p.y;
  }

  if (p || toElement.getBBox && fromElement.getBBox && toElement.ownerSVGElement === fromElement.ownerSVGElement) {
    p = m.apply(toElement.getBBox());
    x -= p.x;
    y -= p.y;
  }

  m.e = x - fromPoint.x;
  m.f = y - fromPoint.y;
  return m;
},
    _align = function _align(rawPath, target, _ref) {
  var align = _ref.align,
      matrix = _ref.matrix,
      offsetX = _ref.offsetX,
      offsetY = _ref.offsetY,
      alignOrigin = _ref.alignOrigin;

  var x = rawPath[0][0],
      y = rawPath[0][1],
      curX = _getPropNum(target, "x"),
      curY = _getPropNum(target, "y"),
      alignTarget,
      m,
      p;

  if (!rawPath || !rawPath.length) {
    return getRawPath("M0,0L0,0");
  }

  if (align) {
    if (align === "self" || (alignTarget = _toArray(align)[0] || target) === target) {
      transformRawPath(rawPath, 1, 0, 0, 1, curX - x, curY - y);
    } else {
      if (alignOrigin && alignOrigin[2] !== false) {
        gsap.set(target, {
          transformOrigin: alignOrigin[0] * 100 + "% " + alignOrigin[1] * 100 + "%"
        });
      } else {
        alignOrigin = [_getPropNum(target, "xPercent") / -100, _getPropNum(target, "yPercent") / -100];
      }

      m = _getAlignMatrix(target, alignTarget, alignOrigin, "auto");
      p = m.apply({
        x: x,
        y: y
      });
      transformRawPath(rawPath, m.a, m.b, m.c, m.d, curX + m.e - (p.x - m.e), curY + m.f - (p.y - m.f));
    }
  }

  if (matrix) {
    transformRawPath(rawPath, matrix.a, matrix.b, matrix.c, matrix.d, matrix.e, matrix.f);
  } else if (offsetX || offsetY) {
    transformRawPath(rawPath, 1, 0, 0, 1, offsetX || 0, offsetY || 0);
  }

  return rawPath;
},
    _addDimensionalPropTween = function _addDimensionalPropTween(plugin, target, property, rawPath, pathProperty, forceUnit) {
  var cache = target._gsap,
      harness = cache.harness,
      alias = harness && harness.aliases && harness.aliases[property],
      prop = alias && alias.indexOf(",") < 0 ? alias : property,
      pt = plugin._pt = new PropTween(plugin._pt, target, prop, 0, 0, _emptyFunc, 0, cache.set(target, prop, plugin));
  pt.u = _getUnit(cache.get(target, prop, forceUnit)) || 0;
  pt.path = rawPath;
  pt.pp = pathProperty;

  plugin._props.push(prop);
},
    _sliceModifier = function _sliceModifier(start, end) {
  return function (rawPath) {
    return start || end !== 1 ? sliceRawPath(rawPath, start, end) : rawPath;
  };
};

var MotionPathPlugin = {
  version: "3.10.4",
  name: "motionPath",
  register: function register(core, Plugin, propTween) {
    gsap = core;
    _getUnit = gsap.utils.getUnit;
    _toArray = gsap.utils.toArray;
    PropTween = propTween;
  },
  init: function init(target, vars) {
    if (!gsap) {
      console.warn("Please gsap.registerPlugin(MotionPathPlugin)");
      return false;
    }

    if (!(_typeof(vars) === "object" && !vars.style) || !vars.path) {
      vars = {
        path: vars
      };
    }

    var rawPaths = [],
        _vars = vars,
        path = _vars.path,
        autoRotate = _vars.autoRotate,
        unitX = _vars.unitX,
        unitY = _vars.unitY,
        x = _vars.x,
        y = _vars.y,
        firstObj = path[0],
        slicer = _sliceModifier(vars.start, "end" in vars ? vars.end : 1),
        rawPath,
        p;

    this.rawPaths = rawPaths;
    this.target = target;

    if (this.rotate = autoRotate || autoRotate === 0) {
      //get the rotational data FIRST so that the setTransform() method is called in the correct order in the render() loop - rotation gets set last.
      this.rOffset = parseFloat(autoRotate) || 0;
      this.radians = !!vars.useRadians;
      this.rProp = vars.rotation || "rotation"; // rotation property

      this.rSet = target._gsap.set(target, this.rProp, this); // rotation setter

      this.ru = _getUnit(target._gsap.get(target, this.rProp)) || 0; // rotation units
    }

    if (Array.isArray(path) && !("closed" in path) && typeof firstObj !== "number") {
      for (p in firstObj) {
        if (!x && ~_xProps.indexOf(p)) {
          x = p;
        } else if (!y && ~_yProps.indexOf(p)) {
          y = p;
        }
      }

      if (x && y) {
        //correlated values
        rawPaths.push(_segmentToRawPath(this, _populateSegmentFromArray(_populateSegmentFromArray([], path, x, 0), path, y, 1), target, x, y, slicer, vars, unitX || _getUnit(path[0][x]), unitY || _getUnit(path[0][y])));
      } else {
        x = y = 0;
      }

      for (p in firstObj) {
        p !== x && p !== y && rawPaths.push(_segmentToRawPath(this, _populateSegmentFromArray([], path, p, 2), target, p, 0, slicer, vars, _getUnit(path[0][p])));
      }
    } else {
      rawPath = slicer(_align(getRawPath(vars.path), target, vars));
      cacheRawPathMeasurements(rawPath, vars.resolution);
      rawPaths.push(rawPath);

      _addDimensionalPropTween(this, target, vars.x || "x", rawPath, "x", vars.unitX || "px");

      _addDimensionalPropTween(this, target, vars.y || "y", rawPath, "y", vars.unitY || "px");
    }
  },
  render: function render(ratio, data) {
    var rawPaths = data.rawPaths,
        i = rawPaths.length,
        pt = data._pt;

    if (ratio > 1) {
      ratio = 1;
    } else if (ratio < 0) {
      ratio = 0;
    }

    while (i--) {
      getPositionOnPath(rawPaths[i], ratio, !i && data.rotate, rawPaths[i]);
    }

    while (pt) {
      pt.set(pt.t, pt.p, pt.path[pt.pp] + pt.u, pt.d, ratio);
      pt = pt._next;
    }

    data.rotate && data.rSet(data.target, data.rProp, rawPaths[0].angle * (data.radians ? MotionPathPlugin_DEG2RAD : 1) + data.rOffset + data.ru, data, ratio);
  },
  getLength: function getLength(path) {
    return cacheRawPathMeasurements(getRawPath(path)).totalLength;
  },
  sliceRawPath: sliceRawPath,
  getRawPath: getRawPath,
  pointsToSegment: pointsToSegment,
  stringToRawPath: stringToRawPath,
  rawPathToString: rawPathToString,
  transformRawPath: transformRawPath,
  getGlobalMatrix: matrix/* getGlobalMatrix */.M9,
  getPositionOnPath: getPositionOnPath,
  cacheRawPathMeasurements: cacheRawPathMeasurements,
  convertToPath: function convertToPath(targets, swap) {
    return _toArray(targets).map(function (target) {
      return paths_convertToPath(target, swap !== false);
    });
  },
  convertCoordinates: function convertCoordinates(fromElement, toElement, point) {
    var m = (0,matrix/* getGlobalMatrix */.M9)(toElement, true, true).multiply((0,matrix/* getGlobalMatrix */.M9)(fromElement));
    return point ? m.apply(point) : m;
  },
  getAlignMatrix: _getAlignMatrix,
  getRelativePosition: function getRelativePosition(fromElement, toElement, fromOrigin, toOrigin) {
    var m = _getAlignMatrix(fromElement, toElement, fromOrigin, toOrigin);

    return {
      x: m.e,
      y: m.f
    };
  },
  arrayToRawPath: function arrayToRawPath(value, vars) {
    vars = vars || {};

    var segment = _populateSegmentFromArray(_populateSegmentFromArray([], value, vars.x || "x", 0), value, vars.y || "y", 1);

    vars.relative && _relativize(segment);
    return [vars.type === "cubic" ? segment : pointsToSegment(segment, vars.curviness)];
  }
};
_getGSAP() && gsap.registerPlugin(MotionPathPlugin);


/***/ }),

/***/ 964:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  "i": () => (/* binding */ ScrollTrigger_ScrollTrigger)
});

// UNUSED EXPORTS: default

;// CONCATENATED MODULE: ./node_modules/gsap/Observer.js
function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}
/*!
 * Observer 3.10.4
 * https://greensock.com
 *
 * @license Copyright 2008-2022, GreenSock. All rights reserved.
 * Subject to the terms at https://greensock.com/standard-license or for
 * Club GreenSock members, the agreement issued with that membership.
 * @author: Jack Doyle, jack@greensock.com
*/

/* eslint-disable */


var gsap,
    _coreInitted,
    _clamp,
    _win,
    _doc,
    _docEl,
    _body,
    _isTouch,
    _pointerType,
    ScrollTrigger,
    _root,
    _normalizer,
    _eventTypes,
    _getGSAP = function _getGSAP() {
  return gsap || typeof window !== "undefined" && (gsap = window.gsap) && gsap.registerPlugin && gsap;
},
    _passThrough = function _passThrough(p) {
  return p;
},
    _startup = 1,
    _observers = [],
    _scrollers = [],
    _proxies = [],
    _getTime = Date.now,
    _bridge = function _bridge(name, value) {
  return value;
},
    _integrate = function _integrate() {
  var core = ScrollTrigger.core,
      data = core.bridge || {},
      scrollers = core._scrollers,
      proxies = core._proxies;
  scrollers.push.apply(scrollers, _scrollers);
  proxies.push.apply(proxies, _proxies);
  _scrollers = scrollers;
  _proxies = proxies;

  _bridge = function _bridge(name, value) {
    return data[name](value);
  };
},
    _getProxyProp = function _getProxyProp(element, property) {
  return ~_proxies.indexOf(element) && _proxies[_proxies.indexOf(element) + 1][property];
},
    _isViewport = function _isViewport(el) {
  return !!~_root.indexOf(el);
},
    _addListener = function _addListener(element, type, func, nonPassive, capture) {
  return element.addEventListener(type, func, {
    passive: !nonPassive,
    capture: !!capture
  });
},
    _removeListener = function _removeListener(element, type, func, capture) {
  return element.removeEventListener(type, func, !!capture);
},
    _scrollLeft = "scrollLeft",
    _scrollTop = "scrollTop",
    _onScroll = function _onScroll() {
  return _normalizer && _normalizer.isPressed || _scrollers.cache++;
},
    _scrollCacheFunc = function _scrollCacheFunc(f, doNotCache) {
  var cachingFunc = function cachingFunc(value) {
    // since reading the scrollTop/scrollLeft/pageOffsetY/pageOffsetX can trigger a layout, this function allows us to cache the value so it only gets read fresh after a "scroll" event fires (or while we're refreshing because that can lengthen the page and alter the scroll position). when "soft" is true, that means don't actually set the scroll, but cache the new value instead (useful in ScrollSmoother)
    if (value || value === 0) {
      _startup && (_win.history.scrollRestoration = "manual"); // otherwise the new position will get overwritten by the browser onload.

      var isNormalizing = _normalizer && _normalizer.isPressed;
      value = cachingFunc.v = Math.round(value) || (_normalizer && _normalizer.iOS ? 1 : 0); //TODO: iOS Bug: if you allow it to go to 0, Safari can start to report super strange (wildly inaccurate) touch positions!

      f(value);
      cachingFunc.cacheID = _scrollers.cache;
      isNormalizing && _bridge("ss", value); // set scroll (notify ScrollTrigger so it can dispatch a "scrollStart" event if necessary
    } else if (doNotCache || _scrollers.cache !== cachingFunc.cacheID || _bridge("ref")) {
      cachingFunc.cacheID = _scrollers.cache;
      cachingFunc.v = f();
    }

    return cachingFunc.v + cachingFunc.offset;
  };

  cachingFunc.offset = 0;
  return f && cachingFunc;
},
    _horizontal = {
  s: _scrollLeft,
  p: "left",
  p2: "Left",
  os: "right",
  os2: "Right",
  d: "width",
  d2: "Width",
  a: "x",
  sc: _scrollCacheFunc(function (value) {
    return arguments.length ? _win.scrollTo(value, _vertical.sc()) : _win.pageXOffset || _doc[_scrollLeft] || _docEl[_scrollLeft] || _body[_scrollLeft] || 0;
  })
},
    _vertical = {
  s: _scrollTop,
  p: "top",
  p2: "Top",
  os: "bottom",
  os2: "Bottom",
  d: "height",
  d2: "Height",
  a: "y",
  op: _horizontal,
  sc: _scrollCacheFunc(function (value) {
    return arguments.length ? _win.scrollTo(_horizontal.sc(), value) : _win.pageYOffset || _doc[_scrollTop] || _docEl[_scrollTop] || _body[_scrollTop] || 0;
  })
},
    _getTarget = function _getTarget(t) {
  return gsap.utils.toArray(t)[0] || (typeof t === "string" && gsap.config().nullTargetWarn !== false ? console.warn("Element not found:", t) : null);
},
    _getScrollFunc = function _getScrollFunc(element, _ref) {
  var s = _ref.s,
      sc = _ref.sc; // we store the scroller functions in a alternating sequenced Array like [element, verticalScrollFunc, horizontalScrollFunc, ...] so that we can minimize memory, maximize performance, and we also record the last position as a ".rec" property in order to revert to that after refreshing to ensure things don't shift around.

  var i = _scrollers.indexOf(element),
      offset = sc === _vertical.sc ? 1 : 2;

  !~i && (i = _scrollers.push(element) - 1);
  return _scrollers[i + offset] || (_scrollers[i + offset] = _scrollCacheFunc(_getProxyProp(element, s), true) || (_isViewport(element) ? sc : _scrollCacheFunc(function (value) {
    return arguments.length ? element[s] = value : element[s];
  })));
},
    _getVelocityProp = function _getVelocityProp(value, minTimeRefresh, useDelta) {
  var v1 = value,
      v2 = value,
      t1 = _getTime(),
      t2 = t1,
      min = minTimeRefresh || 50,
      dropToZeroTime = Math.max(500, min * 3),
      update = function update(value, force) {
    var t = _getTime();

    if (force || t - t1 > min) {
      v2 = v1;
      v1 = value;
      t2 = t1;
      t1 = t;
    } else if (useDelta) {
      v1 += value;
    } else {
      // not totally necessary, but makes it a bit more accurate by adjusting the v1 value according to the new slope. This way we're not just ignoring the incoming data. Removing for now because it doesn't seem to make much practical difference and it's probably not worth the kb.
      v1 = v2 + (value - v2) / (t - t2) * (t1 - t2);
    }
  },
      reset = function reset() {
    v2 = v1 = useDelta ? 0 : v1;
    t2 = t1 = 0;
  },
      getVelocity = function getVelocity(latestValue) {
    var tOld = t2,
        vOld = v2,
        t = _getTime();

    (latestValue || latestValue === 0) && latestValue !== v1 && update(latestValue);
    return t1 === t2 || t - t2 > dropToZeroTime ? 0 : (v1 + (useDelta ? vOld : -vOld)) / ((useDelta ? t : t1) - tOld) * 1000;
  };

  return {
    update: update,
    reset: reset,
    getVelocity: getVelocity
  };
},
    _getEvent = function _getEvent(e, preventDefault) {
  preventDefault && !e._gsapAllow && e.preventDefault();
  return e.changedTouches ? e.changedTouches[0] : e;
},
    _getAbsoluteMax = function _getAbsoluteMax(a) {
  var max = Math.max.apply(Math, a),
      min = Math.min.apply(Math, a);
  return Math.abs(max) >= Math.abs(min) ? max : min;
},
    _setScrollTrigger = function _setScrollTrigger() {
  ScrollTrigger = gsap.core.globals().ScrollTrigger;
  ScrollTrigger && ScrollTrigger.core && _integrate();
},
    _initCore = function _initCore(core) {
  gsap = core || _getGSAP();

  if (gsap && typeof document !== "undefined" && document.body) {
    _win = window;
    _doc = document;
    _docEl = _doc.documentElement;
    _body = _doc.body;
    _root = [_win, _doc, _docEl, _body];
    _clamp = gsap.utils.clamp;
    _pointerType = "onpointerenter" in _body ? "pointer" : "mouse"; // isTouch is 0 if no touch, 1 if ONLY touch, and 2 if it can accommodate touch but also other types like mouse/pointer.

    _isTouch = Observer.isTouch = _win.matchMedia && _win.matchMedia("(hover: none), (pointer: coarse)").matches ? 1 : "ontouchstart" in _win || navigator.maxTouchPoints > 0 || navigator.msMaxTouchPoints > 0 ? 2 : 0;
    _eventTypes = Observer.eventTypes = ("ontouchstart" in _docEl ? "touchstart,touchmove,touchcancel,touchend" : !("onpointerdown" in _docEl) ? "mousedown,mousemove,mouseup,mouseup" : "pointerdown,pointermove,pointercancel,pointerup").split(",");
    setTimeout(function () {
      return _startup = 0;
    }, 500);

    _setScrollTrigger();

    _coreInitted = 1;
  }

  return _coreInitted;
};

_horizontal.op = _vertical;
_scrollers.cache = 0;
var Observer = /*#__PURE__*/function () {
  function Observer(vars) {
    this.init(vars);
  }

  var _proto = Observer.prototype;

  _proto.init = function init(vars) {
    _coreInitted || _initCore(gsap) || console.warn("Please gsap.registerPlugin(Observer)");
    ScrollTrigger || _setScrollTrigger();
    var tolerance = vars.tolerance,
        dragMinimum = vars.dragMinimum,
        type = vars.type,
        target = vars.target,
        lineHeight = vars.lineHeight,
        debounce = vars.debounce,
        preventDefault = vars.preventDefault,
        onStop = vars.onStop,
        onStopDelay = vars.onStopDelay,
        ignore = vars.ignore,
        wheelSpeed = vars.wheelSpeed,
        event = vars.event,
        onDragStart = vars.onDragStart,
        onDragEnd = vars.onDragEnd,
        onDrag = vars.onDrag,
        onPress = vars.onPress,
        onRelease = vars.onRelease,
        onRight = vars.onRight,
        onLeft = vars.onLeft,
        onUp = vars.onUp,
        onDown = vars.onDown,
        onChangeX = vars.onChangeX,
        onChangeY = vars.onChangeY,
        onChange = vars.onChange,
        onToggleX = vars.onToggleX,
        onToggleY = vars.onToggleY,
        onHover = vars.onHover,
        onHoverEnd = vars.onHoverEnd,
        onMove = vars.onMove,
        ignoreCheck = vars.ignoreCheck,
        isNormalizer = vars.isNormalizer,
        onGestureStart = vars.onGestureStart,
        onGestureEnd = vars.onGestureEnd,
        onWheel = vars.onWheel,
        onEnable = vars.onEnable,
        onDisable = vars.onDisable,
        onClick = vars.onClick,
        scrollSpeed = vars.scrollSpeed,
        capture = vars.capture,
        allowClicks = vars.allowClicks,
        lockAxis = vars.lockAxis,
        onLockAxis = vars.onLockAxis;
    this.target = target = _getTarget(target) || _docEl;
    this.vars = vars;
    ignore && (ignore = gsap.utils.toArray(ignore));
    tolerance = tolerance || 0;
    dragMinimum = dragMinimum || 0;
    wheelSpeed = wheelSpeed || 1;
    scrollSpeed = scrollSpeed || 1;
    type = type || "wheel,touch,pointer";
    debounce = debounce !== false;
    lineHeight || (lineHeight = parseFloat(_win.getComputedStyle(_body).lineHeight) || 22); // note: browser may report "normal", so default to 22.

    var id,
        onStopDelayedCall,
        dragged,
        moved,
        wheeled,
        locked,
        axis,
        self = this,
        prevDeltaX = 0,
        prevDeltaY = 0,
        scrollFuncX = _getScrollFunc(target, _horizontal),
        scrollFuncY = _getScrollFunc(target, _vertical),
        scrollX = scrollFuncX(),
        scrollY = scrollFuncY(),
        limitToTouch = ~type.indexOf("touch") && !~type.indexOf("pointer") && _eventTypes[0] === "pointerdown",
        // for devices that accommodate mouse events and touch events, we need to distinguish.
    isViewport = _isViewport(target),
        ownerDoc = target.ownerDocument || _doc,
        deltaX = [0, 0, 0],
        // wheel, scroll, pointer/touch
    deltaY = [0, 0, 0],
        onClickTime = 0,
        clickCapture = function clickCapture() {
      return onClickTime = _getTime();
    },
        _ignoreCheck = function _ignoreCheck(e, isPointerOrTouch) {
      return (self.event = e) && ignore && ~ignore.indexOf(e.target) || isPointerOrTouch && limitToTouch && e.pointerType !== "touch" || ignoreCheck && ignoreCheck(e, isPointerOrTouch);
    },
        onStopFunc = function onStopFunc() {
      self._vx.reset();

      self._vy.reset();

      onStopDelayedCall.pause();
      onStop && onStop(self);
    },
        update = function update() {
      var dx = self.deltaX = _getAbsoluteMax(deltaX),
          dy = self.deltaY = _getAbsoluteMax(deltaY),
          changedX = Math.abs(dx) >= tolerance,
          changedY = Math.abs(dy) >= tolerance;

      onChange && (changedX || changedY) && onChange(self, dx, dy, deltaX, deltaY); // in ScrollTrigger.normalizeScroll(), we need to know if it was touch/pointer so we need access to the deltaX/deltaY Arrays before we clear them out.

      if (changedX) {
        onRight && self.deltaX > 0 && onRight(self);
        onLeft && self.deltaX < 0 && onLeft(self);
        onChangeX && onChangeX(self);
        onToggleX && self.deltaX < 0 !== prevDeltaX < 0 && onToggleX(self);
        prevDeltaX = self.deltaX;
        deltaX[0] = deltaX[1] = deltaX[2] = 0;
      }

      if (changedY) {
        onDown && self.deltaY > 0 && onDown(self);
        onUp && self.deltaY < 0 && onUp(self);
        onChangeY && onChangeY(self);
        onToggleY && self.deltaY < 0 !== prevDeltaY < 0 && onToggleY(self);
        prevDeltaY = self.deltaY;
        deltaY[0] = deltaY[1] = deltaY[2] = 0;
      }

      if (moved || dragged) {
        onMove && onMove(self);
        onLockAxis && locked && onLockAxis(self);

        if (dragged) {
          onDrag(self);
          dragged = false;
        }

        moved = locked = false;
      }

      if (wheeled) {
        onWheel(self);
        wheeled = false;
      }

      id = 0;
    },
        onDelta = function onDelta(x, y, index) {
      deltaX[index] += x;
      deltaY[index] += y;

      self._vx.update(x);

      self._vy.update(y);

      debounce ? id || (id = requestAnimationFrame(update)) : update();
    },
        onTouchOrPointerDelta = function onTouchOrPointerDelta(x, y) {
      if (axis !== "y") {
        deltaX[2] += x;

        self._vx.update(x, true); // update the velocity as frequently as possible instead of in the debounced function so that very quick touch-scrolls (flicks) feel natural. If it's the mouse/touch/pointer, force it so that we get snappy/accurate momentum scroll.

      }

      if (axis !== "x") {
        deltaY[2] += y;

        self._vy.update(y, true);
      }

      if (lockAxis && !axis) {
        self.axis = axis = Math.abs(x) > Math.abs(y) ? "x" : "y";
        locked = true;
      }

      debounce ? id || (id = requestAnimationFrame(update)) : update();
    },
        _onDrag = function _onDrag(e) {
      if (_ignoreCheck(e, 1)) {
        return;
      }

      e = _getEvent(e, preventDefault);
      var x = e.clientX,
          y = e.clientY,
          dx = x - self.x,
          dy = y - self.y,
          isDragging = self.isDragging;
      self.x = x;
      self.y = y;

      if (isDragging || Math.abs(self.startX - x) >= dragMinimum || Math.abs(self.startY - y) >= dragMinimum) {
        onDrag && (dragged = true);
        isDragging || (self.isDragging = true);
        onTouchOrPointerDelta(dx, dy);
        isDragging || onDragStart && onDragStart(self);
      }
    },
        _onPress = self.onPress = function (e) {
      if (_ignoreCheck(e, 1)) {
        return;
      }

      self.axis = axis = null;
      onStopDelayedCall.pause();
      self.isPressed = true;
      e = _getEvent(e); // note: may need to preventDefault(?) Won't side-scroll on iOS Safari if we do, though.

      prevDeltaX = prevDeltaY = 0;
      self.startX = self.x = e.clientX;
      self.startY = self.y = e.clientY;

      self._vx.reset(); // otherwise the t2 may be stale if the user touches and flicks super fast and releases in less than 2 requestAnimationFrame ticks, causing velocity to be 0.


      self._vy.reset();

      _addListener(isNormalizer ? target : ownerDoc, _eventTypes[1], _onDrag, preventDefault, true);

      self.deltaX = self.deltaY = 0;
      onPress && onPress(self);
    },
        _onRelease = function _onRelease(e) {
      if (_ignoreCheck(e, 1)) {
        return;
      }

      _removeListener(isNormalizer ? target : ownerDoc, _eventTypes[1], _onDrag, true);

      var wasDragging = self.isDragging && (Math.abs(self.x - self.startX) > 3 || Math.abs(self.y - self.startY) > 3),
          // some touch devices need some wiggle room in terms of sensing clicks - the finger may move a few pixels.
      eventData = _getEvent(e);

      if (!wasDragging) {
        self._vx.reset();

        self._vy.reset();

        if (preventDefault && allowClicks) {
          gsap.delayedCall(0.08, function () {
            // some browsers (like Firefox) won't trust script-generated clicks, so if the user tries to click on a video to play it, for example, it simply won't work. Since a regular "click" event will most likely be generated anyway (one that has its isTrusted flag set to true), we must slightly delay our script-generated click so that the "real"/trusted one is prioritized. Remember, when there are duplicate events in quick succession, we suppress all but the first one. Some browsers don't even trigger the "real" one at all, so our synthetic one is a safety valve that ensures that no matter what, a click event does get dispatched.
            if (_getTime() - onClickTime > 300 && !e.defaultPrevented) {
              if (e.target.click) {
                //some browsers (like mobile Safari) don't properly trigger the click event
                e.target.click();
              } else if (ownerDoc.createEvent) {
                var syntheticEvent = ownerDoc.createEvent("MouseEvents");
                syntheticEvent.initMouseEvent("click", true, true, _win, 1, eventData.screenX, eventData.screenY, eventData.clientX, eventData.clientY, false, false, false, false, 0, null);
                e.target.dispatchEvent(syntheticEvent);
              }
            }
          });
        }
      }

      self.isDragging = self.isGesturing = self.isPressed = false;
      onStop && !isNormalizer && onStopDelayedCall.restart(true);
      onDragEnd && wasDragging && onDragEnd(self);
      onRelease && onRelease(self, wasDragging);
    },
        _onGestureStart = function _onGestureStart(e) {
      return e.touches && e.touches.length > 1 && (self.isGesturing = true) && onGestureStart(e, self.isDragging);
    },
        _onGestureEnd = function _onGestureEnd() {
      return (self.isGesturing = false) || onGestureEnd(self);
    },
        onScroll = function onScroll(e) {
      if (_ignoreCheck(e)) {
        return;
      }

      var x = scrollFuncX(),
          y = scrollFuncY();
      onDelta((x - scrollX) * scrollSpeed, (y - scrollY) * scrollSpeed, 1);
      scrollX = x;
      scrollY = y;
      onStop && onStopDelayedCall.restart(true);
    },
        _onWheel = function _onWheel(e) {
      if (_ignoreCheck(e)) {
        return;
      }

      e = _getEvent(e, preventDefault);
      onWheel && (wheeled = true);
      var multiplier = (e.deltaMode === 1 ? lineHeight : e.deltaMode === 2 ? _win.innerHeight : 1) * wheelSpeed;
      onDelta(e.deltaX * multiplier, e.deltaY * multiplier, 0);
      onStop && !isNormalizer && onStopDelayedCall.restart(true);
    },
        _onMove = function _onMove(e) {
      if (_ignoreCheck(e)) {
        return;
      }

      var x = e.clientX,
          y = e.clientY,
          dx = x - self.x,
          dy = y - self.y;
      self.x = x;
      self.y = y;
      moved = true;
      (dx || dy) && onTouchOrPointerDelta(dx, dy);
    },
        _onHover = function _onHover(e) {
      self.event = e;
      onHover(self);
    },
        _onHoverEnd = function _onHoverEnd(e) {
      self.event = e;
      onHoverEnd(self);
    },
        _onClick = function _onClick(e) {
      return _ignoreCheck(e) || _getEvent(e, preventDefault) && onClick(self);
    };

    onStopDelayedCall = self._dc = gsap.delayedCall(onStopDelay || 0.25, onStopFunc).pause();
    self.deltaX = self.deltaY = 0;
    self._vx = _getVelocityProp(0, 50, true);
    self._vy = _getVelocityProp(0, 50, true);
    self.scrollX = scrollFuncX;
    self.scrollY = scrollFuncY;
    self.isDragging = self.isGesturing = self.isPressed = false;

    self.enable = function (e) {
      if (!self.isEnabled) {
        _addListener(isViewport ? ownerDoc : target, "scroll", _onScroll);

        type.indexOf("scroll") >= 0 && _addListener(isViewport ? ownerDoc : target, "scroll", onScroll, preventDefault, capture);
        type.indexOf("wheel") >= 0 && _addListener(target, "wheel", _onWheel, preventDefault, capture);

        if (type.indexOf("touch") >= 0 && _isTouch || type.indexOf("pointer") >= 0) {
          _addListener(target, _eventTypes[0], _onPress, preventDefault, capture);

          _addListener(ownerDoc, _eventTypes[2], _onRelease);

          _addListener(ownerDoc, _eventTypes[3], _onRelease);

          allowClicks && _addListener(target, "click", clickCapture, false, true);
          onClick && _addListener(target, "click", _onClick);
          onGestureStart && _addListener(ownerDoc, "gesturestart", _onGestureStart);
          onGestureEnd && _addListener(ownerDoc, "gestureend", _onGestureEnd);
          onHover && _addListener(target, _pointerType + "enter", _onHover);
          onHoverEnd && _addListener(target, _pointerType + "leave", _onHoverEnd);
          onMove && _addListener(target, _pointerType + "move", _onMove);
        }

        self.isEnabled = true;
        e && e.type && _onPress(e);
        onEnable && onEnable(self);
      }

      return self;
    };

    self.disable = function () {
      if (self.isEnabled) {
        // only remove the _onScroll listener if there aren't any others that rely on the functionality.
        _observers.filter(function (o) {
          return o !== self && _isViewport(o.target);
        }).length || _removeListener(isViewport ? ownerDoc : target, "scroll", _onScroll);

        if (self.isPressed) {
          self._vx.reset();

          self._vy.reset();

          _removeListener(isNormalizer ? target : ownerDoc, _eventTypes[1], _onDrag, true);
        }

        _removeListener(isViewport ? ownerDoc : target, "scroll", onScroll, capture);

        _removeListener(target, "wheel", _onWheel, capture);

        _removeListener(target, _eventTypes[0], _onPress, capture);

        _removeListener(ownerDoc, _eventTypes[2], _onRelease);

        _removeListener(ownerDoc, _eventTypes[3], _onRelease);

        _removeListener(target, "click", clickCapture, true);

        _removeListener(target, "click", _onClick);

        _removeListener(ownerDoc, "gesturestart", _onGestureStart);

        _removeListener(ownerDoc, "gestureend", _onGestureEnd);

        _removeListener(target, _pointerType + "enter", _onHover);

        _removeListener(target, _pointerType + "leave", _onHoverEnd);

        _removeListener(target, _pointerType + "move", _onMove);

        self.isEnabled = self.isPressed = self.isDragging = false;
        onDisable && onDisable(self);
      }
    };

    self.kill = function () {
      self.disable();

      var i = _observers.indexOf(self);

      i >= 0 && _observers.splice(i, 1);
      _normalizer === self && (_normalizer = 0);
    };

    _observers.push(self);

    isNormalizer && _isViewport(target) && (_normalizer = self);
    self.enable(event);
  };

  _createClass(Observer, [{
    key: "velocityX",
    get: function get() {
      return this._vx.getVelocity();
    }
  }, {
    key: "velocityY",
    get: function get() {
      return this._vy.getVelocity();
    }
  }]);

  return Observer;
}();
Observer.version = "3.10.4";

Observer.create = function (vars) {
  return new Observer(vars);
};

Observer.register = _initCore;

Observer.getAll = function () {
  return _observers.slice();
};

Observer.getById = function (id) {
  return _observers.filter(function (o) {
    return o.vars.id === id;
  })[0];
};

_getGSAP() && gsap.registerPlugin(Observer);

;// CONCATENATED MODULE: ./node_modules/gsap/ScrollTrigger.js
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

/*!
 * ScrollTrigger 3.10.4
 * https://greensock.com
 *
 * @license Copyright 2008-2022, GreenSock. All rights reserved.
 * Subject to the terms at https://greensock.com/standard-license or for
 * Club GreenSock members, the agreement issued with that membership.
 * @author: Jack Doyle, jack@greensock.com
*/

/* eslint-disable */


var ScrollTrigger_gsap,
    ScrollTrigger_coreInitted,
    ScrollTrigger_win,
    ScrollTrigger_doc,
    ScrollTrigger_docEl,
    ScrollTrigger_body,
    ScrollTrigger_root,
    _resizeDelay,
    _toArray,
    ScrollTrigger_clamp,
    _time2,
    _syncInterval,
    _refreshing,
    _pointerIsDown,
    _transformProp,
    _i,
    _prevWidth,
    _prevHeight,
    _autoRefresh,
    _sort,
    _suppressOverwrites,
    _ignoreResize,
    ScrollTrigger_normalizer,
    _ignoreMobileResize,
    _baseScreenHeight,
    _baseScreenWidth,
    _fixIOSBug,
    _limitCallbacks,
    // if true, we'll only trigger callbacks if the active state toggles, so if you scroll immediately past both the start and end positions of a ScrollTrigger (thus inactive to inactive), neither its onEnter nor onLeave will be called. This is useful during startup.
ScrollTrigger_startup = 1,
    ScrollTrigger_getTime = Date.now,
    _time1 = ScrollTrigger_getTime(),
    _lastScrollTime = 0,
    _enabled = 0,
    _pointerDownHandler = function _pointerDownHandler() {
  return _pointerIsDown = 1;
},
    _pointerUpHandler = function _pointerUpHandler() {
  return _pointerIsDown = 0;
},
    ScrollTrigger_passThrough = function _passThrough(v) {
  return v;
},
    _round = function _round(value) {
  return Math.round(value * 100000) / 100000 || 0;
},
    _windowExists = function _windowExists() {
  return typeof window !== "undefined";
},
    ScrollTrigger_getGSAP = function _getGSAP() {
  return ScrollTrigger_gsap || _windowExists() && (ScrollTrigger_gsap = window.gsap) && ScrollTrigger_gsap.registerPlugin && ScrollTrigger_gsap;
},
    ScrollTrigger_isViewport = function _isViewport(e) {
  return !!~ScrollTrigger_root.indexOf(e);
},
    _getBoundsFunc = function _getBoundsFunc(element) {
  return _getProxyProp(element, "getBoundingClientRect") || (ScrollTrigger_isViewport(element) ? function () {
    _winOffsets.width = ScrollTrigger_win.innerWidth;
    _winOffsets.height = ScrollTrigger_win.innerHeight;
    return _winOffsets;
  } : function () {
    return _getBounds(element);
  });
},
    _getSizeFunc = function _getSizeFunc(scroller, isViewport, _ref) {
  var d = _ref.d,
      d2 = _ref.d2,
      a = _ref.a;
  return (a = _getProxyProp(scroller, "getBoundingClientRect")) ? function () {
    return a()[d];
  } : function () {
    return (isViewport ? ScrollTrigger_win["inner" + d2] : scroller["client" + d2]) || 0;
  };
},
    _getOffsetsFunc = function _getOffsetsFunc(element, isViewport) {
  return !isViewport || ~_proxies.indexOf(element) ? _getBoundsFunc(element) : function () {
    return _winOffsets;
  };
},
    _maxScroll = function _maxScroll(element, _ref2) {
  var s = _ref2.s,
      d2 = _ref2.d2,
      d = _ref2.d,
      a = _ref2.a;
  return (s = "scroll" + d2) && (a = _getProxyProp(element, s)) ? a() - _getBoundsFunc(element)()[d] : ScrollTrigger_isViewport(element) ? (ScrollTrigger_docEl[s] || ScrollTrigger_body[s]) - (ScrollTrigger_win["inner" + d2] || ScrollTrigger_docEl["client" + d2] || ScrollTrigger_body["client" + d2]) : element[s] - element["offset" + d2];
},
    _iterateAutoRefresh = function _iterateAutoRefresh(func, events) {
  for (var i = 0; i < _autoRefresh.length; i += 3) {
    (!events || ~events.indexOf(_autoRefresh[i + 1])) && func(_autoRefresh[i], _autoRefresh[i + 1], _autoRefresh[i + 2]);
  }
},
    _isString = function _isString(value) {
  return typeof value === "string";
},
    _isFunction = function _isFunction(value) {
  return typeof value === "function";
},
    _isNumber = function _isNumber(value) {
  return typeof value === "number";
},
    _isObject = function _isObject(value) {
  return _typeof(value) === "object";
},
    _callIfFunc = function _callIfFunc(value) {
  return _isFunction(value) && value();
},
    _combineFunc = function _combineFunc(f1, f2) {
  return function () {
    var result1 = _callIfFunc(f1),
        result2 = _callIfFunc(f2);

    return function () {
      _callIfFunc(result1);

      _callIfFunc(result2);
    };
  };
},
    _endAnimation = function _endAnimation(animation, reversed, pause) {
  return animation && animation.progress(reversed ? 0 : 1) && pause && animation.pause();
},
    _callback = function _callback(self, func) {
  if (self.enabled) {
    var result = func(self);
    result && result.totalTime && (self.callbackAnimation = result);
  }
},
    _abs = Math.abs,
    ScrollTrigger_scrollLeft = "scrollLeft",
    ScrollTrigger_scrollTop = "scrollTop",
    _left = "left",
    _top = "top",
    _right = "right",
    _bottom = "bottom",
    _width = "width",
    _height = "height",
    _Right = "Right",
    _Left = "Left",
    _Top = "Top",
    _Bottom = "Bottom",
    _padding = "padding",
    _margin = "margin",
    _Width = "Width",
    _Height = "Height",
    _px = "px",
    _getComputedStyle = function _getComputedStyle(element) {
  return ScrollTrigger_win.getComputedStyle(element);
},
    _makePositionable = function _makePositionable(element) {
  // if the element already has position: absolute or fixed, leave that, otherwise make it position: relative
  var position = _getComputedStyle(element).position;

  element.style.position = position === "absolute" || position === "fixed" ? position : "relative";
},
    _setDefaults = function _setDefaults(obj, defaults) {
  for (var p in defaults) {
    p in obj || (obj[p] = defaults[p]);
  }

  return obj;
},
    _getBounds = function _getBounds(element, withoutTransforms) {
  var tween = withoutTransforms && _getComputedStyle(element)[_transformProp] !== "matrix(1, 0, 0, 1, 0, 0)" && ScrollTrigger_gsap.to(element, {
    x: 0,
    y: 0,
    xPercent: 0,
    yPercent: 0,
    rotation: 0,
    rotationX: 0,
    rotationY: 0,
    scale: 1,
    skewX: 0,
    skewY: 0
  }).progress(1),
      bounds = element.getBoundingClientRect();
  tween && tween.progress(0).kill();
  return bounds;
},
    _getSize = function _getSize(element, _ref3) {
  var d2 = _ref3.d2;
  return element["offset" + d2] || element["client" + d2] || 0;
},
    _getLabelRatioArray = function _getLabelRatioArray(timeline) {
  var a = [],
      labels = timeline.labels,
      duration = timeline.duration(),
      p;

  for (p in labels) {
    a.push(labels[p] / duration);
  }

  return a;
},
    _getClosestLabel = function _getClosestLabel(animation) {
  return function (value) {
    return ScrollTrigger_gsap.utils.snap(_getLabelRatioArray(animation), value);
  };
},
    _snapDirectional = function _snapDirectional(snapIncrementOrArray) {
  var snap = ScrollTrigger_gsap.utils.snap(snapIncrementOrArray),
      a = Array.isArray(snapIncrementOrArray) && snapIncrementOrArray.slice(0).sort(function (a, b) {
    return a - b;
  });
  return a ? function (value, direction, threshold) {
    if (threshold === void 0) {
      threshold = 1e-3;
    }

    var i;

    if (!direction) {
      return snap(value);
    }

    if (direction > 0) {
      value -= threshold; // to avoid rounding errors. If we're too strict, it might snap forward, then immediately again, and again.

      for (i = 0; i < a.length; i++) {
        if (a[i] >= value) {
          return a[i];
        }
      }

      return a[i - 1];
    } else {
      i = a.length;
      value += threshold;

      while (i--) {
        if (a[i] <= value) {
          return a[i];
        }
      }
    }

    return a[0];
  } : function (value, direction, threshold) {
    if (threshold === void 0) {
      threshold = 1e-3;
    }

    var snapped = snap(value);
    return !direction || Math.abs(snapped - value) < threshold || snapped - value < 0 === direction < 0 ? snapped : snap(direction < 0 ? value - snapIncrementOrArray : value + snapIncrementOrArray);
  };
},
    _getLabelAtDirection = function _getLabelAtDirection(timeline) {
  return function (value, st) {
    return _snapDirectional(_getLabelRatioArray(timeline))(value, st.direction);
  };
},
    _multiListener = function _multiListener(func, element, types, callback) {
  return types.split(",").forEach(function (type) {
    return func(element, type, callback);
  });
},
    ScrollTrigger_addListener = function _addListener(element, type, func, nonPassive, capture) {
  return element.addEventListener(type, func, {
    passive: !nonPassive,
    capture: !!capture
  });
},
    ScrollTrigger_removeListener = function _removeListener(element, type, func, capture) {
  return element.removeEventListener(type, func, !!capture);
},
    _wheelListener = function _wheelListener(func, el, scrollFunc) {
  return scrollFunc && scrollFunc.wheelHandler && func(el, "wheel", scrollFunc);
},
    _markerDefaults = {
  startColor: "green",
  endColor: "red",
  indent: 0,
  fontSize: "16px",
  fontWeight: "normal"
},
    _defaults = {
  toggleActions: "play",
  anticipatePin: 0
},
    _keywords = {
  top: 0,
  left: 0,
  center: 0.5,
  bottom: 1,
  right: 1
},
    _offsetToPx = function _offsetToPx(value, size) {
  if (_isString(value)) {
    var eqIndex = value.indexOf("="),
        relative = ~eqIndex ? +(value.charAt(eqIndex - 1) + 1) * parseFloat(value.substr(eqIndex + 1)) : 0;

    if (~eqIndex) {
      value.indexOf("%") > eqIndex && (relative *= size / 100);
      value = value.substr(0, eqIndex - 1);
    }

    value = relative + (value in _keywords ? _keywords[value] * size : ~value.indexOf("%") ? parseFloat(value) * size / 100 : parseFloat(value) || 0);
  }

  return value;
},
    _createMarker = function _createMarker(type, name, container, direction, _ref4, offset, matchWidthEl, containerAnimation) {
  var startColor = _ref4.startColor,
      endColor = _ref4.endColor,
      fontSize = _ref4.fontSize,
      indent = _ref4.indent,
      fontWeight = _ref4.fontWeight;

  var e = ScrollTrigger_doc.createElement("div"),
      useFixedPosition = ScrollTrigger_isViewport(container) || _getProxyProp(container, "pinType") === "fixed",
      isScroller = type.indexOf("scroller") !== -1,
      parent = useFixedPosition ? ScrollTrigger_body : container,
      isStart = type.indexOf("start") !== -1,
      color = isStart ? startColor : endColor,
      css = "border-color:" + color + ";font-size:" + fontSize + ";color:" + color + ";font-weight:" + fontWeight + ";pointer-events:none;white-space:nowrap;font-family:sans-serif,Arial;z-index:1000;padding:4px 8px;border-width:0;border-style:solid;";

  css += "position:" + ((isScroller || containerAnimation) && useFixedPosition ? "fixed;" : "absolute;");
  (isScroller || containerAnimation || !useFixedPosition) && (css += (direction === _vertical ? _right : _bottom) + ":" + (offset + parseFloat(indent)) + "px;");
  matchWidthEl && (css += "box-sizing:border-box;text-align:left;width:" + matchWidthEl.offsetWidth + "px;");
  e._isStart = isStart;
  e.setAttribute("class", "gsap-marker-" + type + (name ? " marker-" + name : ""));
  e.style.cssText = css;
  e.innerText = name || name === 0 ? type + "-" + name : type;
  parent.children[0] ? parent.insertBefore(e, parent.children[0]) : parent.appendChild(e);
  e._offset = e["offset" + direction.op.d2];

  _positionMarker(e, 0, direction, isStart);

  return e;
},
    _positionMarker = function _positionMarker(marker, start, direction, flipped) {
  var vars = {
    display: "block"
  },
      side = direction[flipped ? "os2" : "p2"],
      oppositeSide = direction[flipped ? "p2" : "os2"];
  marker._isFlipped = flipped;
  vars[direction.a + "Percent"] = flipped ? -100 : 0;
  vars[direction.a] = flipped ? "1px" : 0;
  vars["border" + side + _Width] = 1;
  vars["border" + oppositeSide + _Width] = 0;
  vars[direction.p] = start + "px";
  ScrollTrigger_gsap.set(marker, vars);
},
    _triggers = [],
    _ids = {},
    _rafID,
    _sync = function _sync() {
  return ScrollTrigger_getTime() - _lastScrollTime > 34 && _updateAll();
},
    ScrollTrigger_onScroll = function _onScroll() {
  // previously, we tried to optimize performance by batching/deferring to the next requestAnimationFrame(), but discovered that Safari has a few bugs that make this unworkable (especially on iOS). See https://codepen.io/GreenSock/pen/16c435b12ef09c38125204818e7b45fc?editors=0010 and https://codepen.io/GreenSock/pen/JjOxYpQ/3dd65ccec5a60f1d862c355d84d14562?editors=0010 and https://codepen.io/GreenSock/pen/ExbrPNa/087cef197dc35445a0951e8935c41503?editors=0010
  if (!ScrollTrigger_normalizer || !ScrollTrigger_normalizer.isPressed || ScrollTrigger_normalizer.startX > ScrollTrigger_body.clientWidth) {
    // if the user is dragging the scrollbar, allow it.
    _scrollers.cache++;
    _rafID || (_rafID = requestAnimationFrame(_updateAll));
    _lastScrollTime || _dispatch("scrollStart");
    _lastScrollTime = ScrollTrigger_getTime();
  }
},
    _setBaseDimensions = function _setBaseDimensions() {
  _baseScreenWidth = ScrollTrigger_win.innerWidth;
  _baseScreenHeight = ScrollTrigger_win.innerHeight;
},
    _onResize = function _onResize() {
  _scrollers.cache++;
  !_refreshing && !_ignoreResize && !ScrollTrigger_doc.fullscreenElement && !ScrollTrigger_doc.webkitFullscreenElement && (!_ignoreMobileResize || _baseScreenWidth !== ScrollTrigger_win.innerWidth || Math.abs(ScrollTrigger_win.innerHeight - _baseScreenHeight) > ScrollTrigger_win.innerHeight * 0.25) && _resizeDelay.restart(true);
},
    // ignore resizes triggered by refresh()
_listeners = {},
    _emptyArray = [],
    _media = [],
    _creatingMedia,
    // when ScrollTrigger.matchMedia() is called, we record the current media key here (like "(min-width: 800px)") so that we can assign it to everything that's created during that call. Then we can revert just those when necessary. In the ScrollTrigger's init() call, the _creatingMedia is recorded as a "media" property on the instance.
_lastMediaTick,
    _onMediaChange = function _onMediaChange(e) {
  var tick = ScrollTrigger_gsap.ticker.frame,
      matches = [],
      i = 0,
      index;

  if (_lastMediaTick !== tick || ScrollTrigger_startup) {
    _revertAll();

    for (; i < _media.length; i += 4) {
      index = ScrollTrigger_win.matchMedia(_media[i]).matches;

      if (index !== _media[i + 3]) {
        // note: some browsers fire the matchMedia event multiple times, like when going full screen, so we shouldn't call the function multiple times. Check to see if it's already matched.
        _media[i + 3] = index;
        index ? matches.push(i) : _revertAll(1, _media[i]) || _isFunction(_media[i + 2]) && _media[i + 2](); // Firefox doesn't update the "matches" property of the MediaQueryList object correctly - it only does so as it calls its change handler - so we must re-create a media query here to ensure it's accurate.
      }
    }

    _revertRecorded(); // in case killing/reverting any of the animations actually added inline styles back.


    for (i = 0; i < matches.length; i++) {
      index = matches[i];
      _creatingMedia = _media[index];
      _media[index + 2] = _media[index + 1](e);
    }

    _creatingMedia = 0;
    ScrollTrigger_coreInitted && _refreshAll(0, 1);
    _lastMediaTick = tick;

    _dispatch("matchMedia");
  }
},
    _softRefresh = function _softRefresh() {
  return ScrollTrigger_removeListener(ScrollTrigger_ScrollTrigger, "scrollEnd", _softRefresh) || _refreshAll(true);
},
    _dispatch = function _dispatch(type) {
  return _listeners[type] && _listeners[type].map(function (f) {
    return f();
  }) || _emptyArray;
},
    _savedStyles = [],
    // when ScrollTrigger.saveStyles() is called, the inline styles are recorded in this Array in a sequential format like [element, cssText, gsCache, media]. This keeps it very memory-efficient and fast to iterate through.
_revertRecorded = function _revertRecorded(media) {
  for (var i = 0; i < _savedStyles.length; i += 5) {
    if (!media || _savedStyles[i + 4] === media) {
      _savedStyles[i].style.cssText = _savedStyles[i + 1];
      _savedStyles[i].getBBox && _savedStyles[i].setAttribute("transform", _savedStyles[i + 2] || "");
      _savedStyles[i + 3].uncache = 1;
    }
  }
},
    _revertAll = function _revertAll(kill, media) {
  var trigger;

  for (_i = 0; _i < _triggers.length; _i++) {
    trigger = _triggers[_i];

    if (!media || trigger.media === media) {
      if (kill) {
        trigger.kill(1);
      } else {
        trigger.revert();
      }
    }
  }

  media && _revertRecorded(media);
  media || _dispatch("revert");
},
    _clearScrollMemory = function _clearScrollMemory() {
  return _scrollers.cache++ && _scrollers.forEach(function (obj) {
    return typeof obj === "function" && (obj.rec = 0);
  });
},
    // zero-out all the recorded scroll positions. Don't use _triggers because if, for example, .matchMedia() is used to create some ScrollTriggers and then the user resizes and it removes ALL ScrollTriggers, and then go back to a size where there are ScrollTriggers, it would have kept the position(s) saved from the initial state.
_refreshingAll,
    _refreshID = 0,
    _refreshAll = function _refreshAll(force, skipRevert) {
  if (_lastScrollTime && !force) {
    ScrollTrigger_addListener(ScrollTrigger_ScrollTrigger, "scrollEnd", _softRefresh);

    return;
  }

  _refreshingAll = true;

  var refreshInits = _dispatch("refreshInit");

  _sort && ScrollTrigger_ScrollTrigger.sort();
  skipRevert || _revertAll();

  _triggers.slice(0).forEach(function (t) {
    return t.refresh();
  }); // don't loop with _i because during a refresh() someone could call ScrollTrigger.update() which would iterate through _i resulting in a skip.


  _triggers.forEach(function (t) {
    return t.vars.end === "max" && t.setPositions(t.start, _maxScroll(t.scroller, t._dir));
  }); // the scroller's max scroll position may change after all the ScrollTriggers refreshed (like pinning could push it down), so we need to loop back and correct any with end: "max".


  refreshInits.forEach(function (result) {
    return result && result.render && result.render(-1);
  }); // if the onRefreshInit() returns an animation (typically a gsap.set()), revert it. This makes it easy to put things in a certain spot before refreshing for measurement purposes, and then put things back.

  _clearScrollMemory();

  _resizeDelay.pause();

  _refreshID++;
  _refreshingAll = false;

  _dispatch("refresh");
},
    _lastScroll = 0,
    _direction = 1,
    _primary,
    _updateAll = function _updateAll() {
  if (!_refreshingAll) {
    ScrollTrigger_ScrollTrigger.isUpdating = true;
    _primary && _primary.update(0); // ScrollSmoother users refreshPriority -9999 to become the primary that gets updated before all others because it affects the scroll position.

    var l = _triggers.length,
        time = ScrollTrigger_getTime(),
        recordVelocity = time - _time1 >= 50,
        scroll = l && _triggers[0].scroll();

    _direction = _lastScroll > scroll ? -1 : 1;
    _lastScroll = scroll;

    if (recordVelocity) {
      if (_lastScrollTime && !_pointerIsDown && time - _lastScrollTime > 200) {
        _lastScrollTime = 0;

        _dispatch("scrollEnd");
      }

      _time2 = _time1;
      _time1 = time;
    }

    if (_direction < 0) {
      _i = l;

      while (_i-- > 0) {
        _triggers[_i] && _triggers[_i].update(0, recordVelocity);
      }

      _direction = 1;
    } else {
      for (_i = 0; _i < l; _i++) {
        _triggers[_i] && _triggers[_i].update(0, recordVelocity);
      }
    }

    ScrollTrigger_ScrollTrigger.isUpdating = false;
  }

  _rafID = 0;
},
    _propNamesToCopy = [_left, _top, _bottom, _right, _margin + _Bottom, _margin + _Right, _margin + _Top, _margin + _Left, "display", "flexShrink", "float", "zIndex", "gridColumnStart", "gridColumnEnd", "gridRowStart", "gridRowEnd", "gridArea", "justifySelf", "alignSelf", "placeSelf", "order"],
    _stateProps = _propNamesToCopy.concat([_width, _height, "boxSizing", "max" + _Width, "max" + _Height, "position", _margin, _padding, _padding + _Top, _padding + _Right, _padding + _Bottom, _padding + _Left]),
    _swapPinOut = function _swapPinOut(pin, spacer, state) {
  _setState(state);

  var cache = pin._gsap;

  if (cache.spacerIsNative) {
    _setState(cache.spacerState);
  } else if (pin.parentNode === spacer) {
    var parent = spacer.parentNode;

    if (parent) {
      parent.insertBefore(pin, spacer);
      parent.removeChild(spacer);
    }
  }
},
    _swapPinIn = function _swapPinIn(pin, spacer, cs, spacerState) {
  if (pin.parentNode !== spacer) {
    var i = _propNamesToCopy.length,
        spacerStyle = spacer.style,
        pinStyle = pin.style,
        p;

    while (i--) {
      p = _propNamesToCopy[i];
      spacerStyle[p] = cs[p];
    }

    spacerStyle.position = cs.position === "absolute" ? "absolute" : "relative";
    cs.display === "inline" && (spacerStyle.display = "inline-block");
    pinStyle[_bottom] = pinStyle[_right] = spacerStyle.flexBasis = "auto";
    spacerStyle.overflow = "visible";
    spacerStyle.boxSizing = "border-box";
    spacerStyle[_width] = _getSize(pin, _horizontal) + _px;
    spacerStyle[_height] = _getSize(pin, _vertical) + _px;
    spacerStyle[_padding] = pinStyle[_margin] = pinStyle[_top] = pinStyle[_left] = "0";

    _setState(spacerState);

    pinStyle[_width] = pinStyle["max" + _Width] = cs[_width];
    pinStyle[_height] = pinStyle["max" + _Height] = cs[_height];
    pinStyle[_padding] = cs[_padding];
    pin.parentNode.insertBefore(spacer, pin);
    spacer.appendChild(pin);
  }
},
    _capsExp = /([A-Z])/g,
    _setState = function _setState(state) {
  if (state) {
    var style = state.t.style,
        l = state.length,
        i = 0,
        p,
        value;
    (state.t._gsap || ScrollTrigger_gsap.core.getCache(state.t)).uncache = 1; // otherwise transforms may be off

    for (; i < l; i += 2) {
      value = state[i + 1];
      p = state[i];

      if (value) {
        style[p] = value;
      } else if (style[p]) {
        style.removeProperty(p.replace(_capsExp, "-$1").toLowerCase());
      }
    }
  }
},
    _getState = function _getState(element) {
  // returns an Array with alternating values like [property, value, property, value] and a "t" property pointing to the target (element). Makes it fast and cheap.
  var l = _stateProps.length,
      style = element.style,
      state = [],
      i = 0;

  for (; i < l; i++) {
    state.push(_stateProps[i], style[_stateProps[i]]);
  }

  state.t = element;
  return state;
},
    _copyState = function _copyState(state, override, omitOffsets) {
  var result = [],
      l = state.length,
      i = omitOffsets ? 8 : 0,
      // skip top, left, right, bottom if omitOffsets is true
  p;

  for (; i < l; i += 2) {
    p = state[i];
    result.push(p, p in override ? override[p] : state[i + 1]);
  }

  result.t = state.t;
  return result;
},
    _winOffsets = {
  left: 0,
  top: 0
},
    // // potential future feature (?) Allow users to calculate where a trigger hits (scroll position) like getScrollPosition("#id", "top bottom")
// _getScrollPosition = (trigger, position, {scroller, containerAnimation, horizontal}) => {
// 	scroller = _getTarget(scroller || _win);
// 	let direction = horizontal ? _horizontal : _vertical,
// 		isViewport = _isViewport(scroller);
// 	_getSizeFunc(scroller, isViewport, direction);
// 	return _parsePosition(position, _getTarget(trigger), _getSizeFunc(scroller, isViewport, direction)(), direction, _getScrollFunc(scroller, direction)(), 0, 0, 0, _getOffsetsFunc(scroller, isViewport)(), isViewport ? 0 : parseFloat(_getComputedStyle(scroller)["border" + direction.p2 + _Width]) || 0, 0, containerAnimation ? containerAnimation.duration() : _maxScroll(scroller), containerAnimation);
// },
_parsePosition = function _parsePosition(value, trigger, scrollerSize, direction, scroll, marker, markerScroller, self, scrollerBounds, borderWidth, useFixedPosition, scrollerMax, containerAnimation) {
  _isFunction(value) && (value = value(self));

  if (_isString(value) && value.substr(0, 3) === "max") {
    value = scrollerMax + (value.charAt(4) === "=" ? _offsetToPx("0" + value.substr(3), scrollerSize) : 0);
  }

  var time = containerAnimation ? containerAnimation.time() : 0,
      p1,
      p2,
      element;
  containerAnimation && containerAnimation.seek(0);

  if (!_isNumber(value)) {
    _isFunction(trigger) && (trigger = trigger(self));
    var offsets = value.split(" "),
        bounds,
        localOffset,
        globalOffset,
        display;
    element = _getTarget(trigger) || ScrollTrigger_body;
    bounds = _getBounds(element) || {};

    if ((!bounds || !bounds.left && !bounds.top) && _getComputedStyle(element).display === "none") {
      // if display is "none", it won't report getBoundingClientRect() properly
      display = element.style.display;
      element.style.display = "block";
      bounds = _getBounds(element);
      display ? element.style.display = display : element.style.removeProperty("display");
    }

    localOffset = _offsetToPx(offsets[0], bounds[direction.d]);
    globalOffset = _offsetToPx(offsets[1] || "0", scrollerSize);
    value = bounds[direction.p] - scrollerBounds[direction.p] - borderWidth + localOffset + scroll - globalOffset;
    markerScroller && _positionMarker(markerScroller, globalOffset, direction, scrollerSize - globalOffset < 20 || markerScroller._isStart && globalOffset > 20);
    scrollerSize -= scrollerSize - globalOffset; // adjust for the marker
  } else if (markerScroller) {
    _positionMarker(markerScroller, scrollerSize, direction, true);
  }

  if (marker) {
    var position = value + scrollerSize,
        isStart = marker._isStart;
    p1 = "scroll" + direction.d2;

    _positionMarker(marker, position, direction, isStart && position > 20 || !isStart && (useFixedPosition ? Math.max(ScrollTrigger_body[p1], ScrollTrigger_docEl[p1]) : marker.parentNode[p1]) <= position + 1);

    if (useFixedPosition) {
      scrollerBounds = _getBounds(markerScroller);
      useFixedPosition && (marker.style[direction.op.p] = scrollerBounds[direction.op.p] - direction.op.m - marker._offset + _px);
    }
  }

  if (containerAnimation && element) {
    p1 = _getBounds(element);
    containerAnimation.seek(scrollerMax);
    p2 = _getBounds(element);
    containerAnimation._caScrollDist = p1[direction.p] - p2[direction.p];
    value = value / containerAnimation._caScrollDist * scrollerMax;
  }

  containerAnimation && containerAnimation.seek(time);
  return containerAnimation ? value : Math.round(value);
},
    _prefixExp = /(webkit|moz|length|cssText|inset)/i,
    _reparent = function _reparent(element, parent, top, left) {
  if (element.parentNode !== parent) {
    var style = element.style,
        p,
        cs;

    if (parent === ScrollTrigger_body) {
      element._stOrig = style.cssText; // record original inline styles so we can revert them later

      cs = _getComputedStyle(element);

      for (p in cs) {
        // must copy all relevant styles to ensure that nothing changes visually when we reparent to the <body>. Skip the vendor prefixed ones.
        if (!+p && !_prefixExp.test(p) && cs[p] && typeof style[p] === "string" && p !== "0") {
          style[p] = cs[p];
        }
      }

      style.top = top;
      style.left = left;
    } else {
      style.cssText = element._stOrig;
    }

    ScrollTrigger_gsap.core.getCache(element).uncache = 1;
    parent.appendChild(element);
  }
},
    // _mergeAnimations = animations => {
// 	let tl = gsap.timeline({smoothChildTiming: true}).startTime(Math.min(...animations.map(a => a.globalTime(0))));
// 	animations.forEach(a => {let time = a.totalTime(); tl.add(a); a.totalTime(time); });
// 	tl.smoothChildTiming = false;
// 	return tl;
// },
// returns a function that can be used to tween the scroll position in the direction provided, and when doing so it'll add a .tween property to the FUNCTION itself, and remove it when the tween completes or gets killed. This gives us a way to have multiple ScrollTriggers use a central function for any given scroller and see if there's a scroll tween running (which would affect if/how things get updated)
_getTweenCreator = function _getTweenCreator(scroller, direction) {
  var getScroll = _getScrollFunc(scroller, direction),
      prop = "_scroll" + direction.p2,
      // add a tweenable property to the scroller that's a getter/setter function, like _scrollTop or _scrollLeft. This way, if someone does gsap.killTweensOf(scroller) it'll kill the scroll tween.
  lastScroll1,
      lastScroll2,
      getTween = function getTween(scrollTo, vars, initialValue, change1, change2) {
    var tween = getTween.tween,
        onComplete = vars.onComplete,
        modifiers = {};
    initialValue = initialValue || getScroll();
    change2 = change1 && change2 || 0; // if change1 is 0, we set that to the difference and ignore change2. Otherwise, there would be a compound effect.

    change1 = change1 || scrollTo - initialValue;
    tween && tween.kill();
    lastScroll1 = Math.round(initialValue);
    vars[prop] = scrollTo;
    vars.modifiers = modifiers;

    modifiers[prop] = function (value) {
      value = _round(getScroll()); // round because in some [very uncommon] Windows environments, it can get reported with decimals even though it was set without.

      if (value !== lastScroll1 && value !== lastScroll2 && Math.abs(value - lastScroll1) > 2 && Math.abs(value - lastScroll2) > 2) {
        // if the user scrolls, kill the tween. iOS Safari intermittently misreports the scroll position, it may be the most recently-set one or the one before that! When Safari is zoomed (CMD-+), it often misreports as 1 pixel off too! So if we set the scroll position to 125, for example, it'll actually report it as 124.
        tween.kill();
        getTween.tween = 0;
      } else {
        value = initialValue + change1 * tween.ratio + change2 * tween.ratio * tween.ratio;
      }

      lastScroll2 = lastScroll1;
      return lastScroll1 = _round(value);
    };

    vars.onComplete = function () {
      getTween.tween = 0;
      onComplete && onComplete.call(tween);
    };

    tween = getTween.tween = ScrollTrigger_gsap.to(scroller, vars);
    return tween;
  };

  scroller[prop] = getScroll;

  getScroll.wheelHandler = function () {
    return getTween.tween && getTween.tween.kill() && (getTween.tween = 0);
  };

  ScrollTrigger_addListener(scroller, "wheel", getScroll.wheelHandler); // Windows machines handle mousewheel scrolling in chunks (like "3 lines per scroll") meaning the typical strategy for cancelling the scroll isn't as sensitive. It's much more likely to match one of the previous 2 scroll event positions. So we kill any snapping as soon as there's a wheel event.


  return getTween;
};

var ScrollTrigger_ScrollTrigger = /*#__PURE__*/function () {
  function ScrollTrigger(vars, animation) {
    ScrollTrigger_coreInitted || ScrollTrigger.register(ScrollTrigger_gsap) || console.warn("Please gsap.registerPlugin(ScrollTrigger)");
    this.init(vars, animation);
  }

  var _proto = ScrollTrigger.prototype;

  _proto.init = function init(vars, animation) {
    this.progress = this.start = 0;
    this.vars && this.kill(true, true); // in case it's being initted again

    if (!_enabled) {
      this.update = this.refresh = this.kill = ScrollTrigger_passThrough;
      return;
    }

    vars = _setDefaults(_isString(vars) || _isNumber(vars) || vars.nodeType ? {
      trigger: vars
    } : vars, _defaults);

    var _vars = vars,
        onUpdate = _vars.onUpdate,
        toggleClass = _vars.toggleClass,
        id = _vars.id,
        onToggle = _vars.onToggle,
        onRefresh = _vars.onRefresh,
        scrub = _vars.scrub,
        trigger = _vars.trigger,
        pin = _vars.pin,
        pinSpacing = _vars.pinSpacing,
        invalidateOnRefresh = _vars.invalidateOnRefresh,
        anticipatePin = _vars.anticipatePin,
        onScrubComplete = _vars.onScrubComplete,
        onSnapComplete = _vars.onSnapComplete,
        once = _vars.once,
        snap = _vars.snap,
        pinReparent = _vars.pinReparent,
        pinSpacer = _vars.pinSpacer,
        containerAnimation = _vars.containerAnimation,
        fastScrollEnd = _vars.fastScrollEnd,
        preventOverlaps = _vars.preventOverlaps,
        direction = vars.horizontal || vars.containerAnimation && vars.horizontal !== false ? _horizontal : _vertical,
        isToggle = !scrub && scrub !== 0,
        scroller = _getTarget(vars.scroller || ScrollTrigger_win),
        scrollerCache = ScrollTrigger_gsap.core.getCache(scroller),
        isViewport = ScrollTrigger_isViewport(scroller),
        useFixedPosition = ("pinType" in vars ? vars.pinType : _getProxyProp(scroller, "pinType") || isViewport && "fixed") === "fixed",
        callbacks = [vars.onEnter, vars.onLeave, vars.onEnterBack, vars.onLeaveBack],
        toggleActions = isToggle && vars.toggleActions.split(" "),
        markers = "markers" in vars ? vars.markers : _defaults.markers,
        borderWidth = isViewport ? 0 : parseFloat(_getComputedStyle(scroller)["border" + direction.p2 + _Width]) || 0,
        self = this,
        onRefreshInit = vars.onRefreshInit && function () {
      return vars.onRefreshInit(self);
    },
        getScrollerSize = _getSizeFunc(scroller, isViewport, direction),
        getScrollerOffsets = _getOffsetsFunc(scroller, isViewport),
        lastSnap = 0,
        lastRefresh = 0,
        scrollFunc = _getScrollFunc(scroller, direction),
        tweenTo,
        pinCache,
        snapFunc,
        scroll1,
        scroll2,
        start,
        end,
        markerStart,
        markerEnd,
        markerStartTrigger,
        markerEndTrigger,
        markerVars,
        change,
        pinOriginalState,
        pinActiveState,
        pinState,
        spacer,
        offset,
        pinGetter,
        pinSetter,
        pinStart,
        pinChange,
        spacingStart,
        spacerState,
        markerStartSetter,
        markerEndSetter,
        cs,
        snap1,
        snap2,
        scrubTween,
        scrubSmooth,
        snapDurClamp,
        snapDelayedCall,
        prevProgress,
        prevScroll,
        prevAnimProgress,
        caMarkerSetter,
        customRevertReturn;

    self.media = _creatingMedia;
    self._dir = direction;
    anticipatePin *= 45;
    self.scroller = scroller;
    self.scroll = containerAnimation ? containerAnimation.time.bind(containerAnimation) : scrollFunc;
    scroll1 = scrollFunc();
    self.vars = vars;
    animation = animation || vars.animation;

    if ("refreshPriority" in vars) {
      _sort = 1;
      vars.refreshPriority === -9999 && (_primary = self); // used by ScrollSmoother
    }

    scrollerCache.tweenScroll = scrollerCache.tweenScroll || {
      top: _getTweenCreator(scroller, _vertical),
      left: _getTweenCreator(scroller, _horizontal)
    };
    self.tweenTo = tweenTo = scrollerCache.tweenScroll[direction.p];

    self.scrubDuration = function (value) {
      scrubSmooth = _isNumber(value) && value;

      if (!scrubSmooth) {
        scrubTween && scrubTween.progress(1).kill();
        scrubTween = 0;
      } else {
        scrubTween ? scrubTween.duration(value) : scrubTween = ScrollTrigger_gsap.to(animation, {
          ease: "expo",
          totalProgress: "+=0.001",
          duration: scrubSmooth,
          paused: true,
          onComplete: function onComplete() {
            return onScrubComplete && onScrubComplete(self);
          }
        });
      }
    };

    if (animation) {
      animation.vars.lazy = false;
      animation._initted || animation.vars.immediateRender !== false && vars.immediateRender !== false && animation.render(0, true, true);
      self.animation = animation.pause();
      animation.scrollTrigger = self;
      self.scrubDuration(scrub);
      snap1 = 0;
      id || (id = animation.vars.id);
    }

    _triggers.push(self);

    if (snap) {
      if (!_isObject(snap) || snap.push) {
        snap = {
          snapTo: snap
        };
      }

      "scrollBehavior" in ScrollTrigger_body.style && ScrollTrigger_gsap.set(isViewport ? [ScrollTrigger_body, ScrollTrigger_docEl] : scroller, {
        scrollBehavior: "auto"
      }); // smooth scrolling doesn't work with snap.

      snapFunc = _isFunction(snap.snapTo) ? snap.snapTo : snap.snapTo === "labels" ? _getClosestLabel(animation) : snap.snapTo === "labelsDirectional" ? _getLabelAtDirection(animation) : snap.directional !== false ? function (value, st) {
        return _snapDirectional(snap.snapTo)(value, ScrollTrigger_getTime() - lastRefresh < 500 ? 0 : st.direction);
      } : ScrollTrigger_gsap.utils.snap(snap.snapTo);
      snapDurClamp = snap.duration || {
        min: 0.1,
        max: 2
      };
      snapDurClamp = _isObject(snapDurClamp) ? ScrollTrigger_clamp(snapDurClamp.min, snapDurClamp.max) : ScrollTrigger_clamp(snapDurClamp, snapDurClamp);
      snapDelayedCall = ScrollTrigger_gsap.delayedCall(snap.delay || scrubSmooth / 2 || 0.1, function () {
        var scroll = scrollFunc(),
            refreshedRecently = ScrollTrigger_getTime() - lastRefresh < 500,
            tween = tweenTo.tween;

        if ((refreshedRecently || Math.abs(self.getVelocity()) < 10) && !tween && !_pointerIsDown && lastSnap !== scroll) {
          var progress = (scroll - start) / change,
              totalProgress = animation && !isToggle ? animation.totalProgress() : progress,
              velocity = refreshedRecently ? 0 : (totalProgress - snap2) / (ScrollTrigger_getTime() - _time2) * 1000 || 0,
              change1 = ScrollTrigger_gsap.utils.clamp(-progress, 1 - progress, _abs(velocity / 2) * velocity / 0.185),
              naturalEnd = progress + (snap.inertia === false ? 0 : change1),
              endValue = ScrollTrigger_clamp(0, 1, snapFunc(naturalEnd, self)),
              endScroll = Math.round(start + endValue * change),
              _snap = snap,
              onStart = _snap.onStart,
              _onInterrupt = _snap.onInterrupt,
              _onComplete = _snap.onComplete;

          if (scroll <= end && scroll >= start && endScroll !== scroll) {
            if (tween && !tween._initted && tween.data <= _abs(endScroll - scroll)) {
              // there's an overlapping snap! So we must figure out which one is closer and let that tween live.
              return;
            }

            if (snap.inertia === false) {
              change1 = endValue - progress;
            }

            tweenTo(endScroll, {
              duration: snapDurClamp(_abs(Math.max(_abs(naturalEnd - totalProgress), _abs(endValue - totalProgress)) * 0.185 / velocity / 0.05 || 0)),
              ease: snap.ease || "power3",
              data: _abs(endScroll - scroll),
              // record the distance so that if another snap tween occurs (conflict) we can prioritize the closest snap.
              onInterrupt: function onInterrupt() {
                return snapDelayedCall.restart(true) && _onInterrupt && _onInterrupt(self);
              },
              onComplete: function onComplete() {
                self.update();
                lastSnap = scrollFunc();
                snap1 = snap2 = animation && !isToggle ? animation.totalProgress() : self.progress;
                onSnapComplete && onSnapComplete(self);
                _onComplete && _onComplete(self);
              }
            }, scroll, change1 * change, endScroll - scroll - change1 * change);
            onStart && onStart(self, tweenTo.tween);
          }
        } else if (self.isActive && lastSnap !== scroll) {
          snapDelayedCall.restart(true);
        }
      }).pause();
    }

    id && (_ids[id] = self);
    trigger = self.trigger = _getTarget(trigger || pin); // if a trigger has some kind of scroll-related effect applied that could contaminate the "y" or "x" position (like a ScrollSmoother effect), we needed a way to temporarily revert it, so we use the stRevert property of the gsCache. It can return another function that we'll call at the end so it can return to its normal state.

    customRevertReturn = trigger && trigger._gsap && trigger._gsap.stRevert;
    customRevertReturn && (customRevertReturn = customRevertReturn(self));
    pin = pin === true ? trigger : _getTarget(pin);
    _isString(toggleClass) && (toggleClass = {
      targets: trigger,
      className: toggleClass
    });

    if (pin) {
      pinSpacing === false || pinSpacing === _margin || (pinSpacing = !pinSpacing && _getComputedStyle(pin.parentNode).display === "flex" ? false : _padding); // if the parent is display: flex, don't apply pinSpacing by default.

      self.pin = pin;
      vars.force3D !== false && ScrollTrigger_gsap.set(pin, {
        force3D: true
      });
      pinCache = ScrollTrigger_gsap.core.getCache(pin);

      if (!pinCache.spacer) {
        // record the spacer and pinOriginalState on the cache in case someone tries pinning the same element with MULTIPLE ScrollTriggers - we don't want to have multiple spacers or record the "original" pin state after it has already been affected by another ScrollTrigger.
        if (pinSpacer) {
          pinSpacer = _getTarget(pinSpacer);
          pinSpacer && !pinSpacer.nodeType && (pinSpacer = pinSpacer.current || pinSpacer.nativeElement); // for React & Angular

          pinCache.spacerIsNative = !!pinSpacer;
          pinSpacer && (pinCache.spacerState = _getState(pinSpacer));
        }

        pinCache.spacer = spacer = pinSpacer || ScrollTrigger_doc.createElement("div");
        spacer.classList.add("pin-spacer");
        id && spacer.classList.add("pin-spacer-" + id);
        pinCache.pinState = pinOriginalState = _getState(pin);
      } else {
        pinOriginalState = pinCache.pinState;
      }

      self.spacer = spacer = pinCache.spacer;
      cs = _getComputedStyle(pin);
      spacingStart = cs[pinSpacing + direction.os2];
      pinGetter = ScrollTrigger_gsap.getProperty(pin);
      pinSetter = ScrollTrigger_gsap.quickSetter(pin, direction.a, _px); // pin.firstChild && !_maxScroll(pin, direction) && (pin.style.overflow = "hidden"); // protects from collapsing margins, but can have unintended consequences as demonstrated here: https://codepen.io/GreenSock/pen/1e42c7a73bfa409d2cf1e184e7a4248d so it was removed in favor of just telling people to set up their CSS to avoid the collapsing margins (overflow: hidden | auto is just one option. Another is border-top: 1px solid transparent).

      _swapPinIn(pin, spacer, cs);

      pinState = _getState(pin);
    }

    if (markers) {
      markerVars = _isObject(markers) ? _setDefaults(markers, _markerDefaults) : _markerDefaults;
      markerStartTrigger = _createMarker("scroller-start", id, scroller, direction, markerVars, 0);
      markerEndTrigger = _createMarker("scroller-end", id, scroller, direction, markerVars, 0, markerStartTrigger);
      offset = markerStartTrigger["offset" + direction.op.d2];

      var content = _getTarget(_getProxyProp(scroller, "content") || scroller);

      markerStart = this.markerStart = _createMarker("start", id, content, direction, markerVars, offset, 0, containerAnimation);
      markerEnd = this.markerEnd = _createMarker("end", id, content, direction, markerVars, offset, 0, containerAnimation);
      containerAnimation && (caMarkerSetter = ScrollTrigger_gsap.quickSetter([markerStart, markerEnd], direction.a, _px));

      if (!useFixedPosition && !(_proxies.length && _getProxyProp(scroller, "fixedMarkers") === true)) {
        _makePositionable(isViewport ? ScrollTrigger_body : scroller);

        ScrollTrigger_gsap.set([markerStartTrigger, markerEndTrigger], {
          force3D: true
        });
        markerStartSetter = ScrollTrigger_gsap.quickSetter(markerStartTrigger, direction.a, _px);
        markerEndSetter = ScrollTrigger_gsap.quickSetter(markerEndTrigger, direction.a, _px);
      }
    }

    if (containerAnimation) {
      var oldOnUpdate = containerAnimation.vars.onUpdate,
          oldParams = containerAnimation.vars.onUpdateParams;
      containerAnimation.eventCallback("onUpdate", function () {
        self.update(0, 0, 1);
        oldOnUpdate && oldOnUpdate.apply(oldParams || []);
      });
    }

    self.previous = function () {
      return _triggers[_triggers.indexOf(self) - 1];
    };

    self.next = function () {
      return _triggers[_triggers.indexOf(self) + 1];
    };

    self.revert = function (revert) {
      var r = revert !== false || !self.enabled,
          prevRefreshing = _refreshing;

      if (r !== self.isReverted) {
        if (r) {
          self.scroll.rec || !_refreshing || !_refreshingAll || (self.scroll.rec = scrollFunc());
          prevScroll = Math.max(scrollFunc(), self.scroll.rec || 0); // record the scroll so we can revert later (repositioning/pinning things can affect scroll position). In the static refresh() method, we first record all the scroll positions as a reference.

          prevProgress = self.progress;
          prevAnimProgress = animation && animation.progress();
        }

        markerStart && [markerStart, markerEnd, markerStartTrigger, markerEndTrigger].forEach(function (m) {
          return m.style.display = r ? "none" : "block";
        });
        r && (_refreshing = 1);
        self.update(r); // make sure the pin is back in its original position so that all the measurements are correct.

        _refreshing = prevRefreshing;
        pin && (r ? _swapPinOut(pin, spacer, pinOriginalState) : (!pinReparent || !self.isActive) && _swapPinIn(pin, spacer, _getComputedStyle(pin), spacerState));
        self.isReverted = r;
      }
    };

    self.refresh = function (soft, force) {
      if ((_refreshing || !self.enabled) && !force) {
        return;
      }

      if (pin && soft && _lastScrollTime) {
        ScrollTrigger_addListener(ScrollTrigger, "scrollEnd", _softRefresh);

        return;
      }

      !_refreshingAll && onRefreshInit && onRefreshInit(self);
      _refreshing = 1;
      lastRefresh = ScrollTrigger_getTime();

      if (tweenTo.tween) {
        tweenTo.tween.kill();
        tweenTo.tween = 0;
      }

      scrubTween && scrubTween.pause();
      invalidateOnRefresh && animation && animation.time(-0.01, true).invalidate();
      self.isReverted || self.revert();

      var size = getScrollerSize(),
          scrollerBounds = getScrollerOffsets(),
          max = containerAnimation ? containerAnimation.duration() : _maxScroll(scroller, direction),
          offset = 0,
          otherPinOffset = 0,
          parsedEnd = vars.end,
          parsedEndTrigger = vars.endTrigger || trigger,
          parsedStart = vars.start || (vars.start === 0 || !trigger ? 0 : pin ? "0 0" : "0 100%"),
          pinnedContainer = self.pinnedContainer = vars.pinnedContainer && _getTarget(vars.pinnedContainer),
          triggerIndex = trigger && Math.max(0, _triggers.indexOf(self)) || 0,
          i = triggerIndex,
          cs,
          bounds,
          scroll,
          isVertical,
          override,
          curTrigger,
          curPin,
          oppositeScroll,
          initted,
          revertedPins;

      while (i--) {
        // user might try to pin the same element more than once, so we must find any prior triggers with the same pin, revert them, and determine how long they're pinning so that we can offset things appropriately. Make sure we revert from last to first so that things "rewind" properly.
        curTrigger = _triggers[i];
        curTrigger.end || curTrigger.refresh(0, 1) || (_refreshing = 1); // if it's a timeline-based trigger that hasn't been fully initialized yet because it's waiting for 1 tick, just force the refresh() here, otherwise if it contains a pin that's supposed to affect other ScrollTriggers further down the page, they won't be adjusted properly.

        curPin = curTrigger.pin;

        if (curPin && (curPin === trigger || curPin === pin) && !curTrigger.isReverted) {
          revertedPins || (revertedPins = []);
          revertedPins.unshift(curTrigger); // we'll revert from first to last to make sure things reach their end state properly

          curTrigger.revert();
        }

        if (curTrigger !== _triggers[i]) {
          // in case it got removed.
          triggerIndex--;
          i--;
        }
      }

      _isFunction(parsedStart) && (parsedStart = parsedStart(self));
      start = _parsePosition(parsedStart, trigger, size, direction, scrollFunc(), markerStart, markerStartTrigger, self, scrollerBounds, borderWidth, useFixedPosition, max, containerAnimation) || (pin ? -0.001 : 0);
      _isFunction(parsedEnd) && (parsedEnd = parsedEnd(self));

      if (_isString(parsedEnd) && !parsedEnd.indexOf("+=")) {
        if (~parsedEnd.indexOf(" ")) {
          parsedEnd = (_isString(parsedStart) ? parsedStart.split(" ")[0] : "") + parsedEnd;
        } else {
          offset = _offsetToPx(parsedEnd.substr(2), size);
          parsedEnd = _isString(parsedStart) ? parsedStart : start + offset; // _parsePosition won't factor in the offset if the start is a number, so do it here.

          parsedEndTrigger = trigger;
        }
      }

      end = Math.max(start, _parsePosition(parsedEnd || (parsedEndTrigger ? "100% 0" : max), parsedEndTrigger, size, direction, scrollFunc() + offset, markerEnd, markerEndTrigger, self, scrollerBounds, borderWidth, useFixedPosition, max, containerAnimation)) || -0.001;
      change = end - start || (start -= 0.01) && 0.001;
      offset = 0;
      i = triggerIndex;

      while (i--) {
        curTrigger = _triggers[i];
        curPin = curTrigger.pin;

        if (curPin && curTrigger.start - curTrigger._pinPush < start && !containerAnimation && curTrigger.end > 0) {
          cs = curTrigger.end - curTrigger.start;

          if ((curPin === trigger || curPin === pinnedContainer) && !_isNumber(parsedStart)) {
            // numeric start values shouldn't be offset at all - treat them as absolute
            offset += cs * (1 - curTrigger.progress);
          }

          curPin === pin && (otherPinOffset += cs);
        }
      }

      start += offset;
      end += offset;
      self._pinPush = otherPinOffset;

      if (markerStart && offset) {
        // offset the markers if necessary
        cs = {};
        cs[direction.a] = "+=" + offset;
        pinnedContainer && (cs[direction.p] = "-=" + scrollFunc());
        ScrollTrigger_gsap.set([markerStart, markerEnd], cs);
      }

      if (pin) {
        cs = _getComputedStyle(pin);
        isVertical = direction === _vertical;
        scroll = scrollFunc(); // recalculate because the triggers can affect the scroll

        pinStart = parseFloat(pinGetter(direction.a)) + otherPinOffset;
        !max && end > 1 && ((isViewport ? ScrollTrigger_body : scroller).style["overflow-" + direction.a] = "scroll"); // makes sure the scroller has a scrollbar, otherwise if something has width: 100%, for example, it would be too big (exclude the scrollbar). See https://greensock.com/forums/topic/25182-scrolltrigger-width-of-page-increase-where-markers-are-set-to-false/

        _swapPinIn(pin, spacer, cs);

        pinState = _getState(pin); // transforms will interfere with the top/left/right/bottom placement, so remove them temporarily. getBoundingClientRect() factors in transforms.

        bounds = _getBounds(pin, true);
        oppositeScroll = useFixedPosition && _getScrollFunc(scroller, isVertical ? _horizontal : _vertical)();

        if (pinSpacing) {
          spacerState = [pinSpacing + direction.os2, change + otherPinOffset + _px];
          spacerState.t = spacer;
          i = pinSpacing === _padding ? _getSize(pin, direction) + change + otherPinOffset : 0;
          i && spacerState.push(direction.d, i + _px); // for box-sizing: border-box (must include padding).

          _setState(spacerState);

          useFixedPosition && scrollFunc(prevScroll);
        }

        if (useFixedPosition) {
          override = {
            top: bounds.top + (isVertical ? scroll - start : oppositeScroll) + _px,
            left: bounds.left + (isVertical ? oppositeScroll : scroll - start) + _px,
            boxSizing: "border-box",
            position: "fixed"
          };
          override[_width] = override["max" + _Width] = Math.ceil(bounds.width) + _px;
          override[_height] = override["max" + _Height] = Math.ceil(bounds.height) + _px;
          override[_margin] = override[_margin + _Top] = override[_margin + _Right] = override[_margin + _Bottom] = override[_margin + _Left] = "0";
          override[_padding] = cs[_padding];
          override[_padding + _Top] = cs[_padding + _Top];
          override[_padding + _Right] = cs[_padding + _Right];
          override[_padding + _Bottom] = cs[_padding + _Bottom];
          override[_padding + _Left] = cs[_padding + _Left];
          pinActiveState = _copyState(pinOriginalState, override, pinReparent);
        }

        if (animation) {
          // the animation might be affecting the transform, so we must jump to the end, check the value, and compensate accordingly. Otherwise, when it becomes unpinned, the pinSetter() will get set to a value that doesn't include whatever the animation did.
          initted = animation._initted; // if not, we must invalidate() after this step, otherwise it could lock in starting values prematurely.

          _suppressOverwrites(1);

          animation.render(animation.duration(), true, true);
          pinChange = pinGetter(direction.a) - pinStart + change + otherPinOffset;
          change !== pinChange && useFixedPosition && pinActiveState.splice(pinActiveState.length - 2, 2); // transform is the last property/value set in the state Array. Since the animation is controlling that, we should omit it.

          animation.render(0, true, true);
          initted || animation.invalidate();

          _suppressOverwrites(0);
        } else {
          pinChange = change;
        }
      } else if (trigger && scrollFunc() && !containerAnimation) {
        // it may be INSIDE a pinned element, so walk up the tree and look for any elements with _pinOffset to compensate because anything with pinSpacing that's already scrolled would throw off the measurements in getBoundingClientRect()
        bounds = trigger.parentNode;

        while (bounds && bounds !== ScrollTrigger_body) {
          if (bounds._pinOffset) {
            start -= bounds._pinOffset;
            end -= bounds._pinOffset;
          }

          bounds = bounds.parentNode;
        }
      }

      revertedPins && revertedPins.forEach(function (t) {
        return t.revert(false);
      });
      self.start = start;
      self.end = end;
      scroll1 = scroll2 = scrollFunc(); // reset velocity

      if (!containerAnimation) {
        scroll1 < prevScroll && scrollFunc(prevScroll);
        self.scroll.rec = 0;
      }

      self.revert(false);

      if (snapDelayedCall) {
        lastSnap = -1;
        self.isActive && scrollFunc(start + change * prevProgress); // just so snapping gets re-enabled, clear out any recorded last value

        snapDelayedCall.restart(true);
      }

      _refreshing = 0;
      animation && isToggle && (animation._initted || prevAnimProgress) && animation.progress() !== prevAnimProgress && animation.progress(prevAnimProgress, true).render(animation.time(), true, true); // must force a re-render because if saveStyles() was used on the target(s), the styles could have been wiped out during the refresh().

      if (prevProgress !== self.progress || containerAnimation) {
        // ensures that the direction is set properly (when refreshing, progress is set back to 0 initially, then back again to wherever it needs to be) and that callbacks are triggered.
        animation && !isToggle && animation.totalProgress(prevProgress, true); // to avoid issues where animation callbacks like onStart aren't triggered.

        self.progress = prevProgress;
        self.update(0, 0, 1);
      }

      pin && pinSpacing && (spacer._pinOffset = Math.round(self.progress * pinChange)); //			scrubTween && scrubTween.invalidate();

      onRefresh && onRefresh(self);
    };

    self.getVelocity = function () {
      return (scrollFunc() - scroll2) / (ScrollTrigger_getTime() - _time2) * 1000 || 0;
    };

    self.endAnimation = function () {
      _endAnimation(self.callbackAnimation);

      if (animation) {
        scrubTween ? scrubTween.progress(1) : !animation.paused() ? _endAnimation(animation, animation.reversed()) : isToggle || _endAnimation(animation, self.direction < 0, 1);
      }
    };

    self.labelToScroll = function (label) {
      return animation && animation.labels && (start || self.refresh() || start) + animation.labels[label] / animation.duration() * change || 0;
    };

    self.getTrailing = function (name) {
      var i = _triggers.indexOf(self),
          a = self.direction > 0 ? _triggers.slice(0, i).reverse() : _triggers.slice(i + 1);

      return (_isString(name) ? a.filter(function (t) {
        return t.vars.preventOverlaps === name;
      }) : a).filter(function (t) {
        return self.direction > 0 ? t.end <= start : t.start >= end;
      });
    };

    self.update = function (reset, recordVelocity, forceFake) {
      if (containerAnimation && !forceFake && !reset) {
        return;
      }

      var scroll = self.scroll(),
          p = reset ? 0 : (scroll - start) / change,
          clipped = p < 0 ? 0 : p > 1 ? 1 : p || 0,
          prevProgress = self.progress,
          isActive,
          wasActive,
          toggleState,
          action,
          stateChanged,
          toggled,
          isAtMax,
          isTakingAction;

      if (recordVelocity) {
        scroll2 = scroll1;
        scroll1 = containerAnimation ? scrollFunc() : scroll;

        if (snap) {
          snap2 = snap1;
          snap1 = animation && !isToggle ? animation.totalProgress() : clipped;
        }
      } // anticipate the pinning a few ticks ahead of time based on velocity to avoid a visual glitch due to the fact that most browsers do scrolling on a separate thread (not synced with requestAnimationFrame).


      anticipatePin && !clipped && pin && !_refreshing && !ScrollTrigger_startup && _lastScrollTime && start < scroll + (scroll - scroll2) / (ScrollTrigger_getTime() - _time2) * anticipatePin && (clipped = 0.0001);

      if (clipped !== prevProgress && self.enabled) {
        isActive = self.isActive = !!clipped && clipped < 1;
        wasActive = !!prevProgress && prevProgress < 1;
        toggled = isActive !== wasActive;
        stateChanged = toggled || !!clipped !== !!prevProgress; // could go from start all the way to end, thus it didn't toggle but it did change state in a sense (may need to fire a callback)

        self.direction = clipped > prevProgress ? 1 : -1;
        self.progress = clipped;

        if (stateChanged && !_refreshing) {
          toggleState = clipped && !prevProgress ? 0 : clipped === 1 ? 1 : prevProgress === 1 ? 2 : 3; // 0 = enter, 1 = leave, 2 = enterBack, 3 = leaveBack (we prioritize the FIRST encounter, thus if you scroll really fast past the onEnter and onLeave in one tick, it'd prioritize onEnter.

          if (isToggle) {
            action = !toggled && toggleActions[toggleState + 1] !== "none" && toggleActions[toggleState + 1] || toggleActions[toggleState]; // if it didn't toggle, that means it shot right past and since we prioritize the "enter" action, we should switch to the "leave" in this case (but only if one is defined)

            isTakingAction = animation && (action === "complete" || action === "reset" || action in animation);
          }
        }

        preventOverlaps && (toggled || isTakingAction) && (isTakingAction || scrub || !animation) && (_isFunction(preventOverlaps) ? preventOverlaps(self) : self.getTrailing(preventOverlaps).forEach(function (t) {
          return t.endAnimation();
        }));

        if (!isToggle) {
          if (scrubTween && !_refreshing && !ScrollTrigger_startup) {
            (containerAnimation || _primary && _primary !== self) && scrubTween.render(scrubTween._dp._time - scrubTween._start); // if there's a scrub on both the container animation and this one (or a ScrollSmoother), the update order would cause this one not to have rendered yet, so it wouldn't make any progress before we .restart() it heading toward the new progress so it'd appear stuck thus we force a render here.

            if (scrubTween.resetTo) {
              scrubTween.resetTo("totalProgress", clipped, animation._tTime / animation._tDur);
            } else {
              // legacy support (courtesy), before 3.10.0
              scrubTween.vars.totalProgress = clipped;
              scrubTween.invalidate().restart();
            }
          } else if (animation) {
            animation.totalProgress(clipped, !!_refreshing);
          }
        }

        if (pin) {
          reset && pinSpacing && (spacer.style[pinSpacing + direction.os2] = spacingStart);

          if (!useFixedPosition) {
            pinSetter(_round(pinStart + pinChange * clipped));
          } else if (stateChanged) {
            isAtMax = !reset && clipped > prevProgress && end + 1 > scroll && scroll + 1 >= _maxScroll(scroller, direction); // if it's at the VERY end of the page, don't switch away from position: fixed because it's pointless and it could cause a brief flash when the user scrolls back up (when it gets pinned again)

            if (pinReparent) {
              if (!reset && (isActive || isAtMax)) {
                var bounds = _getBounds(pin, true),
                    _offset = scroll - start;

                _reparent(pin, ScrollTrigger_body, bounds.top + (direction === _vertical ? _offset : 0) + _px, bounds.left + (direction === _vertical ? 0 : _offset) + _px);
              } else {
                _reparent(pin, spacer);
              }
            }

            _setState(isActive || isAtMax ? pinActiveState : pinState);

            pinChange !== change && clipped < 1 && isActive || pinSetter(pinStart + (clipped === 1 && !isAtMax ? pinChange : 0));
          }
        }

        snap && !tweenTo.tween && !_refreshing && !ScrollTrigger_startup && snapDelayedCall.restart(true);
        toggleClass && (toggled || once && clipped && (clipped < 1 || !_limitCallbacks)) && _toArray(toggleClass.targets).forEach(function (el) {
          return el.classList[isActive || once ? "add" : "remove"](toggleClass.className);
        }); // classes could affect positioning, so do it even if reset or refreshing is true.

        onUpdate && !isToggle && !reset && onUpdate(self);

        if (stateChanged && !_refreshing) {
          if (isToggle) {
            if (isTakingAction) {
              if (action === "complete") {
                animation.pause().totalProgress(1);
              } else if (action === "reset") {
                animation.restart(true).pause();
              } else if (action === "restart") {
                animation.restart(true);
              } else {
                animation[action]();
              }
            }

            onUpdate && onUpdate(self);
          }

          if (toggled || !_limitCallbacks) {
            // on startup, the page could be scrolled and we don't want to fire callbacks that didn't toggle. For example onEnter shouldn't fire if the ScrollTrigger isn't actually entered.
            onToggle && toggled && _callback(self, onToggle);
            callbacks[toggleState] && _callback(self, callbacks[toggleState]);
            once && (clipped === 1 ? self.kill(false, 1) : callbacks[toggleState] = 0); // a callback shouldn't be called again if once is true.

            if (!toggled) {
              // it's possible to go completely past, like from before the start to after the end (or vice-versa) in which case BOTH callbacks should be fired in that order
              toggleState = clipped === 1 ? 1 : 3;
              callbacks[toggleState] && _callback(self, callbacks[toggleState]);
            }
          }

          if (fastScrollEnd && !isActive && Math.abs(self.getVelocity()) > (_isNumber(fastScrollEnd) ? fastScrollEnd : 2500)) {
            _endAnimation(self.callbackAnimation);

            scrubTween ? scrubTween.progress(1) : _endAnimation(animation, !clipped, 1);
          }
        } else if (isToggle && onUpdate && !_refreshing) {
          onUpdate(self);
        }
      } // update absolutely-positioned markers (only if the scroller isn't the viewport)


      if (markerEndSetter) {
        var n = containerAnimation ? scroll / containerAnimation.duration() * (containerAnimation._caScrollDist || 0) : scroll;
        markerStartSetter(n + (markerStartTrigger._isFlipped ? 1 : 0));
        markerEndSetter(n);
      }

      caMarkerSetter && caMarkerSetter(-scroll / containerAnimation.duration() * (containerAnimation._caScrollDist || 0));
    };

    self.enable = function (reset, refresh) {
      if (!self.enabled) {
        self.enabled = true;

        ScrollTrigger_addListener(scroller, "resize", _onResize);

        ScrollTrigger_addListener(isViewport ? ScrollTrigger_doc : scroller, "scroll", ScrollTrigger_onScroll);

        onRefreshInit && ScrollTrigger_addListener(ScrollTrigger, "refreshInit", onRefreshInit);

        if (reset !== false) {
          self.progress = prevProgress = 0;
          scroll1 = scroll2 = lastSnap = scrollFunc();
        }

        refresh !== false && self.refresh();
      }
    };

    self.getTween = function (snap) {
      return snap && tweenTo ? tweenTo.tween : scrubTween;
    };

    self.setPositions = function (newStart, newEnd) {
      // doesn't persist after refresh()! Intended to be a way to override values that were set during refresh(), like you could set it in onRefresh()
      if (pin) {
        pinStart += newStart - start;
        pinChange += newEnd - newStart - change;
      }

      self.start = start = newStart;
      self.end = end = newEnd;
      change = newEnd - newStart;
      self.update();
    };

    self.disable = function (reset, allowAnimation) {
      if (self.enabled) {
        reset !== false && self.revert();
        self.enabled = self.isActive = false;
        allowAnimation || scrubTween && scrubTween.pause();
        prevScroll = 0;
        pinCache && (pinCache.uncache = 1);
        onRefreshInit && ScrollTrigger_removeListener(ScrollTrigger, "refreshInit", onRefreshInit);

        if (snapDelayedCall) {
          snapDelayedCall.pause();
          tweenTo.tween && tweenTo.tween.kill() && (tweenTo.tween = 0);
        }

        if (!isViewport) {
          var i = _triggers.length;

          while (i--) {
            if (_triggers[i].scroller === scroller && _triggers[i] !== self) {
              return; //don't remove the listeners if there are still other triggers referencing it.
            }
          }

          ScrollTrigger_removeListener(scroller, "resize", _onResize);

          ScrollTrigger_removeListener(scroller, "scroll", ScrollTrigger_onScroll);
        }
      }
    };

    self.kill = function (revert, allowAnimation) {
      self.disable(revert, allowAnimation);
      scrubTween && !allowAnimation && scrubTween.kill();
      id && delete _ids[id];

      var i = _triggers.indexOf(self);

      i >= 0 && _triggers.splice(i, 1);
      i === _i && _direction > 0 && _i--; // if we're in the middle of a refresh() or update(), splicing would cause skips in the index, so adjust...
      // if no other ScrollTrigger instances of the same scroller are found, wipe out any recorded scroll position. Otherwise, in a single page application, for example, it could maintain scroll position when it really shouldn't.

      i = 0;

      _triggers.forEach(function (t) {
        return t.scroller === self.scroller && (i = 1);
      });

      i || (self.scroll.rec = 0);

      if (animation) {
        animation.scrollTrigger = null;
        revert && animation.render(-1);
        allowAnimation || animation.kill();
      }

      markerStart && [markerStart, markerEnd, markerStartTrigger, markerEndTrigger].forEach(function (m) {
        return m.parentNode && m.parentNode.removeChild(m);
      });
      _primary === self && (_primary = 0);

      if (pin) {
        pinCache && (pinCache.uncache = 1);
        i = 0;

        _triggers.forEach(function (t) {
          return t.pin === pin && i++;
        });

        i || (pinCache.spacer = 0); // if there aren't any more ScrollTriggers with the same pin, remove the spacer, otherwise it could be contaminated with old/stale values if the user re-creates a ScrollTrigger for the same element.
      }

      vars.onKill && vars.onKill(self);
    };

    self.enable(false, false);
    customRevertReturn && customRevertReturn(self);
    !animation || !animation.add || change ? self.refresh() : ScrollTrigger_gsap.delayedCall(0.01, function () {
      return start || end || self.refresh();
    }) && (change = 0.01) && (start = end = 0); // if the animation is a timeline, it may not have been populated yet, so it wouldn't render at the proper place on the first refresh(), thus we should schedule one for the next tick. If "change" is defined, we know it must be re-enabling, thus we can refresh() right away.
  };

  ScrollTrigger.register = function register(core) {
    if (!ScrollTrigger_coreInitted) {
      ScrollTrigger_gsap = core || ScrollTrigger_getGSAP();
      _windowExists() && window.document && ScrollTrigger.enable();
      ScrollTrigger_coreInitted = _enabled;
    }

    return ScrollTrigger_coreInitted;
  };

  ScrollTrigger.defaults = function defaults(config) {
    if (config) {
      for (var p in config) {
        _defaults[p] = config[p];
      }
    }

    return _defaults;
  };

  ScrollTrigger.disable = function disable(reset, kill) {
    _enabled = 0;

    _triggers.forEach(function (trigger) {
      return trigger[kill ? "kill" : "disable"](reset);
    });

    ScrollTrigger_removeListener(ScrollTrigger_win, "wheel", ScrollTrigger_onScroll);

    ScrollTrigger_removeListener(ScrollTrigger_doc, "scroll", ScrollTrigger_onScroll);

    clearInterval(_syncInterval);

    ScrollTrigger_removeListener(ScrollTrigger_doc, "touchcancel", ScrollTrigger_passThrough);

    ScrollTrigger_removeListener(ScrollTrigger_body, "touchstart", ScrollTrigger_passThrough);

    _multiListener(ScrollTrigger_removeListener, ScrollTrigger_doc, "pointerdown,touchstart,mousedown", _pointerDownHandler);

    _multiListener(ScrollTrigger_removeListener, ScrollTrigger_doc, "pointerup,touchend,mouseup", _pointerUpHandler);

    _resizeDelay.kill();

    _iterateAutoRefresh(ScrollTrigger_removeListener);

    for (var i = 0; i < _scrollers.length; i += 3) {
      _wheelListener(ScrollTrigger_removeListener, _scrollers[i], _scrollers[i + 1]);

      _wheelListener(ScrollTrigger_removeListener, _scrollers[i], _scrollers[i + 2]);
    }
  };

  ScrollTrigger.enable = function enable() {
    ScrollTrigger_win = window;
    ScrollTrigger_doc = document;
    ScrollTrigger_docEl = ScrollTrigger_doc.documentElement;
    ScrollTrigger_body = ScrollTrigger_doc.body;

    if (ScrollTrigger_gsap) {
      _toArray = ScrollTrigger_gsap.utils.toArray;
      ScrollTrigger_clamp = ScrollTrigger_gsap.utils.clamp;
      _suppressOverwrites = ScrollTrigger_gsap.core.suppressOverwrites || ScrollTrigger_passThrough;
      ScrollTrigger_gsap.core.globals("ScrollTrigger", ScrollTrigger); // must register the global manually because in Internet Explorer, functions (classes) don't have a "name" property.

      if (ScrollTrigger_body) {
        _enabled = 1;
        Observer.register(ScrollTrigger_gsap); // isTouch is 0 if no touch, 1 if ONLY touch, and 2 if it can accommodate touch but also other types like mouse/pointer.

        ScrollTrigger.isTouch = Observer.isTouch;
        _fixIOSBug = Observer.isTouch && /(iPad|iPhone|iPod|Mac)/g.test(navigator.userAgent); // since 2017, iOS has had a bug that causes event.clientX/Y to be inaccurate when a scroll occurs, thus we must alternate ignoring every other touchmove event to work around it. See https://bugs.webkit.org/show_bug.cgi?id=181954 and https://codepen.io/GreenSock/pen/ExbrPNa/087cef197dc35445a0951e8935c41503

        ScrollTrigger_addListener(ScrollTrigger_win, "wheel", ScrollTrigger_onScroll); // mostly for 3rd party smooth scrolling libraries.


        ScrollTrigger_root = [ScrollTrigger_win, ScrollTrigger_doc, ScrollTrigger_docEl, ScrollTrigger_body];
        ScrollTrigger.matchMedia({
          // when orientation changes, we should take new base measurements for the ignoreMobileResize feature.
          "(orientation: portrait)": function orientationPortrait() {
            _setBaseDimensions();

            return _setBaseDimensions;
          }
        });

        ScrollTrigger_addListener(ScrollTrigger_doc, "scroll", ScrollTrigger_onScroll); // some browsers (like Chrome), the window stops dispatching scroll events on the window if you scroll really fast, but it's consistent on the document!


        var bodyStyle = ScrollTrigger_body.style,
            border = bodyStyle.borderTopStyle,
            bounds,
            i;
        bodyStyle.borderTopStyle = "solid"; // works around an issue where a margin of a child element could throw off the bounds of the _body, making it seem like there's a margin when there actually isn't. The border ensures that the bounds are accurate.

        bounds = _getBounds(ScrollTrigger_body);
        _vertical.m = Math.round(bounds.top + _vertical.sc()) || 0; // accommodate the offset of the <body> caused by margins and/or padding

        _horizontal.m = Math.round(bounds.left + _horizontal.sc()) || 0;
        border ? bodyStyle.borderTopStyle = border : bodyStyle.removeProperty("border-top-style"); // TODO: (?) maybe move to leveraging the velocity mechanism in Observer and skip intervals.

        _syncInterval = setInterval(_sync, 250);
        ScrollTrigger_gsap.delayedCall(0.5, function () {
          return ScrollTrigger_startup = 0;
        });

        ScrollTrigger_addListener(ScrollTrigger_doc, "touchcancel", ScrollTrigger_passThrough); // some older Android devices intermittently stop dispatching "touchmove" events if we don't listen for "touchcancel" on the document.


        ScrollTrigger_addListener(ScrollTrigger_body, "touchstart", ScrollTrigger_passThrough); //works around Safari bug: https://greensock.com/forums/topic/21450-draggable-in-iframe-on-mobile-is-buggy/


        _multiListener(ScrollTrigger_addListener, ScrollTrigger_doc, "pointerdown,touchstart,mousedown", _pointerDownHandler);

        _multiListener(ScrollTrigger_addListener, ScrollTrigger_doc, "pointerup,touchend,mouseup", _pointerUpHandler);

        _transformProp = ScrollTrigger_gsap.utils.checkPrefix("transform");

        _stateProps.push(_transformProp);

        ScrollTrigger_coreInitted = ScrollTrigger_getTime();
        _resizeDelay = ScrollTrigger_gsap.delayedCall(0.2, _refreshAll).pause();
        _autoRefresh = [ScrollTrigger_doc, "visibilitychange", function () {
          var w = ScrollTrigger_win.innerWidth,
              h = ScrollTrigger_win.innerHeight;

          if (ScrollTrigger_doc.hidden) {
            _prevWidth = w;
            _prevHeight = h;
          } else if (_prevWidth !== w || _prevHeight !== h) {
            _onResize();
          }
        }, ScrollTrigger_doc, "DOMContentLoaded", _refreshAll, ScrollTrigger_win, "load", _refreshAll, ScrollTrigger_win, "resize", _onResize];

        _iterateAutoRefresh(ScrollTrigger_addListener);

        _triggers.forEach(function (trigger) {
          return trigger.enable(0, 1);
        });

        for (i = 0; i < _scrollers.length; i += 3) {
          _wheelListener(ScrollTrigger_removeListener, _scrollers[i], _scrollers[i + 1]);

          _wheelListener(ScrollTrigger_removeListener, _scrollers[i], _scrollers[i + 2]);
        }
      }
    }
  };

  ScrollTrigger.config = function config(vars) {
    "limitCallbacks" in vars && (_limitCallbacks = !!vars.limitCallbacks);
    var ms = vars.syncInterval;
    ms && clearInterval(_syncInterval) || (_syncInterval = ms) && setInterval(_sync, ms);
    "ignoreMobileResize" in vars && (_ignoreMobileResize = ScrollTrigger.isTouch === 1 && vars.ignoreMobileResize);

    if ("autoRefreshEvents" in vars) {
      _iterateAutoRefresh(ScrollTrigger_removeListener) || _iterateAutoRefresh(ScrollTrigger_addListener, vars.autoRefreshEvents || "none");
      _ignoreResize = (vars.autoRefreshEvents + "").indexOf("resize") === -1;
    }
  };

  ScrollTrigger.scrollerProxy = function scrollerProxy(target, vars) {
    var t = _getTarget(target),
        i = _scrollers.indexOf(t),
        isViewport = ScrollTrigger_isViewport(t);

    if (~i) {
      _scrollers.splice(i, isViewport ? 6 : 2);
    }

    if (vars) {
      isViewport ? _proxies.unshift(ScrollTrigger_win, vars, ScrollTrigger_body, vars, ScrollTrigger_docEl, vars) : _proxies.unshift(t, vars);
    }
  };

  ScrollTrigger.matchMedia = function matchMedia(vars) {
    // _media is populated in the following order: mediaQueryString, onMatch, onUnmatch, isMatched. So if there are two media queries, the Array would have a length of 8
    var mq, p, i, func, result;

    for (p in vars) {
      i = _media.indexOf(p);
      func = vars[p];
      _creatingMedia = p;

      if (p === "all") {
        func();
      } else {
        mq = ScrollTrigger_win.matchMedia(p);

        if (mq) {
          mq.matches && (result = func());

          if (~i) {
            _media[i + 1] = _combineFunc(_media[i + 1], func);
            _media[i + 2] = _combineFunc(_media[i + 2], result);
          } else {
            i = _media.length;

            _media.push(p, func, result);

            mq.addListener ? mq.addListener(_onMediaChange) : mq.addEventListener("change", _onMediaChange);
          }

          _media[i + 3] = mq.matches;
        }
      }

      _creatingMedia = 0;
    }

    return _media;
  };

  ScrollTrigger.clearMatchMedia = function clearMatchMedia(query) {
    query || (_media.length = 0);
    query = _media.indexOf(query);
    query >= 0 && _media.splice(query, 4);
  };

  ScrollTrigger.isInViewport = function isInViewport(element, ratio, horizontal) {
    var bounds = (_isString(element) ? _getTarget(element) : element).getBoundingClientRect(),
        offset = bounds[horizontal ? _width : _height] * ratio || 0;
    return horizontal ? bounds.right - offset > 0 && bounds.left + offset < ScrollTrigger_win.innerWidth : bounds.bottom - offset > 0 && bounds.top + offset < ScrollTrigger_win.innerHeight;
  };

  ScrollTrigger.positionInViewport = function positionInViewport(element, referencePoint, horizontal) {
    _isString(element) && (element = _getTarget(element));
    var bounds = element.getBoundingClientRect(),
        size = bounds[horizontal ? _width : _height],
        offset = referencePoint == null ? size / 2 : referencePoint in _keywords ? _keywords[referencePoint] * size : ~referencePoint.indexOf("%") ? parseFloat(referencePoint) * size / 100 : parseFloat(referencePoint) || 0;
    return horizontal ? (bounds.left + offset) / ScrollTrigger_win.innerWidth : (bounds.top + offset) / ScrollTrigger_win.innerHeight;
  };

  return ScrollTrigger;
}();
ScrollTrigger_ScrollTrigger.version = "3.10.4";

ScrollTrigger_ScrollTrigger.saveStyles = function (targets) {
  return targets ? _toArray(targets).forEach(function (target) {
    // saved styles are recorded in a consecutive alternating Array, like [element, cssText, transform attribute, cache, matchMedia, ...]
    if (target && target.style) {
      var i = _savedStyles.indexOf(target);

      i >= 0 && _savedStyles.splice(i, 5);

      _savedStyles.push(target, target.style.cssText, target.getBBox && target.getAttribute("transform"), ScrollTrigger_gsap.core.getCache(target), _creatingMedia);
    }
  }) : _savedStyles;
};

ScrollTrigger_ScrollTrigger.revert = function (soft, media) {
  return _revertAll(!soft, media);
};

ScrollTrigger_ScrollTrigger.create = function (vars, animation) {
  return new ScrollTrigger_ScrollTrigger(vars, animation);
};

ScrollTrigger_ScrollTrigger.refresh = function (safe) {
  return safe ? _onResize() : (ScrollTrigger_coreInitted || ScrollTrigger_ScrollTrigger.register()) && _refreshAll(true);
};

ScrollTrigger_ScrollTrigger.update = _updateAll;
ScrollTrigger_ScrollTrigger.clearScrollMemory = _clearScrollMemory;

ScrollTrigger_ScrollTrigger.maxScroll = function (element, horizontal) {
  return _maxScroll(element, horizontal ? _horizontal : _vertical);
};

ScrollTrigger_ScrollTrigger.getScrollFunc = function (element, horizontal) {
  return _getScrollFunc(_getTarget(element), horizontal ? _horizontal : _vertical);
};

ScrollTrigger_ScrollTrigger.getById = function (id) {
  return _ids[id];
};

ScrollTrigger_ScrollTrigger.getAll = function () {
  return _triggers.filter(function (t) {
    return t.vars.id !== "ScrollSmoother";
  });
}; // it's common for people to ScrollTrigger.getAll(t => t.kill()) on page routes, for example, and we don't want it to ruin smooth scrolling by killing the main ScrollSmoother one.


ScrollTrigger_ScrollTrigger.isScrolling = function () {
  return !!_lastScrollTime;
};

ScrollTrigger_ScrollTrigger.snapDirectional = _snapDirectional;

ScrollTrigger_ScrollTrigger.addEventListener = function (type, callback) {
  var a = _listeners[type] || (_listeners[type] = []);
  ~a.indexOf(callback) || a.push(callback);
};

ScrollTrigger_ScrollTrigger.removeEventListener = function (type, callback) {
  var a = _listeners[type],
      i = a && a.indexOf(callback);
  i >= 0 && a.splice(i, 1);
};

ScrollTrigger_ScrollTrigger.batch = function (targets, vars) {
  var result = [],
      varsCopy = {},
      interval = vars.interval || 0.016,
      batchMax = vars.batchMax || 1e9,
      proxyCallback = function proxyCallback(type, callback) {
    var elements = [],
        triggers = [],
        delay = ScrollTrigger_gsap.delayedCall(interval, function () {
      callback(elements, triggers);
      elements = [];
      triggers = [];
    }).pause();
    return function (self) {
      elements.length || delay.restart(true);
      elements.push(self.trigger);
      triggers.push(self);
      batchMax <= elements.length && delay.progress(1);
    };
  },
      p;

  for (p in vars) {
    varsCopy[p] = p.substr(0, 2) === "on" && _isFunction(vars[p]) && p !== "onRefreshInit" ? proxyCallback(p, vars[p]) : vars[p];
  }

  if (_isFunction(batchMax)) {
    batchMax = batchMax();

    ScrollTrigger_addListener(ScrollTrigger_ScrollTrigger, "refresh", function () {
      return batchMax = vars.batchMax();
    });
  }

  _toArray(targets).forEach(function (target) {
    var config = {};

    for (p in varsCopy) {
      config[p] = varsCopy[p];
    }

    config.trigger = target;
    result.push(ScrollTrigger_ScrollTrigger.create(config));
  });

  return result;
}; // to reduce file size. clamps the scroll and also returns a duration multiplier so that if the scroll gets chopped shorter, the duration gets curtailed as well (otherwise if you're very close to the top of the page, for example, and swipe up really fast, it'll suddenly slow down and take a long time to reach the top).


var _clampScrollAndGetDurationMultiplier = function _clampScrollAndGetDurationMultiplier(scrollFunc, current, end, max) {
  current > max ? scrollFunc(max) : current < 0 && scrollFunc(0);
  return end > max ? (max - current) / (end - current) : end < 0 ? current / (current - end) : 1;
},
    _allowNativePanning = function _allowNativePanning(target, direction) {
  if (direction === true) {
    target.style.removeProperty("touch-action");
  } else {
    target.style.touchAction = direction === true ? "auto" : direction ? "pan-" + direction + (Observer.isTouch ? " pinch-zoom" : "") : "none"; // note: Firefox doesn't support it pinch-zoom properly, at least in addition to a pan-x or pan-y.
  }

  target === ScrollTrigger_docEl && _allowNativePanning(ScrollTrigger_body, direction);
},
    _overflow = {
  auto: 1,
  scroll: 1
},
    _nestedScroll = function _nestedScroll(_ref5) {
  var event = _ref5.event,
      target = _ref5.target,
      axis = _ref5.axis;

  var node = (event.changedTouches ? event.changedTouches[0] : event).target,
      cache = node._gsap || ScrollTrigger_gsap.core.getCache(node),
      time = ScrollTrigger_getTime(),
      cs;

  if (!cache._isScrollT || time - cache._isScrollT > 2000) {
    // cache for 2 seconds to improve performance.
    while (node && node.scrollHeight <= node.clientHeight) {
      node = node.parentNode;
    }

    cache._isScroll = node && !ScrollTrigger_isViewport(node) && node !== target && (_overflow[(cs = _getComputedStyle(node)).overflowY] || _overflow[cs.overflowX]);
    cache._isScrollT = time;
  }

  (cache._isScroll || axis === "x") && (event._gsapAllow = true);
},
    // capture events on scrollable elements INSIDE the <body> and allow those by calling stopPropagation() when we find a scrollable ancestor
_inputObserver = function _inputObserver(target, type, inputs, nested) {
  return Observer.create({
    target: target,
    capture: true,
    debounce: false,
    lockAxis: true,
    type: type,
    onWheel: nested = nested && _nestedScroll,
    onPress: nested,
    onDrag: nested,
    onScroll: nested,
    onEnable: function onEnable() {
      return inputs && ScrollTrigger_addListener(ScrollTrigger_doc, Observer.eventTypes[0], _captureInputs, false, true);
    },
    onDisable: function onDisable() {
      return ScrollTrigger_removeListener(ScrollTrigger_doc, Observer.eventTypes[0], _captureInputs, true);
    }
  });
},
    _inputExp = /(input|label|select|textarea)/i,
    _inputIsFocused,
    _captureInputs = function _captureInputs(e) {
  var isInput = _inputExp.test(e.target.tagName);

  if (isInput || _inputIsFocused) {
    e._gsapAllow = true;
    _inputIsFocused = isInput;
  }
},
    _getScrollNormalizer = function _getScrollNormalizer(vars) {
  _isObject(vars) || (vars = {});
  vars.preventDefault = vars.isNormalizer = vars.allowClicks = true;
  vars.type || (vars.type = "wheel,touch");
  vars.debounce = !!vars.debounce;
  vars.id = vars.id || "normalizer";

  var _vars2 = vars,
      normalizeScrollX = _vars2.normalizeScrollX,
      momentum = _vars2.momentum,
      allowNestedScroll = _vars2.allowNestedScroll,
      self,
      maxY,
      target = _getTarget(vars.target) || ScrollTrigger_docEl,
      smoother = ScrollTrigger_gsap.core.globals().ScrollSmoother,
      content = _fixIOSBug && (vars.content && _getTarget(vars.content) || smoother && smoother.get() && smoother.get().content()),
      scrollFuncY = _getScrollFunc(target, _vertical),
      scrollFuncX = _getScrollFunc(target, _horizontal),
      scale = 1,
      initialScale = (Observer.isTouch && ScrollTrigger_win.visualViewport ? ScrollTrigger_win.visualViewport.scale * ScrollTrigger_win.visualViewport.width : ScrollTrigger_win.outerWidth) / ScrollTrigger_win.innerWidth,
      wheelRefresh = 0,
      resolveMomentumDuration = _isFunction(momentum) ? function () {
    return momentum(self);
  } : function () {
    return momentum || 2.8;
  },
      skipTouchMove,
      lastRefreshID,
      inputObserver = _inputObserver(target, vars.type, true, allowNestedScroll),
      resumeTouchMove = function resumeTouchMove() {
    return skipTouchMove = false;
  },
      scrollClampX = ScrollTrigger_passThrough,
      scrollClampY = ScrollTrigger_passThrough,
      updateClamps = function updateClamps() {
    maxY = _maxScroll(target, _vertical);
    scrollClampY = ScrollTrigger_clamp(_fixIOSBug ? 1 : 0, maxY);
    normalizeScrollX && (scrollClampX = ScrollTrigger_clamp(0, _maxScroll(target, _horizontal)));
    lastRefreshID = _refreshID;
  },
      ignoreDrag = function ignoreDrag() {
    if (skipTouchMove) {
      requestAnimationFrame(resumeTouchMove); // we MUST wait for a requestAnimationFrame, otherwise iOS will misreport the value.

      var offset = _round(self.deltaY / 2),
          scroll = scrollClampY(scrollFuncY.v - offset);

      if (content && scroll !== scrollFuncY.v + scrollFuncY.offset) {
        scrollFuncY.offset = scroll - scrollFuncY.v;
        content.style.transform = "translateY(" + -scrollFuncY.offset + "px)";
        content._gsap && (content._gsap.y = -scrollFuncY.offset + "px");
        scrollFuncY.cacheID = _scrollers.cache;

        _updateAll();
      }

      return true;
    }

    if (content) {
      content.style.transform = "translateY(0px)";
      scrollFuncY.offset = scrollFuncY.cacheID = 0;
      content._gsap && (content._gsap.y = "0px");
    }

    skipTouchMove = true;
  },
      tween,
      startScrollX,
      startScrollY,
      onStopDelayedCall,
      onResize = function onResize() {
    // if the window resizes, like on an iPhone which Apple FORCES the address bar to show/hide even if we event.preventDefault(), it may be scrolling too far now that the address bar is showing, so we must dynamically adjust the momentum tween.
    updateClamps();

    if (tween.isActive() && tween.vars.scrollY > maxY) {
      scrollFuncY() > maxY ? tween.progress(1) && scrollFuncY(maxY) : tween.resetTo("scrollY", maxY);
    }
  };

  vars.ignoreCheck = function (e) {
    return _fixIOSBug && e.type === "touchmove" && ignoreDrag(e) || scale > 1.05 && e.type !== "touchstart" || self.isGesturing || e.touches && e.touches.length > 1;
  };

  vars.onPress = function () {
    var prevScale = scale;
    scale = _round((ScrollTrigger_win.visualViewport && ScrollTrigger_win.visualViewport.scale || 1) / initialScale);
    tween.pause();
    prevScale !== scale && _allowNativePanning(target, scale > 1.01 ? true : normalizeScrollX ? false : "x");
    skipTouchMove = false;
    startScrollX = scrollFuncX();
    startScrollY = scrollFuncY();
    updateClamps();
    lastRefreshID = _refreshID;
  };

  vars.onRelease = vars.onGestureStart = function (self, wasDragging) {
    if (content) {
      content.style.transform = "translateY(0px)";
      scrollFuncY.offset = scrollFuncY.cacheID = 0;
      content._gsap && (content._gsap.y = "0px");
    }

    if (!wasDragging) {
      onStopDelayedCall.restart(true);
    } else {
      _scrollers.cache++; // make sure we're pulling the non-cached value
      // alternate algorithm: durX = Math.min(6, Math.abs(self.velocityX / 800)),	dur = Math.max(durX, Math.min(6, Math.abs(self.velocityY / 800))); dur = dur * (0.4 + (1 - _power4In(dur / 6)) * 0.6)) * (momentumSpeed || 1)

      var dur = resolveMomentumDuration(),
          currentScroll,
          endScroll;

      if (normalizeScrollX) {
        currentScroll = scrollFuncX();
        endScroll = currentScroll + dur * 0.05 * -self.velocityX / 0.227; // the constant .227 is from power4(0.05). velocity is inverted because scrolling goes in the opposite direction.

        dur *= _clampScrollAndGetDurationMultiplier(scrollFuncX, currentScroll, endScroll, _maxScroll(target, _horizontal));
        tween.vars.scrollX = scrollClampX(endScroll);
      }

      currentScroll = scrollFuncY();
      endScroll = currentScroll + dur * 0.05 * -self.velocityY / 0.227; // the constant .227 is from power4(0.05)

      dur *= _clampScrollAndGetDurationMultiplier(scrollFuncY, currentScroll, endScroll, _maxScroll(target, _vertical));
      tween.vars.scrollY = scrollClampY(endScroll);
      tween.invalidate().duration(dur).play(0.01);

      if (_fixIOSBug && tween.vars.scrollY >= maxY || currentScroll >= maxY - 1) {
        // iOS bug: it'll show the address bar but NOT fire the window "resize" event until the animation is done but we must protect against overshoot so we leverage an onUpdate to do so.
        ScrollTrigger_gsap.to({}, {
          onUpdate: onResize,
          duration: dur
        });
      }
    }
  };

  vars.onWheel = function () {
    tween._ts && tween.pause();

    if (ScrollTrigger_getTime() - wheelRefresh > 1000) {
      // after 1 second, refresh the clamps otherwise that'll only happen when ScrollTrigger.refresh() is called or for touch-scrolling.
      lastRefreshID = 0;
      wheelRefresh = ScrollTrigger_getTime();
    }
  };

  vars.onChange = function (self, dx, dy, xArray, yArray) {
    _refreshID !== lastRefreshID && updateClamps();
    dx && normalizeScrollX && scrollFuncX(scrollClampX(xArray[2] === dx ? startScrollX + (self.startX - self.x) : scrollFuncX() + dx - xArray[1])); // for more precision, we track pointer/touch movement from the start, otherwise it'll drift.

    dy && scrollFuncY(scrollClampY(yArray[2] === dy ? startScrollY + (self.startY - self.y) : scrollFuncY() + dy - yArray[1]));

    _updateAll();
  };

  vars.onEnable = function () {
    _allowNativePanning(target, normalizeScrollX ? false : "x");

    ScrollTrigger_addListener(ScrollTrigger_win, "resize", onResize);

    inputObserver.enable();
  };

  vars.onDisable = function () {
    _allowNativePanning(target, true);

    ScrollTrigger_removeListener(ScrollTrigger_win, "resize", onResize);

    inputObserver.kill();
  };

  self = new Observer(vars);
  self.iOS = _fixIOSBug; // used in the Observer getCachedScroll() function to work around an iOS bug that wreaks havoc with TouchEvent.clientY if we allow scroll to go all the way back to 0.

  _fixIOSBug && !scrollFuncY() && scrollFuncY(1); // iOS bug causes event.clientY values to freak out (wildly inaccurate) if the scroll position is exactly 0.

  onStopDelayedCall = self._dc;
  tween = ScrollTrigger_gsap.to(self, {
    ease: "power4",
    paused: true,
    scrollX: normalizeScrollX ? "+=0.1" : "+=0",
    scrollY: "+=0.1",
    onComplete: onStopDelayedCall.vars.onComplete
  });
  return self;
};

ScrollTrigger_ScrollTrigger.sort = function (func) {
  return _triggers.sort(func || function (a, b) {
    return (a.vars.refreshPriority || 0) * -1e6 + a.start - (b.start + (b.vars.refreshPriority || 0) * -1e6);
  });
};

ScrollTrigger_ScrollTrigger.observe = function (vars) {
  return new Observer(vars);
};

ScrollTrigger_ScrollTrigger.normalizeScroll = function (vars) {
  if (typeof vars === "undefined") {
    return ScrollTrigger_normalizer;
  }

  if (vars === true && ScrollTrigger_normalizer) {
    return ScrollTrigger_normalizer.enable();
  }

  if (vars === false) {
    return ScrollTrigger_normalizer && ScrollTrigger_normalizer.kill();
  }

  var normalizer = vars instanceof Observer ? vars : _getScrollNormalizer(vars);
  ScrollTrigger_normalizer && ScrollTrigger_normalizer.target === normalizer.target && ScrollTrigger_normalizer.kill();
  ScrollTrigger_isViewport(normalizer.target) && (ScrollTrigger_normalizer = normalizer);
  return normalizer;
};

ScrollTrigger_ScrollTrigger.core = {
  // smaller file size way to leverage in ScrollSmoother and Observer
  _getVelocityProp: _getVelocityProp,
  _inputObserver: _inputObserver,
  _scrollers: _scrollers,
  _proxies: _proxies,
  bridge: {
    // when normalizeScroll sets the scroll position (ss = setScroll)
    ss: function ss() {
      _lastScrollTime || _dispatch("scrollStart");
      _lastScrollTime = ScrollTrigger_getTime();
    },
    // a way to get the _refreshing value in Observer
    ref: function ref() {
      return _refreshing;
    }
  }
};
ScrollTrigger_getGSAP() && ScrollTrigger_gsap.registerPlugin(ScrollTrigger_ScrollTrigger);


/***/ }),

/***/ 225:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  "ZP": () => (/* binding */ gsapWithCSS)
});

// UNUSED EXPORTS: Back, Bounce, CSSPlugin, Circ, Cubic, Elastic, Expo, Linear, Power0, Power1, Power2, Power3, Power4, Quad, Quart, Quint, Sine, SteppedEase, Strong, TimelineLite, TimelineMax, TweenLite, TweenMax, gsap

;// CONCATENATED MODULE: ./node_modules/gsap/gsap-core.js
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  subClass.__proto__ = superClass;
}
/*!
 * GSAP 3.10.4
 * https://greensock.com
 *
 * @license Copyright 2008-2022, GreenSock. All rights reserved.
 * Subject to the terms at https://greensock.com/standard-license or for
 * Club GreenSock members, the agreement issued with that membership.
 * @author: Jack Doyle, jack@greensock.com
*/

/* eslint-disable */


var _config = {
  autoSleep: 120,
  force3D: "auto",
  nullTargetWarn: 1,
  units: {
    lineHeight: ""
  }
},
    _defaults = {
  duration: .5,
  overwrite: false,
  delay: 0
},
    _suppressOverwrites,
    _bigNum = 1e8,
    _tinyNum = 1 / _bigNum,
    _2PI = Math.PI * 2,
    _HALF_PI = _2PI / 4,
    _gsID = 0,
    _sqrt = Math.sqrt,
    _cos = Math.cos,
    _sin = Math.sin,
    _isString = function _isString(value) {
  return typeof value === "string";
},
    _isFunction = function _isFunction(value) {
  return typeof value === "function";
},
    _isNumber = function _isNumber(value) {
  return typeof value === "number";
},
    _isUndefined = function _isUndefined(value) {
  return typeof value === "undefined";
},
    _isObject = function _isObject(value) {
  return _typeof(value) === "object";
},
    _isNotFalse = function _isNotFalse(value) {
  return value !== false;
},
    _windowExists = function _windowExists() {
  return typeof window !== "undefined";
},
    _isFuncOrString = function _isFuncOrString(value) {
  return _isFunction(value) || _isString(value);
},
    _isTypedArray = typeof ArrayBuffer === "function" && ArrayBuffer.isView || function () {},
    // note: IE10 has ArrayBuffer, but NOT ArrayBuffer.isView().
_isArray = Array.isArray,
    _strictNumExp = /(?:-?\.?\d|\.)+/gi,
    //only numbers (including negatives and decimals) but NOT relative values.
_numExp = /[-+=.]*\d+[.e\-+]*\d*[e\-+]*\d*/g,
    //finds any numbers, including ones that start with += or -=, negative numbers, and ones in scientific notation like 1e-8.
_numWithUnitExp = /[-+=.]*\d+[.e-]*\d*[a-z%]*/g,
    _complexStringNumExp = /[-+=.]*\d+\.?\d*(?:e-|e\+)?\d*/gi,
    //duplicate so that while we're looping through matches from exec(), it doesn't contaminate the lastIndex of _numExp which we use to search for colors too.
_relExp = /[+-]=-?[.\d]+/,
    _delimitedValueExp = /[^,'"\[\]\s]+/gi,
    // previously /[#\-+.]*\b[a-z\d\-=+%.]+/gi but didn't catch special characters.
_unitExp = /^[+\-=e\s\d]*\d+[.\d]*([a-z]*|%)\s*$/i,
    _globalTimeline,
    _win,
    _coreInitted,
    _doc,
    _globals = {},
    _installScope = {},
    _coreReady,
    _install = function _install(scope) {
  return (_installScope = _merge(scope, _globals)) && gsap;
},
    _missingPlugin = function _missingPlugin(property, value) {
  return console.warn("Invalid property", property, "set to", value, "Missing plugin? gsap.registerPlugin()");
},
    _warn = function _warn(message, suppress) {
  return !suppress && console.warn(message);
},
    _addGlobal = function _addGlobal(name, obj) {
  return name && (_globals[name] = obj) && _installScope && (_installScope[name] = obj) || _globals;
},
    _emptyFunc = function _emptyFunc() {
  return 0;
},
    _reservedProps = {},
    _lazyTweens = [],
    _lazyLookup = {},
    _lastRenderedFrame,
    _plugins = {},
    _effects = {},
    _nextGCFrame = 30,
    _harnessPlugins = [],
    _callbackNames = "",
    _harness = function _harness(targets) {
  var target = targets[0],
      harnessPlugin,
      i;
  _isObject(target) || _isFunction(target) || (targets = [targets]);

  if (!(harnessPlugin = (target._gsap || {}).harness)) {
    // find the first target with a harness. We assume targets passed into an animation will be of similar type, meaning the same kind of harness can be used for them all (performance optimization)
    i = _harnessPlugins.length;

    while (i-- && !_harnessPlugins[i].targetTest(target)) {}

    harnessPlugin = _harnessPlugins[i];
  }

  i = targets.length;

  while (i--) {
    targets[i] && (targets[i]._gsap || (targets[i]._gsap = new GSCache(targets[i], harnessPlugin))) || targets.splice(i, 1);
  }

  return targets;
},
    _getCache = function _getCache(target) {
  return target._gsap || _harness(toArray(target))[0]._gsap;
},
    _getProperty = function _getProperty(target, property, v) {
  return (v = target[property]) && _isFunction(v) ? target[property]() : _isUndefined(v) && target.getAttribute && target.getAttribute(property) || v;
},
    _forEachName = function _forEachName(names, func) {
  return (names = names.split(",")).forEach(func) || names;
},
    //split a comma-delimited list of names into an array, then run a forEach() function and return the split array (this is just a way to consolidate/shorten some code).
_round = function _round(value) {
  return Math.round(value * 100000) / 100000 || 0;
},
    _roundPrecise = function _roundPrecise(value) {
  return Math.round(value * 10000000) / 10000000 || 0;
},
    // increased precision mostly for timing values.
_parseRelative = function _parseRelative(start, value) {
  var operator = value.charAt(0),
      end = parseFloat(value.substr(2));
  start = parseFloat(start);
  return operator === "+" ? start + end : operator === "-" ? start - end : operator === "*" ? start * end : start / end;
},
    _arrayContainsAny = function _arrayContainsAny(toSearch, toFind) {
  //searches one array to find matches for any of the items in the toFind array. As soon as one is found, it returns true. It does NOT return all the matches; it's simply a boolean search.
  var l = toFind.length,
      i = 0;

  for (; toSearch.indexOf(toFind[i]) < 0 && ++i < l;) {}

  return i < l;
},
    _lazyRender = function _lazyRender() {
  var l = _lazyTweens.length,
      a = _lazyTweens.slice(0),
      i,
      tween;

  _lazyLookup = {};
  _lazyTweens.length = 0;

  for (i = 0; i < l; i++) {
    tween = a[i];
    tween && tween._lazy && (tween.render(tween._lazy[0], tween._lazy[1], true)._lazy = 0);
  }
},
    _lazySafeRender = function _lazySafeRender(animation, time, suppressEvents, force) {
  _lazyTweens.length && _lazyRender();
  animation.render(time, suppressEvents, force);
  _lazyTweens.length && _lazyRender(); //in case rendering caused any tweens to lazy-init, we should render them because typically when someone calls seek() or time() or progress(), they expect an immediate render.
},
    _numericIfPossible = function _numericIfPossible(value) {
  var n = parseFloat(value);
  return (n || n === 0) && (value + "").match(_delimitedValueExp).length < 2 ? n : _isString(value) ? value.trim() : value;
},
    _passThrough = function _passThrough(p) {
  return p;
},
    _setDefaults = function _setDefaults(obj, defaults) {
  for (var p in defaults) {
    p in obj || (obj[p] = defaults[p]);
  }

  return obj;
},
    _setKeyframeDefaults = function _setKeyframeDefaults(excludeDuration) {
  return function (obj, defaults) {
    for (var p in defaults) {
      p in obj || p === "duration" && excludeDuration || p === "ease" || (obj[p] = defaults[p]);
    }
  };
},
    _merge = function _merge(base, toMerge) {
  for (var p in toMerge) {
    base[p] = toMerge[p];
  }

  return base;
},
    _mergeDeep = function _mergeDeep(base, toMerge) {
  for (var p in toMerge) {
    p !== "__proto__" && p !== "constructor" && p !== "prototype" && (base[p] = _isObject(toMerge[p]) ? _mergeDeep(base[p] || (base[p] = {}), toMerge[p]) : toMerge[p]);
  }

  return base;
},
    _copyExcluding = function _copyExcluding(obj, excluding) {
  var copy = {},
      p;

  for (p in obj) {
    p in excluding || (copy[p] = obj[p]);
  }

  return copy;
},
    _inheritDefaults = function _inheritDefaults(vars) {
  var parent = vars.parent || _globalTimeline,
      func = vars.keyframes ? _setKeyframeDefaults(_isArray(vars.keyframes)) : _setDefaults;

  if (_isNotFalse(vars.inherit)) {
    while (parent) {
      func(vars, parent.vars.defaults);
      parent = parent.parent || parent._dp;
    }
  }

  return vars;
},
    _arraysMatch = function _arraysMatch(a1, a2) {
  var i = a1.length,
      match = i === a2.length;

  while (match && i-- && a1[i] === a2[i]) {}

  return i < 0;
},
    _addLinkedListItem = function _addLinkedListItem(parent, child, firstProp, lastProp, sortBy) {
  if (firstProp === void 0) {
    firstProp = "_first";
  }

  if (lastProp === void 0) {
    lastProp = "_last";
  }

  var prev = parent[lastProp],
      t;

  if (sortBy) {
    t = child[sortBy];

    while (prev && prev[sortBy] > t) {
      prev = prev._prev;
    }
  }

  if (prev) {
    child._next = prev._next;
    prev._next = child;
  } else {
    child._next = parent[firstProp];
    parent[firstProp] = child;
  }

  if (child._next) {
    child._next._prev = child;
  } else {
    parent[lastProp] = child;
  }

  child._prev = prev;
  child.parent = child._dp = parent;
  return child;
},
    _removeLinkedListItem = function _removeLinkedListItem(parent, child, firstProp, lastProp) {
  if (firstProp === void 0) {
    firstProp = "_first";
  }

  if (lastProp === void 0) {
    lastProp = "_last";
  }

  var prev = child._prev,
      next = child._next;

  if (prev) {
    prev._next = next;
  } else if (parent[firstProp] === child) {
    parent[firstProp] = next;
  }

  if (next) {
    next._prev = prev;
  } else if (parent[lastProp] === child) {
    parent[lastProp] = prev;
  }

  child._next = child._prev = child.parent = null; // don't delete the _dp just so we can revert if necessary. But parent should be null to indicate the item isn't in a linked list.
},
    _removeFromParent = function _removeFromParent(child, onlyIfParentHasAutoRemove) {
  child.parent && (!onlyIfParentHasAutoRemove || child.parent.autoRemoveChildren) && child.parent.remove(child);
  child._act = 0;
},
    _uncache = function _uncache(animation, child) {
  if (animation && (!child || child._end > animation._dur || child._start < 0)) {
    // performance optimization: if a child animation is passed in we should only uncache if that child EXTENDS the animation (its end time is beyond the end)
    var a = animation;

    while (a) {
      a._dirty = 1;
      a = a.parent;
    }
  }

  return animation;
},
    _recacheAncestors = function _recacheAncestors(animation) {
  var parent = animation.parent;

  while (parent && parent.parent) {
    //sometimes we must force a re-sort of all children and update the duration/totalDuration of all ancestor timelines immediately in case, for example, in the middle of a render loop, one tween alters another tween's timeScale which shoves its startTime before 0, forcing the parent timeline to shift around and shiftChildren() which could affect that next tween's render (startTime). Doesn't matter for the root timeline though.
    parent._dirty = 1;
    parent.totalDuration();
    parent = parent.parent;
  }

  return animation;
},
    _hasNoPausedAncestors = function _hasNoPausedAncestors(animation) {
  return !animation || animation._ts && _hasNoPausedAncestors(animation.parent);
},
    _elapsedCycleDuration = function _elapsedCycleDuration(animation) {
  return animation._repeat ? _animationCycle(animation._tTime, animation = animation.duration() + animation._rDelay) * animation : 0;
},
    // feed in the totalTime and cycleDuration and it'll return the cycle (iteration minus 1) and if the playhead is exactly at the very END, it will NOT bump up to the next cycle.
_animationCycle = function _animationCycle(tTime, cycleDuration) {
  var whole = Math.floor(tTime /= cycleDuration);
  return tTime && whole === tTime ? whole - 1 : whole;
},
    _parentToChildTotalTime = function _parentToChildTotalTime(parentTime, child) {
  return (parentTime - child._start) * child._ts + (child._ts >= 0 ? 0 : child._dirty ? child.totalDuration() : child._tDur);
},
    _setEnd = function _setEnd(animation) {
  return animation._end = _roundPrecise(animation._start + (animation._tDur / Math.abs(animation._ts || animation._rts || _tinyNum) || 0));
},
    _alignPlayhead = function _alignPlayhead(animation, totalTime) {
  // adjusts the animation's _start and _end according to the provided totalTime (only if the parent's smoothChildTiming is true and the animation isn't paused). It doesn't do any rendering or forcing things back into parent timelines, etc. - that's what totalTime() is for.
  var parent = animation._dp;

  if (parent && parent.smoothChildTiming && animation._ts) {
    animation._start = _roundPrecise(parent._time - (animation._ts > 0 ? totalTime / animation._ts : ((animation._dirty ? animation.totalDuration() : animation._tDur) - totalTime) / -animation._ts));

    _setEnd(animation);

    parent._dirty || _uncache(parent, animation); //for performance improvement. If the parent's cache is already dirty, it already took care of marking the ancestors as dirty too, so skip the function call here.
  }

  return animation;
},

/*
_totalTimeToTime = (clampedTotalTime, duration, repeat, repeatDelay, yoyo) => {
	let cycleDuration = duration + repeatDelay,
		time = _round(clampedTotalTime % cycleDuration);
	if (time > duration) {
		time = duration;
	}
	return (yoyo && (~~(clampedTotalTime / cycleDuration) & 1)) ? duration - time : time;
},
*/
_postAddChecks = function _postAddChecks(timeline, child) {
  var t;

  if (child._time || child._initted && !child._dur) {
    //in case, for example, the _start is moved on a tween that has already rendered. Imagine it's at its end state, then the startTime is moved WAY later (after the end of this timeline), it should render at its beginning.
    t = _parentToChildTotalTime(timeline.rawTime(), child);

    if (!child._dur || _clamp(0, child.totalDuration(), t) - child._tTime > _tinyNum) {
      child.render(t, true);
    }
  } //if the timeline has already ended but the inserted tween/timeline extends the duration, we should enable this timeline again so that it renders properly. We should also align the playhead with the parent timeline's when appropriate.


  if (_uncache(timeline, child)._dp && timeline._initted && timeline._time >= timeline._dur && timeline._ts) {
    //in case any of the ancestors had completed but should now be enabled...
    if (timeline._dur < timeline.duration()) {
      t = timeline;

      while (t._dp) {
        t.rawTime() >= 0 && t.totalTime(t._tTime); //moves the timeline (shifts its startTime) if necessary, and also enables it. If it's currently zero, though, it may not be scheduled to render until later so there's no need to force it to align with the current playhead position. Only move to catch up with the playhead.

        t = t._dp;
      }
    }

    timeline._zTime = -_tinyNum; // helps ensure that the next render() will be forced (crossingStart = true in render()), even if the duration hasn't changed (we're adding a child which would need to get rendered). Definitely an edge case. Note: we MUST do this AFTER the loop above where the totalTime() might trigger a render() because this _addToTimeline() method gets called from the Animation constructor, BEFORE tweens even record their targets, etc. so we wouldn't want things to get triggered in the wrong order.
  }
},
    _addToTimeline = function _addToTimeline(timeline, child, position, skipChecks) {
  child.parent && _removeFromParent(child);
  child._start = _roundPrecise((_isNumber(position) ? position : position || timeline !== _globalTimeline ? _parsePosition(timeline, position, child) : timeline._time) + child._delay);
  child._end = _roundPrecise(child._start + (child.totalDuration() / Math.abs(child.timeScale()) || 0));

  _addLinkedListItem(timeline, child, "_first", "_last", timeline._sort ? "_start" : 0);

  _isFromOrFromStart(child) || (timeline._recent = child);
  skipChecks || _postAddChecks(timeline, child);
  return timeline;
},
    _scrollTrigger = function _scrollTrigger(animation, trigger) {
  return (_globals.ScrollTrigger || _missingPlugin("scrollTrigger", trigger)) && _globals.ScrollTrigger.create(trigger, animation);
},
    _attemptInitTween = function _attemptInitTween(tween, totalTime, force, suppressEvents) {
  _initTween(tween, totalTime);

  if (!tween._initted) {
    return 1;
  }

  if (!force && tween._pt && (tween._dur && tween.vars.lazy !== false || !tween._dur && tween.vars.lazy) && _lastRenderedFrame !== _ticker.frame) {
    _lazyTweens.push(tween);

    tween._lazy = [totalTime, suppressEvents];
    return 1;
  }
},
    _parentPlayheadIsBeforeStart = function _parentPlayheadIsBeforeStart(_ref) {
  var parent = _ref.parent;
  return parent && parent._ts && parent._initted && !parent._lock && (parent.rawTime() < 0 || _parentPlayheadIsBeforeStart(parent));
},
    // check parent's _lock because when a timeline repeats/yoyos and does its artificial wrapping, we shouldn't force the ratio back to 0
_isFromOrFromStart = function _isFromOrFromStart(_ref2) {
  var data = _ref2.data;
  return data === "isFromStart" || data === "isStart";
},
    _renderZeroDurationTween = function _renderZeroDurationTween(tween, totalTime, suppressEvents, force) {
  var prevRatio = tween.ratio,
      ratio = totalTime < 0 || !totalTime && (!tween._start && _parentPlayheadIsBeforeStart(tween) && !(!tween._initted && _isFromOrFromStart(tween)) || (tween._ts < 0 || tween._dp._ts < 0) && !_isFromOrFromStart(tween)) ? 0 : 1,
      // if the tween or its parent is reversed and the totalTime is 0, we should go to a ratio of 0. Edge case: if a from() or fromTo() stagger tween is placed later in a timeline, the "startAt" zero-duration tween could initially render at a time when the parent timeline's playhead is technically BEFORE where this tween is, so make sure that any "from" and "fromTo" startAt tweens are rendered the first time at a ratio of 1.
  repeatDelay = tween._rDelay,
      tTime = 0,
      pt,
      iteration,
      prevIteration;

  if (repeatDelay && tween._repeat) {
    // in case there's a zero-duration tween that has a repeat with a repeatDelay
    tTime = _clamp(0, tween._tDur, totalTime);
    iteration = _animationCycle(tTime, repeatDelay);
    tween._yoyo && iteration & 1 && (ratio = 1 - ratio);

    if (iteration !== _animationCycle(tween._tTime, repeatDelay)) {
      // if iteration changed
      prevRatio = 1 - ratio;
      tween.vars.repeatRefresh && tween._initted && tween.invalidate();
    }
  }

  if (ratio !== prevRatio || force || tween._zTime === _tinyNum || !totalTime && tween._zTime) {
    if (!tween._initted && _attemptInitTween(tween, totalTime, force, suppressEvents)) {
      // if we render the very beginning (time == 0) of a fromTo(), we must force the render (normal tweens wouldn't need to render at a time of 0 when the prevTime was also 0). This is also mandatory to make sure overwriting kicks in immediately.
      return;
    }

    prevIteration = tween._zTime;
    tween._zTime = totalTime || (suppressEvents ? _tinyNum : 0); // when the playhead arrives at EXACTLY time 0 (right on top) of a zero-duration tween, we need to discern if events are suppressed so that when the playhead moves again (next time), it'll trigger the callback. If events are NOT suppressed, obviously the callback would be triggered in this render. Basically, the callback should fire either when the playhead ARRIVES or LEAVES this exact spot, not both. Imagine doing a timeline.seek(0) and there's a callback that sits at 0. Since events are suppressed on that seek() by default, nothing will fire, but when the playhead moves off of that position, the callback should fire. This behavior is what people intuitively expect.

    suppressEvents || (suppressEvents = totalTime && !prevIteration); // if it was rendered previously at exactly 0 (_zTime) and now the playhead is moving away, DON'T fire callbacks otherwise they'll seem like duplicates.

    tween.ratio = ratio;
    tween._from && (ratio = 1 - ratio);
    tween._time = 0;
    tween._tTime = tTime;
    pt = tween._pt;

    while (pt) {
      pt.r(ratio, pt.d);
      pt = pt._next;
    }

    tween._startAt && totalTime < 0 && tween._startAt.render(totalTime, true, true);
    tween._onUpdate && !suppressEvents && _callback(tween, "onUpdate");
    tTime && tween._repeat && !suppressEvents && tween.parent && _callback(tween, "onRepeat");

    if ((totalTime >= tween._tDur || totalTime < 0) && tween.ratio === ratio) {
      ratio && _removeFromParent(tween, 1);

      if (!suppressEvents) {
        _callback(tween, ratio ? "onComplete" : "onReverseComplete", true);

        tween._prom && tween._prom();
      }
    }
  } else if (!tween._zTime) {
    tween._zTime = totalTime;
  }
},
    _findNextPauseTween = function _findNextPauseTween(animation, prevTime, time) {
  var child;

  if (time > prevTime) {
    child = animation._first;

    while (child && child._start <= time) {
      if (child.data === "isPause" && child._start > prevTime) {
        return child;
      }

      child = child._next;
    }
  } else {
    child = animation._last;

    while (child && child._start >= time) {
      if (child.data === "isPause" && child._start < prevTime) {
        return child;
      }

      child = child._prev;
    }
  }
},
    _setDuration = function _setDuration(animation, duration, skipUncache, leavePlayhead) {
  var repeat = animation._repeat,
      dur = _roundPrecise(duration) || 0,
      totalProgress = animation._tTime / animation._tDur;
  totalProgress && !leavePlayhead && (animation._time *= dur / animation._dur);
  animation._dur = dur;
  animation._tDur = !repeat ? dur : repeat < 0 ? 1e10 : _roundPrecise(dur * (repeat + 1) + animation._rDelay * repeat);
  totalProgress > 0 && !leavePlayhead ? _alignPlayhead(animation, animation._tTime = animation._tDur * totalProgress) : animation.parent && _setEnd(animation);
  skipUncache || _uncache(animation.parent, animation);
  return animation;
},
    _onUpdateTotalDuration = function _onUpdateTotalDuration(animation) {
  return animation instanceof Timeline ? _uncache(animation) : _setDuration(animation, animation._dur);
},
    _zeroPosition = {
  _start: 0,
  endTime: _emptyFunc,
  totalDuration: _emptyFunc
},
    _parsePosition = function _parsePosition(animation, position, percentAnimation) {
  var labels = animation.labels,
      recent = animation._recent || _zeroPosition,
      clippedDuration = animation.duration() >= _bigNum ? recent.endTime(false) : animation._dur,
      //in case there's a child that infinitely repeats, users almost never intend for the insertion point of a new child to be based on a SUPER long value like that so we clip it and assume the most recently-added child's endTime should be used instead.
  i,
      offset,
      isPercent;

  if (_isString(position) && (isNaN(position) || position in labels)) {
    //if the string is a number like "1", check to see if there's a label with that name, otherwise interpret it as a number (absolute value).
    offset = position.charAt(0);
    isPercent = position.substr(-1) === "%";
    i = position.indexOf("=");

    if (offset === "<" || offset === ">") {
      i >= 0 && (position = position.replace(/=/, ""));
      return (offset === "<" ? recent._start : recent.endTime(recent._repeat >= 0)) + (parseFloat(position.substr(1)) || 0) * (isPercent ? (i < 0 ? recent : percentAnimation).totalDuration() / 100 : 1);
    }

    if (i < 0) {
      position in labels || (labels[position] = clippedDuration);
      return labels[position];
    }

    offset = parseFloat(position.charAt(i - 1) + position.substr(i + 1));

    if (isPercent && percentAnimation) {
      offset = offset / 100 * (_isArray(percentAnimation) ? percentAnimation[0] : percentAnimation).totalDuration();
    }

    return i > 1 ? _parsePosition(animation, position.substr(0, i - 1), percentAnimation) + offset : clippedDuration + offset;
  }

  return position == null ? clippedDuration : +position;
},
    _createTweenType = function _createTweenType(type, params, timeline) {
  var isLegacy = _isNumber(params[1]),
      varsIndex = (isLegacy ? 2 : 1) + (type < 2 ? 0 : 1),
      vars = params[varsIndex],
      irVars,
      parent;

  isLegacy && (vars.duration = params[1]);
  vars.parent = timeline;

  if (type) {
    irVars = vars;
    parent = timeline;

    while (parent && !("immediateRender" in irVars)) {
      // inheritance hasn't happened yet, but someone may have set a default in an ancestor timeline. We could do vars.immediateRender = _isNotFalse(_inheritDefaults(vars).immediateRender) but that'd exact a slight performance penalty because _inheritDefaults() also runs in the Tween constructor. We're paying a small kb price here to gain speed.
      irVars = parent.vars.defaults || {};
      parent = _isNotFalse(parent.vars.inherit) && parent.parent;
    }

    vars.immediateRender = _isNotFalse(irVars.immediateRender);
    type < 2 ? vars.runBackwards = 1 : vars.startAt = params[varsIndex - 1]; // "from" vars
  }

  return new Tween(params[0], vars, params[varsIndex + 1]);
},
    _conditionalReturn = function _conditionalReturn(value, func) {
  return value || value === 0 ? func(value) : func;
},
    _clamp = function _clamp(min, max, value) {
  return value < min ? min : value > max ? max : value;
},
    getUnit = function getUnit(value, v) {
  return !_isString(value) || !(v = _unitExp.exec(value)) ? "" : v[1];
},
    // note: protect against padded numbers as strings, like "100.100". That shouldn't return "00" as the unit. If it's numeric, return no unit.
clamp = function clamp(min, max, value) {
  return _conditionalReturn(value, function (v) {
    return _clamp(min, max, v);
  });
},
    _slice = [].slice,
    _isArrayLike = function _isArrayLike(value, nonEmpty) {
  return value && _isObject(value) && "length" in value && (!nonEmpty && !value.length || value.length - 1 in value && _isObject(value[0])) && !value.nodeType && value !== _win;
},
    _flatten = function _flatten(ar, leaveStrings, accumulator) {
  if (accumulator === void 0) {
    accumulator = [];
  }

  return ar.forEach(function (value) {
    var _accumulator;

    return _isString(value) && !leaveStrings || _isArrayLike(value, 1) ? (_accumulator = accumulator).push.apply(_accumulator, toArray(value)) : accumulator.push(value);
  }) || accumulator;
},
    //takes any value and returns an array. If it's a string (and leaveStrings isn't true), it'll use document.querySelectorAll() and convert that to an array. It'll also accept iterables like jQuery objects.
toArray = function toArray(value, scope, leaveStrings) {
  return _isString(value) && !leaveStrings && (_coreInitted || !_wake()) ? _slice.call((scope || _doc).querySelectorAll(value), 0) : _isArray(value) ? _flatten(value, leaveStrings) : _isArrayLike(value) ? _slice.call(value, 0) : value ? [value] : [];
},
    selector = function selector(value) {
  value = toArray(value)[0] || _warn("Invalid scope") || {};
  return function (v) {
    var el = value.current || value.nativeElement || value;
    return toArray(v, el.querySelectorAll ? el : el === value ? _warn("Invalid scope") || _doc.createElement("div") : value);
  };
},
    shuffle = function shuffle(a) {
  return a.sort(function () {
    return .5 - Math.random();
  });
},
    // alternative that's a bit faster and more reliably diverse but bigger:   for (let j, v, i = a.length; i; j = Math.floor(Math.random() * i), v = a[--i], a[i] = a[j], a[j] = v); return a;
//for distributing values across an array. Can accept a number, a function or (most commonly) a function which can contain the following properties: {base, amount, from, ease, grid, axis, length, each}. Returns a function that expects the following parameters: index, target, array. Recognizes the following
distribute = function distribute(v) {
  if (_isFunction(v)) {
    return v;
  }

  var vars = _isObject(v) ? v : {
    each: v
  },
      //n:1 is just to indicate v was a number; we leverage that later to set v according to the length we get. If a number is passed in, we treat it like the old stagger value where 0.1, for example, would mean that things would be distributed with 0.1 between each element in the array rather than a total "amount" that's chunked out among them all.
  ease = _parseEase(vars.ease),
      from = vars.from || 0,
      base = parseFloat(vars.base) || 0,
      cache = {},
      isDecimal = from > 0 && from < 1,
      ratios = isNaN(from) || isDecimal,
      axis = vars.axis,
      ratioX = from,
      ratioY = from;

  if (_isString(from)) {
    ratioX = ratioY = {
      center: .5,
      edges: .5,
      end: 1
    }[from] || 0;
  } else if (!isDecimal && ratios) {
    ratioX = from[0];
    ratioY = from[1];
  }

  return function (i, target, a) {
    var l = (a || vars).length,
        distances = cache[l],
        originX,
        originY,
        x,
        y,
        d,
        j,
        max,
        min,
        wrapAt;

    if (!distances) {
      wrapAt = vars.grid === "auto" ? 0 : (vars.grid || [1, _bigNum])[1];

      if (!wrapAt) {
        max = -_bigNum;

        while (max < (max = a[wrapAt++].getBoundingClientRect().left) && wrapAt < l) {}

        wrapAt--;
      }

      distances = cache[l] = [];
      originX = ratios ? Math.min(wrapAt, l) * ratioX - .5 : from % wrapAt;
      originY = wrapAt === _bigNum ? 0 : ratios ? l * ratioY / wrapAt - .5 : from / wrapAt | 0;
      max = 0;
      min = _bigNum;

      for (j = 0; j < l; j++) {
        x = j % wrapAt - originX;
        y = originY - (j / wrapAt | 0);
        distances[j] = d = !axis ? _sqrt(x * x + y * y) : Math.abs(axis === "y" ? y : x);
        d > max && (max = d);
        d < min && (min = d);
      }

      from === "random" && shuffle(distances);
      distances.max = max - min;
      distances.min = min;
      distances.v = l = (parseFloat(vars.amount) || parseFloat(vars.each) * (wrapAt > l ? l - 1 : !axis ? Math.max(wrapAt, l / wrapAt) : axis === "y" ? l / wrapAt : wrapAt) || 0) * (from === "edges" ? -1 : 1);
      distances.b = l < 0 ? base - l : base;
      distances.u = getUnit(vars.amount || vars.each) || 0; //unit

      ease = ease && l < 0 ? _invertEase(ease) : ease;
    }

    l = (distances[i] - distances.min) / distances.max || 0;
    return _roundPrecise(distances.b + (ease ? ease(l) : l) * distances.v) + distances.u; //round in order to work around floating point errors
  };
},
    _roundModifier = function _roundModifier(v) {
  //pass in 0.1 get a function that'll round to the nearest tenth, or 5 to round to the closest 5, or 0.001 to the closest 1000th, etc.
  var p = Math.pow(10, ((v + "").split(".")[1] || "").length); //to avoid floating point math errors (like 24 * 0.1 == 2.4000000000000004), we chop off at a specific number of decimal places (much faster than toFixed())

  return function (raw) {
    var n = Math.round(parseFloat(raw) / v) * v * p;
    return (n - n % 1) / p + (_isNumber(raw) ? 0 : getUnit(raw)); // n - n % 1 replaces Math.floor() in order to handle negative values properly. For example, Math.floor(-150.00000000000003) is 151!
  };
},
    snap = function snap(snapTo, value) {
  var isArray = _isArray(snapTo),
      radius,
      is2D;

  if (!isArray && _isObject(snapTo)) {
    radius = isArray = snapTo.radius || _bigNum;

    if (snapTo.values) {
      snapTo = toArray(snapTo.values);

      if (is2D = !_isNumber(snapTo[0])) {
        radius *= radius; //performance optimization so we don't have to Math.sqrt() in the loop.
      }
    } else {
      snapTo = _roundModifier(snapTo.increment);
    }
  }

  return _conditionalReturn(value, !isArray ? _roundModifier(snapTo) : _isFunction(snapTo) ? function (raw) {
    is2D = snapTo(raw);
    return Math.abs(is2D - raw) <= radius ? is2D : raw;
  } : function (raw) {
    var x = parseFloat(is2D ? raw.x : raw),
        y = parseFloat(is2D ? raw.y : 0),
        min = _bigNum,
        closest = 0,
        i = snapTo.length,
        dx,
        dy;

    while (i--) {
      if (is2D) {
        dx = snapTo[i].x - x;
        dy = snapTo[i].y - y;
        dx = dx * dx + dy * dy;
      } else {
        dx = Math.abs(snapTo[i] - x);
      }

      if (dx < min) {
        min = dx;
        closest = i;
      }
    }

    closest = !radius || min <= radius ? snapTo[closest] : raw;
    return is2D || closest === raw || _isNumber(raw) ? closest : closest + getUnit(raw);
  });
},
    random = function random(min, max, roundingIncrement, returnFunction) {
  return _conditionalReturn(_isArray(min) ? !max : roundingIncrement === true ? !!(roundingIncrement = 0) : !returnFunction, function () {
    return _isArray(min) ? min[~~(Math.random() * min.length)] : (roundingIncrement = roundingIncrement || 1e-5) && (returnFunction = roundingIncrement < 1 ? Math.pow(10, (roundingIncrement + "").length - 2) : 1) && Math.floor(Math.round((min - roundingIncrement / 2 + Math.random() * (max - min + roundingIncrement * .99)) / roundingIncrement) * roundingIncrement * returnFunction) / returnFunction;
  });
},
    pipe = function pipe() {
  for (var _len = arguments.length, functions = new Array(_len), _key = 0; _key < _len; _key++) {
    functions[_key] = arguments[_key];
  }

  return function (value) {
    return functions.reduce(function (v, f) {
      return f(v);
    }, value);
  };
},
    unitize = function unitize(func, unit) {
  return function (value) {
    return func(parseFloat(value)) + (unit || getUnit(value));
  };
},
    normalize = function normalize(min, max, value) {
  return mapRange(min, max, 0, 1, value);
},
    _wrapArray = function _wrapArray(a, wrapper, value) {
  return _conditionalReturn(value, function (index) {
    return a[~~wrapper(index)];
  });
},
    wrap = function wrap(min, max, value) {
  // NOTE: wrap() CANNOT be an arrow function! A very odd compiling bug causes problems (unrelated to GSAP).
  var range = max - min;
  return _isArray(min) ? _wrapArray(min, wrap(0, min.length), max) : _conditionalReturn(value, function (value) {
    return (range + (value - min) % range) % range + min;
  });
},
    wrapYoyo = function wrapYoyo(min, max, value) {
  var range = max - min,
      total = range * 2;
  return _isArray(min) ? _wrapArray(min, wrapYoyo(0, min.length - 1), max) : _conditionalReturn(value, function (value) {
    value = (total + (value - min) % total) % total || 0;
    return min + (value > range ? total - value : value);
  });
},
    _replaceRandom = function _replaceRandom(value) {
  //replaces all occurrences of random(...) in a string with the calculated random value. can be a range like random(-100, 100, 5) or an array like random([0, 100, 500])
  var prev = 0,
      s = "",
      i,
      nums,
      end,
      isArray;

  while (~(i = value.indexOf("random(", prev))) {
    end = value.indexOf(")", i);
    isArray = value.charAt(i + 7) === "[";
    nums = value.substr(i + 7, end - i - 7).match(isArray ? _delimitedValueExp : _strictNumExp);
    s += value.substr(prev, i - prev) + random(isArray ? nums : +nums[0], isArray ? 0 : +nums[1], +nums[2] || 1e-5);
    prev = end + 1;
  }

  return s + value.substr(prev, value.length - prev);
},
    mapRange = function mapRange(inMin, inMax, outMin, outMax, value) {
  var inRange = inMax - inMin,
      outRange = outMax - outMin;
  return _conditionalReturn(value, function (value) {
    return outMin + ((value - inMin) / inRange * outRange || 0);
  });
},
    interpolate = function interpolate(start, end, progress, mutate) {
  var func = isNaN(start + end) ? 0 : function (p) {
    return (1 - p) * start + p * end;
  };

  if (!func) {
    var isString = _isString(start),
        master = {},
        p,
        i,
        interpolators,
        l,
        il;

    progress === true && (mutate = 1) && (progress = null);

    if (isString) {
      start = {
        p: start
      };
      end = {
        p: end
      };
    } else if (_isArray(start) && !_isArray(end)) {
      interpolators = [];
      l = start.length;
      il = l - 2;

      for (i = 1; i < l; i++) {
        interpolators.push(interpolate(start[i - 1], start[i])); //build the interpolators up front as a performance optimization so that when the function is called many times, it can just reuse them.
      }

      l--;

      func = function func(p) {
        p *= l;
        var i = Math.min(il, ~~p);
        return interpolators[i](p - i);
      };

      progress = end;
    } else if (!mutate) {
      start = _merge(_isArray(start) ? [] : {}, start);
    }

    if (!interpolators) {
      for (p in end) {
        _addPropTween.call(master, start, p, "get", end[p]);
      }

      func = function func(p) {
        return _renderPropTweens(p, master) || (isString ? start.p : start);
      };
    }
  }

  return _conditionalReturn(progress, func);
},
    _getLabelInDirection = function _getLabelInDirection(timeline, fromTime, backward) {
  //used for nextLabel() and previousLabel()
  var labels = timeline.labels,
      min = _bigNum,
      p,
      distance,
      label;

  for (p in labels) {
    distance = labels[p] - fromTime;

    if (distance < 0 === !!backward && distance && min > (distance = Math.abs(distance))) {
      label = p;
      min = distance;
    }
  }

  return label;
},
    _callback = function _callback(animation, type, executeLazyFirst) {
  var v = animation.vars,
      callback = v[type],
      params,
      scope;

  if (!callback) {
    return;
  }

  params = v[type + "Params"];
  scope = v.callbackScope || animation;
  executeLazyFirst && _lazyTweens.length && _lazyRender(); //in case rendering caused any tweens to lazy-init, we should render them because typically when a timeline finishes, users expect things to have rendered fully. Imagine an onUpdate on a timeline that reports/checks tweened values.

  return params ? callback.apply(scope, params) : callback.call(scope);
},
    _interrupt = function _interrupt(animation) {
  _removeFromParent(animation);

  animation.scrollTrigger && animation.scrollTrigger.kill(false);
  animation.progress() < 1 && _callback(animation, "onInterrupt");
  return animation;
},
    _quickTween,
    _createPlugin = function _createPlugin(config) {
  config = !config.name && config["default"] || config; //UMD packaging wraps things oddly, so for example MotionPathHelper becomes {MotionPathHelper:MotionPathHelper, default:MotionPathHelper}.

  var name = config.name,
      isFunc = _isFunction(config),
      Plugin = name && !isFunc && config.init ? function () {
    this._props = [];
  } : config,
      //in case someone passes in an object that's not a plugin, like CustomEase
  instanceDefaults = {
    init: _emptyFunc,
    render: _renderPropTweens,
    add: _addPropTween,
    kill: _killPropTweensOf,
    modifier: _addPluginModifier,
    rawVars: 0
  },
      statics = {
    targetTest: 0,
    get: 0,
    getSetter: _getSetter,
    aliases: {},
    register: 0
  };

  _wake();

  if (config !== Plugin) {
    if (_plugins[name]) {
      return;
    }

    _setDefaults(Plugin, _setDefaults(_copyExcluding(config, instanceDefaults), statics)); //static methods


    _merge(Plugin.prototype, _merge(instanceDefaults, _copyExcluding(config, statics))); //instance methods


    _plugins[Plugin.prop = name] = Plugin;

    if (config.targetTest) {
      _harnessPlugins.push(Plugin);

      _reservedProps[name] = 1;
    }

    name = (name === "css" ? "CSS" : name.charAt(0).toUpperCase() + name.substr(1)) + "Plugin"; //for the global name. "motionPath" should become MotionPathPlugin
  }

  _addGlobal(name, Plugin);

  config.register && config.register(gsap, Plugin, PropTween);
},

/*
 * --------------------------------------------------------------------------------------
 * COLORS
 * --------------------------------------------------------------------------------------
 */
_255 = 255,
    _colorLookup = {
  aqua: [0, _255, _255],
  lime: [0, _255, 0],
  silver: [192, 192, 192],
  black: [0, 0, 0],
  maroon: [128, 0, 0],
  teal: [0, 128, 128],
  blue: [0, 0, _255],
  navy: [0, 0, 128],
  white: [_255, _255, _255],
  olive: [128, 128, 0],
  yellow: [_255, _255, 0],
  orange: [_255, 165, 0],
  gray: [128, 128, 128],
  purple: [128, 0, 128],
  green: [0, 128, 0],
  red: [_255, 0, 0],
  pink: [_255, 192, 203],
  cyan: [0, _255, _255],
  transparent: [_255, _255, _255, 0]
},
    // possible future idea to replace the hard-coded color name values - put this in the ticker.wake() where we set the _doc:
// let ctx = _doc.createElement("canvas").getContext("2d");
// _forEachName("aqua,lime,silver,black,maroon,teal,blue,navy,white,olive,yellow,orange,gray,purple,green,red,pink,cyan", color => {ctx.fillStyle = color; _colorLookup[color] = splitColor(ctx.fillStyle)});
_hue = function _hue(h, m1, m2) {
  h += h < 0 ? 1 : h > 1 ? -1 : 0;
  return (h * 6 < 1 ? m1 + (m2 - m1) * h * 6 : h < .5 ? m2 : h * 3 < 2 ? m1 + (m2 - m1) * (2 / 3 - h) * 6 : m1) * _255 + .5 | 0;
},
    splitColor = function splitColor(v, toHSL, forceAlpha) {
  var a = !v ? _colorLookup.black : _isNumber(v) ? [v >> 16, v >> 8 & _255, v & _255] : 0,
      r,
      g,
      b,
      h,
      s,
      l,
      max,
      min,
      d,
      wasHSL;

  if (!a) {
    if (v.substr(-1) === ",") {
      //sometimes a trailing comma is included and we should chop it off (typically from a comma-delimited list of values like a textShadow:"2px 2px 2px blue, 5px 5px 5px rgb(255,0,0)" - in this example "blue," has a trailing comma. We could strip it out inside parseComplex() but we'd need to do it to the beginning and ending values plus it wouldn't provide protection from other potential scenarios like if the user passes in a similar value.
      v = v.substr(0, v.length - 1);
    }

    if (_colorLookup[v]) {
      a = _colorLookup[v];
    } else if (v.charAt(0) === "#") {
      if (v.length < 6) {
        //for shorthand like #9F0 or #9F0F (could have alpha)
        r = v.charAt(1);
        g = v.charAt(2);
        b = v.charAt(3);
        v = "#" + r + r + g + g + b + b + (v.length === 5 ? v.charAt(4) + v.charAt(4) : "");
      }

      if (v.length === 9) {
        // hex with alpha, like #fd5e53ff
        a = parseInt(v.substr(1, 6), 16);
        return [a >> 16, a >> 8 & _255, a & _255, parseInt(v.substr(7), 16) / 255];
      }

      v = parseInt(v.substr(1), 16);
      a = [v >> 16, v >> 8 & _255, v & _255];
    } else if (v.substr(0, 3) === "hsl") {
      a = wasHSL = v.match(_strictNumExp);

      if (!toHSL) {
        h = +a[0] % 360 / 360;
        s = +a[1] / 100;
        l = +a[2] / 100;
        g = l <= .5 ? l * (s + 1) : l + s - l * s;
        r = l * 2 - g;
        a.length > 3 && (a[3] *= 1); //cast as number

        a[0] = _hue(h + 1 / 3, r, g);
        a[1] = _hue(h, r, g);
        a[2] = _hue(h - 1 / 3, r, g);
      } else if (~v.indexOf("=")) {
        //if relative values are found, just return the raw strings with the relative prefixes in place.
        a = v.match(_numExp);
        forceAlpha && a.length < 4 && (a[3] = 1);
        return a;
      }
    } else {
      a = v.match(_strictNumExp) || _colorLookup.transparent;
    }

    a = a.map(Number);
  }

  if (toHSL && !wasHSL) {
    r = a[0] / _255;
    g = a[1] / _255;
    b = a[2] / _255;
    max = Math.max(r, g, b);
    min = Math.min(r, g, b);
    l = (max + min) / 2;

    if (max === min) {
      h = s = 0;
    } else {
      d = max - min;
      s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
      h = max === r ? (g - b) / d + (g < b ? 6 : 0) : max === g ? (b - r) / d + 2 : (r - g) / d + 4;
      h *= 60;
    }

    a[0] = ~~(h + .5);
    a[1] = ~~(s * 100 + .5);
    a[2] = ~~(l * 100 + .5);
  }

  forceAlpha && a.length < 4 && (a[3] = 1);
  return a;
},
    _colorOrderData = function _colorOrderData(v) {
  // strips out the colors from the string, finds all the numeric slots (with units) and returns an array of those. The Array also has a "c" property which is an Array of the index values where the colors belong. This is to help work around issues where there's a mis-matched order of color/numeric data like drop-shadow(#f00 0px 1px 2px) and drop-shadow(0x 1px 2px #f00). This is basically a helper function used in _formatColors()
  var values = [],
      c = [],
      i = -1;
  v.split(_colorExp).forEach(function (v) {
    var a = v.match(_numWithUnitExp) || [];
    values.push.apply(values, a);
    c.push(i += a.length + 1);
  });
  values.c = c;
  return values;
},
    _formatColors = function _formatColors(s, toHSL, orderMatchData) {
  var result = "",
      colors = (s + result).match(_colorExp),
      type = toHSL ? "hsla(" : "rgba(",
      i = 0,
      c,
      shell,
      d,
      l;

  if (!colors) {
    return s;
  }

  colors = colors.map(function (color) {
    return (color = splitColor(color, toHSL, 1)) && type + (toHSL ? color[0] + "," + color[1] + "%," + color[2] + "%," + color[3] : color.join(",")) + ")";
  });

  if (orderMatchData) {
    d = _colorOrderData(s);
    c = orderMatchData.c;

    if (c.join(result) !== d.c.join(result)) {
      shell = s.replace(_colorExp, "1").split(_numWithUnitExp);
      l = shell.length - 1;

      for (; i < l; i++) {
        result += shell[i] + (~c.indexOf(i) ? colors.shift() || type + "0,0,0,0)" : (d.length ? d : colors.length ? colors : orderMatchData).shift());
      }
    }
  }

  if (!shell) {
    shell = s.split(_colorExp);
    l = shell.length - 1;

    for (; i < l; i++) {
      result += shell[i] + colors[i];
    }
  }

  return result + shell[l];
},
    _colorExp = function () {
  var s = "(?:\\b(?:(?:rgb|rgba|hsl|hsla)\\(.+?\\))|\\B#(?:[0-9a-f]{3,4}){1,2}\\b",
      //we'll dynamically build this Regular Expression to conserve file size. After building it, it will be able to find rgb(), rgba(), # (hexadecimal), and named color values like red, blue, purple, etc.,
  p;

  for (p in _colorLookup) {
    s += "|" + p + "\\b";
  }

  return new RegExp(s + ")", "gi");
}(),
    _hslExp = /hsl[a]?\(/,
    _colorStringFilter = function _colorStringFilter(a) {
  var combined = a.join(" "),
      toHSL;
  _colorExp.lastIndex = 0;

  if (_colorExp.test(combined)) {
    toHSL = _hslExp.test(combined);
    a[1] = _formatColors(a[1], toHSL);
    a[0] = _formatColors(a[0], toHSL, _colorOrderData(a[1])); // make sure the order of numbers/colors match with the END value.

    return true;
  }
},

/*
 * --------------------------------------------------------------------------------------
 * TICKER
 * --------------------------------------------------------------------------------------
 */
_tickerActive,
    _ticker = function () {
  var _getTime = Date.now,
      _lagThreshold = 500,
      _adjustedLag = 33,
      _startTime = _getTime(),
      _lastUpdate = _startTime,
      _gap = 1000 / 240,
      _nextTime = _gap,
      _listeners = [],
      _id,
      _req,
      _raf,
      _self,
      _delta,
      _i,
      _tick = function _tick(v) {
    var elapsed = _getTime() - _lastUpdate,
        manual = v === true,
        overlap,
        dispatch,
        time,
        frame;

    elapsed > _lagThreshold && (_startTime += elapsed - _adjustedLag);
    _lastUpdate += elapsed;
    time = _lastUpdate - _startTime;
    overlap = time - _nextTime;

    if (overlap > 0 || manual) {
      frame = ++_self.frame;
      _delta = time - _self.time * 1000;
      _self.time = time = time / 1000;
      _nextTime += overlap + (overlap >= _gap ? 4 : _gap - overlap);
      dispatch = 1;
    }

    manual || (_id = _req(_tick)); //make sure the request is made before we dispatch the "tick" event so that timing is maintained. Otherwise, if processing the "tick" requires a bunch of time (like 15ms) and we're using a setTimeout() that's based on 16.7ms, it'd technically take 31.7ms between frames otherwise.

    if (dispatch) {
      for (_i = 0; _i < _listeners.length; _i++) {
        // use _i and check _listeners.length instead of a variable because a listener could get removed during the loop, and if that happens to an element less than the current index, it'd throw things off in the loop.
        _listeners[_i](time, _delta, frame, v);
      }
    }
  };

  _self = {
    time: 0,
    frame: 0,
    tick: function tick() {
      _tick(true);
    },
    deltaRatio: function deltaRatio(fps) {
      return _delta / (1000 / (fps || 60));
    },
    wake: function wake() {
      if (_coreReady) {
        if (!_coreInitted && _windowExists()) {
          _win = _coreInitted = window;
          _doc = _win.document || {};
          _globals.gsap = gsap;
          (_win.gsapVersions || (_win.gsapVersions = [])).push(gsap.version);

          _install(_installScope || _win.GreenSockGlobals || !_win.gsap && _win || {});

          _raf = _win.requestAnimationFrame;
        }

        _id && _self.sleep();

        _req = _raf || function (f) {
          return setTimeout(f, _nextTime - _self.time * 1000 + 1 | 0);
        };

        _tickerActive = 1;

        _tick(2);
      }
    },
    sleep: function sleep() {
      (_raf ? _win.cancelAnimationFrame : clearTimeout)(_id);
      _tickerActive = 0;
      _req = _emptyFunc;
    },
    lagSmoothing: function lagSmoothing(threshold, adjustedLag) {
      _lagThreshold = threshold || 1 / _tinyNum; //zero should be interpreted as basically unlimited

      _adjustedLag = Math.min(adjustedLag, _lagThreshold, 0);
    },
    fps: function fps(_fps) {
      _gap = 1000 / (_fps || 240);
      _nextTime = _self.time * 1000 + _gap;
    },
    add: function add(callback, once, prioritize) {
      var func = once ? function (t, d, f, v) {
        callback(t, d, f, v);

        _self.remove(func);
      } : callback;

      _self.remove(callback);

      _listeners[prioritize ? "unshift" : "push"](func);

      _wake();

      return func;
    },
    remove: function remove(callback, i) {
      ~(i = _listeners.indexOf(callback)) && _listeners.splice(i, 1) && _i >= i && _i--;
    },
    _listeners: _listeners
  };
  return _self;
}(),
    _wake = function _wake() {
  return !_tickerActive && _ticker.wake();
},
    //also ensures the core classes are initialized.

/*
* -------------------------------------------------
* EASING
* -------------------------------------------------
*/
_easeMap = {},
    _customEaseExp = /^[\d.\-M][\d.\-,\s]/,
    _quotesExp = /["']/g,
    _parseObjectInString = function _parseObjectInString(value) {
  //takes a string like "{wiggles:10, type:anticipate})" and turns it into a real object. Notice it ends in ")" and includes the {} wrappers. This is because we only use this function for parsing ease configs and prioritized optimization rather than reusability.
  var obj = {},
      split = value.substr(1, value.length - 3).split(":"),
      key = split[0],
      i = 1,
      l = split.length,
      index,
      val,
      parsedVal;

  for (; i < l; i++) {
    val = split[i];
    index = i !== l - 1 ? val.lastIndexOf(",") : val.length;
    parsedVal = val.substr(0, index);
    obj[key] = isNaN(parsedVal) ? parsedVal.replace(_quotesExp, "").trim() : +parsedVal;
    key = val.substr(index + 1).trim();
  }

  return obj;
},
    _valueInParentheses = function _valueInParentheses(value) {
  var open = value.indexOf("(") + 1,
      close = value.indexOf(")"),
      nested = value.indexOf("(", open);
  return value.substring(open, ~nested && nested < close ? value.indexOf(")", close + 1) : close);
},
    _configEaseFromString = function _configEaseFromString(name) {
  //name can be a string like "elastic.out(1,0.5)", and pass in _easeMap as obj and it'll parse it out and call the actual function like _easeMap.Elastic.easeOut.config(1,0.5). It will also parse custom ease strings as long as CustomEase is loaded and registered (internally as _easeMap._CE).
  var split = (name + "").split("("),
      ease = _easeMap[split[0]];
  return ease && split.length > 1 && ease.config ? ease.config.apply(null, ~name.indexOf("{") ? [_parseObjectInString(split[1])] : _valueInParentheses(name).split(",").map(_numericIfPossible)) : _easeMap._CE && _customEaseExp.test(name) ? _easeMap._CE("", name) : ease;
},
    _invertEase = function _invertEase(ease) {
  return function (p) {
    return 1 - ease(1 - p);
  };
},
    // allow yoyoEase to be set in children and have those affected when the parent/ancestor timeline yoyos.
_propagateYoyoEase = function _propagateYoyoEase(timeline, isYoyo) {
  var child = timeline._first,
      ease;

  while (child) {
    if (child instanceof Timeline) {
      _propagateYoyoEase(child, isYoyo);
    } else if (child.vars.yoyoEase && (!child._yoyo || !child._repeat) && child._yoyo !== isYoyo) {
      if (child.timeline) {
        _propagateYoyoEase(child.timeline, isYoyo);
      } else {
        ease = child._ease;
        child._ease = child._yEase;
        child._yEase = ease;
        child._yoyo = isYoyo;
      }
    }

    child = child._next;
  }
},
    _parseEase = function _parseEase(ease, defaultEase) {
  return !ease ? defaultEase : (_isFunction(ease) ? ease : _easeMap[ease] || _configEaseFromString(ease)) || defaultEase;
},
    _insertEase = function _insertEase(names, easeIn, easeOut, easeInOut) {
  if (easeOut === void 0) {
    easeOut = function easeOut(p) {
      return 1 - easeIn(1 - p);
    };
  }

  if (easeInOut === void 0) {
    easeInOut = function easeInOut(p) {
      return p < .5 ? easeIn(p * 2) / 2 : 1 - easeIn((1 - p) * 2) / 2;
    };
  }

  var ease = {
    easeIn: easeIn,
    easeOut: easeOut,
    easeInOut: easeInOut
  },
      lowercaseName;

  _forEachName(names, function (name) {
    _easeMap[name] = _globals[name] = ease;
    _easeMap[lowercaseName = name.toLowerCase()] = easeOut;

    for (var p in ease) {
      _easeMap[lowercaseName + (p === "easeIn" ? ".in" : p === "easeOut" ? ".out" : ".inOut")] = _easeMap[name + "." + p] = ease[p];
    }
  });

  return ease;
},
    _easeInOutFromOut = function _easeInOutFromOut(easeOut) {
  return function (p) {
    return p < .5 ? (1 - easeOut(1 - p * 2)) / 2 : .5 + easeOut((p - .5) * 2) / 2;
  };
},
    _configElastic = function _configElastic(type, amplitude, period) {
  var p1 = amplitude >= 1 ? amplitude : 1,
      //note: if amplitude is < 1, we simply adjust the period for a more natural feel. Otherwise the math doesn't work right and the curve starts at 1.
  p2 = (period || (type ? .3 : .45)) / (amplitude < 1 ? amplitude : 1),
      p3 = p2 / _2PI * (Math.asin(1 / p1) || 0),
      easeOut = function easeOut(p) {
    return p === 1 ? 1 : p1 * Math.pow(2, -10 * p) * _sin((p - p3) * p2) + 1;
  },
      ease = type === "out" ? easeOut : type === "in" ? function (p) {
    return 1 - easeOut(1 - p);
  } : _easeInOutFromOut(easeOut);

  p2 = _2PI / p2; //precalculate to optimize

  ease.config = function (amplitude, period) {
    return _configElastic(type, amplitude, period);
  };

  return ease;
},
    _configBack = function _configBack(type, overshoot) {
  if (overshoot === void 0) {
    overshoot = 1.70158;
  }

  var easeOut = function easeOut(p) {
    return p ? --p * p * ((overshoot + 1) * p + overshoot) + 1 : 0;
  },
      ease = type === "out" ? easeOut : type === "in" ? function (p) {
    return 1 - easeOut(1 - p);
  } : _easeInOutFromOut(easeOut);

  ease.config = function (overshoot) {
    return _configBack(type, overshoot);
  };

  return ease;
}; // a cheaper (kb and cpu) but more mild way to get a parameterized weighted ease by feeding in a value between -1 (easeIn) and 1 (easeOut) where 0 is linear.
// _weightedEase = ratio => {
// 	let y = 0.5 + ratio / 2;
// 	return p => (2 * (1 - p) * p * y + p * p);
// },
// a stronger (but more expensive kb/cpu) parameterized weighted ease that lets you feed in a value between -1 (easeIn) and 1 (easeOut) where 0 is linear.
// _weightedEaseStrong = ratio => {
// 	ratio = .5 + ratio / 2;
// 	let o = 1 / 3 * (ratio < .5 ? ratio : 1 - ratio),
// 		b = ratio - o,
// 		c = ratio + o;
// 	return p => p === 1 ? p : 3 * b * (1 - p) * (1 - p) * p + 3 * c * (1 - p) * p * p + p * p * p;
// };


_forEachName("Linear,Quad,Cubic,Quart,Quint,Strong", function (name, i) {
  var power = i < 5 ? i + 1 : i;

  _insertEase(name + ",Power" + (power - 1), i ? function (p) {
    return Math.pow(p, power);
  } : function (p) {
    return p;
  }, function (p) {
    return 1 - Math.pow(1 - p, power);
  }, function (p) {
    return p < .5 ? Math.pow(p * 2, power) / 2 : 1 - Math.pow((1 - p) * 2, power) / 2;
  });
});

_easeMap.Linear.easeNone = _easeMap.none = _easeMap.Linear.easeIn;

_insertEase("Elastic", _configElastic("in"), _configElastic("out"), _configElastic());

(function (n, c) {
  var n1 = 1 / c,
      n2 = 2 * n1,
      n3 = 2.5 * n1,
      easeOut = function easeOut(p) {
    return p < n1 ? n * p * p : p < n2 ? n * Math.pow(p - 1.5 / c, 2) + .75 : p < n3 ? n * (p -= 2.25 / c) * p + .9375 : n * Math.pow(p - 2.625 / c, 2) + .984375;
  };

  _insertEase("Bounce", function (p) {
    return 1 - easeOut(1 - p);
  }, easeOut);
})(7.5625, 2.75);

_insertEase("Expo", function (p) {
  return p ? Math.pow(2, 10 * (p - 1)) : 0;
});

_insertEase("Circ", function (p) {
  return -(_sqrt(1 - p * p) - 1);
});

_insertEase("Sine", function (p) {
  return p === 1 ? 1 : -_cos(p * _HALF_PI) + 1;
});

_insertEase("Back", _configBack("in"), _configBack("out"), _configBack());

_easeMap.SteppedEase = _easeMap.steps = _globals.SteppedEase = {
  config: function config(steps, immediateStart) {
    if (steps === void 0) {
      steps = 1;
    }

    var p1 = 1 / steps,
        p2 = steps + (immediateStart ? 0 : 1),
        p3 = immediateStart ? 1 : 0,
        max = 1 - _tinyNum;
    return function (p) {
      return ((p2 * _clamp(0, max, p) | 0) + p3) * p1;
    };
  }
};
_defaults.ease = _easeMap["quad.out"];

_forEachName("onComplete,onUpdate,onStart,onRepeat,onReverseComplete,onInterrupt", function (name) {
  return _callbackNames += name + "," + name + "Params,";
});
/*
 * --------------------------------------------------------------------------------------
 * CACHE
 * --------------------------------------------------------------------------------------
 */


var GSCache = function GSCache(target, harness) {
  this.id = _gsID++;
  target._gsap = this;
  this.target = target;
  this.harness = harness;
  this.get = harness ? harness.get : _getProperty;
  this.set = harness ? harness.getSetter : _getSetter;
};
/*
 * --------------------------------------------------------------------------------------
 * ANIMATION
 * --------------------------------------------------------------------------------------
 */

var Animation = /*#__PURE__*/function () {
  function Animation(vars) {
    this.vars = vars;
    this._delay = +vars.delay || 0;

    if (this._repeat = vars.repeat === Infinity ? -2 : vars.repeat || 0) {
      // TODO: repeat: Infinity on a timeline's children must flag that timeline internally and affect its totalDuration, otherwise it'll stop in the negative direction when reaching the start.
      this._rDelay = vars.repeatDelay || 0;
      this._yoyo = !!vars.yoyo || !!vars.yoyoEase;
    }

    this._ts = 1;

    _setDuration(this, +vars.duration, 1, 1);

    this.data = vars.data;
    _tickerActive || _ticker.wake();
  }

  var _proto = Animation.prototype;

  _proto.delay = function delay(value) {
    if (value || value === 0) {
      this.parent && this.parent.smoothChildTiming && this.startTime(this._start + value - this._delay);
      this._delay = value;
      return this;
    }

    return this._delay;
  };

  _proto.duration = function duration(value) {
    return arguments.length ? this.totalDuration(this._repeat > 0 ? value + (value + this._rDelay) * this._repeat : value) : this.totalDuration() && this._dur;
  };

  _proto.totalDuration = function totalDuration(value) {
    if (!arguments.length) {
      return this._tDur;
    }

    this._dirty = 0;
    return _setDuration(this, this._repeat < 0 ? value : (value - this._repeat * this._rDelay) / (this._repeat + 1));
  };

  _proto.totalTime = function totalTime(_totalTime, suppressEvents) {
    _wake();

    if (!arguments.length) {
      return this._tTime;
    }

    var parent = this._dp;

    if (parent && parent.smoothChildTiming && this._ts) {
      _alignPlayhead(this, _totalTime);

      !parent._dp || parent.parent || _postAddChecks(parent, this); // edge case: if this is a child of a timeline that already completed, for example, we must re-activate the parent.
      //in case any of the ancestor timelines had completed but should now be enabled, we should reset their totalTime() which will also ensure that they're lined up properly and enabled. Skip for animations that are on the root (wasteful). Example: a TimelineLite.exportRoot() is performed when there's a paused tween on the root, the export will not complete until that tween is unpaused, but imagine a child gets restarted later, after all [unpaused] tweens have completed. The start of that child would get pushed out, but one of the ancestors may have completed.

      while (parent && parent.parent) {
        if (parent.parent._time !== parent._start + (parent._ts >= 0 ? parent._tTime / parent._ts : (parent.totalDuration() - parent._tTime) / -parent._ts)) {
          parent.totalTime(parent._tTime, true);
        }

        parent = parent.parent;
      }

      if (!this.parent && this._dp.autoRemoveChildren && (this._ts > 0 && _totalTime < this._tDur || this._ts < 0 && _totalTime > 0 || !this._tDur && !_totalTime)) {
        //if the animation doesn't have a parent, put it back into its last parent (recorded as _dp for exactly cases like this). Limit to parents with autoRemoveChildren (like globalTimeline) so that if the user manually removes an animation from a timeline and then alters its playhead, it doesn't get added back in.
        _addToTimeline(this._dp, this, this._start - this._delay);
      }
    }

    if (this._tTime !== _totalTime || !this._dur && !suppressEvents || this._initted && Math.abs(this._zTime) === _tinyNum || !_totalTime && !this._initted && (this.add || this._ptLookup)) {
      // check for _ptLookup on a Tween instance to ensure it has actually finished being instantiated, otherwise if this.reverse() gets called in the Animation constructor, it could trigger a render() here even though the _targets weren't populated, thus when _init() is called there won't be any PropTweens (it'll act like the tween is non-functional)
      this._ts || (this._pTime = _totalTime); // otherwise, if an animation is paused, then the playhead is moved back to zero, then resumed, it'd revert back to the original time at the pause
      //if (!this._lock) { // avoid endless recursion (not sure we need this yet or if it's worth the performance hit)
      //   this._lock = 1;

      _lazySafeRender(this, _totalTime, suppressEvents); //   this._lock = 0;
      //}

    }

    return this;
  };

  _proto.time = function time(value, suppressEvents) {
    return arguments.length ? this.totalTime(Math.min(this.totalDuration(), value + _elapsedCycleDuration(this)) % (this._dur + this._rDelay) || (value ? this._dur : 0), suppressEvents) : this._time; // note: if the modulus results in 0, the playhead could be exactly at the end or the beginning, and we always defer to the END with a non-zero value, otherwise if you set the time() to the very end (duration()), it would render at the START!
  };

  _proto.totalProgress = function totalProgress(value, suppressEvents) {
    return arguments.length ? this.totalTime(this.totalDuration() * value, suppressEvents) : this.totalDuration() ? Math.min(1, this._tTime / this._tDur) : this.ratio;
  };

  _proto.progress = function progress(value, suppressEvents) {
    return arguments.length ? this.totalTime(this.duration() * (this._yoyo && !(this.iteration() & 1) ? 1 - value : value) + _elapsedCycleDuration(this), suppressEvents) : this.duration() ? Math.min(1, this._time / this._dur) : this.ratio;
  };

  _proto.iteration = function iteration(value, suppressEvents) {
    var cycleDuration = this.duration() + this._rDelay;

    return arguments.length ? this.totalTime(this._time + (value - 1) * cycleDuration, suppressEvents) : this._repeat ? _animationCycle(this._tTime, cycleDuration) + 1 : 1;
  } // potential future addition:
  // isPlayingBackwards() {
  // 	let animation = this,
  // 		orientation = 1; // 1 = forward, -1 = backward
  // 	while (animation) {
  // 		orientation *= animation.reversed() || (animation.repeat() && !(animation.iteration() & 1)) ? -1 : 1;
  // 		animation = animation.parent;
  // 	}
  // 	return orientation < 0;
  // }
  ;

  _proto.timeScale = function timeScale(value) {
    if (!arguments.length) {
      return this._rts === -_tinyNum ? 0 : this._rts; // recorded timeScale. Special case: if someone calls reverse() on an animation with timeScale of 0, we assign it -_tinyNum to remember it's reversed.
    }

    if (this._rts === value) {
      return this;
    }

    var tTime = this.parent && this._ts ? _parentToChildTotalTime(this.parent._time, this) : this._tTime; // make sure to do the parentToChildTotalTime() BEFORE setting the new _ts because the old one must be used in that calculation.
    // future addition? Up side: fast and minimal file size. Down side: only works on this animation; if a timeline is reversed, for example, its childrens' onReverse wouldn't get called.
    //(+value < 0 && this._rts >= 0) && _callback(this, "onReverse", true);
    // prioritize rendering where the parent's playhead lines up instead of this._tTime because there could be a tween that's animating another tween's timeScale in the same rendering loop (same parent), thus if the timeScale tween renders first, it would alter _start BEFORE _tTime was set on that tick (in the rendering loop), effectively freezing it until the timeScale tween finishes.

    this._rts = +value || 0;
    this._ts = this._ps || value === -_tinyNum ? 0 : this._rts; // _ts is the functional timeScale which would be 0 if the animation is paused.

    this.totalTime(_clamp(-this._delay, this._tDur, tTime), true);

    _setEnd(this); // if parent.smoothChildTiming was false, the end time didn't get updated in the _alignPlayhead() method, so do it here.


    return _recacheAncestors(this);
  };

  _proto.paused = function paused(value) {
    if (!arguments.length) {
      return this._ps;
    }

    if (this._ps !== value) {
      this._ps = value;

      if (value) {
        this._pTime = this._tTime || Math.max(-this._delay, this.rawTime()); // if the pause occurs during the delay phase, make sure that's factored in when resuming.

        this._ts = this._act = 0; // _ts is the functional timeScale, so a paused tween would effectively have a timeScale of 0. We record the "real" timeScale as _rts (recorded time scale)
      } else {
        _wake();

        this._ts = this._rts; //only defer to _pTime (pauseTime) if tTime is zero. Remember, someone could pause() an animation, then scrub the playhead and resume(). If the parent doesn't have smoothChildTiming, we render at the rawTime() because the startTime won't get updated.

        this.totalTime(this.parent && !this.parent.smoothChildTiming ? this.rawTime() : this._tTime || this._pTime, this.progress() === 1 && Math.abs(this._zTime) !== _tinyNum && (this._tTime -= _tinyNum)); // edge case: animation.progress(1).pause().play() wouldn't render again because the playhead is already at the end, but the call to totalTime() below will add it back to its parent...and not remove it again (since removing only happens upon rendering at a new time). Offsetting the _tTime slightly is done simply to cause the final render in totalTime() that'll pop it off its timeline (if autoRemoveChildren is true, of course). Check to make sure _zTime isn't -_tinyNum to avoid an edge case where the playhead is pushed to the end but INSIDE a tween/callback, the timeline itself is paused thus halting rendering and leaving a few unrendered. When resuming, it wouldn't render those otherwise.
      }
    }

    return this;
  };

  _proto.startTime = function startTime(value) {
    if (arguments.length) {
      this._start = value;
      var parent = this.parent || this._dp;
      parent && (parent._sort || !this.parent) && _addToTimeline(parent, this, value - this._delay);
      return this;
    }

    return this._start;
  };

  _proto.endTime = function endTime(includeRepeats) {
    return this._start + (_isNotFalse(includeRepeats) ? this.totalDuration() : this.duration()) / Math.abs(this._ts || 1);
  };

  _proto.rawTime = function rawTime(wrapRepeats) {
    var parent = this.parent || this._dp; // _dp = detached parent

    return !parent ? this._tTime : wrapRepeats && (!this._ts || this._repeat && this._time && this.totalProgress() < 1) ? this._tTime % (this._dur + this._rDelay) : !this._ts ? this._tTime : _parentToChildTotalTime(parent.rawTime(wrapRepeats), this);
  };

  _proto.globalTime = function globalTime(rawTime) {
    var animation = this,
        time = arguments.length ? rawTime : animation.rawTime();

    while (animation) {
      time = animation._start + time / (animation._ts || 1);
      animation = animation._dp;
    }

    return time;
  };

  _proto.repeat = function repeat(value) {
    if (arguments.length) {
      this._repeat = value === Infinity ? -2 : value;
      return _onUpdateTotalDuration(this);
    }

    return this._repeat === -2 ? Infinity : this._repeat;
  };

  _proto.repeatDelay = function repeatDelay(value) {
    if (arguments.length) {
      var time = this._time;
      this._rDelay = value;

      _onUpdateTotalDuration(this);

      return time ? this.time(time) : this;
    }

    return this._rDelay;
  };

  _proto.yoyo = function yoyo(value) {
    if (arguments.length) {
      this._yoyo = value;
      return this;
    }

    return this._yoyo;
  };

  _proto.seek = function seek(position, suppressEvents) {
    return this.totalTime(_parsePosition(this, position), _isNotFalse(suppressEvents));
  };

  _proto.restart = function restart(includeDelay, suppressEvents) {
    return this.play().totalTime(includeDelay ? -this._delay : 0, _isNotFalse(suppressEvents));
  };

  _proto.play = function play(from, suppressEvents) {
    from != null && this.seek(from, suppressEvents);
    return this.reversed(false).paused(false);
  };

  _proto.reverse = function reverse(from, suppressEvents) {
    from != null && this.seek(from || this.totalDuration(), suppressEvents);
    return this.reversed(true).paused(false);
  };

  _proto.pause = function pause(atTime, suppressEvents) {
    atTime != null && this.seek(atTime, suppressEvents);
    return this.paused(true);
  };

  _proto.resume = function resume() {
    return this.paused(false);
  };

  _proto.reversed = function reversed(value) {
    if (arguments.length) {
      !!value !== this.reversed() && this.timeScale(-this._rts || (value ? -_tinyNum : 0)); // in case timeScale is zero, reversing would have no effect so we use _tinyNum.

      return this;
    }

    return this._rts < 0;
  };

  _proto.invalidate = function invalidate() {
    this._initted = this._act = 0;
    this._zTime = -_tinyNum;
    return this;
  };

  _proto.isActive = function isActive() {
    var parent = this.parent || this._dp,
        start = this._start,
        rawTime;
    return !!(!parent || this._ts && this._initted && parent.isActive() && (rawTime = parent.rawTime(true)) >= start && rawTime < this.endTime(true) - _tinyNum);
  };

  _proto.eventCallback = function eventCallback(type, callback, params) {
    var vars = this.vars;

    if (arguments.length > 1) {
      if (!callback) {
        delete vars[type];
      } else {
        vars[type] = callback;
        params && (vars[type + "Params"] = params);
        type === "onUpdate" && (this._onUpdate = callback);
      }

      return this;
    }

    return vars[type];
  };

  _proto.then = function then(onFulfilled) {
    var self = this;
    return new Promise(function (resolve) {
      var f = _isFunction(onFulfilled) ? onFulfilled : _passThrough,
          _resolve = function _resolve() {
        var _then = self.then;
        self.then = null; // temporarily null the then() method to avoid an infinite loop (see https://github.com/greensock/GSAP/issues/322)

        _isFunction(f) && (f = f(self)) && (f.then || f === self) && (self.then = _then);
        resolve(f);
        self.then = _then;
      };

      if (self._initted && self.totalProgress() === 1 && self._ts >= 0 || !self._tTime && self._ts < 0) {
        _resolve();
      } else {
        self._prom = _resolve;
      }
    });
  };

  _proto.kill = function kill() {
    _interrupt(this);
  };

  return Animation;
}();

_setDefaults(Animation.prototype, {
  _time: 0,
  _start: 0,
  _end: 0,
  _tTime: 0,
  _tDur: 0,
  _dirty: 0,
  _repeat: 0,
  _yoyo: false,
  parent: null,
  _initted: false,
  _rDelay: 0,
  _ts: 1,
  _dp: 0,
  ratio: 0,
  _zTime: -_tinyNum,
  _prom: 0,
  _ps: false,
  _rts: 1
});
/*
 * -------------------------------------------------
 * TIMELINE
 * -------------------------------------------------
 */


var Timeline = /*#__PURE__*/function (_Animation) {
  _inheritsLoose(Timeline, _Animation);

  function Timeline(vars, position) {
    var _this;

    if (vars === void 0) {
      vars = {};
    }

    _this = _Animation.call(this, vars) || this;
    _this.labels = {};
    _this.smoothChildTiming = !!vars.smoothChildTiming;
    _this.autoRemoveChildren = !!vars.autoRemoveChildren;
    _this._sort = _isNotFalse(vars.sortChildren);
    _globalTimeline && _addToTimeline(vars.parent || _globalTimeline, _assertThisInitialized(_this), position);
    vars.reversed && _this.reverse();
    vars.paused && _this.paused(true);
    vars.scrollTrigger && _scrollTrigger(_assertThisInitialized(_this), vars.scrollTrigger);
    return _this;
  }

  var _proto2 = Timeline.prototype;

  _proto2.to = function to(targets, vars, position) {
    _createTweenType(0, arguments, this);

    return this;
  };

  _proto2.from = function from(targets, vars, position) {
    _createTweenType(1, arguments, this);

    return this;
  };

  _proto2.fromTo = function fromTo(targets, fromVars, toVars, position) {
    _createTweenType(2, arguments, this);

    return this;
  };

  _proto2.set = function set(targets, vars, position) {
    vars.duration = 0;
    vars.parent = this;
    _inheritDefaults(vars).repeatDelay || (vars.repeat = 0);
    vars.immediateRender = !!vars.immediateRender;
    new Tween(targets, vars, _parsePosition(this, position), 1);
    return this;
  };

  _proto2.call = function call(callback, params, position) {
    return _addToTimeline(this, Tween.delayedCall(0, callback, params), position);
  } //ONLY for backward compatibility! Maybe delete?
  ;

  _proto2.staggerTo = function staggerTo(targets, duration, vars, stagger, position, onCompleteAll, onCompleteAllParams) {
    vars.duration = duration;
    vars.stagger = vars.stagger || stagger;
    vars.onComplete = onCompleteAll;
    vars.onCompleteParams = onCompleteAllParams;
    vars.parent = this;
    new Tween(targets, vars, _parsePosition(this, position));
    return this;
  };

  _proto2.staggerFrom = function staggerFrom(targets, duration, vars, stagger, position, onCompleteAll, onCompleteAllParams) {
    vars.runBackwards = 1;
    _inheritDefaults(vars).immediateRender = _isNotFalse(vars.immediateRender);
    return this.staggerTo(targets, duration, vars, stagger, position, onCompleteAll, onCompleteAllParams);
  };

  _proto2.staggerFromTo = function staggerFromTo(targets, duration, fromVars, toVars, stagger, position, onCompleteAll, onCompleteAllParams) {
    toVars.startAt = fromVars;
    _inheritDefaults(toVars).immediateRender = _isNotFalse(toVars.immediateRender);
    return this.staggerTo(targets, duration, toVars, stagger, position, onCompleteAll, onCompleteAllParams);
  };

  _proto2.render = function render(totalTime, suppressEvents, force) {
    var prevTime = this._time,
        tDur = this._dirty ? this.totalDuration() : this._tDur,
        dur = this._dur,
        tTime = totalTime <= 0 ? 0 : _roundPrecise(totalTime),
        // if a paused timeline is resumed (or its _start is updated for another reason...which rounds it), that could result in the playhead shifting a **tiny** amount and a zero-duration child at that spot may get rendered at a different ratio, like its totalTime in render() may be 1e-17 instead of 0, for example.
    crossingStart = this._zTime < 0 !== totalTime < 0 && (this._initted || !dur),
        time,
        child,
        next,
        iteration,
        cycleDuration,
        prevPaused,
        pauseTween,
        timeScale,
        prevStart,
        prevIteration,
        yoyo,
        isYoyo;
    this !== _globalTimeline && tTime > tDur && totalTime >= 0 && (tTime = tDur);

    if (tTime !== this._tTime || force || crossingStart) {
      if (prevTime !== this._time && dur) {
        //if totalDuration() finds a child with a negative startTime and smoothChildTiming is true, things get shifted around internally so we need to adjust the time accordingly. For example, if a tween starts at -30 we must shift EVERYTHING forward 30 seconds and move this timeline's startTime backward by 30 seconds so that things align with the playhead (no jump).
        tTime += this._time - prevTime;
        totalTime += this._time - prevTime;
      }

      time = tTime;
      prevStart = this._start;
      timeScale = this._ts;
      prevPaused = !timeScale;

      if (crossingStart) {
        dur || (prevTime = this._zTime); //when the playhead arrives at EXACTLY time 0 (right on top) of a zero-duration timeline, we need to discern if events are suppressed so that when the playhead moves again (next time), it'll trigger the callback. If events are NOT suppressed, obviously the callback would be triggered in this render. Basically, the callback should fire either when the playhead ARRIVES or LEAVES this exact spot, not both. Imagine doing a timeline.seek(0) and there's a callback that sits at 0. Since events are suppressed on that seek() by default, nothing will fire, but when the playhead moves off of that position, the callback should fire. This behavior is what people intuitively expect.

        (totalTime || !suppressEvents) && (this._zTime = totalTime);
      }

      if (this._repeat) {
        //adjust the time for repeats and yoyos
        yoyo = this._yoyo;
        cycleDuration = dur + this._rDelay;

        if (this._repeat < -1 && totalTime < 0) {
          return this.totalTime(cycleDuration * 100 + totalTime, suppressEvents, force);
        }

        time = _roundPrecise(tTime % cycleDuration); //round to avoid floating point errors. (4 % 0.8 should be 0 but some browsers report it as 0.79999999!)

        if (tTime === tDur) {
          // the tDur === tTime is for edge cases where there's a lengthy decimal on the duration and it may reach the very end but the time is rendered as not-quite-there (remember, tDur is rounded to 4 decimals whereas dur isn't)
          iteration = this._repeat;
          time = dur;
        } else {
          iteration = ~~(tTime / cycleDuration);

          if (iteration && iteration === tTime / cycleDuration) {
            time = dur;
            iteration--;
          }

          time > dur && (time = dur);
        }

        prevIteration = _animationCycle(this._tTime, cycleDuration);
        !prevTime && this._tTime && prevIteration !== iteration && (prevIteration = iteration); // edge case - if someone does addPause() at the very beginning of a repeating timeline, that pause is technically at the same spot as the end which causes this._time to get set to 0 when the totalTime would normally place the playhead at the end. See https://greensock.com/forums/topic/23823-closing-nav-animation-not-working-on-ie-and-iphone-6-maybe-other-older-browser/?tab=comments#comment-113005

        if (yoyo && iteration & 1) {
          time = dur - time;
          isYoyo = 1;
        }
        /*
        make sure children at the end/beginning of the timeline are rendered properly. If, for example,
        a 3-second long timeline rendered at 2.9 seconds previously, and now renders at 3.2 seconds (which
        would get translated to 2.8 seconds if the timeline yoyos or 0.2 seconds if it just repeats), there
        could be a callback or a short tween that's at 2.95 or 3 seconds in which wouldn't render. So
        we need to push the timeline to the end (and/or beginning depending on its yoyo value). Also we must
        ensure that zero-duration tweens at the very beginning or end of the Timeline work.
        */


        if (iteration !== prevIteration && !this._lock) {
          var rewinding = yoyo && prevIteration & 1,
              doesWrap = rewinding === (yoyo && iteration & 1);
          iteration < prevIteration && (rewinding = !rewinding);
          prevTime = rewinding ? 0 : dur;
          this._lock = 1;
          this.render(prevTime || (isYoyo ? 0 : _roundPrecise(iteration * cycleDuration)), suppressEvents, !dur)._lock = 0;
          this._tTime = tTime; // if a user gets the iteration() inside the onRepeat, for example, it should be accurate.

          !suppressEvents && this.parent && _callback(this, "onRepeat");
          this.vars.repeatRefresh && !isYoyo && (this.invalidate()._lock = 1);

          if (prevTime && prevTime !== this._time || prevPaused !== !this._ts || this.vars.onRepeat && !this.parent && !this._act) {
            // if prevTime is 0 and we render at the very end, _time will be the end, thus won't match. So in this edge case, prevTime won't match _time but that's okay. If it gets killed in the onRepeat, eject as well.
            return this;
          }

          dur = this._dur; // in case the duration changed in the onRepeat

          tDur = this._tDur;

          if (doesWrap) {
            this._lock = 2;
            prevTime = rewinding ? dur : -0.0001;
            this.render(prevTime, true);
            this.vars.repeatRefresh && !isYoyo && this.invalidate();
          }

          this._lock = 0;

          if (!this._ts && !prevPaused) {
            return this;
          } //in order for yoyoEase to work properly when there's a stagger, we must swap out the ease in each sub-tween.


          _propagateYoyoEase(this, isYoyo);
        }
      }

      if (this._hasPause && !this._forcing && this._lock < 2) {
        pauseTween = _findNextPauseTween(this, _roundPrecise(prevTime), _roundPrecise(time));

        if (pauseTween) {
          tTime -= time - (time = pauseTween._start);
        }
      }

      this._tTime = tTime;
      this._time = time;
      this._act = !timeScale; //as long as it's not paused, force it to be active so that if the user renders independent of the parent timeline, it'll be forced to re-render on the next tick.

      if (!this._initted) {
        this._onUpdate = this.vars.onUpdate;
        this._initted = 1;
        this._zTime = totalTime;
        prevTime = 0; // upon init, the playhead should always go forward; someone could invalidate() a completed timeline and then if they restart(), that would make child tweens render in reverse order which could lock in the wrong starting values if they build on each other, like tl.to(obj, {x: 100}).to(obj, {x: 0}).
      }

      if (!prevTime && time && !suppressEvents) {
        _callback(this, "onStart");

        if (this._tTime !== tTime) {
          // in case the onStart triggered a render at a different spot, eject. Like if someone did animation.pause(0.5) or something inside the onStart.
          return this;
        }
      }

      if (time >= prevTime && totalTime >= 0) {
        child = this._first;

        while (child) {
          next = child._next;

          if ((child._act || time >= child._start) && child._ts && pauseTween !== child) {
            if (child.parent !== this) {
              // an extreme edge case - the child's render could do something like kill() the "next" one in the linked list, or reparent it. In that case we must re-initiate the whole render to be safe.
              return this.render(totalTime, suppressEvents, force);
            }

            child.render(child._ts > 0 ? (time - child._start) * child._ts : (child._dirty ? child.totalDuration() : child._tDur) + (time - child._start) * child._ts, suppressEvents, force);

            if (time !== this._time || !this._ts && !prevPaused) {
              //in case a tween pauses or seeks the timeline when rendering, like inside of an onUpdate/onComplete
              pauseTween = 0;
              next && (tTime += this._zTime = -_tinyNum); // it didn't finish rendering, so flag zTime as negative so that so that the next time render() is called it'll be forced (to render any remaining children)

              break;
            }
          }

          child = next;
        }
      } else {
        child = this._last;
        var adjustedTime = totalTime < 0 ? totalTime : time; //when the playhead goes backward beyond the start of this timeline, we must pass that information down to the child animations so that zero-duration tweens know whether to render their starting or ending values.

        while (child) {
          next = child._prev;

          if ((child._act || adjustedTime <= child._end) && child._ts && pauseTween !== child) {
            if (child.parent !== this) {
              // an extreme edge case - the child's render could do something like kill() the "next" one in the linked list, or reparent it. In that case we must re-initiate the whole render to be safe.
              return this.render(totalTime, suppressEvents, force);
            }

            child.render(child._ts > 0 ? (adjustedTime - child._start) * child._ts : (child._dirty ? child.totalDuration() : child._tDur) + (adjustedTime - child._start) * child._ts, suppressEvents, force);

            if (time !== this._time || !this._ts && !prevPaused) {
              //in case a tween pauses or seeks the timeline when rendering, like inside of an onUpdate/onComplete
              pauseTween = 0;
              next && (tTime += this._zTime = adjustedTime ? -_tinyNum : _tinyNum); // it didn't finish rendering, so adjust zTime so that so that the next time render() is called it'll be forced (to render any remaining children)

              break;
            }
          }

          child = next;
        }
      }

      if (pauseTween && !suppressEvents) {
        this.pause();
        pauseTween.render(time >= prevTime ? 0 : -_tinyNum)._zTime = time >= prevTime ? 1 : -1;

        if (this._ts) {
          //the callback resumed playback! So since we may have held back the playhead due to where the pause is positioned, go ahead and jump to where it's SUPPOSED to be (if no pause happened).
          this._start = prevStart; //if the pause was at an earlier time and the user resumed in the callback, it could reposition the timeline (changing its startTime), throwing things off slightly, so we make sure the _start doesn't shift.

          _setEnd(this);

          return this.render(totalTime, suppressEvents, force);
        }
      }

      this._onUpdate && !suppressEvents && _callback(this, "onUpdate", true);
      if (tTime === tDur && this._tTime >= this.totalDuration() || !tTime && prevTime) if (prevStart === this._start || Math.abs(timeScale) !== Math.abs(this._ts)) if (!this._lock) {
        // remember, a child's callback may alter this timeline's playhead or timeScale which is why we need to add some of these checks.
        (totalTime || !dur) && (tTime === tDur && this._ts > 0 || !tTime && this._ts < 0) && _removeFromParent(this, 1); // don't remove if the timeline is reversed and the playhead isn't at 0, otherwise tl.progress(1).reverse() won't work. Only remove if the playhead is at the end and timeScale is positive, or if the playhead is at 0 and the timeScale is negative.

        if (!suppressEvents && !(totalTime < 0 && !prevTime) && (tTime || prevTime || !tDur)) {
          _callback(this, tTime === tDur && totalTime >= 0 ? "onComplete" : "onReverseComplete", true);

          this._prom && !(tTime < tDur && this.timeScale() > 0) && this._prom();
        }
      }
    }

    return this;
  };

  _proto2.add = function add(child, position) {
    var _this2 = this;

    _isNumber(position) || (position = _parsePosition(this, position, child));

    if (!(child instanceof Animation)) {
      if (_isArray(child)) {
        child.forEach(function (obj) {
          return _this2.add(obj, position);
        });
        return this;
      }

      if (_isString(child)) {
        return this.addLabel(child, position);
      }

      if (_isFunction(child)) {
        child = Tween.delayedCall(0, child);
      } else {
        return this;
      }
    }

    return this !== child ? _addToTimeline(this, child, position) : this; //don't allow a timeline to be added to itself as a child!
  };

  _proto2.getChildren = function getChildren(nested, tweens, timelines, ignoreBeforeTime) {
    if (nested === void 0) {
      nested = true;
    }

    if (tweens === void 0) {
      tweens = true;
    }

    if (timelines === void 0) {
      timelines = true;
    }

    if (ignoreBeforeTime === void 0) {
      ignoreBeforeTime = -_bigNum;
    }

    var a = [],
        child = this._first;

    while (child) {
      if (child._start >= ignoreBeforeTime) {
        if (child instanceof Tween) {
          tweens && a.push(child);
        } else {
          timelines && a.push(child);
          nested && a.push.apply(a, child.getChildren(true, tweens, timelines));
        }
      }

      child = child._next;
    }

    return a;
  };

  _proto2.getById = function getById(id) {
    var animations = this.getChildren(1, 1, 1),
        i = animations.length;

    while (i--) {
      if (animations[i].vars.id === id) {
        return animations[i];
      }
    }
  };

  _proto2.remove = function remove(child) {
    if (_isString(child)) {
      return this.removeLabel(child);
    }

    if (_isFunction(child)) {
      return this.killTweensOf(child);
    }

    _removeLinkedListItem(this, child);

    if (child === this._recent) {
      this._recent = this._last;
    }

    return _uncache(this);
  };

  _proto2.totalTime = function totalTime(_totalTime2, suppressEvents) {
    if (!arguments.length) {
      return this._tTime;
    }

    this._forcing = 1;

    if (!this._dp && this._ts) {
      //special case for the global timeline (or any other that has no parent or detached parent).
      this._start = _roundPrecise(_ticker.time - (this._ts > 0 ? _totalTime2 / this._ts : (this.totalDuration() - _totalTime2) / -this._ts));
    }

    _Animation.prototype.totalTime.call(this, _totalTime2, suppressEvents);

    this._forcing = 0;
    return this;
  };

  _proto2.addLabel = function addLabel(label, position) {
    this.labels[label] = _parsePosition(this, position);
    return this;
  };

  _proto2.removeLabel = function removeLabel(label) {
    delete this.labels[label];
    return this;
  };

  _proto2.addPause = function addPause(position, callback, params) {
    var t = Tween.delayedCall(0, callback || _emptyFunc, params);
    t.data = "isPause";
    this._hasPause = 1;
    return _addToTimeline(this, t, _parsePosition(this, position));
  };

  _proto2.removePause = function removePause(position) {
    var child = this._first;
    position = _parsePosition(this, position);

    while (child) {
      if (child._start === position && child.data === "isPause") {
        _removeFromParent(child);
      }

      child = child._next;
    }
  };

  _proto2.killTweensOf = function killTweensOf(targets, props, onlyActive) {
    var tweens = this.getTweensOf(targets, onlyActive),
        i = tweens.length;

    while (i--) {
      _overwritingTween !== tweens[i] && tweens[i].kill(targets, props);
    }

    return this;
  };

  _proto2.getTweensOf = function getTweensOf(targets, onlyActive) {
    var a = [],
        parsedTargets = toArray(targets),
        child = this._first,
        isGlobalTime = _isNumber(onlyActive),
        // a number is interpreted as a global time. If the animation spans
    children;

    while (child) {
      if (child instanceof Tween) {
        if (_arrayContainsAny(child._targets, parsedTargets) && (isGlobalTime ? (!_overwritingTween || child._initted && child._ts) && child.globalTime(0) <= onlyActive && child.globalTime(child.totalDuration()) > onlyActive : !onlyActive || child.isActive())) {
          // note: if this is for overwriting, it should only be for tweens that aren't paused and are initted.
          a.push(child);
        }
      } else if ((children = child.getTweensOf(parsedTargets, onlyActive)).length) {
        a.push.apply(a, children);
      }

      child = child._next;
    }

    return a;
  } // potential future feature - targets() on timelines
  // targets() {
  // 	let result = [];
  // 	this.getChildren(true, true, false).forEach(t => result.push(...t.targets()));
  // 	return result.filter((v, i) => result.indexOf(v) === i);
  // }
  ;

  _proto2.tweenTo = function tweenTo(position, vars) {
    vars = vars || {};

    var tl = this,
        endTime = _parsePosition(tl, position),
        _vars = vars,
        startAt = _vars.startAt,
        _onStart = _vars.onStart,
        onStartParams = _vars.onStartParams,
        immediateRender = _vars.immediateRender,
        initted,
        tween = Tween.to(tl, _setDefaults({
      ease: vars.ease || "none",
      lazy: false,
      immediateRender: false,
      time: endTime,
      overwrite: "auto",
      duration: vars.duration || Math.abs((endTime - (startAt && "time" in startAt ? startAt.time : tl._time)) / tl.timeScale()) || _tinyNum,
      onStart: function onStart() {
        tl.pause();

        if (!initted) {
          var duration = vars.duration || Math.abs((endTime - (startAt && "time" in startAt ? startAt.time : tl._time)) / tl.timeScale());
          tween._dur !== duration && _setDuration(tween, duration, 0, 1).render(tween._time, true, true);
          initted = 1;
        }

        _onStart && _onStart.apply(tween, onStartParams || []); //in case the user had an onStart in the vars - we don't want to overwrite it.
      }
    }, vars));

    return immediateRender ? tween.render(0) : tween;
  };

  _proto2.tweenFromTo = function tweenFromTo(fromPosition, toPosition, vars) {
    return this.tweenTo(toPosition, _setDefaults({
      startAt: {
        time: _parsePosition(this, fromPosition)
      }
    }, vars));
  };

  _proto2.recent = function recent() {
    return this._recent;
  };

  _proto2.nextLabel = function nextLabel(afterTime) {
    if (afterTime === void 0) {
      afterTime = this._time;
    }

    return _getLabelInDirection(this, _parsePosition(this, afterTime));
  };

  _proto2.previousLabel = function previousLabel(beforeTime) {
    if (beforeTime === void 0) {
      beforeTime = this._time;
    }

    return _getLabelInDirection(this, _parsePosition(this, beforeTime), 1);
  };

  _proto2.currentLabel = function currentLabel(value) {
    return arguments.length ? this.seek(value, true) : this.previousLabel(this._time + _tinyNum);
  };

  _proto2.shiftChildren = function shiftChildren(amount, adjustLabels, ignoreBeforeTime) {
    if (ignoreBeforeTime === void 0) {
      ignoreBeforeTime = 0;
    }

    var child = this._first,
        labels = this.labels,
        p;

    while (child) {
      if (child._start >= ignoreBeforeTime) {
        child._start += amount;
        child._end += amount;
      }

      child = child._next;
    }

    if (adjustLabels) {
      for (p in labels) {
        if (labels[p] >= ignoreBeforeTime) {
          labels[p] += amount;
        }
      }
    }

    return _uncache(this);
  };

  _proto2.invalidate = function invalidate() {
    var child = this._first;
    this._lock = 0;

    while (child) {
      child.invalidate();
      child = child._next;
    }

    return _Animation.prototype.invalidate.call(this);
  };

  _proto2.clear = function clear(includeLabels) {
    if (includeLabels === void 0) {
      includeLabels = true;
    }

    var child = this._first,
        next;

    while (child) {
      next = child._next;
      this.remove(child);
      child = next;
    }

    this._dp && (this._time = this._tTime = this._pTime = 0);
    includeLabels && (this.labels = {});
    return _uncache(this);
  };

  _proto2.totalDuration = function totalDuration(value) {
    var max = 0,
        self = this,
        child = self._last,
        prevStart = _bigNum,
        prev,
        start,
        parent;

    if (arguments.length) {
      return self.timeScale((self._repeat < 0 ? self.duration() : self.totalDuration()) / (self.reversed() ? -value : value));
    }

    if (self._dirty) {
      parent = self.parent;

      while (child) {
        prev = child._prev; //record it here in case the tween changes position in the sequence...

        child._dirty && child.totalDuration(); //could change the tween._startTime, so make sure the animation's cache is clean before analyzing it.

        start = child._start;

        if (start > prevStart && self._sort && child._ts && !self._lock) {
          //in case one of the tweens shifted out of order, it needs to be re-inserted into the correct position in the sequence
          self._lock = 1; //prevent endless recursive calls - there are methods that get triggered that check duration/totalDuration when we add().

          _addToTimeline(self, child, start - child._delay, 1)._lock = 0;
        } else {
          prevStart = start;
        }

        if (start < 0 && child._ts) {
          //children aren't allowed to have negative startTimes unless smoothChildTiming is true, so adjust here if one is found.
          max -= start;

          if (!parent && !self._dp || parent && parent.smoothChildTiming) {
            self._start += start / self._ts;
            self._time -= start;
            self._tTime -= start;
          }

          self.shiftChildren(-start, false, -1e999);
          prevStart = 0;
        }

        child._end > max && child._ts && (max = child._end);
        child = prev;
      }

      _setDuration(self, self === _globalTimeline && self._time > max ? self._time : max, 1, 1);

      self._dirty = 0;
    }

    return self._tDur;
  };

  Timeline.updateRoot = function updateRoot(time) {
    if (_globalTimeline._ts) {
      _lazySafeRender(_globalTimeline, _parentToChildTotalTime(time, _globalTimeline));

      _lastRenderedFrame = _ticker.frame;
    }

    if (_ticker.frame >= _nextGCFrame) {
      _nextGCFrame += _config.autoSleep || 120;
      var child = _globalTimeline._first;
      if (!child || !child._ts) if (_config.autoSleep && _ticker._listeners.length < 2) {
        while (child && !child._ts) {
          child = child._next;
        }

        child || _ticker.sleep();
      }
    }
  };

  return Timeline;
}(Animation);

_setDefaults(Timeline.prototype, {
  _lock: 0,
  _hasPause: 0,
  _forcing: 0
});

var _addComplexStringPropTween = function _addComplexStringPropTween(target, prop, start, end, setter, stringFilter, funcParam) {
  //note: we call _addComplexStringPropTween.call(tweenInstance...) to ensure that it's scoped properly. We may call it from within a plugin too, thus "this" would refer to the plugin.
  var pt = new PropTween(this._pt, target, prop, 0, 1, _renderComplexString, null, setter),
      index = 0,
      matchIndex = 0,
      result,
      startNums,
      color,
      endNum,
      chunk,
      startNum,
      hasRandom,
      a;
  pt.b = start;
  pt.e = end;
  start += ""; //ensure values are strings

  end += "";

  if (hasRandom = ~end.indexOf("random(")) {
    end = _replaceRandom(end);
  }

  if (stringFilter) {
    a = [start, end];
    stringFilter(a, target, prop); //pass an array with the starting and ending values and let the filter do whatever it needs to the values.

    start = a[0];
    end = a[1];
  }

  startNums = start.match(_complexStringNumExp) || [];

  while (result = _complexStringNumExp.exec(end)) {
    endNum = result[0];
    chunk = end.substring(index, result.index);

    if (color) {
      color = (color + 1) % 5;
    } else if (chunk.substr(-5) === "rgba(") {
      color = 1;
    }

    if (endNum !== startNums[matchIndex++]) {
      startNum = parseFloat(startNums[matchIndex - 1]) || 0; //these nested PropTweens are handled in a special way - we'll never actually call a render or setter method on them. We'll just loop through them in the parent complex string PropTween's render method.

      pt._pt = {
        _next: pt._pt,
        p: chunk || matchIndex === 1 ? chunk : ",",
        //note: SVG spec allows omission of comma/space when a negative sign is wedged between two numbers, like 2.5-5.3 instead of 2.5,-5.3 but when tweening, the negative value may switch to positive, so we insert the comma just in case.
        s: startNum,
        c: endNum.charAt(1) === "=" ? _parseRelative(startNum, endNum) - startNum : parseFloat(endNum) - startNum,
        m: color && color < 4 ? Math.round : 0
      };
      index = _complexStringNumExp.lastIndex;
    }
  }

  pt.c = index < end.length ? end.substring(index, end.length) : ""; //we use the "c" of the PropTween to store the final part of the string (after the last number)

  pt.fp = funcParam;

  if (_relExp.test(end) || hasRandom) {
    pt.e = 0; //if the end string contains relative values or dynamic random(...) values, delete the end it so that on the final render we don't actually set it to the string with += or -= characters (forces it to use the calculated value).
  }

  this._pt = pt; //start the linked list with this new PropTween. Remember, we call _addComplexStringPropTween.call(tweenInstance...) to ensure that it's scoped properly. We may call it from within a plugin too, thus "this" would refer to the plugin.

  return pt;
},
    _addPropTween = function _addPropTween(target, prop, start, end, index, targets, modifier, stringFilter, funcParam) {
  _isFunction(end) && (end = end(index || 0, target, targets));
  var currentValue = target[prop],
      parsedStart = start !== "get" ? start : !_isFunction(currentValue) ? currentValue : funcParam ? target[prop.indexOf("set") || !_isFunction(target["get" + prop.substr(3)]) ? prop : "get" + prop.substr(3)](funcParam) : target[prop](),
      setter = !_isFunction(currentValue) ? _setterPlain : funcParam ? _setterFuncWithParam : _setterFunc,
      pt;

  if (_isString(end)) {
    if (~end.indexOf("random(")) {
      end = _replaceRandom(end);
    }

    if (end.charAt(1) === "=") {
      pt = _parseRelative(parsedStart, end) + (getUnit(parsedStart) || 0);

      if (pt || pt === 0) {
        // to avoid isNaN, like if someone passes in a value like "!= whatever"
        end = pt;
      }
    }
  }

  if (parsedStart !== end || _forceAllPropTweens) {
    if (!isNaN(parsedStart * end) && end !== "") {
      // fun fact: any number multiplied by "" is evaluated as the number 0!
      pt = new PropTween(this._pt, target, prop, +parsedStart || 0, end - (parsedStart || 0), typeof currentValue === "boolean" ? _renderBoolean : _renderPlain, 0, setter);
      funcParam && (pt.fp = funcParam);
      modifier && pt.modifier(modifier, this, target);
      return this._pt = pt;
    }

    !currentValue && !(prop in target) && _missingPlugin(prop, end);
    return _addComplexStringPropTween.call(this, target, prop, parsedStart, end, setter, stringFilter || _config.stringFilter, funcParam);
  }
},
    //creates a copy of the vars object and processes any function-based values (putting the resulting values directly into the copy) as well as strings with "random()" in them. It does NOT process relative values.
_processVars = function _processVars(vars, index, target, targets, tween) {
  _isFunction(vars) && (vars = _parseFuncOrString(vars, tween, index, target, targets));

  if (!_isObject(vars) || vars.style && vars.nodeType || _isArray(vars) || _isTypedArray(vars)) {
    return _isString(vars) ? _parseFuncOrString(vars, tween, index, target, targets) : vars;
  }

  var copy = {},
      p;

  for (p in vars) {
    copy[p] = _parseFuncOrString(vars[p], tween, index, target, targets);
  }

  return copy;
},
    _checkPlugin = function _checkPlugin(property, vars, tween, index, target, targets) {
  var plugin, pt, ptLookup, i;

  if (_plugins[property] && (plugin = new _plugins[property]()).init(target, plugin.rawVars ? vars[property] : _processVars(vars[property], index, target, targets, tween), tween, index, targets) !== false) {
    tween._pt = pt = new PropTween(tween._pt, target, property, 0, 1, plugin.render, plugin, 0, plugin.priority);

    if (tween !== _quickTween) {
      ptLookup = tween._ptLookup[tween._targets.indexOf(target)]; //note: we can't use tween._ptLookup[index] because for staggered tweens, the index from the fullTargets array won't match what it is in each individual tween that spawns from the stagger.

      i = plugin._props.length;

      while (i--) {
        ptLookup[plugin._props[i]] = pt;
      }
    }
  }

  return plugin;
},
    _overwritingTween,
    //store a reference temporarily so we can avoid overwriting itself.
_forceAllPropTweens,
    _initTween = function _initTween(tween, time) {
  var vars = tween.vars,
      ease = vars.ease,
      startAt = vars.startAt,
      immediateRender = vars.immediateRender,
      lazy = vars.lazy,
      onUpdate = vars.onUpdate,
      onUpdateParams = vars.onUpdateParams,
      callbackScope = vars.callbackScope,
      runBackwards = vars.runBackwards,
      yoyoEase = vars.yoyoEase,
      keyframes = vars.keyframes,
      autoRevert = vars.autoRevert,
      dur = tween._dur,
      prevStartAt = tween._startAt,
      targets = tween._targets,
      parent = tween.parent,
      fullTargets = parent && parent.data === "nested" ? parent.parent._targets : targets,
      autoOverwrite = tween._overwrite === "auto" && !_suppressOverwrites,
      tl = tween.timeline,
      cleanVars,
      i,
      p,
      pt,
      target,
      hasPriority,
      gsData,
      harness,
      plugin,
      ptLookup,
      index,
      harnessVars,
      overwritten;
  tl && (!keyframes || !ease) && (ease = "none");
  tween._ease = _parseEase(ease, _defaults.ease);
  tween._yEase = yoyoEase ? _invertEase(_parseEase(yoyoEase === true ? ease : yoyoEase, _defaults.ease)) : 0;

  if (yoyoEase && tween._yoyo && !tween._repeat) {
    //there must have been a parent timeline with yoyo:true that is currently in its yoyo phase, so flip the eases.
    yoyoEase = tween._yEase;
    tween._yEase = tween._ease;
    tween._ease = yoyoEase;
  }

  tween._from = !tl && !!vars.runBackwards; //nested timelines should never run backwards - the backwards-ness is in the child tweens.

  if (!tl || keyframes && !vars.stagger) {
    //if there's an internal timeline, skip all the parsing because we passed that task down the chain.
    harness = targets[0] ? _getCache(targets[0]).harness : 0;
    harnessVars = harness && vars[harness.prop]; //someone may need to specify CSS-specific values AND non-CSS values, like if the element has an "x" property plus it's a standard DOM element. We allow people to distinguish by wrapping plugin-specific stuff in a css:{} object for example.

    cleanVars = _copyExcluding(vars, _reservedProps);

    if (prevStartAt) {
      _removeFromParent(prevStartAt.render(-1, true));

      prevStartAt._lazy = 0;
    }

    if (startAt) {
      _removeFromParent(tween._startAt = Tween.set(targets, _setDefaults({
        data: "isStart",
        overwrite: false,
        parent: parent,
        immediateRender: true,
        lazy: _isNotFalse(lazy),
        startAt: null,
        delay: 0,
        onUpdate: onUpdate,
        onUpdateParams: onUpdateParams,
        callbackScope: callbackScope,
        stagger: 0
      }, startAt))); //copy the properties/values into a new object to avoid collisions, like var to = {x:0}, from = {x:500}; timeline.fromTo(e, from, to).fromTo(e, to, from);


      time < 0 && !immediateRender && !autoRevert && tween._startAt.render(-1, true); // rare edge case, like if a render is forced in the negative direction of a non-initted tween.

      if (immediateRender) {
        time > 0 && !autoRevert && (tween._startAt = 0); //tweens that render immediately (like most from() and fromTo() tweens) shouldn't revert when their parent timeline's playhead goes backward past the startTime because the initial render could have happened anytime and it shouldn't be directly correlated to this tween's startTime. Imagine setting up a complex animation where the beginning states of various objects are rendered immediately but the tween doesn't happen for quite some time - if we revert to the starting values as soon as the playhead goes backward past the tween's startTime, it will throw things off visually. Reversion should only happen in Timeline instances where immediateRender was false or when autoRevert is explicitly set to true.

        if (dur && time <= 0) {
          time && (tween._zTime = time);
          return; //we skip initialization here so that overwriting doesn't occur until the tween actually begins. Otherwise, if you create several immediateRender:true tweens of the same target/properties to drop into a Timeline, the last one created would overwrite the first ones because they didn't get placed into the timeline yet before the first render occurs and kicks in overwriting.
        } // if (time > 0) {
        // 	autoRevert || (tween._startAt = 0); //tweens that render immediately (like most from() and fromTo() tweens) shouldn't revert when their parent timeline's playhead goes backward past the startTime because the initial render could have happened anytime and it shouldn't be directly correlated to this tween's startTime. Imagine setting up a complex animation where the beginning states of various objects are rendered immediately but the tween doesn't happen for quite some time - if we revert to the starting values as soon as the playhead goes backward past the tween's startTime, it will throw things off visually. Reversion should only happen in Timeline instances where immediateRender was false or when autoRevert is explicitly set to true.
        // } else if (dur && !(time < 0 && prevStartAt)) {
        // 	time && (tween._zTime = time);
        // 	return; //we skip initialization here so that overwriting doesn't occur until the tween actually begins. Otherwise, if you create several immediateRender:true tweens of the same target/properties to drop into a Timeline, the last one created would overwrite the first ones because they didn't get placed into the timeline yet before the first render occurs and kicks in overwriting.
        // }

      } else if (autoRevert === false) {
        tween._startAt = 0;
      }
    } else if (runBackwards && dur) {
      //from() tweens must be handled uniquely: their beginning values must be rendered but we don't want overwriting to occur yet (when time is still 0). Wait until the tween actually begins before doing all the routines like overwriting. At that time, we should render at the END of the tween to ensure that things initialize correctly (remember, from() tweens go backwards)
      if (prevStartAt) {
        !autoRevert && (tween._startAt = 0);
      } else {
        time && (immediateRender = false); //in rare cases (like if a from() tween runs and then is invalidate()-ed), immediateRender could be true but the initial forced-render gets skipped, so there's no need to force the render in this context when the _time is greater than 0

        p = _setDefaults({
          overwrite: false,
          data: "isFromStart",
          //we tag the tween with as "isFromStart" so that if [inside a plugin] we need to only do something at the very END of a tween, we have a way of identifying this tween as merely the one that's setting the beginning values for a "from()" tween. For example, clearProps in CSSPlugin should only get applied at the very END of a tween and without this tag, from(...{height:100, clearProps:"height", delay:1}) would wipe the height at the beginning of the tween and after 1 second, it'd kick back in.
          lazy: immediateRender && _isNotFalse(lazy),
          immediateRender: immediateRender,
          //zero-duration tweens render immediately by default, but if we're not specifically instructed to render this tween immediately, we should skip this and merely _init() to record the starting values (rendering them immediately would push them to completion which is wasteful in that case - we'd have to render(-1) immediately after)
          stagger: 0,
          parent: parent //ensures that nested tweens that had a stagger are handled properly, like gsap.from(".class", {y:gsap.utils.wrap([-100,100])})

        }, cleanVars);
        harnessVars && (p[harness.prop] = harnessVars); // in case someone does something like .from(..., {css:{}})

        _removeFromParent(tween._startAt = Tween.set(targets, p));

        time < 0 && tween._startAt.render(-1, true); // rare edge case, like if a render is forced in the negative direction of a non-initted from() tween.

        tween._zTime = time;

        if (!immediateRender) {
          _initTween(tween._startAt, _tinyNum); //ensures that the initial values are recorded

        } else if (!time) {
          return;
        }
      }
    }

    tween._pt = tween._ptCache = 0;
    lazy = dur && _isNotFalse(lazy) || lazy && !dur;

    for (i = 0; i < targets.length; i++) {
      target = targets[i];
      gsData = target._gsap || _harness(targets)[i]._gsap;
      tween._ptLookup[i] = ptLookup = {};
      _lazyLookup[gsData.id] && _lazyTweens.length && _lazyRender(); //if other tweens of the same target have recently initted but haven't rendered yet, we've got to force the render so that the starting values are correct (imagine populating a timeline with a bunch of sequential tweens and then jumping to the end)

      index = fullTargets === targets ? i : fullTargets.indexOf(target);

      if (harness && (plugin = new harness()).init(target, harnessVars || cleanVars, tween, index, fullTargets) !== false) {
        tween._pt = pt = new PropTween(tween._pt, target, plugin.name, 0, 1, plugin.render, plugin, 0, plugin.priority);

        plugin._props.forEach(function (name) {
          ptLookup[name] = pt;
        });

        plugin.priority && (hasPriority = 1);
      }

      if (!harness || harnessVars) {
        for (p in cleanVars) {
          if (_plugins[p] && (plugin = _checkPlugin(p, cleanVars, tween, index, target, fullTargets))) {
            plugin.priority && (hasPriority = 1);
          } else {
            ptLookup[p] = pt = _addPropTween.call(tween, target, p, "get", cleanVars[p], index, fullTargets, 0, vars.stringFilter);
          }
        }
      }

      tween._op && tween._op[i] && tween.kill(target, tween._op[i]);

      if (autoOverwrite && tween._pt) {
        _overwritingTween = tween;

        _globalTimeline.killTweensOf(target, ptLookup, tween.globalTime(time)); // make sure the overwriting doesn't overwrite THIS tween!!!


        overwritten = !tween.parent;
        _overwritingTween = 0;
      }

      tween._pt && lazy && (_lazyLookup[gsData.id] = 1);
    }

    hasPriority && _sortPropTweensByPriority(tween);
    tween._onInit && tween._onInit(tween); //plugins like RoundProps must wait until ALL of the PropTweens are instantiated. In the plugin's init() function, it sets the _onInit on the tween instance. May not be pretty/intuitive, but it's fast and keeps file size down.
  }

  tween._onUpdate = onUpdate;
  tween._initted = (!tween._op || tween._pt) && !overwritten; // if overwrittenProps resulted in the entire tween being killed, do NOT flag it as initted or else it may render for one tick.

  keyframes && time <= 0 && tl.render(_bigNum, true, true); // if there's a 0% keyframe, it'll render in the "before" state for any staggered/delayed animations thus when the following tween initializes, it'll use the "before" state instead of the "after" state as the initial values.
},
    _updatePropTweens = function _updatePropTweens(tween, property, value, start, startIsRelative, ratio, time) {
  var ptCache = (tween._pt && tween._ptCache || (tween._ptCache = {}))[property],
      pt,
      lookup,
      i;

  if (!ptCache) {
    ptCache = tween._ptCache[property] = [];
    lookup = tween._ptLookup;
    i = tween._targets.length;

    while (i--) {
      pt = lookup[i][property];

      if (pt && pt.d && pt.d._pt) {
        // it's a plugin, so find the nested PropTween
        pt = pt.d._pt;

        while (pt && pt.p !== property) {
          pt = pt._next;
        }
      }

      if (!pt) {
        // there is no PropTween associated with that property, so we must FORCE one to be created and ditch out of this
        // if the tween has other properties that already rendered at new positions, we'd normally have to rewind to put them back like tween.render(0, true) before forcing an _initTween(), but that can create another edge case like tweening a timeline's progress would trigger onUpdates to fire which could move other things around. It's better to just inform users that .resetTo() should ONLY be used for tweens that already have that property. For example, you can't gsap.to(...{ y: 0 }) and then tween.restTo("x", 200) for example.
        _forceAllPropTweens = 1; // otherwise, when we _addPropTween() and it finds no change between the start and end values, it skips creating a PropTween (for efficiency...why tween when there's no difference?) but in this case we NEED that PropTween created so we can edit it.

        tween.vars[property] = "+=0";

        _initTween(tween, time);

        _forceAllPropTweens = 0;
        return 1;
      }

      ptCache.push(pt);
    }
  }

  i = ptCache.length;

  while (i--) {
    pt = ptCache[i];
    pt.s = (start || start === 0) && !startIsRelative ? start : pt.s + (start || 0) + ratio * pt.c;
    pt.c = value - pt.s;
    pt.e && (pt.e = _round(value) + getUnit(pt.e)); // mainly for CSSPlugin (end value)

    pt.b && (pt.b = pt.s + getUnit(pt.b)); // (beginning value)
  }
},
    _addAliasesToVars = function _addAliasesToVars(targets, vars) {
  var harness = targets[0] ? _getCache(targets[0]).harness : 0,
      propertyAliases = harness && harness.aliases,
      copy,
      p,
      i,
      aliases;

  if (!propertyAliases) {
    return vars;
  }

  copy = _merge({}, vars);

  for (p in propertyAliases) {
    if (p in copy) {
      aliases = propertyAliases[p].split(",");
      i = aliases.length;

      while (i--) {
        copy[aliases[i]] = copy[p];
      }
    }
  }

  return copy;
},
    // parses multiple formats, like {"0%": {x: 100}, {"50%": {x: -20}} and { x: {"0%": 100, "50%": -20} }, and an "ease" can be set on any object. We populate an "allProps" object with an Array for each property, like {x: [{}, {}], y:[{}, {}]} with data for each property tween. The objects have a "t" (time), "v", (value), and "e" (ease) property. This allows us to piece together a timeline later.
_parseKeyframe = function _parseKeyframe(prop, obj, allProps, easeEach) {
  var ease = obj.ease || easeEach || "power1.inOut",
      p,
      a;

  if (_isArray(obj)) {
    a = allProps[prop] || (allProps[prop] = []); // t = time (out of 100), v = value, e = ease

    obj.forEach(function (value, i) {
      return a.push({
        t: i / (obj.length - 1) * 100,
        v: value,
        e: ease
      });
    });
  } else {
    for (p in obj) {
      a = allProps[p] || (allProps[p] = []);
      p === "ease" || a.push({
        t: parseFloat(prop),
        v: obj[p],
        e: ease
      });
    }
  }
},
    _parseFuncOrString = function _parseFuncOrString(value, tween, i, target, targets) {
  return _isFunction(value) ? value.call(tween, i, target, targets) : _isString(value) && ~value.indexOf("random(") ? _replaceRandom(value) : value;
},
    _staggerTweenProps = _callbackNames + "repeat,repeatDelay,yoyo,repeatRefresh,yoyoEase,autoRevert",
    _staggerPropsToSkip = {};

_forEachName(_staggerTweenProps + ",id,stagger,delay,duration,paused,scrollTrigger", function (name) {
  return _staggerPropsToSkip[name] = 1;
});
/*
 * --------------------------------------------------------------------------------------
 * TWEEN
 * --------------------------------------------------------------------------------------
 */


var Tween = /*#__PURE__*/function (_Animation2) {
  _inheritsLoose(Tween, _Animation2);

  function Tween(targets, vars, position, skipInherit) {
    var _this3;

    if (typeof vars === "number") {
      position.duration = vars;
      vars = position;
      position = null;
    }

    _this3 = _Animation2.call(this, skipInherit ? vars : _inheritDefaults(vars)) || this;
    var _this3$vars = _this3.vars,
        duration = _this3$vars.duration,
        delay = _this3$vars.delay,
        immediateRender = _this3$vars.immediateRender,
        stagger = _this3$vars.stagger,
        overwrite = _this3$vars.overwrite,
        keyframes = _this3$vars.keyframes,
        defaults = _this3$vars.defaults,
        scrollTrigger = _this3$vars.scrollTrigger,
        yoyoEase = _this3$vars.yoyoEase,
        parent = vars.parent || _globalTimeline,
        parsedTargets = (_isArray(targets) || _isTypedArray(targets) ? _isNumber(targets[0]) : "length" in vars) ? [targets] : toArray(targets),
        tl,
        i,
        copy,
        l,
        p,
        curTarget,
        staggerFunc,
        staggerVarsToMerge;
    _this3._targets = parsedTargets.length ? _harness(parsedTargets) : _warn("GSAP target " + targets + " not found. https://greensock.com", !_config.nullTargetWarn) || [];
    _this3._ptLookup = []; //PropTween lookup. An array containing an object for each target, having keys for each tweening property

    _this3._overwrite = overwrite;

    if (keyframes || stagger || _isFuncOrString(duration) || _isFuncOrString(delay)) {
      vars = _this3.vars;
      tl = _this3.timeline = new Timeline({
        data: "nested",
        defaults: defaults || {}
      });
      tl.kill();
      tl.parent = tl._dp = _assertThisInitialized(_this3);
      tl._start = 0;

      if (stagger || _isFuncOrString(duration) || _isFuncOrString(delay)) {
        l = parsedTargets.length;
        staggerFunc = stagger && distribute(stagger);

        if (_isObject(stagger)) {
          //users can pass in callbacks like onStart/onComplete in the stagger object. These should fire with each individual tween.
          for (p in stagger) {
            if (~_staggerTweenProps.indexOf(p)) {
              staggerVarsToMerge || (staggerVarsToMerge = {});
              staggerVarsToMerge[p] = stagger[p];
            }
          }
        }

        for (i = 0; i < l; i++) {
          copy = _copyExcluding(vars, _staggerPropsToSkip);
          copy.stagger = 0;
          yoyoEase && (copy.yoyoEase = yoyoEase);
          staggerVarsToMerge && _merge(copy, staggerVarsToMerge);
          curTarget = parsedTargets[i]; //don't just copy duration or delay because if they're a string or function, we'd end up in an infinite loop because _isFuncOrString() would evaluate as true in the child tweens, entering this loop, etc. So we parse the value straight from vars and default to 0.

          copy.duration = +_parseFuncOrString(duration, _assertThisInitialized(_this3), i, curTarget, parsedTargets);
          copy.delay = (+_parseFuncOrString(delay, _assertThisInitialized(_this3), i, curTarget, parsedTargets) || 0) - _this3._delay;

          if (!stagger && l === 1 && copy.delay) {
            // if someone does delay:"random(1, 5)", repeat:-1, for example, the delay shouldn't be inside the repeat.
            _this3._delay = delay = copy.delay;
            _this3._start += delay;
            copy.delay = 0;
          }

          tl.to(curTarget, copy, staggerFunc ? staggerFunc(i, curTarget, parsedTargets) : 0);
          tl._ease = _easeMap.none;
        }

        tl.duration() ? duration = delay = 0 : _this3.timeline = 0; // if the timeline's duration is 0, we don't need a timeline internally!
      } else if (keyframes) {
        _inheritDefaults(_setDefaults(tl.vars.defaults, {
          ease: "none"
        }));

        tl._ease = _parseEase(keyframes.ease || vars.ease || "none");
        var time = 0,
            a,
            kf,
            v;

        if (_isArray(keyframes)) {
          keyframes.forEach(function (frame) {
            return tl.to(parsedTargets, frame, ">");
          });
        } else {
          copy = {};

          for (p in keyframes) {
            p === "ease" || p === "easeEach" || _parseKeyframe(p, keyframes[p], copy, keyframes.easeEach);
          }

          for (p in copy) {
            a = copy[p].sort(function (a, b) {
              return a.t - b.t;
            });
            time = 0;

            for (i = 0; i < a.length; i++) {
              kf = a[i];
              v = {
                ease: kf.e,
                duration: (kf.t - (i ? a[i - 1].t : 0)) / 100 * duration
              };
              v[p] = kf.v;
              tl.to(parsedTargets, v, time);
              time += v.duration;
            }
          }

          tl.duration() < duration && tl.to({}, {
            duration: duration - tl.duration()
          }); // in case keyframes didn't go to 100%
        }
      }

      duration || _this3.duration(duration = tl.duration());
    } else {
      _this3.timeline = 0; //speed optimization, faster lookups (no going up the prototype chain)
    }

    if (overwrite === true && !_suppressOverwrites) {
      _overwritingTween = _assertThisInitialized(_this3);

      _globalTimeline.killTweensOf(parsedTargets);

      _overwritingTween = 0;
    }

    _addToTimeline(parent, _assertThisInitialized(_this3), position);

    vars.reversed && _this3.reverse();
    vars.paused && _this3.paused(true);

    if (immediateRender || !duration && !keyframes && _this3._start === _roundPrecise(parent._time) && _isNotFalse(immediateRender) && _hasNoPausedAncestors(_assertThisInitialized(_this3)) && parent.data !== "nested") {
      _this3._tTime = -_tinyNum; //forces a render without having to set the render() "force" parameter to true because we want to allow lazying by default (using the "force" parameter always forces an immediate full render)

      _this3.render(Math.max(0, -delay)); //in case delay is negative

    }

    scrollTrigger && _scrollTrigger(_assertThisInitialized(_this3), scrollTrigger);
    return _this3;
  }

  var _proto3 = Tween.prototype;

  _proto3.render = function render(totalTime, suppressEvents, force) {
    var prevTime = this._time,
        tDur = this._tDur,
        dur = this._dur,
        tTime = totalTime > tDur - _tinyNum && totalTime >= 0 ? tDur : totalTime < _tinyNum ? 0 : totalTime,
        time,
        pt,
        iteration,
        cycleDuration,
        prevIteration,
        isYoyo,
        ratio,
        timeline,
        yoyoEase;

    if (!dur) {
      _renderZeroDurationTween(this, totalTime, suppressEvents, force);
    } else if (tTime !== this._tTime || !totalTime || force || !this._initted && this._tTime || this._startAt && this._zTime < 0 !== totalTime < 0) {
      //this senses if we're crossing over the start time, in which case we must record _zTime and force the render, but we do it in this lengthy conditional way for performance reasons (usually we can skip the calculations): this._initted && (this._zTime < 0) !== (totalTime < 0)
      time = tTime;
      timeline = this.timeline;

      if (this._repeat) {
        //adjust the time for repeats and yoyos
        cycleDuration = dur + this._rDelay;

        if (this._repeat < -1 && totalTime < 0) {
          return this.totalTime(cycleDuration * 100 + totalTime, suppressEvents, force);
        }

        time = _roundPrecise(tTime % cycleDuration); //round to avoid floating point errors. (4 % 0.8 should be 0 but some browsers report it as 0.79999999!)

        if (tTime === tDur) {
          // the tDur === tTime is for edge cases where there's a lengthy decimal on the duration and it may reach the very end but the time is rendered as not-quite-there (remember, tDur is rounded to 4 decimals whereas dur isn't)
          iteration = this._repeat;
          time = dur;
        } else {
          iteration = ~~(tTime / cycleDuration);

          if (iteration && iteration === tTime / cycleDuration) {
            time = dur;
            iteration--;
          }

          time > dur && (time = dur);
        }

        isYoyo = this._yoyo && iteration & 1;

        if (isYoyo) {
          yoyoEase = this._yEase;
          time = dur - time;
        }

        prevIteration = _animationCycle(this._tTime, cycleDuration);

        if (time === prevTime && !force && this._initted) {
          //could be during the repeatDelay part. No need to render and fire callbacks.
          this._tTime = tTime;
          return this;
        }

        if (iteration !== prevIteration) {
          timeline && this._yEase && _propagateYoyoEase(timeline, isYoyo); //repeatRefresh functionality

          if (this.vars.repeatRefresh && !isYoyo && !this._lock) {
            this._lock = force = 1; //force, otherwise if lazy is true, the _attemptInitTween() will return and we'll jump out and get caught bouncing on each tick.

            this.render(_roundPrecise(cycleDuration * iteration), true).invalidate()._lock = 0;
          }
        }
      }

      if (!this._initted) {
        if (_attemptInitTween(this, totalTime < 0 ? totalTime : time, force, suppressEvents)) {
          this._tTime = 0; // in constructor if immediateRender is true, we set _tTime to -_tinyNum to have the playhead cross the starting point but we can't leave _tTime as a negative number.

          return this;
        }

        if (prevTime !== this._time) {
          // rare edge case - during initialization, an onUpdate in the _startAt (.fromTo()) might force this tween to render at a different spot in which case we should ditch this render() call so that it doesn't revert the values.
          return this;
        }

        if (dur !== this._dur) {
          // while initting, a plugin like InertiaPlugin might alter the duration, so rerun from the start to ensure everything renders as it should.
          return this.render(totalTime, suppressEvents, force);
        }
      }

      this._tTime = tTime;
      this._time = time;

      if (!this._act && this._ts) {
        this._act = 1; //as long as it's not paused, force it to be active so that if the user renders independent of the parent timeline, it'll be forced to re-render on the next tick.

        this._lazy = 0;
      }

      this.ratio = ratio = (yoyoEase || this._ease)(time / dur);

      if (this._from) {
        this.ratio = ratio = 1 - ratio;
      }

      if (time && !prevTime && !suppressEvents) {
        _callback(this, "onStart");

        if (this._tTime !== tTime) {
          // in case the onStart triggered a render at a different spot, eject. Like if someone did animation.pause(0.5) or something inside the onStart.
          return this;
        }
      }

      pt = this._pt;

      while (pt) {
        pt.r(ratio, pt.d);
        pt = pt._next;
      }

      timeline && timeline.render(totalTime < 0 ? totalTime : !time && isYoyo ? -_tinyNum : timeline._dur * timeline._ease(time / this._dur), suppressEvents, force) || this._startAt && (this._zTime = totalTime);

      if (this._onUpdate && !suppressEvents) {
        totalTime < 0 && this._startAt && this._startAt.render(totalTime, true, force); //note: for performance reasons, we tuck this conditional logic inside less traveled areas (most tweens don't have an onUpdate). We'd just have it at the end before the onComplete, but the values should be updated before any onUpdate is called, so we ALSO put it here and then if it's not called, we do so later near the onComplete.

        _callback(this, "onUpdate");
      }

      this._repeat && iteration !== prevIteration && this.vars.onRepeat && !suppressEvents && this.parent && _callback(this, "onRepeat");

      if ((tTime === this._tDur || !tTime) && this._tTime === tTime) {
        totalTime < 0 && this._startAt && !this._onUpdate && this._startAt.render(totalTime, true, true);
        (totalTime || !dur) && (tTime === this._tDur && this._ts > 0 || !tTime && this._ts < 0) && _removeFromParent(this, 1); // don't remove if we're rendering at exactly a time of 0, as there could be autoRevert values that should get set on the next tick (if the playhead goes backward beyond the startTime, negative totalTime). Don't remove if the timeline is reversed and the playhead isn't at 0, otherwise tl.progress(1).reverse() won't work. Only remove if the playhead is at the end and timeScale is positive, or if the playhead is at 0 and the timeScale is negative.

        if (!suppressEvents && !(totalTime < 0 && !prevTime) && (tTime || prevTime)) {
          // if prevTime and tTime are zero, we shouldn't fire the onReverseComplete. This could happen if you gsap.to(... {paused:true}).play();
          _callback(this, tTime === tDur ? "onComplete" : "onReverseComplete", true);

          this._prom && !(tTime < tDur && this.timeScale() > 0) && this._prom();
        }
      }
    }

    return this;
  };

  _proto3.targets = function targets() {
    return this._targets;
  };

  _proto3.invalidate = function invalidate() {
    this._pt = this._op = this._startAt = this._onUpdate = this._lazy = this.ratio = 0;
    this._ptLookup = [];
    this.timeline && this.timeline.invalidate();
    return _Animation2.prototype.invalidate.call(this);
  };

  _proto3.resetTo = function resetTo(property, value, start, startIsRelative) {
    _tickerActive || _ticker.wake();
    this._ts || this.play();
    var time = Math.min(this._dur, (this._dp._time - this._start) * this._ts),
        ratio;
    this._initted || _initTween(this, time);
    ratio = this._ease(time / this._dur); // don't just get tween.ratio because it may not have rendered yet.
    // possible future addition to allow an object with multiple values to update, like tween.resetTo({x: 100, y: 200}); At this point, it doesn't seem worth the added kb given the fact that most users will likely opt for the convenient gsap.quickTo() way of interacting with this method.
    // if (_isObject(property)) { // performance optimization
    // 	for (p in property) {
    // 		if (_updatePropTweens(this, p, property[p], value ? value[p] : null, start, ratio, time)) {
    // 			return this.resetTo(property, value, start, startIsRelative); // if a PropTween wasn't found for the property, it'll get forced with a re-initialization so we need to jump out and start over again.
    // 		}
    // 	}
    // } else {

    if (_updatePropTweens(this, property, value, start, startIsRelative, ratio, time)) {
      return this.resetTo(property, value, start, startIsRelative); // if a PropTween wasn't found for the property, it'll get forced with a re-initialization so we need to jump out and start over again.
    } //}


    _alignPlayhead(this, 0);

    this.parent || _addLinkedListItem(this._dp, this, "_first", "_last", this._dp._sort ? "_start" : 0);
    return this.render(0);
  };

  _proto3.kill = function kill(targets, vars) {
    if (vars === void 0) {
      vars = "all";
    }

    if (!targets && (!vars || vars === "all")) {
      this._lazy = this._pt = 0;
      return this.parent ? _interrupt(this) : this;
    }

    if (this.timeline) {
      var tDur = this.timeline.totalDuration();
      this.timeline.killTweensOf(targets, vars, _overwritingTween && _overwritingTween.vars.overwrite !== true)._first || _interrupt(this); // if nothing is left tweening, interrupt.

      this.parent && tDur !== this.timeline.totalDuration() && _setDuration(this, this._dur * this.timeline._tDur / tDur, 0, 1); // if a nested tween is killed that changes the duration, it should affect this tween's duration. We must use the ratio, though, because sometimes the internal timeline is stretched like for keyframes where they don't all add up to whatever the parent tween's duration was set to.

      return this;
    }

    var parsedTargets = this._targets,
        killingTargets = targets ? toArray(targets) : parsedTargets,
        propTweenLookup = this._ptLookup,
        firstPT = this._pt,
        overwrittenProps,
        curLookup,
        curOverwriteProps,
        props,
        p,
        pt,
        i;

    if ((!vars || vars === "all") && _arraysMatch(parsedTargets, killingTargets)) {
      vars === "all" && (this._pt = 0);
      return _interrupt(this);
    }

    overwrittenProps = this._op = this._op || [];

    if (vars !== "all") {
      //so people can pass in a comma-delimited list of property names
      if (_isString(vars)) {
        p = {};

        _forEachName(vars, function (name) {
          return p[name] = 1;
        });

        vars = p;
      }

      vars = _addAliasesToVars(parsedTargets, vars);
    }

    i = parsedTargets.length;

    while (i--) {
      if (~killingTargets.indexOf(parsedTargets[i])) {
        curLookup = propTweenLookup[i];

        if (vars === "all") {
          overwrittenProps[i] = vars;
          props = curLookup;
          curOverwriteProps = {};
        } else {
          curOverwriteProps = overwrittenProps[i] = overwrittenProps[i] || {};
          props = vars;
        }

        for (p in props) {
          pt = curLookup && curLookup[p];

          if (pt) {
            if (!("kill" in pt.d) || pt.d.kill(p) === true) {
              _removeLinkedListItem(this, pt, "_pt");
            }

            delete curLookup[p];
          }

          if (curOverwriteProps !== "all") {
            curOverwriteProps[p] = 1;
          }
        }
      }
    }

    this._initted && !this._pt && firstPT && _interrupt(this); //if all tweening properties are killed, kill the tween. Without this line, if there's a tween with multiple targets and then you killTweensOf() each target individually, the tween would technically still remain active and fire its onComplete even though there aren't any more properties tweening.

    return this;
  };

  Tween.to = function to(targets, vars) {
    return new Tween(targets, vars, arguments[2]);
  };

  Tween.from = function from(targets, vars) {
    return _createTweenType(1, arguments);
  };

  Tween.delayedCall = function delayedCall(delay, callback, params, scope) {
    return new Tween(callback, 0, {
      immediateRender: false,
      lazy: false,
      overwrite: false,
      delay: delay,
      onComplete: callback,
      onReverseComplete: callback,
      onCompleteParams: params,
      onReverseCompleteParams: params,
      callbackScope: scope
    });
  };

  Tween.fromTo = function fromTo(targets, fromVars, toVars) {
    return _createTweenType(2, arguments);
  };

  Tween.set = function set(targets, vars) {
    vars.duration = 0;
    vars.repeatDelay || (vars.repeat = 0);
    return new Tween(targets, vars);
  };

  Tween.killTweensOf = function killTweensOf(targets, props, onlyActive) {
    return _globalTimeline.killTweensOf(targets, props, onlyActive);
  };

  return Tween;
}(Animation);

_setDefaults(Tween.prototype, {
  _targets: [],
  _lazy: 0,
  _startAt: 0,
  _op: 0,
  _onInit: 0
}); //add the pertinent timeline methods to Tween instances so that users can chain conveniently and create a timeline automatically. (removed due to concerns that it'd ultimately add to more confusion especially for beginners)
// _forEachName("to,from,fromTo,set,call,add,addLabel,addPause", name => {
// 	Tween.prototype[name] = function() {
// 		let tl = new Timeline();
// 		return _addToTimeline(tl, this)[name].apply(tl, toArray(arguments));
// 	}
// });
//for backward compatibility. Leverage the timeline calls.


_forEachName("staggerTo,staggerFrom,staggerFromTo", function (name) {
  Tween[name] = function () {
    var tl = new Timeline(),
        params = _slice.call(arguments, 0);

    params.splice(name === "staggerFromTo" ? 5 : 4, 0, 0);
    return tl[name].apply(tl, params);
  };
});
/*
 * --------------------------------------------------------------------------------------
 * PROPTWEEN
 * --------------------------------------------------------------------------------------
 */


var _setterPlain = function _setterPlain(target, property, value) {
  return target[property] = value;
},
    _setterFunc = function _setterFunc(target, property, value) {
  return target[property](value);
},
    _setterFuncWithParam = function _setterFuncWithParam(target, property, value, data) {
  return target[property](data.fp, value);
},
    _setterAttribute = function _setterAttribute(target, property, value) {
  return target.setAttribute(property, value);
},
    _getSetter = function _getSetter(target, property) {
  return _isFunction(target[property]) ? _setterFunc : _isUndefined(target[property]) && target.setAttribute ? _setterAttribute : _setterPlain;
},
    _renderPlain = function _renderPlain(ratio, data) {
  return data.set(data.t, data.p, Math.round((data.s + data.c * ratio) * 1000000) / 1000000, data);
},
    _renderBoolean = function _renderBoolean(ratio, data) {
  return data.set(data.t, data.p, !!(data.s + data.c * ratio), data);
},
    _renderComplexString = function _renderComplexString(ratio, data) {
  var pt = data._pt,
      s = "";

  if (!ratio && data.b) {
    //b = beginning string
    s = data.b;
  } else if (ratio === 1 && data.e) {
    //e = ending string
    s = data.e;
  } else {
    while (pt) {
      s = pt.p + (pt.m ? pt.m(pt.s + pt.c * ratio) : Math.round((pt.s + pt.c * ratio) * 10000) / 10000) + s; //we use the "p" property for the text inbetween (like a suffix). And in the context of a complex string, the modifier (m) is typically just Math.round(), like for RGB colors.

      pt = pt._next;
    }

    s += data.c; //we use the "c" of the PropTween to store the final chunk of non-numeric text.
  }

  data.set(data.t, data.p, s, data);
},
    _renderPropTweens = function _renderPropTweens(ratio, data) {
  var pt = data._pt;

  while (pt) {
    pt.r(ratio, pt.d);
    pt = pt._next;
  }
},
    _addPluginModifier = function _addPluginModifier(modifier, tween, target, property) {
  var pt = this._pt,
      next;

  while (pt) {
    next = pt._next;
    pt.p === property && pt.modifier(modifier, tween, target);
    pt = next;
  }
},
    _killPropTweensOf = function _killPropTweensOf(property) {
  var pt = this._pt,
      hasNonDependentRemaining,
      next;

  while (pt) {
    next = pt._next;

    if (pt.p === property && !pt.op || pt.op === property) {
      _removeLinkedListItem(this, pt, "_pt");
    } else if (!pt.dep) {
      hasNonDependentRemaining = 1;
    }

    pt = next;
  }

  return !hasNonDependentRemaining;
},
    _setterWithModifier = function _setterWithModifier(target, property, value, data) {
  data.mSet(target, property, data.m.call(data.tween, value, data.mt), data);
},
    _sortPropTweensByPriority = function _sortPropTweensByPriority(parent) {
  var pt = parent._pt,
      next,
      pt2,
      first,
      last; //sorts the PropTween linked list in order of priority because some plugins need to do their work after ALL of the PropTweens were created (like RoundPropsPlugin and ModifiersPlugin)

  while (pt) {
    next = pt._next;
    pt2 = first;

    while (pt2 && pt2.pr > pt.pr) {
      pt2 = pt2._next;
    }

    if (pt._prev = pt2 ? pt2._prev : last) {
      pt._prev._next = pt;
    } else {
      first = pt;
    }

    if (pt._next = pt2) {
      pt2._prev = pt;
    } else {
      last = pt;
    }

    pt = next;
  }

  parent._pt = first;
}; //PropTween key: t = target, p = prop, r = renderer, d = data, s = start, c = change, op = overwriteProperty (ONLY populated when it's different than p), pr = priority, _next/_prev for the linked list siblings, set = setter, m = modifier, mSet = modifierSetter (the original setter, before a modifier was added)


var PropTween = /*#__PURE__*/function () {
  function PropTween(next, target, prop, start, change, renderer, data, setter, priority) {
    this.t = target;
    this.s = start;
    this.c = change;
    this.p = prop;
    this.r = renderer || _renderPlain;
    this.d = data || this;
    this.set = setter || _setterPlain;
    this.pr = priority || 0;
    this._next = next;

    if (next) {
      next._prev = this;
    }
  }

  var _proto4 = PropTween.prototype;

  _proto4.modifier = function modifier(func, tween, target) {
    this.mSet = this.mSet || this.set; //in case it was already set (a PropTween can only have one modifier)

    this.set = _setterWithModifier;
    this.m = func;
    this.mt = target; //modifier target

    this.tween = tween;
  };

  return PropTween;
}(); //Initialization tasks

_forEachName(_callbackNames + "parent,duration,ease,delay,overwrite,runBackwards,startAt,yoyo,immediateRender,repeat,repeatDelay,data,paused,reversed,lazy,callbackScope,stringFilter,id,yoyoEase,stagger,inherit,repeatRefresh,keyframes,autoRevert,scrollTrigger", function (name) {
  return _reservedProps[name] = 1;
});

_globals.TweenMax = _globals.TweenLite = Tween;
_globals.TimelineLite = _globals.TimelineMax = Timeline;
_globalTimeline = new Timeline({
  sortChildren: false,
  defaults: _defaults,
  autoRemoveChildren: true,
  id: "root",
  smoothChildTiming: true
});
_config.stringFilter = _colorStringFilter;
/*
 * --------------------------------------------------------------------------------------
 * GSAP
 * --------------------------------------------------------------------------------------
 */

var _gsap = {
  registerPlugin: function registerPlugin() {
    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }

    args.forEach(function (config) {
      return _createPlugin(config);
    });
  },
  timeline: function timeline(vars) {
    return new Timeline(vars);
  },
  getTweensOf: function getTweensOf(targets, onlyActive) {
    return _globalTimeline.getTweensOf(targets, onlyActive);
  },
  getProperty: function getProperty(target, property, unit, uncache) {
    _isString(target) && (target = toArray(target)[0]); //in case selector text or an array is passed in

    var getter = _getCache(target || {}).get,
        format = unit ? _passThrough : _numericIfPossible;

    unit === "native" && (unit = "");
    return !target ? target : !property ? function (property, unit, uncache) {
      return format((_plugins[property] && _plugins[property].get || getter)(target, property, unit, uncache));
    } : format((_plugins[property] && _plugins[property].get || getter)(target, property, unit, uncache));
  },
  quickSetter: function quickSetter(target, property, unit) {
    target = toArray(target);

    if (target.length > 1) {
      var setters = target.map(function (t) {
        return gsap.quickSetter(t, property, unit);
      }),
          l = setters.length;
      return function (value) {
        var i = l;

        while (i--) {
          setters[i](value);
        }
      };
    }

    target = target[0] || {};

    var Plugin = _plugins[property],
        cache = _getCache(target),
        p = cache.harness && (cache.harness.aliases || {})[property] || property,
        // in case it's an alias, like "rotate" for "rotation".
    setter = Plugin ? function (value) {
      var p = new Plugin();
      _quickTween._pt = 0;
      p.init(target, unit ? value + unit : value, _quickTween, 0, [target]);
      p.render(1, p);
      _quickTween._pt && _renderPropTweens(1, _quickTween);
    } : cache.set(target, p);

    return Plugin ? setter : function (value) {
      return setter(target, p, unit ? value + unit : value, cache, 1);
    };
  },
  quickTo: function quickTo(target, property, vars) {
    var _merge2;

    var tween = gsap.to(target, _merge((_merge2 = {}, _merge2[property] = "+=0.1", _merge2.paused = true, _merge2), vars || {})),
        func = function func(value, start, startIsRelative) {
      return tween.resetTo(property, value, start, startIsRelative);
    };

    func.tween = tween;
    return func;
  },
  isTweening: function isTweening(targets) {
    return _globalTimeline.getTweensOf(targets, true).length > 0;
  },
  defaults: function defaults(value) {
    value && value.ease && (value.ease = _parseEase(value.ease, _defaults.ease));
    return _mergeDeep(_defaults, value || {});
  },
  config: function config(value) {
    return _mergeDeep(_config, value || {});
  },
  registerEffect: function registerEffect(_ref3) {
    var name = _ref3.name,
        effect = _ref3.effect,
        plugins = _ref3.plugins,
        defaults = _ref3.defaults,
        extendTimeline = _ref3.extendTimeline;
    (plugins || "").split(",").forEach(function (pluginName) {
      return pluginName && !_plugins[pluginName] && !_globals[pluginName] && _warn(name + " effect requires " + pluginName + " plugin.");
    });

    _effects[name] = function (targets, vars, tl) {
      return effect(toArray(targets), _setDefaults(vars || {}, defaults), tl);
    };

    if (extendTimeline) {
      Timeline.prototype[name] = function (targets, vars, position) {
        return this.add(_effects[name](targets, _isObject(vars) ? vars : (position = vars) && {}, this), position);
      };
    }
  },
  registerEase: function registerEase(name, ease) {
    _easeMap[name] = _parseEase(ease);
  },
  parseEase: function parseEase(ease, defaultEase) {
    return arguments.length ? _parseEase(ease, defaultEase) : _easeMap;
  },
  getById: function getById(id) {
    return _globalTimeline.getById(id);
  },
  exportRoot: function exportRoot(vars, includeDelayedCalls) {
    if (vars === void 0) {
      vars = {};
    }

    var tl = new Timeline(vars),
        child,
        next;
    tl.smoothChildTiming = _isNotFalse(vars.smoothChildTiming);

    _globalTimeline.remove(tl);

    tl._dp = 0; //otherwise it'll get re-activated when adding children and be re-introduced into _globalTimeline's linked list (then added to itself).

    tl._time = tl._tTime = _globalTimeline._time;
    child = _globalTimeline._first;

    while (child) {
      next = child._next;

      if (includeDelayedCalls || !(!child._dur && child instanceof Tween && child.vars.onComplete === child._targets[0])) {
        _addToTimeline(tl, child, child._start - child._delay);
      }

      child = next;
    }

    _addToTimeline(_globalTimeline, tl, 0);

    return tl;
  },
  utils: {
    wrap: wrap,
    wrapYoyo: wrapYoyo,
    distribute: distribute,
    random: random,
    snap: snap,
    normalize: normalize,
    getUnit: getUnit,
    clamp: clamp,
    splitColor: splitColor,
    toArray: toArray,
    selector: selector,
    mapRange: mapRange,
    pipe: pipe,
    unitize: unitize,
    interpolate: interpolate,
    shuffle: shuffle
  },
  install: _install,
  effects: _effects,
  ticker: _ticker,
  updateRoot: Timeline.updateRoot,
  plugins: _plugins,
  globalTimeline: _globalTimeline,
  core: {
    PropTween: PropTween,
    globals: _addGlobal,
    Tween: Tween,
    Timeline: Timeline,
    Animation: Animation,
    getCache: _getCache,
    _removeLinkedListItem: _removeLinkedListItem,
    suppressOverwrites: function suppressOverwrites(value) {
      return _suppressOverwrites = value;
    }
  }
};

_forEachName("to,from,fromTo,delayedCall,set,killTweensOf", function (name) {
  return _gsap[name] = Tween[name];
});

_ticker.add(Timeline.updateRoot);

_quickTween = _gsap.to({}, {
  duration: 0
}); // ---- EXTRA PLUGINS --------------------------------------------------------

var _getPluginPropTween = function _getPluginPropTween(plugin, prop) {
  var pt = plugin._pt;

  while (pt && pt.p !== prop && pt.op !== prop && pt.fp !== prop) {
    pt = pt._next;
  }

  return pt;
},
    _addModifiers = function _addModifiers(tween, modifiers) {
  var targets = tween._targets,
      p,
      i,
      pt;

  for (p in modifiers) {
    i = targets.length;

    while (i--) {
      pt = tween._ptLookup[i][p];

      if (pt && (pt = pt.d)) {
        if (pt._pt) {
          // is a plugin
          pt = _getPluginPropTween(pt, p);
        }

        pt && pt.modifier && pt.modifier(modifiers[p], tween, targets[i], p);
      }
    }
  }
},
    _buildModifierPlugin = function _buildModifierPlugin(name, modifier) {
  return {
    name: name,
    rawVars: 1,
    //don't pre-process function-based values or "random()" strings.
    init: function init(target, vars, tween) {
      tween._onInit = function (tween) {
        var temp, p;

        if (_isString(vars)) {
          temp = {};

          _forEachName(vars, function (name) {
            return temp[name] = 1;
          }); //if the user passes in a comma-delimited list of property names to roundProps, like "x,y", we round to whole numbers.


          vars = temp;
        }

        if (modifier) {
          temp = {};

          for (p in vars) {
            temp[p] = modifier(vars[p]);
          }

          vars = temp;
        }

        _addModifiers(tween, vars);
      };
    }
  };
}; //register core plugins


var gsap = _gsap.registerPlugin({
  name: "attr",
  init: function init(target, vars, tween, index, targets) {
    var p, pt;

    for (p in vars) {
      pt = this.add(target, "setAttribute", (target.getAttribute(p) || 0) + "", vars[p], index, targets, 0, 0, p);
      pt && (pt.op = p);

      this._props.push(p);
    }
  }
}, {
  name: "endArray",
  init: function init(target, value) {
    var i = value.length;

    while (i--) {
      this.add(target, i, target[i] || 0, value[i]);
    }
  }
}, _buildModifierPlugin("roundProps", _roundModifier), _buildModifierPlugin("modifiers"), _buildModifierPlugin("snap", snap)) || _gsap; //to prevent the core plugins from being dropped via aggressive tree shaking, we must include them in the variable declaration in this way.

Tween.version = Timeline.version = gsap.version = "3.10.4";
_coreReady = 1;
_windowExists() && _wake();
var Power0 = _easeMap.Power0,
    Power1 = _easeMap.Power1,
    Power2 = _easeMap.Power2,
    Power3 = _easeMap.Power3,
    Power4 = _easeMap.Power4,
    Linear = _easeMap.Linear,
    Quad = _easeMap.Quad,
    Cubic = _easeMap.Cubic,
    Quart = _easeMap.Quart,
    Quint = _easeMap.Quint,
    Strong = _easeMap.Strong,
    Elastic = _easeMap.Elastic,
    Back = _easeMap.Back,
    SteppedEase = _easeMap.SteppedEase,
    Bounce = _easeMap.Bounce,
    Sine = _easeMap.Sine,
    Expo = _easeMap.Expo,
    Circ = _easeMap.Circ;

 //export some internal methods/orojects for use in CSSPlugin so that we can externalize that file and allow custom builds that exclude it.


;// CONCATENATED MODULE: ./node_modules/gsap/CSSPlugin.js
function CSSPlugin_typeof(obj) { "@babel/helpers - typeof"; return CSSPlugin_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, CSSPlugin_typeof(obj); }

/*!
 * CSSPlugin 3.10.4
 * https://greensock.com
 *
 * Copyright 2008-2022, GreenSock. All rights reserved.
 * Subject to the terms at https://greensock.com/standard-license or for
 * Club GreenSock members, the agreement issued with that membership.
 * @author: Jack Doyle, jack@greensock.com
*/

/* eslint-disable */


var CSSPlugin_win,
    CSSPlugin_doc,
    _docElement,
    _pluginInitted,
    _tempDiv,
    _tempDivStyler,
    _recentSetterPlugin,
    CSSPlugin_windowExists = function _windowExists() {
  return typeof window !== "undefined";
},
    _transformProps = {},
    _RAD2DEG = 180 / Math.PI,
    _DEG2RAD = Math.PI / 180,
    _atan2 = Math.atan2,
    CSSPlugin_bigNum = 1e8,
    _capsExp = /([A-Z])/g,
    _horizontalExp = /(left|right|width|margin|padding|x)/i,
    _complexExp = /[\s,\(]\S/,
    _propertyAliases = {
  autoAlpha: "opacity,visibility",
  scale: "scaleX,scaleY",
  alpha: "opacity"
},
    _renderCSSProp = function _renderCSSProp(ratio, data) {
  return data.set(data.t, data.p, Math.round((data.s + data.c * ratio) * 10000) / 10000 + data.u, data);
},
    _renderPropWithEnd = function _renderPropWithEnd(ratio, data) {
  return data.set(data.t, data.p, ratio === 1 ? data.e : Math.round((data.s + data.c * ratio) * 10000) / 10000 + data.u, data);
},
    _renderCSSPropWithBeginning = function _renderCSSPropWithBeginning(ratio, data) {
  return data.set(data.t, data.p, ratio ? Math.round((data.s + data.c * ratio) * 10000) / 10000 + data.u : data.b, data);
},
    //if units change, we need a way to render the original unit/value when the tween goes all the way back to the beginning (ratio:0)
_renderRoundedCSSProp = function _renderRoundedCSSProp(ratio, data) {
  var value = data.s + data.c * ratio;
  data.set(data.t, data.p, ~~(value + (value < 0 ? -.5 : .5)) + data.u, data);
},
    _renderNonTweeningValue = function _renderNonTweeningValue(ratio, data) {
  return data.set(data.t, data.p, ratio ? data.e : data.b, data);
},
    _renderNonTweeningValueOnlyAtEnd = function _renderNonTweeningValueOnlyAtEnd(ratio, data) {
  return data.set(data.t, data.p, ratio !== 1 ? data.b : data.e, data);
},
    _setterCSSStyle = function _setterCSSStyle(target, property, value) {
  return target.style[property] = value;
},
    _setterCSSProp = function _setterCSSProp(target, property, value) {
  return target.style.setProperty(property, value);
},
    _setterTransform = function _setterTransform(target, property, value) {
  return target._gsap[property] = value;
},
    _setterScale = function _setterScale(target, property, value) {
  return target._gsap.scaleX = target._gsap.scaleY = value;
},
    _setterScaleWithRender = function _setterScaleWithRender(target, property, value, data, ratio) {
  var cache = target._gsap;
  cache.scaleX = cache.scaleY = value;
  cache.renderTransform(ratio, cache);
},
    _setterTransformWithRender = function _setterTransformWithRender(target, property, value, data, ratio) {
  var cache = target._gsap;
  cache[property] = value;
  cache.renderTransform(ratio, cache);
},
    _transformProp = "transform",
    _transformOriginProp = _transformProp + "Origin",
    _supports3D,
    _createElement = function _createElement(type, ns) {
  var e = CSSPlugin_doc.createElementNS ? CSSPlugin_doc.createElementNS((ns || "http://www.w3.org/1999/xhtml").replace(/^https/, "http"), type) : CSSPlugin_doc.createElement(type); //some servers swap in https for http in the namespace which can break things, making "style" inaccessible.

  return e.style ? e : CSSPlugin_doc.createElement(type); //some environments won't allow access to the element's style when created with a namespace in which case we default to the standard createElement() to work around the issue. Also note that when GSAP is embedded directly inside an SVG file, createElement() won't allow access to the style object in Firefox (see https://greensock.com/forums/topic/20215-problem-using-tweenmax-in-standalone-self-containing-svg-file-err-cannot-set-property-csstext-of-undefined/).
},
    _getComputedProperty = function _getComputedProperty(target, property, skipPrefixFallback) {
  var cs = getComputedStyle(target);
  return cs[property] || cs.getPropertyValue(property.replace(_capsExp, "-$1").toLowerCase()) || cs.getPropertyValue(property) || !skipPrefixFallback && _getComputedProperty(target, _checkPropPrefix(property) || property, 1) || ""; //css variables may not need caps swapped out for dashes and lowercase.
},
    _prefixes = "O,Moz,ms,Ms,Webkit".split(","),
    _checkPropPrefix = function _checkPropPrefix(property, element, preferPrefix) {
  var e = element || _tempDiv,
      s = e.style,
      i = 5;

  if (property in s && !preferPrefix) {
    return property;
  }

  property = property.charAt(0).toUpperCase() + property.substr(1);

  while (i-- && !(_prefixes[i] + property in s)) {}

  return i < 0 ? null : (i === 3 ? "ms" : i >= 0 ? _prefixes[i] : "") + property;
},
    _initCore = function _initCore() {
  if (CSSPlugin_windowExists() && window.document) {
    CSSPlugin_win = window;
    CSSPlugin_doc = CSSPlugin_win.document;
    _docElement = CSSPlugin_doc.documentElement;
    _tempDiv = _createElement("div") || {
      style: {}
    };
    _tempDivStyler = _createElement("div");
    _transformProp = _checkPropPrefix(_transformProp);
    _transformOriginProp = _transformProp + "Origin";
    _tempDiv.style.cssText = "border-width:0;line-height:0;position:absolute;padding:0"; //make sure to override certain properties that may contaminate measurements, in case the user has overreaching style sheets.

    _supports3D = !!_checkPropPrefix("perspective");
    _pluginInitted = 1;
  }
},
    _getBBoxHack = function _getBBoxHack(swapIfPossible) {
  //works around issues in some browsers (like Firefox) that don't correctly report getBBox() on SVG elements inside a <defs> element and/or <mask>. We try creating an SVG, adding it to the documentElement and toss the element in there so that it's definitely part of the rendering tree, then grab the bbox and if it works, we actually swap out the original getBBox() method for our own that does these extra steps whenever getBBox is needed. This helps ensure that performance is optimal (only do all these extra steps when absolutely necessary...most elements don't need it).
  var svg = _createElement("svg", this.ownerSVGElement && this.ownerSVGElement.getAttribute("xmlns") || "http://www.w3.org/2000/svg"),
      oldParent = this.parentNode,
      oldSibling = this.nextSibling,
      oldCSS = this.style.cssText,
      bbox;

  _docElement.appendChild(svg);

  svg.appendChild(this);
  this.style.display = "block";

  if (swapIfPossible) {
    try {
      bbox = this.getBBox();
      this._gsapBBox = this.getBBox; //store the original

      this.getBBox = _getBBoxHack;
    } catch (e) {}
  } else if (this._gsapBBox) {
    bbox = this._gsapBBox();
  }

  if (oldParent) {
    if (oldSibling) {
      oldParent.insertBefore(this, oldSibling);
    } else {
      oldParent.appendChild(this);
    }
  }

  _docElement.removeChild(svg);

  this.style.cssText = oldCSS;
  return bbox;
},
    _getAttributeFallbacks = function _getAttributeFallbacks(target, attributesArray) {
  var i = attributesArray.length;

  while (i--) {
    if (target.hasAttribute(attributesArray[i])) {
      return target.getAttribute(attributesArray[i]);
    }
  }
},
    _getBBox = function _getBBox(target) {
  var bounds;

  try {
    bounds = target.getBBox(); //Firefox throws errors if you try calling getBBox() on an SVG element that's not rendered (like in a <symbol> or <defs>). https://bugzilla.mozilla.org/show_bug.cgi?id=612118
  } catch (error) {
    bounds = _getBBoxHack.call(target, true);
  }

  bounds && (bounds.width || bounds.height) || target.getBBox === _getBBoxHack || (bounds = _getBBoxHack.call(target, true)); //some browsers (like Firefox) misreport the bounds if the element has zero width and height (it just assumes it's at x:0, y:0), thus we need to manually grab the position in that case.

  return bounds && !bounds.width && !bounds.x && !bounds.y ? {
    x: +_getAttributeFallbacks(target, ["x", "cx", "x1"]) || 0,
    y: +_getAttributeFallbacks(target, ["y", "cy", "y1"]) || 0,
    width: 0,
    height: 0
  } : bounds;
},
    _isSVG = function _isSVG(e) {
  return !!(e.getCTM && (!e.parentNode || e.ownerSVGElement) && _getBBox(e));
},
    //reports if the element is an SVG on which getBBox() actually works
_removeProperty = function _removeProperty(target, property) {
  if (property) {
    var style = target.style;

    if (property in _transformProps && property !== _transformOriginProp) {
      property = _transformProp;
    }

    if (style.removeProperty) {
      if (property.substr(0, 2) === "ms" || property.substr(0, 6) === "webkit") {
        //Microsoft and some Webkit browsers don't conform to the standard of capitalizing the first prefix character, so we adjust so that when we prefix the caps with a dash, it's correct (otherwise it'd be "ms-transform" instead of "-ms-transform" for IE9, for example)
        property = "-" + property;
      }

      style.removeProperty(property.replace(_capsExp, "-$1").toLowerCase());
    } else {
      //note: old versions of IE use "removeAttribute()" instead of "removeProperty()"
      style.removeAttribute(property);
    }
  }
},
    _addNonTweeningPT = function _addNonTweeningPT(plugin, target, property, beginning, end, onlySetAtEnd) {
  var pt = new PropTween(plugin._pt, target, property, 0, 1, onlySetAtEnd ? _renderNonTweeningValueOnlyAtEnd : _renderNonTweeningValue);
  plugin._pt = pt;
  pt.b = beginning;
  pt.e = end;

  plugin._props.push(property);

  return pt;
},
    _nonConvertibleUnits = {
  deg: 1,
  rad: 1,
  turn: 1
},
    //takes a single value like 20px and converts it to the unit specified, like "%", returning only the numeric amount.
_convertToUnit = function _convertToUnit(target, property, value, unit) {
  var curValue = parseFloat(value) || 0,
      curUnit = (value + "").trim().substr((curValue + "").length) || "px",
      // some browsers leave extra whitespace at the beginning of CSS variables, hence the need to trim()
  style = _tempDiv.style,
      horizontal = _horizontalExp.test(property),
      isRootSVG = target.tagName.toLowerCase() === "svg",
      measureProperty = (isRootSVG ? "client" : "offset") + (horizontal ? "Width" : "Height"),
      amount = 100,
      toPixels = unit === "px",
      toPercent = unit === "%",
      px,
      parent,
      cache,
      isSVG;

  if (unit === curUnit || !curValue || _nonConvertibleUnits[unit] || _nonConvertibleUnits[curUnit]) {
    return curValue;
  }

  curUnit !== "px" && !toPixels && (curValue = _convertToUnit(target, property, value, "px"));
  isSVG = target.getCTM && _isSVG(target);

  if ((toPercent || curUnit === "%") && (_transformProps[property] || ~property.indexOf("adius"))) {
    px = isSVG ? target.getBBox()[horizontal ? "width" : "height"] : target[measureProperty];
    return _round(toPercent ? curValue / px * amount : curValue / 100 * px);
  }

  style[horizontal ? "width" : "height"] = amount + (toPixels ? curUnit : unit);
  parent = ~property.indexOf("adius") || unit === "em" && target.appendChild && !isRootSVG ? target : target.parentNode;

  if (isSVG) {
    parent = (target.ownerSVGElement || {}).parentNode;
  }

  if (!parent || parent === CSSPlugin_doc || !parent.appendChild) {
    parent = CSSPlugin_doc.body;
  }

  cache = parent._gsap;

  if (cache && toPercent && cache.width && horizontal && cache.time === _ticker.time) {
    return _round(curValue / cache.width * amount);
  } else {
    (toPercent || curUnit === "%") && (style.position = _getComputedProperty(target, "position"));
    parent === target && (style.position = "static"); // like for borderRadius, if it's a % we must have it relative to the target itself but that may not have position: relative or position: absolute in which case it'd go up the chain until it finds its offsetParent (bad). position: static protects against that.

    parent.appendChild(_tempDiv);
    px = _tempDiv[measureProperty];
    parent.removeChild(_tempDiv);
    style.position = "absolute";

    if (horizontal && toPercent) {
      cache = _getCache(parent);
      cache.time = _ticker.time;
      cache.width = parent[measureProperty];
    }
  }

  return _round(toPixels ? px * curValue / amount : px && curValue ? amount / px * curValue : 0);
},
    _get = function _get(target, property, unit, uncache) {
  var value;
  _pluginInitted || _initCore();

  if (property in _propertyAliases && property !== "transform") {
    property = _propertyAliases[property];

    if (~property.indexOf(",")) {
      property = property.split(",")[0];
    }
  }

  if (_transformProps[property] && property !== "transform") {
    value = _parseTransform(target, uncache);
    value = property !== "transformOrigin" ? value[property] : value.svg ? value.origin : _firstTwoOnly(_getComputedProperty(target, _transformOriginProp)) + " " + value.zOrigin + "px";
  } else {
    value = target.style[property];

    if (!value || value === "auto" || uncache || ~(value + "").indexOf("calc(")) {
      value = _specialProps[property] && _specialProps[property](target, property, unit) || _getComputedProperty(target, property) || _getProperty(target, property) || (property === "opacity" ? 1 : 0); // note: some browsers, like Firefox, don't report borderRadius correctly! Instead, it only reports every corner like  borderTopLeftRadius
    }
  }

  return unit && !~(value + "").trim().indexOf(" ") ? _convertToUnit(target, property, value, unit) + unit : value;
},
    _tweenComplexCSSString = function _tweenComplexCSSString(target, prop, start, end) {
  // note: we call _tweenComplexCSSString.call(pluginInstance...) to ensure that it's scoped properly. We may call it from within a plugin too, thus "this" would refer to the plugin.
  if (!start || start === "none") {
    // some browsers like Safari actually PREFER the prefixed property and mis-report the unprefixed value like clipPath (BUG). In other words, even though clipPath exists in the style ("clipPath" in target.style) and it's set in the CSS properly (along with -webkit-clip-path), Safari reports clipPath as "none" whereas WebkitClipPath reports accurately like "ellipse(100% 0% at 50% 0%)", so in this case we must SWITCH to using the prefixed property instead. See https://greensock.com/forums/topic/18310-clippath-doesnt-work-on-ios/
    var p = _checkPropPrefix(prop, target, 1),
        s = p && _getComputedProperty(target, p, 1);

    if (s && s !== start) {
      prop = p;
      start = s;
    } else if (prop === "borderColor") {
      start = _getComputedProperty(target, "borderTopColor"); // Firefox bug: always reports "borderColor" as "", so we must fall back to borderTopColor. See https://greensock.com/forums/topic/24583-how-to-return-colors-that-i-had-after-reverse/
    }
  }

  var pt = new PropTween(this._pt, target.style, prop, 0, 1, _renderComplexString),
      index = 0,
      matchIndex = 0,
      a,
      result,
      startValues,
      startNum,
      color,
      startValue,
      endValue,
      endNum,
      chunk,
      endUnit,
      startUnit,
      endValues;
  pt.b = start;
  pt.e = end;
  start += ""; // ensure values are strings

  end += "";

  if (end === "auto") {
    target.style[prop] = end;
    end = _getComputedProperty(target, prop) || end;
    target.style[prop] = start;
  }

  a = [start, end];

  _colorStringFilter(a); // pass an array with the starting and ending values and let the filter do whatever it needs to the values. If colors are found, it returns true and then we must match where the color shows up order-wise because for things like boxShadow, sometimes the browser provides the computed values with the color FIRST, but the user provides it with the color LAST, so flip them if necessary. Same for drop-shadow().


  start = a[0];
  end = a[1];
  startValues = start.match(_numWithUnitExp) || [];
  endValues = end.match(_numWithUnitExp) || [];

  if (endValues.length) {
    while (result = _numWithUnitExp.exec(end)) {
      endValue = result[0];
      chunk = end.substring(index, result.index);

      if (color) {
        color = (color + 1) % 5;
      } else if (chunk.substr(-5) === "rgba(" || chunk.substr(-5) === "hsla(") {
        color = 1;
      }

      if (endValue !== (startValue = startValues[matchIndex++] || "")) {
        startNum = parseFloat(startValue) || 0;
        startUnit = startValue.substr((startNum + "").length);
        endValue.charAt(1) === "=" && (endValue = _parseRelative(startNum, endValue) + startUnit);
        endNum = parseFloat(endValue);
        endUnit = endValue.substr((endNum + "").length);
        index = _numWithUnitExp.lastIndex - endUnit.length;

        if (!endUnit) {
          //if something like "perspective:300" is passed in and we must add a unit to the end
          endUnit = endUnit || _config.units[prop] || startUnit;

          if (index === end.length) {
            end += endUnit;
            pt.e += endUnit;
          }
        }

        if (startUnit !== endUnit) {
          startNum = _convertToUnit(target, prop, startValue, endUnit) || 0;
        } // these nested PropTweens are handled in a special way - we'll never actually call a render or setter method on them. We'll just loop through them in the parent complex string PropTween's render method.


        pt._pt = {
          _next: pt._pt,
          p: chunk || matchIndex === 1 ? chunk : ",",
          //note: SVG spec allows omission of comma/space when a negative sign is wedged between two numbers, like 2.5-5.3 instead of 2.5,-5.3 but when tweening, the negative value may switch to positive, so we insert the comma just in case.
          s: startNum,
          c: endNum - startNum,
          m: color && color < 4 || prop === "zIndex" ? Math.round : 0
        };
      }
    }

    pt.c = index < end.length ? end.substring(index, end.length) : ""; //we use the "c" of the PropTween to store the final part of the string (after the last number)
  } else {
    pt.r = prop === "display" && end === "none" ? _renderNonTweeningValueOnlyAtEnd : _renderNonTweeningValue;
  }

  _relExp.test(end) && (pt.e = 0); //if the end string contains relative values or dynamic random(...) values, delete the end it so that on the final render we don't actually set it to the string with += or -= characters (forces it to use the calculated value).

  this._pt = pt; //start the linked list with this new PropTween. Remember, we call _tweenComplexCSSString.call(pluginInstance...) to ensure that it's scoped properly. We may call it from within another plugin too, thus "this" would refer to the plugin.

  return pt;
},
    _keywordToPercent = {
  top: "0%",
  bottom: "100%",
  left: "0%",
  right: "100%",
  center: "50%"
},
    _convertKeywordsToPercentages = function _convertKeywordsToPercentages(value) {
  var split = value.split(" "),
      x = split[0],
      y = split[1] || "50%";

  if (x === "top" || x === "bottom" || y === "left" || y === "right") {
    //the user provided them in the wrong order, so flip them
    value = x;
    x = y;
    y = value;
  }

  split[0] = _keywordToPercent[x] || x;
  split[1] = _keywordToPercent[y] || y;
  return split.join(" ");
},
    _renderClearProps = function _renderClearProps(ratio, data) {
  if (data.tween && data.tween._time === data.tween._dur) {
    var target = data.t,
        style = target.style,
        props = data.u,
        cache = target._gsap,
        prop,
        clearTransforms,
        i;

    if (props === "all" || props === true) {
      style.cssText = "";
      clearTransforms = 1;
    } else {
      props = props.split(",");
      i = props.length;

      while (--i > -1) {
        prop = props[i];

        if (_transformProps[prop]) {
          clearTransforms = 1;
          prop = prop === "transformOrigin" ? _transformOriginProp : _transformProp;
        }

        _removeProperty(target, prop);
      }
    }

    if (clearTransforms) {
      _removeProperty(target, _transformProp);

      if (cache) {
        cache.svg && target.removeAttribute("transform");

        _parseTransform(target, 1); // force all the cached values back to "normal"/identity, otherwise if there's another tween that's already set to render transforms on this element, it could display the wrong values.


        cache.uncache = 1;
      }
    }
  }
},
    // note: specialProps should return 1 if (and only if) they have a non-zero priority. It indicates we need to sort the linked list.
_specialProps = {
  clearProps: function clearProps(plugin, target, property, endValue, tween) {
    if (tween.data !== "isFromStart") {
      var pt = plugin._pt = new PropTween(plugin._pt, target, property, 0, 0, _renderClearProps);
      pt.u = endValue;
      pt.pr = -10;
      pt.tween = tween;

      plugin._props.push(property);

      return 1;
    }
  }
  /* className feature (about 0.4kb gzipped).
  , className(plugin, target, property, endValue, tween) {
  	let _renderClassName = (ratio, data) => {
  			data.css.render(ratio, data.css);
  			if (!ratio || ratio === 1) {
  				let inline = data.rmv,
  					target = data.t,
  					p;
  				target.setAttribute("class", ratio ? data.e : data.b);
  				for (p in inline) {
  					_removeProperty(target, p);
  				}
  			}
  		},
  		_getAllStyles = (target) => {
  			let styles = {},
  				computed = getComputedStyle(target),
  				p;
  			for (p in computed) {
  				if (isNaN(p) && p !== "cssText" && p !== "length") {
  					styles[p] = computed[p];
  				}
  			}
  			_setDefaults(styles, _parseTransform(target, 1));
  			return styles;
  		},
  		startClassList = target.getAttribute("class"),
  		style = target.style,
  		cssText = style.cssText,
  		cache = target._gsap,
  		classPT = cache.classPT,
  		inlineToRemoveAtEnd = {},
  		data = {t:target, plugin:plugin, rmv:inlineToRemoveAtEnd, b:startClassList, e:(endValue.charAt(1) !== "=") ? endValue : startClassList.replace(new RegExp("(?:\\s|^)" + endValue.substr(2) + "(?![\\w-])"), "") + ((endValue.charAt(0) === "+") ? " " + endValue.substr(2) : "")},
  		changingVars = {},
  		startVars = _getAllStyles(target),
  		transformRelated = /(transform|perspective)/i,
  		endVars, p;
  	if (classPT) {
  		classPT.r(1, classPT.d);
  		_removeLinkedListItem(classPT.d.plugin, classPT, "_pt");
  	}
  	target.setAttribute("class", data.e);
  	endVars = _getAllStyles(target, true);
  	target.setAttribute("class", startClassList);
  	for (p in endVars) {
  		if (endVars[p] !== startVars[p] && !transformRelated.test(p)) {
  			changingVars[p] = endVars[p];
  			if (!style[p] && style[p] !== "0") {
  				inlineToRemoveAtEnd[p] = 1;
  			}
  		}
  	}
  	cache.classPT = plugin._pt = new PropTween(plugin._pt, target, "className", 0, 0, _renderClassName, data, 0, -11);
  	if (style.cssText !== cssText) { //only apply if things change. Otherwise, in cases like a background-image that's pulled dynamically, it could cause a refresh. See https://greensock.com/forums/topic/20368-possible-gsap-bug-switching-classnames-in-chrome/.
  		style.cssText = cssText; //we recorded cssText before we swapped classes and ran _getAllStyles() because in cases when a className tween is overwritten, we remove all the related tweening properties from that class change (otherwise class-specific stuff can't override properties we've directly set on the target's style object due to specificity).
  	}
  	_parseTransform(target, true); //to clear the caching of transforms
  	data.css = new gsap.plugins.css();
  	data.css.init(target, changingVars, tween);
  	plugin._props.push(...data.css._props);
  	return 1;
  }
  */

},

/*
 * --------------------------------------------------------------------------------------
 * TRANSFORMS
 * --------------------------------------------------------------------------------------
 */
_identity2DMatrix = [1, 0, 0, 1, 0, 0],
    _rotationalProperties = {},
    _isNullTransform = function _isNullTransform(value) {
  return value === "matrix(1, 0, 0, 1, 0, 0)" || value === "none" || !value;
},
    _getComputedTransformMatrixAsArray = function _getComputedTransformMatrixAsArray(target) {
  var matrixString = _getComputedProperty(target, _transformProp);

  return _isNullTransform(matrixString) ? _identity2DMatrix : matrixString.substr(7).match(_numExp).map(_round);
},
    _getMatrix = function _getMatrix(target, force2D) {
  var cache = target._gsap || _getCache(target),
      style = target.style,
      matrix = _getComputedTransformMatrixAsArray(target),
      parent,
      nextSibling,
      temp,
      addedToDOM;

  if (cache.svg && target.getAttribute("transform")) {
    temp = target.transform.baseVal.consolidate().matrix; //ensures that even complex values like "translate(50,60) rotate(135,0,0)" are parsed because it mashes it into a matrix.

    matrix = [temp.a, temp.b, temp.c, temp.d, temp.e, temp.f];
    return matrix.join(",") === "1,0,0,1,0,0" ? _identity2DMatrix : matrix;
  } else if (matrix === _identity2DMatrix && !target.offsetParent && target !== _docElement && !cache.svg) {
    //note: if offsetParent is null, that means the element isn't in the normal document flow, like if it has display:none or one of its ancestors has display:none). Firefox returns null for getComputedStyle() if the element is in an iframe that has display:none. https://bugzilla.mozilla.org/show_bug.cgi?id=548397
    //browsers don't report transforms accurately unless the element is in the DOM and has a display value that's not "none". Firefox and Microsoft browsers have a partial bug where they'll report transforms even if display:none BUT not any percentage-based values like translate(-50%, 8px) will be reported as if it's translate(0, 8px).
    temp = style.display;
    style.display = "block";
    parent = target.parentNode;

    if (!parent || !target.offsetParent) {
      // note: in 3.3.0 we switched target.offsetParent to _doc.body.contains(target) to avoid [sometimes unnecessary] MutationObserver calls but that wasn't adequate because there are edge cases where nested position: fixed elements need to get reparented to accurately sense transforms. See https://github.com/greensock/GSAP/issues/388 and https://github.com/greensock/GSAP/issues/375
      addedToDOM = 1; //flag

      nextSibling = target.nextSibling;

      _docElement.appendChild(target); //we must add it to the DOM in order to get values properly

    }

    matrix = _getComputedTransformMatrixAsArray(target);
    temp ? style.display = temp : _removeProperty(target, "display");

    if (addedToDOM) {
      nextSibling ? parent.insertBefore(target, nextSibling) : parent ? parent.appendChild(target) : _docElement.removeChild(target);
    }
  }

  return force2D && matrix.length > 6 ? [matrix[0], matrix[1], matrix[4], matrix[5], matrix[12], matrix[13]] : matrix;
},
    _applySVGOrigin = function _applySVGOrigin(target, origin, originIsAbsolute, smooth, matrixArray, pluginToAddPropTweensTo) {
  var cache = target._gsap,
      matrix = matrixArray || _getMatrix(target, true),
      xOriginOld = cache.xOrigin || 0,
      yOriginOld = cache.yOrigin || 0,
      xOffsetOld = cache.xOffset || 0,
      yOffsetOld = cache.yOffset || 0,
      a = matrix[0],
      b = matrix[1],
      c = matrix[2],
      d = matrix[3],
      tx = matrix[4],
      ty = matrix[5],
      originSplit = origin.split(" "),
      xOrigin = parseFloat(originSplit[0]) || 0,
      yOrigin = parseFloat(originSplit[1]) || 0,
      bounds,
      determinant,
      x,
      y;

  if (!originIsAbsolute) {
    bounds = _getBBox(target);
    xOrigin = bounds.x + (~originSplit[0].indexOf("%") ? xOrigin / 100 * bounds.width : xOrigin);
    yOrigin = bounds.y + (~(originSplit[1] || originSplit[0]).indexOf("%") ? yOrigin / 100 * bounds.height : yOrigin);
  } else if (matrix !== _identity2DMatrix && (determinant = a * d - b * c)) {
    //if it's zero (like if scaleX and scaleY are zero), skip it to avoid errors with dividing by zero.
    x = xOrigin * (d / determinant) + yOrigin * (-c / determinant) + (c * ty - d * tx) / determinant;
    y = xOrigin * (-b / determinant) + yOrigin * (a / determinant) - (a * ty - b * tx) / determinant;
    xOrigin = x;
    yOrigin = y;
  }

  if (smooth || smooth !== false && cache.smooth) {
    tx = xOrigin - xOriginOld;
    ty = yOrigin - yOriginOld;
    cache.xOffset = xOffsetOld + (tx * a + ty * c) - tx;
    cache.yOffset = yOffsetOld + (tx * b + ty * d) - ty;
  } else {
    cache.xOffset = cache.yOffset = 0;
  }

  cache.xOrigin = xOrigin;
  cache.yOrigin = yOrigin;
  cache.smooth = !!smooth;
  cache.origin = origin;
  cache.originIsAbsolute = !!originIsAbsolute;
  target.style[_transformOriginProp] = "0px 0px"; //otherwise, if someone sets  an origin via CSS, it will likely interfere with the SVG transform attribute ones (because remember, we're baking the origin into the matrix() value).

  if (pluginToAddPropTweensTo) {
    _addNonTweeningPT(pluginToAddPropTweensTo, cache, "xOrigin", xOriginOld, xOrigin);

    _addNonTweeningPT(pluginToAddPropTweensTo, cache, "yOrigin", yOriginOld, yOrigin);

    _addNonTweeningPT(pluginToAddPropTweensTo, cache, "xOffset", xOffsetOld, cache.xOffset);

    _addNonTweeningPT(pluginToAddPropTweensTo, cache, "yOffset", yOffsetOld, cache.yOffset);
  }

  target.setAttribute("data-svg-origin", xOrigin + " " + yOrigin);
},
    _parseTransform = function _parseTransform(target, uncache) {
  var cache = target._gsap || new GSCache(target);

  if ("x" in cache && !uncache && !cache.uncache) {
    return cache;
  }

  var style = target.style,
      invertedScaleX = cache.scaleX < 0,
      px = "px",
      deg = "deg",
      origin = _getComputedProperty(target, _transformOriginProp) || "0",
      x,
      y,
      z,
      scaleX,
      scaleY,
      rotation,
      rotationX,
      rotationY,
      skewX,
      skewY,
      perspective,
      xOrigin,
      yOrigin,
      matrix,
      angle,
      cos,
      sin,
      a,
      b,
      c,
      d,
      a12,
      a22,
      t1,
      t2,
      t3,
      a13,
      a23,
      a33,
      a42,
      a43,
      a32;
  x = y = z = rotation = rotationX = rotationY = skewX = skewY = perspective = 0;
  scaleX = scaleY = 1;
  cache.svg = !!(target.getCTM && _isSVG(target));
  matrix = _getMatrix(target, cache.svg);

  if (cache.svg) {
    t1 = (!cache.uncache || origin === "0px 0px") && !uncache && target.getAttribute("data-svg-origin"); // if origin is 0,0 and cache.uncache is true, let the recorded data-svg-origin stay. Otherwise, whenever we set cache.uncache to true, we'd need to set element.style.transformOrigin = (cache.xOrigin - bbox.x) + "px " + (cache.yOrigin - bbox.y) + "px". Remember, to work around browser inconsistencies we always force SVG elements' transformOrigin to 0,0 and offset the translation accordingly.

    _applySVGOrigin(target, t1 || origin, !!t1 || cache.originIsAbsolute, cache.smooth !== false, matrix);
  }

  xOrigin = cache.xOrigin || 0;
  yOrigin = cache.yOrigin || 0;

  if (matrix !== _identity2DMatrix) {
    a = matrix[0]; //a11

    b = matrix[1]; //a21

    c = matrix[2]; //a31

    d = matrix[3]; //a41

    x = a12 = matrix[4];
    y = a22 = matrix[5]; //2D matrix

    if (matrix.length === 6) {
      scaleX = Math.sqrt(a * a + b * b);
      scaleY = Math.sqrt(d * d + c * c);
      rotation = a || b ? _atan2(b, a) * _RAD2DEG : 0; //note: if scaleX is 0, we cannot accurately measure rotation. Same for skewX with a scaleY of 0. Therefore, we default to the previously recorded value (or zero if that doesn't exist).

      skewX = c || d ? _atan2(c, d) * _RAD2DEG + rotation : 0;
      skewX && (scaleY *= Math.abs(Math.cos(skewX * _DEG2RAD)));

      if (cache.svg) {
        x -= xOrigin - (xOrigin * a + yOrigin * c);
        y -= yOrigin - (xOrigin * b + yOrigin * d);
      } //3D matrix

    } else {
      a32 = matrix[6];
      a42 = matrix[7];
      a13 = matrix[8];
      a23 = matrix[9];
      a33 = matrix[10];
      a43 = matrix[11];
      x = matrix[12];
      y = matrix[13];
      z = matrix[14];
      angle = _atan2(a32, a33);
      rotationX = angle * _RAD2DEG; //rotationX

      if (angle) {
        cos = Math.cos(-angle);
        sin = Math.sin(-angle);
        t1 = a12 * cos + a13 * sin;
        t2 = a22 * cos + a23 * sin;
        t3 = a32 * cos + a33 * sin;
        a13 = a12 * -sin + a13 * cos;
        a23 = a22 * -sin + a23 * cos;
        a33 = a32 * -sin + a33 * cos;
        a43 = a42 * -sin + a43 * cos;
        a12 = t1;
        a22 = t2;
        a32 = t3;
      } //rotationY


      angle = _atan2(-c, a33);
      rotationY = angle * _RAD2DEG;

      if (angle) {
        cos = Math.cos(-angle);
        sin = Math.sin(-angle);
        t1 = a * cos - a13 * sin;
        t2 = b * cos - a23 * sin;
        t3 = c * cos - a33 * sin;
        a43 = d * sin + a43 * cos;
        a = t1;
        b = t2;
        c = t3;
      } //rotationZ


      angle = _atan2(b, a);
      rotation = angle * _RAD2DEG;

      if (angle) {
        cos = Math.cos(angle);
        sin = Math.sin(angle);
        t1 = a * cos + b * sin;
        t2 = a12 * cos + a22 * sin;
        b = b * cos - a * sin;
        a22 = a22 * cos - a12 * sin;
        a = t1;
        a12 = t2;
      }

      if (rotationX && Math.abs(rotationX) + Math.abs(rotation) > 359.9) {
        //when rotationY is set, it will often be parsed as 180 degrees different than it should be, and rotationX and rotation both being 180 (it looks the same), so we adjust for that here.
        rotationX = rotation = 0;
        rotationY = 180 - rotationY;
      }

      scaleX = _round(Math.sqrt(a * a + b * b + c * c));
      scaleY = _round(Math.sqrt(a22 * a22 + a32 * a32));
      angle = _atan2(a12, a22);
      skewX = Math.abs(angle) > 0.0002 ? angle * _RAD2DEG : 0;
      perspective = a43 ? 1 / (a43 < 0 ? -a43 : a43) : 0;
    }

    if (cache.svg) {
      //sense if there are CSS transforms applied on an SVG element in which case we must overwrite them when rendering. The transform attribute is more reliable cross-browser, but we can't just remove the CSS ones because they may be applied in a CSS rule somewhere (not just inline).
      t1 = target.getAttribute("transform");
      cache.forceCSS = target.setAttribute("transform", "") || !_isNullTransform(_getComputedProperty(target, _transformProp));
      t1 && target.setAttribute("transform", t1);
    }
  }

  if (Math.abs(skewX) > 90 && Math.abs(skewX) < 270) {
    if (invertedScaleX) {
      scaleX *= -1;
      skewX += rotation <= 0 ? 180 : -180;
      rotation += rotation <= 0 ? 180 : -180;
    } else {
      scaleY *= -1;
      skewX += skewX <= 0 ? 180 : -180;
    }
  }

  uncache = uncache || cache.uncache;
  cache.x = x - ((cache.xPercent = x && (!uncache && cache.xPercent || (Math.round(target.offsetWidth / 2) === Math.round(-x) ? -50 : 0))) ? target.offsetWidth * cache.xPercent / 100 : 0) + px;
  cache.y = y - ((cache.yPercent = y && (!uncache && cache.yPercent || (Math.round(target.offsetHeight / 2) === Math.round(-y) ? -50 : 0))) ? target.offsetHeight * cache.yPercent / 100 : 0) + px;
  cache.z = z + px;
  cache.scaleX = _round(scaleX);
  cache.scaleY = _round(scaleY);
  cache.rotation = _round(rotation) + deg;
  cache.rotationX = _round(rotationX) + deg;
  cache.rotationY = _round(rotationY) + deg;
  cache.skewX = skewX + deg;
  cache.skewY = skewY + deg;
  cache.transformPerspective = perspective + px;

  if (cache.zOrigin = parseFloat(origin.split(" ")[2]) || 0) {
    style[_transformOriginProp] = _firstTwoOnly(origin);
  }

  cache.xOffset = cache.yOffset = 0;
  cache.force3D = _config.force3D;
  cache.renderTransform = cache.svg ? _renderSVGTransforms : _supports3D ? _renderCSSTransforms : _renderNon3DTransforms;
  cache.uncache = 0;
  return cache;
},
    _firstTwoOnly = function _firstTwoOnly(value) {
  return (value = value.split(" "))[0] + " " + value[1];
},
    //for handling transformOrigin values, stripping out the 3rd dimension
_addPxTranslate = function _addPxTranslate(target, start, value) {
  var unit = getUnit(start);
  return _round(parseFloat(start) + parseFloat(_convertToUnit(target, "x", value + "px", unit))) + unit;
},
    _renderNon3DTransforms = function _renderNon3DTransforms(ratio, cache) {
  cache.z = "0px";
  cache.rotationY = cache.rotationX = "0deg";
  cache.force3D = 0;

  _renderCSSTransforms(ratio, cache);
},
    _zeroDeg = "0deg",
    _zeroPx = "0px",
    _endParenthesis = ") ",
    _renderCSSTransforms = function _renderCSSTransforms(ratio, cache) {
  var _ref = cache || this,
      xPercent = _ref.xPercent,
      yPercent = _ref.yPercent,
      x = _ref.x,
      y = _ref.y,
      z = _ref.z,
      rotation = _ref.rotation,
      rotationY = _ref.rotationY,
      rotationX = _ref.rotationX,
      skewX = _ref.skewX,
      skewY = _ref.skewY,
      scaleX = _ref.scaleX,
      scaleY = _ref.scaleY,
      transformPerspective = _ref.transformPerspective,
      force3D = _ref.force3D,
      target = _ref.target,
      zOrigin = _ref.zOrigin,
      transforms = "",
      use3D = force3D === "auto" && ratio && ratio !== 1 || force3D === true; // Safari has a bug that causes it not to render 3D transform-origin values properly, so we force the z origin to 0, record it in the cache, and then do the math here to offset the translate values accordingly (basically do the 3D transform-origin part manually)


  if (zOrigin && (rotationX !== _zeroDeg || rotationY !== _zeroDeg)) {
    var angle = parseFloat(rotationY) * _DEG2RAD,
        a13 = Math.sin(angle),
        a33 = Math.cos(angle),
        cos;

    angle = parseFloat(rotationX) * _DEG2RAD;
    cos = Math.cos(angle);
    x = _addPxTranslate(target, x, a13 * cos * -zOrigin);
    y = _addPxTranslate(target, y, -Math.sin(angle) * -zOrigin);
    z = _addPxTranslate(target, z, a33 * cos * -zOrigin + zOrigin);
  }

  if (transformPerspective !== _zeroPx) {
    transforms += "perspective(" + transformPerspective + _endParenthesis;
  }

  if (xPercent || yPercent) {
    transforms += "translate(" + xPercent + "%, " + yPercent + "%) ";
  }

  if (use3D || x !== _zeroPx || y !== _zeroPx || z !== _zeroPx) {
    transforms += z !== _zeroPx || use3D ? "translate3d(" + x + ", " + y + ", " + z + ") " : "translate(" + x + ", " + y + _endParenthesis;
  }

  if (rotation !== _zeroDeg) {
    transforms += "rotate(" + rotation + _endParenthesis;
  }

  if (rotationY !== _zeroDeg) {
    transforms += "rotateY(" + rotationY + _endParenthesis;
  }

  if (rotationX !== _zeroDeg) {
    transforms += "rotateX(" + rotationX + _endParenthesis;
  }

  if (skewX !== _zeroDeg || skewY !== _zeroDeg) {
    transforms += "skew(" + skewX + ", " + skewY + _endParenthesis;
  }

  if (scaleX !== 1 || scaleY !== 1) {
    transforms += "scale(" + scaleX + ", " + scaleY + _endParenthesis;
  }

  target.style[_transformProp] = transforms || "translate(0, 0)";
},
    _renderSVGTransforms = function _renderSVGTransforms(ratio, cache) {
  var _ref2 = cache || this,
      xPercent = _ref2.xPercent,
      yPercent = _ref2.yPercent,
      x = _ref2.x,
      y = _ref2.y,
      rotation = _ref2.rotation,
      skewX = _ref2.skewX,
      skewY = _ref2.skewY,
      scaleX = _ref2.scaleX,
      scaleY = _ref2.scaleY,
      target = _ref2.target,
      xOrigin = _ref2.xOrigin,
      yOrigin = _ref2.yOrigin,
      xOffset = _ref2.xOffset,
      yOffset = _ref2.yOffset,
      forceCSS = _ref2.forceCSS,
      tx = parseFloat(x),
      ty = parseFloat(y),
      a11,
      a21,
      a12,
      a22,
      temp;

  rotation = parseFloat(rotation);
  skewX = parseFloat(skewX);
  skewY = parseFloat(skewY);

  if (skewY) {
    //for performance reasons, we combine all skewing into the skewX and rotation values. Remember, a skewY of 10 degrees looks the same as a rotation of 10 degrees plus a skewX of 10 degrees.
    skewY = parseFloat(skewY);
    skewX += skewY;
    rotation += skewY;
  }

  if (rotation || skewX) {
    rotation *= _DEG2RAD;
    skewX *= _DEG2RAD;
    a11 = Math.cos(rotation) * scaleX;
    a21 = Math.sin(rotation) * scaleX;
    a12 = Math.sin(rotation - skewX) * -scaleY;
    a22 = Math.cos(rotation - skewX) * scaleY;

    if (skewX) {
      skewY *= _DEG2RAD;
      temp = Math.tan(skewX - skewY);
      temp = Math.sqrt(1 + temp * temp);
      a12 *= temp;
      a22 *= temp;

      if (skewY) {
        temp = Math.tan(skewY);
        temp = Math.sqrt(1 + temp * temp);
        a11 *= temp;
        a21 *= temp;
      }
    }

    a11 = _round(a11);
    a21 = _round(a21);
    a12 = _round(a12);
    a22 = _round(a22);
  } else {
    a11 = scaleX;
    a22 = scaleY;
    a21 = a12 = 0;
  }

  if (tx && !~(x + "").indexOf("px") || ty && !~(y + "").indexOf("px")) {
    tx = _convertToUnit(target, "x", x, "px");
    ty = _convertToUnit(target, "y", y, "px");
  }

  if (xOrigin || yOrigin || xOffset || yOffset) {
    tx = _round(tx + xOrigin - (xOrigin * a11 + yOrigin * a12) + xOffset);
    ty = _round(ty + yOrigin - (xOrigin * a21 + yOrigin * a22) + yOffset);
  }

  if (xPercent || yPercent) {
    //The SVG spec doesn't support percentage-based translation in the "transform" attribute, so we merge it into the translation to simulate it.
    temp = target.getBBox();
    tx = _round(tx + xPercent / 100 * temp.width);
    ty = _round(ty + yPercent / 100 * temp.height);
  }

  temp = "matrix(" + a11 + "," + a21 + "," + a12 + "," + a22 + "," + tx + "," + ty + ")";
  target.setAttribute("transform", temp);
  forceCSS && (target.style[_transformProp] = temp); //some browsers prioritize CSS transforms over the transform attribute. When we sense that the user has CSS transforms applied, we must overwrite them this way (otherwise some browser simply won't render the  transform attribute changes!)
},
    _addRotationalPropTween = function _addRotationalPropTween(plugin, target, property, startNum, endValue) {
  var cap = 360,
      isString = _isString(endValue),
      endNum = parseFloat(endValue) * (isString && ~endValue.indexOf("rad") ? _RAD2DEG : 1),
      change = endNum - startNum,
      finalValue = startNum + change + "deg",
      direction,
      pt;

  if (isString) {
    direction = endValue.split("_")[1];

    if (direction === "short") {
      change %= cap;

      if (change !== change % (cap / 2)) {
        change += change < 0 ? cap : -cap;
      }
    }

    if (direction === "cw" && change < 0) {
      change = (change + cap * CSSPlugin_bigNum) % cap - ~~(change / cap) * cap;
    } else if (direction === "ccw" && change > 0) {
      change = (change - cap * CSSPlugin_bigNum) % cap - ~~(change / cap) * cap;
    }
  }

  plugin._pt = pt = new PropTween(plugin._pt, target, property, startNum, change, _renderPropWithEnd);
  pt.e = finalValue;
  pt.u = "deg";

  plugin._props.push(property);

  return pt;
},
    _assign = function _assign(target, source) {
  // Internet Explorer doesn't have Object.assign(), so we recreate it here.
  for (var p in source) {
    target[p] = source[p];
  }

  return target;
},
    _addRawTransformPTs = function _addRawTransformPTs(plugin, transforms, target) {
  //for handling cases where someone passes in a whole transform string, like transform: "scale(2, 3) rotate(20deg) translateY(30em)"
  var startCache = _assign({}, target._gsap),
      exclude = "perspective,force3D,transformOrigin,svgOrigin",
      style = target.style,
      endCache,
      p,
      startValue,
      endValue,
      startNum,
      endNum,
      startUnit,
      endUnit;

  if (startCache.svg) {
    startValue = target.getAttribute("transform");
    target.setAttribute("transform", "");
    style[_transformProp] = transforms;
    endCache = _parseTransform(target, 1);

    _removeProperty(target, _transformProp);

    target.setAttribute("transform", startValue);
  } else {
    startValue = getComputedStyle(target)[_transformProp];
    style[_transformProp] = transforms;
    endCache = _parseTransform(target, 1);
    style[_transformProp] = startValue;
  }

  for (p in _transformProps) {
    startValue = startCache[p];
    endValue = endCache[p];

    if (startValue !== endValue && exclude.indexOf(p) < 0) {
      //tweening to no perspective gives very unintuitive results - just keep the same perspective in that case.
      startUnit = getUnit(startValue);
      endUnit = getUnit(endValue);
      startNum = startUnit !== endUnit ? _convertToUnit(target, p, startValue, endUnit) : parseFloat(startValue);
      endNum = parseFloat(endValue);
      plugin._pt = new PropTween(plugin._pt, endCache, p, startNum, endNum - startNum, _renderCSSProp);
      plugin._pt.u = endUnit || 0;

      plugin._props.push(p);
    }
  }

  _assign(endCache, startCache);
}; // handle splitting apart padding, margin, borderWidth, and borderRadius into their 4 components. Firefox, for example, won't report borderRadius correctly - it will only do borderTopLeftRadius and the other corners. We also want to handle paddingTop, marginLeft, borderRightWidth, etc.


_forEachName("padding,margin,Width,Radius", function (name, index) {
  var t = "Top",
      r = "Right",
      b = "Bottom",
      l = "Left",
      props = (index < 3 ? [t, r, b, l] : [t + l, t + r, b + r, b + l]).map(function (side) {
    return index < 2 ? name + side : "border" + side + name;
  });

  _specialProps[index > 1 ? "border" + name : name] = function (plugin, target, property, endValue, tween) {
    var a, vars;

    if (arguments.length < 4) {
      // getter, passed target, property, and unit (from _get())
      a = props.map(function (prop) {
        return _get(plugin, prop, property);
      });
      vars = a.join(" ");
      return vars.split(a[0]).length === 5 ? a[0] : vars;
    }

    a = (endValue + "").split(" ");
    vars = {};
    props.forEach(function (prop, i) {
      return vars[prop] = a[i] = a[i] || a[(i - 1) / 2 | 0];
    });
    plugin.init(target, vars, tween);
  };
});

var CSSPlugin = {
  name: "css",
  register: _initCore,
  targetTest: function targetTest(target) {
    return target.style && target.nodeType;
  },
  init: function init(target, vars, tween, index, targets) {
    var props = this._props,
        style = target.style,
        startAt = tween.vars.startAt,
        startValue,
        endValue,
        endNum,
        startNum,
        type,
        specialProp,
        p,
        startUnit,
        endUnit,
        relative,
        isTransformRelated,
        transformPropTween,
        cache,
        smooth,
        hasPriority;
    _pluginInitted || _initCore();

    for (p in vars) {
      if (p === "autoRound") {
        continue;
      }

      endValue = vars[p];

      if (_plugins[p] && _checkPlugin(p, vars, tween, index, target, targets)) {
        // plugins
        continue;
      }

      type = CSSPlugin_typeof(endValue);
      specialProp = _specialProps[p];

      if (type === "function") {
        endValue = endValue.call(tween, index, target, targets);
        type = CSSPlugin_typeof(endValue);
      }

      if (type === "string" && ~endValue.indexOf("random(")) {
        endValue = _replaceRandom(endValue);
      }

      if (specialProp) {
        specialProp(this, target, p, endValue, tween) && (hasPriority = 1);
      } else if (p.substr(0, 2) === "--") {
        //CSS variable
        startValue = (getComputedStyle(target).getPropertyValue(p) + "").trim();
        endValue += "";
        _colorExp.lastIndex = 0;

        if (!_colorExp.test(startValue)) {
          // colors don't have units
          startUnit = getUnit(startValue);
          endUnit = getUnit(endValue);
        }

        endUnit ? startUnit !== endUnit && (startValue = _convertToUnit(target, p, startValue, endUnit) + endUnit) : startUnit && (endValue += startUnit);
        this.add(style, "setProperty", startValue, endValue, index, targets, 0, 0, p);
        props.push(p);
      } else if (type !== "undefined") {
        if (startAt && p in startAt) {
          // in case someone hard-codes a complex value as the start, like top: "calc(2vh / 2)". Without this, it'd use the computed value (always in px)
          startValue = typeof startAt[p] === "function" ? startAt[p].call(tween, index, target, targets) : startAt[p];
          _isString(startValue) && ~startValue.indexOf("random(") && (startValue = _replaceRandom(startValue));
          getUnit(startValue + "") || (startValue += _config.units[p] || getUnit(_get(target, p)) || ""); // for cases when someone passes in a unitless value like {x: 100}; if we try setting translate(100, 0px) it won't work.

          (startValue + "").charAt(1) === "=" && (startValue = _get(target, p)); // can't work with relative values
        } else {
          startValue = _get(target, p);
        }

        startNum = parseFloat(startValue);
        relative = type === "string" && endValue.charAt(1) === "=" && endValue.substr(0, 2);
        relative && (endValue = endValue.substr(2));
        endNum = parseFloat(endValue);

        if (p in _propertyAliases) {
          if (p === "autoAlpha") {
            //special case where we control the visibility along with opacity. We still allow the opacity value to pass through and get tweened.
            if (startNum === 1 && _get(target, "visibility") === "hidden" && endNum) {
              //if visibility is initially set to "hidden", we should interpret that as intent to make opacity 0 (a convenience)
              startNum = 0;
            }

            _addNonTweeningPT(this, style, "visibility", startNum ? "inherit" : "hidden", endNum ? "inherit" : "hidden", !endNum);
          }

          if (p !== "scale" && p !== "transform") {
            p = _propertyAliases[p];
            ~p.indexOf(",") && (p = p.split(",")[0]);
          }
        }

        isTransformRelated = p in _transformProps; //--- TRANSFORM-RELATED ---

        if (isTransformRelated) {
          if (!transformPropTween) {
            cache = target._gsap;
            cache.renderTransform && !vars.parseTransform || _parseTransform(target, vars.parseTransform); // if, for example, gsap.set(... {transform:"translateX(50vw)"}), the _get() call doesn't parse the transform, thus cache.renderTransform won't be set yet so force the parsing of the transform here.

            smooth = vars.smoothOrigin !== false && cache.smooth;
            transformPropTween = this._pt = new PropTween(this._pt, style, _transformProp, 0, 1, cache.renderTransform, cache, 0, -1); //the first time through, create the rendering PropTween so that it runs LAST (in the linked list, we keep adding to the beginning)

            transformPropTween.dep = 1; //flag it as dependent so that if things get killed/overwritten and this is the only PropTween left, we can safely kill the whole tween.
          }

          if (p === "scale") {
            this._pt = new PropTween(this._pt, cache, "scaleY", cache.scaleY, (relative ? _parseRelative(cache.scaleY, relative + endNum) : endNum) - cache.scaleY || 0);
            props.push("scaleY", p);
            p += "X";
          } else if (p === "transformOrigin") {
            endValue = _convertKeywordsToPercentages(endValue); //in case something like "left top" or "bottom right" is passed in. Convert to percentages.

            if (cache.svg) {
              _applySVGOrigin(target, endValue, 0, smooth, 0, this);
            } else {
              endUnit = parseFloat(endValue.split(" ")[2]) || 0; //handle the zOrigin separately!

              endUnit !== cache.zOrigin && _addNonTweeningPT(this, cache, "zOrigin", cache.zOrigin, endUnit);

              _addNonTweeningPT(this, style, p, _firstTwoOnly(startValue), _firstTwoOnly(endValue));
            }

            continue;
          } else if (p === "svgOrigin") {
            _applySVGOrigin(target, endValue, 1, smooth, 0, this);

            continue;
          } else if (p in _rotationalProperties) {
            _addRotationalPropTween(this, cache, p, startNum, relative ? _parseRelative(startNum, relative + endValue) : endValue);

            continue;
          } else if (p === "smoothOrigin") {
            _addNonTweeningPT(this, cache, "smooth", cache.smooth, endValue);

            continue;
          } else if (p === "force3D") {
            cache[p] = endValue;
            continue;
          } else if (p === "transform") {
            _addRawTransformPTs(this, endValue, target);

            continue;
          }
        } else if (!(p in style)) {
          p = _checkPropPrefix(p) || p;
        }

        if (isTransformRelated || (endNum || endNum === 0) && (startNum || startNum === 0) && !_complexExp.test(endValue) && p in style) {
          startUnit = (startValue + "").substr((startNum + "").length);
          endNum || (endNum = 0); // protect against NaN

          endUnit = getUnit(endValue) || (p in _config.units ? _config.units[p] : startUnit);
          startUnit !== endUnit && (startNum = _convertToUnit(target, p, startValue, endUnit));
          this._pt = new PropTween(this._pt, isTransformRelated ? cache : style, p, startNum, (relative ? _parseRelative(startNum, relative + endNum) : endNum) - startNum, !isTransformRelated && (endUnit === "px" || p === "zIndex") && vars.autoRound !== false ? _renderRoundedCSSProp : _renderCSSProp);
          this._pt.u = endUnit || 0;

          if (startUnit !== endUnit && endUnit !== "%") {
            //when the tween goes all the way back to the beginning, we need to revert it to the OLD/ORIGINAL value (with those units). We record that as a "b" (beginning) property and point to a render method that handles that. (performance optimization)
            this._pt.b = startValue;
            this._pt.r = _renderCSSPropWithBeginning;
          }
        } else if (!(p in style)) {
          if (p in target) {
            //maybe it's not a style - it could be a property added directly to an element in which case we'll try to animate that.
            this.add(target, p, startValue || target[p], relative ? relative + endValue : endValue, index, targets);
          } else {
            _missingPlugin(p, endValue);

            continue;
          }
        } else {
          _tweenComplexCSSString.call(this, target, p, startValue, relative ? relative + endValue : endValue);
        }

        props.push(p);
      }
    }

    hasPriority && _sortPropTweensByPriority(this);
  },
  get: _get,
  aliases: _propertyAliases,
  getSetter: function getSetter(target, property, plugin) {
    //returns a setter function that accepts target, property, value and applies it accordingly. Remember, properties like "x" aren't as simple as target.style.property = value because they've got to be applied to a proxy object and then merged into a transform string in a renderer.
    var p = _propertyAliases[property];
    p && p.indexOf(",") < 0 && (property = p);
    return property in _transformProps && property !== _transformOriginProp && (target._gsap.x || _get(target, "x")) ? plugin && _recentSetterPlugin === plugin ? property === "scale" ? _setterScale : _setterTransform : (_recentSetterPlugin = plugin || {}) && (property === "scale" ? _setterScaleWithRender : _setterTransformWithRender) : target.style && !_isUndefined(target.style[property]) ? _setterCSSStyle : ~property.indexOf("-") ? _setterCSSProp : _getSetter(target, property);
  },
  core: {
    _removeProperty: _removeProperty,
    _getMatrix: _getMatrix
  }
};
gsap.utils.checkPrefix = _checkPropPrefix;

(function (positionAndScale, rotation, others, aliases) {
  var all = _forEachName(positionAndScale + "," + rotation + "," + others, function (name) {
    _transformProps[name] = 1;
  });

  _forEachName(rotation, function (name) {
    _config.units[name] = "deg";
    _rotationalProperties[name] = 1;
  });

  _propertyAliases[all[13]] = positionAndScale + "," + rotation;

  _forEachName(aliases, function (name) {
    var split = name.split(":");
    _propertyAliases[split[1]] = all[split[0]];
  });
})("x,y,z,scale,scaleX,scaleY,xPercent,yPercent", "rotation,rotationX,rotationY,skewX,skewY", "transform,transformOrigin,svgOrigin,force3D,smoothOrigin,transformPerspective", "0:translateX,1:translateY,2:translateZ,8:rotate,8:rotationZ,8:rotateZ,9:rotateX,10:rotateY");

_forEachName("x,y,z,top,right,bottom,left,width,height,fontSize,padding,margin,perspective", function (name) {
  _config.units[name] = "px";
});

gsap.registerPlugin(CSSPlugin);

;// CONCATENATED MODULE: ./node_modules/gsap/index.js


var gsapWithCSS = gsap.registerPlugin(CSSPlugin) || gsap,
    // to protect from tree shaking
TweenMaxWithCSS = gsapWithCSS.core.Tween;


/***/ }),

/***/ 708:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "G9": () => (/* binding */ Matrix2D),
/* harmony export */   "M9": () => (/* binding */ getGlobalMatrix)
/* harmony export */ });
/* unused harmony exports _getDocScrollTop, _getDocScrollLeft, _setDoc, _isFixed, _getCTM */
/*!
 * matrix 3.10.4
 * https://greensock.com
 *
 * Copyright 2008-2022, GreenSock. All rights reserved.
 * Subject to the terms at https://greensock.com/standard-license or for
 * Club GreenSock members, the agreement issued with that membership.
 * @author: Jack Doyle, jack@greensock.com
*/

/* eslint-disable */
var _doc,
    _win,
    _docElement,
    _body,
    _divContainer,
    _svgContainer,
    _identityMatrix,
    _gEl,
    _transformProp = "transform",
    _transformOriginProp = _transformProp + "Origin",
    _hasOffsetBug,
    _setDoc = function _setDoc(element) {
  var doc = element.ownerDocument || element;

  if (!(_transformProp in element.style) && "msTransform" in element.style) {
    //to improve compatibility with old Microsoft browsers
    _transformProp = "msTransform";
    _transformOriginProp = _transformProp + "Origin";
  }

  while (doc.parentNode && (doc = doc.parentNode)) {}

  _win = window;
  _identityMatrix = new Matrix2D();

  if (doc) {
    _doc = doc;
    _docElement = doc.documentElement;
    _body = doc.body;
    _gEl = _doc.createElementNS("http://www.w3.org/2000/svg", "g"); // prevent any existing CSS from transforming it

    _gEl.style.transform = "none"; // now test for the offset reporting bug. Use feature detection instead of browser sniffing to make things more bulletproof and future-proof. Hopefully Safari will fix their bug soon but it's 2020 and it's still not fixed.

    var d1 = doc.createElement("div"),
        d2 = doc.createElement("div");

    _body.appendChild(d1);

    d1.appendChild(d2);
    d1.style.position = "static";
    d1.style[_transformProp] = "translate3d(0,0,1px)";
    _hasOffsetBug = d2.offsetParent !== d1;

    _body.removeChild(d1);
  }

  return doc;
},
    _forceNonZeroScale = function _forceNonZeroScale(e) {
  // walks up the element's ancestors and finds any that had their scale set to 0 via GSAP, and changes them to 0.0001 to ensure that measurements work. Firefox has a bug that causes it to incorrectly report getBoundingClientRect() when scale is 0.
  var a, cache;

  while (e && e !== _body) {
    cache = e._gsap;
    cache && cache.uncache && cache.get(e, "x"); // force re-parsing of transforms if necessary

    if (cache && !cache.scaleX && !cache.scaleY && cache.renderTransform) {
      cache.scaleX = cache.scaleY = 1e-4;
      cache.renderTransform(1, cache);
      a ? a.push(cache) : a = [cache];
    }

    e = e.parentNode;
  }

  return a;
},
    // possible future addition: pass an element to _forceDisplay() and it'll walk up all its ancestors and make sure anything with display: none is set to display: block, and if there's no parentNode, it'll add it to the body. It returns an Array that you can then feed to _revertDisplay() to have it revert all the changes it made.
// _forceDisplay = e => {
// 	let a = [],
// 		parent;
// 	while (e && e !== _body) {
// 		parent = e.parentNode;
// 		(_win.getComputedStyle(e).display === "none" || !parent) && a.push(e, e.style.display, parent) && (e.style.display = "block");
// 		parent || _body.appendChild(e);
// 		e = parent;
// 	}
// 	return a;
// },
// _revertDisplay = a => {
// 	for (let i = 0; i < a.length; i+=3) {
// 		a[i+1] ? (a[i].style.display = a[i+1]) : a[i].style.removeProperty("display");
// 		a[i+2] || a[i].parentNode.removeChild(a[i]);
// 	}
// },
_svgTemps = [],
    //we create 3 elements for SVG, and 3 for other DOM elements and cache them for performance reasons. They get nested in _divContainer and _svgContainer so that just one element is added to the DOM on each successive attempt. Again, performance is key.
_divTemps = [],
    _getDocScrollTop = function _getDocScrollTop() {
  return _win.pageYOffset || _doc.scrollTop || _docElement.scrollTop || _body.scrollTop || 0;
},
    _getDocScrollLeft = function _getDocScrollLeft() {
  return _win.pageXOffset || _doc.scrollLeft || _docElement.scrollLeft || _body.scrollLeft || 0;
},
    _svgOwner = function _svgOwner(element) {
  return element.ownerSVGElement || ((element.tagName + "").toLowerCase() === "svg" ? element : null);
},
    _isFixed = function _isFixed(element) {
  if (_win.getComputedStyle(element).position === "fixed") {
    return true;
  }

  element = element.parentNode;

  if (element && element.nodeType === 1) {
    // avoid document fragments which will throw an error.
    return _isFixed(element);
  }
},
    _createSibling = function _createSibling(element, i) {
  if (element.parentNode && (_doc || _setDoc(element))) {
    var svg = _svgOwner(element),
        ns = svg ? svg.getAttribute("xmlns") || "http://www.w3.org/2000/svg" : "http://www.w3.org/1999/xhtml",
        type = svg ? i ? "rect" : "g" : "div",
        x = i !== 2 ? 0 : 100,
        y = i === 3 ? 100 : 0,
        css = "position:absolute;display:block;pointer-events:none;margin:0;padding:0;",
        e = _doc.createElementNS ? _doc.createElementNS(ns.replace(/^https/, "http"), type) : _doc.createElement(type);

    if (i) {
      if (!svg) {
        if (!_divContainer) {
          _divContainer = _createSibling(element);
          _divContainer.style.cssText = css;
        }

        e.style.cssText = css + "width:0.1px;height:0.1px;top:" + y + "px;left:" + x + "px";

        _divContainer.appendChild(e);
      } else {
        _svgContainer || (_svgContainer = _createSibling(element));
        e.setAttribute("width", 0.01);
        e.setAttribute("height", 0.01);
        e.setAttribute("transform", "translate(" + x + "," + y + ")");

        _svgContainer.appendChild(e);
      }
    }

    return e;
  }

  throw "Need document and parent.";
},
    _consolidate = function _consolidate(m) {
  // replaces SVGTransformList.consolidate() because a bug in Firefox causes it to break pointer events. See https://greensock.com/forums/topic/23248-touch-is-not-working-on-draggable-in-firefox-windows-v324/?tab=comments#comment-109800
  var c = new Matrix2D(),
      i = 0;

  for (; i < m.numberOfItems; i++) {
    c.multiply(m.getItem(i).matrix);
  }

  return c;
},
    _getCTM = function _getCTM(svg) {
  var m = svg.getCTM(),
      transform;

  if (!m) {
    // Firefox returns null for getCTM() on root <svg> elements, so this is a workaround using a <g> that we temporarily append.
    transform = svg.style[_transformProp];
    svg.style[_transformProp] = "none"; // a bug in Firefox causes css transforms to contaminate the getCTM()

    svg.appendChild(_gEl);
    m = _gEl.getCTM();
    svg.removeChild(_gEl);
    transform ? svg.style[_transformProp] = transform : svg.style.removeProperty(_transformProp.replace(/([A-Z])/g, "-$1").toLowerCase());
  }

  return m || _identityMatrix.clone(); // Firefox will still return null if the <svg> has a width/height of 0 in the browser.
},
    _placeSiblings = function _placeSiblings(element, adjustGOffset) {
  var svg = _svgOwner(element),
      isRootSVG = element === svg,
      siblings = svg ? _svgTemps : _divTemps,
      parent = element.parentNode,
      container,
      m,
      b,
      x,
      y,
      cs;

  if (element === _win) {
    return element;
  }

  siblings.length || siblings.push(_createSibling(element, 1), _createSibling(element, 2), _createSibling(element, 3));
  container = svg ? _svgContainer : _divContainer;

  if (svg) {
    if (isRootSVG) {
      b = _getCTM(element);
      x = -b.e / b.a;
      y = -b.f / b.d;
      m = _identityMatrix;
    } else if (element.getBBox) {
      b = element.getBBox();
      m = element.transform ? element.transform.baseVal : {}; // IE11 doesn't follow the spec.

      m = !m.numberOfItems ? _identityMatrix : m.numberOfItems > 1 ? _consolidate(m) : m.getItem(0).matrix; // don't call m.consolidate().matrix because a bug in Firefox makes pointer events not work when consolidate() is called on the same tick as getBoundingClientRect()! See https://greensock.com/forums/topic/23248-touch-is-not-working-on-draggable-in-firefox-windows-v324/?tab=comments#comment-109800

      x = m.a * b.x + m.c * b.y;
      y = m.b * b.x + m.d * b.y;
    } else {
      // may be a <mask> which has no getBBox() so just use defaults instead of throwing errors.
      m = new Matrix2D();
      x = y = 0;
    }

    if (adjustGOffset && element.tagName.toLowerCase() === "g") {
      x = y = 0;
    }

    (isRootSVG ? svg : parent).appendChild(container);
    container.setAttribute("transform", "matrix(" + m.a + "," + m.b + "," + m.c + "," + m.d + "," + (m.e + x) + "," + (m.f + y) + ")");
  } else {
    x = y = 0;

    if (_hasOffsetBug) {
      // some browsers (like Safari) have a bug that causes them to misreport offset values. When an ancestor element has a transform applied, it's supposed to treat it as if it's position: relative (new context). Safari botches this, so we need to find the closest ancestor (between the element and its offsetParent) that has a transform applied and if one is found, grab its offsetTop/Left and subtract them to compensate.
      m = element.offsetParent;
      b = element;

      while (b && (b = b.parentNode) && b !== m && b.parentNode) {
        if ((_win.getComputedStyle(b)[_transformProp] + "").length > 4) {
          x = b.offsetLeft;
          y = b.offsetTop;
          b = 0;
        }
      }
    }

    cs = _win.getComputedStyle(element);

    if (cs.position !== "absolute" && cs.position !== "fixed") {
      m = element.offsetParent;

      while (parent && parent !== m) {
        // if there's an ancestor element between the element and its offsetParent that's scrolled, we must factor that in.
        x += parent.scrollLeft || 0;
        y += parent.scrollTop || 0;
        parent = parent.parentNode;
      }
    }

    b = container.style;
    b.top = element.offsetTop - y + "px";
    b.left = element.offsetLeft - x + "px";
    b[_transformProp] = cs[_transformProp];
    b[_transformOriginProp] = cs[_transformOriginProp]; // b.border = m.border;
    // b.borderLeftStyle = m.borderLeftStyle;
    // b.borderTopStyle = m.borderTopStyle;
    // b.borderLeftWidth = m.borderLeftWidth;
    // b.borderTopWidth = m.borderTopWidth;

    b.position = cs.position === "fixed" ? "fixed" : "absolute";
    element.parentNode.appendChild(container);
  }

  return container;
},
    _setMatrix = function _setMatrix(m, a, b, c, d, e, f) {
  m.a = a;
  m.b = b;
  m.c = c;
  m.d = d;
  m.e = e;
  m.f = f;
  return m;
};

var Matrix2D = /*#__PURE__*/function () {
  function Matrix2D(a, b, c, d, e, f) {
    if (a === void 0) {
      a = 1;
    }

    if (b === void 0) {
      b = 0;
    }

    if (c === void 0) {
      c = 0;
    }

    if (d === void 0) {
      d = 1;
    }

    if (e === void 0) {
      e = 0;
    }

    if (f === void 0) {
      f = 0;
    }

    _setMatrix(this, a, b, c, d, e, f);
  }

  var _proto = Matrix2D.prototype;

  _proto.inverse = function inverse() {
    var a = this.a,
        b = this.b,
        c = this.c,
        d = this.d,
        e = this.e,
        f = this.f,
        determinant = a * d - b * c || 1e-10;
    return _setMatrix(this, d / determinant, -b / determinant, -c / determinant, a / determinant, (c * f - d * e) / determinant, -(a * f - b * e) / determinant);
  };

  _proto.multiply = function multiply(matrix) {
    var a = this.a,
        b = this.b,
        c = this.c,
        d = this.d,
        e = this.e,
        f = this.f,
        a2 = matrix.a,
        b2 = matrix.c,
        c2 = matrix.b,
        d2 = matrix.d,
        e2 = matrix.e,
        f2 = matrix.f;
    return _setMatrix(this, a2 * a + c2 * c, a2 * b + c2 * d, b2 * a + d2 * c, b2 * b + d2 * d, e + e2 * a + f2 * c, f + e2 * b + f2 * d);
  };

  _proto.clone = function clone() {
    return new Matrix2D(this.a, this.b, this.c, this.d, this.e, this.f);
  };

  _proto.equals = function equals(matrix) {
    var a = this.a,
        b = this.b,
        c = this.c,
        d = this.d,
        e = this.e,
        f = this.f;
    return a === matrix.a && b === matrix.b && c === matrix.c && d === matrix.d && e === matrix.e && f === matrix.f;
  };

  _proto.apply = function apply(point, decoratee) {
    if (decoratee === void 0) {
      decoratee = {};
    }

    var x = point.x,
        y = point.y,
        a = this.a,
        b = this.b,
        c = this.c,
        d = this.d,
        e = this.e,
        f = this.f;
    decoratee.x = x * a + y * c + e || 0;
    decoratee.y = x * b + y * d + f || 0;
    return decoratee;
  };

  return Matrix2D;
}(); // Feed in an element and it'll return a 2D matrix (optionally inverted) so that you can translate between coordinate spaces.
// Inverting lets you translate a global point into a local coordinate space. No inverting lets you go the other way.
// We needed this to work around various browser bugs, like Firefox doesn't accurately report getScreenCTM() when there
// are transforms applied to ancestor elements.
// The matrix math to convert any x/y coordinate is as follows, which is wrapped in a convenient apply() method of Matrix2D above:
//     tx = m.a * x + m.c * y + m.e
//     ty = m.b * x + m.d * y + m.f

function getGlobalMatrix(element, inverse, adjustGOffset, includeScrollInFixed) {
  // adjustGOffset is typically used only when grabbing an element's PARENT's global matrix, and it ignores the x/y offset of any SVG <g> elements because they behave in a special way.
  if (!element || !element.parentNode || (_doc || _setDoc(element)).documentElement === element) {
    return new Matrix2D();
  }

  var zeroScales = _forceNonZeroScale(element),
      svg = _svgOwner(element),
      temps = svg ? _svgTemps : _divTemps,
      container = _placeSiblings(element, adjustGOffset),
      b1 = temps[0].getBoundingClientRect(),
      b2 = temps[1].getBoundingClientRect(),
      b3 = temps[2].getBoundingClientRect(),
      parent = container.parentNode,
      isFixed = !includeScrollInFixed && _isFixed(element),
      m = new Matrix2D((b2.left - b1.left) / 100, (b2.top - b1.top) / 100, (b3.left - b1.left) / 100, (b3.top - b1.top) / 100, b1.left + (isFixed ? 0 : _getDocScrollLeft()), b1.top + (isFixed ? 0 : _getDocScrollTop()));

  parent.removeChild(container);

  if (zeroScales) {
    b1 = zeroScales.length;

    while (b1--) {
      b2 = zeroScales[b1];
      b2.scaleX = b2.scaleY = 0;
      b2.renderTransform(1, b2);
    }
  }

  return inverse ? m.inverse() : m;
}
 // export function getMatrix(element) {
// 	_doc || _setDoc(element);
// 	let m = (_win.getComputedStyle(element)[_transformProp] + "").substr(7).match(/[-.]*\d+[.e\-+]*\d*[e\-\+]*\d*/g),
// 		is2D = m && m.length === 6;
// 	return !m || m.length < 6 ? new Matrix2D() : new Matrix2D(+m[0], +m[1], +m[is2D ? 2 : 4], +m[is2D ? 3 : 5], +m[is2D ? 4 : 12], +m[is2D ? 5 : 13]);
// }

/***/ }),

/***/ 549:
/***/ (function(module, exports, __webpack_require__) {

/* module decorator */ module = __webpack_require__.nmd(module);
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

/*!
 * jQuery JavaScript Library v3.6.0
 * https://jquery.com/
 *
 * Includes Sizzle.js
 * https://sizzlejs.com/
 *
 * Copyright OpenJS Foundation and other contributors
 * Released under the MIT license
 * https://jquery.org/license
 *
 * Date: 2021-03-02T17:08Z
 */
(function (global, factory) {
  "use strict";

  if (( false ? 0 : _typeof(module)) === "object" && _typeof(module.exports) === "object") {
    // For CommonJS and CommonJS-like environments where a proper `window`
    // is present, execute the factory and get jQuery.
    // For environments that do not have a `window` with a `document`
    // (such as Node.js), expose a factory as module.exports.
    // This accentuates the need for the creation of a real `window`.
    // e.g. var jQuery = require("jquery")(window);
    // See ticket #14549 for more info.
    module.exports = global.document ? factory(global, true) : function (w) {
      if (!w.document) {
        throw new Error("jQuery requires a window with a document");
      }

      return factory(w);
    };
  } else {
    factory(global);
  } // Pass this if window is not defined yet

})(typeof window !== "undefined" ? window : this, function (window, noGlobal) {
  // Edge <= 12 - 13+, Firefox <=18 - 45+, IE 10 - 11, Safari 5.1 - 9+, iOS 6 - 9.1
  // throw exceptions when non-strict code (e.g., ASP.NET 4.5) accesses strict mode
  // arguments.callee.caller (trac-13335). But as of jQuery 3.0 (2016), strict mode should be common
  // enough that all such attempts are guarded in a try block.
  "use strict";

  var arr = [];
  var getProto = Object.getPrototypeOf;
  var _slice = arr.slice;
  var flat = arr.flat ? function (array) {
    return arr.flat.call(array);
  } : function (array) {
    return arr.concat.apply([], array);
  };
  var push = arr.push;
  var indexOf = arr.indexOf;
  var class2type = {};
  var toString = class2type.toString;
  var hasOwn = class2type.hasOwnProperty;
  var fnToString = hasOwn.toString;
  var ObjectFunctionString = fnToString.call(Object);
  var support = {};

  var isFunction = function isFunction(obj) {
    // Support: Chrome <=57, Firefox <=52
    // In some browsers, typeof returns "function" for HTML <object> elements
    // (i.e., `typeof document.createElement( "object" ) === "function"`).
    // We don't want to classify *any* DOM node as a function.
    // Support: QtWeb <=3.8.5, WebKit <=534.34, wkhtmltopdf tool <=0.12.5
    // Plus for old WebKit, typeof returns "function" for HTML collections
    // (e.g., `typeof document.getElementsByTagName("div") === "function"`). (gh-4756)
    return typeof obj === "function" && typeof obj.nodeType !== "number" && typeof obj.item !== "function";
  };

  var isWindow = function isWindow(obj) {
    return obj != null && obj === obj.window;
  };

  var document = window.document;
  var preservedScriptAttributes = {
    type: true,
    src: true,
    nonce: true,
    noModule: true
  };

  function DOMEval(code, node, doc) {
    doc = doc || document;
    var i,
        val,
        script = doc.createElement("script");
    script.text = code;

    if (node) {
      for (i in preservedScriptAttributes) {
        // Support: Firefox 64+, Edge 18+
        // Some browsers don't support the "nonce" property on scripts.
        // On the other hand, just using `getAttribute` is not enough as
        // the `nonce` attribute is reset to an empty string whenever it
        // becomes browsing-context connected.
        // See https://github.com/whatwg/html/issues/2369
        // See https://html.spec.whatwg.org/#nonce-attributes
        // The `node.getAttribute` check was added for the sake of
        // `jQuery.globalEval` so that it can fake a nonce-containing node
        // via an object.
        val = node[i] || node.getAttribute && node.getAttribute(i);

        if (val) {
          script.setAttribute(i, val);
        }
      }
    }

    doc.head.appendChild(script).parentNode.removeChild(script);
  }

  function toType(obj) {
    if (obj == null) {
      return obj + "";
    } // Support: Android <=2.3 only (functionish RegExp)


    return _typeof(obj) === "object" || typeof obj === "function" ? class2type[toString.call(obj)] || "object" : _typeof(obj);
  }
  /* global Symbol */
  // Defining this global in .eslintrc.json would create a danger of using the global
  // unguarded in another place, it seems safer to define global only for this module


  var version = "3.6.0",
      // Define a local copy of jQuery
  jQuery = function jQuery(selector, context) {
    // The jQuery object is actually just the init constructor 'enhanced'
    // Need init if jQuery is called (just allow error to be thrown if not included)
    return new jQuery.fn.init(selector, context);
  };

  jQuery.fn = jQuery.prototype = {
    // The current version of jQuery being used
    jquery: version,
    constructor: jQuery,
    // The default length of a jQuery object is 0
    length: 0,
    toArray: function toArray() {
      return _slice.call(this);
    },
    // Get the Nth element in the matched element set OR
    // Get the whole matched element set as a clean array
    get: function get(num) {
      // Return all the elements in a clean array
      if (num == null) {
        return _slice.call(this);
      } // Return just the one element from the set


      return num < 0 ? this[num + this.length] : this[num];
    },
    // Take an array of elements and push it onto the stack
    // (returning the new matched element set)
    pushStack: function pushStack(elems) {
      // Build a new jQuery matched element set
      var ret = jQuery.merge(this.constructor(), elems); // Add the old object onto the stack (as a reference)

      ret.prevObject = this; // Return the newly-formed element set

      return ret;
    },
    // Execute a callback for every element in the matched set.
    each: function each(callback) {
      return jQuery.each(this, callback);
    },
    map: function map(callback) {
      return this.pushStack(jQuery.map(this, function (elem, i) {
        return callback.call(elem, i, elem);
      }));
    },
    slice: function slice() {
      return this.pushStack(_slice.apply(this, arguments));
    },
    first: function first() {
      return this.eq(0);
    },
    last: function last() {
      return this.eq(-1);
    },
    even: function even() {
      return this.pushStack(jQuery.grep(this, function (_elem, i) {
        return (i + 1) % 2;
      }));
    },
    odd: function odd() {
      return this.pushStack(jQuery.grep(this, function (_elem, i) {
        return i % 2;
      }));
    },
    eq: function eq(i) {
      var len = this.length,
          j = +i + (i < 0 ? len : 0);
      return this.pushStack(j >= 0 && j < len ? [this[j]] : []);
    },
    end: function end() {
      return this.prevObject || this.constructor();
    },
    // For internal use only.
    // Behaves like an Array's method, not like a jQuery method.
    push: push,
    sort: arr.sort,
    splice: arr.splice
  };

  jQuery.extend = jQuery.fn.extend = function () {
    var options,
        name,
        src,
        copy,
        copyIsArray,
        clone,
        target = arguments[0] || {},
        i = 1,
        length = arguments.length,
        deep = false; // Handle a deep copy situation

    if (typeof target === "boolean") {
      deep = target; // Skip the boolean and the target

      target = arguments[i] || {};
      i++;
    } // Handle case when target is a string or something (possible in deep copy)


    if (_typeof(target) !== "object" && !isFunction(target)) {
      target = {};
    } // Extend jQuery itself if only one argument is passed


    if (i === length) {
      target = this;
      i--;
    }

    for (; i < length; i++) {
      // Only deal with non-null/undefined values
      if ((options = arguments[i]) != null) {
        // Extend the base object
        for (name in options) {
          copy = options[name]; // Prevent Object.prototype pollution
          // Prevent never-ending loop

          if (name === "__proto__" || target === copy) {
            continue;
          } // Recurse if we're merging plain objects or arrays


          if (deep && copy && (jQuery.isPlainObject(copy) || (copyIsArray = Array.isArray(copy)))) {
            src = target[name]; // Ensure proper type for the source value

            if (copyIsArray && !Array.isArray(src)) {
              clone = [];
            } else if (!copyIsArray && !jQuery.isPlainObject(src)) {
              clone = {};
            } else {
              clone = src;
            }

            copyIsArray = false; // Never move original objects, clone them

            target[name] = jQuery.extend(deep, clone, copy); // Don't bring in undefined values
          } else if (copy !== undefined) {
            target[name] = copy;
          }
        }
      }
    } // Return the modified object


    return target;
  };

  jQuery.extend({
    // Unique for each copy of jQuery on the page
    expando: "jQuery" + (version + Math.random()).replace(/\D/g, ""),
    // Assume jQuery is ready without the ready module
    isReady: true,
    error: function error(msg) {
      throw new Error(msg);
    },
    noop: function noop() {},
    isPlainObject: function isPlainObject(obj) {
      var proto, Ctor; // Detect obvious negatives
      // Use toString instead of jQuery.type to catch host objects

      if (!obj || toString.call(obj) !== "[object Object]") {
        return false;
      }

      proto = getProto(obj); // Objects with no prototype (e.g., `Object.create( null )`) are plain

      if (!proto) {
        return true;
      } // Objects with prototype are plain iff they were constructed by a global Object function


      Ctor = hasOwn.call(proto, "constructor") && proto.constructor;
      return typeof Ctor === "function" && fnToString.call(Ctor) === ObjectFunctionString;
    },
    isEmptyObject: function isEmptyObject(obj) {
      var name;

      for (name in obj) {
        return false;
      }

      return true;
    },
    // Evaluates a script in a provided context; falls back to the global one
    // if not specified.
    globalEval: function globalEval(code, options, doc) {
      DOMEval(code, {
        nonce: options && options.nonce
      }, doc);
    },
    each: function each(obj, callback) {
      var length,
          i = 0;

      if (isArrayLike(obj)) {
        length = obj.length;

        for (; i < length; i++) {
          if (callback.call(obj[i], i, obj[i]) === false) {
            break;
          }
        }
      } else {
        for (i in obj) {
          if (callback.call(obj[i], i, obj[i]) === false) {
            break;
          }
        }
      }

      return obj;
    },
    // results is for internal usage only
    makeArray: function makeArray(arr, results) {
      var ret = results || [];

      if (arr != null) {
        if (isArrayLike(Object(arr))) {
          jQuery.merge(ret, typeof arr === "string" ? [arr] : arr);
        } else {
          push.call(ret, arr);
        }
      }

      return ret;
    },
    inArray: function inArray(elem, arr, i) {
      return arr == null ? -1 : indexOf.call(arr, elem, i);
    },
    // Support: Android <=4.0 only, PhantomJS 1 only
    // push.apply(_, arraylike) throws on ancient WebKit
    merge: function merge(first, second) {
      var len = +second.length,
          j = 0,
          i = first.length;

      for (; j < len; j++) {
        first[i++] = second[j];
      }

      first.length = i;
      return first;
    },
    grep: function grep(elems, callback, invert) {
      var callbackInverse,
          matches = [],
          i = 0,
          length = elems.length,
          callbackExpect = !invert; // Go through the array, only saving the items
      // that pass the validator function

      for (; i < length; i++) {
        callbackInverse = !callback(elems[i], i);

        if (callbackInverse !== callbackExpect) {
          matches.push(elems[i]);
        }
      }

      return matches;
    },
    // arg is for internal usage only
    map: function map(elems, callback, arg) {
      var length,
          value,
          i = 0,
          ret = []; // Go through the array, translating each of the items to their new values

      if (isArrayLike(elems)) {
        length = elems.length;

        for (; i < length; i++) {
          value = callback(elems[i], i, arg);

          if (value != null) {
            ret.push(value);
          }
        } // Go through every key on the object,

      } else {
        for (i in elems) {
          value = callback(elems[i], i, arg);

          if (value != null) {
            ret.push(value);
          }
        }
      } // Flatten any nested arrays


      return flat(ret);
    },
    // A global GUID counter for objects
    guid: 1,
    // jQuery.support is not used in Core but other projects attach their
    // properties to it so it needs to exist.
    support: support
  });

  if (typeof Symbol === "function") {
    jQuery.fn[Symbol.iterator] = arr[Symbol.iterator];
  } // Populate the class2type map


  jQuery.each("Boolean Number String Function Array Date RegExp Object Error Symbol".split(" "), function (_i, name) {
    class2type["[object " + name + "]"] = name.toLowerCase();
  });

  function isArrayLike(obj) {
    // Support: real iOS 8.2 only (not reproducible in simulator)
    // `in` check used to prevent JIT error (gh-2145)
    // hasOwn isn't used here due to false negatives
    // regarding Nodelist length in IE
    var length = !!obj && "length" in obj && obj.length,
        type = toType(obj);

    if (isFunction(obj) || isWindow(obj)) {
      return false;
    }

    return type === "array" || length === 0 || typeof length === "number" && length > 0 && length - 1 in obj;
  }

  var Sizzle =
  /*!
   * Sizzle CSS Selector Engine v2.3.6
   * https://sizzlejs.com/
   *
   * Copyright JS Foundation and other contributors
   * Released under the MIT license
   * https://js.foundation/
   *
   * Date: 2021-02-16
   */
  function (window) {
    var i,
        support,
        Expr,
        getText,
        isXML,
        tokenize,
        compile,
        select,
        outermostContext,
        sortInput,
        hasDuplicate,
        // Local document vars
    setDocument,
        document,
        docElem,
        documentIsHTML,
        rbuggyQSA,
        rbuggyMatches,
        matches,
        contains,
        // Instance-specific data
    expando = "sizzle" + 1 * new Date(),
        preferredDoc = window.document,
        dirruns = 0,
        done = 0,
        classCache = createCache(),
        tokenCache = createCache(),
        compilerCache = createCache(),
        nonnativeSelectorCache = createCache(),
        sortOrder = function sortOrder(a, b) {
      if (a === b) {
        hasDuplicate = true;
      }

      return 0;
    },
        // Instance methods
    hasOwn = {}.hasOwnProperty,
        arr = [],
        pop = arr.pop,
        pushNative = arr.push,
        push = arr.push,
        slice = arr.slice,
        // Use a stripped-down indexOf as it's faster than native
    // https://jsperf.com/thor-indexof-vs-for/5
    indexOf = function indexOf(list, elem) {
      var i = 0,
          len = list.length;

      for (; i < len; i++) {
        if (list[i] === elem) {
          return i;
        }
      }

      return -1;
    },
        booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|" + "ismap|loop|multiple|open|readonly|required|scoped",
        // Regular expressions
    // http://www.w3.org/TR/css3-selectors/#whitespace
    whitespace = "[\\x20\\t\\r\\n\\f]",
        // https://www.w3.org/TR/css-syntax-3/#ident-token-diagram
    identifier = "(?:\\\\[\\da-fA-F]{1,6}" + whitespace + "?|\\\\[^\\r\\n\\f]|[\\w-]|[^\0-\\x7f])+",
        // Attribute selectors: http://www.w3.org/TR/selectors/#attribute-selectors
    attributes = "\\[" + whitespace + "*(" + identifier + ")(?:" + whitespace + // Operator (capture 2)
    "*([*^$|!~]?=)" + whitespace + // "Attribute values must be CSS identifiers [capture 5]
    // or strings [capture 3 or capture 4]"
    "*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + identifier + "))|)" + whitespace + "*\\]",
        pseudos = ":(" + identifier + ")(?:\\((" + // To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:
    // 1. quoted (capture 3; capture 4 or capture 5)
    "('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|" + // 2. simple (capture 6)
    "((?:\\\\.|[^\\\\()[\\]]|" + attributes + ")*)|" + // 3. anything else (capture 2)
    ".*" + ")\\)|)",
        // Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter
    rwhitespace = new RegExp(whitespace + "+", "g"),
        rtrim = new RegExp("^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$", "g"),
        rcomma = new RegExp("^" + whitespace + "*," + whitespace + "*"),
        rcombinators = new RegExp("^" + whitespace + "*([>+~]|" + whitespace + ")" + whitespace + "*"),
        rdescend = new RegExp(whitespace + "|>"),
        rpseudo = new RegExp(pseudos),
        ridentifier = new RegExp("^" + identifier + "$"),
        matchExpr = {
      "ID": new RegExp("^#(" + identifier + ")"),
      "CLASS": new RegExp("^\\.(" + identifier + ")"),
      "TAG": new RegExp("^(" + identifier + "|[*])"),
      "ATTR": new RegExp("^" + attributes),
      "PSEUDO": new RegExp("^" + pseudos),
      "CHILD": new RegExp("^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + whitespace + "*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" + whitespace + "*(\\d+)|))" + whitespace + "*\\)|)", "i"),
      "bool": new RegExp("^(?:" + booleans + ")$", "i"),
      // For use in libraries implementing .is()
      // We use this for POS matching in `select`
      "needsContext": new RegExp("^" + whitespace + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" + whitespace + "*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)", "i")
    },
        rhtml = /HTML$/i,
        rinputs = /^(?:input|select|textarea|button)$/i,
        rheader = /^h\d$/i,
        rnative = /^[^{]+\{\s*\[native \w/,
        // Easily-parseable/retrievable ID or TAG or CLASS selectors
    rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,
        rsibling = /[+~]/,
        // CSS escapes
    // http://www.w3.org/TR/CSS21/syndata.html#escaped-characters
    runescape = new RegExp("\\\\[\\da-fA-F]{1,6}" + whitespace + "?|\\\\([^\\r\\n\\f])", "g"),
        funescape = function funescape(escape, nonHex) {
      var high = "0x" + escape.slice(1) - 0x10000;
      return nonHex ? // Strip the backslash prefix from a non-hex escape sequence
      nonHex : // Replace a hexadecimal escape sequence with the encoded Unicode code point
      // Support: IE <=11+
      // For values outside the Basic Multilingual Plane (BMP), manually construct a
      // surrogate pair
      high < 0 ? String.fromCharCode(high + 0x10000) : String.fromCharCode(high >> 10 | 0xD800, high & 0x3FF | 0xDC00);
    },
        // CSS string/identifier serialization
    // https://drafts.csswg.org/cssom/#common-serializing-idioms
    rcssescape = /([\0-\x1f\x7f]|^-?\d)|^-$|[^\0-\x1f\x7f-\uFFFF\w-]/g,
        fcssescape = function fcssescape(ch, asCodePoint) {
      if (asCodePoint) {
        // U+0000 NULL becomes U+FFFD REPLACEMENT CHARACTER
        if (ch === "\0") {
          return "\uFFFD";
        } // Control characters and (dependent upon position) numbers get escaped as code points


        return ch.slice(0, -1) + "\\" + ch.charCodeAt(ch.length - 1).toString(16) + " ";
      } // Other potentially-special ASCII characters get backslash-escaped


      return "\\" + ch;
    },
        // Used for iframes
    // See setDocument()
    // Removing the function wrapper causes a "Permission Denied"
    // error in IE
    unloadHandler = function unloadHandler() {
      setDocument();
    },
        inDisabledFieldset = addCombinator(function (elem) {
      return elem.disabled === true && elem.nodeName.toLowerCase() === "fieldset";
    }, {
      dir: "parentNode",
      next: "legend"
    }); // Optimize for push.apply( _, NodeList )


    try {
      push.apply(arr = slice.call(preferredDoc.childNodes), preferredDoc.childNodes); // Support: Android<4.0
      // Detect silently failing push.apply
      // eslint-disable-next-line no-unused-expressions

      arr[preferredDoc.childNodes.length].nodeType;
    } catch (e) {
      push = {
        apply: arr.length ? // Leverage slice if possible
        function (target, els) {
          pushNative.apply(target, slice.call(els));
        } : // Support: IE<9
        // Otherwise append directly
        function (target, els) {
          var j = target.length,
              i = 0; // Can't trust NodeList.length

          while (target[j++] = els[i++]) {}

          target.length = j - 1;
        }
      };
    }

    function Sizzle(selector, context, results, seed) {
      var m,
          i,
          elem,
          nid,
          match,
          groups,
          newSelector,
          newContext = context && context.ownerDocument,
          // nodeType defaults to 9, since context defaults to document
      nodeType = context ? context.nodeType : 9;
      results = results || []; // Return early from calls with invalid selector or context

      if (typeof selector !== "string" || !selector || nodeType !== 1 && nodeType !== 9 && nodeType !== 11) {
        return results;
      } // Try to shortcut find operations (as opposed to filters) in HTML documents


      if (!seed) {
        setDocument(context);
        context = context || document;

        if (documentIsHTML) {
          // If the selector is sufficiently simple, try using a "get*By*" DOM method
          // (excepting DocumentFragment context, where the methods don't exist)
          if (nodeType !== 11 && (match = rquickExpr.exec(selector))) {
            // ID selector
            if (m = match[1]) {
              // Document context
              if (nodeType === 9) {
                if (elem = context.getElementById(m)) {
                  // Support: IE, Opera, Webkit
                  // TODO: identify versions
                  // getElementById can match elements by name instead of ID
                  if (elem.id === m) {
                    results.push(elem);
                    return results;
                  }
                } else {
                  return results;
                } // Element context

              } else {
                // Support: IE, Opera, Webkit
                // TODO: identify versions
                // getElementById can match elements by name instead of ID
                if (newContext && (elem = newContext.getElementById(m)) && contains(context, elem) && elem.id === m) {
                  results.push(elem);
                  return results;
                }
              } // Type selector

            } else if (match[2]) {
              push.apply(results, context.getElementsByTagName(selector));
              return results; // Class selector
            } else if ((m = match[3]) && support.getElementsByClassName && context.getElementsByClassName) {
              push.apply(results, context.getElementsByClassName(m));
              return results;
            }
          } // Take advantage of querySelectorAll


          if (support.qsa && !nonnativeSelectorCache[selector + " "] && (!rbuggyQSA || !rbuggyQSA.test(selector)) && ( // Support: IE 8 only
          // Exclude object elements
          nodeType !== 1 || context.nodeName.toLowerCase() !== "object")) {
            newSelector = selector;
            newContext = context; // qSA considers elements outside a scoping root when evaluating child or
            // descendant combinators, which is not what we want.
            // In such cases, we work around the behavior by prefixing every selector in the
            // list with an ID selector referencing the scope context.
            // The technique has to be used as well when a leading combinator is used
            // as such selectors are not recognized by querySelectorAll.
            // Thanks to Andrew Dupont for this technique.

            if (nodeType === 1 && (rdescend.test(selector) || rcombinators.test(selector))) {
              // Expand context for sibling selectors
              newContext = rsibling.test(selector) && testContext(context.parentNode) || context; // We can use :scope instead of the ID hack if the browser
              // supports it & if we're not changing the context.

              if (newContext !== context || !support.scope) {
                // Capture the context ID, setting it first if necessary
                if (nid = context.getAttribute("id")) {
                  nid = nid.replace(rcssescape, fcssescape);
                } else {
                  context.setAttribute("id", nid = expando);
                }
              } // Prefix every selector in the list


              groups = tokenize(selector);
              i = groups.length;

              while (i--) {
                groups[i] = (nid ? "#" + nid : ":scope") + " " + toSelector(groups[i]);
              }

              newSelector = groups.join(",");
            }

            try {
              push.apply(results, newContext.querySelectorAll(newSelector));
              return results;
            } catch (qsaError) {
              nonnativeSelectorCache(selector, true);
            } finally {
              if (nid === expando) {
                context.removeAttribute("id");
              }
            }
          }
        }
      } // All others


      return select(selector.replace(rtrim, "$1"), context, results, seed);
    }
    /**
     * Create key-value caches of limited size
     * @returns {function(string, object)} Returns the Object data after storing it on itself with
     *	property name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)
     *	deleting the oldest entry
     */


    function createCache() {
      var keys = [];

      function cache(key, value) {
        // Use (key + " ") to avoid collision with native prototype properties (see Issue #157)
        if (keys.push(key + " ") > Expr.cacheLength) {
          // Only keep the most recent entries
          delete cache[keys.shift()];
        }

        return cache[key + " "] = value;
      }

      return cache;
    }
    /**
     * Mark a function for special use by Sizzle
     * @param {Function} fn The function to mark
     */


    function markFunction(fn) {
      fn[expando] = true;
      return fn;
    }
    /**
     * Support testing using an element
     * @param {Function} fn Passed the created element and returns a boolean result
     */


    function assert(fn) {
      var el = document.createElement("fieldset");

      try {
        return !!fn(el);
      } catch (e) {
        return false;
      } finally {
        // Remove from its parent by default
        if (el.parentNode) {
          el.parentNode.removeChild(el);
        } // release memory in IE


        el = null;
      }
    }
    /**
     * Adds the same handler for all of the specified attrs
     * @param {String} attrs Pipe-separated list of attributes
     * @param {Function} handler The method that will be applied
     */


    function addHandle(attrs, handler) {
      var arr = attrs.split("|"),
          i = arr.length;

      while (i--) {
        Expr.attrHandle[arr[i]] = handler;
      }
    }
    /**
     * Checks document order of two siblings
     * @param {Element} a
     * @param {Element} b
     * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b
     */


    function siblingCheck(a, b) {
      var cur = b && a,
          diff = cur && a.nodeType === 1 && b.nodeType === 1 && a.sourceIndex - b.sourceIndex; // Use IE sourceIndex if available on both nodes

      if (diff) {
        return diff;
      } // Check if b follows a


      if (cur) {
        while (cur = cur.nextSibling) {
          if (cur === b) {
            return -1;
          }
        }
      }

      return a ? 1 : -1;
    }
    /**
     * Returns a function to use in pseudos for input types
     * @param {String} type
     */


    function createInputPseudo(type) {
      return function (elem) {
        var name = elem.nodeName.toLowerCase();
        return name === "input" && elem.type === type;
      };
    }
    /**
     * Returns a function to use in pseudos for buttons
     * @param {String} type
     */


    function createButtonPseudo(type) {
      return function (elem) {
        var name = elem.nodeName.toLowerCase();
        return (name === "input" || name === "button") && elem.type === type;
      };
    }
    /**
     * Returns a function to use in pseudos for :enabled/:disabled
     * @param {Boolean} disabled true for :disabled; false for :enabled
     */


    function createDisabledPseudo(disabled) {
      // Known :disabled false positives: fieldset[disabled] > legend:nth-of-type(n+2) :can-disable
      return function (elem) {
        // Only certain elements can match :enabled or :disabled
        // https://html.spec.whatwg.org/multipage/scripting.html#selector-enabled
        // https://html.spec.whatwg.org/multipage/scripting.html#selector-disabled
        if ("form" in elem) {
          // Check for inherited disabledness on relevant non-disabled elements:
          // * listed form-associated elements in a disabled fieldset
          //   https://html.spec.whatwg.org/multipage/forms.html#category-listed
          //   https://html.spec.whatwg.org/multipage/forms.html#concept-fe-disabled
          // * option elements in a disabled optgroup
          //   https://html.spec.whatwg.org/multipage/forms.html#concept-option-disabled
          // All such elements have a "form" property.
          if (elem.parentNode && elem.disabled === false) {
            // Option elements defer to a parent optgroup if present
            if ("label" in elem) {
              if ("label" in elem.parentNode) {
                return elem.parentNode.disabled === disabled;
              } else {
                return elem.disabled === disabled;
              }
            } // Support: IE 6 - 11
            // Use the isDisabled shortcut property to check for disabled fieldset ancestors


            return elem.isDisabled === disabled || // Where there is no isDisabled, check manually

            /* jshint -W018 */
            elem.isDisabled !== !disabled && inDisabledFieldset(elem) === disabled;
          }

          return elem.disabled === disabled; // Try to winnow out elements that can't be disabled before trusting the disabled property.
          // Some victims get caught in our net (label, legend, menu, track), but it shouldn't
          // even exist on them, let alone have a boolean value.
        } else if ("label" in elem) {
          return elem.disabled === disabled;
        } // Remaining elements are neither :enabled nor :disabled


        return false;
      };
    }
    /**
     * Returns a function to use in pseudos for positionals
     * @param {Function} fn
     */


    function createPositionalPseudo(fn) {
      return markFunction(function (argument) {
        argument = +argument;
        return markFunction(function (seed, matches) {
          var j,
              matchIndexes = fn([], seed.length, argument),
              i = matchIndexes.length; // Match elements found at the specified indexes

          while (i--) {
            if (seed[j = matchIndexes[i]]) {
              seed[j] = !(matches[j] = seed[j]);
            }
          }
        });
      });
    }
    /**
     * Checks a node for validity as a Sizzle context
     * @param {Element|Object=} context
     * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value
     */


    function testContext(context) {
      return context && typeof context.getElementsByTagName !== "undefined" && context;
    } // Expose support vars for convenience


    support = Sizzle.support = {};
    /**
     * Detects XML nodes
     * @param {Element|Object} elem An element or a document
     * @returns {Boolean} True iff elem is a non-HTML XML node
     */

    isXML = Sizzle.isXML = function (elem) {
      var namespace = elem && elem.namespaceURI,
          docElem = elem && (elem.ownerDocument || elem).documentElement; // Support: IE <=8
      // Assume HTML when documentElement doesn't yet exist, such as inside loading iframes
      // https://bugs.jquery.com/ticket/4833

      return !rhtml.test(namespace || docElem && docElem.nodeName || "HTML");
    };
    /**
     * Sets document-related variables once based on the current document
     * @param {Element|Object} [doc] An element or document object to use to set the document
     * @returns {Object} Returns the current document
     */


    setDocument = Sizzle.setDocument = function (node) {
      var hasCompare,
          subWindow,
          doc = node ? node.ownerDocument || node : preferredDoc; // Return early if doc is invalid or already selected
      // Support: IE 11+, Edge 17 - 18+
      // IE/Edge sometimes throw a "Permission denied" error when strict-comparing
      // two documents; shallow comparisons work.
      // eslint-disable-next-line eqeqeq

      if (doc == document || doc.nodeType !== 9 || !doc.documentElement) {
        return document;
      } // Update global variables


      document = doc;
      docElem = document.documentElement;
      documentIsHTML = !isXML(document); // Support: IE 9 - 11+, Edge 12 - 18+
      // Accessing iframe documents after unload throws "permission denied" errors (jQuery #13936)
      // Support: IE 11+, Edge 17 - 18+
      // IE/Edge sometimes throw a "Permission denied" error when strict-comparing
      // two documents; shallow comparisons work.
      // eslint-disable-next-line eqeqeq

      if (preferredDoc != document && (subWindow = document.defaultView) && subWindow.top !== subWindow) {
        // Support: IE 11, Edge
        if (subWindow.addEventListener) {
          subWindow.addEventListener("unload", unloadHandler, false); // Support: IE 9 - 10 only
        } else if (subWindow.attachEvent) {
          subWindow.attachEvent("onunload", unloadHandler);
        }
      } // Support: IE 8 - 11+, Edge 12 - 18+, Chrome <=16 - 25 only, Firefox <=3.6 - 31 only,
      // Safari 4 - 5 only, Opera <=11.6 - 12.x only
      // IE/Edge & older browsers don't support the :scope pseudo-class.
      // Support: Safari 6.0 only
      // Safari 6.0 supports :scope but it's an alias of :root there.


      support.scope = assert(function (el) {
        docElem.appendChild(el).appendChild(document.createElement("div"));
        return typeof el.querySelectorAll !== "undefined" && !el.querySelectorAll(":scope fieldset div").length;
      });
      /* Attributes
      ---------------------------------------------------------------------- */
      // Support: IE<8
      // Verify that getAttribute really returns attributes and not properties
      // (excepting IE8 booleans)

      support.attributes = assert(function (el) {
        el.className = "i";
        return !el.getAttribute("className");
      });
      /* getElement(s)By*
      ---------------------------------------------------------------------- */
      // Check if getElementsByTagName("*") returns only elements

      support.getElementsByTagName = assert(function (el) {
        el.appendChild(document.createComment(""));
        return !el.getElementsByTagName("*").length;
      }); // Support: IE<9

      support.getElementsByClassName = rnative.test(document.getElementsByClassName); // Support: IE<10
      // Check if getElementById returns elements by name
      // The broken getElementById methods don't pick up programmatically-set names,
      // so use a roundabout getElementsByName test

      support.getById = assert(function (el) {
        docElem.appendChild(el).id = expando;
        return !document.getElementsByName || !document.getElementsByName(expando).length;
      }); // ID filter and find

      if (support.getById) {
        Expr.filter["ID"] = function (id) {
          var attrId = id.replace(runescape, funescape);
          return function (elem) {
            return elem.getAttribute("id") === attrId;
          };
        };

        Expr.find["ID"] = function (id, context) {
          if (typeof context.getElementById !== "undefined" && documentIsHTML) {
            var elem = context.getElementById(id);
            return elem ? [elem] : [];
          }
        };
      } else {
        Expr.filter["ID"] = function (id) {
          var attrId = id.replace(runescape, funescape);
          return function (elem) {
            var node = typeof elem.getAttributeNode !== "undefined" && elem.getAttributeNode("id");
            return node && node.value === attrId;
          };
        }; // Support: IE 6 - 7 only
        // getElementById is not reliable as a find shortcut


        Expr.find["ID"] = function (id, context) {
          if (typeof context.getElementById !== "undefined" && documentIsHTML) {
            var node,
                i,
                elems,
                elem = context.getElementById(id);

            if (elem) {
              // Verify the id attribute
              node = elem.getAttributeNode("id");

              if (node && node.value === id) {
                return [elem];
              } // Fall back on getElementsByName


              elems = context.getElementsByName(id);
              i = 0;

              while (elem = elems[i++]) {
                node = elem.getAttributeNode("id");

                if (node && node.value === id) {
                  return [elem];
                }
              }
            }

            return [];
          }
        };
      } // Tag


      Expr.find["TAG"] = support.getElementsByTagName ? function (tag, context) {
        if (typeof context.getElementsByTagName !== "undefined") {
          return context.getElementsByTagName(tag); // DocumentFragment nodes don't have gEBTN
        } else if (support.qsa) {
          return context.querySelectorAll(tag);
        }
      } : function (tag, context) {
        var elem,
            tmp = [],
            i = 0,
            // By happy coincidence, a (broken) gEBTN appears on DocumentFragment nodes too
        results = context.getElementsByTagName(tag); // Filter out possible comments

        if (tag === "*") {
          while (elem = results[i++]) {
            if (elem.nodeType === 1) {
              tmp.push(elem);
            }
          }

          return tmp;
        }

        return results;
      }; // Class

      Expr.find["CLASS"] = support.getElementsByClassName && function (className, context) {
        if (typeof context.getElementsByClassName !== "undefined" && documentIsHTML) {
          return context.getElementsByClassName(className);
        }
      };
      /* QSA/matchesSelector
      ---------------------------------------------------------------------- */
      // QSA and matchesSelector support
      // matchesSelector(:active) reports false when true (IE9/Opera 11.5)


      rbuggyMatches = []; // qSa(:focus) reports false when true (Chrome 21)
      // We allow this because of a bug in IE8/9 that throws an error
      // whenever `document.activeElement` is accessed on an iframe
      // So, we allow :focus to pass through QSA all the time to avoid the IE error
      // See https://bugs.jquery.com/ticket/13378

      rbuggyQSA = [];

      if (support.qsa = rnative.test(document.querySelectorAll)) {
        // Build QSA regex
        // Regex strategy adopted from Diego Perini
        assert(function (el) {
          var input; // Select is set to empty string on purpose
          // This is to test IE's treatment of not explicitly
          // setting a boolean content attribute,
          // since its presence should be enough
          // https://bugs.jquery.com/ticket/12359

          docElem.appendChild(el).innerHTML = "<a id='" + expando + "'></a>" + "<select id='" + expando + "-\r\\' msallowcapture=''>" + "<option selected=''></option></select>"; // Support: IE8, Opera 11-12.16
          // Nothing should be selected when empty strings follow ^= or $= or *=
          // The test attribute must be unknown in Opera but "safe" for WinRT
          // https://msdn.microsoft.com/en-us/library/ie/hh465388.aspx#attribute_section

          if (el.querySelectorAll("[msallowcapture^='']").length) {
            rbuggyQSA.push("[*^$]=" + whitespace + "*(?:''|\"\")");
          } // Support: IE8
          // Boolean attributes and "value" are not treated correctly


          if (!el.querySelectorAll("[selected]").length) {
            rbuggyQSA.push("\\[" + whitespace + "*(?:value|" + booleans + ")");
          } // Support: Chrome<29, Android<4.4, Safari<7.0+, iOS<7.0+, PhantomJS<1.9.8+


          if (!el.querySelectorAll("[id~=" + expando + "-]").length) {
            rbuggyQSA.push("~=");
          } // Support: IE 11+, Edge 15 - 18+
          // IE 11/Edge don't find elements on a `[name='']` query in some cases.
          // Adding a temporary attribute to the document before the selection works
          // around the issue.
          // Interestingly, IE 10 & older don't seem to have the issue.


          input = document.createElement("input");
          input.setAttribute("name", "");
          el.appendChild(input);

          if (!el.querySelectorAll("[name='']").length) {
            rbuggyQSA.push("\\[" + whitespace + "*name" + whitespace + "*=" + whitespace + "*(?:''|\"\")");
          } // Webkit/Opera - :checked should return selected option elements
          // http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
          // IE8 throws error here and will not see later tests


          if (!el.querySelectorAll(":checked").length) {
            rbuggyQSA.push(":checked");
          } // Support: Safari 8+, iOS 8+
          // https://bugs.webkit.org/show_bug.cgi?id=136851
          // In-page `selector#id sibling-combinator selector` fails


          if (!el.querySelectorAll("a#" + expando + "+*").length) {
            rbuggyQSA.push(".#.+[+~]");
          } // Support: Firefox <=3.6 - 5 only
          // Old Firefox doesn't throw on a badly-escaped identifier.


          el.querySelectorAll("\\\f");
          rbuggyQSA.push("[\\r\\n\\f]");
        });
        assert(function (el) {
          el.innerHTML = "<a href='' disabled='disabled'></a>" + "<select disabled='disabled'><option/></select>"; // Support: Windows 8 Native Apps
          // The type and name attributes are restricted during .innerHTML assignment

          var input = document.createElement("input");
          input.setAttribute("type", "hidden");
          el.appendChild(input).setAttribute("name", "D"); // Support: IE8
          // Enforce case-sensitivity of name attribute

          if (el.querySelectorAll("[name=d]").length) {
            rbuggyQSA.push("name" + whitespace + "*[*^$|!~]?=");
          } // FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)
          // IE8 throws error here and will not see later tests


          if (el.querySelectorAll(":enabled").length !== 2) {
            rbuggyQSA.push(":enabled", ":disabled");
          } // Support: IE9-11+
          // IE's :disabled selector does not pick up the children of disabled fieldsets


          docElem.appendChild(el).disabled = true;

          if (el.querySelectorAll(":disabled").length !== 2) {
            rbuggyQSA.push(":enabled", ":disabled");
          } // Support: Opera 10 - 11 only
          // Opera 10-11 does not throw on post-comma invalid pseudos


          el.querySelectorAll("*,:x");
          rbuggyQSA.push(",.*:");
        });
      }

      if (support.matchesSelector = rnative.test(matches = docElem.matches || docElem.webkitMatchesSelector || docElem.mozMatchesSelector || docElem.oMatchesSelector || docElem.msMatchesSelector)) {
        assert(function (el) {
          // Check to see if it's possible to do matchesSelector
          // on a disconnected node (IE 9)
          support.disconnectedMatch = matches.call(el, "*"); // This should fail with an exception
          // Gecko does not error, returns false instead

          matches.call(el, "[s!='']:x");
          rbuggyMatches.push("!=", pseudos);
        });
      }

      rbuggyQSA = rbuggyQSA.length && new RegExp(rbuggyQSA.join("|"));
      rbuggyMatches = rbuggyMatches.length && new RegExp(rbuggyMatches.join("|"));
      /* Contains
      ---------------------------------------------------------------------- */

      hasCompare = rnative.test(docElem.compareDocumentPosition); // Element contains another
      // Purposefully self-exclusive
      // As in, an element does not contain itself

      contains = hasCompare || rnative.test(docElem.contains) ? function (a, b) {
        var adown = a.nodeType === 9 ? a.documentElement : a,
            bup = b && b.parentNode;
        return a === bup || !!(bup && bup.nodeType === 1 && (adown.contains ? adown.contains(bup) : a.compareDocumentPosition && a.compareDocumentPosition(bup) & 16));
      } : function (a, b) {
        if (b) {
          while (b = b.parentNode) {
            if (b === a) {
              return true;
            }
          }
        }

        return false;
      };
      /* Sorting
      ---------------------------------------------------------------------- */
      // Document order sorting

      sortOrder = hasCompare ? function (a, b) {
        // Flag for duplicate removal
        if (a === b) {
          hasDuplicate = true;
          return 0;
        } // Sort on method existence if only one input has compareDocumentPosition


        var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;

        if (compare) {
          return compare;
        } // Calculate position if both inputs belong to the same document
        // Support: IE 11+, Edge 17 - 18+
        // IE/Edge sometimes throw a "Permission denied" error when strict-comparing
        // two documents; shallow comparisons work.
        // eslint-disable-next-line eqeqeq


        compare = (a.ownerDocument || a) == (b.ownerDocument || b) ? a.compareDocumentPosition(b) : // Otherwise we know they are disconnected
        1; // Disconnected nodes

        if (compare & 1 || !support.sortDetached && b.compareDocumentPosition(a) === compare) {
          // Choose the first element that is related to our preferred document
          // Support: IE 11+, Edge 17 - 18+
          // IE/Edge sometimes throw a "Permission denied" error when strict-comparing
          // two documents; shallow comparisons work.
          // eslint-disable-next-line eqeqeq
          if (a == document || a.ownerDocument == preferredDoc && contains(preferredDoc, a)) {
            return -1;
          } // Support: IE 11+, Edge 17 - 18+
          // IE/Edge sometimes throw a "Permission denied" error when strict-comparing
          // two documents; shallow comparisons work.
          // eslint-disable-next-line eqeqeq


          if (b == document || b.ownerDocument == preferredDoc && contains(preferredDoc, b)) {
            return 1;
          } // Maintain original order


          return sortInput ? indexOf(sortInput, a) - indexOf(sortInput, b) : 0;
        }

        return compare & 4 ? -1 : 1;
      } : function (a, b) {
        // Exit early if the nodes are identical
        if (a === b) {
          hasDuplicate = true;
          return 0;
        }

        var cur,
            i = 0,
            aup = a.parentNode,
            bup = b.parentNode,
            ap = [a],
            bp = [b]; // Parentless nodes are either documents or disconnected

        if (!aup || !bup) {
          // Support: IE 11+, Edge 17 - 18+
          // IE/Edge sometimes throw a "Permission denied" error when strict-comparing
          // two documents; shallow comparisons work.

          /* eslint-disable eqeqeq */
          return a == document ? -1 : b == document ? 1 :
          /* eslint-enable eqeqeq */
          aup ? -1 : bup ? 1 : sortInput ? indexOf(sortInput, a) - indexOf(sortInput, b) : 0; // If the nodes are siblings, we can do a quick check
        } else if (aup === bup) {
          return siblingCheck(a, b);
        } // Otherwise we need full lists of their ancestors for comparison


        cur = a;

        while (cur = cur.parentNode) {
          ap.unshift(cur);
        }

        cur = b;

        while (cur = cur.parentNode) {
          bp.unshift(cur);
        } // Walk down the tree looking for a discrepancy


        while (ap[i] === bp[i]) {
          i++;
        }

        return i ? // Do a sibling check if the nodes have a common ancestor
        siblingCheck(ap[i], bp[i]) : // Otherwise nodes in our document sort first
        // Support: IE 11+, Edge 17 - 18+
        // IE/Edge sometimes throw a "Permission denied" error when strict-comparing
        // two documents; shallow comparisons work.

        /* eslint-disable eqeqeq */
        ap[i] == preferredDoc ? -1 : bp[i] == preferredDoc ? 1 :
        /* eslint-enable eqeqeq */
        0;
      };
      return document;
    };

    Sizzle.matches = function (expr, elements) {
      return Sizzle(expr, null, null, elements);
    };

    Sizzle.matchesSelector = function (elem, expr) {
      setDocument(elem);

      if (support.matchesSelector && documentIsHTML && !nonnativeSelectorCache[expr + " "] && (!rbuggyMatches || !rbuggyMatches.test(expr)) && (!rbuggyQSA || !rbuggyQSA.test(expr))) {
        try {
          var ret = matches.call(elem, expr); // IE 9's matchesSelector returns false on disconnected nodes

          if (ret || support.disconnectedMatch || // As well, disconnected nodes are said to be in a document
          // fragment in IE 9
          elem.document && elem.document.nodeType !== 11) {
            return ret;
          }
        } catch (e) {
          nonnativeSelectorCache(expr, true);
        }
      }

      return Sizzle(expr, document, null, [elem]).length > 0;
    };

    Sizzle.contains = function (context, elem) {
      // Set document vars if needed
      // Support: IE 11+, Edge 17 - 18+
      // IE/Edge sometimes throw a "Permission denied" error when strict-comparing
      // two documents; shallow comparisons work.
      // eslint-disable-next-line eqeqeq
      if ((context.ownerDocument || context) != document) {
        setDocument(context);
      }

      return contains(context, elem);
    };

    Sizzle.attr = function (elem, name) {
      // Set document vars if needed
      // Support: IE 11+, Edge 17 - 18+
      // IE/Edge sometimes throw a "Permission denied" error when strict-comparing
      // two documents; shallow comparisons work.
      // eslint-disable-next-line eqeqeq
      if ((elem.ownerDocument || elem) != document) {
        setDocument(elem);
      }

      var fn = Expr.attrHandle[name.toLowerCase()],
          // Don't get fooled by Object.prototype properties (jQuery #13807)
      val = fn && hasOwn.call(Expr.attrHandle, name.toLowerCase()) ? fn(elem, name, !documentIsHTML) : undefined;
      return val !== undefined ? val : support.attributes || !documentIsHTML ? elem.getAttribute(name) : (val = elem.getAttributeNode(name)) && val.specified ? val.value : null;
    };

    Sizzle.escape = function (sel) {
      return (sel + "").replace(rcssescape, fcssescape);
    };

    Sizzle.error = function (msg) {
      throw new Error("Syntax error, unrecognized expression: " + msg);
    };
    /**
     * Document sorting and removing duplicates
     * @param {ArrayLike} results
     */


    Sizzle.uniqueSort = function (results) {
      var elem,
          duplicates = [],
          j = 0,
          i = 0; // Unless we *know* we can detect duplicates, assume their presence

      hasDuplicate = !support.detectDuplicates;
      sortInput = !support.sortStable && results.slice(0);
      results.sort(sortOrder);

      if (hasDuplicate) {
        while (elem = results[i++]) {
          if (elem === results[i]) {
            j = duplicates.push(i);
          }
        }

        while (j--) {
          results.splice(duplicates[j], 1);
        }
      } // Clear input after sorting to release objects
      // See https://github.com/jquery/sizzle/pull/225


      sortInput = null;
      return results;
    };
    /**
     * Utility function for retrieving the text value of an array of DOM nodes
     * @param {Array|Element} elem
     */


    getText = Sizzle.getText = function (elem) {
      var node,
          ret = "",
          i = 0,
          nodeType = elem.nodeType;

      if (!nodeType) {
        // If no nodeType, this is expected to be an array
        while (node = elem[i++]) {
          // Do not traverse comment nodes
          ret += getText(node);
        }
      } else if (nodeType === 1 || nodeType === 9 || nodeType === 11) {
        // Use textContent for elements
        // innerText usage removed for consistency of new lines (jQuery #11153)
        if (typeof elem.textContent === "string") {
          return elem.textContent;
        } else {
          // Traverse its children
          for (elem = elem.firstChild; elem; elem = elem.nextSibling) {
            ret += getText(elem);
          }
        }
      } else if (nodeType === 3 || nodeType === 4) {
        return elem.nodeValue;
      } // Do not include comment or processing instruction nodes


      return ret;
    };

    Expr = Sizzle.selectors = {
      // Can be adjusted by the user
      cacheLength: 50,
      createPseudo: markFunction,
      match: matchExpr,
      attrHandle: {},
      find: {},
      relative: {
        ">": {
          dir: "parentNode",
          first: true
        },
        " ": {
          dir: "parentNode"
        },
        "+": {
          dir: "previousSibling",
          first: true
        },
        "~": {
          dir: "previousSibling"
        }
      },
      preFilter: {
        "ATTR": function ATTR(match) {
          match[1] = match[1].replace(runescape, funescape); // Move the given value to match[3] whether quoted or unquoted

          match[3] = (match[3] || match[4] || match[5] || "").replace(runescape, funescape);

          if (match[2] === "~=") {
            match[3] = " " + match[3] + " ";
          }

          return match.slice(0, 4);
        },
        "CHILD": function CHILD(match) {
          /* matches from matchExpr["CHILD"]
          	1 type (only|nth|...)
          	2 what (child|of-type)
          	3 argument (even|odd|\d*|\d*n([+-]\d+)?|...)
          	4 xn-component of xn+y argument ([+-]?\d*n|)
          	5 sign of xn-component
          	6 x of xn-component
          	7 sign of y-component
          	8 y of y-component
          */
          match[1] = match[1].toLowerCase();

          if (match[1].slice(0, 3) === "nth") {
            // nth-* requires argument
            if (!match[3]) {
              Sizzle.error(match[0]);
            } // numeric x and y parameters for Expr.filter.CHILD
            // remember that false/true cast respectively to 0/1


            match[4] = +(match[4] ? match[5] + (match[6] || 1) : 2 * (match[3] === "even" || match[3] === "odd"));
            match[5] = +(match[7] + match[8] || match[3] === "odd"); // other types prohibit arguments
          } else if (match[3]) {
            Sizzle.error(match[0]);
          }

          return match;
        },
        "PSEUDO": function PSEUDO(match) {
          var excess,
              unquoted = !match[6] && match[2];

          if (matchExpr["CHILD"].test(match[0])) {
            return null;
          } // Accept quoted arguments as-is


          if (match[3]) {
            match[2] = match[4] || match[5] || ""; // Strip excess characters from unquoted arguments
          } else if (unquoted && rpseudo.test(unquoted) && ( // Get excess from tokenize (recursively)
          excess = tokenize(unquoted, true)) && ( // advance to the next closing parenthesis
          excess = unquoted.indexOf(")", unquoted.length - excess) - unquoted.length)) {
            // excess is a negative index
            match[0] = match[0].slice(0, excess);
            match[2] = unquoted.slice(0, excess);
          } // Return only captures needed by the pseudo filter method (type and argument)


          return match.slice(0, 3);
        }
      },
      filter: {
        "TAG": function TAG(nodeNameSelector) {
          var nodeName = nodeNameSelector.replace(runescape, funescape).toLowerCase();
          return nodeNameSelector === "*" ? function () {
            return true;
          } : function (elem) {
            return elem.nodeName && elem.nodeName.toLowerCase() === nodeName;
          };
        },
        "CLASS": function CLASS(className) {
          var pattern = classCache[className + " "];
          return pattern || (pattern = new RegExp("(^|" + whitespace + ")" + className + "(" + whitespace + "|$)")) && classCache(className, function (elem) {
            return pattern.test(typeof elem.className === "string" && elem.className || typeof elem.getAttribute !== "undefined" && elem.getAttribute("class") || "");
          });
        },
        "ATTR": function ATTR(name, operator, check) {
          return function (elem) {
            var result = Sizzle.attr(elem, name);

            if (result == null) {
              return operator === "!=";
            }

            if (!operator) {
              return true;
            }

            result += "";
            /* eslint-disable max-len */

            return operator === "=" ? result === check : operator === "!=" ? result !== check : operator === "^=" ? check && result.indexOf(check) === 0 : operator === "*=" ? check && result.indexOf(check) > -1 : operator === "$=" ? check && result.slice(-check.length) === check : operator === "~=" ? (" " + result.replace(rwhitespace, " ") + " ").indexOf(check) > -1 : operator === "|=" ? result === check || result.slice(0, check.length + 1) === check + "-" : false;
            /* eslint-enable max-len */
          };
        },
        "CHILD": function CHILD(type, what, _argument, first, last) {
          var simple = type.slice(0, 3) !== "nth",
              forward = type.slice(-4) !== "last",
              ofType = what === "of-type";
          return first === 1 && last === 0 ? // Shortcut for :nth-*(n)
          function (elem) {
            return !!elem.parentNode;
          } : function (elem, _context, xml) {
            var cache,
                uniqueCache,
                outerCache,
                node,
                nodeIndex,
                start,
                dir = simple !== forward ? "nextSibling" : "previousSibling",
                parent = elem.parentNode,
                name = ofType && elem.nodeName.toLowerCase(),
                useCache = !xml && !ofType,
                diff = false;

            if (parent) {
              // :(first|last|only)-(child|of-type)
              if (simple) {
                while (dir) {
                  node = elem;

                  while (node = node[dir]) {
                    if (ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1) {
                      return false;
                    }
                  } // Reverse direction for :only-* (if we haven't yet done so)


                  start = dir = type === "only" && !start && "nextSibling";
                }

                return true;
              }

              start = [forward ? parent.firstChild : parent.lastChild]; // non-xml :nth-child(...) stores cache data on `parent`

              if (forward && useCache) {
                // Seek `elem` from a previously-cached index
                // ...in a gzip-friendly way
                node = parent;
                outerCache = node[expando] || (node[expando] = {}); // Support: IE <9 only
                // Defend against cloned attroperties (jQuery gh-1709)

                uniqueCache = outerCache[node.uniqueID] || (outerCache[node.uniqueID] = {});
                cache = uniqueCache[type] || [];
                nodeIndex = cache[0] === dirruns && cache[1];
                diff = nodeIndex && cache[2];
                node = nodeIndex && parent.childNodes[nodeIndex];

                while (node = ++nodeIndex && node && node[dir] || ( // Fallback to seeking `elem` from the start
                diff = nodeIndex = 0) || start.pop()) {
                  // When found, cache indexes on `parent` and break
                  if (node.nodeType === 1 && ++diff && node === elem) {
                    uniqueCache[type] = [dirruns, nodeIndex, diff];
                    break;
                  }
                }
              } else {
                // Use previously-cached element index if available
                if (useCache) {
                  // ...in a gzip-friendly way
                  node = elem;
                  outerCache = node[expando] || (node[expando] = {}); // Support: IE <9 only
                  // Defend against cloned attroperties (jQuery gh-1709)

                  uniqueCache = outerCache[node.uniqueID] || (outerCache[node.uniqueID] = {});
                  cache = uniqueCache[type] || [];
                  nodeIndex = cache[0] === dirruns && cache[1];
                  diff = nodeIndex;
                } // xml :nth-child(...)
                // or :nth-last-child(...) or :nth(-last)?-of-type(...)


                if (diff === false) {
                  // Use the same loop as above to seek `elem` from the start
                  while (node = ++nodeIndex && node && node[dir] || (diff = nodeIndex = 0) || start.pop()) {
                    if ((ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1) && ++diff) {
                      // Cache the index of each encountered element
                      if (useCache) {
                        outerCache = node[expando] || (node[expando] = {}); // Support: IE <9 only
                        // Defend against cloned attroperties (jQuery gh-1709)

                        uniqueCache = outerCache[node.uniqueID] || (outerCache[node.uniqueID] = {});
                        uniqueCache[type] = [dirruns, diff];
                      }

                      if (node === elem) {
                        break;
                      }
                    }
                  }
                }
              } // Incorporate the offset, then check against cycle size


              diff -= last;
              return diff === first || diff % first === 0 && diff / first >= 0;
            }
          };
        },
        "PSEUDO": function PSEUDO(pseudo, argument) {
          // pseudo-class names are case-insensitive
          // http://www.w3.org/TR/selectors/#pseudo-classes
          // Prioritize by case sensitivity in case custom pseudos are added with uppercase letters
          // Remember that setFilters inherits from pseudos
          var args,
              fn = Expr.pseudos[pseudo] || Expr.setFilters[pseudo.toLowerCase()] || Sizzle.error("unsupported pseudo: " + pseudo); // The user may use createPseudo to indicate that
          // arguments are needed to create the filter function
          // just as Sizzle does

          if (fn[expando]) {
            return fn(argument);
          } // But maintain support for old signatures


          if (fn.length > 1) {
            args = [pseudo, pseudo, "", argument];
            return Expr.setFilters.hasOwnProperty(pseudo.toLowerCase()) ? markFunction(function (seed, matches) {
              var idx,
                  matched = fn(seed, argument),
                  i = matched.length;

              while (i--) {
                idx = indexOf(seed, matched[i]);
                seed[idx] = !(matches[idx] = matched[i]);
              }
            }) : function (elem) {
              return fn(elem, 0, args);
            };
          }

          return fn;
        }
      },
      pseudos: {
        // Potentially complex pseudos
        "not": markFunction(function (selector) {
          // Trim the selector passed to compile
          // to avoid treating leading and trailing
          // spaces as combinators
          var input = [],
              results = [],
              matcher = compile(selector.replace(rtrim, "$1"));
          return matcher[expando] ? markFunction(function (seed, matches, _context, xml) {
            var elem,
                unmatched = matcher(seed, null, xml, []),
                i = seed.length; // Match elements unmatched by `matcher`

            while (i--) {
              if (elem = unmatched[i]) {
                seed[i] = !(matches[i] = elem);
              }
            }
          }) : function (elem, _context, xml) {
            input[0] = elem;
            matcher(input, null, xml, results); // Don't keep the element (issue #299)

            input[0] = null;
            return !results.pop();
          };
        }),
        "has": markFunction(function (selector) {
          return function (elem) {
            return Sizzle(selector, elem).length > 0;
          };
        }),
        "contains": markFunction(function (text) {
          text = text.replace(runescape, funescape);
          return function (elem) {
            return (elem.textContent || getText(elem)).indexOf(text) > -1;
          };
        }),
        // "Whether an element is represented by a :lang() selector
        // is based solely on the element's language value
        // being equal to the identifier C,
        // or beginning with the identifier C immediately followed by "-".
        // The matching of C against the element's language value is performed case-insensitively.
        // The identifier C does not have to be a valid language name."
        // http://www.w3.org/TR/selectors/#lang-pseudo
        "lang": markFunction(function (lang) {
          // lang value must be a valid identifier
          if (!ridentifier.test(lang || "")) {
            Sizzle.error("unsupported lang: " + lang);
          }

          lang = lang.replace(runescape, funescape).toLowerCase();
          return function (elem) {
            var elemLang;

            do {
              if (elemLang = documentIsHTML ? elem.lang : elem.getAttribute("xml:lang") || elem.getAttribute("lang")) {
                elemLang = elemLang.toLowerCase();
                return elemLang === lang || elemLang.indexOf(lang + "-") === 0;
              }
            } while ((elem = elem.parentNode) && elem.nodeType === 1);

            return false;
          };
        }),
        // Miscellaneous
        "target": function target(elem) {
          var hash = window.location && window.location.hash;
          return hash && hash.slice(1) === elem.id;
        },
        "root": function root(elem) {
          return elem === docElem;
        },
        "focus": function focus(elem) {
          return elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);
        },
        // Boolean properties
        "enabled": createDisabledPseudo(false),
        "disabled": createDisabledPseudo(true),
        "checked": function checked(elem) {
          // In CSS3, :checked should return both checked and selected elements
          // http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
          var nodeName = elem.nodeName.toLowerCase();
          return nodeName === "input" && !!elem.checked || nodeName === "option" && !!elem.selected;
        },
        "selected": function selected(elem) {
          // Accessing this property makes selected-by-default
          // options in Safari work properly
          if (elem.parentNode) {
            // eslint-disable-next-line no-unused-expressions
            elem.parentNode.selectedIndex;
          }

          return elem.selected === true;
        },
        // Contents
        "empty": function empty(elem) {
          // http://www.w3.org/TR/selectors/#empty-pseudo
          // :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),
          //   but not by others (comment: 8; processing instruction: 7; etc.)
          // nodeType < 6 works because attributes (2) do not appear as children
          for (elem = elem.firstChild; elem; elem = elem.nextSibling) {
            if (elem.nodeType < 6) {
              return false;
            }
          }

          return true;
        },
        "parent": function parent(elem) {
          return !Expr.pseudos["empty"](elem);
        },
        // Element/input types
        "header": function header(elem) {
          return rheader.test(elem.nodeName);
        },
        "input": function input(elem) {
          return rinputs.test(elem.nodeName);
        },
        "button": function button(elem) {
          var name = elem.nodeName.toLowerCase();
          return name === "input" && elem.type === "button" || name === "button";
        },
        "text": function text(elem) {
          var attr;
          return elem.nodeName.toLowerCase() === "input" && elem.type === "text" && ( // Support: IE<8
          // New HTML5 attribute values (e.g., "search") appear with elem.type === "text"
          (attr = elem.getAttribute("type")) == null || attr.toLowerCase() === "text");
        },
        // Position-in-collection
        "first": createPositionalPseudo(function () {
          return [0];
        }),
        "last": createPositionalPseudo(function (_matchIndexes, length) {
          return [length - 1];
        }),
        "eq": createPositionalPseudo(function (_matchIndexes, length, argument) {
          return [argument < 0 ? argument + length : argument];
        }),
        "even": createPositionalPseudo(function (matchIndexes, length) {
          var i = 0;

          for (; i < length; i += 2) {
            matchIndexes.push(i);
          }

          return matchIndexes;
        }),
        "odd": createPositionalPseudo(function (matchIndexes, length) {
          var i = 1;

          for (; i < length; i += 2) {
            matchIndexes.push(i);
          }

          return matchIndexes;
        }),
        "lt": createPositionalPseudo(function (matchIndexes, length, argument) {
          var i = argument < 0 ? argument + length : argument > length ? length : argument;

          for (; --i >= 0;) {
            matchIndexes.push(i);
          }

          return matchIndexes;
        }),
        "gt": createPositionalPseudo(function (matchIndexes, length, argument) {
          var i = argument < 0 ? argument + length : argument;

          for (; ++i < length;) {
            matchIndexes.push(i);
          }

          return matchIndexes;
        })
      }
    };
    Expr.pseudos["nth"] = Expr.pseudos["eq"]; // Add button/input type pseudos

    for (i in {
      radio: true,
      checkbox: true,
      file: true,
      password: true,
      image: true
    }) {
      Expr.pseudos[i] = createInputPseudo(i);
    }

    for (i in {
      submit: true,
      reset: true
    }) {
      Expr.pseudos[i] = createButtonPseudo(i);
    } // Easy API for creating new setFilters


    function setFilters() {}

    setFilters.prototype = Expr.filters = Expr.pseudos;
    Expr.setFilters = new setFilters();

    tokenize = Sizzle.tokenize = function (selector, parseOnly) {
      var matched,
          match,
          tokens,
          type,
          soFar,
          groups,
          preFilters,
          cached = tokenCache[selector + " "];

      if (cached) {
        return parseOnly ? 0 : cached.slice(0);
      }

      soFar = selector;
      groups = [];
      preFilters = Expr.preFilter;

      while (soFar) {
        // Comma and first run
        if (!matched || (match = rcomma.exec(soFar))) {
          if (match) {
            // Don't consume trailing commas as valid
            soFar = soFar.slice(match[0].length) || soFar;
          }

          groups.push(tokens = []);
        }

        matched = false; // Combinators

        if (match = rcombinators.exec(soFar)) {
          matched = match.shift();
          tokens.push({
            value: matched,
            // Cast descendant combinators to space
            type: match[0].replace(rtrim, " ")
          });
          soFar = soFar.slice(matched.length);
        } // Filters


        for (type in Expr.filter) {
          if ((match = matchExpr[type].exec(soFar)) && (!preFilters[type] || (match = preFilters[type](match)))) {
            matched = match.shift();
            tokens.push({
              value: matched,
              type: type,
              matches: match
            });
            soFar = soFar.slice(matched.length);
          }
        }

        if (!matched) {
          break;
        }
      } // Return the length of the invalid excess
      // if we're just parsing
      // Otherwise, throw an error or return tokens


      return parseOnly ? soFar.length : soFar ? Sizzle.error(selector) : // Cache the tokens
      tokenCache(selector, groups).slice(0);
    };

    function toSelector(tokens) {
      var i = 0,
          len = tokens.length,
          selector = "";

      for (; i < len; i++) {
        selector += tokens[i].value;
      }

      return selector;
    }

    function addCombinator(matcher, combinator, base) {
      var dir = combinator.dir,
          skip = combinator.next,
          key = skip || dir,
          checkNonElements = base && key === "parentNode",
          doneName = done++;
      return combinator.first ? // Check against closest ancestor/preceding element
      function (elem, context, xml) {
        while (elem = elem[dir]) {
          if (elem.nodeType === 1 || checkNonElements) {
            return matcher(elem, context, xml);
          }
        }

        return false;
      } : // Check against all ancestor/preceding elements
      function (elem, context, xml) {
        var oldCache,
            uniqueCache,
            outerCache,
            newCache = [dirruns, doneName]; // We can't set arbitrary data on XML nodes, so they don't benefit from combinator caching

        if (xml) {
          while (elem = elem[dir]) {
            if (elem.nodeType === 1 || checkNonElements) {
              if (matcher(elem, context, xml)) {
                return true;
              }
            }
          }
        } else {
          while (elem = elem[dir]) {
            if (elem.nodeType === 1 || checkNonElements) {
              outerCache = elem[expando] || (elem[expando] = {}); // Support: IE <9 only
              // Defend against cloned attroperties (jQuery gh-1709)

              uniqueCache = outerCache[elem.uniqueID] || (outerCache[elem.uniqueID] = {});

              if (skip && skip === elem.nodeName.toLowerCase()) {
                elem = elem[dir] || elem;
              } else if ((oldCache = uniqueCache[key]) && oldCache[0] === dirruns && oldCache[1] === doneName) {
                // Assign to newCache so results back-propagate to previous elements
                return newCache[2] = oldCache[2];
              } else {
                // Reuse newcache so results back-propagate to previous elements
                uniqueCache[key] = newCache; // A match means we're done; a fail means we have to keep checking

                if (newCache[2] = matcher(elem, context, xml)) {
                  return true;
                }
              }
            }
          }
        }

        return false;
      };
    }

    function elementMatcher(matchers) {
      return matchers.length > 1 ? function (elem, context, xml) {
        var i = matchers.length;

        while (i--) {
          if (!matchers[i](elem, context, xml)) {
            return false;
          }
        }

        return true;
      } : matchers[0];
    }

    function multipleContexts(selector, contexts, results) {
      var i = 0,
          len = contexts.length;

      for (; i < len; i++) {
        Sizzle(selector, contexts[i], results);
      }

      return results;
    }

    function condense(unmatched, map, filter, context, xml) {
      var elem,
          newUnmatched = [],
          i = 0,
          len = unmatched.length,
          mapped = map != null;

      for (; i < len; i++) {
        if (elem = unmatched[i]) {
          if (!filter || filter(elem, context, xml)) {
            newUnmatched.push(elem);

            if (mapped) {
              map.push(i);
            }
          }
        }
      }

      return newUnmatched;
    }

    function setMatcher(preFilter, selector, matcher, postFilter, postFinder, postSelector) {
      if (postFilter && !postFilter[expando]) {
        postFilter = setMatcher(postFilter);
      }

      if (postFinder && !postFinder[expando]) {
        postFinder = setMatcher(postFinder, postSelector);
      }

      return markFunction(function (seed, results, context, xml) {
        var temp,
            i,
            elem,
            preMap = [],
            postMap = [],
            preexisting = results.length,
            // Get initial elements from seed or context
        elems = seed || multipleContexts(selector || "*", context.nodeType ? [context] : context, []),
            // Prefilter to get matcher input, preserving a map for seed-results synchronization
        matcherIn = preFilter && (seed || !selector) ? condense(elems, preMap, preFilter, context, xml) : elems,
            matcherOut = matcher ? // If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,
        postFinder || (seed ? preFilter : preexisting || postFilter) ? // ...intermediate processing is necessary
        [] : // ...otherwise use results directly
        results : matcherIn; // Find primary matches

        if (matcher) {
          matcher(matcherIn, matcherOut, context, xml);
        } // Apply postFilter


        if (postFilter) {
          temp = condense(matcherOut, postMap);
          postFilter(temp, [], context, xml); // Un-match failing elements by moving them back to matcherIn

          i = temp.length;

          while (i--) {
            if (elem = temp[i]) {
              matcherOut[postMap[i]] = !(matcherIn[postMap[i]] = elem);
            }
          }
        }

        if (seed) {
          if (postFinder || preFilter) {
            if (postFinder) {
              // Get the final matcherOut by condensing this intermediate into postFinder contexts
              temp = [];
              i = matcherOut.length;

              while (i--) {
                if (elem = matcherOut[i]) {
                  // Restore matcherIn since elem is not yet a final match
                  temp.push(matcherIn[i] = elem);
                }
              }

              postFinder(null, matcherOut = [], temp, xml);
            } // Move matched elements from seed to results to keep them synchronized


            i = matcherOut.length;

            while (i--) {
              if ((elem = matcherOut[i]) && (temp = postFinder ? indexOf(seed, elem) : preMap[i]) > -1) {
                seed[temp] = !(results[temp] = elem);
              }
            }
          } // Add elements to results, through postFinder if defined

        } else {
          matcherOut = condense(matcherOut === results ? matcherOut.splice(preexisting, matcherOut.length) : matcherOut);

          if (postFinder) {
            postFinder(null, results, matcherOut, xml);
          } else {
            push.apply(results, matcherOut);
          }
        }
      });
    }

    function matcherFromTokens(tokens) {
      var checkContext,
          matcher,
          j,
          len = tokens.length,
          leadingRelative = Expr.relative[tokens[0].type],
          implicitRelative = leadingRelative || Expr.relative[" "],
          i = leadingRelative ? 1 : 0,
          // The foundational matcher ensures that elements are reachable from top-level context(s)
      matchContext = addCombinator(function (elem) {
        return elem === checkContext;
      }, implicitRelative, true),
          matchAnyContext = addCombinator(function (elem) {
        return indexOf(checkContext, elem) > -1;
      }, implicitRelative, true),
          matchers = [function (elem, context, xml) {
        var ret = !leadingRelative && (xml || context !== outermostContext) || ((checkContext = context).nodeType ? matchContext(elem, context, xml) : matchAnyContext(elem, context, xml)); // Avoid hanging onto element (issue #299)

        checkContext = null;
        return ret;
      }];

      for (; i < len; i++) {
        if (matcher = Expr.relative[tokens[i].type]) {
          matchers = [addCombinator(elementMatcher(matchers), matcher)];
        } else {
          matcher = Expr.filter[tokens[i].type].apply(null, tokens[i].matches); // Return special upon seeing a positional matcher

          if (matcher[expando]) {
            // Find the next relative operator (if any) for proper handling
            j = ++i;

            for (; j < len; j++) {
              if (Expr.relative[tokens[j].type]) {
                break;
              }
            }

            return setMatcher(i > 1 && elementMatcher(matchers), i > 1 && toSelector( // If the preceding token was a descendant combinator, insert an implicit any-element `*`
            tokens.slice(0, i - 1).concat({
              value: tokens[i - 2].type === " " ? "*" : ""
            })).replace(rtrim, "$1"), matcher, i < j && matcherFromTokens(tokens.slice(i, j)), j < len && matcherFromTokens(tokens = tokens.slice(j)), j < len && toSelector(tokens));
          }

          matchers.push(matcher);
        }
      }

      return elementMatcher(matchers);
    }

    function matcherFromGroupMatchers(elementMatchers, setMatchers) {
      var bySet = setMatchers.length > 0,
          byElement = elementMatchers.length > 0,
          superMatcher = function superMatcher(seed, context, xml, results, outermost) {
        var elem,
            j,
            matcher,
            matchedCount = 0,
            i = "0",
            unmatched = seed && [],
            setMatched = [],
            contextBackup = outermostContext,
            // We must always have either seed elements or outermost context
        elems = seed || byElement && Expr.find["TAG"]("*", outermost),
            // Use integer dirruns iff this is the outermost matcher
        dirrunsUnique = dirruns += contextBackup == null ? 1 : Math.random() || 0.1,
            len = elems.length;

        if (outermost) {
          // Support: IE 11+, Edge 17 - 18+
          // IE/Edge sometimes throw a "Permission denied" error when strict-comparing
          // two documents; shallow comparisons work.
          // eslint-disable-next-line eqeqeq
          outermostContext = context == document || context || outermost;
        } // Add elements passing elementMatchers directly to results
        // Support: IE<9, Safari
        // Tolerate NodeList properties (IE: "length"; Safari: <number>) matching elements by id


        for (; i !== len && (elem = elems[i]) != null; i++) {
          if (byElement && elem) {
            j = 0; // Support: IE 11+, Edge 17 - 18+
            // IE/Edge sometimes throw a "Permission denied" error when strict-comparing
            // two documents; shallow comparisons work.
            // eslint-disable-next-line eqeqeq

            if (!context && elem.ownerDocument != document) {
              setDocument(elem);
              xml = !documentIsHTML;
            }

            while (matcher = elementMatchers[j++]) {
              if (matcher(elem, context || document, xml)) {
                results.push(elem);
                break;
              }
            }

            if (outermost) {
              dirruns = dirrunsUnique;
            }
          } // Track unmatched elements for set filters


          if (bySet) {
            // They will have gone through all possible matchers
            if (elem = !matcher && elem) {
              matchedCount--;
            } // Lengthen the array for every element, matched or not


            if (seed) {
              unmatched.push(elem);
            }
          }
        } // `i` is now the count of elements visited above, and adding it to `matchedCount`
        // makes the latter nonnegative.


        matchedCount += i; // Apply set filters to unmatched elements
        // NOTE: This can be skipped if there are no unmatched elements (i.e., `matchedCount`
        // equals `i`), unless we didn't visit _any_ elements in the above loop because we have
        // no element matchers and no seed.
        // Incrementing an initially-string "0" `i` allows `i` to remain a string only in that
        // case, which will result in a "00" `matchedCount` that differs from `i` but is also
        // numerically zero.

        if (bySet && i !== matchedCount) {
          j = 0;

          while (matcher = setMatchers[j++]) {
            matcher(unmatched, setMatched, context, xml);
          }

          if (seed) {
            // Reintegrate element matches to eliminate the need for sorting
            if (matchedCount > 0) {
              while (i--) {
                if (!(unmatched[i] || setMatched[i])) {
                  setMatched[i] = pop.call(results);
                }
              }
            } // Discard index placeholder values to get only actual matches


            setMatched = condense(setMatched);
          } // Add matches to results


          push.apply(results, setMatched); // Seedless set matches succeeding multiple successful matchers stipulate sorting

          if (outermost && !seed && setMatched.length > 0 && matchedCount + setMatchers.length > 1) {
            Sizzle.uniqueSort(results);
          }
        } // Override manipulation of globals by nested matchers


        if (outermost) {
          dirruns = dirrunsUnique;
          outermostContext = contextBackup;
        }

        return unmatched;
      };

      return bySet ? markFunction(superMatcher) : superMatcher;
    }

    compile = Sizzle.compile = function (selector, match
    /* Internal Use Only */
    ) {
      var i,
          setMatchers = [],
          elementMatchers = [],
          cached = compilerCache[selector + " "];

      if (!cached) {
        // Generate a function of recursive functions that can be used to check each element
        if (!match) {
          match = tokenize(selector);
        }

        i = match.length;

        while (i--) {
          cached = matcherFromTokens(match[i]);

          if (cached[expando]) {
            setMatchers.push(cached);
          } else {
            elementMatchers.push(cached);
          }
        } // Cache the compiled function


        cached = compilerCache(selector, matcherFromGroupMatchers(elementMatchers, setMatchers)); // Save selector and tokenization

        cached.selector = selector;
      }

      return cached;
    };
    /**
     * A low-level selection function that works with Sizzle's compiled
     *  selector functions
     * @param {String|Function} selector A selector or a pre-compiled
     *  selector function built with Sizzle.compile
     * @param {Element} context
     * @param {Array} [results]
     * @param {Array} [seed] A set of elements to match against
     */


    select = Sizzle.select = function (selector, context, results, seed) {
      var i,
          tokens,
          token,
          type,
          find,
          compiled = typeof selector === "function" && selector,
          match = !seed && tokenize(selector = compiled.selector || selector);
      results = results || []; // Try to minimize operations if there is only one selector in the list and no seed
      // (the latter of which guarantees us context)

      if (match.length === 1) {
        // Reduce context if the leading compound selector is an ID
        tokens = match[0] = match[0].slice(0);

        if (tokens.length > 2 && (token = tokens[0]).type === "ID" && context.nodeType === 9 && documentIsHTML && Expr.relative[tokens[1].type]) {
          context = (Expr.find["ID"](token.matches[0].replace(runescape, funescape), context) || [])[0];

          if (!context) {
            return results; // Precompiled matchers will still verify ancestry, so step up a level
          } else if (compiled) {
            context = context.parentNode;
          }

          selector = selector.slice(tokens.shift().value.length);
        } // Fetch a seed set for right-to-left matching


        i = matchExpr["needsContext"].test(selector) ? 0 : tokens.length;

        while (i--) {
          token = tokens[i]; // Abort if we hit a combinator

          if (Expr.relative[type = token.type]) {
            break;
          }

          if (find = Expr.find[type]) {
            // Search, expanding context for leading sibling combinators
            if (seed = find(token.matches[0].replace(runescape, funescape), rsibling.test(tokens[0].type) && testContext(context.parentNode) || context)) {
              // If seed is empty or no tokens remain, we can return early
              tokens.splice(i, 1);
              selector = seed.length && toSelector(tokens);

              if (!selector) {
                push.apply(results, seed);
                return results;
              }

              break;
            }
          }
        }
      } // Compile and execute a filtering function if one is not provided
      // Provide `match` to avoid retokenization if we modified the selector above


      (compiled || compile(selector, match))(seed, context, !documentIsHTML, results, !context || rsibling.test(selector) && testContext(context.parentNode) || context);
      return results;
    }; // One-time assignments
    // Sort stability


    support.sortStable = expando.split("").sort(sortOrder).join("") === expando; // Support: Chrome 14-35+
    // Always assume duplicates if they aren't passed to the comparison function

    support.detectDuplicates = !!hasDuplicate; // Initialize against the default document

    setDocument(); // Support: Webkit<537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)
    // Detached nodes confoundingly follow *each other*

    support.sortDetached = assert(function (el) {
      // Should return 1, but returns 4 (following)
      return el.compareDocumentPosition(document.createElement("fieldset")) & 1;
    }); // Support: IE<8
    // Prevent attribute/property "interpolation"
    // https://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx

    if (!assert(function (el) {
      el.innerHTML = "<a href='#'></a>";
      return el.firstChild.getAttribute("href") === "#";
    })) {
      addHandle("type|href|height|width", function (elem, name, isXML) {
        if (!isXML) {
          return elem.getAttribute(name, name.toLowerCase() === "type" ? 1 : 2);
        }
      });
    } // Support: IE<9
    // Use defaultValue in place of getAttribute("value")


    if (!support.attributes || !assert(function (el) {
      el.innerHTML = "<input/>";
      el.firstChild.setAttribute("value", "");
      return el.firstChild.getAttribute("value") === "";
    })) {
      addHandle("value", function (elem, _name, isXML) {
        if (!isXML && elem.nodeName.toLowerCase() === "input") {
          return elem.defaultValue;
        }
      });
    } // Support: IE<9
    // Use getAttributeNode to fetch booleans when getAttribute lies


    if (!assert(function (el) {
      return el.getAttribute("disabled") == null;
    })) {
      addHandle(booleans, function (elem, name, isXML) {
        var val;

        if (!isXML) {
          return elem[name] === true ? name.toLowerCase() : (val = elem.getAttributeNode(name)) && val.specified ? val.value : null;
        }
      });
    }

    return Sizzle;
  }(window);

  jQuery.find = Sizzle;
  jQuery.expr = Sizzle.selectors; // Deprecated

  jQuery.expr[":"] = jQuery.expr.pseudos;
  jQuery.uniqueSort = jQuery.unique = Sizzle.uniqueSort;
  jQuery.text = Sizzle.getText;
  jQuery.isXMLDoc = Sizzle.isXML;
  jQuery.contains = Sizzle.contains;
  jQuery.escapeSelector = Sizzle.escape;

  var dir = function dir(elem, _dir, until) {
    var matched = [],
        truncate = until !== undefined;

    while ((elem = elem[_dir]) && elem.nodeType !== 9) {
      if (elem.nodeType === 1) {
        if (truncate && jQuery(elem).is(until)) {
          break;
        }

        matched.push(elem);
      }
    }

    return matched;
  };

  var _siblings = function siblings(n, elem) {
    var matched = [];

    for (; n; n = n.nextSibling) {
      if (n.nodeType === 1 && n !== elem) {
        matched.push(n);
      }
    }

    return matched;
  };

  var rneedsContext = jQuery.expr.match.needsContext;

  function nodeName(elem, name) {
    return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();
  }

  var rsingleTag = /^<([a-z][^\/\0>:\x20\t\r\n\f]*)[\x20\t\r\n\f]*\/?>(?:<\/\1>|)$/i; // Implement the identical functionality for filter and not

  function winnow(elements, qualifier, not) {
    if (isFunction(qualifier)) {
      return jQuery.grep(elements, function (elem, i) {
        return !!qualifier.call(elem, i, elem) !== not;
      });
    } // Single element


    if (qualifier.nodeType) {
      return jQuery.grep(elements, function (elem) {
        return elem === qualifier !== not;
      });
    } // Arraylike of elements (jQuery, arguments, Array)


    if (typeof qualifier !== "string") {
      return jQuery.grep(elements, function (elem) {
        return indexOf.call(qualifier, elem) > -1 !== not;
      });
    } // Filtered directly for both simple and complex selectors


    return jQuery.filter(qualifier, elements, not);
  }

  jQuery.filter = function (expr, elems, not) {
    var elem = elems[0];

    if (not) {
      expr = ":not(" + expr + ")";
    }

    if (elems.length === 1 && elem.nodeType === 1) {
      return jQuery.find.matchesSelector(elem, expr) ? [elem] : [];
    }

    return jQuery.find.matches(expr, jQuery.grep(elems, function (elem) {
      return elem.nodeType === 1;
    }));
  };

  jQuery.fn.extend({
    find: function find(selector) {
      var i,
          ret,
          len = this.length,
          self = this;

      if (typeof selector !== "string") {
        return this.pushStack(jQuery(selector).filter(function () {
          for (i = 0; i < len; i++) {
            if (jQuery.contains(self[i], this)) {
              return true;
            }
          }
        }));
      }

      ret = this.pushStack([]);

      for (i = 0; i < len; i++) {
        jQuery.find(selector, self[i], ret);
      }

      return len > 1 ? jQuery.uniqueSort(ret) : ret;
    },
    filter: function filter(selector) {
      return this.pushStack(winnow(this, selector || [], false));
    },
    not: function not(selector) {
      return this.pushStack(winnow(this, selector || [], true));
    },
    is: function is(selector) {
      return !!winnow(this, // If this is a positional/relative selector, check membership in the returned set
      // so $("p:first").is("p:last") won't return true for a doc with two "p".
      typeof selector === "string" && rneedsContext.test(selector) ? jQuery(selector) : selector || [], false).length;
    }
  }); // Initialize a jQuery object
  // A central reference to the root jQuery(document)

  var rootjQuery,
      // A simple way to check for HTML strings
  // Prioritize #id over <tag> to avoid XSS via location.hash (#9521)
  // Strict HTML recognition (#11290: must start with <)
  // Shortcut simple #id case for speed
  rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]+))$/,
      init = jQuery.fn.init = function (selector, context, root) {
    var match, elem; // HANDLE: $(""), $(null), $(undefined), $(false)

    if (!selector) {
      return this;
    } // Method init() accepts an alternate rootjQuery
    // so migrate can support jQuery.sub (gh-2101)


    root = root || rootjQuery; // Handle HTML strings

    if (typeof selector === "string") {
      if (selector[0] === "<" && selector[selector.length - 1] === ">" && selector.length >= 3) {
        // Assume that strings that start and end with <> are HTML and skip the regex check
        match = [null, selector, null];
      } else {
        match = rquickExpr.exec(selector);
      } // Match html or make sure no context is specified for #id


      if (match && (match[1] || !context)) {
        // HANDLE: $(html) -> $(array)
        if (match[1]) {
          context = context instanceof jQuery ? context[0] : context; // Option to run scripts is true for back-compat
          // Intentionally let the error be thrown if parseHTML is not present

          jQuery.merge(this, jQuery.parseHTML(match[1], context && context.nodeType ? context.ownerDocument || context : document, true)); // HANDLE: $(html, props)

          if (rsingleTag.test(match[1]) && jQuery.isPlainObject(context)) {
            for (match in context) {
              // Properties of context are called as methods if possible
              if (isFunction(this[match])) {
                this[match](context[match]); // ...and otherwise set as attributes
              } else {
                this.attr(match, context[match]);
              }
            }
          }

          return this; // HANDLE: $(#id)
        } else {
          elem = document.getElementById(match[2]);

          if (elem) {
            // Inject the element directly into the jQuery object
            this[0] = elem;
            this.length = 1;
          }

          return this;
        } // HANDLE: $(expr, $(...))

      } else if (!context || context.jquery) {
        return (context || root).find(selector); // HANDLE: $(expr, context)
        // (which is just equivalent to: $(context).find(expr)
      } else {
        return this.constructor(context).find(selector);
      } // HANDLE: $(DOMElement)

    } else if (selector.nodeType) {
      this[0] = selector;
      this.length = 1;
      return this; // HANDLE: $(function)
      // Shortcut for document ready
    } else if (isFunction(selector)) {
      return root.ready !== undefined ? root.ready(selector) : // Execute immediately if ready is not present
      selector(jQuery);
    }

    return jQuery.makeArray(selector, this);
  }; // Give the init function the jQuery prototype for later instantiation


  init.prototype = jQuery.fn; // Initialize central reference

  rootjQuery = jQuery(document);
  var rparentsprev = /^(?:parents|prev(?:Until|All))/,
      // Methods guaranteed to produce a unique set when starting from a unique set
  guaranteedUnique = {
    children: true,
    contents: true,
    next: true,
    prev: true
  };
  jQuery.fn.extend({
    has: function has(target) {
      var targets = jQuery(target, this),
          l = targets.length;
      return this.filter(function () {
        var i = 0;

        for (; i < l; i++) {
          if (jQuery.contains(this, targets[i])) {
            return true;
          }
        }
      });
    },
    closest: function closest(selectors, context) {
      var cur,
          i = 0,
          l = this.length,
          matched = [],
          targets = typeof selectors !== "string" && jQuery(selectors); // Positional selectors never match, since there's no _selection_ context

      if (!rneedsContext.test(selectors)) {
        for (; i < l; i++) {
          for (cur = this[i]; cur && cur !== context; cur = cur.parentNode) {
            // Always skip document fragments
            if (cur.nodeType < 11 && (targets ? targets.index(cur) > -1 : // Don't pass non-elements to Sizzle
            cur.nodeType === 1 && jQuery.find.matchesSelector(cur, selectors))) {
              matched.push(cur);
              break;
            }
          }
        }
      }

      return this.pushStack(matched.length > 1 ? jQuery.uniqueSort(matched) : matched);
    },
    // Determine the position of an element within the set
    index: function index(elem) {
      // No argument, return index in parent
      if (!elem) {
        return this[0] && this[0].parentNode ? this.first().prevAll().length : -1;
      } // Index in selector


      if (typeof elem === "string") {
        return indexOf.call(jQuery(elem), this[0]);
      } // Locate the position of the desired element


      return indexOf.call(this, // If it receives a jQuery object, the first element is used
      elem.jquery ? elem[0] : elem);
    },
    add: function add(selector, context) {
      return this.pushStack(jQuery.uniqueSort(jQuery.merge(this.get(), jQuery(selector, context))));
    },
    addBack: function addBack(selector) {
      return this.add(selector == null ? this.prevObject : this.prevObject.filter(selector));
    }
  });

  function sibling(cur, dir) {
    while ((cur = cur[dir]) && cur.nodeType !== 1) {}

    return cur;
  }

  jQuery.each({
    parent: function parent(elem) {
      var parent = elem.parentNode;
      return parent && parent.nodeType !== 11 ? parent : null;
    },
    parents: function parents(elem) {
      return dir(elem, "parentNode");
    },
    parentsUntil: function parentsUntil(elem, _i, until) {
      return dir(elem, "parentNode", until);
    },
    next: function next(elem) {
      return sibling(elem, "nextSibling");
    },
    prev: function prev(elem) {
      return sibling(elem, "previousSibling");
    },
    nextAll: function nextAll(elem) {
      return dir(elem, "nextSibling");
    },
    prevAll: function prevAll(elem) {
      return dir(elem, "previousSibling");
    },
    nextUntil: function nextUntil(elem, _i, until) {
      return dir(elem, "nextSibling", until);
    },
    prevUntil: function prevUntil(elem, _i, until) {
      return dir(elem, "previousSibling", until);
    },
    siblings: function siblings(elem) {
      return _siblings((elem.parentNode || {}).firstChild, elem);
    },
    children: function children(elem) {
      return _siblings(elem.firstChild);
    },
    contents: function contents(elem) {
      if (elem.contentDocument != null && // Support: IE 11+
      // <object> elements with no `data` attribute has an object
      // `contentDocument` with a `null` prototype.
      getProto(elem.contentDocument)) {
        return elem.contentDocument;
      } // Support: IE 9 - 11 only, iOS 7 only, Android Browser <=4.3 only
      // Treat the template element as a regular one in browsers that
      // don't support it.


      if (nodeName(elem, "template")) {
        elem = elem.content || elem;
      }

      return jQuery.merge([], elem.childNodes);
    }
  }, function (name, fn) {
    jQuery.fn[name] = function (until, selector) {
      var matched = jQuery.map(this, fn, until);

      if (name.slice(-5) !== "Until") {
        selector = until;
      }

      if (selector && typeof selector === "string") {
        matched = jQuery.filter(selector, matched);
      }

      if (this.length > 1) {
        // Remove duplicates
        if (!guaranteedUnique[name]) {
          jQuery.uniqueSort(matched);
        } // Reverse order for parents* and prev-derivatives


        if (rparentsprev.test(name)) {
          matched.reverse();
        }
      }

      return this.pushStack(matched);
    };
  });
  var rnothtmlwhite = /[^\x20\t\r\n\f]+/g; // Convert String-formatted options into Object-formatted ones

  function createOptions(options) {
    var object = {};
    jQuery.each(options.match(rnothtmlwhite) || [], function (_, flag) {
      object[flag] = true;
    });
    return object;
  }
  /*
   * Create a callback list using the following parameters:
   *
   *	options: an optional list of space-separated options that will change how
   *			the callback list behaves or a more traditional option object
   *
   * By default a callback list will act like an event callback list and can be
   * "fired" multiple times.
   *
   * Possible options:
   *
   *	once:			will ensure the callback list can only be fired once (like a Deferred)
   *
   *	memory:			will keep track of previous values and will call any callback added
   *					after the list has been fired right away with the latest "memorized"
   *					values (like a Deferred)
   *
   *	unique:			will ensure a callback can only be added once (no duplicate in the list)
   *
   *	stopOnFalse:	interrupt callings when a callback returns false
   *
   */


  jQuery.Callbacks = function (options) {
    // Convert options from String-formatted to Object-formatted if needed
    // (we check in cache first)
    options = typeof options === "string" ? createOptions(options) : jQuery.extend({}, options);

    var // Flag to know if list is currently firing
    firing,
        // Last fire value for non-forgettable lists
    memory,
        // Flag to know if list was already fired
    _fired,
        // Flag to prevent firing
    _locked,
        // Actual callback list
    list = [],
        // Queue of execution data for repeatable lists
    queue = [],
        // Index of currently firing callback (modified by add/remove as needed)
    firingIndex = -1,
        // Fire callbacks
    fire = function fire() {
      // Enforce single-firing
      _locked = _locked || options.once; // Execute callbacks for all pending executions,
      // respecting firingIndex overrides and runtime changes

      _fired = firing = true;

      for (; queue.length; firingIndex = -1) {
        memory = queue.shift();

        while (++firingIndex < list.length) {
          // Run callback and check for early termination
          if (list[firingIndex].apply(memory[0], memory[1]) === false && options.stopOnFalse) {
            // Jump to end and forget the data so .add doesn't re-fire
            firingIndex = list.length;
            memory = false;
          }
        }
      } // Forget the data if we're done with it


      if (!options.memory) {
        memory = false;
      }

      firing = false; // Clean up if we're done firing for good

      if (_locked) {
        // Keep an empty list if we have data for future add calls
        if (memory) {
          list = []; // Otherwise, this object is spent
        } else {
          list = "";
        }
      }
    },
        // Actual Callbacks object
    self = {
      // Add a callback or a collection of callbacks to the list
      add: function add() {
        if (list) {
          // If we have memory from a past run, we should fire after adding
          if (memory && !firing) {
            firingIndex = list.length - 1;
            queue.push(memory);
          }

          (function add(args) {
            jQuery.each(args, function (_, arg) {
              if (isFunction(arg)) {
                if (!options.unique || !self.has(arg)) {
                  list.push(arg);
                }
              } else if (arg && arg.length && toType(arg) !== "string") {
                // Inspect recursively
                add(arg);
              }
            });
          })(arguments);

          if (memory && !firing) {
            fire();
          }
        }

        return this;
      },
      // Remove a callback from the list
      remove: function remove() {
        jQuery.each(arguments, function (_, arg) {
          var index;

          while ((index = jQuery.inArray(arg, list, index)) > -1) {
            list.splice(index, 1); // Handle firing indexes

            if (index <= firingIndex) {
              firingIndex--;
            }
          }
        });
        return this;
      },
      // Check if a given callback is in the list.
      // If no argument is given, return whether or not list has callbacks attached.
      has: function has(fn) {
        return fn ? jQuery.inArray(fn, list) > -1 : list.length > 0;
      },
      // Remove all callbacks from the list
      empty: function empty() {
        if (list) {
          list = [];
        }

        return this;
      },
      // Disable .fire and .add
      // Abort any current/pending executions
      // Clear all callbacks and values
      disable: function disable() {
        _locked = queue = [];
        list = memory = "";
        return this;
      },
      disabled: function disabled() {
        return !list;
      },
      // Disable .fire
      // Also disable .add unless we have memory (since it would have no effect)
      // Abort any pending executions
      lock: function lock() {
        _locked = queue = [];

        if (!memory && !firing) {
          list = memory = "";
        }

        return this;
      },
      locked: function locked() {
        return !!_locked;
      },
      // Call all callbacks with the given context and arguments
      fireWith: function fireWith(context, args) {
        if (!_locked) {
          args = args || [];
          args = [context, args.slice ? args.slice() : args];
          queue.push(args);

          if (!firing) {
            fire();
          }
        }

        return this;
      },
      // Call all the callbacks with the given arguments
      fire: function fire() {
        self.fireWith(this, arguments);
        return this;
      },
      // To know if the callbacks have already been called at least once
      fired: function fired() {
        return !!_fired;
      }
    };

    return self;
  };

  function Identity(v) {
    return v;
  }

  function Thrower(ex) {
    throw ex;
  }

  function adoptValue(value, resolve, reject, noValue) {
    var method;

    try {
      // Check for promise aspect first to privilege synchronous behavior
      if (value && isFunction(method = value.promise)) {
        method.call(value).done(resolve).fail(reject); // Other thenables
      } else if (value && isFunction(method = value.then)) {
        method.call(value, resolve, reject); // Other non-thenables
      } else {
        // Control `resolve` arguments by letting Array#slice cast boolean `noValue` to integer:
        // * false: [ value ].slice( 0 ) => resolve( value )
        // * true: [ value ].slice( 1 ) => resolve()
        resolve.apply(undefined, [value].slice(noValue));
      } // For Promises/A+, convert exceptions into rejections
      // Since jQuery.when doesn't unwrap thenables, we can skip the extra checks appearing in
      // Deferred#then to conditionally suppress rejection.

    } catch (value) {
      // Support: Android 4.0 only
      // Strict mode functions invoked without .call/.apply get global-object context
      reject.apply(undefined, [value]);
    }
  }

  jQuery.extend({
    Deferred: function Deferred(func) {
      var tuples = [// action, add listener, callbacks,
      // ... .then handlers, argument index, [final state]
      ["notify", "progress", jQuery.Callbacks("memory"), jQuery.Callbacks("memory"), 2], ["resolve", "done", jQuery.Callbacks("once memory"), jQuery.Callbacks("once memory"), 0, "resolved"], ["reject", "fail", jQuery.Callbacks("once memory"), jQuery.Callbacks("once memory"), 1, "rejected"]],
          _state = "pending",
          _promise = {
        state: function state() {
          return _state;
        },
        always: function always() {
          deferred.done(arguments).fail(arguments);
          return this;
        },
        "catch": function _catch(fn) {
          return _promise.then(null, fn);
        },
        // Keep pipe for back-compat
        pipe: function
          /* fnDone, fnFail, fnProgress */
        pipe() {
          var fns = arguments;
          return jQuery.Deferred(function (newDefer) {
            jQuery.each(tuples, function (_i, tuple) {
              // Map tuples (progress, done, fail) to arguments (done, fail, progress)
              var fn = isFunction(fns[tuple[4]]) && fns[tuple[4]]; // deferred.progress(function() { bind to newDefer or newDefer.notify })
              // deferred.done(function() { bind to newDefer or newDefer.resolve })
              // deferred.fail(function() { bind to newDefer or newDefer.reject })

              deferred[tuple[1]](function () {
                var returned = fn && fn.apply(this, arguments);

                if (returned && isFunction(returned.promise)) {
                  returned.promise().progress(newDefer.notify).done(newDefer.resolve).fail(newDefer.reject);
                } else {
                  newDefer[tuple[0] + "With"](this, fn ? [returned] : arguments);
                }
              });
            });
            fns = null;
          }).promise();
        },
        then: function then(onFulfilled, onRejected, onProgress) {
          var maxDepth = 0;

          function resolve(depth, deferred, handler, special) {
            return function () {
              var that = this,
                  args = arguments,
                  mightThrow = function mightThrow() {
                var returned, then; // Support: Promises/A+ section 2.3.3.3.3
                // https://promisesaplus.com/#point-59
                // Ignore double-resolution attempts

                if (depth < maxDepth) {
                  return;
                }

                returned = handler.apply(that, args); // Support: Promises/A+ section 2.3.1
                // https://promisesaplus.com/#point-48

                if (returned === deferred.promise()) {
                  throw new TypeError("Thenable self-resolution");
                } // Support: Promises/A+ sections 2.3.3.1, 3.5
                // https://promisesaplus.com/#point-54
                // https://promisesaplus.com/#point-75
                // Retrieve `then` only once


                then = returned && ( // Support: Promises/A+ section 2.3.4
                // https://promisesaplus.com/#point-64
                // Only check objects and functions for thenability
                _typeof(returned) === "object" || typeof returned === "function") && returned.then; // Handle a returned thenable

                if (isFunction(then)) {
                  // Special processors (notify) just wait for resolution
                  if (special) {
                    then.call(returned, resolve(maxDepth, deferred, Identity, special), resolve(maxDepth, deferred, Thrower, special)); // Normal processors (resolve) also hook into progress
                  } else {
                    // ...and disregard older resolution values
                    maxDepth++;
                    then.call(returned, resolve(maxDepth, deferred, Identity, special), resolve(maxDepth, deferred, Thrower, special), resolve(maxDepth, deferred, Identity, deferred.notifyWith));
                  } // Handle all other returned values

                } else {
                  // Only substitute handlers pass on context
                  // and multiple values (non-spec behavior)
                  if (handler !== Identity) {
                    that = undefined;
                    args = [returned];
                  } // Process the value(s)
                  // Default process is resolve


                  (special || deferred.resolveWith)(that, args);
                }
              },
                  // Only normal processors (resolve) catch and reject exceptions
              process = special ? mightThrow : function () {
                try {
                  mightThrow();
                } catch (e) {
                  if (jQuery.Deferred.exceptionHook) {
                    jQuery.Deferred.exceptionHook(e, process.stackTrace);
                  } // Support: Promises/A+ section 2.3.3.3.4.1
                  // https://promisesaplus.com/#point-61
                  // Ignore post-resolution exceptions


                  if (depth + 1 >= maxDepth) {
                    // Only substitute handlers pass on context
                    // and multiple values (non-spec behavior)
                    if (handler !== Thrower) {
                      that = undefined;
                      args = [e];
                    }

                    deferred.rejectWith(that, args);
                  }
                }
              }; // Support: Promises/A+ section 2.3.3.3.1
              // https://promisesaplus.com/#point-57
              // Re-resolve promises immediately to dodge false rejection from
              // subsequent errors


              if (depth) {
                process();
              } else {
                // Call an optional hook to record the stack, in case of exception
                // since it's otherwise lost when execution goes async
                if (jQuery.Deferred.getStackHook) {
                  process.stackTrace = jQuery.Deferred.getStackHook();
                }

                window.setTimeout(process);
              }
            };
          }

          return jQuery.Deferred(function (newDefer) {
            // progress_handlers.add( ... )
            tuples[0][3].add(resolve(0, newDefer, isFunction(onProgress) ? onProgress : Identity, newDefer.notifyWith)); // fulfilled_handlers.add( ... )

            tuples[1][3].add(resolve(0, newDefer, isFunction(onFulfilled) ? onFulfilled : Identity)); // rejected_handlers.add( ... )

            tuples[2][3].add(resolve(0, newDefer, isFunction(onRejected) ? onRejected : Thrower));
          }).promise();
        },
        // Get a promise for this deferred
        // If obj is provided, the promise aspect is added to the object
        promise: function promise(obj) {
          return obj != null ? jQuery.extend(obj, _promise) : _promise;
        }
      },
          deferred = {}; // Add list-specific methods

      jQuery.each(tuples, function (i, tuple) {
        var list = tuple[2],
            stateString = tuple[5]; // promise.progress = list.add
        // promise.done = list.add
        // promise.fail = list.add

        _promise[tuple[1]] = list.add; // Handle state

        if (stateString) {
          list.add(function () {
            // state = "resolved" (i.e., fulfilled)
            // state = "rejected"
            _state = stateString;
          }, // rejected_callbacks.disable
          // fulfilled_callbacks.disable
          tuples[3 - i][2].disable, // rejected_handlers.disable
          // fulfilled_handlers.disable
          tuples[3 - i][3].disable, // progress_callbacks.lock
          tuples[0][2].lock, // progress_handlers.lock
          tuples[0][3].lock);
        } // progress_handlers.fire
        // fulfilled_handlers.fire
        // rejected_handlers.fire


        list.add(tuple[3].fire); // deferred.notify = function() { deferred.notifyWith(...) }
        // deferred.resolve = function() { deferred.resolveWith(...) }
        // deferred.reject = function() { deferred.rejectWith(...) }

        deferred[tuple[0]] = function () {
          deferred[tuple[0] + "With"](this === deferred ? undefined : this, arguments);
          return this;
        }; // deferred.notifyWith = list.fireWith
        // deferred.resolveWith = list.fireWith
        // deferred.rejectWith = list.fireWith


        deferred[tuple[0] + "With"] = list.fireWith;
      }); // Make the deferred a promise

      _promise.promise(deferred); // Call given func if any


      if (func) {
        func.call(deferred, deferred);
      } // All done!


      return deferred;
    },
    // Deferred helper
    when: function when(singleValue) {
      var // count of uncompleted subordinates
      remaining = arguments.length,
          // count of unprocessed arguments
      i = remaining,
          // subordinate fulfillment data
      resolveContexts = Array(i),
          resolveValues = _slice.call(arguments),
          // the primary Deferred
      primary = jQuery.Deferred(),
          // subordinate callback factory
      updateFunc = function updateFunc(i) {
        return function (value) {
          resolveContexts[i] = this;
          resolveValues[i] = arguments.length > 1 ? _slice.call(arguments) : value;

          if (! --remaining) {
            primary.resolveWith(resolveContexts, resolveValues);
          }
        };
      }; // Single- and empty arguments are adopted like Promise.resolve


      if (remaining <= 1) {
        adoptValue(singleValue, primary.done(updateFunc(i)).resolve, primary.reject, !remaining); // Use .then() to unwrap secondary thenables (cf. gh-3000)

        if (primary.state() === "pending" || isFunction(resolveValues[i] && resolveValues[i].then)) {
          return primary.then();
        }
      } // Multiple arguments are aggregated like Promise.all array elements


      while (i--) {
        adoptValue(resolveValues[i], updateFunc(i), primary.reject);
      }

      return primary.promise();
    }
  }); // These usually indicate a programmer mistake during development,
  // warn about them ASAP rather than swallowing them by default.

  var rerrorNames = /^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;

  jQuery.Deferred.exceptionHook = function (error, stack) {
    // Support: IE 8 - 9 only
    // Console exists when dev tools are open, which can happen at any time
    if (window.console && window.console.warn && error && rerrorNames.test(error.name)) {
      window.console.warn("jQuery.Deferred exception: " + error.message, error.stack, stack);
    }
  };

  jQuery.readyException = function (error) {
    window.setTimeout(function () {
      throw error;
    });
  }; // The deferred used on DOM ready


  var readyList = jQuery.Deferred();

  jQuery.fn.ready = function (fn) {
    readyList.then(fn) // Wrap jQuery.readyException in a function so that the lookup
    // happens at the time of error handling instead of callback
    // registration.
    ["catch"](function (error) {
      jQuery.readyException(error);
    });
    return this;
  };

  jQuery.extend({
    // Is the DOM ready to be used? Set to true once it occurs.
    isReady: false,
    // A counter to track how many items to wait for before
    // the ready event fires. See #6781
    readyWait: 1,
    // Handle when the DOM is ready
    ready: function ready(wait) {
      // Abort if there are pending holds or we're already ready
      if (wait === true ? --jQuery.readyWait : jQuery.isReady) {
        return;
      } // Remember that the DOM is ready


      jQuery.isReady = true; // If a normal DOM Ready event fired, decrement, and wait if need be

      if (wait !== true && --jQuery.readyWait > 0) {
        return;
      } // If there are functions bound, to execute


      readyList.resolveWith(document, [jQuery]);
    }
  });
  jQuery.ready.then = readyList.then; // The ready event handler and self cleanup method

  function completed() {
    document.removeEventListener("DOMContentLoaded", completed);
    window.removeEventListener("load", completed);
    jQuery.ready();
  } // Catch cases where $(document).ready() is called
  // after the browser event has already occurred.
  // Support: IE <=9 - 10 only
  // Older IE sometimes signals "interactive" too soon


  if (document.readyState === "complete" || document.readyState !== "loading" && !document.documentElement.doScroll) {
    // Handle it asynchronously to allow scripts the opportunity to delay ready
    window.setTimeout(jQuery.ready);
  } else {
    // Use the handy event callback
    document.addEventListener("DOMContentLoaded", completed); // A fallback to window.onload, that will always work

    window.addEventListener("load", completed);
  } // Multifunctional method to get and set values of a collection
  // The value/s can optionally be executed if it's a function


  var access = function access(elems, fn, key, value, chainable, emptyGet, raw) {
    var i = 0,
        len = elems.length,
        bulk = key == null; // Sets many values

    if (toType(key) === "object") {
      chainable = true;

      for (i in key) {
        access(elems, fn, i, key[i], true, emptyGet, raw);
      } // Sets one value

    } else if (value !== undefined) {
      chainable = true;

      if (!isFunction(value)) {
        raw = true;
      }

      if (bulk) {
        // Bulk operations run against the entire set
        if (raw) {
          fn.call(elems, value);
          fn = null; // ...except when executing function values
        } else {
          bulk = fn;

          fn = function fn(elem, _key, value) {
            return bulk.call(jQuery(elem), value);
          };
        }
      }

      if (fn) {
        for (; i < len; i++) {
          fn(elems[i], key, raw ? value : value.call(elems[i], i, fn(elems[i], key)));
        }
      }
    }

    if (chainable) {
      return elems;
    } // Gets


    if (bulk) {
      return fn.call(elems);
    }

    return len ? fn(elems[0], key) : emptyGet;
  }; // Matches dashed string for camelizing


  var rmsPrefix = /^-ms-/,
      rdashAlpha = /-([a-z])/g; // Used by camelCase as callback to replace()

  function fcamelCase(_all, letter) {
    return letter.toUpperCase();
  } // Convert dashed to camelCase; used by the css and data modules
  // Support: IE <=9 - 11, Edge 12 - 15
  // Microsoft forgot to hump their vendor prefix (#9572)


  function camelCase(string) {
    return string.replace(rmsPrefix, "ms-").replace(rdashAlpha, fcamelCase);
  }

  var acceptData = function acceptData(owner) {
    // Accepts only:
    //  - Node
    //    - Node.ELEMENT_NODE
    //    - Node.DOCUMENT_NODE
    //  - Object
    //    - Any
    return owner.nodeType === 1 || owner.nodeType === 9 || !+owner.nodeType;
  };

  function Data() {
    this.expando = jQuery.expando + Data.uid++;
  }

  Data.uid = 1;
  Data.prototype = {
    cache: function cache(owner) {
      // Check if the owner object already has a cache
      var value = owner[this.expando]; // If not, create one

      if (!value) {
        value = {}; // We can accept data for non-element nodes in modern browsers,
        // but we should not, see #8335.
        // Always return an empty object.

        if (acceptData(owner)) {
          // If it is a node unlikely to be stringify-ed or looped over
          // use plain assignment
          if (owner.nodeType) {
            owner[this.expando] = value; // Otherwise secure it in a non-enumerable property
            // configurable must be true to allow the property to be
            // deleted when data is removed
          } else {
            Object.defineProperty(owner, this.expando, {
              value: value,
              configurable: true
            });
          }
        }
      }

      return value;
    },
    set: function set(owner, data, value) {
      var prop,
          cache = this.cache(owner); // Handle: [ owner, key, value ] args
      // Always use camelCase key (gh-2257)

      if (typeof data === "string") {
        cache[camelCase(data)] = value; // Handle: [ owner, { properties } ] args
      } else {
        // Copy the properties one-by-one to the cache object
        for (prop in data) {
          cache[camelCase(prop)] = data[prop];
        }
      }

      return cache;
    },
    get: function get(owner, key) {
      return key === undefined ? this.cache(owner) : // Always use camelCase key (gh-2257)
      owner[this.expando] && owner[this.expando][camelCase(key)];
    },
    access: function access(owner, key, value) {
      // In cases where either:
      //
      //   1. No key was specified
      //   2. A string key was specified, but no value provided
      //
      // Take the "read" path and allow the get method to determine
      // which value to return, respectively either:
      //
      //   1. The entire cache object
      //   2. The data stored at the key
      //
      if (key === undefined || key && typeof key === "string" && value === undefined) {
        return this.get(owner, key);
      } // When the key is not a string, or both a key and value
      // are specified, set or extend (existing objects) with either:
      //
      //   1. An object of properties
      //   2. A key and value
      //


      this.set(owner, key, value); // Since the "set" path can have two possible entry points
      // return the expected data based on which path was taken[*]

      return value !== undefined ? value : key;
    },
    remove: function remove(owner, key) {
      var i,
          cache = owner[this.expando];

      if (cache === undefined) {
        return;
      }

      if (key !== undefined) {
        // Support array or space separated string of keys
        if (Array.isArray(key)) {
          // If key is an array of keys...
          // We always set camelCase keys, so remove that.
          key = key.map(camelCase);
        } else {
          key = camelCase(key); // If a key with the spaces exists, use it.
          // Otherwise, create an array by matching non-whitespace

          key = key in cache ? [key] : key.match(rnothtmlwhite) || [];
        }

        i = key.length;

        while (i--) {
          delete cache[key[i]];
        }
      } // Remove the expando if there's no more data


      if (key === undefined || jQuery.isEmptyObject(cache)) {
        // Support: Chrome <=35 - 45
        // Webkit & Blink performance suffers when deleting properties
        // from DOM nodes, so set to undefined instead
        // https://bugs.chromium.org/p/chromium/issues/detail?id=378607 (bug restricted)
        if (owner.nodeType) {
          owner[this.expando] = undefined;
        } else {
          delete owner[this.expando];
        }
      }
    },
    hasData: function hasData(owner) {
      var cache = owner[this.expando];
      return cache !== undefined && !jQuery.isEmptyObject(cache);
    }
  };
  var dataPriv = new Data();
  var dataUser = new Data(); //	Implementation Summary
  //
  //	1. Enforce API surface and semantic compatibility with 1.9.x branch
  //	2. Improve the module's maintainability by reducing the storage
  //		paths to a single mechanism.
  //	3. Use the same single mechanism to support "private" and "user" data.
  //	4. _Never_ expose "private" data to user code (TODO: Drop _data, _removeData)
  //	5. Avoid exposing implementation details on user objects (eg. expando properties)
  //	6. Provide a clear path for implementation upgrade to WeakMap in 2014

  var rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,
      rmultiDash = /[A-Z]/g;

  function getData(data) {
    if (data === "true") {
      return true;
    }

    if (data === "false") {
      return false;
    }

    if (data === "null") {
      return null;
    } // Only convert to a number if it doesn't change the string


    if (data === +data + "") {
      return +data;
    }

    if (rbrace.test(data)) {
      return JSON.parse(data);
    }

    return data;
  }

  function dataAttr(elem, key, data) {
    var name; // If nothing was found internally, try to fetch any
    // data from the HTML5 data-* attribute

    if (data === undefined && elem.nodeType === 1) {
      name = "data-" + key.replace(rmultiDash, "-$&").toLowerCase();
      data = elem.getAttribute(name);

      if (typeof data === "string") {
        try {
          data = getData(data);
        } catch (e) {} // Make sure we set the data so it isn't changed later


        dataUser.set(elem, key, data);
      } else {
        data = undefined;
      }
    }

    return data;
  }

  jQuery.extend({
    hasData: function hasData(elem) {
      return dataUser.hasData(elem) || dataPriv.hasData(elem);
    },
    data: function data(elem, name, _data) {
      return dataUser.access(elem, name, _data);
    },
    removeData: function removeData(elem, name) {
      dataUser.remove(elem, name);
    },
    // TODO: Now that all calls to _data and _removeData have been replaced
    // with direct calls to dataPriv methods, these can be deprecated.
    _data: function _data(elem, name, data) {
      return dataPriv.access(elem, name, data);
    },
    _removeData: function _removeData(elem, name) {
      dataPriv.remove(elem, name);
    }
  });
  jQuery.fn.extend({
    data: function data(key, value) {
      var i,
          name,
          data,
          elem = this[0],
          attrs = elem && elem.attributes; // Gets all values

      if (key === undefined) {
        if (this.length) {
          data = dataUser.get(elem);

          if (elem.nodeType === 1 && !dataPriv.get(elem, "hasDataAttrs")) {
            i = attrs.length;

            while (i--) {
              // Support: IE 11 only
              // The attrs elements can be null (#14894)
              if (attrs[i]) {
                name = attrs[i].name;

                if (name.indexOf("data-") === 0) {
                  name = camelCase(name.slice(5));
                  dataAttr(elem, name, data[name]);
                }
              }
            }

            dataPriv.set(elem, "hasDataAttrs", true);
          }
        }

        return data;
      } // Sets multiple values


      if (_typeof(key) === "object") {
        return this.each(function () {
          dataUser.set(this, key);
        });
      }

      return access(this, function (value) {
        var data; // The calling jQuery object (element matches) is not empty
        // (and therefore has an element appears at this[ 0 ]) and the
        // `value` parameter was not undefined. An empty jQuery object
        // will result in `undefined` for elem = this[ 0 ] which will
        // throw an exception if an attempt to read a data cache is made.

        if (elem && value === undefined) {
          // Attempt to get data from the cache
          // The key will always be camelCased in Data
          data = dataUser.get(elem, key);

          if (data !== undefined) {
            return data;
          } // Attempt to "discover" the data in
          // HTML5 custom data-* attrs


          data = dataAttr(elem, key);

          if (data !== undefined) {
            return data;
          } // We tried really hard, but the data doesn't exist.


          return;
        } // Set the data...


        this.each(function () {
          // We always store the camelCased key
          dataUser.set(this, key, value);
        });
      }, null, value, arguments.length > 1, null, true);
    },
    removeData: function removeData(key) {
      return this.each(function () {
        dataUser.remove(this, key);
      });
    }
  });
  jQuery.extend({
    queue: function queue(elem, type, data) {
      var queue;

      if (elem) {
        type = (type || "fx") + "queue";
        queue = dataPriv.get(elem, type); // Speed up dequeue by getting out quickly if this is just a lookup

        if (data) {
          if (!queue || Array.isArray(data)) {
            queue = dataPriv.access(elem, type, jQuery.makeArray(data));
          } else {
            queue.push(data);
          }
        }

        return queue || [];
      }
    },
    dequeue: function dequeue(elem, type) {
      type = type || "fx";

      var queue = jQuery.queue(elem, type),
          startLength = queue.length,
          fn = queue.shift(),
          hooks = jQuery._queueHooks(elem, type),
          next = function next() {
        jQuery.dequeue(elem, type);
      }; // If the fx queue is dequeued, always remove the progress sentinel


      if (fn === "inprogress") {
        fn = queue.shift();
        startLength--;
      }

      if (fn) {
        // Add a progress sentinel to prevent the fx queue from being
        // automatically dequeued
        if (type === "fx") {
          queue.unshift("inprogress");
        } // Clear up the last queue stop function


        delete hooks.stop;
        fn.call(elem, next, hooks);
      }

      if (!startLength && hooks) {
        hooks.empty.fire();
      }
    },
    // Not public - generate a queueHooks object, or return the current one
    _queueHooks: function _queueHooks(elem, type) {
      var key = type + "queueHooks";
      return dataPriv.get(elem, key) || dataPriv.access(elem, key, {
        empty: jQuery.Callbacks("once memory").add(function () {
          dataPriv.remove(elem, [type + "queue", key]);
        })
      });
    }
  });
  jQuery.fn.extend({
    queue: function queue(type, data) {
      var setter = 2;

      if (typeof type !== "string") {
        data = type;
        type = "fx";
        setter--;
      }

      if (arguments.length < setter) {
        return jQuery.queue(this[0], type);
      }

      return data === undefined ? this : this.each(function () {
        var queue = jQuery.queue(this, type, data); // Ensure a hooks for this queue

        jQuery._queueHooks(this, type);

        if (type === "fx" && queue[0] !== "inprogress") {
          jQuery.dequeue(this, type);
        }
      });
    },
    dequeue: function dequeue(type) {
      return this.each(function () {
        jQuery.dequeue(this, type);
      });
    },
    clearQueue: function clearQueue(type) {
      return this.queue(type || "fx", []);
    },
    // Get a promise resolved when queues of a certain type
    // are emptied (fx is the type by default)
    promise: function promise(type, obj) {
      var tmp,
          count = 1,
          defer = jQuery.Deferred(),
          elements = this,
          i = this.length,
          resolve = function resolve() {
        if (! --count) {
          defer.resolveWith(elements, [elements]);
        }
      };

      if (typeof type !== "string") {
        obj = type;
        type = undefined;
      }

      type = type || "fx";

      while (i--) {
        tmp = dataPriv.get(elements[i], type + "queueHooks");

        if (tmp && tmp.empty) {
          count++;
          tmp.empty.add(resolve);
        }
      }

      resolve();
      return defer.promise(obj);
    }
  });
  var pnum = /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source;
  var rcssNum = new RegExp("^(?:([+-])=|)(" + pnum + ")([a-z%]*)$", "i");
  var cssExpand = ["Top", "Right", "Bottom", "Left"];
  var documentElement = document.documentElement;

  var isAttached = function isAttached(elem) {
    return jQuery.contains(elem.ownerDocument, elem);
  },
      composed = {
    composed: true
  }; // Support: IE 9 - 11+, Edge 12 - 18+, iOS 10.0 - 10.2 only
  // Check attachment across shadow DOM boundaries when possible (gh-3504)
  // Support: iOS 10.0-10.2 only
  // Early iOS 10 versions support `attachShadow` but not `getRootNode`,
  // leading to errors. We need to check for `getRootNode`.


  if (documentElement.getRootNode) {
    isAttached = function isAttached(elem) {
      return jQuery.contains(elem.ownerDocument, elem) || elem.getRootNode(composed) === elem.ownerDocument;
    };
  }

  var isHiddenWithinTree = function isHiddenWithinTree(elem, el) {
    // isHiddenWithinTree might be called from jQuery#filter function;
    // in that case, element will be second argument
    elem = el || elem; // Inline style trumps all

    return elem.style.display === "none" || elem.style.display === "" && // Otherwise, check computed style
    // Support: Firefox <=43 - 45
    // Disconnected elements can have computed display: none, so first confirm that elem is
    // in the document.
    isAttached(elem) && jQuery.css(elem, "display") === "none";
  };

  function adjustCSS(elem, prop, valueParts, tween) {
    var adjusted,
        scale,
        maxIterations = 20,
        currentValue = tween ? function () {
      return tween.cur();
    } : function () {
      return jQuery.css(elem, prop, "");
    },
        initial = currentValue(),
        unit = valueParts && valueParts[3] || (jQuery.cssNumber[prop] ? "" : "px"),
        // Starting value computation is required for potential unit mismatches
    initialInUnit = elem.nodeType && (jQuery.cssNumber[prop] || unit !== "px" && +initial) && rcssNum.exec(jQuery.css(elem, prop));

    if (initialInUnit && initialInUnit[3] !== unit) {
      // Support: Firefox <=54
      // Halve the iteration target value to prevent interference from CSS upper bounds (gh-2144)
      initial = initial / 2; // Trust units reported by jQuery.css

      unit = unit || initialInUnit[3]; // Iteratively approximate from a nonzero starting point

      initialInUnit = +initial || 1;

      while (maxIterations--) {
        // Evaluate and update our best guess (doubling guesses that zero out).
        // Finish if the scale equals or crosses 1 (making the old*new product non-positive).
        jQuery.style(elem, prop, initialInUnit + unit);

        if ((1 - scale) * (1 - (scale = currentValue() / initial || 0.5)) <= 0) {
          maxIterations = 0;
        }

        initialInUnit = initialInUnit / scale;
      }

      initialInUnit = initialInUnit * 2;
      jQuery.style(elem, prop, initialInUnit + unit); // Make sure we update the tween properties later on

      valueParts = valueParts || [];
    }

    if (valueParts) {
      initialInUnit = +initialInUnit || +initial || 0; // Apply relative offset (+=/-=) if specified

      adjusted = valueParts[1] ? initialInUnit + (valueParts[1] + 1) * valueParts[2] : +valueParts[2];

      if (tween) {
        tween.unit = unit;
        tween.start = initialInUnit;
        tween.end = adjusted;
      }
    }

    return adjusted;
  }

  var defaultDisplayMap = {};

  function getDefaultDisplay(elem) {
    var temp,
        doc = elem.ownerDocument,
        nodeName = elem.nodeName,
        display = defaultDisplayMap[nodeName];

    if (display) {
      return display;
    }

    temp = doc.body.appendChild(doc.createElement(nodeName));
    display = jQuery.css(temp, "display");
    temp.parentNode.removeChild(temp);

    if (display === "none") {
      display = "block";
    }

    defaultDisplayMap[nodeName] = display;
    return display;
  }

  function showHide(elements, show) {
    var display,
        elem,
        values = [],
        index = 0,
        length = elements.length; // Determine new display value for elements that need to change

    for (; index < length; index++) {
      elem = elements[index];

      if (!elem.style) {
        continue;
      }

      display = elem.style.display;

      if (show) {
        // Since we force visibility upon cascade-hidden elements, an immediate (and slow)
        // check is required in this first loop unless we have a nonempty display value (either
        // inline or about-to-be-restored)
        if (display === "none") {
          values[index] = dataPriv.get(elem, "display") || null;

          if (!values[index]) {
            elem.style.display = "";
          }
        }

        if (elem.style.display === "" && isHiddenWithinTree(elem)) {
          values[index] = getDefaultDisplay(elem);
        }
      } else {
        if (display !== "none") {
          values[index] = "none"; // Remember what we're overwriting

          dataPriv.set(elem, "display", display);
        }
      }
    } // Set the display of the elements in a second loop to avoid constant reflow


    for (index = 0; index < length; index++) {
      if (values[index] != null) {
        elements[index].style.display = values[index];
      }
    }

    return elements;
  }

  jQuery.fn.extend({
    show: function show() {
      return showHide(this, true);
    },
    hide: function hide() {
      return showHide(this);
    },
    toggle: function toggle(state) {
      if (typeof state === "boolean") {
        return state ? this.show() : this.hide();
      }

      return this.each(function () {
        if (isHiddenWithinTree(this)) {
          jQuery(this).show();
        } else {
          jQuery(this).hide();
        }
      });
    }
  });
  var rcheckableType = /^(?:checkbox|radio)$/i;
  var rtagName = /<([a-z][^\/\0>\x20\t\r\n\f]*)/i;
  var rscriptType = /^$|^module$|\/(?:java|ecma)script/i;

  (function () {
    var fragment = document.createDocumentFragment(),
        div = fragment.appendChild(document.createElement("div")),
        input = document.createElement("input"); // Support: Android 4.0 - 4.3 only
    // Check state lost if the name is set (#11217)
    // Support: Windows Web Apps (WWA)
    // `name` and `type` must use .setAttribute for WWA (#14901)

    input.setAttribute("type", "radio");
    input.setAttribute("checked", "checked");
    input.setAttribute("name", "t");
    div.appendChild(input); // Support: Android <=4.1 only
    // Older WebKit doesn't clone checked state correctly in fragments

    support.checkClone = div.cloneNode(true).cloneNode(true).lastChild.checked; // Support: IE <=11 only
    // Make sure textarea (and checkbox) defaultValue is properly cloned

    div.innerHTML = "<textarea>x</textarea>";
    support.noCloneChecked = !!div.cloneNode(true).lastChild.defaultValue; // Support: IE <=9 only
    // IE <=9 replaces <option> tags with their contents when inserted outside of
    // the select element.

    div.innerHTML = "<option></option>";
    support.option = !!div.lastChild;
  })(); // We have to close these tags to support XHTML (#13200)


  var wrapMap = {
    // XHTML parsers do not magically insert elements in the
    // same way that tag soup parsers do. So we cannot shorten
    // this by omitting <tbody> or other required elements.
    thead: [1, "<table>", "</table>"],
    col: [2, "<table><colgroup>", "</colgroup></table>"],
    tr: [2, "<table><tbody>", "</tbody></table>"],
    td: [3, "<table><tbody><tr>", "</tr></tbody></table>"],
    _default: [0, "", ""]
  };
  wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
  wrapMap.th = wrapMap.td; // Support: IE <=9 only

  if (!support.option) {
    wrapMap.optgroup = wrapMap.option = [1, "<select multiple='multiple'>", "</select>"];
  }

  function getAll(context, tag) {
    // Support: IE <=9 - 11 only
    // Use typeof to avoid zero-argument method invocation on host objects (#15151)
    var ret;

    if (typeof context.getElementsByTagName !== "undefined") {
      ret = context.getElementsByTagName(tag || "*");
    } else if (typeof context.querySelectorAll !== "undefined") {
      ret = context.querySelectorAll(tag || "*");
    } else {
      ret = [];
    }

    if (tag === undefined || tag && nodeName(context, tag)) {
      return jQuery.merge([context], ret);
    }

    return ret;
  } // Mark scripts as having already been evaluated


  function setGlobalEval(elems, refElements) {
    var i = 0,
        l = elems.length;

    for (; i < l; i++) {
      dataPriv.set(elems[i], "globalEval", !refElements || dataPriv.get(refElements[i], "globalEval"));
    }
  }

  var rhtml = /<|&#?\w+;/;

  function buildFragment(elems, context, scripts, selection, ignored) {
    var elem,
        tmp,
        tag,
        wrap,
        attached,
        j,
        fragment = context.createDocumentFragment(),
        nodes = [],
        i = 0,
        l = elems.length;

    for (; i < l; i++) {
      elem = elems[i];

      if (elem || elem === 0) {
        // Add nodes directly
        if (toType(elem) === "object") {
          // Support: Android <=4.0 only, PhantomJS 1 only
          // push.apply(_, arraylike) throws on ancient WebKit
          jQuery.merge(nodes, elem.nodeType ? [elem] : elem); // Convert non-html into a text node
        } else if (!rhtml.test(elem)) {
          nodes.push(context.createTextNode(elem)); // Convert html into DOM nodes
        } else {
          tmp = tmp || fragment.appendChild(context.createElement("div")); // Deserialize a standard representation

          tag = (rtagName.exec(elem) || ["", ""])[1].toLowerCase();
          wrap = wrapMap[tag] || wrapMap._default;
          tmp.innerHTML = wrap[1] + jQuery.htmlPrefilter(elem) + wrap[2]; // Descend through wrappers to the right content

          j = wrap[0];

          while (j--) {
            tmp = tmp.lastChild;
          } // Support: Android <=4.0 only, PhantomJS 1 only
          // push.apply(_, arraylike) throws on ancient WebKit


          jQuery.merge(nodes, tmp.childNodes); // Remember the top-level container

          tmp = fragment.firstChild; // Ensure the created nodes are orphaned (#12392)

          tmp.textContent = "";
        }
      }
    } // Remove wrapper from fragment


    fragment.textContent = "";
    i = 0;

    while (elem = nodes[i++]) {
      // Skip elements already in the context collection (trac-4087)
      if (selection && jQuery.inArray(elem, selection) > -1) {
        if (ignored) {
          ignored.push(elem);
        }

        continue;
      }

      attached = isAttached(elem); // Append to fragment

      tmp = getAll(fragment.appendChild(elem), "script"); // Preserve script evaluation history

      if (attached) {
        setGlobalEval(tmp);
      } // Capture executables


      if (scripts) {
        j = 0;

        while (elem = tmp[j++]) {
          if (rscriptType.test(elem.type || "")) {
            scripts.push(elem);
          }
        }
      }
    }

    return fragment;
  }

  var rtypenamespace = /^([^.]*)(?:\.(.+)|)/;

  function returnTrue() {
    return true;
  }

  function returnFalse() {
    return false;
  } // Support: IE <=9 - 11+
  // focus() and blur() are asynchronous, except when they are no-op.
  // So expect focus to be synchronous when the element is already active,
  // and blur to be synchronous when the element is not already active.
  // (focus and blur are always synchronous in other supported browsers,
  // this just defines when we can count on it).


  function expectSync(elem, type) {
    return elem === safeActiveElement() === (type === "focus");
  } // Support: IE <=9 only
  // Accessing document.activeElement can throw unexpectedly
  // https://bugs.jquery.com/ticket/13393


  function safeActiveElement() {
    try {
      return document.activeElement;
    } catch (err) {}
  }

  function _on(elem, types, selector, data, fn, one) {
    var origFn, type; // Types can be a map of types/handlers

    if (_typeof(types) === "object") {
      // ( types-Object, selector, data )
      if (typeof selector !== "string") {
        // ( types-Object, data )
        data = data || selector;
        selector = undefined;
      }

      for (type in types) {
        _on(elem, type, selector, data, types[type], one);
      }

      return elem;
    }

    if (data == null && fn == null) {
      // ( types, fn )
      fn = selector;
      data = selector = undefined;
    } else if (fn == null) {
      if (typeof selector === "string") {
        // ( types, selector, fn )
        fn = data;
        data = undefined;
      } else {
        // ( types, data, fn )
        fn = data;
        data = selector;
        selector = undefined;
      }
    }

    if (fn === false) {
      fn = returnFalse;
    } else if (!fn) {
      return elem;
    }

    if (one === 1) {
      origFn = fn;

      fn = function fn(event) {
        // Can use an empty set, since event contains the info
        jQuery().off(event);
        return origFn.apply(this, arguments);
      }; // Use same guid so caller can remove using origFn


      fn.guid = origFn.guid || (origFn.guid = jQuery.guid++);
    }

    return elem.each(function () {
      jQuery.event.add(this, types, fn, data, selector);
    });
  }
  /*
   * Helper functions for managing events -- not part of the public interface.
   * Props to Dean Edwards' addEvent library for many of the ideas.
   */


  jQuery.event = {
    global: {},
    add: function add(elem, types, handler, data, selector) {
      var handleObjIn,
          eventHandle,
          tmp,
          events,
          t,
          handleObj,
          special,
          handlers,
          type,
          namespaces,
          origType,
          elemData = dataPriv.get(elem); // Only attach events to objects that accept data

      if (!acceptData(elem)) {
        return;
      } // Caller can pass in an object of custom data in lieu of the handler


      if (handler.handler) {
        handleObjIn = handler;
        handler = handleObjIn.handler;
        selector = handleObjIn.selector;
      } // Ensure that invalid selectors throw exceptions at attach time
      // Evaluate against documentElement in case elem is a non-element node (e.g., document)


      if (selector) {
        jQuery.find.matchesSelector(documentElement, selector);
      } // Make sure that the handler has a unique ID, used to find/remove it later


      if (!handler.guid) {
        handler.guid = jQuery.guid++;
      } // Init the element's event structure and main handler, if this is the first


      if (!(events = elemData.events)) {
        events = elemData.events = Object.create(null);
      }

      if (!(eventHandle = elemData.handle)) {
        eventHandle = elemData.handle = function (e) {
          // Discard the second event of a jQuery.event.trigger() and
          // when an event is called after a page has unloaded
          return typeof jQuery !== "undefined" && jQuery.event.triggered !== e.type ? jQuery.event.dispatch.apply(elem, arguments) : undefined;
        };
      } // Handle multiple events separated by a space


      types = (types || "").match(rnothtmlwhite) || [""];
      t = types.length;

      while (t--) {
        tmp = rtypenamespace.exec(types[t]) || [];
        type = origType = tmp[1];
        namespaces = (tmp[2] || "").split(".").sort(); // There *must* be a type, no attaching namespace-only handlers

        if (!type) {
          continue;
        } // If event changes its type, use the special event handlers for the changed type


        special = jQuery.event.special[type] || {}; // If selector defined, determine special event api type, otherwise given type

        type = (selector ? special.delegateType : special.bindType) || type; // Update special based on newly reset type

        special = jQuery.event.special[type] || {}; // handleObj is passed to all event handlers

        handleObj = jQuery.extend({
          type: type,
          origType: origType,
          data: data,
          handler: handler,
          guid: handler.guid,
          selector: selector,
          needsContext: selector && jQuery.expr.match.needsContext.test(selector),
          namespace: namespaces.join(".")
        }, handleObjIn); // Init the event handler queue if we're the first

        if (!(handlers = events[type])) {
          handlers = events[type] = [];
          handlers.delegateCount = 0; // Only use addEventListener if the special events handler returns false

          if (!special.setup || special.setup.call(elem, data, namespaces, eventHandle) === false) {
            if (elem.addEventListener) {
              elem.addEventListener(type, eventHandle);
            }
          }
        }

        if (special.add) {
          special.add.call(elem, handleObj);

          if (!handleObj.handler.guid) {
            handleObj.handler.guid = handler.guid;
          }
        } // Add to the element's handler list, delegates in front


        if (selector) {
          handlers.splice(handlers.delegateCount++, 0, handleObj);
        } else {
          handlers.push(handleObj);
        } // Keep track of which events have ever been used, for event optimization


        jQuery.event.global[type] = true;
      }
    },
    // Detach an event or set of events from an element
    remove: function remove(elem, types, handler, selector, mappedTypes) {
      var j,
          origCount,
          tmp,
          events,
          t,
          handleObj,
          special,
          handlers,
          type,
          namespaces,
          origType,
          elemData = dataPriv.hasData(elem) && dataPriv.get(elem);

      if (!elemData || !(events = elemData.events)) {
        return;
      } // Once for each type.namespace in types; type may be omitted


      types = (types || "").match(rnothtmlwhite) || [""];
      t = types.length;

      while (t--) {
        tmp = rtypenamespace.exec(types[t]) || [];
        type = origType = tmp[1];
        namespaces = (tmp[2] || "").split(".").sort(); // Unbind all events (on this namespace, if provided) for the element

        if (!type) {
          for (type in events) {
            jQuery.event.remove(elem, type + types[t], handler, selector, true);
          }

          continue;
        }

        special = jQuery.event.special[type] || {};
        type = (selector ? special.delegateType : special.bindType) || type;
        handlers = events[type] || [];
        tmp = tmp[2] && new RegExp("(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)"); // Remove matching events

        origCount = j = handlers.length;

        while (j--) {
          handleObj = handlers[j];

          if ((mappedTypes || origType === handleObj.origType) && (!handler || handler.guid === handleObj.guid) && (!tmp || tmp.test(handleObj.namespace)) && (!selector || selector === handleObj.selector || selector === "**" && handleObj.selector)) {
            handlers.splice(j, 1);

            if (handleObj.selector) {
              handlers.delegateCount--;
            }

            if (special.remove) {
              special.remove.call(elem, handleObj);
            }
          }
        } // Remove generic event handler if we removed something and no more handlers exist
        // (avoids potential for endless recursion during removal of special event handlers)


        if (origCount && !handlers.length) {
          if (!special.teardown || special.teardown.call(elem, namespaces, elemData.handle) === false) {
            jQuery.removeEvent(elem, type, elemData.handle);
          }

          delete events[type];
        }
      } // Remove data and the expando if it's no longer used


      if (jQuery.isEmptyObject(events)) {
        dataPriv.remove(elem, "handle events");
      }
    },
    dispatch: function dispatch(nativeEvent) {
      var i,
          j,
          ret,
          matched,
          handleObj,
          handlerQueue,
          args = new Array(arguments.length),
          // Make a writable jQuery.Event from the native event object
      event = jQuery.event.fix(nativeEvent),
          handlers = (dataPriv.get(this, "events") || Object.create(null))[event.type] || [],
          special = jQuery.event.special[event.type] || {}; // Use the fix-ed jQuery.Event rather than the (read-only) native event

      args[0] = event;

      for (i = 1; i < arguments.length; i++) {
        args[i] = arguments[i];
      }

      event.delegateTarget = this; // Call the preDispatch hook for the mapped type, and let it bail if desired

      if (special.preDispatch && special.preDispatch.call(this, event) === false) {
        return;
      } // Determine handlers


      handlerQueue = jQuery.event.handlers.call(this, event, handlers); // Run delegates first; they may want to stop propagation beneath us

      i = 0;

      while ((matched = handlerQueue[i++]) && !event.isPropagationStopped()) {
        event.currentTarget = matched.elem;
        j = 0;

        while ((handleObj = matched.handlers[j++]) && !event.isImmediatePropagationStopped()) {
          // If the event is namespaced, then each handler is only invoked if it is
          // specially universal or its namespaces are a superset of the event's.
          if (!event.rnamespace || handleObj.namespace === false || event.rnamespace.test(handleObj.namespace)) {
            event.handleObj = handleObj;
            event.data = handleObj.data;
            ret = ((jQuery.event.special[handleObj.origType] || {}).handle || handleObj.handler).apply(matched.elem, args);

            if (ret !== undefined) {
              if ((event.result = ret) === false) {
                event.preventDefault();
                event.stopPropagation();
              }
            }
          }
        }
      } // Call the postDispatch hook for the mapped type


      if (special.postDispatch) {
        special.postDispatch.call(this, event);
      }

      return event.result;
    },
    handlers: function handlers(event, _handlers) {
      var i,
          handleObj,
          sel,
          matchedHandlers,
          matchedSelectors,
          handlerQueue = [],
          delegateCount = _handlers.delegateCount,
          cur = event.target; // Find delegate handlers

      if (delegateCount && // Support: IE <=9
      // Black-hole SVG <use> instance trees (trac-13180)
      cur.nodeType && // Support: Firefox <=42
      // Suppress spec-violating clicks indicating a non-primary pointer button (trac-3861)
      // https://www.w3.org/TR/DOM-Level-3-Events/#event-type-click
      // Support: IE 11 only
      // ...but not arrow key "clicks" of radio inputs, which can have `button` -1 (gh-2343)
      !(event.type === "click" && event.button >= 1)) {
        for (; cur !== this; cur = cur.parentNode || this) {
          // Don't check non-elements (#13208)
          // Don't process clicks on disabled elements (#6911, #8165, #11382, #11764)
          if (cur.nodeType === 1 && !(event.type === "click" && cur.disabled === true)) {
            matchedHandlers = [];
            matchedSelectors = {};

            for (i = 0; i < delegateCount; i++) {
              handleObj = _handlers[i]; // Don't conflict with Object.prototype properties (#13203)

              sel = handleObj.selector + " ";

              if (matchedSelectors[sel] === undefined) {
                matchedSelectors[sel] = handleObj.needsContext ? jQuery(sel, this).index(cur) > -1 : jQuery.find(sel, this, null, [cur]).length;
              }

              if (matchedSelectors[sel]) {
                matchedHandlers.push(handleObj);
              }
            }

            if (matchedHandlers.length) {
              handlerQueue.push({
                elem: cur,
                handlers: matchedHandlers
              });
            }
          }
        }
      } // Add the remaining (directly-bound) handlers


      cur = this;

      if (delegateCount < _handlers.length) {
        handlerQueue.push({
          elem: cur,
          handlers: _handlers.slice(delegateCount)
        });
      }

      return handlerQueue;
    },
    addProp: function addProp(name, hook) {
      Object.defineProperty(jQuery.Event.prototype, name, {
        enumerable: true,
        configurable: true,
        get: isFunction(hook) ? function () {
          if (this.originalEvent) {
            return hook(this.originalEvent);
          }
        } : function () {
          if (this.originalEvent) {
            return this.originalEvent[name];
          }
        },
        set: function set(value) {
          Object.defineProperty(this, name, {
            enumerable: true,
            configurable: true,
            writable: true,
            value: value
          });
        }
      });
    },
    fix: function fix(originalEvent) {
      return originalEvent[jQuery.expando] ? originalEvent : new jQuery.Event(originalEvent);
    },
    special: {
      load: {
        // Prevent triggered image.load events from bubbling to window.load
        noBubble: true
      },
      click: {
        // Utilize native event to ensure correct state for checkable inputs
        setup: function setup(data) {
          // For mutual compressibility with _default, replace `this` access with a local var.
          // `|| data` is dead code meant only to preserve the variable through minification.
          var el = this || data; // Claim the first handler

          if (rcheckableType.test(el.type) && el.click && nodeName(el, "input")) {
            // dataPriv.set( el, "click", ... )
            leverageNative(el, "click", returnTrue);
          } // Return false to allow normal processing in the caller


          return false;
        },
        trigger: function trigger(data) {
          // For mutual compressibility with _default, replace `this` access with a local var.
          // `|| data` is dead code meant only to preserve the variable through minification.
          var el = this || data; // Force setup before triggering a click

          if (rcheckableType.test(el.type) && el.click && nodeName(el, "input")) {
            leverageNative(el, "click");
          } // Return non-false to allow normal event-path propagation


          return true;
        },
        // For cross-browser consistency, suppress native .click() on links
        // Also prevent it if we're currently inside a leveraged native-event stack
        _default: function _default(event) {
          var target = event.target;
          return rcheckableType.test(target.type) && target.click && nodeName(target, "input") && dataPriv.get(target, "click") || nodeName(target, "a");
        }
      },
      beforeunload: {
        postDispatch: function postDispatch(event) {
          // Support: Firefox 20+
          // Firefox doesn't alert if the returnValue field is not set.
          if (event.result !== undefined && event.originalEvent) {
            event.originalEvent.returnValue = event.result;
          }
        }
      }
    }
  }; // Ensure the presence of an event listener that handles manually-triggered
  // synthetic events by interrupting progress until reinvoked in response to
  // *native* events that it fires directly, ensuring that state changes have
  // already occurred before other listeners are invoked.

  function leverageNative(el, type, expectSync) {
    // Missing expectSync indicates a trigger call, which must force setup through jQuery.event.add
    if (!expectSync) {
      if (dataPriv.get(el, type) === undefined) {
        jQuery.event.add(el, type, returnTrue);
      }

      return;
    } // Register the controller as a special universal handler for all event namespaces


    dataPriv.set(el, type, false);
    jQuery.event.add(el, type, {
      namespace: false,
      handler: function handler(event) {
        var notAsync,
            result,
            saved = dataPriv.get(this, type);

        if (event.isTrigger & 1 && this[type]) {
          // Interrupt processing of the outer synthetic .trigger()ed event
          // Saved data should be false in such cases, but might be a leftover capture object
          // from an async native handler (gh-4350)
          if (!saved.length) {
            // Store arguments for use when handling the inner native event
            // There will always be at least one argument (an event object), so this array
            // will not be confused with a leftover capture object.
            saved = _slice.call(arguments);
            dataPriv.set(this, type, saved); // Trigger the native event and capture its result
            // Support: IE <=9 - 11+
            // focus() and blur() are asynchronous

            notAsync = expectSync(this, type);
            this[type]();
            result = dataPriv.get(this, type);

            if (saved !== result || notAsync) {
              dataPriv.set(this, type, false);
            } else {
              result = {};
            }

            if (saved !== result) {
              // Cancel the outer synthetic event
              event.stopImmediatePropagation();
              event.preventDefault(); // Support: Chrome 86+
              // In Chrome, if an element having a focusout handler is blurred by
              // clicking outside of it, it invokes the handler synchronously. If
              // that handler calls `.remove()` on the element, the data is cleared,
              // leaving `result` undefined. We need to guard against this.

              return result && result.value;
            } // If this is an inner synthetic event for an event with a bubbling surrogate
            // (focus or blur), assume that the surrogate already propagated from triggering the
            // native event and prevent that from happening again here.
            // This technically gets the ordering wrong w.r.t. to `.trigger()` (in which the
            // bubbling surrogate propagates *after* the non-bubbling base), but that seems
            // less bad than duplication.

          } else if ((jQuery.event.special[type] || {}).delegateType) {
            event.stopPropagation();
          } // If this is a native event triggered above, everything is now in order
          // Fire an inner synthetic event with the original arguments

        } else if (saved.length) {
          // ...and capture the result
          dataPriv.set(this, type, {
            value: jQuery.event.trigger( // Support: IE <=9 - 11+
            // Extend with the prototype to reset the above stopImmediatePropagation()
            jQuery.extend(saved[0], jQuery.Event.prototype), saved.slice(1), this)
          }); // Abort handling of the native event

          event.stopImmediatePropagation();
        }
      }
    });
  }

  jQuery.removeEvent = function (elem, type, handle) {
    // This "if" is needed for plain objects
    if (elem.removeEventListener) {
      elem.removeEventListener(type, handle);
    }
  };

  jQuery.Event = function (src, props) {
    // Allow instantiation without the 'new' keyword
    if (!(this instanceof jQuery.Event)) {
      return new jQuery.Event(src, props);
    } // Event object


    if (src && src.type) {
      this.originalEvent = src;
      this.type = src.type; // Events bubbling up the document may have been marked as prevented
      // by a handler lower down the tree; reflect the correct value.

      this.isDefaultPrevented = src.defaultPrevented || src.defaultPrevented === undefined && // Support: Android <=2.3 only
      src.returnValue === false ? returnTrue : returnFalse; // Create target properties
      // Support: Safari <=6 - 7 only
      // Target should not be a text node (#504, #13143)

      this.target = src.target && src.target.nodeType === 3 ? src.target.parentNode : src.target;
      this.currentTarget = src.currentTarget;
      this.relatedTarget = src.relatedTarget; // Event type
    } else {
      this.type = src;
    } // Put explicitly provided properties onto the event object


    if (props) {
      jQuery.extend(this, props);
    } // Create a timestamp if incoming event doesn't have one


    this.timeStamp = src && src.timeStamp || Date.now(); // Mark it as fixed

    this[jQuery.expando] = true;
  }; // jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding
  // https://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html


  jQuery.Event.prototype = {
    constructor: jQuery.Event,
    isDefaultPrevented: returnFalse,
    isPropagationStopped: returnFalse,
    isImmediatePropagationStopped: returnFalse,
    isSimulated: false,
    preventDefault: function preventDefault() {
      var e = this.originalEvent;
      this.isDefaultPrevented = returnTrue;

      if (e && !this.isSimulated) {
        e.preventDefault();
      }
    },
    stopPropagation: function stopPropagation() {
      var e = this.originalEvent;
      this.isPropagationStopped = returnTrue;

      if (e && !this.isSimulated) {
        e.stopPropagation();
      }
    },
    stopImmediatePropagation: function stopImmediatePropagation() {
      var e = this.originalEvent;
      this.isImmediatePropagationStopped = returnTrue;

      if (e && !this.isSimulated) {
        e.stopImmediatePropagation();
      }

      this.stopPropagation();
    }
  }; // Includes all common event props including KeyEvent and MouseEvent specific props

  jQuery.each({
    altKey: true,
    bubbles: true,
    cancelable: true,
    changedTouches: true,
    ctrlKey: true,
    detail: true,
    eventPhase: true,
    metaKey: true,
    pageX: true,
    pageY: true,
    shiftKey: true,
    view: true,
    "char": true,
    code: true,
    charCode: true,
    key: true,
    keyCode: true,
    button: true,
    buttons: true,
    clientX: true,
    clientY: true,
    offsetX: true,
    offsetY: true,
    pointerId: true,
    pointerType: true,
    screenX: true,
    screenY: true,
    targetTouches: true,
    toElement: true,
    touches: true,
    which: true
  }, jQuery.event.addProp);
  jQuery.each({
    focus: "focusin",
    blur: "focusout"
  }, function (type, delegateType) {
    jQuery.event.special[type] = {
      // Utilize native event if possible so blur/focus sequence is correct
      setup: function setup() {
        // Claim the first handler
        // dataPriv.set( this, "focus", ... )
        // dataPriv.set( this, "blur", ... )
        leverageNative(this, type, expectSync); // Return false to allow normal processing in the caller

        return false;
      },
      trigger: function trigger() {
        // Force setup before trigger
        leverageNative(this, type); // Return non-false to allow normal event-path propagation

        return true;
      },
      // Suppress native focus or blur as it's already being fired
      // in leverageNative.
      _default: function _default() {
        return true;
      },
      delegateType: delegateType
    };
  }); // Create mouseenter/leave events using mouseover/out and event-time checks
  // so that event delegation works in jQuery.
  // Do the same for pointerenter/pointerleave and pointerover/pointerout
  //
  // Support: Safari 7 only
  // Safari sends mouseenter too often; see:
  // https://bugs.chromium.org/p/chromium/issues/detail?id=470258
  // for the description of the bug (it existed in older Chrome versions as well).

  jQuery.each({
    mouseenter: "mouseover",
    mouseleave: "mouseout",
    pointerenter: "pointerover",
    pointerleave: "pointerout"
  }, function (orig, fix) {
    jQuery.event.special[orig] = {
      delegateType: fix,
      bindType: fix,
      handle: function handle(event) {
        var ret,
            target = this,
            related = event.relatedTarget,
            handleObj = event.handleObj; // For mouseenter/leave call the handler if related is outside the target.
        // NB: No relatedTarget if the mouse left/entered the browser window

        if (!related || related !== target && !jQuery.contains(target, related)) {
          event.type = handleObj.origType;
          ret = handleObj.handler.apply(this, arguments);
          event.type = fix;
        }

        return ret;
      }
    };
  });
  jQuery.fn.extend({
    on: function on(types, selector, data, fn) {
      return _on(this, types, selector, data, fn);
    },
    one: function one(types, selector, data, fn) {
      return _on(this, types, selector, data, fn, 1);
    },
    off: function off(types, selector, fn) {
      var handleObj, type;

      if (types && types.preventDefault && types.handleObj) {
        // ( event )  dispatched jQuery.Event
        handleObj = types.handleObj;
        jQuery(types.delegateTarget).off(handleObj.namespace ? handleObj.origType + "." + handleObj.namespace : handleObj.origType, handleObj.selector, handleObj.handler);
        return this;
      }

      if (_typeof(types) === "object") {
        // ( types-object [, selector] )
        for (type in types) {
          this.off(type, selector, types[type]);
        }

        return this;
      }

      if (selector === false || typeof selector === "function") {
        // ( types [, fn] )
        fn = selector;
        selector = undefined;
      }

      if (fn === false) {
        fn = returnFalse;
      }

      return this.each(function () {
        jQuery.event.remove(this, types, fn, selector);
      });
    }
  });
  var // Support: IE <=10 - 11, Edge 12 - 13 only
  // In IE/Edge using regex groups here causes severe slowdowns.
  // See https://connect.microsoft.com/IE/feedback/details/1736512/
  rnoInnerhtml = /<script|<style|<link/i,
      // checked="checked" or checked
  rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,
      rcleanScript = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g; // Prefer a tbody over its parent table for containing new rows

  function manipulationTarget(elem, content) {
    if (nodeName(elem, "table") && nodeName(content.nodeType !== 11 ? content : content.firstChild, "tr")) {
      return jQuery(elem).children("tbody")[0] || elem;
    }

    return elem;
  } // Replace/restore the type attribute of script elements for safe DOM manipulation


  function disableScript(elem) {
    elem.type = (elem.getAttribute("type") !== null) + "/" + elem.type;
    return elem;
  }

  function restoreScript(elem) {
    if ((elem.type || "").slice(0, 5) === "true/") {
      elem.type = elem.type.slice(5);
    } else {
      elem.removeAttribute("type");
    }

    return elem;
  }

  function cloneCopyEvent(src, dest) {
    var i, l, type, pdataOld, udataOld, udataCur, events;

    if (dest.nodeType !== 1) {
      return;
    } // 1. Copy private data: events, handlers, etc.


    if (dataPriv.hasData(src)) {
      pdataOld = dataPriv.get(src);
      events = pdataOld.events;

      if (events) {
        dataPriv.remove(dest, "handle events");

        for (type in events) {
          for (i = 0, l = events[type].length; i < l; i++) {
            jQuery.event.add(dest, type, events[type][i]);
          }
        }
      }
    } // 2. Copy user data


    if (dataUser.hasData(src)) {
      udataOld = dataUser.access(src);
      udataCur = jQuery.extend({}, udataOld);
      dataUser.set(dest, udataCur);
    }
  } // Fix IE bugs, see support tests


  function fixInput(src, dest) {
    var nodeName = dest.nodeName.toLowerCase(); // Fails to persist the checked state of a cloned checkbox or radio button.

    if (nodeName === "input" && rcheckableType.test(src.type)) {
      dest.checked = src.checked; // Fails to return the selected option to the default selected state when cloning options
    } else if (nodeName === "input" || nodeName === "textarea") {
      dest.defaultValue = src.defaultValue;
    }
  }

  function domManip(collection, args, callback, ignored) {
    // Flatten any nested arrays
    args = flat(args);
    var fragment,
        first,
        scripts,
        hasScripts,
        node,
        doc,
        i = 0,
        l = collection.length,
        iNoClone = l - 1,
        value = args[0],
        valueIsFunction = isFunction(value); // We can't cloneNode fragments that contain checked, in WebKit

    if (valueIsFunction || l > 1 && typeof value === "string" && !support.checkClone && rchecked.test(value)) {
      return collection.each(function (index) {
        var self = collection.eq(index);

        if (valueIsFunction) {
          args[0] = value.call(this, index, self.html());
        }

        domManip(self, args, callback, ignored);
      });
    }

    if (l) {
      fragment = buildFragment(args, collection[0].ownerDocument, false, collection, ignored);
      first = fragment.firstChild;

      if (fragment.childNodes.length === 1) {
        fragment = first;
      } // Require either new content or an interest in ignored elements to invoke the callback


      if (first || ignored) {
        scripts = jQuery.map(getAll(fragment, "script"), disableScript);
        hasScripts = scripts.length; // Use the original fragment for the last item
        // instead of the first because it can end up
        // being emptied incorrectly in certain situations (#8070).

        for (; i < l; i++) {
          node = fragment;

          if (i !== iNoClone) {
            node = jQuery.clone(node, true, true); // Keep references to cloned scripts for later restoration

            if (hasScripts) {
              // Support: Android <=4.0 only, PhantomJS 1 only
              // push.apply(_, arraylike) throws on ancient WebKit
              jQuery.merge(scripts, getAll(node, "script"));
            }
          }

          callback.call(collection[i], node, i);
        }

        if (hasScripts) {
          doc = scripts[scripts.length - 1].ownerDocument; // Reenable scripts

          jQuery.map(scripts, restoreScript); // Evaluate executable scripts on first document insertion

          for (i = 0; i < hasScripts; i++) {
            node = scripts[i];

            if (rscriptType.test(node.type || "") && !dataPriv.access(node, "globalEval") && jQuery.contains(doc, node)) {
              if (node.src && (node.type || "").toLowerCase() !== "module") {
                // Optional AJAX dependency, but won't run scripts if not present
                if (jQuery._evalUrl && !node.noModule) {
                  jQuery._evalUrl(node.src, {
                    nonce: node.nonce || node.getAttribute("nonce")
                  }, doc);
                }
              } else {
                DOMEval(node.textContent.replace(rcleanScript, ""), node, doc);
              }
            }
          }
        }
      }
    }

    return collection;
  }

  function _remove(elem, selector, keepData) {
    var node,
        nodes = selector ? jQuery.filter(selector, elem) : elem,
        i = 0;

    for (; (node = nodes[i]) != null; i++) {
      if (!keepData && node.nodeType === 1) {
        jQuery.cleanData(getAll(node));
      }

      if (node.parentNode) {
        if (keepData && isAttached(node)) {
          setGlobalEval(getAll(node, "script"));
        }

        node.parentNode.removeChild(node);
      }
    }

    return elem;
  }

  jQuery.extend({
    htmlPrefilter: function htmlPrefilter(html) {
      return html;
    },
    clone: function clone(elem, dataAndEvents, deepDataAndEvents) {
      var i,
          l,
          srcElements,
          destElements,
          clone = elem.cloneNode(true),
          inPage = isAttached(elem); // Fix IE cloning issues

      if (!support.noCloneChecked && (elem.nodeType === 1 || elem.nodeType === 11) && !jQuery.isXMLDoc(elem)) {
        // We eschew Sizzle here for performance reasons: https://jsperf.com/getall-vs-sizzle/2
        destElements = getAll(clone);
        srcElements = getAll(elem);

        for (i = 0, l = srcElements.length; i < l; i++) {
          fixInput(srcElements[i], destElements[i]);
        }
      } // Copy the events from the original to the clone


      if (dataAndEvents) {
        if (deepDataAndEvents) {
          srcElements = srcElements || getAll(elem);
          destElements = destElements || getAll(clone);

          for (i = 0, l = srcElements.length; i < l; i++) {
            cloneCopyEvent(srcElements[i], destElements[i]);
          }
        } else {
          cloneCopyEvent(elem, clone);
        }
      } // Preserve script evaluation history


      destElements = getAll(clone, "script");

      if (destElements.length > 0) {
        setGlobalEval(destElements, !inPage && getAll(elem, "script"));
      } // Return the cloned set


      return clone;
    },
    cleanData: function cleanData(elems) {
      var data,
          elem,
          type,
          special = jQuery.event.special,
          i = 0;

      for (; (elem = elems[i]) !== undefined; i++) {
        if (acceptData(elem)) {
          if (data = elem[dataPriv.expando]) {
            if (data.events) {
              for (type in data.events) {
                if (special[type]) {
                  jQuery.event.remove(elem, type); // This is a shortcut to avoid jQuery.event.remove's overhead
                } else {
                  jQuery.removeEvent(elem, type, data.handle);
                }
              }
            } // Support: Chrome <=35 - 45+
            // Assign undefined instead of using delete, see Data#remove


            elem[dataPriv.expando] = undefined;
          }

          if (elem[dataUser.expando]) {
            // Support: Chrome <=35 - 45+
            // Assign undefined instead of using delete, see Data#remove
            elem[dataUser.expando] = undefined;
          }
        }
      }
    }
  });
  jQuery.fn.extend({
    detach: function detach(selector) {
      return _remove(this, selector, true);
    },
    remove: function remove(selector) {
      return _remove(this, selector);
    },
    text: function text(value) {
      return access(this, function (value) {
        return value === undefined ? jQuery.text(this) : this.empty().each(function () {
          if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
            this.textContent = value;
          }
        });
      }, null, value, arguments.length);
    },
    append: function append() {
      return domManip(this, arguments, function (elem) {
        if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
          var target = manipulationTarget(this, elem);
          target.appendChild(elem);
        }
      });
    },
    prepend: function prepend() {
      return domManip(this, arguments, function (elem) {
        if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
          var target = manipulationTarget(this, elem);
          target.insertBefore(elem, target.firstChild);
        }
      });
    },
    before: function before() {
      return domManip(this, arguments, function (elem) {
        if (this.parentNode) {
          this.parentNode.insertBefore(elem, this);
        }
      });
    },
    after: function after() {
      return domManip(this, arguments, function (elem) {
        if (this.parentNode) {
          this.parentNode.insertBefore(elem, this.nextSibling);
        }
      });
    },
    empty: function empty() {
      var elem,
          i = 0;

      for (; (elem = this[i]) != null; i++) {
        if (elem.nodeType === 1) {
          // Prevent memory leaks
          jQuery.cleanData(getAll(elem, false)); // Remove any remaining nodes

          elem.textContent = "";
        }
      }

      return this;
    },
    clone: function clone(dataAndEvents, deepDataAndEvents) {
      dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
      deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;
      return this.map(function () {
        return jQuery.clone(this, dataAndEvents, deepDataAndEvents);
      });
    },
    html: function html(value) {
      return access(this, function (value) {
        var elem = this[0] || {},
            i = 0,
            l = this.length;

        if (value === undefined && elem.nodeType === 1) {
          return elem.innerHTML;
        } // See if we can take a shortcut and just use innerHTML


        if (typeof value === "string" && !rnoInnerhtml.test(value) && !wrapMap[(rtagName.exec(value) || ["", ""])[1].toLowerCase()]) {
          value = jQuery.htmlPrefilter(value);

          try {
            for (; i < l; i++) {
              elem = this[i] || {}; // Remove element nodes and prevent memory leaks

              if (elem.nodeType === 1) {
                jQuery.cleanData(getAll(elem, false));
                elem.innerHTML = value;
              }
            }

            elem = 0; // If using innerHTML throws an exception, use the fallback method
          } catch (e) {}
        }

        if (elem) {
          this.empty().append(value);
        }
      }, null, value, arguments.length);
    },
    replaceWith: function replaceWith() {
      var ignored = []; // Make the changes, replacing each non-ignored context element with the new content

      return domManip(this, arguments, function (elem) {
        var parent = this.parentNode;

        if (jQuery.inArray(this, ignored) < 0) {
          jQuery.cleanData(getAll(this));

          if (parent) {
            parent.replaceChild(elem, this);
          }
        } // Force callback invocation

      }, ignored);
    }
  });
  jQuery.each({
    appendTo: "append",
    prependTo: "prepend",
    insertBefore: "before",
    insertAfter: "after",
    replaceAll: "replaceWith"
  }, function (name, original) {
    jQuery.fn[name] = function (selector) {
      var elems,
          ret = [],
          insert = jQuery(selector),
          last = insert.length - 1,
          i = 0;

      for (; i <= last; i++) {
        elems = i === last ? this : this.clone(true);
        jQuery(insert[i])[original](elems); // Support: Android <=4.0 only, PhantomJS 1 only
        // .get() because push.apply(_, arraylike) throws on ancient WebKit

        push.apply(ret, elems.get());
      }

      return this.pushStack(ret);
    };
  });
  var rnumnonpx = new RegExp("^(" + pnum + ")(?!px)[a-z%]+$", "i");

  var getStyles = function getStyles(elem) {
    // Support: IE <=11 only, Firefox <=30 (#15098, #14150)
    // IE throws on elements created in popups
    // FF meanwhile throws on frame elements through "defaultView.getComputedStyle"
    var view = elem.ownerDocument.defaultView;

    if (!view || !view.opener) {
      view = window;
    }

    return view.getComputedStyle(elem);
  };

  var swap = function swap(elem, options, callback) {
    var ret,
        name,
        old = {}; // Remember the old values, and insert the new ones

    for (name in options) {
      old[name] = elem.style[name];
      elem.style[name] = options[name];
    }

    ret = callback.call(elem); // Revert the old values

    for (name in options) {
      elem.style[name] = old[name];
    }

    return ret;
  };

  var rboxStyle = new RegExp(cssExpand.join("|"), "i");

  (function () {
    // Executing both pixelPosition & boxSizingReliable tests require only one layout
    // so they're executed at the same time to save the second computation.
    function computeStyleTests() {
      // This is a singleton, we need to execute it only once
      if (!div) {
        return;
      }

      container.style.cssText = "position:absolute;left:-11111px;width:60px;" + "margin-top:1px;padding:0;border:0";
      div.style.cssText = "position:relative;display:block;box-sizing:border-box;overflow:scroll;" + "margin:auto;border:1px;padding:1px;" + "width:60%;top:1%";
      documentElement.appendChild(container).appendChild(div);
      var divStyle = window.getComputedStyle(div);
      pixelPositionVal = divStyle.top !== "1%"; // Support: Android 4.0 - 4.3 only, Firefox <=3 - 44

      reliableMarginLeftVal = roundPixelMeasures(divStyle.marginLeft) === 12; // Support: Android 4.0 - 4.3 only, Safari <=9.1 - 10.1, iOS <=7.0 - 9.3
      // Some styles come back with percentage values, even though they shouldn't

      div.style.right = "60%";
      pixelBoxStylesVal = roundPixelMeasures(divStyle.right) === 36; // Support: IE 9 - 11 only
      // Detect misreporting of content dimensions for box-sizing:border-box elements

      boxSizingReliableVal = roundPixelMeasures(divStyle.width) === 36; // Support: IE 9 only
      // Detect overflow:scroll screwiness (gh-3699)
      // Support: Chrome <=64
      // Don't get tricked when zoom affects offsetWidth (gh-4029)

      div.style.position = "absolute";
      scrollboxSizeVal = roundPixelMeasures(div.offsetWidth / 3) === 12;
      documentElement.removeChild(container); // Nullify the div so it wouldn't be stored in the memory and
      // it will also be a sign that checks already performed

      div = null;
    }

    function roundPixelMeasures(measure) {
      return Math.round(parseFloat(measure));
    }

    var pixelPositionVal,
        boxSizingReliableVal,
        scrollboxSizeVal,
        pixelBoxStylesVal,
        reliableTrDimensionsVal,
        reliableMarginLeftVal,
        container = document.createElement("div"),
        div = document.createElement("div"); // Finish early in limited (non-browser) environments

    if (!div.style) {
      return;
    } // Support: IE <=9 - 11 only
    // Style of cloned element affects source element cloned (#8908)


    div.style.backgroundClip = "content-box";
    div.cloneNode(true).style.backgroundClip = "";
    support.clearCloneStyle = div.style.backgroundClip === "content-box";
    jQuery.extend(support, {
      boxSizingReliable: function boxSizingReliable() {
        computeStyleTests();
        return boxSizingReliableVal;
      },
      pixelBoxStyles: function pixelBoxStyles() {
        computeStyleTests();
        return pixelBoxStylesVal;
      },
      pixelPosition: function pixelPosition() {
        computeStyleTests();
        return pixelPositionVal;
      },
      reliableMarginLeft: function reliableMarginLeft() {
        computeStyleTests();
        return reliableMarginLeftVal;
      },
      scrollboxSize: function scrollboxSize() {
        computeStyleTests();
        return scrollboxSizeVal;
      },
      // Support: IE 9 - 11+, Edge 15 - 18+
      // IE/Edge misreport `getComputedStyle` of table rows with width/height
      // set in CSS while `offset*` properties report correct values.
      // Behavior in IE 9 is more subtle than in newer versions & it passes
      // some versions of this test; make sure not to make it pass there!
      //
      // Support: Firefox 70+
      // Only Firefox includes border widths
      // in computed dimensions. (gh-4529)
      reliableTrDimensions: function reliableTrDimensions() {
        var table, tr, trChild, trStyle;

        if (reliableTrDimensionsVal == null) {
          table = document.createElement("table");
          tr = document.createElement("tr");
          trChild = document.createElement("div");
          table.style.cssText = "position:absolute;left:-11111px;border-collapse:separate";
          tr.style.cssText = "border:1px solid"; // Support: Chrome 86+
          // Height set through cssText does not get applied.
          // Computed height then comes back as 0.

          tr.style.height = "1px";
          trChild.style.height = "9px"; // Support: Android 8 Chrome 86+
          // In our bodyBackground.html iframe,
          // display for all div elements is set to "inline",
          // which causes a problem only in Android 8 Chrome 86.
          // Ensuring the div is display: block
          // gets around this issue.

          trChild.style.display = "block";
          documentElement.appendChild(table).appendChild(tr).appendChild(trChild);
          trStyle = window.getComputedStyle(tr);
          reliableTrDimensionsVal = parseInt(trStyle.height, 10) + parseInt(trStyle.borderTopWidth, 10) + parseInt(trStyle.borderBottomWidth, 10) === tr.offsetHeight;
          documentElement.removeChild(table);
        }

        return reliableTrDimensionsVal;
      }
    });
  })();

  function curCSS(elem, name, computed) {
    var width,
        minWidth,
        maxWidth,
        ret,
        // Support: Firefox 51+
    // Retrieving style before computed somehow
    // fixes an issue with getting wrong values
    // on detached elements
    style = elem.style;
    computed = computed || getStyles(elem); // getPropertyValue is needed for:
    //   .css('filter') (IE 9 only, #12537)
    //   .css('--customProperty) (#3144)

    if (computed) {
      ret = computed.getPropertyValue(name) || computed[name];

      if (ret === "" && !isAttached(elem)) {
        ret = jQuery.style(elem, name);
      } // A tribute to the "awesome hack by Dean Edwards"
      // Android Browser returns percentage for some values,
      // but width seems to be reliably pixels.
      // This is against the CSSOM draft spec:
      // https://drafts.csswg.org/cssom/#resolved-values


      if (!support.pixelBoxStyles() && rnumnonpx.test(ret) && rboxStyle.test(name)) {
        // Remember the original values
        width = style.width;
        minWidth = style.minWidth;
        maxWidth = style.maxWidth; // Put in the new values to get a computed value out

        style.minWidth = style.maxWidth = style.width = ret;
        ret = computed.width; // Revert the changed values

        style.width = width;
        style.minWidth = minWidth;
        style.maxWidth = maxWidth;
      }
    }

    return ret !== undefined ? // Support: IE <=9 - 11 only
    // IE returns zIndex value as an integer.
    ret + "" : ret;
  }

  function addGetHookIf(conditionFn, hookFn) {
    // Define the hook, we'll check on the first run if it's really needed.
    return {
      get: function get() {
        if (conditionFn()) {
          // Hook not needed (or it's not possible to use it due
          // to missing dependency), remove it.
          delete this.get;
          return;
        } // Hook needed; redefine it so that the support test is not executed again.


        return (this.get = hookFn).apply(this, arguments);
      }
    };
  }

  var cssPrefixes = ["Webkit", "Moz", "ms"],
      emptyStyle = document.createElement("div").style,
      vendorProps = {}; // Return a vendor-prefixed property or undefined

  function vendorPropName(name) {
    // Check for vendor prefixed names
    var capName = name[0].toUpperCase() + name.slice(1),
        i = cssPrefixes.length;

    while (i--) {
      name = cssPrefixes[i] + capName;

      if (name in emptyStyle) {
        return name;
      }
    }
  } // Return a potentially-mapped jQuery.cssProps or vendor prefixed property


  function finalPropName(name) {
    var _final = jQuery.cssProps[name] || vendorProps[name];

    if (_final) {
      return _final;
    }

    if (name in emptyStyle) {
      return name;
    }

    return vendorProps[name] = vendorPropName(name) || name;
  }

  var // Swappable if display is none or starts with table
  // except "table", "table-cell", or "table-caption"
  // See here for display values: https://developer.mozilla.org/en-US/docs/CSS/display
  rdisplayswap = /^(none|table(?!-c[ea]).+)/,
      rcustomProp = /^--/,
      cssShow = {
    position: "absolute",
    visibility: "hidden",
    display: "block"
  },
      cssNormalTransform = {
    letterSpacing: "0",
    fontWeight: "400"
  };

  function setPositiveNumber(_elem, value, subtract) {
    // Any relative (+/-) values have already been
    // normalized at this point
    var matches = rcssNum.exec(value);
    return matches ? // Guard against undefined "subtract", e.g., when used as in cssHooks
    Math.max(0, matches[2] - (subtract || 0)) + (matches[3] || "px") : value;
  }

  function boxModelAdjustment(elem, dimension, box, isBorderBox, styles, computedVal) {
    var i = dimension === "width" ? 1 : 0,
        extra = 0,
        delta = 0; // Adjustment may not be necessary

    if (box === (isBorderBox ? "border" : "content")) {
      return 0;
    }

    for (; i < 4; i += 2) {
      // Both box models exclude margin
      if (box === "margin") {
        delta += jQuery.css(elem, box + cssExpand[i], true, styles);
      } // If we get here with a content-box, we're seeking "padding" or "border" or "margin"


      if (!isBorderBox) {
        // Add padding
        delta += jQuery.css(elem, "padding" + cssExpand[i], true, styles); // For "border" or "margin", add border

        if (box !== "padding") {
          delta += jQuery.css(elem, "border" + cssExpand[i] + "Width", true, styles); // But still keep track of it otherwise
        } else {
          extra += jQuery.css(elem, "border" + cssExpand[i] + "Width", true, styles);
        } // If we get here with a border-box (content + padding + border), we're seeking "content" or
        // "padding" or "margin"

      } else {
        // For "content", subtract padding
        if (box === "content") {
          delta -= jQuery.css(elem, "padding" + cssExpand[i], true, styles);
        } // For "content" or "padding", subtract border


        if (box !== "margin") {
          delta -= jQuery.css(elem, "border" + cssExpand[i] + "Width", true, styles);
        }
      }
    } // Account for positive content-box scroll gutter when requested by providing computedVal


    if (!isBorderBox && computedVal >= 0) {
      // offsetWidth/offsetHeight is a rounded sum of content, padding, scroll gutter, and border
      // Assuming integer scroll gutter, subtract the rest and round down
      delta += Math.max(0, Math.ceil(elem["offset" + dimension[0].toUpperCase() + dimension.slice(1)] - computedVal - delta - extra - 0.5 // If offsetWidth/offsetHeight is unknown, then we can't determine content-box scroll gutter
      // Use an explicit zero to avoid NaN (gh-3964)
      )) || 0;
    }

    return delta;
  }

  function getWidthOrHeight(elem, dimension, extra) {
    // Start with computed style
    var styles = getStyles(elem),
        // To avoid forcing a reflow, only fetch boxSizing if we need it (gh-4322).
    // Fake content-box until we know it's needed to know the true value.
    boxSizingNeeded = !support.boxSizingReliable() || extra,
        isBorderBox = boxSizingNeeded && jQuery.css(elem, "boxSizing", false, styles) === "border-box",
        valueIsBorderBox = isBorderBox,
        val = curCSS(elem, dimension, styles),
        offsetProp = "offset" + dimension[0].toUpperCase() + dimension.slice(1); // Support: Firefox <=54
    // Return a confounding non-pixel value or feign ignorance, as appropriate.

    if (rnumnonpx.test(val)) {
      if (!extra) {
        return val;
      }

      val = "auto";
    } // Support: IE 9 - 11 only
    // Use offsetWidth/offsetHeight for when box sizing is unreliable.
    // In those cases, the computed value can be trusted to be border-box.


    if ((!support.boxSizingReliable() && isBorderBox || // Support: IE 10 - 11+, Edge 15 - 18+
    // IE/Edge misreport `getComputedStyle` of table rows with width/height
    // set in CSS while `offset*` properties report correct values.
    // Interestingly, in some cases IE 9 doesn't suffer from this issue.
    !support.reliableTrDimensions() && nodeName(elem, "tr") || // Fall back to offsetWidth/offsetHeight when value is "auto"
    // This happens for inline elements with no explicit setting (gh-3571)
    val === "auto" || // Support: Android <=4.1 - 4.3 only
    // Also use offsetWidth/offsetHeight for misreported inline dimensions (gh-3602)
    !parseFloat(val) && jQuery.css(elem, "display", false, styles) === "inline") && // Make sure the element is visible & connected
    elem.getClientRects().length) {
      isBorderBox = jQuery.css(elem, "boxSizing", false, styles) === "border-box"; // Where available, offsetWidth/offsetHeight approximate border box dimensions.
      // Where not available (e.g., SVG), assume unreliable box-sizing and interpret the
      // retrieved value as a content box dimension.

      valueIsBorderBox = offsetProp in elem;

      if (valueIsBorderBox) {
        val = elem[offsetProp];
      }
    } // Normalize "" and auto


    val = parseFloat(val) || 0; // Adjust for the element's box model

    return val + boxModelAdjustment(elem, dimension, extra || (isBorderBox ? "border" : "content"), valueIsBorderBox, styles, // Provide the current computed size to request scroll gutter calculation (gh-3589)
    val) + "px";
  }

  jQuery.extend({
    // Add in style property hooks for overriding the default
    // behavior of getting and setting a style property
    cssHooks: {
      opacity: {
        get: function get(elem, computed) {
          if (computed) {
            // We should always get a number back from opacity
            var ret = curCSS(elem, "opacity");
            return ret === "" ? "1" : ret;
          }
        }
      }
    },
    // Don't automatically add "px" to these possibly-unitless properties
    cssNumber: {
      "animationIterationCount": true,
      "columnCount": true,
      "fillOpacity": true,
      "flexGrow": true,
      "flexShrink": true,
      "fontWeight": true,
      "gridArea": true,
      "gridColumn": true,
      "gridColumnEnd": true,
      "gridColumnStart": true,
      "gridRow": true,
      "gridRowEnd": true,
      "gridRowStart": true,
      "lineHeight": true,
      "opacity": true,
      "order": true,
      "orphans": true,
      "widows": true,
      "zIndex": true,
      "zoom": true
    },
    // Add in properties whose names you wish to fix before
    // setting or getting the value
    cssProps: {},
    // Get and set the style property on a DOM Node
    style: function style(elem, name, value, extra) {
      // Don't set styles on text and comment nodes
      if (!elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style) {
        return;
      } // Make sure that we're working with the right name


      var ret,
          type,
          hooks,
          origName = camelCase(name),
          isCustomProp = rcustomProp.test(name),
          style = elem.style; // Make sure that we're working with the right name. We don't
      // want to query the value if it is a CSS custom property
      // since they are user-defined.

      if (!isCustomProp) {
        name = finalPropName(origName);
      } // Gets hook for the prefixed version, then unprefixed version


      hooks = jQuery.cssHooks[name] || jQuery.cssHooks[origName]; // Check if we're setting a value

      if (value !== undefined) {
        type = _typeof(value); // Convert "+=" or "-=" to relative numbers (#7345)

        if (type === "string" && (ret = rcssNum.exec(value)) && ret[1]) {
          value = adjustCSS(elem, name, ret); // Fixes bug #9237

          type = "number";
        } // Make sure that null and NaN values aren't set (#7116)


        if (value == null || value !== value) {
          return;
        } // If a number was passed in, add the unit (except for certain CSS properties)
        // The isCustomProp check can be removed in jQuery 4.0 when we only auto-append
        // "px" to a few hardcoded values.


        if (type === "number" && !isCustomProp) {
          value += ret && ret[3] || (jQuery.cssNumber[origName] ? "" : "px");
        } // background-* props affect original clone's values


        if (!support.clearCloneStyle && value === "" && name.indexOf("background") === 0) {
          style[name] = "inherit";
        } // If a hook was provided, use that value, otherwise just set the specified value


        if (!hooks || !("set" in hooks) || (value = hooks.set(elem, value, extra)) !== undefined) {
          if (isCustomProp) {
            style.setProperty(name, value);
          } else {
            style[name] = value;
          }
        }
      } else {
        // If a hook was provided get the non-computed value from there
        if (hooks && "get" in hooks && (ret = hooks.get(elem, false, extra)) !== undefined) {
          return ret;
        } // Otherwise just get the value from the style object


        return style[name];
      }
    },
    css: function css(elem, name, extra, styles) {
      var val,
          num,
          hooks,
          origName = camelCase(name),
          isCustomProp = rcustomProp.test(name); // Make sure that we're working with the right name. We don't
      // want to modify the value if it is a CSS custom property
      // since they are user-defined.

      if (!isCustomProp) {
        name = finalPropName(origName);
      } // Try prefixed name followed by the unprefixed name


      hooks = jQuery.cssHooks[name] || jQuery.cssHooks[origName]; // If a hook was provided get the computed value from there

      if (hooks && "get" in hooks) {
        val = hooks.get(elem, true, extra);
      } // Otherwise, if a way to get the computed value exists, use that


      if (val === undefined) {
        val = curCSS(elem, name, styles);
      } // Convert "normal" to computed value


      if (val === "normal" && name in cssNormalTransform) {
        val = cssNormalTransform[name];
      } // Make numeric if forced or a qualifier was provided and val looks numeric


      if (extra === "" || extra) {
        num = parseFloat(val);
        return extra === true || isFinite(num) ? num || 0 : val;
      }

      return val;
    }
  });
  jQuery.each(["height", "width"], function (_i, dimension) {
    jQuery.cssHooks[dimension] = {
      get: function get(elem, computed, extra) {
        if (computed) {
          // Certain elements can have dimension info if we invisibly show them
          // but it must have a current display style that would benefit
          return rdisplayswap.test(jQuery.css(elem, "display")) && ( // Support: Safari 8+
          // Table columns in Safari have non-zero offsetWidth & zero
          // getBoundingClientRect().width unless display is changed.
          // Support: IE <=11 only
          // Running getBoundingClientRect on a disconnected node
          // in IE throws an error.
          !elem.getClientRects().length || !elem.getBoundingClientRect().width) ? swap(elem, cssShow, function () {
            return getWidthOrHeight(elem, dimension, extra);
          }) : getWidthOrHeight(elem, dimension, extra);
        }
      },
      set: function set(elem, value, extra) {
        var matches,
            styles = getStyles(elem),
            // Only read styles.position if the test has a chance to fail
        // to avoid forcing a reflow.
        scrollboxSizeBuggy = !support.scrollboxSize() && styles.position === "absolute",
            // To avoid forcing a reflow, only fetch boxSizing if we need it (gh-3991)
        boxSizingNeeded = scrollboxSizeBuggy || extra,
            isBorderBox = boxSizingNeeded && jQuery.css(elem, "boxSizing", false, styles) === "border-box",
            subtract = extra ? boxModelAdjustment(elem, dimension, extra, isBorderBox, styles) : 0; // Account for unreliable border-box dimensions by comparing offset* to computed and
        // faking a content-box to get border and padding (gh-3699)

        if (isBorderBox && scrollboxSizeBuggy) {
          subtract -= Math.ceil(elem["offset" + dimension[0].toUpperCase() + dimension.slice(1)] - parseFloat(styles[dimension]) - boxModelAdjustment(elem, dimension, "border", false, styles) - 0.5);
        } // Convert to pixels if value adjustment is needed


        if (subtract && (matches = rcssNum.exec(value)) && (matches[3] || "px") !== "px") {
          elem.style[dimension] = value;
          value = jQuery.css(elem, dimension);
        }

        return setPositiveNumber(elem, value, subtract);
      }
    };
  });
  jQuery.cssHooks.marginLeft = addGetHookIf(support.reliableMarginLeft, function (elem, computed) {
    if (computed) {
      return (parseFloat(curCSS(elem, "marginLeft")) || elem.getBoundingClientRect().left - swap(elem, {
        marginLeft: 0
      }, function () {
        return elem.getBoundingClientRect().left;
      })) + "px";
    }
  }); // These hooks are used by animate to expand properties

  jQuery.each({
    margin: "",
    padding: "",
    border: "Width"
  }, function (prefix, suffix) {
    jQuery.cssHooks[prefix + suffix] = {
      expand: function expand(value) {
        var i = 0,
            expanded = {},
            // Assumes a single number if not a string
        parts = typeof value === "string" ? value.split(" ") : [value];

        for (; i < 4; i++) {
          expanded[prefix + cssExpand[i] + suffix] = parts[i] || parts[i - 2] || parts[0];
        }

        return expanded;
      }
    };

    if (prefix !== "margin") {
      jQuery.cssHooks[prefix + suffix].set = setPositiveNumber;
    }
  });
  jQuery.fn.extend({
    css: function css(name, value) {
      return access(this, function (elem, name, value) {
        var styles,
            len,
            map = {},
            i = 0;

        if (Array.isArray(name)) {
          styles = getStyles(elem);
          len = name.length;

          for (; i < len; i++) {
            map[name[i]] = jQuery.css(elem, name[i], false, styles);
          }

          return map;
        }

        return value !== undefined ? jQuery.style(elem, name, value) : jQuery.css(elem, name);
      }, name, value, arguments.length > 1);
    }
  });

  function Tween(elem, options, prop, end, easing) {
    return new Tween.prototype.init(elem, options, prop, end, easing);
  }

  jQuery.Tween = Tween;
  Tween.prototype = {
    constructor: Tween,
    init: function init(elem, options, prop, end, easing, unit) {
      this.elem = elem;
      this.prop = prop;
      this.easing = easing || jQuery.easing._default;
      this.options = options;
      this.start = this.now = this.cur();
      this.end = end;
      this.unit = unit || (jQuery.cssNumber[prop] ? "" : "px");
    },
    cur: function cur() {
      var hooks = Tween.propHooks[this.prop];
      return hooks && hooks.get ? hooks.get(this) : Tween.propHooks._default.get(this);
    },
    run: function run(percent) {
      var eased,
          hooks = Tween.propHooks[this.prop];

      if (this.options.duration) {
        this.pos = eased = jQuery.easing[this.easing](percent, this.options.duration * percent, 0, 1, this.options.duration);
      } else {
        this.pos = eased = percent;
      }

      this.now = (this.end - this.start) * eased + this.start;

      if (this.options.step) {
        this.options.step.call(this.elem, this.now, this);
      }

      if (hooks && hooks.set) {
        hooks.set(this);
      } else {
        Tween.propHooks._default.set(this);
      }

      return this;
    }
  };
  Tween.prototype.init.prototype = Tween.prototype;
  Tween.propHooks = {
    _default: {
      get: function get(tween) {
        var result; // Use a property on the element directly when it is not a DOM element,
        // or when there is no matching style property that exists.

        if (tween.elem.nodeType !== 1 || tween.elem[tween.prop] != null && tween.elem.style[tween.prop] == null) {
          return tween.elem[tween.prop];
        } // Passing an empty string as a 3rd parameter to .css will automatically
        // attempt a parseFloat and fallback to a string if the parse fails.
        // Simple values such as "10px" are parsed to Float;
        // complex values such as "rotate(1rad)" are returned as-is.


        result = jQuery.css(tween.elem, tween.prop, ""); // Empty strings, null, undefined and "auto" are converted to 0.

        return !result || result === "auto" ? 0 : result;
      },
      set: function set(tween) {
        // Use step hook for back compat.
        // Use cssHook if its there.
        // Use .style if available and use plain properties where available.
        if (jQuery.fx.step[tween.prop]) {
          jQuery.fx.step[tween.prop](tween);
        } else if (tween.elem.nodeType === 1 && (jQuery.cssHooks[tween.prop] || tween.elem.style[finalPropName(tween.prop)] != null)) {
          jQuery.style(tween.elem, tween.prop, tween.now + tween.unit);
        } else {
          tween.elem[tween.prop] = tween.now;
        }
      }
    }
  }; // Support: IE <=9 only
  // Panic based approach to setting things on disconnected nodes

  Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
    set: function set(tween) {
      if (tween.elem.nodeType && tween.elem.parentNode) {
        tween.elem[tween.prop] = tween.now;
      }
    }
  };
  jQuery.easing = {
    linear: function linear(p) {
      return p;
    },
    swing: function swing(p) {
      return 0.5 - Math.cos(p * Math.PI) / 2;
    },
    _default: "swing"
  };
  jQuery.fx = Tween.prototype.init; // Back compat <1.8 extension point

  jQuery.fx.step = {};
  var fxNow,
      inProgress,
      rfxtypes = /^(?:toggle|show|hide)$/,
      rrun = /queueHooks$/;

  function schedule() {
    if (inProgress) {
      if (document.hidden === false && window.requestAnimationFrame) {
        window.requestAnimationFrame(schedule);
      } else {
        window.setTimeout(schedule, jQuery.fx.interval);
      }

      jQuery.fx.tick();
    }
  } // Animations created synchronously will run synchronously


  function createFxNow() {
    window.setTimeout(function () {
      fxNow = undefined;
    });
    return fxNow = Date.now();
  } // Generate parameters to create a standard animation


  function genFx(type, includeWidth) {
    var which,
        i = 0,
        attrs = {
      height: type
    }; // If we include width, step value is 1 to do all cssExpand values,
    // otherwise step value is 2 to skip over Left and Right

    includeWidth = includeWidth ? 1 : 0;

    for (; i < 4; i += 2 - includeWidth) {
      which = cssExpand[i];
      attrs["margin" + which] = attrs["padding" + which] = type;
    }

    if (includeWidth) {
      attrs.opacity = attrs.width = type;
    }

    return attrs;
  }

  function createTween(value, prop, animation) {
    var tween,
        collection = (Animation.tweeners[prop] || []).concat(Animation.tweeners["*"]),
        index = 0,
        length = collection.length;

    for (; index < length; index++) {
      if (tween = collection[index].call(animation, prop, value)) {
        // We're done with this property
        return tween;
      }
    }
  }

  function defaultPrefilter(elem, props, opts) {
    var prop,
        value,
        toggle,
        hooks,
        oldfire,
        propTween,
        restoreDisplay,
        display,
        isBox = "width" in props || "height" in props,
        anim = this,
        orig = {},
        style = elem.style,
        hidden = elem.nodeType && isHiddenWithinTree(elem),
        dataShow = dataPriv.get(elem, "fxshow"); // Queue-skipping animations hijack the fx hooks

    if (!opts.queue) {
      hooks = jQuery._queueHooks(elem, "fx");

      if (hooks.unqueued == null) {
        hooks.unqueued = 0;
        oldfire = hooks.empty.fire;

        hooks.empty.fire = function () {
          if (!hooks.unqueued) {
            oldfire();
          }
        };
      }

      hooks.unqueued++;
      anim.always(function () {
        // Ensure the complete handler is called before this completes
        anim.always(function () {
          hooks.unqueued--;

          if (!jQuery.queue(elem, "fx").length) {
            hooks.empty.fire();
          }
        });
      });
    } // Detect show/hide animations


    for (prop in props) {
      value = props[prop];

      if (rfxtypes.test(value)) {
        delete props[prop];
        toggle = toggle || value === "toggle";

        if (value === (hidden ? "hide" : "show")) {
          // Pretend to be hidden if this is a "show" and
          // there is still data from a stopped show/hide
          if (value === "show" && dataShow && dataShow[prop] !== undefined) {
            hidden = true; // Ignore all other no-op show/hide data
          } else {
            continue;
          }
        }

        orig[prop] = dataShow && dataShow[prop] || jQuery.style(elem, prop);
      }
    } // Bail out if this is a no-op like .hide().hide()


    propTween = !jQuery.isEmptyObject(props);

    if (!propTween && jQuery.isEmptyObject(orig)) {
      return;
    } // Restrict "overflow" and "display" styles during box animations


    if (isBox && elem.nodeType === 1) {
      // Support: IE <=9 - 11, Edge 12 - 15
      // Record all 3 overflow attributes because IE does not infer the shorthand
      // from identically-valued overflowX and overflowY and Edge just mirrors
      // the overflowX value there.
      opts.overflow = [style.overflow, style.overflowX, style.overflowY]; // Identify a display type, preferring old show/hide data over the CSS cascade

      restoreDisplay = dataShow && dataShow.display;

      if (restoreDisplay == null) {
        restoreDisplay = dataPriv.get(elem, "display");
      }

      display = jQuery.css(elem, "display");

      if (display === "none") {
        if (restoreDisplay) {
          display = restoreDisplay;
        } else {
          // Get nonempty value(s) by temporarily forcing visibility
          showHide([elem], true);
          restoreDisplay = elem.style.display || restoreDisplay;
          display = jQuery.css(elem, "display");
          showHide([elem]);
        }
      } // Animate inline elements as inline-block


      if (display === "inline" || display === "inline-block" && restoreDisplay != null) {
        if (jQuery.css(elem, "float") === "none") {
          // Restore the original display value at the end of pure show/hide animations
          if (!propTween) {
            anim.done(function () {
              style.display = restoreDisplay;
            });

            if (restoreDisplay == null) {
              display = style.display;
              restoreDisplay = display === "none" ? "" : display;
            }
          }

          style.display = "inline-block";
        }
      }
    }

    if (opts.overflow) {
      style.overflow = "hidden";
      anim.always(function () {
        style.overflow = opts.overflow[0];
        style.overflowX = opts.overflow[1];
        style.overflowY = opts.overflow[2];
      });
    } // Implement show/hide animations


    propTween = false;

    for (prop in orig) {
      // General show/hide setup for this element animation
      if (!propTween) {
        if (dataShow) {
          if ("hidden" in dataShow) {
            hidden = dataShow.hidden;
          }
        } else {
          dataShow = dataPriv.access(elem, "fxshow", {
            display: restoreDisplay
          });
        } // Store hidden/visible for toggle so `.stop().toggle()` "reverses"


        if (toggle) {
          dataShow.hidden = !hidden;
        } // Show elements before animating them


        if (hidden) {
          showHide([elem], true);
        }
        /* eslint-disable no-loop-func */


        anim.done(function () {
          /* eslint-enable no-loop-func */
          // The final step of a "hide" animation is actually hiding the element
          if (!hidden) {
            showHide([elem]);
          }

          dataPriv.remove(elem, "fxshow");

          for (prop in orig) {
            jQuery.style(elem, prop, orig[prop]);
          }
        });
      } // Per-property setup


      propTween = createTween(hidden ? dataShow[prop] : 0, prop, anim);

      if (!(prop in dataShow)) {
        dataShow[prop] = propTween.start;

        if (hidden) {
          propTween.end = propTween.start;
          propTween.start = 0;
        }
      }
    }
  }

  function propFilter(props, specialEasing) {
    var index, name, easing, value, hooks; // camelCase, specialEasing and expand cssHook pass

    for (index in props) {
      name = camelCase(index);
      easing = specialEasing[name];
      value = props[index];

      if (Array.isArray(value)) {
        easing = value[1];
        value = props[index] = value[0];
      }

      if (index !== name) {
        props[name] = value;
        delete props[index];
      }

      hooks = jQuery.cssHooks[name];

      if (hooks && "expand" in hooks) {
        value = hooks.expand(value);
        delete props[name]; // Not quite $.extend, this won't overwrite existing keys.
        // Reusing 'index' because we have the correct "name"

        for (index in value) {
          if (!(index in props)) {
            props[index] = value[index];
            specialEasing[index] = easing;
          }
        }
      } else {
        specialEasing[name] = easing;
      }
    }
  }

  function Animation(elem, properties, options) {
    var result,
        stopped,
        index = 0,
        length = Animation.prefilters.length,
        deferred = jQuery.Deferred().always(function () {
      // Don't match elem in the :animated selector
      delete tick.elem;
    }),
        tick = function tick() {
      if (stopped) {
        return false;
      }

      var currentTime = fxNow || createFxNow(),
          remaining = Math.max(0, animation.startTime + animation.duration - currentTime),
          // Support: Android 2.3 only
      // Archaic crash bug won't allow us to use `1 - ( 0.5 || 0 )` (#12497)
      temp = remaining / animation.duration || 0,
          percent = 1 - temp,
          index = 0,
          length = animation.tweens.length;

      for (; index < length; index++) {
        animation.tweens[index].run(percent);
      }

      deferred.notifyWith(elem, [animation, percent, remaining]); // If there's more to do, yield

      if (percent < 1 && length) {
        return remaining;
      } // If this was an empty animation, synthesize a final progress notification


      if (!length) {
        deferred.notifyWith(elem, [animation, 1, 0]);
      } // Resolve the animation and report its conclusion


      deferred.resolveWith(elem, [animation]);
      return false;
    },
        animation = deferred.promise({
      elem: elem,
      props: jQuery.extend({}, properties),
      opts: jQuery.extend(true, {
        specialEasing: {},
        easing: jQuery.easing._default
      }, options),
      originalProperties: properties,
      originalOptions: options,
      startTime: fxNow || createFxNow(),
      duration: options.duration,
      tweens: [],
      createTween: function createTween(prop, end) {
        var tween = jQuery.Tween(elem, animation.opts, prop, end, animation.opts.specialEasing[prop] || animation.opts.easing);
        animation.tweens.push(tween);
        return tween;
      },
      stop: function stop(gotoEnd) {
        var index = 0,
            // If we are going to the end, we want to run all the tweens
        // otherwise we skip this part
        length = gotoEnd ? animation.tweens.length : 0;

        if (stopped) {
          return this;
        }

        stopped = true;

        for (; index < length; index++) {
          animation.tweens[index].run(1);
        } // Resolve when we played the last frame; otherwise, reject


        if (gotoEnd) {
          deferred.notifyWith(elem, [animation, 1, 0]);
          deferred.resolveWith(elem, [animation, gotoEnd]);
        } else {
          deferred.rejectWith(elem, [animation, gotoEnd]);
        }

        return this;
      }
    }),
        props = animation.props;

    propFilter(props, animation.opts.specialEasing);

    for (; index < length; index++) {
      result = Animation.prefilters[index].call(animation, elem, props, animation.opts);

      if (result) {
        if (isFunction(result.stop)) {
          jQuery._queueHooks(animation.elem, animation.opts.queue).stop = result.stop.bind(result);
        }

        return result;
      }
    }

    jQuery.map(props, createTween, animation);

    if (isFunction(animation.opts.start)) {
      animation.opts.start.call(elem, animation);
    } // Attach callbacks from options


    animation.progress(animation.opts.progress).done(animation.opts.done, animation.opts.complete).fail(animation.opts.fail).always(animation.opts.always);
    jQuery.fx.timer(jQuery.extend(tick, {
      elem: elem,
      anim: animation,
      queue: animation.opts.queue
    }));
    return animation;
  }

  jQuery.Animation = jQuery.extend(Animation, {
    tweeners: {
      "*": [function (prop, value) {
        var tween = this.createTween(prop, value);
        adjustCSS(tween.elem, prop, rcssNum.exec(value), tween);
        return tween;
      }]
    },
    tweener: function tweener(props, callback) {
      if (isFunction(props)) {
        callback = props;
        props = ["*"];
      } else {
        props = props.match(rnothtmlwhite);
      }

      var prop,
          index = 0,
          length = props.length;

      for (; index < length; index++) {
        prop = props[index];
        Animation.tweeners[prop] = Animation.tweeners[prop] || [];
        Animation.tweeners[prop].unshift(callback);
      }
    },
    prefilters: [defaultPrefilter],
    prefilter: function prefilter(callback, prepend) {
      if (prepend) {
        Animation.prefilters.unshift(callback);
      } else {
        Animation.prefilters.push(callback);
      }
    }
  });

  jQuery.speed = function (speed, easing, fn) {
    var opt = speed && _typeof(speed) === "object" ? jQuery.extend({}, speed) : {
      complete: fn || !fn && easing || isFunction(speed) && speed,
      duration: speed,
      easing: fn && easing || easing && !isFunction(easing) && easing
    }; // Go to the end state if fx are off

    if (jQuery.fx.off) {
      opt.duration = 0;
    } else {
      if (typeof opt.duration !== "number") {
        if (opt.duration in jQuery.fx.speeds) {
          opt.duration = jQuery.fx.speeds[opt.duration];
        } else {
          opt.duration = jQuery.fx.speeds._default;
        }
      }
    } // Normalize opt.queue - true/undefined/null -> "fx"


    if (opt.queue == null || opt.queue === true) {
      opt.queue = "fx";
    } // Queueing


    opt.old = opt.complete;

    opt.complete = function () {
      if (isFunction(opt.old)) {
        opt.old.call(this);
      }

      if (opt.queue) {
        jQuery.dequeue(this, opt.queue);
      }
    };

    return opt;
  };

  jQuery.fn.extend({
    fadeTo: function fadeTo(speed, to, easing, callback) {
      // Show any hidden elements after setting opacity to 0
      return this.filter(isHiddenWithinTree).css("opacity", 0).show() // Animate to the value specified
      .end().animate({
        opacity: to
      }, speed, easing, callback);
    },
    animate: function animate(prop, speed, easing, callback) {
      var empty = jQuery.isEmptyObject(prop),
          optall = jQuery.speed(speed, easing, callback),
          doAnimation = function doAnimation() {
        // Operate on a copy of prop so per-property easing won't be lost
        var anim = Animation(this, jQuery.extend({}, prop), optall); // Empty animations, or finishing resolves immediately

        if (empty || dataPriv.get(this, "finish")) {
          anim.stop(true);
        }
      };

      doAnimation.finish = doAnimation;
      return empty || optall.queue === false ? this.each(doAnimation) : this.queue(optall.queue, doAnimation);
    },
    stop: function stop(type, clearQueue, gotoEnd) {
      var stopQueue = function stopQueue(hooks) {
        var stop = hooks.stop;
        delete hooks.stop;
        stop(gotoEnd);
      };

      if (typeof type !== "string") {
        gotoEnd = clearQueue;
        clearQueue = type;
        type = undefined;
      }

      if (clearQueue) {
        this.queue(type || "fx", []);
      }

      return this.each(function () {
        var dequeue = true,
            index = type != null && type + "queueHooks",
            timers = jQuery.timers,
            data = dataPriv.get(this);

        if (index) {
          if (data[index] && data[index].stop) {
            stopQueue(data[index]);
          }
        } else {
          for (index in data) {
            if (data[index] && data[index].stop && rrun.test(index)) {
              stopQueue(data[index]);
            }
          }
        }

        for (index = timers.length; index--;) {
          if (timers[index].elem === this && (type == null || timers[index].queue === type)) {
            timers[index].anim.stop(gotoEnd);
            dequeue = false;
            timers.splice(index, 1);
          }
        } // Start the next in the queue if the last step wasn't forced.
        // Timers currently will call their complete callbacks, which
        // will dequeue but only if they were gotoEnd.


        if (dequeue || !gotoEnd) {
          jQuery.dequeue(this, type);
        }
      });
    },
    finish: function finish(type) {
      if (type !== false) {
        type = type || "fx";
      }

      return this.each(function () {
        var index,
            data = dataPriv.get(this),
            queue = data[type + "queue"],
            hooks = data[type + "queueHooks"],
            timers = jQuery.timers,
            length = queue ? queue.length : 0; // Enable finishing flag on private data

        data.finish = true; // Empty the queue first

        jQuery.queue(this, type, []);

        if (hooks && hooks.stop) {
          hooks.stop.call(this, true);
        } // Look for any active animations, and finish them


        for (index = timers.length; index--;) {
          if (timers[index].elem === this && timers[index].queue === type) {
            timers[index].anim.stop(true);
            timers.splice(index, 1);
          }
        } // Look for any animations in the old queue and finish them


        for (index = 0; index < length; index++) {
          if (queue[index] && queue[index].finish) {
            queue[index].finish.call(this);
          }
        } // Turn off finishing flag


        delete data.finish;
      });
    }
  });
  jQuery.each(["toggle", "show", "hide"], function (_i, name) {
    var cssFn = jQuery.fn[name];

    jQuery.fn[name] = function (speed, easing, callback) {
      return speed == null || typeof speed === "boolean" ? cssFn.apply(this, arguments) : this.animate(genFx(name, true), speed, easing, callback);
    };
  }); // Generate shortcuts for custom animations

  jQuery.each({
    slideDown: genFx("show"),
    slideUp: genFx("hide"),
    slideToggle: genFx("toggle"),
    fadeIn: {
      opacity: "show"
    },
    fadeOut: {
      opacity: "hide"
    },
    fadeToggle: {
      opacity: "toggle"
    }
  }, function (name, props) {
    jQuery.fn[name] = function (speed, easing, callback) {
      return this.animate(props, speed, easing, callback);
    };
  });
  jQuery.timers = [];

  jQuery.fx.tick = function () {
    var timer,
        i = 0,
        timers = jQuery.timers;
    fxNow = Date.now();

    for (; i < timers.length; i++) {
      timer = timers[i]; // Run the timer and safely remove it when done (allowing for external removal)

      if (!timer() && timers[i] === timer) {
        timers.splice(i--, 1);
      }
    }

    if (!timers.length) {
      jQuery.fx.stop();
    }

    fxNow = undefined;
  };

  jQuery.fx.timer = function (timer) {
    jQuery.timers.push(timer);
    jQuery.fx.start();
  };

  jQuery.fx.interval = 13;

  jQuery.fx.start = function () {
    if (inProgress) {
      return;
    }

    inProgress = true;
    schedule();
  };

  jQuery.fx.stop = function () {
    inProgress = null;
  };

  jQuery.fx.speeds = {
    slow: 600,
    fast: 200,
    // Default speed
    _default: 400
  }; // Based off of the plugin by Clint Helfers, with permission.
  // https://web.archive.org/web/20100324014747/http://blindsignals.com/index.php/2009/07/jquery-delay/

  jQuery.fn.delay = function (time, type) {
    time = jQuery.fx ? jQuery.fx.speeds[time] || time : time;
    type = type || "fx";
    return this.queue(type, function (next, hooks) {
      var timeout = window.setTimeout(next, time);

      hooks.stop = function () {
        window.clearTimeout(timeout);
      };
    });
  };

  (function () {
    var input = document.createElement("input"),
        select = document.createElement("select"),
        opt = select.appendChild(document.createElement("option"));
    input.type = "checkbox"; // Support: Android <=4.3 only
    // Default value for a checkbox should be "on"

    support.checkOn = input.value !== ""; // Support: IE <=11 only
    // Must access selectedIndex to make default options select

    support.optSelected = opt.selected; // Support: IE <=11 only
    // An input loses its value after becoming a radio

    input = document.createElement("input");
    input.value = "t";
    input.type = "radio";
    support.radioValue = input.value === "t";
  })();

  var boolHook,
      attrHandle = jQuery.expr.attrHandle;
  jQuery.fn.extend({
    attr: function attr(name, value) {
      return access(this, jQuery.attr, name, value, arguments.length > 1);
    },
    removeAttr: function removeAttr(name) {
      return this.each(function () {
        jQuery.removeAttr(this, name);
      });
    }
  });
  jQuery.extend({
    attr: function attr(elem, name, value) {
      var ret,
          hooks,
          nType = elem.nodeType; // Don't get/set attributes on text, comment and attribute nodes

      if (nType === 3 || nType === 8 || nType === 2) {
        return;
      } // Fallback to prop when attributes are not supported


      if (typeof elem.getAttribute === "undefined") {
        return jQuery.prop(elem, name, value);
      } // Attribute hooks are determined by the lowercase version
      // Grab necessary hook if one is defined


      if (nType !== 1 || !jQuery.isXMLDoc(elem)) {
        hooks = jQuery.attrHooks[name.toLowerCase()] || (jQuery.expr.match.bool.test(name) ? boolHook : undefined);
      }

      if (value !== undefined) {
        if (value === null) {
          jQuery.removeAttr(elem, name);
          return;
        }

        if (hooks && "set" in hooks && (ret = hooks.set(elem, value, name)) !== undefined) {
          return ret;
        }

        elem.setAttribute(name, value + "");
        return value;
      }

      if (hooks && "get" in hooks && (ret = hooks.get(elem, name)) !== null) {
        return ret;
      }

      ret = jQuery.find.attr(elem, name); // Non-existent attributes return null, we normalize to undefined

      return ret == null ? undefined : ret;
    },
    attrHooks: {
      type: {
        set: function set(elem, value) {
          if (!support.radioValue && value === "radio" && nodeName(elem, "input")) {
            var val = elem.value;
            elem.setAttribute("type", value);

            if (val) {
              elem.value = val;
            }

            return value;
          }
        }
      }
    },
    removeAttr: function removeAttr(elem, value) {
      var name,
          i = 0,
          // Attribute names can contain non-HTML whitespace characters
      // https://html.spec.whatwg.org/multipage/syntax.html#attributes-2
      attrNames = value && value.match(rnothtmlwhite);

      if (attrNames && elem.nodeType === 1) {
        while (name = attrNames[i++]) {
          elem.removeAttribute(name);
        }
      }
    }
  }); // Hooks for boolean attributes

  boolHook = {
    set: function set(elem, value, name) {
      if (value === false) {
        // Remove boolean attributes when set to false
        jQuery.removeAttr(elem, name);
      } else {
        elem.setAttribute(name, name);
      }

      return name;
    }
  };
  jQuery.each(jQuery.expr.match.bool.source.match(/\w+/g), function (_i, name) {
    var getter = attrHandle[name] || jQuery.find.attr;

    attrHandle[name] = function (elem, name, isXML) {
      var ret,
          handle,
          lowercaseName = name.toLowerCase();

      if (!isXML) {
        // Avoid an infinite loop by temporarily removing this function from the getter
        handle = attrHandle[lowercaseName];
        attrHandle[lowercaseName] = ret;
        ret = getter(elem, name, isXML) != null ? lowercaseName : null;
        attrHandle[lowercaseName] = handle;
      }

      return ret;
    };
  });
  var rfocusable = /^(?:input|select|textarea|button)$/i,
      rclickable = /^(?:a|area)$/i;
  jQuery.fn.extend({
    prop: function prop(name, value) {
      return access(this, jQuery.prop, name, value, arguments.length > 1);
    },
    removeProp: function removeProp(name) {
      return this.each(function () {
        delete this[jQuery.propFix[name] || name];
      });
    }
  });
  jQuery.extend({
    prop: function prop(elem, name, value) {
      var ret,
          hooks,
          nType = elem.nodeType; // Don't get/set properties on text, comment and attribute nodes

      if (nType === 3 || nType === 8 || nType === 2) {
        return;
      }

      if (nType !== 1 || !jQuery.isXMLDoc(elem)) {
        // Fix name and attach hooks
        name = jQuery.propFix[name] || name;
        hooks = jQuery.propHooks[name];
      }

      if (value !== undefined) {
        if (hooks && "set" in hooks && (ret = hooks.set(elem, value, name)) !== undefined) {
          return ret;
        }

        return elem[name] = value;
      }

      if (hooks && "get" in hooks && (ret = hooks.get(elem, name)) !== null) {
        return ret;
      }

      return elem[name];
    },
    propHooks: {
      tabIndex: {
        get: function get(elem) {
          // Support: IE <=9 - 11 only
          // elem.tabIndex doesn't always return the
          // correct value when it hasn't been explicitly set
          // https://web.archive.org/web/20141116233347/http://fluidproject.org/blog/2008/01/09/getting-setting-and-removing-tabindex-values-with-javascript/
          // Use proper attribute retrieval(#12072)
          var tabindex = jQuery.find.attr(elem, "tabindex");

          if (tabindex) {
            return parseInt(tabindex, 10);
          }

          if (rfocusable.test(elem.nodeName) || rclickable.test(elem.nodeName) && elem.href) {
            return 0;
          }

          return -1;
        }
      }
    },
    propFix: {
      "for": "htmlFor",
      "class": "className"
    }
  }); // Support: IE <=11 only
  // Accessing the selectedIndex property
  // forces the browser to respect setting selected
  // on the option
  // The getter ensures a default option is selected
  // when in an optgroup
  // eslint rule "no-unused-expressions" is disabled for this code
  // since it considers such accessions noop

  if (!support.optSelected) {
    jQuery.propHooks.selected = {
      get: function get(elem) {
        /* eslint no-unused-expressions: "off" */
        var parent = elem.parentNode;

        if (parent && parent.parentNode) {
          parent.parentNode.selectedIndex;
        }

        return null;
      },
      set: function set(elem) {
        /* eslint no-unused-expressions: "off" */
        var parent = elem.parentNode;

        if (parent) {
          parent.selectedIndex;

          if (parent.parentNode) {
            parent.parentNode.selectedIndex;
          }
        }
      }
    };
  }

  jQuery.each(["tabIndex", "readOnly", "maxLength", "cellSpacing", "cellPadding", "rowSpan", "colSpan", "useMap", "frameBorder", "contentEditable"], function () {
    jQuery.propFix[this.toLowerCase()] = this;
  }); // Strip and collapse whitespace according to HTML spec
  // https://infra.spec.whatwg.org/#strip-and-collapse-ascii-whitespace

  function stripAndCollapse(value) {
    var tokens = value.match(rnothtmlwhite) || [];
    return tokens.join(" ");
  }

  function getClass(elem) {
    return elem.getAttribute && elem.getAttribute("class") || "";
  }

  function classesToArray(value) {
    if (Array.isArray(value)) {
      return value;
    }

    if (typeof value === "string") {
      return value.match(rnothtmlwhite) || [];
    }

    return [];
  }

  jQuery.fn.extend({
    addClass: function addClass(value) {
      var classes,
          elem,
          cur,
          curValue,
          clazz,
          j,
          finalValue,
          i = 0;

      if (isFunction(value)) {
        return this.each(function (j) {
          jQuery(this).addClass(value.call(this, j, getClass(this)));
        });
      }

      classes = classesToArray(value);

      if (classes.length) {
        while (elem = this[i++]) {
          curValue = getClass(elem);
          cur = elem.nodeType === 1 && " " + stripAndCollapse(curValue) + " ";

          if (cur) {
            j = 0;

            while (clazz = classes[j++]) {
              if (cur.indexOf(" " + clazz + " ") < 0) {
                cur += clazz + " ";
              }
            } // Only assign if different to avoid unneeded rendering.


            finalValue = stripAndCollapse(cur);

            if (curValue !== finalValue) {
              elem.setAttribute("class", finalValue);
            }
          }
        }
      }

      return this;
    },
    removeClass: function removeClass(value) {
      var classes,
          elem,
          cur,
          curValue,
          clazz,
          j,
          finalValue,
          i = 0;

      if (isFunction(value)) {
        return this.each(function (j) {
          jQuery(this).removeClass(value.call(this, j, getClass(this)));
        });
      }

      if (!arguments.length) {
        return this.attr("class", "");
      }

      classes = classesToArray(value);

      if (classes.length) {
        while (elem = this[i++]) {
          curValue = getClass(elem); // This expression is here for better compressibility (see addClass)

          cur = elem.nodeType === 1 && " " + stripAndCollapse(curValue) + " ";

          if (cur) {
            j = 0;

            while (clazz = classes[j++]) {
              // Remove *all* instances
              while (cur.indexOf(" " + clazz + " ") > -1) {
                cur = cur.replace(" " + clazz + " ", " ");
              }
            } // Only assign if different to avoid unneeded rendering.


            finalValue = stripAndCollapse(cur);

            if (curValue !== finalValue) {
              elem.setAttribute("class", finalValue);
            }
          }
        }
      }

      return this;
    },
    toggleClass: function toggleClass(value, stateVal) {
      var type = _typeof(value),
          isValidValue = type === "string" || Array.isArray(value);

      if (typeof stateVal === "boolean" && isValidValue) {
        return stateVal ? this.addClass(value) : this.removeClass(value);
      }

      if (isFunction(value)) {
        return this.each(function (i) {
          jQuery(this).toggleClass(value.call(this, i, getClass(this), stateVal), stateVal);
        });
      }

      return this.each(function () {
        var className, i, self, classNames;

        if (isValidValue) {
          // Toggle individual class names
          i = 0;
          self = jQuery(this);
          classNames = classesToArray(value);

          while (className = classNames[i++]) {
            // Check each className given, space separated list
            if (self.hasClass(className)) {
              self.removeClass(className);
            } else {
              self.addClass(className);
            }
          } // Toggle whole class name

        } else if (value === undefined || type === "boolean") {
          className = getClass(this);

          if (className) {
            // Store className if set
            dataPriv.set(this, "__className__", className);
          } // If the element has a class name or if we're passed `false`,
          // then remove the whole classname (if there was one, the above saved it).
          // Otherwise bring back whatever was previously saved (if anything),
          // falling back to the empty string if nothing was stored.


          if (this.setAttribute) {
            this.setAttribute("class", className || value === false ? "" : dataPriv.get(this, "__className__") || "");
          }
        }
      });
    },
    hasClass: function hasClass(selector) {
      var className,
          elem,
          i = 0;
      className = " " + selector + " ";

      while (elem = this[i++]) {
        if (elem.nodeType === 1 && (" " + stripAndCollapse(getClass(elem)) + " ").indexOf(className) > -1) {
          return true;
        }
      }

      return false;
    }
  });
  var rreturn = /\r/g;
  jQuery.fn.extend({
    val: function val(value) {
      var hooks,
          ret,
          valueIsFunction,
          elem = this[0];

      if (!arguments.length) {
        if (elem) {
          hooks = jQuery.valHooks[elem.type] || jQuery.valHooks[elem.nodeName.toLowerCase()];

          if (hooks && "get" in hooks && (ret = hooks.get(elem, "value")) !== undefined) {
            return ret;
          }

          ret = elem.value; // Handle most common string cases

          if (typeof ret === "string") {
            return ret.replace(rreturn, "");
          } // Handle cases where value is null/undef or number


          return ret == null ? "" : ret;
        }

        return;
      }

      valueIsFunction = isFunction(value);
      return this.each(function (i) {
        var val;

        if (this.nodeType !== 1) {
          return;
        }

        if (valueIsFunction) {
          val = value.call(this, i, jQuery(this).val());
        } else {
          val = value;
        } // Treat null/undefined as ""; convert numbers to string


        if (val == null) {
          val = "";
        } else if (typeof val === "number") {
          val += "";
        } else if (Array.isArray(val)) {
          val = jQuery.map(val, function (value) {
            return value == null ? "" : value + "";
          });
        }

        hooks = jQuery.valHooks[this.type] || jQuery.valHooks[this.nodeName.toLowerCase()]; // If set returns undefined, fall back to normal setting

        if (!hooks || !("set" in hooks) || hooks.set(this, val, "value") === undefined) {
          this.value = val;
        }
      });
    }
  });
  jQuery.extend({
    valHooks: {
      option: {
        get: function get(elem) {
          var val = jQuery.find.attr(elem, "value");
          return val != null ? val : // Support: IE <=10 - 11 only
          // option.text throws exceptions (#14686, #14858)
          // Strip and collapse whitespace
          // https://html.spec.whatwg.org/#strip-and-collapse-whitespace
          stripAndCollapse(jQuery.text(elem));
        }
      },
      select: {
        get: function get(elem) {
          var value,
              option,
              i,
              options = elem.options,
              index = elem.selectedIndex,
              one = elem.type === "select-one",
              values = one ? null : [],
              max = one ? index + 1 : options.length;

          if (index < 0) {
            i = max;
          } else {
            i = one ? index : 0;
          } // Loop through all the selected options


          for (; i < max; i++) {
            option = options[i]; // Support: IE <=9 only
            // IE8-9 doesn't update selected after form reset (#2551)

            if ((option.selected || i === index) && // Don't return options that are disabled or in a disabled optgroup
            !option.disabled && (!option.parentNode.disabled || !nodeName(option.parentNode, "optgroup"))) {
              // Get the specific value for the option
              value = jQuery(option).val(); // We don't need an array for one selects

              if (one) {
                return value;
              } // Multi-Selects return an array


              values.push(value);
            }
          }

          return values;
        },
        set: function set(elem, value) {
          var optionSet,
              option,
              options = elem.options,
              values = jQuery.makeArray(value),
              i = options.length;

          while (i--) {
            option = options[i];
            /* eslint-disable no-cond-assign */

            if (option.selected = jQuery.inArray(jQuery.valHooks.option.get(option), values) > -1) {
              optionSet = true;
            }
            /* eslint-enable no-cond-assign */

          } // Force browsers to behave consistently when non-matching value is set


          if (!optionSet) {
            elem.selectedIndex = -1;
          }

          return values;
        }
      }
    }
  }); // Radios and checkboxes getter/setter

  jQuery.each(["radio", "checkbox"], function () {
    jQuery.valHooks[this] = {
      set: function set(elem, value) {
        if (Array.isArray(value)) {
          return elem.checked = jQuery.inArray(jQuery(elem).val(), value) > -1;
        }
      }
    };

    if (!support.checkOn) {
      jQuery.valHooks[this].get = function (elem) {
        return elem.getAttribute("value") === null ? "on" : elem.value;
      };
    }
  }); // Return jQuery for attributes-only inclusion

  support.focusin = "onfocusin" in window;

  var rfocusMorph = /^(?:focusinfocus|focusoutblur)$/,
      stopPropagationCallback = function stopPropagationCallback(e) {
    e.stopPropagation();
  };

  jQuery.extend(jQuery.event, {
    trigger: function trigger(event, data, elem, onlyHandlers) {
      var i,
          cur,
          tmp,
          bubbleType,
          ontype,
          handle,
          special,
          lastElement,
          eventPath = [elem || document],
          type = hasOwn.call(event, "type") ? event.type : event,
          namespaces = hasOwn.call(event, "namespace") ? event.namespace.split(".") : [];
      cur = lastElement = tmp = elem = elem || document; // Don't do events on text and comment nodes

      if (elem.nodeType === 3 || elem.nodeType === 8) {
        return;
      } // focus/blur morphs to focusin/out; ensure we're not firing them right now


      if (rfocusMorph.test(type + jQuery.event.triggered)) {
        return;
      }

      if (type.indexOf(".") > -1) {
        // Namespaced trigger; create a regexp to match event type in handle()
        namespaces = type.split(".");
        type = namespaces.shift();
        namespaces.sort();
      }

      ontype = type.indexOf(":") < 0 && "on" + type; // Caller can pass in a jQuery.Event object, Object, or just an event type string

      event = event[jQuery.expando] ? event : new jQuery.Event(type, _typeof(event) === "object" && event); // Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)

      event.isTrigger = onlyHandlers ? 2 : 3;
      event.namespace = namespaces.join(".");
      event.rnamespace = event.namespace ? new RegExp("(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)") : null; // Clean up the event in case it is being reused

      event.result = undefined;

      if (!event.target) {
        event.target = elem;
      } // Clone any incoming data and prepend the event, creating the handler arg list


      data = data == null ? [event] : jQuery.makeArray(data, [event]); // Allow special events to draw outside the lines

      special = jQuery.event.special[type] || {};

      if (!onlyHandlers && special.trigger && special.trigger.apply(elem, data) === false) {
        return;
      } // Determine event propagation path in advance, per W3C events spec (#9951)
      // Bubble up to document, then to window; watch for a global ownerDocument var (#9724)


      if (!onlyHandlers && !special.noBubble && !isWindow(elem)) {
        bubbleType = special.delegateType || type;

        if (!rfocusMorph.test(bubbleType + type)) {
          cur = cur.parentNode;
        }

        for (; cur; cur = cur.parentNode) {
          eventPath.push(cur);
          tmp = cur;
        } // Only add window if we got to document (e.g., not plain obj or detached DOM)


        if (tmp === (elem.ownerDocument || document)) {
          eventPath.push(tmp.defaultView || tmp.parentWindow || window);
        }
      } // Fire handlers on the event path


      i = 0;

      while ((cur = eventPath[i++]) && !event.isPropagationStopped()) {
        lastElement = cur;
        event.type = i > 1 ? bubbleType : special.bindType || type; // jQuery handler

        handle = (dataPriv.get(cur, "events") || Object.create(null))[event.type] && dataPriv.get(cur, "handle");

        if (handle) {
          handle.apply(cur, data);
        } // Native handler


        handle = ontype && cur[ontype];

        if (handle && handle.apply && acceptData(cur)) {
          event.result = handle.apply(cur, data);

          if (event.result === false) {
            event.preventDefault();
          }
        }
      }

      event.type = type; // If nobody prevented the default action, do it now

      if (!onlyHandlers && !event.isDefaultPrevented()) {
        if ((!special._default || special._default.apply(eventPath.pop(), data) === false) && acceptData(elem)) {
          // Call a native DOM method on the target with the same name as the event.
          // Don't do default actions on window, that's where global variables be (#6170)
          if (ontype && isFunction(elem[type]) && !isWindow(elem)) {
            // Don't re-trigger an onFOO event when we call its FOO() method
            tmp = elem[ontype];

            if (tmp) {
              elem[ontype] = null;
            } // Prevent re-triggering of the same event, since we already bubbled it above


            jQuery.event.triggered = type;

            if (event.isPropagationStopped()) {
              lastElement.addEventListener(type, stopPropagationCallback);
            }

            elem[type]();

            if (event.isPropagationStopped()) {
              lastElement.removeEventListener(type, stopPropagationCallback);
            }

            jQuery.event.triggered = undefined;

            if (tmp) {
              elem[ontype] = tmp;
            }
          }
        }
      }

      return event.result;
    },
    // Piggyback on a donor event to simulate a different one
    // Used only for `focus(in | out)` events
    simulate: function simulate(type, elem, event) {
      var e = jQuery.extend(new jQuery.Event(), event, {
        type: type,
        isSimulated: true
      });
      jQuery.event.trigger(e, null, elem);
    }
  });
  jQuery.fn.extend({
    trigger: function trigger(type, data) {
      return this.each(function () {
        jQuery.event.trigger(type, data, this);
      });
    },
    triggerHandler: function triggerHandler(type, data) {
      var elem = this[0];

      if (elem) {
        return jQuery.event.trigger(type, data, elem, true);
      }
    }
  }); // Support: Firefox <=44
  // Firefox doesn't have focus(in | out) events
  // Related ticket - https://bugzilla.mozilla.org/show_bug.cgi?id=687787
  //
  // Support: Chrome <=48 - 49, Safari <=9.0 - 9.1
  // focus(in | out) events fire after focus & blur events,
  // which is spec violation - http://www.w3.org/TR/DOM-Level-3-Events/#events-focusevent-event-order
  // Related ticket - https://bugs.chromium.org/p/chromium/issues/detail?id=449857

  if (!support.focusin) {
    jQuery.each({
      focus: "focusin",
      blur: "focusout"
    }, function (orig, fix) {
      // Attach a single capturing handler on the document while someone wants focusin/focusout
      var handler = function handler(event) {
        jQuery.event.simulate(fix, event.target, jQuery.event.fix(event));
      };

      jQuery.event.special[fix] = {
        setup: function setup() {
          // Handle: regular nodes (via `this.ownerDocument`), window
          // (via `this.document`) & document (via `this`).
          var doc = this.ownerDocument || this.document || this,
              attaches = dataPriv.access(doc, fix);

          if (!attaches) {
            doc.addEventListener(orig, handler, true);
          }

          dataPriv.access(doc, fix, (attaches || 0) + 1);
        },
        teardown: function teardown() {
          var doc = this.ownerDocument || this.document || this,
              attaches = dataPriv.access(doc, fix) - 1;

          if (!attaches) {
            doc.removeEventListener(orig, handler, true);
            dataPriv.remove(doc, fix);
          } else {
            dataPriv.access(doc, fix, attaches);
          }
        }
      };
    });
  }

  var location = window.location;
  var nonce = {
    guid: Date.now()
  };
  var rquery = /\?/; // Cross-browser xml parsing

  jQuery.parseXML = function (data) {
    var xml, parserErrorElem;

    if (!data || typeof data !== "string") {
      return null;
    } // Support: IE 9 - 11 only
    // IE throws on parseFromString with invalid input.


    try {
      xml = new window.DOMParser().parseFromString(data, "text/xml");
    } catch (e) {}

    parserErrorElem = xml && xml.getElementsByTagName("parsererror")[0];

    if (!xml || parserErrorElem) {
      jQuery.error("Invalid XML: " + (parserErrorElem ? jQuery.map(parserErrorElem.childNodes, function (el) {
        return el.textContent;
      }).join("\n") : data));
    }

    return xml;
  };

  var rbracket = /\[\]$/,
      rCRLF = /\r?\n/g,
      rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,
      rsubmittable = /^(?:input|select|textarea|keygen)/i;

  function buildParams(prefix, obj, traditional, add) {
    var name;

    if (Array.isArray(obj)) {
      // Serialize array item.
      jQuery.each(obj, function (i, v) {
        if (traditional || rbracket.test(prefix)) {
          // Treat each array item as a scalar.
          add(prefix, v);
        } else {
          // Item is non-scalar (array or object), encode its numeric index.
          buildParams(prefix + "[" + (_typeof(v) === "object" && v != null ? i : "") + "]", v, traditional, add);
        }
      });
    } else if (!traditional && toType(obj) === "object") {
      // Serialize object item.
      for (name in obj) {
        buildParams(prefix + "[" + name + "]", obj[name], traditional, add);
      }
    } else {
      // Serialize scalar item.
      add(prefix, obj);
    }
  } // Serialize an array of form elements or a set of
  // key/values into a query string


  jQuery.param = function (a, traditional) {
    var prefix,
        s = [],
        add = function add(key, valueOrFunction) {
      // If value is a function, invoke it and use its return value
      var value = isFunction(valueOrFunction) ? valueOrFunction() : valueOrFunction;
      s[s.length] = encodeURIComponent(key) + "=" + encodeURIComponent(value == null ? "" : value);
    };

    if (a == null) {
      return "";
    } // If an array was passed in, assume that it is an array of form elements.


    if (Array.isArray(a) || a.jquery && !jQuery.isPlainObject(a)) {
      // Serialize the form elements
      jQuery.each(a, function () {
        add(this.name, this.value);
      });
    } else {
      // If traditional, encode the "old" way (the way 1.3.2 or older
      // did it), otherwise encode params recursively.
      for (prefix in a) {
        buildParams(prefix, a[prefix], traditional, add);
      }
    } // Return the resulting serialization


    return s.join("&");
  };

  jQuery.fn.extend({
    serialize: function serialize() {
      return jQuery.param(this.serializeArray());
    },
    serializeArray: function serializeArray() {
      return this.map(function () {
        // Can add propHook for "elements" to filter or add form elements
        var elements = jQuery.prop(this, "elements");
        return elements ? jQuery.makeArray(elements) : this;
      }).filter(function () {
        var type = this.type; // Use .is( ":disabled" ) so that fieldset[disabled] works

        return this.name && !jQuery(this).is(":disabled") && rsubmittable.test(this.nodeName) && !rsubmitterTypes.test(type) && (this.checked || !rcheckableType.test(type));
      }).map(function (_i, elem) {
        var val = jQuery(this).val();

        if (val == null) {
          return null;
        }

        if (Array.isArray(val)) {
          return jQuery.map(val, function (val) {
            return {
              name: elem.name,
              value: val.replace(rCRLF, "\r\n")
            };
          });
        }

        return {
          name: elem.name,
          value: val.replace(rCRLF, "\r\n")
        };
      }).get();
    }
  });
  var r20 = /%20/g,
      rhash = /#.*$/,
      rantiCache = /([?&])_=[^&]*/,
      rheaders = /^(.*?):[ \t]*([^\r\n]*)$/mg,
      // #7653, #8125, #8152: local protocol detection
  rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,
      rnoContent = /^(?:GET|HEAD)$/,
      rprotocol = /^\/\//,

  /* Prefilters
   * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)
   * 2) These are called:
   *    - BEFORE asking for a transport
   *    - AFTER param serialization (s.data is a string if s.processData is true)
   * 3) key is the dataType
   * 4) the catchall symbol "*" can be used
   * 5) execution will start with transport dataType and THEN continue down to "*" if needed
   */
  prefilters = {},

  /* Transports bindings
   * 1) key is the dataType
   * 2) the catchall symbol "*" can be used
   * 3) selection will start with transport dataType and THEN go to "*" if needed
   */
  transports = {},
      // Avoid comment-prolog char sequence (#10098); must appease lint and evade compression
  allTypes = "*/".concat("*"),
      // Anchor tag for parsing the document origin
  originAnchor = document.createElement("a");
  originAnchor.href = location.href; // Base "constructor" for jQuery.ajaxPrefilter and jQuery.ajaxTransport

  function addToPrefiltersOrTransports(structure) {
    // dataTypeExpression is optional and defaults to "*"
    return function (dataTypeExpression, func) {
      if (typeof dataTypeExpression !== "string") {
        func = dataTypeExpression;
        dataTypeExpression = "*";
      }

      var dataType,
          i = 0,
          dataTypes = dataTypeExpression.toLowerCase().match(rnothtmlwhite) || [];

      if (isFunction(func)) {
        // For each dataType in the dataTypeExpression
        while (dataType = dataTypes[i++]) {
          // Prepend if requested
          if (dataType[0] === "+") {
            dataType = dataType.slice(1) || "*";
            (structure[dataType] = structure[dataType] || []).unshift(func); // Otherwise append
          } else {
            (structure[dataType] = structure[dataType] || []).push(func);
          }
        }
      }
    };
  } // Base inspection function for prefilters and transports


  function inspectPrefiltersOrTransports(structure, options, originalOptions, jqXHR) {
    var inspected = {},
        seekingTransport = structure === transports;

    function inspect(dataType) {
      var selected;
      inspected[dataType] = true;
      jQuery.each(structure[dataType] || [], function (_, prefilterOrFactory) {
        var dataTypeOrTransport = prefilterOrFactory(options, originalOptions, jqXHR);

        if (typeof dataTypeOrTransport === "string" && !seekingTransport && !inspected[dataTypeOrTransport]) {
          options.dataTypes.unshift(dataTypeOrTransport);
          inspect(dataTypeOrTransport);
          return false;
        } else if (seekingTransport) {
          return !(selected = dataTypeOrTransport);
        }
      });
      return selected;
    }

    return inspect(options.dataTypes[0]) || !inspected["*"] && inspect("*");
  } // A special extend for ajax options
  // that takes "flat" options (not to be deep extended)
  // Fixes #9887


  function ajaxExtend(target, src) {
    var key,
        deep,
        flatOptions = jQuery.ajaxSettings.flatOptions || {};

    for (key in src) {
      if (src[key] !== undefined) {
        (flatOptions[key] ? target : deep || (deep = {}))[key] = src[key];
      }
    }

    if (deep) {
      jQuery.extend(true, target, deep);
    }

    return target;
  }
  /* Handles responses to an ajax request:
   * - finds the right dataType (mediates between content-type and expected dataType)
   * - returns the corresponding response
   */


  function ajaxHandleResponses(s, jqXHR, responses) {
    var ct,
        type,
        finalDataType,
        firstDataType,
        contents = s.contents,
        dataTypes = s.dataTypes; // Remove auto dataType and get content-type in the process

    while (dataTypes[0] === "*") {
      dataTypes.shift();

      if (ct === undefined) {
        ct = s.mimeType || jqXHR.getResponseHeader("Content-Type");
      }
    } // Check if we're dealing with a known content-type


    if (ct) {
      for (type in contents) {
        if (contents[type] && contents[type].test(ct)) {
          dataTypes.unshift(type);
          break;
        }
      }
    } // Check to see if we have a response for the expected dataType


    if (dataTypes[0] in responses) {
      finalDataType = dataTypes[0];
    } else {
      // Try convertible dataTypes
      for (type in responses) {
        if (!dataTypes[0] || s.converters[type + " " + dataTypes[0]]) {
          finalDataType = type;
          break;
        }

        if (!firstDataType) {
          firstDataType = type;
        }
      } // Or just use first one


      finalDataType = finalDataType || firstDataType;
    } // If we found a dataType
    // We add the dataType to the list if needed
    // and return the corresponding response


    if (finalDataType) {
      if (finalDataType !== dataTypes[0]) {
        dataTypes.unshift(finalDataType);
      }

      return responses[finalDataType];
    }
  }
  /* Chain conversions given the request and the original response
   * Also sets the responseXXX fields on the jqXHR instance
   */


  function ajaxConvert(s, response, jqXHR, isSuccess) {
    var conv2,
        current,
        conv,
        tmp,
        prev,
        converters = {},
        // Work with a copy of dataTypes in case we need to modify it for conversion
    dataTypes = s.dataTypes.slice(); // Create converters map with lowercased keys

    if (dataTypes[1]) {
      for (conv in s.converters) {
        converters[conv.toLowerCase()] = s.converters[conv];
      }
    }

    current = dataTypes.shift(); // Convert to each sequential dataType

    while (current) {
      if (s.responseFields[current]) {
        jqXHR[s.responseFields[current]] = response;
      } // Apply the dataFilter if provided


      if (!prev && isSuccess && s.dataFilter) {
        response = s.dataFilter(response, s.dataType);
      }

      prev = current;
      current = dataTypes.shift();

      if (current) {
        // There's only work to do if current dataType is non-auto
        if (current === "*") {
          current = prev; // Convert response if prev dataType is non-auto and differs from current
        } else if (prev !== "*" && prev !== current) {
          // Seek a direct converter
          conv = converters[prev + " " + current] || converters["* " + current]; // If none found, seek a pair

          if (!conv) {
            for (conv2 in converters) {
              // If conv2 outputs current
              tmp = conv2.split(" ");

              if (tmp[1] === current) {
                // If prev can be converted to accepted input
                conv = converters[prev + " " + tmp[0]] || converters["* " + tmp[0]];

                if (conv) {
                  // Condense equivalence converters
                  if (conv === true) {
                    conv = converters[conv2]; // Otherwise, insert the intermediate dataType
                  } else if (converters[conv2] !== true) {
                    current = tmp[0];
                    dataTypes.unshift(tmp[1]);
                  }

                  break;
                }
              }
            }
          } // Apply converter (if not an equivalence)


          if (conv !== true) {
            // Unless errors are allowed to bubble, catch and return them
            if (conv && s["throws"]) {
              response = conv(response);
            } else {
              try {
                response = conv(response);
              } catch (e) {
                return {
                  state: "parsererror",
                  error: conv ? e : "No conversion from " + prev + " to " + current
                };
              }
            }
          }
        }
      }
    }

    return {
      state: "success",
      data: response
    };
  }

  jQuery.extend({
    // Counter for holding the number of active queries
    active: 0,
    // Last-Modified header cache for next request
    lastModified: {},
    etag: {},
    ajaxSettings: {
      url: location.href,
      type: "GET",
      isLocal: rlocalProtocol.test(location.protocol),
      global: true,
      processData: true,
      async: true,
      contentType: "application/x-www-form-urlencoded; charset=UTF-8",

      /*
      timeout: 0,
      data: null,
      dataType: null,
      username: null,
      password: null,
      cache: null,
      throws: false,
      traditional: false,
      headers: {},
      */
      accepts: {
        "*": allTypes,
        text: "text/plain",
        html: "text/html",
        xml: "application/xml, text/xml",
        json: "application/json, text/javascript"
      },
      contents: {
        xml: /\bxml\b/,
        html: /\bhtml/,
        json: /\bjson\b/
      },
      responseFields: {
        xml: "responseXML",
        text: "responseText",
        json: "responseJSON"
      },
      // Data converters
      // Keys separate source (or catchall "*") and destination types with a single space
      converters: {
        // Convert anything to text
        "* text": String,
        // Text to html (true = no transformation)
        "text html": true,
        // Evaluate text as a json expression
        "text json": JSON.parse,
        // Parse text as xml
        "text xml": jQuery.parseXML
      },
      // For options that shouldn't be deep extended:
      // you can add your own custom options here if
      // and when you create one that shouldn't be
      // deep extended (see ajaxExtend)
      flatOptions: {
        url: true,
        context: true
      }
    },
    // Creates a full fledged settings object into target
    // with both ajaxSettings and settings fields.
    // If target is omitted, writes into ajaxSettings.
    ajaxSetup: function ajaxSetup(target, settings) {
      return settings ? // Building a settings object
      ajaxExtend(ajaxExtend(target, jQuery.ajaxSettings), settings) : // Extending ajaxSettings
      ajaxExtend(jQuery.ajaxSettings, target);
    },
    ajaxPrefilter: addToPrefiltersOrTransports(prefilters),
    ajaxTransport: addToPrefiltersOrTransports(transports),
    // Main method
    ajax: function ajax(url, options) {
      // If url is an object, simulate pre-1.5 signature
      if (_typeof(url) === "object") {
        options = url;
        url = undefined;
      } // Force options to be an object


      options = options || {};

      var transport,
          // URL without anti-cache param
      cacheURL,
          // Response headers
      responseHeadersString,
          responseHeaders,
          // timeout handle
      timeoutTimer,
          // Url cleanup var
      urlAnchor,
          // Request state (becomes false upon send and true upon completion)
      completed,
          // To know if global events are to be dispatched
      fireGlobals,
          // Loop variable
      i,
          // uncached part of the url
      uncached,
          // Create the final options object
      s = jQuery.ajaxSetup({}, options),
          // Callbacks context
      callbackContext = s.context || s,
          // Context for global events is callbackContext if it is a DOM node or jQuery collection
      globalEventContext = s.context && (callbackContext.nodeType || callbackContext.jquery) ? jQuery(callbackContext) : jQuery.event,
          // Deferreds
      deferred = jQuery.Deferred(),
          completeDeferred = jQuery.Callbacks("once memory"),
          // Status-dependent callbacks
      _statusCode = s.statusCode || {},
          // Headers (they are sent all at once)
      requestHeaders = {},
          requestHeadersNames = {},
          // Default abort message
      strAbort = "canceled",
          // Fake xhr
      jqXHR = {
        readyState: 0,
        // Builds headers hashtable if needed
        getResponseHeader: function getResponseHeader(key) {
          var match;

          if (completed) {
            if (!responseHeaders) {
              responseHeaders = {};

              while (match = rheaders.exec(responseHeadersString)) {
                responseHeaders[match[1].toLowerCase() + " "] = (responseHeaders[match[1].toLowerCase() + " "] || []).concat(match[2]);
              }
            }

            match = responseHeaders[key.toLowerCase() + " "];
          }

          return match == null ? null : match.join(", ");
        },
        // Raw string
        getAllResponseHeaders: function getAllResponseHeaders() {
          return completed ? responseHeadersString : null;
        },
        // Caches the header
        setRequestHeader: function setRequestHeader(name, value) {
          if (completed == null) {
            name = requestHeadersNames[name.toLowerCase()] = requestHeadersNames[name.toLowerCase()] || name;
            requestHeaders[name] = value;
          }

          return this;
        },
        // Overrides response content-type header
        overrideMimeType: function overrideMimeType(type) {
          if (completed == null) {
            s.mimeType = type;
          }

          return this;
        },
        // Status-dependent callbacks
        statusCode: function statusCode(map) {
          var code;

          if (map) {
            if (completed) {
              // Execute the appropriate callbacks
              jqXHR.always(map[jqXHR.status]);
            } else {
              // Lazy-add the new callbacks in a way that preserves old ones
              for (code in map) {
                _statusCode[code] = [_statusCode[code], map[code]];
              }
            }
          }

          return this;
        },
        // Cancel the request
        abort: function abort(statusText) {
          var finalText = statusText || strAbort;

          if (transport) {
            transport.abort(finalText);
          }

          done(0, finalText);
          return this;
        }
      }; // Attach deferreds


      deferred.promise(jqXHR); // Add protocol if not provided (prefilters might expect it)
      // Handle falsy url in the settings object (#10093: consistency with old signature)
      // We also use the url parameter if available

      s.url = ((url || s.url || location.href) + "").replace(rprotocol, location.protocol + "//"); // Alias method option to type as per ticket #12004

      s.type = options.method || options.type || s.method || s.type; // Extract dataTypes list

      s.dataTypes = (s.dataType || "*").toLowerCase().match(rnothtmlwhite) || [""]; // A cross-domain request is in order when the origin doesn't match the current origin.

      if (s.crossDomain == null) {
        urlAnchor = document.createElement("a"); // Support: IE <=8 - 11, Edge 12 - 15
        // IE throws exception on accessing the href property if url is malformed,
        // e.g. http://example.com:80x/

        try {
          urlAnchor.href = s.url; // Support: IE <=8 - 11 only
          // Anchor's host property isn't correctly set when s.url is relative

          urlAnchor.href = urlAnchor.href;
          s.crossDomain = originAnchor.protocol + "//" + originAnchor.host !== urlAnchor.protocol + "//" + urlAnchor.host;
        } catch (e) {
          // If there is an error parsing the URL, assume it is crossDomain,
          // it can be rejected by the transport if it is invalid
          s.crossDomain = true;
        }
      } // Convert data if not already a string


      if (s.data && s.processData && typeof s.data !== "string") {
        s.data = jQuery.param(s.data, s.traditional);
      } // Apply prefilters


      inspectPrefiltersOrTransports(prefilters, s, options, jqXHR); // If request was aborted inside a prefilter, stop there

      if (completed) {
        return jqXHR;
      } // We can fire global events as of now if asked to
      // Don't fire events if jQuery.event is undefined in an AMD-usage scenario (#15118)


      fireGlobals = jQuery.event && s.global; // Watch for a new set of requests

      if (fireGlobals && jQuery.active++ === 0) {
        jQuery.event.trigger("ajaxStart");
      } // Uppercase the type


      s.type = s.type.toUpperCase(); // Determine if request has content

      s.hasContent = !rnoContent.test(s.type); // Save the URL in case we're toying with the If-Modified-Since
      // and/or If-None-Match header later on
      // Remove hash to simplify url manipulation

      cacheURL = s.url.replace(rhash, ""); // More options handling for requests with no content

      if (!s.hasContent) {
        // Remember the hash so we can put it back
        uncached = s.url.slice(cacheURL.length); // If data is available and should be processed, append data to url

        if (s.data && (s.processData || typeof s.data === "string")) {
          cacheURL += (rquery.test(cacheURL) ? "&" : "?") + s.data; // #9682: remove data so that it's not used in an eventual retry

          delete s.data;
        } // Add or update anti-cache param if needed


        if (s.cache === false) {
          cacheURL = cacheURL.replace(rantiCache, "$1");
          uncached = (rquery.test(cacheURL) ? "&" : "?") + "_=" + nonce.guid++ + uncached;
        } // Put hash and anti-cache on the URL that will be requested (gh-1732)


        s.url = cacheURL + uncached; // Change '%20' to '+' if this is encoded form body content (gh-2658)
      } else if (s.data && s.processData && (s.contentType || "").indexOf("application/x-www-form-urlencoded") === 0) {
        s.data = s.data.replace(r20, "+");
      } // Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.


      if (s.ifModified) {
        if (jQuery.lastModified[cacheURL]) {
          jqXHR.setRequestHeader("If-Modified-Since", jQuery.lastModified[cacheURL]);
        }

        if (jQuery.etag[cacheURL]) {
          jqXHR.setRequestHeader("If-None-Match", jQuery.etag[cacheURL]);
        }
      } // Set the correct header, if data is being sent


      if (s.data && s.hasContent && s.contentType !== false || options.contentType) {
        jqXHR.setRequestHeader("Content-Type", s.contentType);
      } // Set the Accepts header for the server, depending on the dataType


      jqXHR.setRequestHeader("Accept", s.dataTypes[0] && s.accepts[s.dataTypes[0]] ? s.accepts[s.dataTypes[0]] + (s.dataTypes[0] !== "*" ? ", " + allTypes + "; q=0.01" : "") : s.accepts["*"]); // Check for headers option

      for (i in s.headers) {
        jqXHR.setRequestHeader(i, s.headers[i]);
      } // Allow custom headers/mimetypes and early abort


      if (s.beforeSend && (s.beforeSend.call(callbackContext, jqXHR, s) === false || completed)) {
        // Abort if not done already and return
        return jqXHR.abort();
      } // Aborting is no longer a cancellation


      strAbort = "abort"; // Install callbacks on deferreds

      completeDeferred.add(s.complete);
      jqXHR.done(s.success);
      jqXHR.fail(s.error); // Get transport

      transport = inspectPrefiltersOrTransports(transports, s, options, jqXHR); // If no transport, we auto-abort

      if (!transport) {
        done(-1, "No Transport");
      } else {
        jqXHR.readyState = 1; // Send global event

        if (fireGlobals) {
          globalEventContext.trigger("ajaxSend", [jqXHR, s]);
        } // If request was aborted inside ajaxSend, stop there


        if (completed) {
          return jqXHR;
        } // Timeout


        if (s.async && s.timeout > 0) {
          timeoutTimer = window.setTimeout(function () {
            jqXHR.abort("timeout");
          }, s.timeout);
        }

        try {
          completed = false;
          transport.send(requestHeaders, done);
        } catch (e) {
          // Rethrow post-completion exceptions
          if (completed) {
            throw e;
          } // Propagate others as results


          done(-1, e);
        }
      } // Callback for when everything is done


      function done(status, nativeStatusText, responses, headers) {
        var isSuccess,
            success,
            error,
            response,
            modified,
            statusText = nativeStatusText; // Ignore repeat invocations

        if (completed) {
          return;
        }

        completed = true; // Clear timeout if it exists

        if (timeoutTimer) {
          window.clearTimeout(timeoutTimer);
        } // Dereference transport for early garbage collection
        // (no matter how long the jqXHR object will be used)


        transport = undefined; // Cache response headers

        responseHeadersString = headers || ""; // Set readyState

        jqXHR.readyState = status > 0 ? 4 : 0; // Determine if successful

        isSuccess = status >= 200 && status < 300 || status === 304; // Get response data

        if (responses) {
          response = ajaxHandleResponses(s, jqXHR, responses);
        } // Use a noop converter for missing script but not if jsonp


        if (!isSuccess && jQuery.inArray("script", s.dataTypes) > -1 && jQuery.inArray("json", s.dataTypes) < 0) {
          s.converters["text script"] = function () {};
        } // Convert no matter what (that way responseXXX fields are always set)


        response = ajaxConvert(s, response, jqXHR, isSuccess); // If successful, handle type chaining

        if (isSuccess) {
          // Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
          if (s.ifModified) {
            modified = jqXHR.getResponseHeader("Last-Modified");

            if (modified) {
              jQuery.lastModified[cacheURL] = modified;
            }

            modified = jqXHR.getResponseHeader("etag");

            if (modified) {
              jQuery.etag[cacheURL] = modified;
            }
          } // if no content


          if (status === 204 || s.type === "HEAD") {
            statusText = "nocontent"; // if not modified
          } else if (status === 304) {
            statusText = "notmodified"; // If we have data, let's convert it
          } else {
            statusText = response.state;
            success = response.data;
            error = response.error;
            isSuccess = !error;
          }
        } else {
          // Extract error from statusText and normalize for non-aborts
          error = statusText;

          if (status || !statusText) {
            statusText = "error";

            if (status < 0) {
              status = 0;
            }
          }
        } // Set data for the fake xhr object


        jqXHR.status = status;
        jqXHR.statusText = (nativeStatusText || statusText) + ""; // Success/Error

        if (isSuccess) {
          deferred.resolveWith(callbackContext, [success, statusText, jqXHR]);
        } else {
          deferred.rejectWith(callbackContext, [jqXHR, statusText, error]);
        } // Status-dependent callbacks


        jqXHR.statusCode(_statusCode);
        _statusCode = undefined;

        if (fireGlobals) {
          globalEventContext.trigger(isSuccess ? "ajaxSuccess" : "ajaxError", [jqXHR, s, isSuccess ? success : error]);
        } // Complete


        completeDeferred.fireWith(callbackContext, [jqXHR, statusText]);

        if (fireGlobals) {
          globalEventContext.trigger("ajaxComplete", [jqXHR, s]); // Handle the global AJAX counter

          if (! --jQuery.active) {
            jQuery.event.trigger("ajaxStop");
          }
        }
      }

      return jqXHR;
    },
    getJSON: function getJSON(url, data, callback) {
      return jQuery.get(url, data, callback, "json");
    },
    getScript: function getScript(url, callback) {
      return jQuery.get(url, undefined, callback, "script");
    }
  });
  jQuery.each(["get", "post"], function (_i, method) {
    jQuery[method] = function (url, data, callback, type) {
      // Shift arguments if data argument was omitted
      if (isFunction(data)) {
        type = type || callback;
        callback = data;
        data = undefined;
      } // The url can be an options object (which then must have .url)


      return jQuery.ajax(jQuery.extend({
        url: url,
        type: method,
        dataType: type,
        data: data,
        success: callback
      }, jQuery.isPlainObject(url) && url));
    };
  });
  jQuery.ajaxPrefilter(function (s) {
    var i;

    for (i in s.headers) {
      if (i.toLowerCase() === "content-type") {
        s.contentType = s.headers[i] || "";
      }
    }
  });

  jQuery._evalUrl = function (url, options, doc) {
    return jQuery.ajax({
      url: url,
      // Make this explicit, since user can override this through ajaxSetup (#11264)
      type: "GET",
      dataType: "script",
      cache: true,
      async: false,
      global: false,
      // Only evaluate the response if it is successful (gh-4126)
      // dataFilter is not invoked for failure responses, so using it instead
      // of the default converter is kludgy but it works.
      converters: {
        "text script": function textScript() {}
      },
      dataFilter: function dataFilter(response) {
        jQuery.globalEval(response, options, doc);
      }
    });
  };

  jQuery.fn.extend({
    wrapAll: function wrapAll(html) {
      var wrap;

      if (this[0]) {
        if (isFunction(html)) {
          html = html.call(this[0]);
        } // The elements to wrap the target around


        wrap = jQuery(html, this[0].ownerDocument).eq(0).clone(true);

        if (this[0].parentNode) {
          wrap.insertBefore(this[0]);
        }

        wrap.map(function () {
          var elem = this;

          while (elem.firstElementChild) {
            elem = elem.firstElementChild;
          }

          return elem;
        }).append(this);
      }

      return this;
    },
    wrapInner: function wrapInner(html) {
      if (isFunction(html)) {
        return this.each(function (i) {
          jQuery(this).wrapInner(html.call(this, i));
        });
      }

      return this.each(function () {
        var self = jQuery(this),
            contents = self.contents();

        if (contents.length) {
          contents.wrapAll(html);
        } else {
          self.append(html);
        }
      });
    },
    wrap: function wrap(html) {
      var htmlIsFunction = isFunction(html);
      return this.each(function (i) {
        jQuery(this).wrapAll(htmlIsFunction ? html.call(this, i) : html);
      });
    },
    unwrap: function unwrap(selector) {
      this.parent(selector).not("body").each(function () {
        jQuery(this).replaceWith(this.childNodes);
      });
      return this;
    }
  });

  jQuery.expr.pseudos.hidden = function (elem) {
    return !jQuery.expr.pseudos.visible(elem);
  };

  jQuery.expr.pseudos.visible = function (elem) {
    return !!(elem.offsetWidth || elem.offsetHeight || elem.getClientRects().length);
  };

  jQuery.ajaxSettings.xhr = function () {
    try {
      return new window.XMLHttpRequest();
    } catch (e) {}
  };

  var xhrSuccessStatus = {
    // File protocol always yields status code 0, assume 200
    0: 200,
    // Support: IE <=9 only
    // #1450: sometimes IE returns 1223 when it should be 204
    1223: 204
  },
      xhrSupported = jQuery.ajaxSettings.xhr();
  support.cors = !!xhrSupported && "withCredentials" in xhrSupported;
  support.ajax = xhrSupported = !!xhrSupported;
  jQuery.ajaxTransport(function (options) {
    var _callback, errorCallback; // Cross domain only allowed if supported through XMLHttpRequest


    if (support.cors || xhrSupported && !options.crossDomain) {
      return {
        send: function send(headers, complete) {
          var i,
              xhr = options.xhr();
          xhr.open(options.type, options.url, options.async, options.username, options.password); // Apply custom fields if provided

          if (options.xhrFields) {
            for (i in options.xhrFields) {
              xhr[i] = options.xhrFields[i];
            }
          } // Override mime type if needed


          if (options.mimeType && xhr.overrideMimeType) {
            xhr.overrideMimeType(options.mimeType);
          } // X-Requested-With header
          // For cross-domain requests, seeing as conditions for a preflight are
          // akin to a jigsaw puzzle, we simply never set it to be sure.
          // (it can always be set on a per-request basis or even using ajaxSetup)
          // For same-domain requests, won't change header if already provided.


          if (!options.crossDomain && !headers["X-Requested-With"]) {
            headers["X-Requested-With"] = "XMLHttpRequest";
          } // Set headers


          for (i in headers) {
            xhr.setRequestHeader(i, headers[i]);
          } // Callback


          _callback = function callback(type) {
            return function () {
              if (_callback) {
                _callback = errorCallback = xhr.onload = xhr.onerror = xhr.onabort = xhr.ontimeout = xhr.onreadystatechange = null;

                if (type === "abort") {
                  xhr.abort();
                } else if (type === "error") {
                  // Support: IE <=9 only
                  // On a manual native abort, IE9 throws
                  // errors on any property access that is not readyState
                  if (typeof xhr.status !== "number") {
                    complete(0, "error");
                  } else {
                    complete( // File: protocol always yields status 0; see #8605, #14207
                    xhr.status, xhr.statusText);
                  }
                } else {
                  complete(xhrSuccessStatus[xhr.status] || xhr.status, xhr.statusText, // Support: IE <=9 only
                  // IE9 has no XHR2 but throws on binary (trac-11426)
                  // For XHR2 non-text, let the caller handle it (gh-2498)
                  (xhr.responseType || "text") !== "text" || typeof xhr.responseText !== "string" ? {
                    binary: xhr.response
                  } : {
                    text: xhr.responseText
                  }, xhr.getAllResponseHeaders());
                }
              }
            };
          }; // Listen to events


          xhr.onload = _callback();
          errorCallback = xhr.onerror = xhr.ontimeout = _callback("error"); // Support: IE 9 only
          // Use onreadystatechange to replace onabort
          // to handle uncaught aborts

          if (xhr.onabort !== undefined) {
            xhr.onabort = errorCallback;
          } else {
            xhr.onreadystatechange = function () {
              // Check readyState before timeout as it changes
              if (xhr.readyState === 4) {
                // Allow onerror to be called first,
                // but that will not handle a native abort
                // Also, save errorCallback to a variable
                // as xhr.onerror cannot be accessed
                window.setTimeout(function () {
                  if (_callback) {
                    errorCallback();
                  }
                });
              }
            };
          } // Create the abort callback


          _callback = _callback("abort");

          try {
            // Do send the request (this may raise an exception)
            xhr.send(options.hasContent && options.data || null);
          } catch (e) {
            // #14683: Only rethrow if this hasn't been notified as an error yet
            if (_callback) {
              throw e;
            }
          }
        },
        abort: function abort() {
          if (_callback) {
            _callback();
          }
        }
      };
    }
  }); // Prevent auto-execution of scripts when no explicit dataType was provided (See gh-2432)

  jQuery.ajaxPrefilter(function (s) {
    if (s.crossDomain) {
      s.contents.script = false;
    }
  }); // Install script dataType

  jQuery.ajaxSetup({
    accepts: {
      script: "text/javascript, application/javascript, " + "application/ecmascript, application/x-ecmascript"
    },
    contents: {
      script: /\b(?:java|ecma)script\b/
    },
    converters: {
      "text script": function textScript(text) {
        jQuery.globalEval(text);
        return text;
      }
    }
  }); // Handle cache's special case and crossDomain

  jQuery.ajaxPrefilter("script", function (s) {
    if (s.cache === undefined) {
      s.cache = false;
    }

    if (s.crossDomain) {
      s.type = "GET";
    }
  }); // Bind script tag hack transport

  jQuery.ajaxTransport("script", function (s) {
    // This transport only deals with cross domain or forced-by-attrs requests
    if (s.crossDomain || s.scriptAttrs) {
      var script, _callback2;

      return {
        send: function send(_, complete) {
          script = jQuery("<script>").attr(s.scriptAttrs || {}).prop({
            charset: s.scriptCharset,
            src: s.url
          }).on("load error", _callback2 = function callback(evt) {
            script.remove();
            _callback2 = null;

            if (evt) {
              complete(evt.type === "error" ? 404 : 200, evt.type);
            }
          }); // Use native DOM manipulation to avoid our domManip AJAX trickery

          document.head.appendChild(script[0]);
        },
        abort: function abort() {
          if (_callback2) {
            _callback2();
          }
        }
      };
    }
  });
  var oldCallbacks = [],
      rjsonp = /(=)\?(?=&|$)|\?\?/; // Default jsonp settings

  jQuery.ajaxSetup({
    jsonp: "callback",
    jsonpCallback: function jsonpCallback() {
      var callback = oldCallbacks.pop() || jQuery.expando + "_" + nonce.guid++;
      this[callback] = true;
      return callback;
    }
  }); // Detect, normalize options and install callbacks for jsonp requests

  jQuery.ajaxPrefilter("json jsonp", function (s, originalSettings, jqXHR) {
    var callbackName,
        overwritten,
        responseContainer,
        jsonProp = s.jsonp !== false && (rjsonp.test(s.url) ? "url" : typeof s.data === "string" && (s.contentType || "").indexOf("application/x-www-form-urlencoded") === 0 && rjsonp.test(s.data) && "data"); // Handle iff the expected data type is "jsonp" or we have a parameter to set

    if (jsonProp || s.dataTypes[0] === "jsonp") {
      // Get callback name, remembering preexisting value associated with it
      callbackName = s.jsonpCallback = isFunction(s.jsonpCallback) ? s.jsonpCallback() : s.jsonpCallback; // Insert callback into url or form data

      if (jsonProp) {
        s[jsonProp] = s[jsonProp].replace(rjsonp, "$1" + callbackName);
      } else if (s.jsonp !== false) {
        s.url += (rquery.test(s.url) ? "&" : "?") + s.jsonp + "=" + callbackName;
      } // Use data converter to retrieve json after script execution


      s.converters["script json"] = function () {
        if (!responseContainer) {
          jQuery.error(callbackName + " was not called");
        }

        return responseContainer[0];
      }; // Force json dataType


      s.dataTypes[0] = "json"; // Install callback

      overwritten = window[callbackName];

      window[callbackName] = function () {
        responseContainer = arguments;
      }; // Clean-up function (fires after converters)


      jqXHR.always(function () {
        // If previous value didn't exist - remove it
        if (overwritten === undefined) {
          jQuery(window).removeProp(callbackName); // Otherwise restore preexisting value
        } else {
          window[callbackName] = overwritten;
        } // Save back as free


        if (s[callbackName]) {
          // Make sure that re-using the options doesn't screw things around
          s.jsonpCallback = originalSettings.jsonpCallback; // Save the callback name for future use

          oldCallbacks.push(callbackName);
        } // Call if it was a function and we have a response


        if (responseContainer && isFunction(overwritten)) {
          overwritten(responseContainer[0]);
        }

        responseContainer = overwritten = undefined;
      }); // Delegate to script

      return "script";
    }
  }); // Support: Safari 8 only
  // In Safari 8 documents created via document.implementation.createHTMLDocument
  // collapse sibling forms: the second one becomes a child of the first one.
  // Because of that, this security measure has to be disabled in Safari 8.
  // https://bugs.webkit.org/show_bug.cgi?id=137337

  support.createHTMLDocument = function () {
    var body = document.implementation.createHTMLDocument("").body;
    body.innerHTML = "<form></form><form></form>";
    return body.childNodes.length === 2;
  }(); // Argument "data" should be string of html
  // context (optional): If specified, the fragment will be created in this context,
  // defaults to document
  // keepScripts (optional): If true, will include scripts passed in the html string


  jQuery.parseHTML = function (data, context, keepScripts) {
    if (typeof data !== "string") {
      return [];
    }

    if (typeof context === "boolean") {
      keepScripts = context;
      context = false;
    }

    var base, parsed, scripts;

    if (!context) {
      // Stop scripts or inline event handlers from being executed immediately
      // by using document.implementation
      if (support.createHTMLDocument) {
        context = document.implementation.createHTMLDocument(""); // Set the base href for the created document
        // so any parsed elements with URLs
        // are based on the document's URL (gh-2965)

        base = context.createElement("base");
        base.href = document.location.href;
        context.head.appendChild(base);
      } else {
        context = document;
      }
    }

    parsed = rsingleTag.exec(data);
    scripts = !keepScripts && []; // Single tag

    if (parsed) {
      return [context.createElement(parsed[1])];
    }

    parsed = buildFragment([data], context, scripts);

    if (scripts && scripts.length) {
      jQuery(scripts).remove();
    }

    return jQuery.merge([], parsed.childNodes);
  };
  /**
   * Load a url into a page
   */


  jQuery.fn.load = function (url, params, callback) {
    var selector,
        type,
        response,
        self = this,
        off = url.indexOf(" ");

    if (off > -1) {
      selector = stripAndCollapse(url.slice(off));
      url = url.slice(0, off);
    } // If it's a function


    if (isFunction(params)) {
      // We assume that it's the callback
      callback = params;
      params = undefined; // Otherwise, build a param string
    } else if (params && _typeof(params) === "object") {
      type = "POST";
    } // If we have elements to modify, make the request


    if (self.length > 0) {
      jQuery.ajax({
        url: url,
        // If "type" variable is undefined, then "GET" method will be used.
        // Make value of this field explicit since
        // user can override it through ajaxSetup method
        type: type || "GET",
        dataType: "html",
        data: params
      }).done(function (responseText) {
        // Save response for use in complete callback
        response = arguments;
        self.html(selector ? // If a selector was specified, locate the right elements in a dummy div
        // Exclude scripts to avoid IE 'Permission Denied' errors
        jQuery("<div>").append(jQuery.parseHTML(responseText)).find(selector) : // Otherwise use the full result
        responseText); // If the request succeeds, this function gets "data", "status", "jqXHR"
        // but they are ignored because response was set above.
        // If it fails, this function gets "jqXHR", "status", "error"
      }).always(callback && function (jqXHR, status) {
        self.each(function () {
          callback.apply(this, response || [jqXHR.responseText, status, jqXHR]);
        });
      });
    }

    return this;
  };

  jQuery.expr.pseudos.animated = function (elem) {
    return jQuery.grep(jQuery.timers, function (fn) {
      return elem === fn.elem;
    }).length;
  };

  jQuery.offset = {
    setOffset: function setOffset(elem, options, i) {
      var curPosition,
          curLeft,
          curCSSTop,
          curTop,
          curOffset,
          curCSSLeft,
          calculatePosition,
          position = jQuery.css(elem, "position"),
          curElem = jQuery(elem),
          props = {}; // Set position first, in-case top/left are set even on static elem

      if (position === "static") {
        elem.style.position = "relative";
      }

      curOffset = curElem.offset();
      curCSSTop = jQuery.css(elem, "top");
      curCSSLeft = jQuery.css(elem, "left");
      calculatePosition = (position === "absolute" || position === "fixed") && (curCSSTop + curCSSLeft).indexOf("auto") > -1; // Need to be able to calculate position if either
      // top or left is auto and position is either absolute or fixed

      if (calculatePosition) {
        curPosition = curElem.position();
        curTop = curPosition.top;
        curLeft = curPosition.left;
      } else {
        curTop = parseFloat(curCSSTop) || 0;
        curLeft = parseFloat(curCSSLeft) || 0;
      }

      if (isFunction(options)) {
        // Use jQuery.extend here to allow modification of coordinates argument (gh-1848)
        options = options.call(elem, i, jQuery.extend({}, curOffset));
      }

      if (options.top != null) {
        props.top = options.top - curOffset.top + curTop;
      }

      if (options.left != null) {
        props.left = options.left - curOffset.left + curLeft;
      }

      if ("using" in options) {
        options.using.call(elem, props);
      } else {
        curElem.css(props);
      }
    }
  };
  jQuery.fn.extend({
    // offset() relates an element's border box to the document origin
    offset: function offset(options) {
      // Preserve chaining for setter
      if (arguments.length) {
        return options === undefined ? this : this.each(function (i) {
          jQuery.offset.setOffset(this, options, i);
        });
      }

      var rect,
          win,
          elem = this[0];

      if (!elem) {
        return;
      } // Return zeros for disconnected and hidden (display: none) elements (gh-2310)
      // Support: IE <=11 only
      // Running getBoundingClientRect on a
      // disconnected node in IE throws an error


      if (!elem.getClientRects().length) {
        return {
          top: 0,
          left: 0
        };
      } // Get document-relative position by adding viewport scroll to viewport-relative gBCR


      rect = elem.getBoundingClientRect();
      win = elem.ownerDocument.defaultView;
      return {
        top: rect.top + win.pageYOffset,
        left: rect.left + win.pageXOffset
      };
    },
    // position() relates an element's margin box to its offset parent's padding box
    // This corresponds to the behavior of CSS absolute positioning
    position: function position() {
      if (!this[0]) {
        return;
      }

      var offsetParent,
          offset,
          doc,
          elem = this[0],
          parentOffset = {
        top: 0,
        left: 0
      }; // position:fixed elements are offset from the viewport, which itself always has zero offset

      if (jQuery.css(elem, "position") === "fixed") {
        // Assume position:fixed implies availability of getBoundingClientRect
        offset = elem.getBoundingClientRect();
      } else {
        offset = this.offset(); // Account for the *real* offset parent, which can be the document or its root element
        // when a statically positioned element is identified

        doc = elem.ownerDocument;
        offsetParent = elem.offsetParent || doc.documentElement;

        while (offsetParent && (offsetParent === doc.body || offsetParent === doc.documentElement) && jQuery.css(offsetParent, "position") === "static") {
          offsetParent = offsetParent.parentNode;
        }

        if (offsetParent && offsetParent !== elem && offsetParent.nodeType === 1) {
          // Incorporate borders into its offset, since they are outside its content origin
          parentOffset = jQuery(offsetParent).offset();
          parentOffset.top += jQuery.css(offsetParent, "borderTopWidth", true);
          parentOffset.left += jQuery.css(offsetParent, "borderLeftWidth", true);
        }
      } // Subtract parent offsets and element margins


      return {
        top: offset.top - parentOffset.top - jQuery.css(elem, "marginTop", true),
        left: offset.left - parentOffset.left - jQuery.css(elem, "marginLeft", true)
      };
    },
    // This method will return documentElement in the following cases:
    // 1) For the element inside the iframe without offsetParent, this method will return
    //    documentElement of the parent window
    // 2) For the hidden or detached element
    // 3) For body or html element, i.e. in case of the html node - it will return itself
    //
    // but those exceptions were never presented as a real life use-cases
    // and might be considered as more preferable results.
    //
    // This logic, however, is not guaranteed and can change at any point in the future
    offsetParent: function offsetParent() {
      return this.map(function () {
        var offsetParent = this.offsetParent;

        while (offsetParent && jQuery.css(offsetParent, "position") === "static") {
          offsetParent = offsetParent.offsetParent;
        }

        return offsetParent || documentElement;
      });
    }
  }); // Create scrollLeft and scrollTop methods

  jQuery.each({
    scrollLeft: "pageXOffset",
    scrollTop: "pageYOffset"
  }, function (method, prop) {
    var top = "pageYOffset" === prop;

    jQuery.fn[method] = function (val) {
      return access(this, function (elem, method, val) {
        // Coalesce documents and windows
        var win;

        if (isWindow(elem)) {
          win = elem;
        } else if (elem.nodeType === 9) {
          win = elem.defaultView;
        }

        if (val === undefined) {
          return win ? win[prop] : elem[method];
        }

        if (win) {
          win.scrollTo(!top ? val : win.pageXOffset, top ? val : win.pageYOffset);
        } else {
          elem[method] = val;
        }
      }, method, val, arguments.length);
    };
  }); // Support: Safari <=7 - 9.1, Chrome <=37 - 49
  // Add the top/left cssHooks using jQuery.fn.position
  // Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084
  // Blink bug: https://bugs.chromium.org/p/chromium/issues/detail?id=589347
  // getComputedStyle returns percent when specified for top/left/bottom/right;
  // rather than make the css module depend on the offset module, just check for it here

  jQuery.each(["top", "left"], function (_i, prop) {
    jQuery.cssHooks[prop] = addGetHookIf(support.pixelPosition, function (elem, computed) {
      if (computed) {
        computed = curCSS(elem, prop); // If curCSS returns percentage, fallback to offset

        return rnumnonpx.test(computed) ? jQuery(elem).position()[prop] + "px" : computed;
      }
    });
  }); // Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods

  jQuery.each({
    Height: "height",
    Width: "width"
  }, function (name, type) {
    jQuery.each({
      padding: "inner" + name,
      content: type,
      "": "outer" + name
    }, function (defaultExtra, funcName) {
      // Margin is only for outerHeight, outerWidth
      jQuery.fn[funcName] = function (margin, value) {
        var chainable = arguments.length && (defaultExtra || typeof margin !== "boolean"),
            extra = defaultExtra || (margin === true || value === true ? "margin" : "border");
        return access(this, function (elem, type, value) {
          var doc;

          if (isWindow(elem)) {
            // $( window ).outerWidth/Height return w/h including scrollbars (gh-1729)
            return funcName.indexOf("outer") === 0 ? elem["inner" + name] : elem.document.documentElement["client" + name];
          } // Get document width or height


          if (elem.nodeType === 9) {
            doc = elem.documentElement; // Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height],
            // whichever is greatest

            return Math.max(elem.body["scroll" + name], doc["scroll" + name], elem.body["offset" + name], doc["offset" + name], doc["client" + name]);
          }

          return value === undefined ? // Get width or height on the element, requesting but not forcing parseFloat
          jQuery.css(elem, type, extra) : // Set width or height on the element
          jQuery.style(elem, type, value, extra);
        }, type, chainable ? margin : undefined, chainable);
      };
    });
  });
  jQuery.each(["ajaxStart", "ajaxStop", "ajaxComplete", "ajaxError", "ajaxSuccess", "ajaxSend"], function (_i, type) {
    jQuery.fn[type] = function (fn) {
      return this.on(type, fn);
    };
  });
  jQuery.fn.extend({
    bind: function bind(types, data, fn) {
      return this.on(types, null, data, fn);
    },
    unbind: function unbind(types, fn) {
      return this.off(types, null, fn);
    },
    delegate: function delegate(selector, types, data, fn) {
      return this.on(types, selector, data, fn);
    },
    undelegate: function undelegate(selector, types, fn) {
      // ( namespace ) or ( selector, types [, fn] )
      return arguments.length === 1 ? this.off(selector, "**") : this.off(types, selector || "**", fn);
    },
    hover: function hover(fnOver, fnOut) {
      return this.mouseenter(fnOver).mouseleave(fnOut || fnOver);
    }
  });
  jQuery.each(("blur focus focusin focusout resize scroll click dblclick " + "mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " + "change select submit keydown keypress keyup contextmenu").split(" "), function (_i, name) {
    // Handle event binding
    jQuery.fn[name] = function (data, fn) {
      return arguments.length > 0 ? this.on(name, null, data, fn) : this.trigger(name);
    };
  }); // Support: Android <=4.0 only
  // Make sure we trim BOM and NBSP

  var rtrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g; // Bind a function to a context, optionally partially applying any
  // arguments.
  // jQuery.proxy is deprecated to promote standards (specifically Function#bind)
  // However, it is not slated for removal any time soon

  jQuery.proxy = function (fn, context) {
    var tmp, args, proxy;

    if (typeof context === "string") {
      tmp = fn[context];
      context = fn;
      fn = tmp;
    } // Quick check to determine if target is callable, in the spec
    // this throws a TypeError, but we will just return undefined.


    if (!isFunction(fn)) {
      return undefined;
    } // Simulated bind


    args = _slice.call(arguments, 2);

    proxy = function proxy() {
      return fn.apply(context || this, args.concat(_slice.call(arguments)));
    }; // Set the guid of unique handler to the same of original handler, so it can be removed


    proxy.guid = fn.guid = fn.guid || jQuery.guid++;
    return proxy;
  };

  jQuery.holdReady = function (hold) {
    if (hold) {
      jQuery.readyWait++;
    } else {
      jQuery.ready(true);
    }
  };

  jQuery.isArray = Array.isArray;
  jQuery.parseJSON = JSON.parse;
  jQuery.nodeName = nodeName;
  jQuery.isFunction = isFunction;
  jQuery.isWindow = isWindow;
  jQuery.camelCase = camelCase;
  jQuery.type = toType;
  jQuery.now = Date.now;

  jQuery.isNumeric = function (obj) {
    // As of jQuery 3.0, isNumeric is limited to
    // strings and numbers (primitives or objects)
    // that can be coerced to finite numbers (gh-2662)
    var type = jQuery.type(obj);
    return (type === "number" || type === "string") && // parseFloat NaNs numeric-cast false positives ("")
    // ...but misinterprets leading-number strings, particularly hex literals ("0x...")
    // subtraction forces infinities to NaN
    !isNaN(obj - parseFloat(obj));
  };

  jQuery.trim = function (text) {
    return text == null ? "" : (text + "").replace(rtrim, "");
  }; // Register as a named AMD module, since jQuery can be concatenated with other
  // files that may use define, but not via a proper concatenation script that
  // understands anonymous AMD modules. A named AMD is safest and most robust
  // way to register. Lowercase jquery is used because AMD module names are
  // derived from file names, and jQuery is normally delivered in a lowercase
  // file name. Do this after creating the global so that if an AMD module wants
  // to call noConflict to hide this version of jQuery, it will work.
  // Note that for maximum portability, libraries that are not jQuery should
  // declare themselves as anonymous modules, and avoid setting a global if an
  // AMD loader is present. jQuery is a special case. For more information, see
  // https://github.com/jrburke/requirejs/wiki/Updating-existing-libraries#wiki-anon


  if (true) {
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function () {
      return jQuery;
    }).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  }

  var // Map over jQuery in case of overwrite
  _jQuery = window.jQuery,
      // Map over the $ in case of overwrite
  _$ = window.$;

  jQuery.noConflict = function (deep) {
    if (window.$ === jQuery) {
      window.$ = _$;
    }

    if (deep && window.jQuery === jQuery) {
      window.jQuery = _jQuery;
    }

    return jQuery;
  }; // Expose jQuery and $ identifiers, even in AMD
  // (#7102#comment:10, https://github.com/jquery/jquery/pull/557)
  // and CommonJS for browser emulators (#13566)


  if (typeof noGlobal === "undefined") {
    window.jQuery = window.$ = jQuery;
  }

  return jQuery;
});

/***/ }),

/***/ 259:
/***/ ((module, exports, __webpack_require__) => {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

/*
     _ _      _       _
 ___| (_) ___| | __  (_)___
/ __| | |/ __| |/ /  | / __|
\__ \ | | (__|   < _ | \__ \
|___/_|_|\___|_|\_(_)/ |___/
                   |__/

 Version: 1.8.1
  Author: Ken Wheeler
 Website: http://kenwheeler.github.io
    Docs: http://kenwheeler.github.io/slick
    Repo: http://github.com/kenwheeler/slick
  Issues: http://github.com/kenwheeler/slick/issues

 */

/* global window, document, define, jQuery, setInterval, clearInterval */
;

(function (factory) {
  'use strict';

  if (true) {
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(549)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
		__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
		(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else {}
})(function ($) {
  'use strict';

  var Slick = window.Slick || {};

  Slick = function () {
    var instanceUid = 0;

    function Slick(element, settings) {
      var _ = this,
          dataSettings;

      _.defaults = {
        accessibility: true,
        adaptiveHeight: false,
        appendArrows: $(element),
        appendDots: $(element),
        arrows: true,
        asNavFor: null,
        prevArrow: '<button class="slick-prev" aria-label="Previous" type="button">Previous</button>',
        nextArrow: '<button class="slick-next" aria-label="Next" type="button">Next</button>',
        autoplay: false,
        autoplaySpeed: 3000,
        centerMode: false,
        centerPadding: '50px',
        cssEase: 'ease',
        customPaging: function customPaging(slider, i) {
          return $('<button type="button" />').text(i + 1);
        },
        dots: false,
        dotsClass: 'slick-dots',
        draggable: true,
        easing: 'linear',
        edgeFriction: 0.35,
        fade: false,
        focusOnSelect: false,
        focusOnChange: false,
        infinite: true,
        initialSlide: 0,
        lazyLoad: 'ondemand',
        mobileFirst: false,
        pauseOnHover: true,
        pauseOnFocus: true,
        pauseOnDotsHover: false,
        respondTo: 'window',
        responsive: null,
        rows: 1,
        rtl: false,
        slide: '',
        slidesPerRow: 1,
        slidesToShow: 1,
        slidesToScroll: 1,
        speed: 500,
        swipe: true,
        swipeToSlide: false,
        touchMove: true,
        touchThreshold: 5,
        useCSS: true,
        useTransform: true,
        variableWidth: false,
        vertical: false,
        verticalSwiping: false,
        waitForAnimate: true,
        zIndex: 1000
      };
      _.initials = {
        animating: false,
        dragging: false,
        autoPlayTimer: null,
        currentDirection: 0,
        currentLeft: null,
        currentSlide: 0,
        direction: 1,
        $dots: null,
        listWidth: null,
        listHeight: null,
        loadIndex: 0,
        $nextArrow: null,
        $prevArrow: null,
        scrolling: false,
        slideCount: null,
        slideWidth: null,
        $slideTrack: null,
        $slides: null,
        sliding: false,
        slideOffset: 0,
        swipeLeft: null,
        swiping: false,
        $list: null,
        touchObject: {},
        transformsEnabled: false,
        unslicked: false
      };
      $.extend(_, _.initials);
      _.activeBreakpoint = null;
      _.animType = null;
      _.animProp = null;
      _.breakpoints = [];
      _.breakpointSettings = [];
      _.cssTransitions = false;
      _.focussed = false;
      _.interrupted = false;
      _.hidden = 'hidden';
      _.paused = true;
      _.positionProp = null;
      _.respondTo = null;
      _.rowCount = 1;
      _.shouldClick = true;
      _.$slider = $(element);
      _.$slidesCache = null;
      _.transformType = null;
      _.transitionType = null;
      _.visibilityChange = 'visibilitychange';
      _.windowWidth = 0;
      _.windowTimer = null;
      dataSettings = $(element).data('slick') || {};
      _.options = $.extend({}, _.defaults, settings, dataSettings);
      _.currentSlide = _.options.initialSlide;
      _.originalSettings = _.options;

      if (typeof document.mozHidden !== 'undefined') {
        _.hidden = 'mozHidden';
        _.visibilityChange = 'mozvisibilitychange';
      } else if (typeof document.webkitHidden !== 'undefined') {
        _.hidden = 'webkitHidden';
        _.visibilityChange = 'webkitvisibilitychange';
      }

      _.autoPlay = $.proxy(_.autoPlay, _);
      _.autoPlayClear = $.proxy(_.autoPlayClear, _);
      _.autoPlayIterator = $.proxy(_.autoPlayIterator, _);
      _.changeSlide = $.proxy(_.changeSlide, _);
      _.clickHandler = $.proxy(_.clickHandler, _);
      _.selectHandler = $.proxy(_.selectHandler, _);
      _.setPosition = $.proxy(_.setPosition, _);
      _.swipeHandler = $.proxy(_.swipeHandler, _);
      _.dragHandler = $.proxy(_.dragHandler, _);
      _.keyHandler = $.proxy(_.keyHandler, _);
      _.instanceUid = instanceUid++; // A simple way to check for HTML strings
      // Strict HTML recognition (must start with <)
      // Extracted from jQuery v1.11 source

      _.htmlExpr = /^(?:\s*(<[\w\W]+>)[^>]*)$/;

      _.registerBreakpoints();

      _.init(true);
    }

    return Slick;
  }();

  Slick.prototype.activateADA = function () {
    var _ = this;

    _.$slideTrack.find('.slick-active').attr({
      'aria-hidden': 'false'
    }).find('a, input, button, select').attr({
      'tabindex': '0'
    });
  };

  Slick.prototype.addSlide = Slick.prototype.slickAdd = function (markup, index, addBefore) {
    var _ = this;

    if (typeof index === 'boolean') {
      addBefore = index;
      index = null;
    } else if (index < 0 || index >= _.slideCount) {
      return false;
    }

    _.unload();

    if (typeof index === 'number') {
      if (index === 0 && _.$slides.length === 0) {
        $(markup).appendTo(_.$slideTrack);
      } else if (addBefore) {
        $(markup).insertBefore(_.$slides.eq(index));
      } else {
        $(markup).insertAfter(_.$slides.eq(index));
      }
    } else {
      if (addBefore === true) {
        $(markup).prependTo(_.$slideTrack);
      } else {
        $(markup).appendTo(_.$slideTrack);
      }
    }

    _.$slides = _.$slideTrack.children(this.options.slide);

    _.$slideTrack.children(this.options.slide).detach();

    _.$slideTrack.append(_.$slides);

    _.$slides.each(function (index, element) {
      $(element).attr('data-slick-index', index);
    });

    _.$slidesCache = _.$slides;

    _.reinit();
  };

  Slick.prototype.animateHeight = function () {
    var _ = this;

    if (_.options.slidesToShow === 1 && _.options.adaptiveHeight === true && _.options.vertical === false) {
      var targetHeight = _.$slides.eq(_.currentSlide).outerHeight(true);

      _.$list.animate({
        height: targetHeight
      }, _.options.speed);
    }
  };

  Slick.prototype.animateSlide = function (targetLeft, callback) {
    var animProps = {},
        _ = this;

    _.animateHeight();

    if (_.options.rtl === true && _.options.vertical === false) {
      targetLeft = -targetLeft;
    }

    if (_.transformsEnabled === false) {
      if (_.options.vertical === false) {
        _.$slideTrack.animate({
          left: targetLeft
        }, _.options.speed, _.options.easing, callback);
      } else {
        _.$slideTrack.animate({
          top: targetLeft
        }, _.options.speed, _.options.easing, callback);
      }
    } else {
      if (_.cssTransitions === false) {
        if (_.options.rtl === true) {
          _.currentLeft = -_.currentLeft;
        }

        $({
          animStart: _.currentLeft
        }).animate({
          animStart: targetLeft
        }, {
          duration: _.options.speed,
          easing: _.options.easing,
          step: function step(now) {
            now = Math.ceil(now);

            if (_.options.vertical === false) {
              animProps[_.animType] = 'translate(' + now + 'px, 0px)';

              _.$slideTrack.css(animProps);
            } else {
              animProps[_.animType] = 'translate(0px,' + now + 'px)';

              _.$slideTrack.css(animProps);
            }
          },
          complete: function complete() {
            if (callback) {
              callback.call();
            }
          }
        });
      } else {
        _.applyTransition();

        targetLeft = Math.ceil(targetLeft);

        if (_.options.vertical === false) {
          animProps[_.animType] = 'translate3d(' + targetLeft + 'px, 0px, 0px)';
        } else {
          animProps[_.animType] = 'translate3d(0px,' + targetLeft + 'px, 0px)';
        }

        _.$slideTrack.css(animProps);

        if (callback) {
          setTimeout(function () {
            _.disableTransition();

            callback.call();
          }, _.options.speed);
        }
      }
    }
  };

  Slick.prototype.getNavTarget = function () {
    var _ = this,
        asNavFor = _.options.asNavFor;

    if (asNavFor && asNavFor !== null) {
      asNavFor = $(asNavFor).not(_.$slider);
    }

    return asNavFor;
  };

  Slick.prototype.asNavFor = function (index) {
    var _ = this,
        asNavFor = _.getNavTarget();

    if (asNavFor !== null && _typeof(asNavFor) === 'object') {
      asNavFor.each(function () {
        var target = $(this).slick('getSlick');

        if (!target.unslicked) {
          target.slideHandler(index, true);
        }
      });
    }
  };

  Slick.prototype.applyTransition = function (slide) {
    var _ = this,
        transition = {};

    if (_.options.fade === false) {
      transition[_.transitionType] = _.transformType + ' ' + _.options.speed + 'ms ' + _.options.cssEase;
    } else {
      transition[_.transitionType] = 'opacity ' + _.options.speed + 'ms ' + _.options.cssEase;
    }

    if (_.options.fade === false) {
      _.$slideTrack.css(transition);
    } else {
      _.$slides.eq(slide).css(transition);
    }
  };

  Slick.prototype.autoPlay = function () {
    var _ = this;

    _.autoPlayClear();

    if (_.slideCount > _.options.slidesToShow) {
      _.autoPlayTimer = setInterval(_.autoPlayIterator, _.options.autoplaySpeed);
    }
  };

  Slick.prototype.autoPlayClear = function () {
    var _ = this;

    if (_.autoPlayTimer) {
      clearInterval(_.autoPlayTimer);
    }
  };

  Slick.prototype.autoPlayIterator = function () {
    var _ = this,
        slideTo = _.currentSlide + _.options.slidesToScroll;

    if (!_.paused && !_.interrupted && !_.focussed) {
      if (_.options.infinite === false) {
        if (_.direction === 1 && _.currentSlide + 1 === _.slideCount - 1) {
          _.direction = 0;
        } else if (_.direction === 0) {
          slideTo = _.currentSlide - _.options.slidesToScroll;

          if (_.currentSlide - 1 === 0) {
            _.direction = 1;
          }
        }
      }

      _.slideHandler(slideTo);
    }
  };

  Slick.prototype.buildArrows = function () {
    var _ = this;

    if (_.options.arrows === true) {
      _.$prevArrow = $(_.options.prevArrow).addClass('slick-arrow');
      _.$nextArrow = $(_.options.nextArrow).addClass('slick-arrow');

      if (_.slideCount > _.options.slidesToShow) {
        _.$prevArrow.removeClass('slick-hidden').removeAttr('aria-hidden tabindex');

        _.$nextArrow.removeClass('slick-hidden').removeAttr('aria-hidden tabindex');

        if (_.htmlExpr.test(_.options.prevArrow)) {
          _.$prevArrow.prependTo(_.options.appendArrows);
        }

        if (_.htmlExpr.test(_.options.nextArrow)) {
          _.$nextArrow.appendTo(_.options.appendArrows);
        }

        if (_.options.infinite !== true) {
          _.$prevArrow.addClass('slick-disabled').attr('aria-disabled', 'true');
        }
      } else {
        _.$prevArrow.add(_.$nextArrow).addClass('slick-hidden').attr({
          'aria-disabled': 'true',
          'tabindex': '-1'
        });
      }
    }
  };

  Slick.prototype.buildDots = function () {
    var _ = this,
        i,
        dot;

    if (_.options.dots === true && _.slideCount > _.options.slidesToShow) {
      _.$slider.addClass('slick-dotted');

      dot = $('<ul />').addClass(_.options.dotsClass);

      for (i = 0; i <= _.getDotCount(); i += 1) {
        dot.append($('<li />').append(_.options.customPaging.call(this, _, i)));
      }

      _.$dots = dot.appendTo(_.options.appendDots);

      _.$dots.find('li').first().addClass('slick-active');
    }
  };

  Slick.prototype.buildOut = function () {
    var _ = this;

    _.$slides = _.$slider.children(_.options.slide + ':not(.slick-cloned)').addClass('slick-slide');
    _.slideCount = _.$slides.length;

    _.$slides.each(function (index, element) {
      $(element).attr('data-slick-index', index).data('originalStyling', $(element).attr('style') || '');
    });

    _.$slider.addClass('slick-slider');

    _.$slideTrack = _.slideCount === 0 ? $('<div class="slick-track"/>').appendTo(_.$slider) : _.$slides.wrapAll('<div class="slick-track"/>').parent();
    _.$list = _.$slideTrack.wrap('<div class="slick-list"/>').parent();

    _.$slideTrack.css('opacity', 0);

    if (_.options.centerMode === true || _.options.swipeToSlide === true) {
      _.options.slidesToScroll = 1;
    }

    $('img[data-lazy]', _.$slider).not('[src]').addClass('slick-loading');

    _.setupInfinite();

    _.buildArrows();

    _.buildDots();

    _.updateDots();

    _.setSlideClasses(typeof _.currentSlide === 'number' ? _.currentSlide : 0);

    if (_.options.draggable === true) {
      _.$list.addClass('draggable');
    }
  };

  Slick.prototype.buildRows = function () {
    var _ = this,
        a,
        b,
        c,
        newSlides,
        numOfSlides,
        originalSlides,
        slidesPerSection;

    newSlides = document.createDocumentFragment();
    originalSlides = _.$slider.children();

    if (_.options.rows > 0) {
      slidesPerSection = _.options.slidesPerRow * _.options.rows;
      numOfSlides = Math.ceil(originalSlides.length / slidesPerSection);

      for (a = 0; a < numOfSlides; a++) {
        var slide = document.createElement('div');

        for (b = 0; b < _.options.rows; b++) {
          var row = document.createElement('div');

          for (c = 0; c < _.options.slidesPerRow; c++) {
            var target = a * slidesPerSection + (b * _.options.slidesPerRow + c);

            if (originalSlides.get(target)) {
              row.appendChild(originalSlides.get(target));
            }
          }

          slide.appendChild(row);
        }

        newSlides.appendChild(slide);
      }

      _.$slider.empty().append(newSlides);

      _.$slider.children().children().children().css({
        'width': 100 / _.options.slidesPerRow + '%',
        'display': 'inline-block'
      });
    }
  };

  Slick.prototype.checkResponsive = function (initial, forceUpdate) {
    var _ = this,
        breakpoint,
        targetBreakpoint,
        respondToWidth,
        triggerBreakpoint = false;

    var sliderWidth = _.$slider.width();

    var windowWidth = window.innerWidth || $(window).width();

    if (_.respondTo === 'window') {
      respondToWidth = windowWidth;
    } else if (_.respondTo === 'slider') {
      respondToWidth = sliderWidth;
    } else if (_.respondTo === 'min') {
      respondToWidth = Math.min(windowWidth, sliderWidth);
    }

    if (_.options.responsive && _.options.responsive.length && _.options.responsive !== null) {
      targetBreakpoint = null;

      for (breakpoint in _.breakpoints) {
        if (_.breakpoints.hasOwnProperty(breakpoint)) {
          if (_.originalSettings.mobileFirst === false) {
            if (respondToWidth < _.breakpoints[breakpoint]) {
              targetBreakpoint = _.breakpoints[breakpoint];
            }
          } else {
            if (respondToWidth > _.breakpoints[breakpoint]) {
              targetBreakpoint = _.breakpoints[breakpoint];
            }
          }
        }
      }

      if (targetBreakpoint !== null) {
        if (_.activeBreakpoint !== null) {
          if (targetBreakpoint !== _.activeBreakpoint || forceUpdate) {
            _.activeBreakpoint = targetBreakpoint;

            if (_.breakpointSettings[targetBreakpoint] === 'unslick') {
              _.unslick(targetBreakpoint);
            } else {
              _.options = $.extend({}, _.originalSettings, _.breakpointSettings[targetBreakpoint]);

              if (initial === true) {
                _.currentSlide = _.options.initialSlide;
              }

              _.refresh(initial);
            }

            triggerBreakpoint = targetBreakpoint;
          }
        } else {
          _.activeBreakpoint = targetBreakpoint;

          if (_.breakpointSettings[targetBreakpoint] === 'unslick') {
            _.unslick(targetBreakpoint);
          } else {
            _.options = $.extend({}, _.originalSettings, _.breakpointSettings[targetBreakpoint]);

            if (initial === true) {
              _.currentSlide = _.options.initialSlide;
            }

            _.refresh(initial);
          }

          triggerBreakpoint = targetBreakpoint;
        }
      } else {
        if (_.activeBreakpoint !== null) {
          _.activeBreakpoint = null;
          _.options = _.originalSettings;

          if (initial === true) {
            _.currentSlide = _.options.initialSlide;
          }

          _.refresh(initial);

          triggerBreakpoint = targetBreakpoint;
        }
      } // only trigger breakpoints during an actual break. not on initialize.


      if (!initial && triggerBreakpoint !== false) {
        _.$slider.trigger('breakpoint', [_, triggerBreakpoint]);
      }
    }
  };

  Slick.prototype.changeSlide = function (event, dontAnimate) {
    var _ = this,
        $target = $(event.currentTarget),
        indexOffset,
        slideOffset,
        unevenOffset; // If target is a link, prevent default action.


    if ($target.is('a')) {
      event.preventDefault();
    } // If target is not the <li> element (ie: a child), find the <li>.


    if (!$target.is('li')) {
      $target = $target.closest('li');
    }

    unevenOffset = _.slideCount % _.options.slidesToScroll !== 0;
    indexOffset = unevenOffset ? 0 : (_.slideCount - _.currentSlide) % _.options.slidesToScroll;

    switch (event.data.message) {
      case 'previous':
        slideOffset = indexOffset === 0 ? _.options.slidesToScroll : _.options.slidesToShow - indexOffset;

        if (_.slideCount > _.options.slidesToShow) {
          _.slideHandler(_.currentSlide - slideOffset, false, dontAnimate);
        }

        break;

      case 'next':
        slideOffset = indexOffset === 0 ? _.options.slidesToScroll : indexOffset;

        if (_.slideCount > _.options.slidesToShow) {
          _.slideHandler(_.currentSlide + slideOffset, false, dontAnimate);
        }

        break;

      case 'index':
        var index = event.data.index === 0 ? 0 : event.data.index || $target.index() * _.options.slidesToScroll;

        _.slideHandler(_.checkNavigable(index), false, dontAnimate);

        $target.children().trigger('focus');
        break;

      default:
        return;
    }
  };

  Slick.prototype.checkNavigable = function (index) {
    var _ = this,
        navigables,
        prevNavigable;

    navigables = _.getNavigableIndexes();
    prevNavigable = 0;

    if (index > navigables[navigables.length - 1]) {
      index = navigables[navigables.length - 1];
    } else {
      for (var n in navigables) {
        if (index < navigables[n]) {
          index = prevNavigable;
          break;
        }

        prevNavigable = navigables[n];
      }
    }

    return index;
  };

  Slick.prototype.cleanUpEvents = function () {
    var _ = this;

    if (_.options.dots && _.$dots !== null) {
      $('li', _.$dots).off('click.slick', _.changeSlide).off('mouseenter.slick', $.proxy(_.interrupt, _, true)).off('mouseleave.slick', $.proxy(_.interrupt, _, false));

      if (_.options.accessibility === true) {
        _.$dots.off('keydown.slick', _.keyHandler);
      }
    }

    _.$slider.off('focus.slick blur.slick');

    if (_.options.arrows === true && _.slideCount > _.options.slidesToShow) {
      _.$prevArrow && _.$prevArrow.off('click.slick', _.changeSlide);
      _.$nextArrow && _.$nextArrow.off('click.slick', _.changeSlide);

      if (_.options.accessibility === true) {
        _.$prevArrow && _.$prevArrow.off('keydown.slick', _.keyHandler);
        _.$nextArrow && _.$nextArrow.off('keydown.slick', _.keyHandler);
      }
    }

    _.$list.off('touchstart.slick mousedown.slick', _.swipeHandler);

    _.$list.off('touchmove.slick mousemove.slick', _.swipeHandler);

    _.$list.off('touchend.slick mouseup.slick', _.swipeHandler);

    _.$list.off('touchcancel.slick mouseleave.slick', _.swipeHandler);

    _.$list.off('click.slick', _.clickHandler);

    $(document).off(_.visibilityChange, _.visibility);

    _.cleanUpSlideEvents();

    if (_.options.accessibility === true) {
      _.$list.off('keydown.slick', _.keyHandler);
    }

    if (_.options.focusOnSelect === true) {
      $(_.$slideTrack).children().off('click.slick', _.selectHandler);
    }

    $(window).off('orientationchange.slick.slick-' + _.instanceUid, _.orientationChange);
    $(window).off('resize.slick.slick-' + _.instanceUid, _.resize);
    $('[draggable!=true]', _.$slideTrack).off('dragstart', _.preventDefault);
    $(window).off('load.slick.slick-' + _.instanceUid, _.setPosition);
  };

  Slick.prototype.cleanUpSlideEvents = function () {
    var _ = this;

    _.$list.off('mouseenter.slick', $.proxy(_.interrupt, _, true));

    _.$list.off('mouseleave.slick', $.proxy(_.interrupt, _, false));
  };

  Slick.prototype.cleanUpRows = function () {
    var _ = this,
        originalSlides;

    if (_.options.rows > 0) {
      originalSlides = _.$slides.children().children();
      originalSlides.removeAttr('style');

      _.$slider.empty().append(originalSlides);
    }
  };

  Slick.prototype.clickHandler = function (event) {
    var _ = this;

    if (_.shouldClick === false) {
      event.stopImmediatePropagation();
      event.stopPropagation();
      event.preventDefault();
    }
  };

  Slick.prototype.destroy = function (refresh) {
    var _ = this;

    _.autoPlayClear();

    _.touchObject = {};

    _.cleanUpEvents();

    $('.slick-cloned', _.$slider).detach();

    if (_.$dots) {
      _.$dots.remove();
    }

    if (_.$prevArrow && _.$prevArrow.length) {
      _.$prevArrow.removeClass('slick-disabled slick-arrow slick-hidden').removeAttr('aria-hidden aria-disabled tabindex').css('display', '');

      if (_.htmlExpr.test(_.options.prevArrow)) {
        _.$prevArrow.remove();
      }
    }

    if (_.$nextArrow && _.$nextArrow.length) {
      _.$nextArrow.removeClass('slick-disabled slick-arrow slick-hidden').removeAttr('aria-hidden aria-disabled tabindex').css('display', '');

      if (_.htmlExpr.test(_.options.nextArrow)) {
        _.$nextArrow.remove();
      }
    }

    if (_.$slides) {
      _.$slides.removeClass('slick-slide slick-active slick-center slick-visible slick-current').removeAttr('aria-hidden').removeAttr('data-slick-index').each(function () {
        $(this).attr('style', $(this).data('originalStyling'));
      });

      _.$slideTrack.children(this.options.slide).detach();

      _.$slideTrack.detach();

      _.$list.detach();

      _.$slider.append(_.$slides);
    }

    _.cleanUpRows();

    _.$slider.removeClass('slick-slider');

    _.$slider.removeClass('slick-initialized');

    _.$slider.removeClass('slick-dotted');

    _.unslicked = true;

    if (!refresh) {
      _.$slider.trigger('destroy', [_]);
    }
  };

  Slick.prototype.disableTransition = function (slide) {
    var _ = this,
        transition = {};

    transition[_.transitionType] = '';

    if (_.options.fade === false) {
      _.$slideTrack.css(transition);
    } else {
      _.$slides.eq(slide).css(transition);
    }
  };

  Slick.prototype.fadeSlide = function (slideIndex, callback) {
    var _ = this;

    if (_.cssTransitions === false) {
      _.$slides.eq(slideIndex).css({
        zIndex: _.options.zIndex
      });

      _.$slides.eq(slideIndex).animate({
        opacity: 1
      }, _.options.speed, _.options.easing, callback);
    } else {
      _.applyTransition(slideIndex);

      _.$slides.eq(slideIndex).css({
        opacity: 1,
        zIndex: _.options.zIndex
      });

      if (callback) {
        setTimeout(function () {
          _.disableTransition(slideIndex);

          callback.call();
        }, _.options.speed);
      }
    }
  };

  Slick.prototype.fadeSlideOut = function (slideIndex) {
    var _ = this;

    if (_.cssTransitions === false) {
      _.$slides.eq(slideIndex).animate({
        opacity: 0,
        zIndex: _.options.zIndex - 2
      }, _.options.speed, _.options.easing);
    } else {
      _.applyTransition(slideIndex);

      _.$slides.eq(slideIndex).css({
        opacity: 0,
        zIndex: _.options.zIndex - 2
      });
    }
  };

  Slick.prototype.filterSlides = Slick.prototype.slickFilter = function (filter) {
    var _ = this;

    if (filter !== null) {
      _.$slidesCache = _.$slides;

      _.unload();

      _.$slideTrack.children(this.options.slide).detach();

      _.$slidesCache.filter(filter).appendTo(_.$slideTrack);

      _.reinit();
    }
  };

  Slick.prototype.focusHandler = function () {
    var _ = this;

    _.$slider.off('focus.slick blur.slick').on('focus.slick blur.slick', '*', function (event) {
      event.stopImmediatePropagation();
      var $sf = $(this);
      setTimeout(function () {
        if (_.options.pauseOnFocus) {
          _.focussed = $sf.is(':focus');

          _.autoPlay();
        }
      }, 0);
    });
  };

  Slick.prototype.getCurrent = Slick.prototype.slickCurrentSlide = function () {
    var _ = this;

    return _.currentSlide;
  };

  Slick.prototype.getDotCount = function () {
    var _ = this;

    var breakPoint = 0;
    var counter = 0;
    var pagerQty = 0;

    if (_.options.infinite === true) {
      if (_.slideCount <= _.options.slidesToShow) {
        ++pagerQty;
      } else {
        while (breakPoint < _.slideCount) {
          ++pagerQty;
          breakPoint = counter + _.options.slidesToScroll;
          counter += _.options.slidesToScroll <= _.options.slidesToShow ? _.options.slidesToScroll : _.options.slidesToShow;
        }
      }
    } else if (_.options.centerMode === true) {
      pagerQty = _.slideCount;
    } else if (!_.options.asNavFor) {
      pagerQty = 1 + Math.ceil((_.slideCount - _.options.slidesToShow) / _.options.slidesToScroll);
    } else {
      while (breakPoint < _.slideCount) {
        ++pagerQty;
        breakPoint = counter + _.options.slidesToScroll;
        counter += _.options.slidesToScroll <= _.options.slidesToShow ? _.options.slidesToScroll : _.options.slidesToShow;
      }
    }

    return pagerQty - 1;
  };

  Slick.prototype.getLeft = function (slideIndex) {
    var _ = this,
        targetLeft,
        verticalHeight,
        verticalOffset = 0,
        targetSlide,
        coef;

    _.slideOffset = 0;
    verticalHeight = _.$slides.first().outerHeight(true);

    if (_.options.infinite === true) {
      if (_.slideCount > _.options.slidesToShow) {
        _.slideOffset = _.slideWidth * _.options.slidesToShow * -1;
        coef = -1;

        if (_.options.vertical === true && _.options.centerMode === true) {
          if (_.options.slidesToShow === 2) {
            coef = -1.5;
          } else if (_.options.slidesToShow === 1) {
            coef = -2;
          }
        }

        verticalOffset = verticalHeight * _.options.slidesToShow * coef;
      }

      if (_.slideCount % _.options.slidesToScroll !== 0) {
        if (slideIndex + _.options.slidesToScroll > _.slideCount && _.slideCount > _.options.slidesToShow) {
          if (slideIndex > _.slideCount) {
            _.slideOffset = (_.options.slidesToShow - (slideIndex - _.slideCount)) * _.slideWidth * -1;
            verticalOffset = (_.options.slidesToShow - (slideIndex - _.slideCount)) * verticalHeight * -1;
          } else {
            _.slideOffset = _.slideCount % _.options.slidesToScroll * _.slideWidth * -1;
            verticalOffset = _.slideCount % _.options.slidesToScroll * verticalHeight * -1;
          }
        }
      }
    } else {
      if (slideIndex + _.options.slidesToShow > _.slideCount) {
        _.slideOffset = (slideIndex + _.options.slidesToShow - _.slideCount) * _.slideWidth;
        verticalOffset = (slideIndex + _.options.slidesToShow - _.slideCount) * verticalHeight;
      }
    }

    if (_.slideCount <= _.options.slidesToShow) {
      _.slideOffset = 0;
      verticalOffset = 0;
    }

    if (_.options.centerMode === true && _.slideCount <= _.options.slidesToShow) {
      _.slideOffset = _.slideWidth * Math.floor(_.options.slidesToShow) / 2 - _.slideWidth * _.slideCount / 2;
    } else if (_.options.centerMode === true && _.options.infinite === true) {
      _.slideOffset += _.slideWidth * Math.floor(_.options.slidesToShow / 2) - _.slideWidth;
    } else if (_.options.centerMode === true) {
      _.slideOffset = 0;
      _.slideOffset += _.slideWidth * Math.floor(_.options.slidesToShow / 2);
    }

    if (_.options.vertical === false) {
      targetLeft = slideIndex * _.slideWidth * -1 + _.slideOffset;
    } else {
      targetLeft = slideIndex * verticalHeight * -1 + verticalOffset;
    }

    if (_.options.variableWidth === true) {
      if (_.slideCount <= _.options.slidesToShow || _.options.infinite === false) {
        targetSlide = _.$slideTrack.children('.slick-slide').eq(slideIndex);
      } else {
        targetSlide = _.$slideTrack.children('.slick-slide').eq(slideIndex + _.options.slidesToShow);
      }

      if (_.options.rtl === true) {
        if (targetSlide[0]) {
          targetLeft = (_.$slideTrack.width() - targetSlide[0].offsetLeft - targetSlide.width()) * -1;
        } else {
          targetLeft = 0;
        }
      } else {
        targetLeft = targetSlide[0] ? targetSlide[0].offsetLeft * -1 : 0;
      }

      if (_.options.centerMode === true) {
        if (_.slideCount <= _.options.slidesToShow || _.options.infinite === false) {
          targetSlide = _.$slideTrack.children('.slick-slide').eq(slideIndex);
        } else {
          targetSlide = _.$slideTrack.children('.slick-slide').eq(slideIndex + _.options.slidesToShow + 1);
        }

        if (_.options.rtl === true) {
          if (targetSlide[0]) {
            targetLeft = (_.$slideTrack.width() - targetSlide[0].offsetLeft - targetSlide.width()) * -1;
          } else {
            targetLeft = 0;
          }
        } else {
          targetLeft = targetSlide[0] ? targetSlide[0].offsetLeft * -1 : 0;
        }

        targetLeft += (_.$list.width() - targetSlide.outerWidth()) / 2;
      }
    }

    return targetLeft;
  };

  Slick.prototype.getOption = Slick.prototype.slickGetOption = function (option) {
    var _ = this;

    return _.options[option];
  };

  Slick.prototype.getNavigableIndexes = function () {
    var _ = this,
        breakPoint = 0,
        counter = 0,
        indexes = [],
        max;

    if (_.options.infinite === false) {
      max = _.slideCount;
    } else {
      breakPoint = _.options.slidesToScroll * -1;
      counter = _.options.slidesToScroll * -1;
      max = _.slideCount * 2;
    }

    while (breakPoint < max) {
      indexes.push(breakPoint);
      breakPoint = counter + _.options.slidesToScroll;
      counter += _.options.slidesToScroll <= _.options.slidesToShow ? _.options.slidesToScroll : _.options.slidesToShow;
    }

    return indexes;
  };

  Slick.prototype.getSlick = function () {
    return this;
  };

  Slick.prototype.getSlideCount = function () {
    var _ = this,
        slidesTraversed,
        swipedSlide,
        centerOffset;

    centerOffset = _.options.centerMode === true ? _.slideWidth * Math.floor(_.options.slidesToShow / 2) : 0;

    if (_.options.swipeToSlide === true) {
      _.$slideTrack.find('.slick-slide').each(function (index, slide) {
        if (slide.offsetLeft - centerOffset + $(slide).outerWidth() / 2 > _.swipeLeft * -1) {
          swipedSlide = slide;
          return false;
        }
      });

      slidesTraversed = Math.abs($(swipedSlide).attr('data-slick-index') - _.currentSlide) || 1;
      return slidesTraversed;
    } else {
      return _.options.slidesToScroll;
    }
  };

  Slick.prototype.goTo = Slick.prototype.slickGoTo = function (slide, dontAnimate) {
    var _ = this;

    _.changeSlide({
      data: {
        message: 'index',
        index: parseInt(slide)
      }
    }, dontAnimate);
  };

  Slick.prototype.init = function (creation) {
    var _ = this;

    if (!$(_.$slider).hasClass('slick-initialized')) {
      $(_.$slider).addClass('slick-initialized');

      _.buildRows();

      _.buildOut();

      _.setProps();

      _.startLoad();

      _.loadSlider();

      _.initializeEvents();

      _.updateArrows();

      _.updateDots();

      _.checkResponsive(true);

      _.focusHandler();
    }

    if (creation) {
      _.$slider.trigger('init', [_]);
    }

    if (_.options.accessibility === true) {
      _.initADA();
    }

    if (_.options.autoplay) {
      _.paused = false;

      _.autoPlay();
    }
  };

  Slick.prototype.initADA = function () {
    var _ = this,
        numDotGroups = Math.ceil(_.slideCount / _.options.slidesToShow),
        tabControlIndexes = _.getNavigableIndexes().filter(function (val) {
      return val >= 0 && val < _.slideCount;
    });

    _.$slides.add(_.$slideTrack.find('.slick-cloned')).attr({
      'aria-hidden': 'true',
      'tabindex': '-1'
    }).find('a, input, button, select').attr({
      'tabindex': '-1'
    });

    if (_.$dots !== null) {
      _.$slides.not(_.$slideTrack.find('.slick-cloned')).each(function (i) {
        var slideControlIndex = tabControlIndexes.indexOf(i);
        $(this).attr({
          'role': 'tabpanel',
          'id': 'slick-slide' + _.instanceUid + i,
          'tabindex': -1
        });

        if (slideControlIndex !== -1) {
          var ariaButtonControl = 'slick-slide-control' + _.instanceUid + slideControlIndex;

          if ($('#' + ariaButtonControl).length) {
            $(this).attr({
              'aria-describedby': ariaButtonControl
            });
          }
        }
      });

      _.$dots.attr('role', 'tablist').find('li').each(function (i) {
        var mappedSlideIndex = tabControlIndexes[i];
        $(this).attr({
          'role': 'presentation'
        });
        $(this).find('button').first().attr({
          'role': 'tab',
          'id': 'slick-slide-control' + _.instanceUid + i,
          'aria-controls': 'slick-slide' + _.instanceUid + mappedSlideIndex,
          'aria-label': i + 1 + ' of ' + numDotGroups,
          'aria-selected': null,
          'tabindex': '-1'
        });
      }).eq(_.currentSlide).find('button').attr({
        'aria-selected': 'true',
        'tabindex': '0'
      }).end();
    }

    for (var i = _.currentSlide, max = i + _.options.slidesToShow; i < max; i++) {
      if (_.options.focusOnChange) {
        _.$slides.eq(i).attr({
          'tabindex': '0'
        });
      } else {
        _.$slides.eq(i).removeAttr('tabindex');
      }
    }

    _.activateADA();
  };

  Slick.prototype.initArrowEvents = function () {
    var _ = this;

    if (_.options.arrows === true && _.slideCount > _.options.slidesToShow) {
      _.$prevArrow.off('click.slick').on('click.slick', {
        message: 'previous'
      }, _.changeSlide);

      _.$nextArrow.off('click.slick').on('click.slick', {
        message: 'next'
      }, _.changeSlide);

      if (_.options.accessibility === true) {
        _.$prevArrow.on('keydown.slick', _.keyHandler);

        _.$nextArrow.on('keydown.slick', _.keyHandler);
      }
    }
  };

  Slick.prototype.initDotEvents = function () {
    var _ = this;

    if (_.options.dots === true && _.slideCount > _.options.slidesToShow) {
      $('li', _.$dots).on('click.slick', {
        message: 'index'
      }, _.changeSlide);

      if (_.options.accessibility === true) {
        _.$dots.on('keydown.slick', _.keyHandler);
      }
    }

    if (_.options.dots === true && _.options.pauseOnDotsHover === true && _.slideCount > _.options.slidesToShow) {
      $('li', _.$dots).on('mouseenter.slick', $.proxy(_.interrupt, _, true)).on('mouseleave.slick', $.proxy(_.interrupt, _, false));
    }
  };

  Slick.prototype.initSlideEvents = function () {
    var _ = this;

    if (_.options.pauseOnHover) {
      _.$list.on('mouseenter.slick', $.proxy(_.interrupt, _, true));

      _.$list.on('mouseleave.slick', $.proxy(_.interrupt, _, false));
    }
  };

  Slick.prototype.initializeEvents = function () {
    var _ = this;

    _.initArrowEvents();

    _.initDotEvents();

    _.initSlideEvents();

    _.$list.on('touchstart.slick mousedown.slick', {
      action: 'start'
    }, _.swipeHandler);

    _.$list.on('touchmove.slick mousemove.slick', {
      action: 'move'
    }, _.swipeHandler);

    _.$list.on('touchend.slick mouseup.slick', {
      action: 'end'
    }, _.swipeHandler);

    _.$list.on('touchcancel.slick mouseleave.slick', {
      action: 'end'
    }, _.swipeHandler);

    _.$list.on('click.slick', _.clickHandler);

    $(document).on(_.visibilityChange, $.proxy(_.visibility, _));

    if (_.options.accessibility === true) {
      _.$list.on('keydown.slick', _.keyHandler);
    }

    if (_.options.focusOnSelect === true) {
      $(_.$slideTrack).children().on('click.slick', _.selectHandler);
    }

    $(window).on('orientationchange.slick.slick-' + _.instanceUid, $.proxy(_.orientationChange, _));
    $(window).on('resize.slick.slick-' + _.instanceUid, $.proxy(_.resize, _));
    $('[draggable!=true]', _.$slideTrack).on('dragstart', _.preventDefault);
    $(window).on('load.slick.slick-' + _.instanceUid, _.setPosition);
    $(_.setPosition);
  };

  Slick.prototype.initUI = function () {
    var _ = this;

    if (_.options.arrows === true && _.slideCount > _.options.slidesToShow) {
      _.$prevArrow.show();

      _.$nextArrow.show();
    }

    if (_.options.dots === true && _.slideCount > _.options.slidesToShow) {
      _.$dots.show();
    }
  };

  Slick.prototype.keyHandler = function (event) {
    var _ = this; //Dont slide if the cursor is inside the form fields and arrow keys are pressed


    if (!event.target.tagName.match('TEXTAREA|INPUT|SELECT')) {
      if (event.keyCode === 37 && _.options.accessibility === true) {
        _.changeSlide({
          data: {
            message: _.options.rtl === true ? 'next' : 'previous'
          }
        });
      } else if (event.keyCode === 39 && _.options.accessibility === true) {
        _.changeSlide({
          data: {
            message: _.options.rtl === true ? 'previous' : 'next'
          }
        });
      }
    }
  };

  Slick.prototype.lazyLoad = function () {
    var _ = this,
        loadRange,
        cloneRange,
        rangeStart,
        rangeEnd;

    function loadImages(imagesScope) {
      $('img[data-lazy]', imagesScope).each(function () {
        var image = $(this),
            imageSource = $(this).attr('data-lazy'),
            imageSrcSet = $(this).attr('data-srcset'),
            imageSizes = $(this).attr('data-sizes') || _.$slider.attr('data-sizes'),
            imageToLoad = document.createElement('img');

        imageToLoad.onload = function () {
          image.animate({
            opacity: 0
          }, 100, function () {
            if (imageSrcSet) {
              image.attr('srcset', imageSrcSet);

              if (imageSizes) {
                image.attr('sizes', imageSizes);
              }
            }

            image.attr('src', imageSource).animate({
              opacity: 1
            }, 200, function () {
              image.removeAttr('data-lazy data-srcset data-sizes').removeClass('slick-loading');
            });

            _.$slider.trigger('lazyLoaded', [_, image, imageSource]);
          });
        };

        imageToLoad.onerror = function () {
          image.removeAttr('data-lazy').removeClass('slick-loading').addClass('slick-lazyload-error');

          _.$slider.trigger('lazyLoadError', [_, image, imageSource]);
        };

        imageToLoad.src = imageSource;
      });
    }

    if (_.options.centerMode === true) {
      if (_.options.infinite === true) {
        rangeStart = _.currentSlide + (_.options.slidesToShow / 2 + 1);
        rangeEnd = rangeStart + _.options.slidesToShow + 2;
      } else {
        rangeStart = Math.max(0, _.currentSlide - (_.options.slidesToShow / 2 + 1));
        rangeEnd = 2 + (_.options.slidesToShow / 2 + 1) + _.currentSlide;
      }
    } else {
      rangeStart = _.options.infinite ? _.options.slidesToShow + _.currentSlide : _.currentSlide;
      rangeEnd = Math.ceil(rangeStart + _.options.slidesToShow);

      if (_.options.fade === true) {
        if (rangeStart > 0) rangeStart--;
        if (rangeEnd <= _.slideCount) rangeEnd++;
      }
    }

    loadRange = _.$slider.find('.slick-slide').slice(rangeStart, rangeEnd);

    if (_.options.lazyLoad === 'anticipated') {
      var prevSlide = rangeStart - 1,
          nextSlide = rangeEnd,
          $slides = _.$slider.find('.slick-slide');

      for (var i = 0; i < _.options.slidesToScroll; i++) {
        if (prevSlide < 0) prevSlide = _.slideCount - 1;
        loadRange = loadRange.add($slides.eq(prevSlide));
        loadRange = loadRange.add($slides.eq(nextSlide));
        prevSlide--;
        nextSlide++;
      }
    }

    loadImages(loadRange);

    if (_.slideCount <= _.options.slidesToShow) {
      cloneRange = _.$slider.find('.slick-slide');
      loadImages(cloneRange);
    } else if (_.currentSlide >= _.slideCount - _.options.slidesToShow) {
      cloneRange = _.$slider.find('.slick-cloned').slice(0, _.options.slidesToShow);
      loadImages(cloneRange);
    } else if (_.currentSlide === 0) {
      cloneRange = _.$slider.find('.slick-cloned').slice(_.options.slidesToShow * -1);
      loadImages(cloneRange);
    }
  };

  Slick.prototype.loadSlider = function () {
    var _ = this;

    _.setPosition();

    _.$slideTrack.css({
      opacity: 1
    });

    _.$slider.removeClass('slick-loading');

    _.initUI();

    if (_.options.lazyLoad === 'progressive') {
      _.progressiveLazyLoad();
    }
  };

  Slick.prototype.next = Slick.prototype.slickNext = function () {
    var _ = this;

    _.changeSlide({
      data: {
        message: 'next'
      }
    });
  };

  Slick.prototype.orientationChange = function () {
    var _ = this;

    _.checkResponsive();

    _.setPosition();
  };

  Slick.prototype.pause = Slick.prototype.slickPause = function () {
    var _ = this;

    _.autoPlayClear();

    _.paused = true;
  };

  Slick.prototype.play = Slick.prototype.slickPlay = function () {
    var _ = this;

    _.autoPlay();

    _.options.autoplay = true;
    _.paused = false;
    _.focussed = false;
    _.interrupted = false;
  };

  Slick.prototype.postSlide = function (index) {
    var _ = this;

    if (!_.unslicked) {
      _.$slider.trigger('afterChange', [_, index]);

      _.animating = false;

      if (_.slideCount > _.options.slidesToShow) {
        _.setPosition();
      }

      _.swipeLeft = null;

      if (_.options.autoplay) {
        _.autoPlay();
      }

      if (_.options.accessibility === true) {
        _.initADA();

        if (_.options.focusOnChange) {
          var $currentSlide = $(_.$slides.get(_.currentSlide));
          $currentSlide.attr('tabindex', 0).focus();
        }
      }
    }
  };

  Slick.prototype.prev = Slick.prototype.slickPrev = function () {
    var _ = this;

    _.changeSlide({
      data: {
        message: 'previous'
      }
    });
  };

  Slick.prototype.preventDefault = function (event) {
    event.preventDefault();
  };

  Slick.prototype.progressiveLazyLoad = function (tryCount) {
    tryCount = tryCount || 1;

    var _ = this,
        $imgsToLoad = $('img[data-lazy]', _.$slider),
        image,
        imageSource,
        imageSrcSet,
        imageSizes,
        imageToLoad;

    if ($imgsToLoad.length) {
      image = $imgsToLoad.first();
      imageSource = image.attr('data-lazy');
      imageSrcSet = image.attr('data-srcset');
      imageSizes = image.attr('data-sizes') || _.$slider.attr('data-sizes');
      imageToLoad = document.createElement('img');

      imageToLoad.onload = function () {
        if (imageSrcSet) {
          image.attr('srcset', imageSrcSet);

          if (imageSizes) {
            image.attr('sizes', imageSizes);
          }
        }

        image.attr('src', imageSource).removeAttr('data-lazy data-srcset data-sizes').removeClass('slick-loading');

        if (_.options.adaptiveHeight === true) {
          _.setPosition();
        }

        _.$slider.trigger('lazyLoaded', [_, image, imageSource]);

        _.progressiveLazyLoad();
      };

      imageToLoad.onerror = function () {
        if (tryCount < 3) {
          /**
           * try to load the image 3 times,
           * leave a slight delay so we don't get
           * servers blocking the request.
           */
          setTimeout(function () {
            _.progressiveLazyLoad(tryCount + 1);
          }, 500);
        } else {
          image.removeAttr('data-lazy').removeClass('slick-loading').addClass('slick-lazyload-error');

          _.$slider.trigger('lazyLoadError', [_, image, imageSource]);

          _.progressiveLazyLoad();
        }
      };

      imageToLoad.src = imageSource;
    } else {
      _.$slider.trigger('allImagesLoaded', [_]);
    }
  };

  Slick.prototype.refresh = function (initializing) {
    var _ = this,
        currentSlide,
        lastVisibleIndex;

    lastVisibleIndex = _.slideCount - _.options.slidesToShow; // in non-infinite sliders, we don't want to go past the
    // last visible index.

    if (!_.options.infinite && _.currentSlide > lastVisibleIndex) {
      _.currentSlide = lastVisibleIndex;
    } // if less slides than to show, go to start.


    if (_.slideCount <= _.options.slidesToShow) {
      _.currentSlide = 0;
    }

    currentSlide = _.currentSlide;

    _.destroy(true);

    $.extend(_, _.initials, {
      currentSlide: currentSlide
    });

    _.init();

    if (!initializing) {
      _.changeSlide({
        data: {
          message: 'index',
          index: currentSlide
        }
      }, false);
    }
  };

  Slick.prototype.registerBreakpoints = function () {
    var _ = this,
        breakpoint,
        currentBreakpoint,
        l,
        responsiveSettings = _.options.responsive || null;

    if ($.type(responsiveSettings) === 'array' && responsiveSettings.length) {
      _.respondTo = _.options.respondTo || 'window';

      for (breakpoint in responsiveSettings) {
        l = _.breakpoints.length - 1;

        if (responsiveSettings.hasOwnProperty(breakpoint)) {
          currentBreakpoint = responsiveSettings[breakpoint].breakpoint; // loop through the breakpoints and cut out any existing
          // ones with the same breakpoint number, we don't want dupes.

          while (l >= 0) {
            if (_.breakpoints[l] && _.breakpoints[l] === currentBreakpoint) {
              _.breakpoints.splice(l, 1);
            }

            l--;
          }

          _.breakpoints.push(currentBreakpoint);

          _.breakpointSettings[currentBreakpoint] = responsiveSettings[breakpoint].settings;
        }
      }

      _.breakpoints.sort(function (a, b) {
        return _.options.mobileFirst ? a - b : b - a;
      });
    }
  };

  Slick.prototype.reinit = function () {
    var _ = this;

    _.$slides = _.$slideTrack.children(_.options.slide).addClass('slick-slide');
    _.slideCount = _.$slides.length;

    if (_.currentSlide >= _.slideCount && _.currentSlide !== 0) {
      _.currentSlide = _.currentSlide - _.options.slidesToScroll;
    }

    if (_.slideCount <= _.options.slidesToShow) {
      _.currentSlide = 0;
    }

    _.registerBreakpoints();

    _.setProps();

    _.setupInfinite();

    _.buildArrows();

    _.updateArrows();

    _.initArrowEvents();

    _.buildDots();

    _.updateDots();

    _.initDotEvents();

    _.cleanUpSlideEvents();

    _.initSlideEvents();

    _.checkResponsive(false, true);

    if (_.options.focusOnSelect === true) {
      $(_.$slideTrack).children().on('click.slick', _.selectHandler);
    }

    _.setSlideClasses(typeof _.currentSlide === 'number' ? _.currentSlide : 0);

    _.setPosition();

    _.focusHandler();

    _.paused = !_.options.autoplay;

    _.autoPlay();

    _.$slider.trigger('reInit', [_]);
  };

  Slick.prototype.resize = function () {
    var _ = this;

    if ($(window).width() !== _.windowWidth) {
      clearTimeout(_.windowDelay);
      _.windowDelay = window.setTimeout(function () {
        _.windowWidth = $(window).width();

        _.checkResponsive();

        if (!_.unslicked) {
          _.setPosition();
        }
      }, 50);
    }
  };

  Slick.prototype.removeSlide = Slick.prototype.slickRemove = function (index, removeBefore, removeAll) {
    var _ = this;

    if (typeof index === 'boolean') {
      removeBefore = index;
      index = removeBefore === true ? 0 : _.slideCount - 1;
    } else {
      index = removeBefore === true ? --index : index;
    }

    if (_.slideCount < 1 || index < 0 || index > _.slideCount - 1) {
      return false;
    }

    _.unload();

    if (removeAll === true) {
      _.$slideTrack.children().remove();
    } else {
      _.$slideTrack.children(this.options.slide).eq(index).remove();
    }

    _.$slides = _.$slideTrack.children(this.options.slide);

    _.$slideTrack.children(this.options.slide).detach();

    _.$slideTrack.append(_.$slides);

    _.$slidesCache = _.$slides;

    _.reinit();
  };

  Slick.prototype.setCSS = function (position) {
    var _ = this,
        positionProps = {},
        x,
        y;

    if (_.options.rtl === true) {
      position = -position;
    }

    x = _.positionProp == 'left' ? Math.ceil(position) + 'px' : '0px';
    y = _.positionProp == 'top' ? Math.ceil(position) + 'px' : '0px';
    positionProps[_.positionProp] = position;

    if (_.transformsEnabled === false) {
      _.$slideTrack.css(positionProps);
    } else {
      positionProps = {};

      if (_.cssTransitions === false) {
        positionProps[_.animType] = 'translate(' + x + ', ' + y + ')';

        _.$slideTrack.css(positionProps);
      } else {
        positionProps[_.animType] = 'translate3d(' + x + ', ' + y + ', 0px)';

        _.$slideTrack.css(positionProps);
      }
    }
  };

  Slick.prototype.setDimensions = function () {
    var _ = this;

    if (_.options.vertical === false) {
      if (_.options.centerMode === true) {
        _.$list.css({
          padding: '0px ' + _.options.centerPadding
        });
      }
    } else {
      _.$list.height(_.$slides.first().outerHeight(true) * _.options.slidesToShow);

      if (_.options.centerMode === true) {
        _.$list.css({
          padding: _.options.centerPadding + ' 0px'
        });
      }
    }

    _.listWidth = _.$list.width();
    _.listHeight = _.$list.height();

    if (_.options.vertical === false && _.options.variableWidth === false) {
      _.slideWidth = Math.ceil(_.listWidth / _.options.slidesToShow);

      _.$slideTrack.width(Math.ceil(_.slideWidth * _.$slideTrack.children('.slick-slide').length));
    } else if (_.options.variableWidth === true) {
      _.$slideTrack.width(5000 * _.slideCount);
    } else {
      _.slideWidth = Math.ceil(_.listWidth);

      _.$slideTrack.height(Math.ceil(_.$slides.first().outerHeight(true) * _.$slideTrack.children('.slick-slide').length));
    }

    var offset = _.$slides.first().outerWidth(true) - _.$slides.first().width();

    if (_.options.variableWidth === false) _.$slideTrack.children('.slick-slide').width(_.slideWidth - offset);
  };

  Slick.prototype.setFade = function () {
    var _ = this,
        targetLeft;

    _.$slides.each(function (index, element) {
      targetLeft = _.slideWidth * index * -1;

      if (_.options.rtl === true) {
        $(element).css({
          position: 'relative',
          right: targetLeft,
          top: 0,
          zIndex: _.options.zIndex - 2,
          opacity: 0
        });
      } else {
        $(element).css({
          position: 'relative',
          left: targetLeft,
          top: 0,
          zIndex: _.options.zIndex - 2,
          opacity: 0
        });
      }
    });

    _.$slides.eq(_.currentSlide).css({
      zIndex: _.options.zIndex - 1,
      opacity: 1
    });
  };

  Slick.prototype.setHeight = function () {
    var _ = this;

    if (_.options.slidesToShow === 1 && _.options.adaptiveHeight === true && _.options.vertical === false) {
      var targetHeight = _.$slides.eq(_.currentSlide).outerHeight(true);

      _.$list.css('height', targetHeight);
    }
  };

  Slick.prototype.setOption = Slick.prototype.slickSetOption = function () {
    /**
     * accepts arguments in format of:
     *
     *  - for changing a single option's value:
     *     .slick("setOption", option, value, refresh )
     *
     *  - for changing a set of responsive options:
     *     .slick("setOption", 'responsive', [{}, ...], refresh )
     *
     *  - for updating multiple values at once (not responsive)
     *     .slick("setOption", { 'option': value, ... }, refresh )
     */
    var _ = this,
        l,
        item,
        option,
        value,
        refresh = false,
        type;

    if ($.type(arguments[0]) === 'object') {
      option = arguments[0];
      refresh = arguments[1];
      type = 'multiple';
    } else if ($.type(arguments[0]) === 'string') {
      option = arguments[0];
      value = arguments[1];
      refresh = arguments[2];

      if (arguments[0] === 'responsive' && $.type(arguments[1]) === 'array') {
        type = 'responsive';
      } else if (typeof arguments[1] !== 'undefined') {
        type = 'single';
      }
    }

    if (type === 'single') {
      _.options[option] = value;
    } else if (type === 'multiple') {
      $.each(option, function (opt, val) {
        _.options[opt] = val;
      });
    } else if (type === 'responsive') {
      for (item in value) {
        if ($.type(_.options.responsive) !== 'array') {
          _.options.responsive = [value[item]];
        } else {
          l = _.options.responsive.length - 1; // loop through the responsive object and splice out duplicates.

          while (l >= 0) {
            if (_.options.responsive[l].breakpoint === value[item].breakpoint) {
              _.options.responsive.splice(l, 1);
            }

            l--;
          }

          _.options.responsive.push(value[item]);
        }
      }
    }

    if (refresh) {
      _.unload();

      _.reinit();
    }
  };

  Slick.prototype.setPosition = function () {
    var _ = this;

    _.setDimensions();

    _.setHeight();

    if (_.options.fade === false) {
      _.setCSS(_.getLeft(_.currentSlide));
    } else {
      _.setFade();
    }

    _.$slider.trigger('setPosition', [_]);
  };

  Slick.prototype.setProps = function () {
    var _ = this,
        bodyStyle = document.body.style;

    _.positionProp = _.options.vertical === true ? 'top' : 'left';

    if (_.positionProp === 'top') {
      _.$slider.addClass('slick-vertical');
    } else {
      _.$slider.removeClass('slick-vertical');
    }

    if (bodyStyle.WebkitTransition !== undefined || bodyStyle.MozTransition !== undefined || bodyStyle.msTransition !== undefined) {
      if (_.options.useCSS === true) {
        _.cssTransitions = true;
      }
    }

    if (_.options.fade) {
      if (typeof _.options.zIndex === 'number') {
        if (_.options.zIndex < 3) {
          _.options.zIndex = 3;
        }
      } else {
        _.options.zIndex = _.defaults.zIndex;
      }
    }

    if (bodyStyle.OTransform !== undefined) {
      _.animType = 'OTransform';
      _.transformType = '-o-transform';
      _.transitionType = 'OTransition';
      if (bodyStyle.perspectiveProperty === undefined && bodyStyle.webkitPerspective === undefined) _.animType = false;
    }

    if (bodyStyle.MozTransform !== undefined) {
      _.animType = 'MozTransform';
      _.transformType = '-moz-transform';
      _.transitionType = 'MozTransition';
      if (bodyStyle.perspectiveProperty === undefined && bodyStyle.MozPerspective === undefined) _.animType = false;
    }

    if (bodyStyle.webkitTransform !== undefined) {
      _.animType = 'webkitTransform';
      _.transformType = '-webkit-transform';
      _.transitionType = 'webkitTransition';
      if (bodyStyle.perspectiveProperty === undefined && bodyStyle.webkitPerspective === undefined) _.animType = false;
    }

    if (bodyStyle.msTransform !== undefined) {
      _.animType = 'msTransform';
      _.transformType = '-ms-transform';
      _.transitionType = 'msTransition';
      if (bodyStyle.msTransform === undefined) _.animType = false;
    }

    if (bodyStyle.transform !== undefined && _.animType !== false) {
      _.animType = 'transform';
      _.transformType = 'transform';
      _.transitionType = 'transition';
    }

    _.transformsEnabled = _.options.useTransform && _.animType !== null && _.animType !== false;
  };

  Slick.prototype.setSlideClasses = function (index) {
    var _ = this,
        centerOffset,
        allSlides,
        indexOffset,
        remainder;

    allSlides = _.$slider.find('.slick-slide').removeClass('slick-active slick-center slick-current').attr('aria-hidden', 'true');

    _.$slides.eq(index).addClass('slick-current');

    if (_.options.centerMode === true) {
      var evenCoef = _.options.slidesToShow % 2 === 0 ? 1 : 0;
      centerOffset = Math.floor(_.options.slidesToShow / 2);

      if (_.options.infinite === true) {
        if (index >= centerOffset && index <= _.slideCount - 1 - centerOffset) {
          _.$slides.slice(index - centerOffset + evenCoef, index + centerOffset + 1).addClass('slick-active').attr('aria-hidden', 'false');
        } else {
          indexOffset = _.options.slidesToShow + index;
          allSlides.slice(indexOffset - centerOffset + 1 + evenCoef, indexOffset + centerOffset + 2).addClass('slick-active').attr('aria-hidden', 'false');
        }

        if (index === 0) {
          allSlides.eq(allSlides.length - 1 - _.options.slidesToShow).addClass('slick-center');
        } else if (index === _.slideCount - 1) {
          allSlides.eq(_.options.slidesToShow).addClass('slick-center');
        }
      }

      _.$slides.eq(index).addClass('slick-center');
    } else {
      if (index >= 0 && index <= _.slideCount - _.options.slidesToShow) {
        _.$slides.slice(index, index + _.options.slidesToShow).addClass('slick-active').attr('aria-hidden', 'false');
      } else if (allSlides.length <= _.options.slidesToShow) {
        allSlides.addClass('slick-active').attr('aria-hidden', 'false');
      } else {
        remainder = _.slideCount % _.options.slidesToShow;
        indexOffset = _.options.infinite === true ? _.options.slidesToShow + index : index;

        if (_.options.slidesToShow == _.options.slidesToScroll && _.slideCount - index < _.options.slidesToShow) {
          allSlides.slice(indexOffset - (_.options.slidesToShow - remainder), indexOffset + remainder).addClass('slick-active').attr('aria-hidden', 'false');
        } else {
          allSlides.slice(indexOffset, indexOffset + _.options.slidesToShow).addClass('slick-active').attr('aria-hidden', 'false');
        }
      }
    }

    if (_.options.lazyLoad === 'ondemand' || _.options.lazyLoad === 'anticipated') {
      _.lazyLoad();
    }
  };

  Slick.prototype.setupInfinite = function () {
    var _ = this,
        i,
        slideIndex,
        infiniteCount;

    if (_.options.fade === true) {
      _.options.centerMode = false;
    }

    if (_.options.infinite === true && _.options.fade === false) {
      slideIndex = null;

      if (_.slideCount > _.options.slidesToShow) {
        if (_.options.centerMode === true) {
          infiniteCount = _.options.slidesToShow + 1;
        } else {
          infiniteCount = _.options.slidesToShow;
        }

        for (i = _.slideCount; i > _.slideCount - infiniteCount; i -= 1) {
          slideIndex = i - 1;
          $(_.$slides[slideIndex]).clone(true).attr('id', '').attr('data-slick-index', slideIndex - _.slideCount).prependTo(_.$slideTrack).addClass('slick-cloned');
        }

        for (i = 0; i < infiniteCount + _.slideCount; i += 1) {
          slideIndex = i;
          $(_.$slides[slideIndex]).clone(true).attr('id', '').attr('data-slick-index', slideIndex + _.slideCount).appendTo(_.$slideTrack).addClass('slick-cloned');
        }

        _.$slideTrack.find('.slick-cloned').find('[id]').each(function () {
          $(this).attr('id', '');
        });
      }
    }
  };

  Slick.prototype.interrupt = function (toggle) {
    var _ = this;

    if (!toggle) {
      _.autoPlay();
    }

    _.interrupted = toggle;
  };

  Slick.prototype.selectHandler = function (event) {
    var _ = this;

    var targetElement = $(event.target).is('.slick-slide') ? $(event.target) : $(event.target).parents('.slick-slide');
    var index = parseInt(targetElement.attr('data-slick-index'));
    if (!index) index = 0;

    if (_.slideCount <= _.options.slidesToShow) {
      _.slideHandler(index, false, true);

      return;
    }

    _.slideHandler(index);
  };

  Slick.prototype.slideHandler = function (index, sync, dontAnimate) {
    var targetSlide,
        animSlide,
        oldSlide,
        slideLeft,
        targetLeft = null,
        _ = this,
        navTarget;

    sync = sync || false;

    if (_.animating === true && _.options.waitForAnimate === true) {
      return;
    }

    if (_.options.fade === true && _.currentSlide === index) {
      return;
    }

    if (sync === false) {
      _.asNavFor(index);
    }

    targetSlide = index;
    targetLeft = _.getLeft(targetSlide);
    slideLeft = _.getLeft(_.currentSlide);
    _.currentLeft = _.swipeLeft === null ? slideLeft : _.swipeLeft;

    if (_.options.infinite === false && _.options.centerMode === false && (index < 0 || index > _.getDotCount() * _.options.slidesToScroll)) {
      if (_.options.fade === false) {
        targetSlide = _.currentSlide;

        if (dontAnimate !== true && _.slideCount > _.options.slidesToShow) {
          _.animateSlide(slideLeft, function () {
            _.postSlide(targetSlide);
          });
        } else {
          _.postSlide(targetSlide);
        }
      }

      return;
    } else if (_.options.infinite === false && _.options.centerMode === true && (index < 0 || index > _.slideCount - _.options.slidesToScroll)) {
      if (_.options.fade === false) {
        targetSlide = _.currentSlide;

        if (dontAnimate !== true && _.slideCount > _.options.slidesToShow) {
          _.animateSlide(slideLeft, function () {
            _.postSlide(targetSlide);
          });
        } else {
          _.postSlide(targetSlide);
        }
      }

      return;
    }

    if (_.options.autoplay) {
      clearInterval(_.autoPlayTimer);
    }

    if (targetSlide < 0) {
      if (_.slideCount % _.options.slidesToScroll !== 0) {
        animSlide = _.slideCount - _.slideCount % _.options.slidesToScroll;
      } else {
        animSlide = _.slideCount + targetSlide;
      }
    } else if (targetSlide >= _.slideCount) {
      if (_.slideCount % _.options.slidesToScroll !== 0) {
        animSlide = 0;
      } else {
        animSlide = targetSlide - _.slideCount;
      }
    } else {
      animSlide = targetSlide;
    }

    _.animating = true;

    _.$slider.trigger('beforeChange', [_, _.currentSlide, animSlide]);

    oldSlide = _.currentSlide;
    _.currentSlide = animSlide;

    _.setSlideClasses(_.currentSlide);

    if (_.options.asNavFor) {
      navTarget = _.getNavTarget();
      navTarget = navTarget.slick('getSlick');

      if (navTarget.slideCount <= navTarget.options.slidesToShow) {
        navTarget.setSlideClasses(_.currentSlide);
      }
    }

    _.updateDots();

    _.updateArrows();

    if (_.options.fade === true) {
      if (dontAnimate !== true) {
        _.fadeSlideOut(oldSlide);

        _.fadeSlide(animSlide, function () {
          _.postSlide(animSlide);
        });
      } else {
        _.postSlide(animSlide);
      }

      _.animateHeight();

      return;
    }

    if (dontAnimate !== true && _.slideCount > _.options.slidesToShow) {
      _.animateSlide(targetLeft, function () {
        _.postSlide(animSlide);
      });
    } else {
      _.postSlide(animSlide);
    }
  };

  Slick.prototype.startLoad = function () {
    var _ = this;

    if (_.options.arrows === true && _.slideCount > _.options.slidesToShow) {
      _.$prevArrow.hide();

      _.$nextArrow.hide();
    }

    if (_.options.dots === true && _.slideCount > _.options.slidesToShow) {
      _.$dots.hide();
    }

    _.$slider.addClass('slick-loading');
  };

  Slick.prototype.swipeDirection = function () {
    var xDist,
        yDist,
        r,
        swipeAngle,
        _ = this;

    xDist = _.touchObject.startX - _.touchObject.curX;
    yDist = _.touchObject.startY - _.touchObject.curY;
    r = Math.atan2(yDist, xDist);
    swipeAngle = Math.round(r * 180 / Math.PI);

    if (swipeAngle < 0) {
      swipeAngle = 360 - Math.abs(swipeAngle);
    }

    if (swipeAngle <= 45 && swipeAngle >= 0) {
      return _.options.rtl === false ? 'left' : 'right';
    }

    if (swipeAngle <= 360 && swipeAngle >= 315) {
      return _.options.rtl === false ? 'left' : 'right';
    }

    if (swipeAngle >= 135 && swipeAngle <= 225) {
      return _.options.rtl === false ? 'right' : 'left';
    }

    if (_.options.verticalSwiping === true) {
      if (swipeAngle >= 35 && swipeAngle <= 135) {
        return 'down';
      } else {
        return 'up';
      }
    }

    return 'vertical';
  };

  Slick.prototype.swipeEnd = function (event) {
    var _ = this,
        slideCount,
        direction;

    _.dragging = false;
    _.swiping = false;

    if (_.scrolling) {
      _.scrolling = false;
      return false;
    }

    _.interrupted = false;
    _.shouldClick = _.touchObject.swipeLength > 10 ? false : true;

    if (_.touchObject.curX === undefined) {
      return false;
    }

    if (_.touchObject.edgeHit === true) {
      _.$slider.trigger('edge', [_, _.swipeDirection()]);
    }

    if (_.touchObject.swipeLength >= _.touchObject.minSwipe) {
      direction = _.swipeDirection();

      switch (direction) {
        case 'left':
        case 'down':
          slideCount = _.options.swipeToSlide ? _.checkNavigable(_.currentSlide + _.getSlideCount()) : _.currentSlide + _.getSlideCount();
          _.currentDirection = 0;
          break;

        case 'right':
        case 'up':
          slideCount = _.options.swipeToSlide ? _.checkNavigable(_.currentSlide - _.getSlideCount()) : _.currentSlide - _.getSlideCount();
          _.currentDirection = 1;
          break;

        default:
      }

      if (direction != 'vertical') {
        _.slideHandler(slideCount);

        _.touchObject = {};

        _.$slider.trigger('swipe', [_, direction]);
      }
    } else {
      if (_.touchObject.startX !== _.touchObject.curX) {
        _.slideHandler(_.currentSlide);

        _.touchObject = {};
      }
    }
  };

  Slick.prototype.swipeHandler = function (event) {
    var _ = this;

    if (_.options.swipe === false || 'ontouchend' in document && _.options.swipe === false) {
      return;
    } else if (_.options.draggable === false && event.type.indexOf('mouse') !== -1) {
      return;
    }

    _.touchObject.fingerCount = event.originalEvent && event.originalEvent.touches !== undefined ? event.originalEvent.touches.length : 1;
    _.touchObject.minSwipe = _.listWidth / _.options.touchThreshold;

    if (_.options.verticalSwiping === true) {
      _.touchObject.minSwipe = _.listHeight / _.options.touchThreshold;
    }

    switch (event.data.action) {
      case 'start':
        _.swipeStart(event);

        break;

      case 'move':
        _.swipeMove(event);

        break;

      case 'end':
        _.swipeEnd(event);

        break;
    }
  };

  Slick.prototype.swipeMove = function (event) {
    var _ = this,
        edgeWasHit = false,
        curLeft,
        swipeDirection,
        swipeLength,
        positionOffset,
        touches,
        verticalSwipeLength;

    touches = event.originalEvent !== undefined ? event.originalEvent.touches : null;

    if (!_.dragging || _.scrolling || touches && touches.length !== 1) {
      return false;
    }

    curLeft = _.getLeft(_.currentSlide);
    _.touchObject.curX = touches !== undefined ? touches[0].pageX : event.clientX;
    _.touchObject.curY = touches !== undefined ? touches[0].pageY : event.clientY;
    _.touchObject.swipeLength = Math.round(Math.sqrt(Math.pow(_.touchObject.curX - _.touchObject.startX, 2)));
    verticalSwipeLength = Math.round(Math.sqrt(Math.pow(_.touchObject.curY - _.touchObject.startY, 2)));

    if (!_.options.verticalSwiping && !_.swiping && verticalSwipeLength > 4) {
      _.scrolling = true;
      return false;
    }

    if (_.options.verticalSwiping === true) {
      _.touchObject.swipeLength = verticalSwipeLength;
    }

    swipeDirection = _.swipeDirection();

    if (event.originalEvent !== undefined && _.touchObject.swipeLength > 4) {
      _.swiping = true;
      event.preventDefault();
    }

    positionOffset = (_.options.rtl === false ? 1 : -1) * (_.touchObject.curX > _.touchObject.startX ? 1 : -1);

    if (_.options.verticalSwiping === true) {
      positionOffset = _.touchObject.curY > _.touchObject.startY ? 1 : -1;
    }

    swipeLength = _.touchObject.swipeLength;
    _.touchObject.edgeHit = false;

    if (_.options.infinite === false) {
      if (_.currentSlide === 0 && swipeDirection === 'right' || _.currentSlide >= _.getDotCount() && swipeDirection === 'left') {
        swipeLength = _.touchObject.swipeLength * _.options.edgeFriction;
        _.touchObject.edgeHit = true;
      }
    }

    if (_.options.vertical === false) {
      _.swipeLeft = curLeft + swipeLength * positionOffset;
    } else {
      _.swipeLeft = curLeft + swipeLength * (_.$list.height() / _.listWidth) * positionOffset;
    }

    if (_.options.verticalSwiping === true) {
      _.swipeLeft = curLeft + swipeLength * positionOffset;
    }

    if (_.options.fade === true || _.options.touchMove === false) {
      return false;
    }

    if (_.animating === true) {
      _.swipeLeft = null;
      return false;
    }

    _.setCSS(_.swipeLeft);
  };

  Slick.prototype.swipeStart = function (event) {
    var _ = this,
        touches;

    _.interrupted = true;

    if (_.touchObject.fingerCount !== 1 || _.slideCount <= _.options.slidesToShow) {
      _.touchObject = {};
      return false;
    }

    if (event.originalEvent !== undefined && event.originalEvent.touches !== undefined) {
      touches = event.originalEvent.touches[0];
    }

    _.touchObject.startX = _.touchObject.curX = touches !== undefined ? touches.pageX : event.clientX;
    _.touchObject.startY = _.touchObject.curY = touches !== undefined ? touches.pageY : event.clientY;
    _.dragging = true;
  };

  Slick.prototype.unfilterSlides = Slick.prototype.slickUnfilter = function () {
    var _ = this;

    if (_.$slidesCache !== null) {
      _.unload();

      _.$slideTrack.children(this.options.slide).detach();

      _.$slidesCache.appendTo(_.$slideTrack);

      _.reinit();
    }
  };

  Slick.prototype.unload = function () {
    var _ = this;

    $('.slick-cloned', _.$slider).remove();

    if (_.$dots) {
      _.$dots.remove();
    }

    if (_.$prevArrow && _.htmlExpr.test(_.options.prevArrow)) {
      _.$prevArrow.remove();
    }

    if (_.$nextArrow && _.htmlExpr.test(_.options.nextArrow)) {
      _.$nextArrow.remove();
    }

    _.$slides.removeClass('slick-slide slick-active slick-visible slick-current').attr('aria-hidden', 'true').css('width', '');
  };

  Slick.prototype.unslick = function (fromBreakpoint) {
    var _ = this;

    _.$slider.trigger('unslick', [_, fromBreakpoint]);

    _.destroy();
  };

  Slick.prototype.updateArrows = function () {
    var _ = this,
        centerOffset;

    centerOffset = Math.floor(_.options.slidesToShow / 2);

    if (_.options.arrows === true && _.slideCount > _.options.slidesToShow && !_.options.infinite) {
      _.$prevArrow.removeClass('slick-disabled').attr('aria-disabled', 'false');

      _.$nextArrow.removeClass('slick-disabled').attr('aria-disabled', 'false');

      if (_.currentSlide === 0) {
        _.$prevArrow.addClass('slick-disabled').attr('aria-disabled', 'true');

        _.$nextArrow.removeClass('slick-disabled').attr('aria-disabled', 'false');
      } else if (_.currentSlide >= _.slideCount - _.options.slidesToShow && _.options.centerMode === false) {
        _.$nextArrow.addClass('slick-disabled').attr('aria-disabled', 'true');

        _.$prevArrow.removeClass('slick-disabled').attr('aria-disabled', 'false');
      } else if (_.currentSlide >= _.slideCount - 1 && _.options.centerMode === true) {
        _.$nextArrow.addClass('slick-disabled').attr('aria-disabled', 'true');

        _.$prevArrow.removeClass('slick-disabled').attr('aria-disabled', 'false');
      }
    }
  };

  Slick.prototype.updateDots = function () {
    var _ = this;

    if (_.$dots !== null) {
      _.$dots.find('li').removeClass('slick-active').end();

      _.$dots.find('li').eq(Math.floor(_.currentSlide / _.options.slidesToScroll)).addClass('slick-active');
    }
  };

  Slick.prototype.visibility = function () {
    var _ = this;

    if (_.options.autoplay) {
      if (document[_.hidden]) {
        _.interrupted = true;
      } else {
        _.interrupted = false;
      }
    }
  };

  $.fn.slick = function () {
    var _ = this,
        opt = arguments[0],
        args = Array.prototype.slice.call(arguments, 1),
        l = _.length,
        i,
        ret;

    for (i = 0; i < l; i++) {
      if (_typeof(opt) == 'object' || typeof opt == 'undefined') _[i].slick = new Slick(_[i], opt);else ret = _[i].slick[opt].apply(_[i].slick, args);
      if (typeof ret != 'undefined') return ret;
    }

    return _;
  };
});

/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDQ2LjBjZGU3ODk1MmNhNGZlMmJmZGUzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7QUFBQSxTQUFTQSxzQkFBVCxDQUFnQ0MsSUFBaEMsRUFBc0M7QUFBRSxNQUFJQSxJQUFJLEtBQUssS0FBSyxDQUFsQixFQUFxQjtBQUFFLFVBQU0sSUFBSUMsY0FBSixDQUFtQiwyREFBbkIsQ0FBTjtBQUF3Rjs7QUFBQyxTQUFPRCxJQUFQO0FBQWM7O0FBRXRLLFNBQVNFLGNBQVQsQ0FBd0JDLFFBQXhCLEVBQWtDQyxVQUFsQyxFQUE4QztBQUFFRCxFQUFBQSxRQUFRLENBQUNFLFNBQVQsR0FBcUJDLE1BQU0sQ0FBQ0MsTUFBUCxDQUFjSCxVQUFVLENBQUNDLFNBQXpCLENBQXJCO0FBQTBERixFQUFBQSxRQUFRLENBQUNFLFNBQVQsQ0FBbUJHLFdBQW5CLEdBQWlDTCxRQUFqQztBQUEyQ0EsRUFBQUEsUUFBUSxDQUFDTSxTQUFULEdBQXFCTCxVQUFyQjtBQUFrQztBQUV2TDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7OztBQUNBOztBQUVBLElBQUlRLElBQUo7QUFBQSxJQUNJQyxJQURKO0FBQUEsSUFFSUMsSUFGSjtBQUFBLElBR0lDLFdBSEo7QUFBQSxJQUlJQyxLQUpKO0FBQUEsSUFLSUMsUUFMSjtBQUFBLElBTUlDLGVBTko7QUFBQSxJQU9JQyxZQVBKO0FBQUEsSUFRSUMsWUFSSjtBQUFBLElBU0lDLFFBVEo7QUFBQSxJQVVJQyxnQkFWSjtBQUFBLElBV0lDLGNBWEo7QUFBQSxJQVlJQyxpQkFaSjtBQUFBLElBYUlDLFVBYko7QUFBQSxJQWNJQyxnQkFkSjtBQUFBLElBZUlDLFVBZko7QUFBQSxJQWdCSUMsYUFoQko7QUFBQSxJQWlCSUMsY0FqQko7QUFBQSxJQWtCSUMsZ0JBbEJKO0FBQUEsSUFtQklDLGFBQWEsR0FBRyxTQUFTQSxhQUFULEdBQXlCO0FBQzNDLFNBQU8sT0FBT0MsTUFBUCxLQUFrQixXQUF6QjtBQUNELENBckJEO0FBQUEsSUFzQklDLFFBQVEsR0FBRyxTQUFTQSxRQUFULEdBQW9CO0FBQ2pDLFNBQU9yQixJQUFJLElBQUltQixhQUFhLE9BQU9uQixJQUFJLEdBQUdvQixNQUFNLENBQUNwQixJQUFyQixDQUFiLElBQTJDQSxJQUFJLENBQUNzQixjQUFoRCxJQUFrRXRCLElBQWpGO0FBQ0QsQ0F4QkQ7QUFBQSxJQXlCSXVCLFdBQVcsR0FBRyxTQUFTQSxXQUFULENBQXFCQyxLQUFyQixFQUE0QjtBQUM1QyxTQUFPLE9BQU9BLEtBQVAsS0FBaUIsVUFBeEI7QUFDRCxDQTNCRDtBQUFBLElBNEJJQyxTQUFTLEdBQUcsU0FBU0EsU0FBVCxDQUFtQkQsS0FBbkIsRUFBMEI7QUFDeEMsU0FBTyxRQUFPQSxLQUFQLE1BQWlCLFFBQXhCO0FBQ0QsQ0E5QkQ7QUFBQSxJQStCSUUsWUFBWSxHQUFHLFNBQVNBLFlBQVQsQ0FBc0JGLEtBQXRCLEVBQTZCO0FBQzlDLFNBQU8sT0FBT0EsS0FBUCxLQUFpQixXQUF4QjtBQUNELENBakNEO0FBQUEsSUFrQ0lHLFVBQVUsR0FBRyxTQUFTQSxVQUFULEdBQXNCO0FBQ3JDLFNBQU8sS0FBUDtBQUNELENBcENEO0FBQUEsSUFxQ0lDLGNBQWMsR0FBRyxXQXJDckI7QUFBQSxJQXNDSUMsb0JBQW9CLEdBQUcsaUJBdEMzQjtBQUFBLElBdUNJQyxNQUFNLEdBQUcsU0FBU0EsTUFBVCxDQUFnQk4sS0FBaEIsRUFBdUI7QUFDbEMsU0FBT08sSUFBSSxDQUFDQyxLQUFMLENBQVdSLEtBQUssR0FBRyxLQUFuQixJQUE0QixLQUFuQztBQUNELENBekNEO0FBQUEsSUEwQ0lTLFFBQVEsR0FBR0MsS0FBSyxDQUFDQyxPQTFDckI7QUFBQSxJQTJDSUMsY0FBYyxHQUFHLFNBQVNBLGNBQVQsQ0FBd0JDLElBQXhCLEVBQThCQyxFQUE5QixFQUFrQztBQUNyRCxNQUFJQyxDQUFDLEdBQUdyQyxJQUFJLENBQUNzQyxlQUFMLEdBQXVCdEMsSUFBSSxDQUFDc0MsZUFBTCxDQUFxQixDQUFDRixFQUFFLElBQUksOEJBQVAsRUFBdUNHLE9BQXZDLENBQStDLFFBQS9DLEVBQXlELE1BQXpELENBQXJCLEVBQXVGSixJQUF2RixDQUF2QixHQUFzSG5DLElBQUksQ0FBQ3dDLGFBQUwsQ0FBbUJMLElBQW5CLENBQTlILENBRHFELENBQ21HOztBQUV4SixTQUFPRSxDQUFDLENBQUNJLEtBQUYsR0FBVUosQ0FBVixHQUFjckMsSUFBSSxDQUFDd0MsYUFBTCxDQUFtQkwsSUFBbkIsQ0FBckIsQ0FIcUQsQ0FHTjtBQUNoRCxDQS9DRDtBQUFBLElBZ0RJTyxRQUFRLEdBQUcsTUFBTWIsSUFBSSxDQUFDYyxFQWhEMUI7QUFBQSxJQWlESUMsT0FBTyxHQUFHLElBakRkO0FBQUEsSUFrRElDLGVBQWUsR0FBRyxJQUFJaEQsZ0VBQUosRUFsRHRCO0FBQUEsSUFtRElpRCxRQUFRLEdBQUdDLElBQUksQ0FBQ0MsR0FBTCxJQUFZLFlBQVk7QUFDckMsU0FBTyxJQUFJRCxJQUFKLEdBQVdFLE9BQVgsRUFBUDtBQUNELENBckREO0FBQUEsSUFzRElDLFlBQVksR0FBRyxFQXREbkI7QUFBQSxJQXVESUMsT0FBTyxHQUFHLEVBdkRkO0FBQUEsSUF3REk7QUFDSkMsWUFBWSxHQUFHLENBekRmO0FBQUEsSUEwRElDLGdCQUFnQixHQUFHLHVDQTFEdkI7QUFBQSxJQTJESUMsYUFBYSxHQUFHLENBM0RwQjtBQUFBLElBNERJQyxNQUFNLEdBQUcsRUE1RGI7QUFBQSxJQTZESTtBQUNKQyxZQUFZLEdBQUcsRUE5RGY7QUFBQSxJQStESTtBQUNKQyxLQUFLLEdBQUcsU0FBU0EsS0FBVCxDQUFlQyxHQUFmLEVBQW9CQyxNQUFwQixFQUE0QjtBQUNsQyxNQUFJQyxJQUFJLEdBQUcsRUFBWDtBQUFBLE1BQ0lDLENBREo7O0FBR0EsT0FBS0EsQ0FBTCxJQUFVSCxHQUFWLEVBQWU7QUFDYkUsSUFBQUEsSUFBSSxDQUFDQyxDQUFELENBQUosR0FBVUYsTUFBTSxHQUFHRCxHQUFHLENBQUNHLENBQUQsQ0FBSCxHQUFTRixNQUFaLEdBQXFCRCxHQUFHLENBQUNHLENBQUQsQ0FBeEM7QUFDRDs7QUFFRCxTQUFPRCxJQUFQO0FBQ0QsQ0F6RUQ7QUFBQSxJQTBFSUUsT0FBTyxHQUFHLFNBQVNBLE9BQVQsQ0FBaUJKLEdBQWpCLEVBQXNCSyxRQUF0QixFQUFnQztBQUM1QyxPQUFLLElBQUlGLENBQVQsSUFBY0UsUUFBZCxFQUF3QjtBQUN0QixRQUFJLEVBQUVGLENBQUMsSUFBSUgsR0FBUCxDQUFKLEVBQWlCO0FBQ2ZBLE1BQUFBLEdBQUcsQ0FBQ0csQ0FBRCxDQUFILEdBQVNFLFFBQVEsQ0FBQ0YsQ0FBRCxDQUFqQjtBQUNEO0FBQ0Y7O0FBRUQsU0FBT0gsR0FBUDtBQUNELENBbEZEO0FBQUEsSUFtRklNLGdDQUFnQyxHQUFHLFNBQVNBLGdDQUFULENBQTBDQyxRQUExQyxFQUFvRDNDLEtBQXBELEVBQTJEO0FBQ2hHLE1BQUk0QyxDQUFDLEdBQUdELFFBQVEsQ0FBQ0UsTUFBakI7QUFBQSxNQUNJQyxRQURKOztBQUdBLFNBQU9GLENBQUMsRUFBUixFQUFZO0FBQ1Y1QyxJQUFBQSxLQUFLLEdBQUcyQyxRQUFRLENBQUNDLENBQUQsQ0FBUixDQUFZekIsS0FBWixDQUFrQjRCLFdBQWxCLEdBQWdDL0MsS0FBbkMsR0FBMkMyQyxRQUFRLENBQUNDLENBQUQsQ0FBUixDQUFZekIsS0FBWixDQUFrQjZCLGNBQWxCLENBQWlDLGNBQWpDLENBQWhEO0FBQ0FGLElBQUFBLFFBQVEsR0FBR0gsUUFBUSxDQUFDQyxDQUFELENBQVIsQ0FBWUUsUUFBdkI7QUFDQUEsSUFBQUEsUUFBUSxJQUFJQSxRQUFRLENBQUNELE1BQXJCLElBQStCSCxnQ0FBZ0MsQ0FBQ0ksUUFBRCxFQUFXOUMsS0FBWCxDQUEvRDtBQUNEO0FBQ0YsQ0E1RkQ7QUFBQSxJQTZGSWlELGdCQUFnQixHQUFHLFNBQVNBLGdCQUFULEdBQTRCO0FBQ2pELFNBQU9yQixZQUFZLENBQUNzQixPQUFiLENBQXFCLFVBQVVDLElBQVYsRUFBZ0I7QUFDMUMsV0FBT0EsSUFBSSxFQUFYO0FBQ0QsR0FGTSxDQUFQO0FBR0QsQ0FqR0Q7QUFBQSxJQWtHSUMsaUJBQWlCLEdBQUcsU0FBU0EsaUJBQVQsQ0FBMkJELElBQTNCLEVBQWlDO0FBQ3ZEdkIsRUFBQUEsWUFBWSxDQUFDeUIsSUFBYixDQUFrQkYsSUFBbEI7O0FBRUEsTUFBSXZCLFlBQVksQ0FBQ2lCLE1BQWIsS0FBd0IsQ0FBNUIsRUFBK0I7QUFDN0JyRSxJQUFBQSxJQUFJLENBQUM4RSxNQUFMLENBQVlDLEdBQVosQ0FBZ0JOLGdCQUFoQjtBQUNEO0FBQ0YsQ0F4R0Q7QUFBQSxJQXlHSU8sbUJBQW1CLEdBQUcsU0FBU0EsbUJBQVQsR0FBK0I7QUFDdkQsU0FBTyxDQUFDNUIsWUFBWSxDQUFDaUIsTUFBZCxJQUF3QnJFLElBQUksQ0FBQzhFLE1BQUwsQ0FBWUcsTUFBWixDQUFtQlIsZ0JBQW5CLENBQS9CO0FBQ0QsQ0EzR0Q7QUFBQSxJQTRHSVMsc0JBQXNCLEdBQUcsU0FBU0Esc0JBQVQsQ0FBZ0NQLElBQWhDLEVBQXNDO0FBQ2pFLE1BQUlQLENBQUMsR0FBR2hCLFlBQVksQ0FBQ2lCLE1BQXJCOztBQUVBLFNBQU9ELENBQUMsRUFBUixFQUFZO0FBQ1YsUUFBSWhCLFlBQVksQ0FBQ2dCLENBQUQsQ0FBWixLQUFvQk8sSUFBeEIsRUFBOEI7QUFDNUJ2QixNQUFBQSxZQUFZLENBQUMrQixNQUFiLENBQW9CZixDQUFwQixFQUF1QixDQUF2QjtBQUNEO0FBQ0Y7O0FBRURwRSxFQUFBQSxJQUFJLENBQUNvRixFQUFMLENBQVFKLG1CQUFSLEVBQTZCO0FBQzNCSyxJQUFBQSxTQUFTLEVBQUUsSUFEZ0I7QUFFM0JDLElBQUFBLEtBQUssRUFBRSxFQUZvQjtBQUczQkMsSUFBQUEsUUFBUSxFQUFFLENBSGlCO0FBSTNCQyxJQUFBQSxVQUFVLEVBQUVSLG1CQUplO0FBSzNCUyxJQUFBQSxJQUFJLEVBQUU7QUFMcUIsR0FBN0IsRUFUaUUsQ0FlN0Q7QUFDTCxDQTVIRDtBQUFBLElBNkhJQyxZQUFZLEdBQUcsU0FBU0EsWUFBVCxDQUFzQjlCLEdBQXRCLEVBQTJCSyxRQUEzQixFQUFxQztBQUN0RCxPQUFLLElBQUlGLENBQVQsSUFBY0UsUUFBZCxFQUF3QjtBQUN0QixRQUFJLEVBQUVGLENBQUMsSUFBSUgsR0FBUCxDQUFKLEVBQWlCO0FBQ2ZBLE1BQUFBLEdBQUcsQ0FBQ0csQ0FBRCxDQUFILEdBQVNFLFFBQVEsQ0FBQ0YsQ0FBRCxDQUFqQjtBQUNEO0FBQ0Y7O0FBRUQsU0FBT0gsR0FBUDtBQUNELENBcklEO0FBQUEsSUFzSUkrQixZQUFZLEdBQUcsU0FBU0EsWUFBVCxDQUFzQkMsT0FBdEIsRUFBK0J2RCxJQUEvQixFQUFxQ3NDLElBQXJDLEVBQTJDa0IsT0FBM0MsRUFBb0Q7QUFDckUsTUFBSUQsT0FBTyxDQUFDRSxnQkFBWixFQUE4QjtBQUM1QixRQUFJQyxTQUFTLEdBQUduRixpQkFBaUIsQ0FBQ3lCLElBQUQsQ0FBakM7QUFDQXdELElBQUFBLE9BQU8sR0FBR0EsT0FBTyxLQUFLbkYsZ0JBQWdCLEdBQUc7QUFDdkNzRixNQUFBQSxPQUFPLEVBQUU7QUFEOEIsS0FBSCxHQUVsQyxJQUZhLENBQWpCO0FBR0FKLElBQUFBLE9BQU8sQ0FBQ0UsZ0JBQVIsQ0FBeUJDLFNBQVMsSUFBSTFELElBQXRDLEVBQTRDc0MsSUFBNUMsRUFBa0RrQixPQUFsRDtBQUNBRSxJQUFBQSxTQUFTLElBQUkxRCxJQUFJLEtBQUswRCxTQUF0QixJQUFtQ0gsT0FBTyxDQUFDRSxnQkFBUixDQUF5QnpELElBQXpCLEVBQStCc0MsSUFBL0IsRUFBcUNrQixPQUFyQyxDQUFuQyxDQU40QixDQU1zRDtBQUNuRjtBQUNGLENBL0lEO0FBQUEsSUFnSklJLGVBQWUsR0FBRyxTQUFTQSxlQUFULENBQXlCTCxPQUF6QixFQUFrQ3ZELElBQWxDLEVBQXdDc0MsSUFBeEMsRUFBOEM7QUFDbEUsTUFBSWlCLE9BQU8sQ0FBQ00sbUJBQVosRUFBaUM7QUFDL0IsUUFBSUgsU0FBUyxHQUFHbkYsaUJBQWlCLENBQUN5QixJQUFELENBQWpDO0FBQ0F1RCxJQUFBQSxPQUFPLENBQUNNLG1CQUFSLENBQTRCSCxTQUFTLElBQUkxRCxJQUF6QyxFQUErQ3NDLElBQS9DO0FBQ0FvQixJQUFBQSxTQUFTLElBQUkxRCxJQUFJLEtBQUswRCxTQUF0QixJQUFtQ0gsT0FBTyxDQUFDTSxtQkFBUixDQUE0QjdELElBQTVCLEVBQWtDc0MsSUFBbEMsQ0FBbkM7QUFDRDtBQUNGLENBdEpEO0FBQUEsSUF1Skl3QixlQUFlLEdBQUcsU0FBU0EsZUFBVCxDQUF5QkMsS0FBekIsRUFBZ0M7QUFDcERBLEVBQUFBLEtBQUssQ0FBQ0MsY0FBTixJQUF3QkQsS0FBSyxDQUFDQyxjQUFOLEVBQXhCO0FBQ0FELEVBQUFBLEtBQUssQ0FBQ0UsbUJBQU4sSUFBNkJGLEtBQUssQ0FBQ0UsbUJBQU4sRUFBN0IsQ0FGb0QsQ0FFTTtBQUMzRCxDQTFKRDtBQUFBLElBMkpJQyxXQUFXLEdBQUcsU0FBU0EsV0FBVCxDQUFxQkMsSUFBckIsRUFBMkJDLEVBQTNCLEVBQStCO0FBQy9DLE1BQUlyQyxDQUFDLEdBQUdvQyxJQUFJLENBQUNuQyxNQUFiOztBQUVBLFNBQU9ELENBQUMsRUFBUixFQUFZO0FBQ1YsUUFBSW9DLElBQUksQ0FBQ3BDLENBQUQsQ0FBSixDQUFRc0MsVUFBUixLQUF1QkQsRUFBM0IsRUFBK0I7QUFDN0IsYUFBTyxJQUFQO0FBQ0Q7QUFDRjtBQUNGLENBbktEO0FBQUEsSUFvS0lFLHdCQUF3QixHQUFHLFNBQVNBLHdCQUFULENBQWtDUCxLQUFsQyxFQUF5QztBQUN0RXRGLEVBQUFBLGdCQUFnQixHQUFHc0YsS0FBSyxDQUFDUSxPQUFOLElBQWlCL0YsVUFBVSxHQUFHdUYsS0FBSyxDQUFDUSxPQUFOLENBQWN2QyxNQUEvRDs7QUFFQTRCLEVBQUFBLGVBQWUsQ0FBQ0csS0FBSyxDQUFDUyxNQUFQLEVBQWUsVUFBZixFQUEyQkYsd0JBQTNCLENBQWY7QUFDRCxDQXhLRDtBQUFBLElBeUtJRyxxQkFBcUIsR0FBRyxTQUFTQSxxQkFBVCxDQUErQlYsS0FBL0IsRUFBc0M7QUFDaEV0RixFQUFBQSxnQkFBZ0IsR0FBR3NGLEtBQUssQ0FBQ1EsT0FBTixJQUFpQi9GLFVBQVUsR0FBR3VGLEtBQUssQ0FBQ1EsT0FBTixDQUFjdkMsTUFBL0Q7O0FBRUFzQixFQUFBQSxZQUFZLENBQUNTLEtBQUssQ0FBQ1MsTUFBUCxFQUFlLFVBQWYsRUFBMkJGLHdCQUEzQixDQUFaO0FBQ0QsQ0E3S0Q7QUFBQSxJQThLSUksZ0JBQWdCLEdBQUcsU0FBU0EsZ0JBQVQsQ0FBMEJDLEdBQTFCLEVBQStCO0FBQ3BELFNBQU8vRyxJQUFJLENBQUNnSCxXQUFMLElBQW9CRCxHQUFHLENBQUNFLFNBQXhCLElBQXFDRixHQUFHLENBQUNHLGVBQUosQ0FBb0JELFNBQXpELElBQXNFRixHQUFHLENBQUNJLElBQUosQ0FBU0YsU0FBL0UsSUFBNEYsQ0FBbkc7QUFDRCxDQWhMRDtBQUFBLElBaUxJRyxpQkFBaUIsR0FBRyxTQUFTQSxpQkFBVCxDQUEyQkwsR0FBM0IsRUFBZ0M7QUFDdEQsU0FBTy9HLElBQUksQ0FBQ3FILFdBQUwsSUFBb0JOLEdBQUcsQ0FBQ08sVUFBeEIsSUFBc0NQLEdBQUcsQ0FBQ0csZUFBSixDQUFvQkksVUFBMUQsSUFBd0VQLEdBQUcsQ0FBQ0ksSUFBSixDQUFTRyxVQUFqRixJQUErRixDQUF0RztBQUNELENBbkxEO0FBQUEsSUFvTElDLGtCQUFrQixHQUFHLFNBQVNBLGtCQUFULENBQTRCakYsQ0FBNUIsRUFBK0JrRixRQUEvQixFQUF5QztBQUNoRTlCLEVBQUFBLFlBQVksQ0FBQ3BELENBQUQsRUFBSSxRQUFKLEVBQWNrRixRQUFkLENBQVo7O0FBRUEsTUFBSSxDQUFDQyxPQUFPLENBQUNuRixDQUFDLENBQUNvRixVQUFILENBQVosRUFBNEI7QUFDMUJILElBQUFBLGtCQUFrQixDQUFDakYsQ0FBQyxDQUFDb0YsVUFBSCxFQUFlRixRQUFmLENBQWxCO0FBQ0Q7QUFDRixDQTFMRDtBQUFBLElBMkxJRyxxQkFBcUIsR0FBRyxTQUFTQSxxQkFBVCxDQUErQnJGLENBQS9CLEVBQWtDa0YsUUFBbEMsRUFBNEM7QUFDdEV4QixFQUFBQSxlQUFlLENBQUMxRCxDQUFELEVBQUksUUFBSixFQUFja0YsUUFBZCxDQUFmOztBQUVBLE1BQUksQ0FBQ0MsT0FBTyxDQUFDbkYsQ0FBQyxDQUFDb0YsVUFBSCxDQUFaLEVBQTRCO0FBQzFCQyxJQUFBQSxxQkFBcUIsQ0FBQ3JGLENBQUMsQ0FBQ29GLFVBQUgsRUFBZUYsUUFBZixDQUFyQjtBQUNEO0FBQ0YsQ0FqTUQ7QUFBQSxJQWtNSUMsT0FBTyxHQUFHLFNBQVNBLE9BQVQsQ0FBaUJuRixDQUFqQixFQUFvQjtBQUNoQyxTQUFPLENBQUMsRUFBRSxDQUFDQSxDQUFELElBQU1BLENBQUMsS0FBS3BDLFdBQVosSUFBMkJvQyxDQUFDLENBQUNzRixRQUFGLEtBQWUsQ0FBMUMsSUFBK0N0RixDQUFDLEtBQUtyQyxJQUFJLENBQUNrSCxJQUExRCxJQUFrRTdFLENBQUMsS0FBS3RDLElBQXhFLElBQWdGLENBQUNzQyxDQUFDLENBQUNzRixRQUFuRixJQUErRixDQUFDdEYsQ0FBQyxDQUFDb0YsVUFBcEcsQ0FBUjtBQUNELENBcE1EO0FBQUEsSUFxTUlHLGFBQWEsR0FBRyxTQUFTQSxhQUFULENBQXVCbEMsT0FBdkIsRUFBZ0NtQyxJQUFoQyxFQUFzQztBQUN4RCxNQUFJQyxHQUFHLEdBQUdELElBQUksS0FBSyxHQUFULEdBQWUsT0FBZixHQUF5QixRQUFuQztBQUFBLE1BQ0lFLE1BQU0sR0FBRyxXQUFXRCxHQUR4QjtBQUFBLE1BRUlFLE1BQU0sR0FBRyxXQUFXRixHQUZ4QjtBQUdBLFNBQU9qRyxJQUFJLENBQUNvRyxHQUFMLENBQVMsQ0FBVCxFQUFZVCxPQUFPLENBQUM5QixPQUFELENBQVAsR0FBbUI3RCxJQUFJLENBQUNvRyxHQUFMLENBQVNoSSxXQUFXLENBQUM4SCxNQUFELENBQXBCLEVBQThCN0gsS0FBSyxDQUFDNkgsTUFBRCxDQUFuQyxLQUFnRGhJLElBQUksQ0FBQyxVQUFVK0gsR0FBWCxDQUFKLElBQXVCN0gsV0FBVyxDQUFDK0gsTUFBRCxDQUFsQyxJQUE4QzlILEtBQUssQ0FBQzhILE1BQUQsQ0FBbkcsQ0FBbkIsR0FBa0l0QyxPQUFPLENBQUNxQyxNQUFELENBQVAsR0FBa0JyQyxPQUFPLENBQUNzQyxNQUFELENBQXZLLENBQVA7QUFDRCxDQTFNRDtBQUFBLElBMk1JRSxpQkFBaUIsR0FBRyxTQUFTQSxpQkFBVCxDQUEyQjdGLENBQTNCLEVBQThCOEYsV0FBOUIsRUFBMkM7QUFDakU7QUFDQSxNQUFJQyxDQUFDLEdBQUdSLGFBQWEsQ0FBQ3ZGLENBQUQsRUFBSSxHQUFKLENBQXJCO0FBQUEsTUFDSWdHLENBQUMsR0FBR1QsYUFBYSxDQUFDdkYsQ0FBRCxFQUFJLEdBQUosQ0FEckI7O0FBR0EsTUFBSW1GLE9BQU8sQ0FBQ25GLENBQUQsQ0FBWCxFQUFnQjtBQUNkQSxJQUFBQSxDQUFDLEdBQUdtQixZQUFKO0FBQ0QsR0FGRCxNQUVPO0FBQ0wwRSxJQUFBQSxpQkFBaUIsQ0FBQzdGLENBQUMsQ0FBQ29GLFVBQUgsRUFBZVUsV0FBZixDQUFqQjtBQUNEOztBQUVEOUYsRUFBQUEsQ0FBQyxDQUFDaUcsYUFBRixHQUFrQkYsQ0FBbEI7QUFDQS9GLEVBQUFBLENBQUMsQ0FBQ2tHLGFBQUYsR0FBa0JGLENBQWxCOztBQUVBLE1BQUksQ0FBQ0YsV0FBTCxFQUFrQjtBQUNoQjlGLElBQUFBLENBQUMsQ0FBQ21HLFVBQUYsR0FBZW5HLENBQUMsQ0FBQ2dGLFVBQUYsSUFBZ0IsQ0FBL0I7QUFDQWhGLElBQUFBLENBQUMsQ0FBQ29HLFVBQUYsR0FBZXBHLENBQUMsQ0FBQzJFLFNBQUYsSUFBZSxDQUE5QjtBQUNEO0FBQ0YsQ0E3TkQ7QUFBQSxJQThOSTBCLFNBQVMsR0FBRyxTQUFTQSxTQUFULENBQW1CaEQsT0FBbkIsRUFBNEJpRCxRQUE1QixFQUFzQ3JILEtBQXRDLEVBQTZDO0FBQzNELE1BQUltQixLQUFLLEdBQUdpRCxPQUFPLENBQUNqRCxLQUFwQjs7QUFFQSxNQUFJLENBQUNBLEtBQUwsRUFBWTtBQUNWO0FBQ0Q7O0FBRUQsTUFBSWpCLFlBQVksQ0FBQ2lCLEtBQUssQ0FBQ2tHLFFBQUQsQ0FBTixDQUFoQixFQUFtQztBQUNqQ0EsSUFBQUEsUUFBUSxHQUFHckksWUFBWSxDQUFDcUksUUFBRCxFQUFXakQsT0FBWCxDQUFaLElBQW1DaUQsUUFBOUM7QUFDRDs7QUFFRCxNQUFJckgsS0FBSyxJQUFJLElBQWIsRUFBbUI7QUFDakJtQixJQUFBQSxLQUFLLENBQUM2QixjQUFOLElBQXdCN0IsS0FBSyxDQUFDNkIsY0FBTixDQUFxQnFFLFFBQVEsQ0FBQ3BHLE9BQVQsQ0FBaUIsVUFBakIsRUFBNkIsS0FBN0IsRUFBb0NxRyxXQUFwQyxFQUFyQixDQUF4QjtBQUNELEdBRkQsTUFFTztBQUNMbkcsSUFBQUEsS0FBSyxDQUFDa0csUUFBRCxDQUFMLEdBQWtCckgsS0FBbEI7QUFDRDtBQUNGLENBOU9EO0FBQUEsSUErT0l1SCxpQkFBaUIsR0FBRyxTQUFTQSxpQkFBVCxDQUEyQm5ELE9BQTNCLEVBQW9DO0FBQzFELFNBQU8zRixJQUFJLENBQUMrSSxnQkFBTCxDQUFzQnBELE9BQU8sWUFBWXFELE9BQW5CLEdBQTZCckQsT0FBN0IsR0FBdUNBLE9BQU8sQ0FBQ3NELElBQVIsSUFBZ0IsQ0FBQ3RELE9BQU8sQ0FBQytCLFVBQVIsSUFBc0IsRUFBdkIsRUFBMkJ1QixJQUEzQyxJQUFtRHRELE9BQWhILENBQVA7QUFDRCxDQWpQRDtBQUFBLElBa1BJO0FBQ0p1RCxTQUFTLEdBQUcsRUFuUFo7QUFBQSxJQW9QSTtBQUNKQyxVQUFVLEdBQUcsU0FBU0EsVUFBVCxDQUFvQjdHLENBQXBCLEVBQXVCO0FBQ2xDO0FBQ0EsTUFBSUEsQ0FBQyxLQUFLdEMsSUFBVixFQUFnQjtBQUNka0osSUFBQUEsU0FBUyxDQUFDRSxJQUFWLEdBQWlCRixTQUFTLENBQUNHLEdBQVYsR0FBZ0IsQ0FBakM7QUFDQUgsSUFBQUEsU0FBUyxDQUFDSSxLQUFWLEdBQWtCSixTQUFTLENBQUNLLEtBQVYsR0FBa0JySixXQUFXLENBQUNzSixXQUFaLElBQTJCbEgsQ0FBQyxDQUFDbUgsVUFBN0IsSUFBMkN0SixLQUFLLENBQUNxSixXQUFqRCxJQUFnRSxDQUFwRztBQUNBTixJQUFBQSxTQUFTLENBQUNRLE1BQVYsR0FBbUJSLFNBQVMsQ0FBQ1MsTUFBVixHQUFtQixDQUFDckgsQ0FBQyxDQUFDc0gsV0FBRixJQUFpQixDQUFsQixJQUF1QixFQUF2QixHQUE0QjFKLFdBQVcsQ0FBQzJKLFlBQXhDLEdBQXVEM0osV0FBVyxDQUFDMkosWUFBbkUsR0FBa0Z2SCxDQUFDLENBQUNzSCxXQUFGLElBQWlCekosS0FBSyxDQUFDMEosWUFBdkIsSUFBdUMsQ0FBL0o7QUFDQSxXQUFPWCxTQUFQO0FBQ0Q7O0FBRUQsTUFBSW5DLEdBQUcsR0FBR3pFLENBQUMsQ0FBQ3dILGFBQUYsSUFBbUI3SixJQUE3QjtBQUFBLE1BQ0k4SixDQUFDLEdBQUcsQ0FBQ3RJLFlBQVksQ0FBQ2EsQ0FBQyxDQUFDMEgsS0FBSCxDQUFiLEdBQXlCO0FBQy9CWixJQUFBQSxJQUFJLEVBQUU5RyxDQUFDLENBQUMwSCxLQUFGLEdBQVU1QyxpQkFBaUIsQ0FBQ0wsR0FBRCxDQURGO0FBRS9Cc0MsSUFBQUEsR0FBRyxFQUFFL0csQ0FBQyxDQUFDMkgsS0FBRixHQUFVbkQsZ0JBQWdCLENBQUNDLEdBQUQsQ0FGQTtBQUcvQndDLElBQUFBLEtBQUssRUFBRWpILENBQUMsQ0FBQzBILEtBQUYsR0FBVTVDLGlCQUFpQixDQUFDTCxHQUFELENBQTNCLEdBQW1DLENBSFg7QUFJL0I0QyxJQUFBQSxNQUFNLEVBQUVySCxDQUFDLENBQUMySCxLQUFGLEdBQVVuRCxnQkFBZ0IsQ0FBQ0MsR0FBRCxDQUExQixHQUFrQztBQUpYLEdBQXpCLEdBS0osQ0FBQ3pFLENBQUMsQ0FBQ3NGLFFBQUgsSUFBZSxDQUFDbkcsWUFBWSxDQUFDYSxDQUFDLENBQUM4RyxJQUFILENBQTVCLElBQXdDLENBQUMzSCxZQUFZLENBQUNhLENBQUMsQ0FBQytHLEdBQUgsQ0FBckQsR0FBK0QvRyxDQUEvRCxHQUFtRTlCLFFBQVEsQ0FBQzhCLENBQUQsQ0FBUixDQUFZLENBQVosRUFBZTRILHFCQUFmLEVBTnZFOztBQVFBLE1BQUl6SSxZQUFZLENBQUNzSSxDQUFDLENBQUNSLEtBQUgsQ0FBWixJQUF5QixDQUFDOUgsWUFBWSxDQUFDc0ksQ0FBQyxDQUFDVCxLQUFILENBQTFDLEVBQXFEO0FBQ25EUyxJQUFBQSxDQUFDLENBQUNSLEtBQUYsR0FBVVEsQ0FBQyxDQUFDWCxJQUFGLEdBQVNXLENBQUMsQ0FBQ1QsS0FBckI7QUFDQVMsSUFBQUEsQ0FBQyxDQUFDSixNQUFGLEdBQVdJLENBQUMsQ0FBQ1YsR0FBRixHQUFRVSxDQUFDLENBQUNMLE1BQXJCO0FBQ0QsR0FIRCxNQUdPLElBQUlqSSxZQUFZLENBQUNzSSxDQUFDLENBQUNULEtBQUgsQ0FBaEIsRUFBMkI7QUFDaEM7QUFDQVMsSUFBQUEsQ0FBQyxHQUFHO0FBQ0ZULE1BQUFBLEtBQUssRUFBRVMsQ0FBQyxDQUFDUixLQUFGLEdBQVVRLENBQUMsQ0FBQ1gsSUFEakI7QUFFRk0sTUFBQUEsTUFBTSxFQUFFSyxDQUFDLENBQUNKLE1BQUYsR0FBV0ksQ0FBQyxDQUFDVixHQUZuQjtBQUdGRSxNQUFBQSxLQUFLLEVBQUVRLENBQUMsQ0FBQ1IsS0FIUDtBQUlGSCxNQUFBQSxJQUFJLEVBQUVXLENBQUMsQ0FBQ1gsSUFKTjtBQUtGTyxNQUFBQSxNQUFNLEVBQUVJLENBQUMsQ0FBQ0osTUFMUjtBQU1GTixNQUFBQSxHQUFHLEVBQUVVLENBQUMsQ0FBQ1Y7QUFOTCxLQUFKO0FBUUQ7O0FBRUQsU0FBT1UsQ0FBUDtBQUNELENBdFJEO0FBQUEsSUF1UklJLGNBQWMsR0FBRyxTQUFTQSxjQUFULENBQXdCdkQsTUFBeEIsRUFBZ0N4RSxJQUFoQyxFQUFzQ2dJLFlBQXRDLEVBQW9EO0FBQ3ZFLE1BQUlDLElBQUksR0FBR3pELE1BQU0sQ0FBQ3lELElBQWxCO0FBQUEsTUFDSTdDLFFBQVEsR0FBRzZDLElBQUksQ0FBQ0QsWUFBRCxDQURuQjtBQUFBLE1BRUlFLFNBQVMsR0FBRzFELE1BQU0sQ0FBQzJELFVBQVAsQ0FBa0JuSSxJQUFsQixDQUZoQjtBQUFBLE1BR0lvSSxNQUhKOztBQUtBLE1BQUlsSixXQUFXLENBQUNrRyxRQUFELENBQWYsRUFBMkI7QUFDekJnRCxJQUFBQSxNQUFNLEdBQUdoRCxRQUFRLENBQUNpRCxLQUFULENBQWVKLElBQUksQ0FBQ0ssYUFBTCxJQUFzQjlELE1BQXJDLEVBQTZDeUQsSUFBSSxDQUFDRCxZQUFZLEdBQUcsUUFBaEIsQ0FBSixJQUFpQyxDQUFDeEQsTUFBTSxDQUFDK0QsWUFBUixDQUE5RSxDQUFUO0FBQ0Q7O0FBRUQsTUFBSUwsU0FBUyxJQUFJMUQsTUFBTSxDQUFDZ0UsYUFBUCxDQUFxQnhJLElBQXJCLE1BQStCLEtBQWhELEVBQXVEO0FBQ3JEb0ksSUFBQUEsTUFBTSxHQUFHLEtBQVQ7QUFDRDs7QUFFRCxTQUFPQSxNQUFQO0FBQ0QsQ0F0U0Q7QUFBQSxJQXVTSUssVUFBVSxHQUFHLFNBQVNBLFVBQVQsQ0FBb0JqRSxNQUFwQixFQUE0QmtFLE9BQTVCLEVBQXFDO0FBQ3BEO0FBQ0EsTUFBSXhJLENBQUMsR0FBRzlCLFFBQVEsQ0FBQ29HLE1BQUQsQ0FBUixDQUFpQixDQUFqQixDQUFSO0FBQUEsTUFDSXlDLEdBREo7QUFBQSxNQUVJRCxJQUZKO0FBQUEsTUFHSTJCLE1BSEo7O0FBS0EsTUFBSSxDQUFDekksQ0FBQyxDQUFDc0YsUUFBSCxJQUFldEYsQ0FBQyxLQUFLdEMsSUFBekIsRUFBK0I7QUFDN0IsUUFBSSxDQUFDeUIsWUFBWSxDQUFDbUYsTUFBTSxDQUFDd0MsSUFBUixDQUFqQixFQUFnQztBQUM5QjJCLE1BQUFBLE1BQU0sR0FBRztBQUNQMUMsUUFBQUEsQ0FBQyxFQUFFLENBREk7QUFFUEMsUUFBQUEsQ0FBQyxFQUFFO0FBRkksT0FBVCxDQUQ4QixDQUkzQjs7QUFFSCxhQUFPO0FBQ0xjLFFBQUFBLElBQUksRUFBRXhDLE1BQU0sQ0FBQ3dDLElBQVAsR0FBYzJCLE1BQU0sQ0FBQzFDLENBRHRCO0FBRUxnQixRQUFBQSxHQUFHLEVBQUV6QyxNQUFNLENBQUN5QyxHQUFQLEdBQWEwQixNQUFNLENBQUN6QyxDQUZwQjtBQUdMZ0IsUUFBQUEsS0FBSyxFQUFFMUMsTUFBTSxDQUFDMEMsS0FIVDtBQUlMSSxRQUFBQSxNQUFNLEVBQUU5QyxNQUFNLENBQUM4QztBQUpWLE9BQVA7QUFNRDs7QUFFRE4sSUFBQUEsSUFBSSxHQUFHeEMsTUFBTSxDQUFDb0UsR0FBUCxJQUFjcEUsTUFBTSxDQUFDcUUsSUFBckIsSUFBNkJyRSxNQUFNLENBQUNzRSxXQUFwQyxJQUFtRCxDQUExRDtBQUNBN0IsSUFBQUEsR0FBRyxHQUFHekMsTUFBTSxDQUFDb0UsR0FBUCxJQUFjcEUsTUFBTSxDQUFDdUUsSUFBckIsSUFBNkIsQ0FBbkM7QUFDQSxXQUFPO0FBQ0wvQixNQUFBQSxJQUFJLEVBQUVBLElBREQ7QUFFTEMsTUFBQUEsR0FBRyxFQUFFQSxHQUZBO0FBR0xDLE1BQUFBLEtBQUssRUFBRSxDQUFDMUMsTUFBTSxDQUFDc0IsR0FBUCxJQUFjdEIsTUFBTSxDQUFDd0UsSUFBckIsSUFBNkJ4RSxNQUFNLENBQUN5RSxXQUFwQyxJQUFtRCxDQUFwRCxJQUF5RGpDLElBSDNEO0FBSUxNLE1BQUFBLE1BQU0sRUFBRSxDQUFDOUMsTUFBTSxDQUFDc0IsR0FBUCxJQUFjdEIsTUFBTSxDQUFDMEUsSUFBckIsSUFBNkIsQ0FBOUIsSUFBbUNqQztBQUp0QyxLQUFQO0FBTUQ7O0FBRUQsU0FBT2tDLGlCQUFpQixDQUFDakosQ0FBRCxFQUFJd0ksT0FBSixDQUF4QjtBQUNELENBeFVEO0FBQUEsSUF5VUlVLE9BQU8sR0FBRyxFQXpVZDtBQUFBLElBMFVJO0FBQ0pELGlCQUFpQixHQUFHLFNBQVNBLGlCQUFULENBQTJCNUYsT0FBM0IsRUFBb0NtRixPQUFwQyxFQUE2QztBQUMvREEsRUFBQUEsT0FBTyxHQUFHdEssUUFBUSxDQUFDc0ssT0FBRCxDQUFSLENBQWtCLENBQWxCLENBQVY7QUFDQSxNQUFJVyxLQUFLLEdBQUc5RixPQUFPLENBQUMrRixPQUFSLElBQW1CL0YsT0FBTyxDQUFDZ0csZUFBdkM7QUFBQSxNQUNJNUUsR0FBRyxHQUFHcEIsT0FBTyxDQUFDbUUsYUFBUixJQUF5QjdKLElBRG5DO0FBQUEsTUFFSW1KLElBRko7QUFBQSxNQUdJRyxLQUhKO0FBQUEsTUFJSUYsR0FKSjtBQUFBLE1BS0lNLE1BTEo7QUFBQSxNQU1JaUMsTUFOSjtBQUFBLE1BT0lDLEVBUEo7QUFBQSxNQVFJQyxFQVJKO0FBQUEsTUFTSUMsRUFUSjtBQUFBLE1BVUlDLEVBVko7QUFBQSxNQVdJQyxJQVhKO0FBQUEsTUFZSTNDLEtBWko7QUFBQSxNQWFJSSxNQWJKO0FBQUEsTUFjSXdDLEVBZEo7QUFBQSxNQWVJQyxhQWZKOztBQWlCQSxNQUFJeEcsT0FBTyxLQUFLM0YsSUFBaEIsRUFBc0I7QUFDcEJxSixJQUFBQSxHQUFHLEdBQUd2QyxnQkFBZ0IsQ0FBQ0MsR0FBRCxDQUF0QjtBQUNBcUMsSUFBQUEsSUFBSSxHQUFHaEMsaUJBQWlCLENBQUNMLEdBQUQsQ0FBeEI7QUFDQXdDLElBQUFBLEtBQUssR0FBR0gsSUFBSSxJQUFJckMsR0FBRyxDQUFDRyxlQUFKLENBQW9Cc0MsV0FBcEIsSUFBbUM3RCxPQUFPLENBQUM4RCxVQUEzQyxJQUF5RDFDLEdBQUcsQ0FBQ0ksSUFBSixDQUFTcUMsV0FBbEUsSUFBaUYsQ0FBckYsQ0FBWjtBQUNBRyxJQUFBQSxNQUFNLEdBQUdOLEdBQUcsSUFBSSxDQUFDMUQsT0FBTyxDQUFDaUUsV0FBUixJQUF1QixDQUF4QixJQUE2QixFQUE3QixHQUFrQzdDLEdBQUcsQ0FBQ0csZUFBSixDQUFvQjJDLFlBQXRELEdBQXFFOUMsR0FBRyxDQUFDRyxlQUFKLENBQW9CMkMsWUFBekYsR0FBd0dsRSxPQUFPLENBQUNpRSxXQUFSLElBQXVCN0MsR0FBRyxDQUFDSSxJQUFKLENBQVMwQyxZQUFoQyxJQUFnRCxDQUE1SixDQUFaLENBSm9CLENBSXdKO0FBQzdLLEdBTEQsTUFLTyxJQUFJaUIsT0FBTyxLQUFLOUssSUFBWixJQUFvQnlCLFlBQVksQ0FBQ3FKLE9BQUQsQ0FBcEMsRUFBK0M7QUFDcEQsV0FBT25GLE9BQU8sQ0FBQ3VFLHFCQUFSLEVBQVA7QUFDRCxHQUZNLE1BRUE7QUFDTGQsSUFBQUEsSUFBSSxHQUFHQyxHQUFHLEdBQUcsQ0FBYjs7QUFFQSxRQUFJb0MsS0FBSixFQUFXO0FBQ1RRLE1BQUFBLElBQUksR0FBR3RHLE9BQU8sQ0FBQytGLE9BQVIsRUFBUDtBQUNBcEMsTUFBQUEsS0FBSyxHQUFHMkMsSUFBSSxDQUFDM0MsS0FBYjtBQUNBSSxNQUFBQSxNQUFNLEdBQUd1QyxJQUFJLENBQUN2QyxNQUFkO0FBQ0QsS0FKRCxNQUlPO0FBQ0wsVUFBSS9ELE9BQU8sQ0FBQ3lHLE9BQVIsS0FBb0JILElBQUksR0FBR3RHLE9BQU8sQ0FBQ3lHLE9BQVIsQ0FBZ0JDLE9BQTNDLENBQUosRUFBeUQ7QUFDdkRqRCxRQUFBQSxJQUFJLEdBQUc2QyxJQUFJLENBQUM1RCxDQUFMLElBQVUsQ0FBakI7QUFDQWdCLFFBQUFBLEdBQUcsR0FBRzRDLElBQUksQ0FBQzNELENBQUwsSUFBVSxDQUFoQjtBQUNBZ0IsUUFBQUEsS0FBSyxHQUFHMkMsSUFBSSxDQUFDM0MsS0FBYjtBQUNBSSxRQUFBQSxNQUFNLEdBQUd1QyxJQUFJLENBQUN2QyxNQUFkO0FBQ0Q7O0FBRUQsVUFBSSxDQUFDSixLQUFMLEVBQVk7QUFDVjRDLFFBQUFBLEVBQUUsR0FBR3BELGlCQUFpQixDQUFDbkQsT0FBRCxDQUF0QjtBQUNBc0csUUFBQUEsSUFBSSxHQUFHQyxFQUFFLENBQUNJLFNBQUgsS0FBaUIsWUFBeEI7QUFDQWhELFFBQUFBLEtBQUssR0FBRyxDQUFDaUQsVUFBVSxDQUFDTCxFQUFFLENBQUM1QyxLQUFKLENBQVYsSUFBd0IzRCxPQUFPLENBQUM2RCxXQUFoQyxJQUErQyxDQUFoRCxLQUFzRHlDLElBQUksR0FBRyxDQUFILEdBQU9NLFVBQVUsQ0FBQ0wsRUFBRSxDQUFDTSxlQUFKLENBQVYsR0FBaUNELFVBQVUsQ0FBQ0wsRUFBRSxDQUFDTyxnQkFBSixDQUE1RyxDQUFSO0FBQ0EvQyxRQUFBQSxNQUFNLEdBQUcsQ0FBQzZDLFVBQVUsQ0FBQ0wsRUFBRSxDQUFDeEMsTUFBSixDQUFWLElBQXlCL0QsT0FBTyxDQUFDa0UsWUFBakMsSUFBaUQsQ0FBbEQsS0FBd0RvQyxJQUFJLEdBQUcsQ0FBSCxHQUFPTSxVQUFVLENBQUNMLEVBQUUsQ0FBQ1EsY0FBSixDQUFWLEdBQWdDSCxVQUFVLENBQUNMLEVBQUUsQ0FBQ1MsaUJBQUosQ0FBN0csQ0FBVDtBQUNEO0FBQ0Y7O0FBRURwRCxJQUFBQSxLQUFLLEdBQUdELEtBQVI7QUFDQUssSUFBQUEsTUFBTSxHQUFHRCxNQUFUO0FBQ0Q7O0FBRUQsTUFBSS9ELE9BQU8sS0FBS21GLE9BQWhCLEVBQXlCO0FBQ3ZCLFdBQU87QUFDTDFCLE1BQUFBLElBQUksRUFBRUEsSUFERDtBQUVMQyxNQUFBQSxHQUFHLEVBQUVBLEdBRkE7QUFHTEMsTUFBQUEsS0FBSyxFQUFFQyxLQUFLLEdBQUdILElBSFY7QUFJTE0sTUFBQUEsTUFBTSxFQUFFQyxNQUFNLEdBQUdOO0FBSlosS0FBUDtBQU1EOztBQUVEdUMsRUFBQUEsTUFBTSxHQUFHL0wsMkVBQWUsQ0FBQ2lMLE9BQUQsRUFBVSxJQUFWLENBQWYsQ0FBK0I4QixRQUEvQixDQUF3Qy9NLDJFQUFlLENBQUM4RixPQUFELENBQXZELENBQVQ7QUFDQWtHLEVBQUFBLEVBQUUsR0FBR0QsTUFBTSxDQUFDbkIsS0FBUCxDQUFhO0FBQ2hCcEMsSUFBQUEsQ0FBQyxFQUFFZSxJQURhO0FBRWhCZCxJQUFBQSxDQUFDLEVBQUVlO0FBRmEsR0FBYixDQUFMO0FBSUF5QyxFQUFBQSxFQUFFLEdBQUdGLE1BQU0sQ0FBQ25CLEtBQVAsQ0FBYTtBQUNoQnBDLElBQUFBLENBQUMsRUFBRWtCLEtBRGE7QUFFaEJqQixJQUFBQSxDQUFDLEVBQUVlO0FBRmEsR0FBYixDQUFMO0FBSUEwQyxFQUFBQSxFQUFFLEdBQUdILE1BQU0sQ0FBQ25CLEtBQVAsQ0FBYTtBQUNoQnBDLElBQUFBLENBQUMsRUFBRWtCLEtBRGE7QUFFaEJqQixJQUFBQSxDQUFDLEVBQUVxQjtBQUZhLEdBQWIsQ0FBTDtBQUlBcUMsRUFBQUEsRUFBRSxHQUFHSixNQUFNLENBQUNuQixLQUFQLENBQWE7QUFDaEJwQyxJQUFBQSxDQUFDLEVBQUVlLElBRGE7QUFFaEJkLElBQUFBLENBQUMsRUFBRXFCO0FBRmEsR0FBYixDQUFMO0FBSUFQLEVBQUFBLElBQUksR0FBR3RILElBQUksQ0FBQ2tKLEdBQUwsQ0FBU2EsRUFBRSxDQUFDeEQsQ0FBWixFQUFleUQsRUFBRSxDQUFDekQsQ0FBbEIsRUFBcUIwRCxFQUFFLENBQUMxRCxDQUF4QixFQUEyQjJELEVBQUUsQ0FBQzNELENBQTlCLENBQVA7QUFDQWdCLEVBQUFBLEdBQUcsR0FBR3ZILElBQUksQ0FBQ2tKLEdBQUwsQ0FBU2EsRUFBRSxDQUFDdkQsQ0FBWixFQUFld0QsRUFBRSxDQUFDeEQsQ0FBbEIsRUFBcUJ5RCxFQUFFLENBQUN6RCxDQUF4QixFQUEyQjBELEVBQUUsQ0FBQzFELENBQTlCLENBQU47QUFDQTZELEVBQUFBLGFBQWEsR0FBR3JCLE9BQU8sQ0FBQ3BELFVBQVIsSUFBc0IsRUFBdEM7QUFDQSxTQUFPO0FBQ0wwQixJQUFBQSxJQUFJLEVBQUVBLElBQUksSUFBSStDLGFBQWEsQ0FBQzdFLFVBQWQsSUFBNEIsQ0FBaEMsQ0FETDtBQUVMK0IsSUFBQUEsR0FBRyxFQUFFQSxHQUFHLElBQUk4QyxhQUFhLENBQUNsRixTQUFkLElBQTJCLENBQS9CLENBRkg7QUFHTHFDLElBQUFBLEtBQUssRUFBRXhILElBQUksQ0FBQ29HLEdBQUwsQ0FBUzJELEVBQUUsQ0FBQ3hELENBQVosRUFBZXlELEVBQUUsQ0FBQ3pELENBQWxCLEVBQXFCMEQsRUFBRSxDQUFDMUQsQ0FBeEIsRUFBMkIyRCxFQUFFLENBQUMzRCxDQUE5QixJQUFtQ2UsSUFIckM7QUFJTE0sSUFBQUEsTUFBTSxFQUFFNUgsSUFBSSxDQUFDb0csR0FBTCxDQUFTMkQsRUFBRSxDQUFDdkQsQ0FBWixFQUFld0QsRUFBRSxDQUFDeEQsQ0FBbEIsRUFBcUJ5RCxFQUFFLENBQUN6RCxDQUF4QixFQUEyQjBELEVBQUUsQ0FBQzFELENBQTlCLElBQW1DZTtBQUp0QyxHQUFQO0FBTUQsQ0FuYUQ7QUFBQSxJQW9hSXdELGFBQWEsR0FBRyxTQUFTQSxhQUFULENBQXVCQyxTQUF2QixFQUFrQ0MsSUFBbEMsRUFBd0M3RSxHQUF4QyxFQUE2QzhDLEdBQTdDLEVBQWtEcEgsTUFBbEQsRUFBMERvSixpQkFBMUQsRUFBNkU7QUFDL0YsTUFBSTNDLElBQUksR0FBRyxFQUFYO0FBQUEsTUFDSTRDLENBREo7QUFBQSxNQUVJOUksQ0FGSjtBQUFBLE1BR0krSSxDQUhKOztBQUtBLE1BQUlILElBQUosRUFBVTtBQUNSLFFBQUluSixNQUFNLEtBQUssQ0FBWCxJQUFnQm1KLElBQUksWUFBWTlLLEtBQXBDLEVBQTJDO0FBQ3pDO0FBQ0FvSSxNQUFBQSxJQUFJLENBQUM4QyxHQUFMLEdBQVdGLENBQUMsR0FBRyxFQUFmO0FBQ0FDLE1BQUFBLENBQUMsR0FBR0gsSUFBSSxDQUFDM0ksTUFBVDs7QUFFQSxVQUFJNUMsU0FBUyxDQUFDdUwsSUFBSSxDQUFDLENBQUQsQ0FBTCxDQUFiLEVBQXdCO0FBQ3RCO0FBQ0EsYUFBSzVJLENBQUMsR0FBRyxDQUFULEVBQVlBLENBQUMsR0FBRytJLENBQWhCLEVBQW1CL0ksQ0FBQyxFQUFwQixFQUF3QjtBQUN0QjhJLFVBQUFBLENBQUMsQ0FBQzlJLENBQUQsQ0FBRCxHQUFPVCxLQUFLLENBQUNxSixJQUFJLENBQUM1SSxDQUFELENBQUwsRUFBVVAsTUFBVixDQUFaO0FBQ0Q7QUFDRixPQUxELE1BS087QUFDTCxhQUFLTyxDQUFDLEdBQUcsQ0FBVCxFQUFZQSxDQUFDLEdBQUcrSSxDQUFoQixFQUFtQi9JLENBQUMsRUFBcEIsRUFBd0I7QUFDdEI4SSxVQUFBQSxDQUFDLENBQUM5SSxDQUFELENBQUQsR0FBTzRJLElBQUksQ0FBQzVJLENBQUQsQ0FBSixHQUFVUCxNQUFqQjtBQUNEO0FBQ0Y7O0FBRURzRSxNQUFBQSxHQUFHLElBQUksR0FBUCxDQWhCeUMsQ0FnQjdCOztBQUVaOEMsTUFBQUEsR0FBRyxJQUFJLEdBQVA7QUFDRCxLQW5CRCxNQW1CTyxJQUFJMUosV0FBVyxDQUFDeUwsSUFBRCxDQUFmLEVBQXVCO0FBQzVCMUMsTUFBQUEsSUFBSSxDQUFDOEMsR0FBTCxHQUFXLFVBQVU1TCxLQUFWLEVBQWlCO0FBQzFCLFlBQUlpSixNQUFNLEdBQUd1QyxJQUFJLENBQUNLLElBQUwsQ0FBVU4sU0FBVixFQUFxQnZMLEtBQXJCLENBQWI7QUFBQSxZQUNJc0MsSUFESjtBQUFBLFlBRUlDLENBRko7O0FBSUEsWUFBSUYsTUFBTSxLQUFLLENBQWYsRUFBa0I7QUFDaEIsY0FBSXBDLFNBQVMsQ0FBQ2dKLE1BQUQsQ0FBYixFQUF1QjtBQUNyQjNHLFlBQUFBLElBQUksR0FBRyxFQUFQOztBQUVBLGlCQUFLQyxDQUFMLElBQVUwRyxNQUFWLEVBQWtCO0FBQ2hCM0csY0FBQUEsSUFBSSxDQUFDQyxDQUFELENBQUosR0FBVTBHLE1BQU0sQ0FBQzFHLENBQUQsQ0FBTixHQUFZRixNQUF0QjtBQUNEOztBQUVENEcsWUFBQUEsTUFBTSxHQUFHM0csSUFBVDtBQUNELFdBUkQsTUFRTztBQUNMMkcsWUFBQUEsTUFBTSxJQUFJNUcsTUFBVjtBQUNEO0FBQ0Y7O0FBRUQsZUFBTzRHLE1BQVAsQ0FuQjBCLENBbUJYO0FBQ2hCLE9BcEJEO0FBcUJELEtBdEJNLE1Bc0JBO0FBQ0xILE1BQUFBLElBQUksQ0FBQzhDLEdBQUwsR0FBV0osSUFBWDtBQUNEO0FBQ0Y7O0FBRUQsTUFBSTdFLEdBQUcsSUFBSUEsR0FBRyxLQUFLLENBQW5CLEVBQXNCO0FBQ3BCbUMsSUFBQUEsSUFBSSxDQUFDbkMsR0FBTCxHQUFXQSxHQUFYO0FBQ0Q7O0FBRUQsTUFBSThDLEdBQUcsSUFBSUEsR0FBRyxLQUFLLENBQW5CLEVBQXNCO0FBQ3BCWCxJQUFBQSxJQUFJLENBQUNXLEdBQUwsR0FBV0EsR0FBWDtBQUNEOztBQUVELE1BQUlnQyxpQkFBSixFQUF1QjtBQUNyQjNDLElBQUFBLElBQUksQ0FBQ2dELFFBQUwsR0FBZ0IsQ0FBaEI7QUFDRDs7QUFFRCxTQUFPaEQsSUFBUDtBQUNELENBdGVEO0FBQUEsSUF1ZUlpRCxZQUFZLEdBQUcsU0FBU0EsWUFBVCxDQUFzQjNILE9BQXRCLEVBQStCO0FBQ2hEO0FBQ0EsTUFBSUgsSUFBSjtBQUNBLFNBQU8sQ0FBQ0csT0FBRCxJQUFZLENBQUNBLE9BQU8sQ0FBQzRILFlBQXJCLElBQXFDNUgsT0FBTyxLQUFLeEYsS0FBakQsR0FBeUQsS0FBekQsR0FBaUUsQ0FBQ3FGLElBQUksR0FBR0csT0FBTyxDQUFDNEgsWUFBUixDQUFxQixnQkFBckIsQ0FBUixNQUFvRCxNQUFwRCxJQUE4RC9ILElBQUksS0FBSyxPQUFULEtBQXFCRyxPQUFPLENBQUM2SCxPQUFSLElBQW1CbEssZ0JBQWdCLENBQUNtSyxJQUFqQixDQUFzQjlILE9BQU8sQ0FBQytILFFBQVIsR0FBbUIsRUFBekMsQ0FBbkIsSUFBbUUvSCxPQUFPLENBQUM0SCxZQUFSLENBQXFCLGlCQUFyQixNQUE0QyxNQUFwSSxDQUE5RCxHQUE0TSxJQUE1TSxHQUFtTkQsWUFBWSxDQUFDM0gsT0FBTyxDQUFDK0IsVUFBVCxDQUF2UztBQUNELENBM2VEO0FBQUEsSUE0ZUlpRyxjQUFjLEdBQUcsU0FBU0EsY0FBVCxDQUF3QnpKLFFBQXhCLEVBQWtDMEosVUFBbEMsRUFBOEM7QUFDakUsTUFBSXpKLENBQUMsR0FBR0QsUUFBUSxDQUFDRSxNQUFqQjtBQUFBLE1BQ0k5QixDQURKOztBQUdBLFNBQU82QixDQUFDLEVBQVIsRUFBWTtBQUNWN0IsSUFBQUEsQ0FBQyxHQUFHNEIsUUFBUSxDQUFDQyxDQUFELENBQVo7QUFDQTdCLElBQUFBLENBQUMsQ0FBQ3VMLFdBQUYsR0FBZ0J2TCxDQUFDLENBQUN3TCxhQUFGLEdBQWtCRixVQUFVLEdBQUcsSUFBSCxHQUFVbE0sVUFBdEQ7QUFDQTNCLElBQUFBLElBQUksQ0FBQ2dPLEdBQUwsQ0FBU3pMLENBQVQsRUFBWTtBQUNWMEwsTUFBQUEsSUFBSSxFQUFFLElBREk7QUFFVkMsTUFBQUEsVUFBVSxFQUFFTCxVQUFVLEdBQUcsTUFBSCxHQUFZO0FBRnhCLEtBQVo7QUFJRDtBQUNGLENBeGZEO0FBQUEsSUF5ZklNLFFBQVEsR0FBRyxTQUFTQSxRQUFULENBQWtCdkksT0FBbEIsRUFBMkI7QUFDeEMsTUFBSW1ELGlCQUFpQixDQUFDbkQsT0FBRCxDQUFqQixDQUEyQndJLFFBQTNCLEtBQXdDLE9BQTVDLEVBQXFEO0FBQ25ELFdBQU8sSUFBUDtBQUNEOztBQUVEeEksRUFBQUEsT0FBTyxHQUFHQSxPQUFPLENBQUMrQixVQUFsQjs7QUFFQSxNQUFJL0IsT0FBTyxJQUFJQSxPQUFPLENBQUNpQyxRQUFSLEtBQXFCLENBQXBDLEVBQXVDO0FBQ3JDO0FBQ0EsV0FBT3NHLFFBQVEsQ0FBQ3ZJLE9BQUQsQ0FBZjtBQUNEO0FBQ0YsQ0FwZ0JEO0FBQUEsSUFxZ0JJeUksV0FyZ0JKO0FBQUEsSUFzZ0JJQyxhQXRnQko7QUFBQSxJQXVnQkk7QUFDSkMsV0FBVyxHQUFHLFNBQVNBLFdBQVQsQ0FBcUIzSSxPQUFyQixFQUE4QjBFLElBQTlCLEVBQW9DO0FBQ2hEMUUsRUFBQUEsT0FBTyxHQUFHNUYsSUFBSSxDQUFDd08sS0FBTCxDQUFXQyxPQUFYLENBQW1CN0ksT0FBbkIsRUFBNEIsQ0FBNUIsQ0FBVjtBQUNBMEUsRUFBQUEsSUFBSSxHQUFHQSxJQUFJLElBQUksRUFBZjtBQUNBLE1BQUlvRSxPQUFPLEdBQUdDLFFBQVEsQ0FBQ2pNLGFBQVQsQ0FBdUIsS0FBdkIsQ0FBZDtBQUFBLE1BQ0lDLEtBQUssR0FBRytMLE9BQU8sQ0FBQy9MLEtBRHBCO0FBQUEsTUFFSWlNLElBQUksR0FBR2hKLE9BQU8sQ0FBQ2lKLFVBRm5CO0FBQUEsTUFHSUMsU0FBUyxHQUFHLENBSGhCO0FBQUEsTUFJSUMsVUFBVSxHQUFHLENBSmpCO0FBQUEsTUFLSUMsT0FBTyxHQUFHcEosT0FBTyxDQUFDc0IsU0FMdEI7QUFBQSxNQU1JK0gsUUFBUSxHQUFHckosT0FBTyxDQUFDMkIsVUFOdkI7QUFBQSxNQU9JMkgsV0FBVyxHQUFHdEosT0FBTyxDQUFDc0osV0FQMUI7QUFBQSxNQVFJQyxZQUFZLEdBQUd2SixPQUFPLENBQUN1SixZQVIzQjtBQUFBLE1BU0lDLGFBQWEsR0FBRyxDQVRwQjtBQUFBLE1BVUlDLE9BQU8sR0FBRyxDQVZkO0FBQUEsTUFXSUMsTUFBTSxHQUFHLENBWGI7QUFBQSxNQVlJQyxZQVpKO0FBQUEsTUFhSUMsYUFiSjtBQUFBLE1BY0lDLGFBZEo7QUFBQSxNQWVJQyxRQWZKO0FBQUEsTUFnQklDLGNBaEJKO0FBQUEsTUFpQklDLFlBakJKOztBQW1CQSxNQUFJdkIsV0FBVyxJQUFJL0QsSUFBSSxDQUFDdUYsT0FBTCxLQUFpQixLQUFwQyxFQUEyQztBQUN6Q0YsSUFBQUEsY0FBYyxHQUFHLGNBQWpCO0FBQ0FDLElBQUFBLFlBQVksR0FBRyxTQUFmO0FBQ0QsR0FIRCxNQUdPLElBQUloTyxjQUFKLEVBQW9CO0FBQ3pCK04sSUFBQUEsY0FBYyxHQUFHLFlBQWpCO0FBQ0FDLElBQUFBLFlBQVksR0FBRyxLQUFmO0FBQ0Q7O0FBRUQsT0FBSzFJLFNBQUwsR0FBaUIsVUFBVTFGLEtBQVYsRUFBaUJzTyxLQUFqQixFQUF3QjtBQUN2QyxRQUFJLENBQUNDLFNBQVMsQ0FBQzFMLE1BQWYsRUFBdUI7QUFDckIsYUFBTyxDQUFDLEtBQUtpRixHQUFMLEVBQVI7QUFDRDs7QUFFRCxTQUFLQSxHQUFMLENBQVMsQ0FBQzlILEtBQVYsRUFBaUJzTyxLQUFqQjtBQUNELEdBTkQ7O0FBUUEsT0FBS3ZJLFVBQUwsR0FBa0IsVUFBVS9GLEtBQVYsRUFBaUJzTyxLQUFqQixFQUF3QjtBQUN4QyxRQUFJLENBQUNDLFNBQVMsQ0FBQzFMLE1BQWYsRUFBdUI7QUFDckIsYUFBTyxDQUFDLEtBQUtnRixJQUFMLEVBQVI7QUFDRDs7QUFFRCxTQUFLQSxJQUFMLENBQVUsQ0FBQzdILEtBQVgsRUFBa0JzTyxLQUFsQjtBQUNELEdBTkQ7O0FBUUEsT0FBS3pHLElBQUwsR0FBWSxVQUFVN0gsS0FBVixFQUFpQnNPLEtBQWpCLEVBQXdCO0FBQ2xDLFFBQUksQ0FBQ0MsU0FBUyxDQUFDMUwsTUFBZixFQUF1QjtBQUNyQixhQUFPLEVBQUV1QixPQUFPLENBQUMyQixVQUFSLEdBQXFCd0gsVUFBdkIsQ0FBUDtBQUNEOztBQUVELFFBQUlpQixHQUFHLEdBQUdwSyxPQUFPLENBQUMyQixVQUFSLEdBQXFCMEgsUUFBL0I7QUFBQSxRQUNJZ0IsU0FBUyxHQUFHbEIsVUFEaEI7O0FBR0EsUUFBSSxDQUFDaUIsR0FBRyxHQUFHLENBQU4sSUFBV0EsR0FBRyxHQUFHLENBQUMsQ0FBbkIsS0FBeUIsQ0FBQ0YsS0FBOUIsRUFBcUM7QUFDbkM7QUFDQWIsTUFBQUEsUUFBUSxHQUFHckosT0FBTyxDQUFDMkIsVUFBbkI7QUFDQXZILE1BQUFBLElBQUksQ0FBQ2tRLFlBQUwsQ0FBa0IsSUFBbEIsRUFBd0I7QUFDdEI3RyxRQUFBQSxJQUFJLEVBQUUsQ0FEZ0I7QUFFdEI5QixRQUFBQSxVQUFVLEVBQUU7QUFGVSxPQUF4QjtBQUlBLFdBQUs4QixJQUFMLENBQVUsQ0FBQzRGLFFBQVg7O0FBRUEsVUFBSTNFLElBQUksQ0FBQzZGLE1BQVQsRUFBaUI7QUFDZjdGLFFBQUFBLElBQUksQ0FBQzZGLE1BQUw7QUFDRDs7QUFFRDtBQUNEOztBQUVEM08sSUFBQUEsS0FBSyxHQUFHLENBQUNBLEtBQVQsQ0F4QmtDLENBd0JsQjs7QUFFaEIsUUFBSUEsS0FBSyxHQUFHLENBQVosRUFBZTtBQUNidU4sTUFBQUEsVUFBVSxHQUFHdk4sS0FBSyxHQUFHLEdBQVIsR0FBYyxDQUEzQjtBQUNBQSxNQUFBQSxLQUFLLEdBQUcsQ0FBUjtBQUNELEtBSEQsTUFHTyxJQUFJQSxLQUFLLEdBQUc2TixPQUFaLEVBQXFCO0FBQzFCTixNQUFBQSxVQUFVLEdBQUd2TixLQUFLLEdBQUc2TixPQUFSLEdBQWtCLENBQS9CO0FBQ0E3TixNQUFBQSxLQUFLLEdBQUc2TixPQUFSO0FBQ0QsS0FITSxNQUdBO0FBQ0xOLE1BQUFBLFVBQVUsR0FBRyxDQUFiO0FBQ0Q7O0FBRUQsUUFBSUEsVUFBVSxJQUFJa0IsU0FBbEIsRUFBNkI7QUFDM0IsVUFBSSxDQUFDLEtBQUtHLEtBQVYsRUFBaUI7QUFDZnpOLFFBQUFBLEtBQUssQ0FBQ2YsY0FBRCxDQUFMLEdBQXdCK04sY0FBYyxHQUFHLENBQUNaLFVBQWxCLEdBQStCLEtBQS9CLEdBQXVDLENBQUNELFNBQXhDLEdBQW9EYyxZQUE1RTtBQUNEOztBQUVELFVBQUliLFVBQVUsR0FBR0ssYUFBYixJQUE4QixDQUFsQyxFQUFxQztBQUNuQ3pNLFFBQUFBLEtBQUssQ0FBQzBOLFlBQU4sR0FBcUJ0QixVQUFVLEdBQUdLLGFBQWIsR0FBNkIsSUFBbEQ7QUFDRDtBQUNGOztBQUVEeEosSUFBQUEsT0FBTyxDQUFDMkIsVUFBUixHQUFxQi9GLEtBQUssR0FBRyxDQUE3QjtBQUNBeU4sSUFBQUEsUUFBUSxHQUFHckosT0FBTyxDQUFDMkIsVUFBbkIsQ0EvQ2tDLENBK0NIO0FBQ2hDLEdBaEREOztBQWtEQSxPQUFLK0IsR0FBTCxHQUFXLFVBQVU5SCxLQUFWLEVBQWlCc08sS0FBakIsRUFBd0I7QUFDakMsUUFBSSxDQUFDQyxTQUFTLENBQUMxTCxNQUFmLEVBQXVCO0FBQ3JCLGFBQU8sRUFBRXVCLE9BQU8sQ0FBQ3NCLFNBQVIsR0FBb0I0SCxTQUF0QixDQUFQO0FBQ0Q7O0FBRUQsUUFBSWtCLEdBQUcsR0FBR3BLLE9BQU8sQ0FBQ3NCLFNBQVIsR0FBb0I4SCxPQUE5QjtBQUFBLFFBQ0lpQixTQUFTLEdBQUduQixTQURoQjs7QUFHQSxRQUFJLENBQUNrQixHQUFHLEdBQUcsQ0FBTixJQUFXQSxHQUFHLEdBQUcsQ0FBQyxDQUFuQixLQUF5QixDQUFDRixLQUE5QixFQUFxQztBQUNuQztBQUNBZCxNQUFBQSxPQUFPLEdBQUdwSixPQUFPLENBQUNzQixTQUFsQjtBQUNBbEgsTUFBQUEsSUFBSSxDQUFDa1EsWUFBTCxDQUFrQixJQUFsQixFQUF3QjtBQUN0QjVHLFFBQUFBLEdBQUcsRUFBRSxDQURpQjtBQUV0QnBDLFFBQUFBLFNBQVMsRUFBRTtBQUZXLE9BQXhCO0FBSUEsV0FBS29DLEdBQUwsQ0FBUyxDQUFDMEYsT0FBVjs7QUFFQSxVQUFJMUUsSUFBSSxDQUFDNkYsTUFBVCxFQUFpQjtBQUNmN0YsUUFBQUEsSUFBSSxDQUFDNkYsTUFBTDtBQUNEOztBQUVEO0FBQ0Q7O0FBRUQzTyxJQUFBQSxLQUFLLEdBQUcsQ0FBQ0EsS0FBVCxDQXhCaUMsQ0F3QmpCOztBQUVoQixRQUFJQSxLQUFLLEdBQUcsQ0FBWixFQUFlO0FBQ2JzTixNQUFBQSxTQUFTLEdBQUd0TixLQUFLLEdBQUcsR0FBUixHQUFjLENBQTFCO0FBQ0FBLE1BQUFBLEtBQUssR0FBRyxDQUFSO0FBQ0QsS0FIRCxNQUdPLElBQUlBLEtBQUssR0FBRzhOLE1BQVosRUFBb0I7QUFDekJSLE1BQUFBLFNBQVMsR0FBR3ROLEtBQUssR0FBRzhOLE1BQVIsR0FBaUIsQ0FBN0I7QUFDQTlOLE1BQUFBLEtBQUssR0FBRzhOLE1BQVI7QUFDRCxLQUhNLE1BR0E7QUFDTFIsTUFBQUEsU0FBUyxHQUFHLENBQVo7QUFDRDs7QUFFRCxRQUFJQSxTQUFTLElBQUltQixTQUFqQixFQUE0QjtBQUMxQixVQUFJLENBQUMsS0FBS0csS0FBVixFQUFpQjtBQUNmek4sUUFBQUEsS0FBSyxDQUFDZixjQUFELENBQUwsR0FBd0IrTixjQUFjLEdBQUcsQ0FBQ1osVUFBbEIsR0FBK0IsS0FBL0IsR0FBdUMsQ0FBQ0QsU0FBeEMsR0FBb0RjLFlBQTVFO0FBQ0Q7QUFDRjs7QUFFRGhLLElBQUFBLE9BQU8sQ0FBQ3NCLFNBQVIsR0FBb0IxRixLQUFLLEdBQUcsQ0FBNUI7QUFDQXdOLElBQUFBLE9BQU8sR0FBR3BKLE9BQU8sQ0FBQ3NCLFNBQWxCO0FBQ0QsR0E1Q0Q7O0FBOENBLE9BQUtvSixZQUFMLEdBQW9CLFlBQVk7QUFDOUIsV0FBT2hCLE1BQVA7QUFDRCxHQUZEOztBQUlBLE9BQUtpQixhQUFMLEdBQXFCLFlBQVk7QUFDL0IsV0FBT2xCLE9BQVA7QUFDRCxHQUZEOztBQUlBLE9BQUttQixPQUFMLEdBQWUsWUFBWTtBQUN6QjVCLElBQUFBLElBQUksR0FBR0YsT0FBTyxDQUFDRyxVQUFmOztBQUVBLFdBQU9ELElBQVAsRUFBYTtBQUNYYyxNQUFBQSxRQUFRLEdBQUdkLElBQUksQ0FBQzZCLFdBQWhCO0FBQ0E3SyxNQUFBQSxPQUFPLENBQUM4SyxXQUFSLENBQW9COUIsSUFBcEI7QUFDQUEsTUFBQUEsSUFBSSxHQUFHYyxRQUFQO0FBQ0Q7O0FBRUQsUUFBSTlKLE9BQU8sS0FBSzhJLE9BQU8sQ0FBQy9HLFVBQXhCLEVBQW9DO0FBQ2xDO0FBQ0EvQixNQUFBQSxPQUFPLENBQUMrSyxXQUFSLENBQW9CakMsT0FBcEI7QUFDRDtBQUNGLEdBYkQ7O0FBZUEsT0FBS2tDLE1BQUwsR0FBYyxZQUFZO0FBQ3hCaEMsSUFBQUEsSUFBSSxHQUFHaEosT0FBTyxDQUFDaUosVUFBZjs7QUFFQSxRQUFJRCxJQUFJLEtBQUtGLE9BQWIsRUFBc0I7QUFDcEI7QUFDRDs7QUFFRCxXQUFPRSxJQUFQLEVBQWE7QUFDWGMsTUFBQUEsUUFBUSxHQUFHZCxJQUFJLENBQUM2QixXQUFoQjtBQUNBL0IsTUFBQUEsT0FBTyxDQUFDZ0MsV0FBUixDQUFvQjlCLElBQXBCO0FBQ0FBLE1BQUFBLElBQUksR0FBR2MsUUFBUDtBQUNEOztBQUVEOUosSUFBQUEsT0FBTyxDQUFDOEssV0FBUixDQUFvQmhDLE9BQXBCO0FBQ0EsU0FBS21DLFNBQUw7QUFDRCxHQWZEOztBQWlCQSxPQUFLQSxTQUFMLEdBQWlCLFVBQVVmLEtBQVYsRUFBaUI7QUFDaEMsUUFBSWdCLFlBQVksR0FBR2xMLE9BQU8sQ0FBQzZELFdBQVIsS0FBd0I4RixZQUEzQztBQUFBLFFBQ0lwRCxFQURKO0FBQUEsUUFFSTdELENBRko7QUFBQSxRQUdJQyxDQUhKO0FBSUF5RyxJQUFBQSxPQUFPLEdBQUdwSixPQUFPLENBQUNzQixTQUFsQjtBQUNBK0gsSUFBQUEsUUFBUSxHQUFHckosT0FBTyxDQUFDMkIsVUFBbkI7O0FBRUEsUUFBSXVKLFlBQVksSUFBSWxMLE9BQU8sQ0FBQ2tFLFlBQVIsS0FBeUIwRixhQUF6QyxJQUEwRGQsT0FBTyxDQUFDcUMsWUFBUixLQUF5QnRCLGFBQW5GLElBQW9HUCxXQUFXLEtBQUt0SixPQUFPLENBQUNzSixXQUE1SCxJQUEySUMsWUFBWSxLQUFLdkosT0FBTyxDQUFDdUosWUFBcEssSUFBb0wsQ0FBQ1csS0FBekwsRUFBZ007QUFDOUwsYUFEOEwsQ0FDdEw7QUFDVDs7QUFFRCxRQUFJaEIsU0FBUyxJQUFJQyxVQUFqQixFQUE2QjtBQUMzQnpHLE1BQUFBLENBQUMsR0FBRyxLQUFLZSxJQUFMLEVBQUo7QUFDQWQsTUFBQUEsQ0FBQyxHQUFHLEtBQUtlLEdBQUwsRUFBSjtBQUNBLFdBQUtELElBQUwsQ0FBVSxDQUFDekQsT0FBTyxDQUFDMkIsVUFBbkI7QUFDQSxXQUFLK0IsR0FBTCxDQUFTLENBQUMxRCxPQUFPLENBQUNzQixTQUFsQjtBQUNEOztBQUVEaUYsSUFBQUEsRUFBRSxHQUFHcEQsaUJBQWlCLENBQUNuRCxPQUFELENBQXRCLENBbkJnQyxDQW1CQzs7QUFFakMsUUFBSSxDQUFDa0wsWUFBRCxJQUFpQmhCLEtBQXJCLEVBQTRCO0FBQzFCbk4sTUFBQUEsS0FBSyxDQUFDcU8sT0FBTixHQUFnQixPQUFoQjtBQUNBck8sTUFBQUEsS0FBSyxDQUFDNEcsS0FBTixHQUFjLE1BQWQ7QUFDQTVHLE1BQUFBLEtBQUssQ0FBQzBOLFlBQU4sR0FBcUIsS0FBckI7QUFDQWpCLE1BQUFBLGFBQWEsR0FBR3JOLElBQUksQ0FBQ29HLEdBQUwsQ0FBUyxDQUFULEVBQVl2QyxPQUFPLENBQUNzSixXQUFSLEdBQXNCdEosT0FBTyxDQUFDNkQsV0FBMUMsQ0FBaEIsQ0FKMEIsQ0FJOEM7O0FBRXhFLFVBQUkyRixhQUFKLEVBQW1CO0FBQ2pCQSxRQUFBQSxhQUFhLElBQUk1QyxVQUFVLENBQUNMLEVBQUUsQ0FBQzhFLFdBQUosQ0FBVixJQUE4QjNDLGFBQWEsR0FBRzlCLFVBQVUsQ0FBQ0wsRUFBRSxDQUFDa0UsWUFBSixDQUFiLEdBQWlDLENBQTVFLENBQWpCO0FBQ0Q7QUFDRjs7QUFFRDFOLElBQUFBLEtBQUssQ0FBQ3FPLE9BQU4sR0FBZ0IsY0FBaEI7QUFDQXJPLElBQUFBLEtBQUssQ0FBQ3lMLFFBQU4sR0FBaUIsVUFBakI7QUFDQXpMLElBQUFBLEtBQUssQ0FBQ3VPLFFBQU4sR0FBaUIsU0FBakI7QUFDQXZPLElBQUFBLEtBQUssQ0FBQ3dPLGFBQU4sR0FBc0IsS0FBdEI7QUFDQXhPLElBQUFBLEtBQUssQ0FBQzRKLFNBQU4sR0FBa0IsYUFBbEI7QUFDQTVKLElBQUFBLEtBQUssQ0FBQzRHLEtBQU4sR0FBYyxNQUFkO0FBQ0E1RyxJQUFBQSxLQUFLLENBQUMwTixZQUFOLEdBQXFCakIsYUFBYSxHQUFHLElBQXJDLENBdENnQyxDQXNDVzs7QUFFM0MsUUFBSWQsYUFBSixFQUFtQjtBQUNqQjNMLE1BQUFBLEtBQUssQ0FBQ3lPLGFBQU4sR0FBc0JqRixFQUFFLENBQUNpRixhQUF6QjtBQUNEOztBQUVEN0IsSUFBQUEsWUFBWSxHQUFHM0osT0FBTyxDQUFDNkQsV0FBdkI7QUFDQStGLElBQUFBLGFBQWEsR0FBRzVKLE9BQU8sQ0FBQ2tFLFlBQXhCO0FBQ0FvRixJQUFBQSxXQUFXLEdBQUd0SixPQUFPLENBQUNzSixXQUF0QjtBQUNBQyxJQUFBQSxZQUFZLEdBQUd2SixPQUFPLENBQUN1SixZQUF2QjtBQUNBRSxJQUFBQSxPQUFPLEdBQUd6SixPQUFPLENBQUNzSixXQUFSLEdBQXNCSyxZQUFoQztBQUNBRCxJQUFBQSxNQUFNLEdBQUcxSixPQUFPLENBQUN1SixZQUFSLEdBQXVCSyxhQUFoQztBQUNBQyxJQUFBQSxhQUFhLEdBQUdmLE9BQU8sQ0FBQ3FDLFlBQXhCO0FBQ0FwTyxJQUFBQSxLQUFLLENBQUNxTyxPQUFOLEdBQWdCLE9BQWhCOztBQUVBLFFBQUkxSSxDQUFDLElBQUlDLENBQVQsRUFBWTtBQUNWLFdBQUtjLElBQUwsQ0FBVWYsQ0FBVjtBQUNBLFdBQUtnQixHQUFMLENBQVNmLENBQVQ7QUFDRDtBQUNGLEdBekREOztBQTJEQSxPQUFLbUcsT0FBTCxHQUFlQSxPQUFmO0FBQ0EsT0FBSzlJLE9BQUwsR0FBZUEsT0FBZjtBQUNBLE9BQUt3SyxLQUFMLEdBQWEsS0FBYjtBQUNBLE9BQUtRLE1BQUw7QUFDRCxDQTd2QkQ7QUFBQSxJQTh2QklTLFNBQVMsR0FBRyxTQUFTQSxTQUFULENBQW1CQyxRQUFuQixFQUE2QjtBQUMzQyxNQUFJblEsYUFBYSxNQUFNd04sUUFBUSxDQUFDdkgsSUFBaEMsRUFBc0M7QUFDcEMsUUFBSW1LLEdBQUcsR0FBR25RLE1BQU0sSUFBSUEsTUFBTSxDQUFDb1EsU0FBM0I7QUFDQXZSLElBQUFBLElBQUksR0FBR21CLE1BQVA7QUFDQWxCLElBQUFBLElBQUksR0FBR3lPLFFBQVA7QUFDQXhPLElBQUFBLFdBQVcsR0FBR0QsSUFBSSxDQUFDaUgsZUFBbkI7QUFDQS9HLElBQUFBLEtBQUssR0FBR0YsSUFBSSxDQUFDa0gsSUFBYjtBQUNBL0csSUFBQUEsUUFBUSxHQUFHK0IsY0FBYyxDQUFDLEtBQUQsQ0FBekI7QUFDQWxCLElBQUFBLGdCQUFnQixHQUFHLENBQUMsQ0FBQ0UsTUFBTSxDQUFDcVEsWUFBNUI7QUFDQW5SLElBQUFBLGVBQWUsR0FBRzhCLGNBQWMsQ0FBQyxLQUFELENBQWhDO0FBQ0E5QixJQUFBQSxlQUFlLENBQUNxQyxLQUFoQixDQUFzQitPLE9BQXRCLEdBQWdDLG9HQUFoQztBQUNBelEsSUFBQUEsY0FBYyxHQUFHWCxlQUFlLENBQUNxQyxLQUFoQixDQUFzQmdQLE1BQXRCLEtBQWlDLE1BQWpDLEdBQTBDLE1BQTFDLEdBQW1ELE1BQXBFO0FBQ0E1USxJQUFBQSxVQUFVLEdBQUd3USxHQUFHLElBQUlBLEdBQUcsQ0FBQ0ssU0FBSixDQUFjOUksV0FBZCxHQUE0QitJLE9BQTVCLENBQW9DLFNBQXBDLE1BQW1ELENBQUMsQ0FBeEUsQ0FYb0MsQ0FXdUM7O0FBRTNFbFIsSUFBQUEsY0FBYyxHQUFHLGtCQUFrQlIsV0FBbEIsSUFBaUMsaUJBQWlCRixJQUFsRCxJQUEwRHNSLEdBQUcsS0FBS0EsR0FBRyxDQUFDTyxjQUFKLEdBQXFCLENBQXJCLElBQTBCUCxHQUFHLENBQUNRLGdCQUFKLEdBQXVCLENBQXRELENBQTlFOztBQUVBekQsSUFBQUEsYUFBYSxHQUFHLFlBQVk7QUFDMUI7QUFDQSxVQUFJMEQsR0FBRyxHQUFHNVAsY0FBYyxDQUFDLEtBQUQsQ0FBeEI7QUFBQSxVQUNJNlAsS0FBSyxHQUFHN1AsY0FBYyxDQUFDLEtBQUQsQ0FEMUI7QUFBQSxVQUVJOFAsVUFBVSxHQUFHRCxLQUFLLENBQUN0UCxLQUZ2QjtBQUFBLFVBR0l3UCxNQUFNLEdBQUcvUixLQUhiO0FBQUEsVUFJSWdTLEdBSko7O0FBTUFGLE1BQUFBLFVBQVUsQ0FBQ2xCLE9BQVgsR0FBcUIsY0FBckI7QUFDQWtCLE1BQUFBLFVBQVUsQ0FBQzlELFFBQVgsR0FBc0IsVUFBdEI7QUFDQTRELE1BQUFBLEdBQUcsQ0FBQ3JQLEtBQUosQ0FBVStPLE9BQVYsR0FBb0JPLEtBQUssQ0FBQ0ksU0FBTixHQUFrQixxRUFBdEM7QUFDQUwsTUFBQUEsR0FBRyxDQUFDdEIsV0FBSixDQUFnQnVCLEtBQWhCO0FBQ0FFLE1BQUFBLE1BQU0sQ0FBQ3pCLFdBQVAsQ0FBbUJzQixHQUFuQjtBQUNBSSxNQUFBQSxHQUFHLEdBQUdILEtBQUssQ0FBQ2xCLFlBQU4sR0FBcUIsRUFBckIsR0FBMEJpQixHQUFHLENBQUM3QyxZQUFwQyxDQWIwQixDQWF3Qjs7QUFFbERnRCxNQUFBQSxNQUFNLENBQUN4QixXQUFQLENBQW1CcUIsR0FBbkI7QUFDQSxhQUFPSSxHQUFQO0FBQ0QsS0FqQmUsRUFBaEI7O0FBbUJBeFIsSUFBQUEsaUJBQWlCLEdBQUcsVUFBVTBSLEtBQVYsRUFBaUI7QUFDbkM7QUFDQSxVQUFJQyxRQUFRLEdBQUdELEtBQUssQ0FBQ0UsS0FBTixDQUFZLEdBQVosQ0FBZjtBQUFBLFVBQ0lDLFNBQVMsR0FBRyxDQUFDLG1CQUFtQnBTLFFBQW5CLEdBQThCLGlEQUE5QixHQUFrRixxQkFBcUJBLFFBQXJCLEdBQWdDLHlEQUFoQyxHQUE0RmlTLEtBQS9LLEVBQXNMRSxLQUF0TCxDQUE0TCxHQUE1TCxDQURoQjtBQUFBLFVBRUk1TyxHQUFHLEdBQUcsRUFGVjtBQUFBLFVBR0lRLENBQUMsR0FBRyxDQUhSOztBQUtBLGFBQU8sRUFBRUEsQ0FBRixHQUFNLENBQUMsQ0FBZCxFQUFpQjtBQUNmUixRQUFBQSxHQUFHLENBQUMyTyxRQUFRLENBQUNuTyxDQUFELENBQVQsQ0FBSCxHQUFtQnFPLFNBQVMsQ0FBQ3JPLENBQUQsQ0FBNUI7QUFDQVIsUUFBQUEsR0FBRyxDQUFDNk8sU0FBUyxDQUFDck8sQ0FBRCxDQUFWLENBQUgsR0FBb0JtTyxRQUFRLENBQUNuTyxDQUFELENBQTVCO0FBQ0QsT0FWa0MsQ0FVakM7OztBQUdGLFVBQUk7QUFDRmpFLFFBQUFBLFdBQVcsQ0FBQzJGLGdCQUFaLENBQTZCLE1BQTdCLEVBQXFDLElBQXJDLEVBQTJDcEcsTUFBTSxDQUFDZ1QsY0FBUCxDQUFzQixFQUF0QixFQUEwQixTQUExQixFQUFxQztBQUM5RUMsVUFBQUEsR0FBRyxFQUFFLFNBQVNBLEdBQVQsR0FBZTtBQUNsQmpTLFlBQUFBLGdCQUFnQixHQUFHLENBQW5CO0FBQ0Q7QUFINkUsU0FBckMsQ0FBM0M7QUFLRCxPQU5ELENBTUUsT0FBTzZCLENBQVAsRUFBVSxDQUFFOztBQUVkLGFBQU9xQixHQUFQO0FBQ0QsS0F0Qm1CLENBc0JsQiwyQ0F0QmtCLENBQXBCOztBQXdCQStCLElBQUFBLFlBQVksQ0FBQ3pGLElBQUQsRUFBTyxhQUFQLEVBQXNCeUIsVUFBdEIsQ0FBWixDQTFEb0MsQ0EwRFc7OztBQUcvQ2dFLElBQUFBLFlBQVksQ0FBQzFGLElBQUQsRUFBTyxXQUFQLEVBQW9CMEIsVUFBcEIsQ0FBWixDQTdEb0MsQ0E2RFM7OztBQUc3Q3ZCLElBQUFBLEtBQUssSUFBSUEsS0FBSyxDQUFDMEYsZ0JBQU4sQ0FBdUIsWUFBdkIsRUFBcUNuRSxVQUFyQyxDQUFULENBaEVvQyxDQWdFdUI7O0FBRTNEZ0UsSUFBQUEsWUFBWSxDQUFDekYsSUFBRCxFQUFPLGFBQVAsRUFBc0IsWUFBWTtBQUM1QyxXQUFLLElBQUk2RCxDQUFULElBQWNWLE9BQWQsRUFBdUI7QUFDckIsWUFBSUEsT0FBTyxDQUFDVSxDQUFELENBQVAsQ0FBVzZPLFNBQWYsRUFBMEI7QUFDeEJ2UCxVQUFBQSxPQUFPLENBQUNVLENBQUQsQ0FBUCxDQUFXOE8sT0FBWDtBQUNEO0FBQ0Y7QUFDRixLQU5XLENBQVo7O0FBUUE3UyxJQUFBQSxJQUFJLEdBQUdPLFlBQVksR0FBR2MsUUFBUSxFQUE5QjtBQUNEOztBQUVELE1BQUlyQixJQUFKLEVBQVU7QUFDUmdCLElBQUFBLGFBQWEsR0FBR2hCLElBQUksQ0FBQzhTLE9BQUwsQ0FBYUMsT0FBN0I7QUFDQXZTLElBQUFBLFlBQVksR0FBR1IsSUFBSSxDQUFDd08sS0FBTCxDQUFXd0UsV0FBMUI7QUFDQXBSLElBQUFBLGNBQWMsR0FBR3BCLFlBQVksQ0FBQ29CLGNBQUQsQ0FBN0I7QUFDQUMsSUFBQUEsb0JBQW9CLEdBQUdyQixZQUFZLENBQUNxQixvQkFBRCxDQUFuQztBQUNBcEIsSUFBQUEsUUFBUSxHQUFHVCxJQUFJLENBQUN3TyxLQUFMLENBQVdDLE9BQXRCO0FBQ0FKLElBQUFBLFdBQVcsR0FBRyxDQUFDLENBQUM3TixZQUFZLENBQUMsYUFBRCxDQUE1QjtBQUNELEdBUEQsTUFPTyxJQUFJOFEsUUFBSixFQUFjO0FBQ25CMkIsSUFBQUEsT0FBTyxDQUFDQyxJQUFSLENBQWEsdUNBQWI7QUFDRDtBQUNGLENBdDFCRDs7QUF3MUJBLElBQUlDLGVBQWUsR0FBRyxhQUFhLFlBQVk7QUFDN0MsV0FBU0EsZUFBVCxDQUF5QnRNLE1BQXpCLEVBQWlDO0FBQy9CLFNBQUsyRCxVQUFMLEdBQWtCLEVBQWxCO0FBQ0EsU0FBSzNELE1BQUwsR0FBY0EsTUFBTSxJQUFJLElBQXhCO0FBQ0Q7O0FBRUQsTUFBSXVNLE1BQU0sR0FBR0QsZUFBZSxDQUFDMVQsU0FBN0I7O0FBRUEyVCxFQUFBQSxNQUFNLENBQUN0TixnQkFBUCxHQUEwQixTQUFTQSxnQkFBVCxDQUEwQnpELElBQTFCLEVBQWdDb0YsUUFBaEMsRUFBMEM7QUFDbEUsUUFBSWpCLElBQUksR0FBRyxLQUFLZ0UsVUFBTCxDQUFnQm5JLElBQWhCLE1BQTBCLEtBQUttSSxVQUFMLENBQWdCbkksSUFBaEIsSUFBd0IsRUFBbEQsQ0FBWDs7QUFFQSxRQUFJLENBQUMsQ0FBQ21FLElBQUksQ0FBQ3FMLE9BQUwsQ0FBYXBLLFFBQWIsQ0FBTixFQUE4QjtBQUM1QmpCLE1BQUFBLElBQUksQ0FBQzNCLElBQUwsQ0FBVTRDLFFBQVY7QUFDRDtBQUNGLEdBTkQ7O0FBUUEyTCxFQUFBQSxNQUFNLENBQUNsTixtQkFBUCxHQUE2QixTQUFTQSxtQkFBVCxDQUE2QjdELElBQTdCLEVBQW1Db0YsUUFBbkMsRUFBNkM7QUFDeEUsUUFBSWpCLElBQUksR0FBRyxLQUFLZ0UsVUFBTCxDQUFnQm5JLElBQWhCLENBQVg7QUFBQSxRQUNJK0IsQ0FBQyxHQUFHb0MsSUFBSSxJQUFJQSxJQUFJLENBQUNxTCxPQUFMLENBQWFwSyxRQUFiLENBQVIsSUFBa0MsQ0FBQyxDQUQzQztBQUVBckQsSUFBQUEsQ0FBQyxHQUFHLENBQUMsQ0FBTCxJQUFVb0MsSUFBSSxDQUFDckIsTUFBTCxDQUFZZixDQUFaLEVBQWUsQ0FBZixDQUFWO0FBQ0QsR0FKRDs7QUFNQWdQLEVBQUFBLE1BQU0sQ0FBQ3ZJLGFBQVAsR0FBdUIsU0FBU0EsYUFBVCxDQUF1QnhJLElBQXZCLEVBQTZCO0FBQ2xELFFBQUlnUixLQUFLLEdBQUcsSUFBWjs7QUFFQSxRQUFJNUksTUFBSjtBQUNBLEtBQUMsS0FBS0QsVUFBTCxDQUFnQm5JLElBQWhCLEtBQXlCLEVBQTFCLEVBQThCcUMsT0FBOUIsQ0FBc0MsVUFBVStDLFFBQVYsRUFBb0I7QUFDeEQsYUFBT0EsUUFBUSxDQUFDNEYsSUFBVCxDQUFjZ0csS0FBZCxFQUFxQjtBQUMxQmhSLFFBQUFBLElBQUksRUFBRUEsSUFEb0I7QUFFMUJ3RSxRQUFBQSxNQUFNLEVBQUV3TSxLQUFLLENBQUN4TTtBQUZZLE9BQXJCLE1BR0EsS0FIQSxLQUdVNEQsTUFBTSxHQUFHLEtBSG5CLENBQVA7QUFJRCxLQUxEO0FBTUEsV0FBT0EsTUFBUCxDQVZrRCxDQVVuQztBQUNoQixHQVhEOztBQWFBLFNBQU8wSSxlQUFQO0FBQ0QsQ0FwQ2tDLEVBQW5DOztBQXNDTyxJQUFJRyxTQUFTLEdBQUcsYUFBYSxVQUFVQyxnQkFBVixFQUE0QjtBQUM5RGpVLEVBQUFBLGNBQWMsQ0FBQ2dVLFNBQUQsRUFBWUMsZ0JBQVosQ0FBZDs7QUFFQSxXQUFTRCxTQUFULENBQW1Cek0sTUFBbkIsRUFBMkJ5RCxJQUEzQixFQUFpQztBQUMvQixRQUFJa0osTUFBSjs7QUFFQUEsSUFBQUEsTUFBTSxHQUFHRCxnQkFBZ0IsQ0FBQ2xHLElBQWpCLENBQXNCLElBQXRCLEtBQStCLElBQXhDO0FBQ0E5TSxJQUFBQSxZQUFZLElBQUk4USxTQUFTLENBQUMsQ0FBRCxDQUF6QjtBQUNBeEssSUFBQUEsTUFBTSxHQUFHcEcsUUFBUSxDQUFDb0csTUFBRCxDQUFSLENBQWlCLENBQWpCLENBQVQsQ0FMK0IsQ0FLRDs7QUFFOUIsUUFBSSxDQUFDN0YsYUFBTCxFQUFvQjtBQUNsQkEsTUFBQUEsYUFBYSxHQUFHaEIsSUFBSSxDQUFDOFMsT0FBTCxDQUFhQyxPQUE3QjtBQUNEOztBQUVEUyxJQUFBQSxNQUFNLENBQUNsSixJQUFQLEdBQWNBLElBQUksR0FBRzNHLEtBQUssQ0FBQzJHLElBQUksSUFBSSxFQUFULENBQTFCO0FBQ0FrSixJQUFBQSxNQUFNLENBQUMzTSxNQUFQLEdBQWdCQSxNQUFoQjtBQUNBMk0sSUFBQUEsTUFBTSxDQUFDbEwsQ0FBUCxHQUFXa0wsTUFBTSxDQUFDakwsQ0FBUCxHQUFXaUwsTUFBTSxDQUFDQyxRQUFQLEdBQWtCLENBQXhDO0FBQ0FELElBQUFBLE1BQU0sQ0FBQ0UsY0FBUCxHQUF3QmxILFVBQVUsQ0FBQ2xDLElBQUksQ0FBQ29KLGNBQU4sQ0FBVixJQUFtQyxDQUEzRDtBQUNBRixJQUFBQSxNQUFNLENBQUNHLGNBQVAsR0FBd0JDLEtBQUssQ0FBQ3RKLElBQUksQ0FBQ3FKLGNBQU4sQ0FBTCxHQUE2QixDQUE3QixHQUFpQ25ILFVBQVUsQ0FBQ2xDLElBQUksQ0FBQ3FKLGNBQU4sQ0FBVixJQUFtQyxDQUE1RjtBQUNBSCxJQUFBQSxNQUFNLENBQUNLLFFBQVAsR0FBa0J2SixJQUFJLENBQUN1SixRQUF2QjtBQUNBTCxJQUFBQSxNQUFNLENBQUNNLFVBQVAsR0FBb0J4SixJQUFJLENBQUN3SixVQUFMLElBQW1CLENBQXZDO0FBQ0FOLElBQUFBLE1BQU0sQ0FBQ08sVUFBUCxHQUFvQixJQUFwQjtBQUNBUCxJQUFBQSxNQUFNLENBQUNRLGlCQUFQLEdBQTJCLENBQUMsQ0FBQzFKLElBQUksQ0FBQzBKLGlCQUFsQztBQUNBaFUsSUFBQUEsSUFBSSxDQUFDaVUsV0FBTCxDQUFpQnBOLE1BQWpCLEVBQXlCLEdBQXpCLEVBcEIrQixDQW9CQTs7QUFFL0IsUUFBSXhFLElBQUksR0FBRyxDQUFDaUksSUFBSSxDQUFDakksSUFBTCxJQUFhLEtBQWQsRUFBcUJ5RyxXQUFyQixFQUFYO0FBQUEsUUFDSW9MLE1BQU0sR0FBRyxDQUFDN1IsSUFBSSxDQUFDd1AsT0FBTCxDQUFhLEdBQWIsQ0FBRCxJQUFzQixDQUFDeFAsSUFBSSxDQUFDd1AsT0FBTCxDQUFhLEdBQWIsQ0FEcEM7QUFBQSxRQUVJc0MsWUFBWSxHQUFHOVIsSUFBSSxDQUFDd1AsT0FBTCxDQUFhLFVBQWIsTUFBNkIsQ0FBQyxDQUZqRDtBQUFBLFFBR0l1QyxLQUFLLEdBQUdELFlBQVksR0FBRyxVQUFILEdBQWdCRCxNQUFNLEdBQUcsR0FBSCxHQUFTLE1BSHZEO0FBQUEsUUFJSUcsS0FBSyxHQUFHSCxNQUFNLEdBQUcsR0FBSCxHQUFTLEtBSjNCO0FBQUEsUUFLSUksTUFBTSxHQUFHLENBQUMsRUFBRSxDQUFDalMsSUFBSSxDQUFDd1AsT0FBTCxDQUFhLEdBQWIsQ0FBRCxJQUFzQixDQUFDeFAsSUFBSSxDQUFDd1AsT0FBTCxDQUFhLE1BQWIsQ0FBdkIsSUFBK0N4UCxJQUFJLEtBQUssUUFBMUQsQ0FMZDtBQUFBLFFBTUlrUyxNQUFNLEdBQUcsQ0FBQyxFQUFFLENBQUNsUyxJQUFJLENBQUN3UCxPQUFMLENBQWEsR0FBYixDQUFELElBQXNCLENBQUN4UCxJQUFJLENBQUN3UCxPQUFMLENBQWEsS0FBYixDQUF2QixJQUE4Q3hQLElBQUksS0FBSyxRQUF6RCxDQU5kO0FBQUEsUUFPSW1TLGVBQWUsR0FBR2xLLElBQUksQ0FBQ2tLLGVBQUwsSUFBd0IsQ0FQOUM7QUFBQSxRQVFJcFYsSUFBSSxHQUFHRCxzQkFBc0IsQ0FBQ3FVLE1BQUQsQ0FSakM7QUFBQSxRQVNJaUIsUUFBUSxHQUFHaFUsUUFBUSxDQUFDNkosSUFBSSxDQUFDb0ssT0FBTCxJQUFnQnBLLElBQUksQ0FBQ3FLLE1BQXJCLElBQStCOU4sTUFBaEMsQ0FUdkI7QUFBQSxRQVVJK04sU0FBUyxHQUFHLEVBVmhCO0FBQUEsUUFXSUMsV0FBVyxHQUFHLENBWGxCO0FBQUEsUUFZSUMscUJBQXFCLEdBQUcsS0FaNUI7QUFBQSxRQWFJQyxtQkFBbUIsR0FBR3pLLElBQUksQ0FBQ3lLLG1CQUFMLElBQTRCLEVBYnREO0FBQUEsUUFjSUMscUJBQXFCLEdBQUcxSyxJQUFJLENBQUMwSyxxQkFBTCxJQUE4QixFQWQxRDtBQUFBLFFBZUlDLHNCQUFzQixHQUFHM0ssSUFBSSxDQUFDMkssc0JBQUwsSUFBK0IsRUFmNUQ7QUFBQSxRQWdCSUMsb0JBQW9CLEdBQUc1SyxJQUFJLENBQUM0SyxvQkFBTCxJQUE2QixFQWhCeEQ7QUFBQSxRQWlCSUMsV0FBVyxHQUFHN0ssSUFBSSxDQUFDOEssYUFBTCxJQUFzQjdILFlBakJ4QztBQUFBLFFBa0JJOEgsU0FBUyxHQUFHLENBbEJoQjtBQUFBLFFBbUJJQyxPQUFPLEdBQUd6TyxNQUFNLENBQUMwTyxLQUFQLElBQWdCdlYsSUFBSSxDQUFDd1YsSUFBTCxDQUFVQyxRQUFWLENBQW1CNU8sTUFBbkIsQ0FuQjlCO0FBQUEsUUFvQkk2TyxPQUFPLEdBQUd2SCxRQUFRLENBQUN0SCxNQUFELENBcEJ0QjtBQUFBLFFBcUJJOE8sWUFBWSxHQUFHLFNBQVNBLFlBQVQsQ0FBc0I5TSxRQUF0QixFQUFnQytNLElBQWhDLEVBQXNDO0FBQ3ZELGFBQU9wSixVQUFVLENBQUM4SSxPQUFPLENBQUMzQyxHQUFSLENBQVk5TCxNQUFaLEVBQW9CZ0MsUUFBcEIsRUFBOEIrTSxJQUE5QixDQUFELENBQWpCO0FBQ0QsS0F2QkQ7QUFBQSxRQXdCSUMsUUFBUSxHQUFHaFAsTUFBTSxDQUFDa0QsYUFBUCxJQUF3QjdKLElBeEJ2QztBQUFBLFFBeUJJNFYsT0F6Qko7QUFBQSxRQTBCSUMsV0ExQko7QUFBQSxRQTJCSUMsYUEzQko7QUFBQSxRQTRCSUMsYUE1Qko7QUFBQSxRQTZCSUMsYUE3Qko7QUFBQSxRQThCSUMsYUE5Qko7QUFBQSxRQStCSUMsU0EvQko7QUFBQSxRQWdDSUMsZUFoQ0o7QUFBQSxRQWlDSUMsZUFqQ0o7QUFBQSxRQWtDSWpMLElBbENKO0FBQUEsUUFtQ0lILElBbkNKO0FBQUEsUUFvQ0lLLElBcENKO0FBQUEsUUFxQ0lILElBckNKO0FBQUEsUUFzQ0ltTCxLQXRDSjtBQUFBLFFBdUNJQyxPQXZDSjtBQUFBLFFBd0NJQyxjQXhDSjtBQUFBLFFBeUNJQyxLQXpDSjtBQUFBLFFBMENJQyxHQTFDSjtBQUFBLFFBMkNJQyxLQTNDSjtBQUFBLFFBNENJQyxLQTVDSjtBQUFBLFFBNkNJQyxNQTdDSjtBQUFBLFFBOENJQyxVQTlDSjtBQUFBLFFBK0NJQyxnQkEvQ0o7QUFBQSxRQWdESW5MLE1BaERKO0FBQUEsUUFpRElvTCxXQWpESjtBQUFBLFFBa0RJQyx5QkFsREo7QUFBQSxRQW1ESUMsYUFuREo7QUFBQSxRQW9ESUMsYUFwREo7QUFBQSxRQXFESUMsYUFyREo7QUFBQSxRQXNESUMsb0JBdERKO0FBQUEsUUF1RElDLG1CQXZESjtBQUFBLFFBd0RJQyxXQXhESjtBQUFBLFFBeURJQyxhQUFhLEdBQUcsU0FBU0EsYUFBVCxDQUF1QmxWLENBQXZCLEVBQTBCO0FBQzVDO0FBQ0E7QUFDQTRELE1BQUFBLGVBQWUsQ0FBQzVELENBQUQsQ0FBZjs7QUFFQUEsTUFBQUEsQ0FBQyxDQUFDbVYsd0JBQUYsSUFBOEJuVixDQUFDLENBQUNtVix3QkFBRixFQUE5QjtBQUNBLGFBQU8sS0FBUDtBQUNELEtBaEVEO0FBQUEsUUFpRUk7QUFDSkMsSUFBQUEsTUFBTSxHQUFHLFNBQVNBLE1BQVQsQ0FBZ0JDLGNBQWhCLEVBQWdDO0FBQ3ZDLFVBQUl4WSxJQUFJLENBQUMwVSxVQUFMLElBQW1CMVUsSUFBSSxDQUFDeVksVUFBeEIsS0FBdUMvQyxxQkFBcUIsSUFBSTRCLEtBQWhFLENBQUosRUFBNEU7QUFDMUUsWUFBSW5VLENBQUMsR0FBR3NFLE1BQVI7QUFBQSxZQUNJaVIsZ0JBQWdCLEdBQUcxWSxJQUFJLENBQUMwVSxVQUFMLEdBQWtCLEVBRHpDO0FBQUEsWUFFSTtBQUNKM0IsUUFBQUEsTUFIQTtBQUFBLFlBSUk0RixNQUpKO0FBQUEsWUFLSUMsSUFMSjtBQUFBLFlBTUlDLFFBTko7QUFBQSxZQU9JQyxRQVBKO0FBQUEsWUFRSUMsT0FSSjtBQUFBLFlBU0lDLE9BVEo7QUFBQSxZQVVJQyxHQVZKO0FBV0F2RCxRQUFBQSxxQkFBcUIsR0FBRyxLQUF4QjtBQUNBcFIsUUFBQUEsWUFBWSxDQUFDd0QsU0FBYixHQUF5QmpILElBQUksQ0FBQ2dILFdBQUwsSUFBb0IsSUFBcEIsR0FBMkJoSCxJQUFJLENBQUNnSCxXQUFoQyxHQUE4QzRPLFFBQVEsQ0FBQzFPLGVBQVQsQ0FBeUJELFNBQXpCLElBQXNDLElBQXRDLEdBQTZDMk8sUUFBUSxDQUFDMU8sZUFBVCxDQUF5QkQsU0FBdEUsR0FBa0YyTyxRQUFRLENBQUN6TyxJQUFULENBQWNGLFNBQXZLO0FBQ0F4RCxRQUFBQSxZQUFZLENBQUM2RCxVQUFiLEdBQTBCdEgsSUFBSSxDQUFDcUgsV0FBTCxJQUFvQixJQUFwQixHQUEyQnJILElBQUksQ0FBQ3FILFdBQWhDLEdBQThDdU8sUUFBUSxDQUFDMU8sZUFBVCxDQUF5QkksVUFBekIsSUFBdUMsSUFBdkMsR0FBOENzTyxRQUFRLENBQUMxTyxlQUFULENBQXlCSSxVQUF2RSxHQUFvRnNPLFFBQVEsQ0FBQ3pPLElBQVQsQ0FBY0csVUFBMUs7QUFDQTBRLFFBQUFBLFFBQVEsR0FBRzdZLElBQUksQ0FBQzZZLFFBQUwsR0FBZ0J2VSxZQUFZLENBQUM2RCxVQUF4QztBQUNBMlEsUUFBQUEsUUFBUSxHQUFHOVksSUFBSSxDQUFDOFksUUFBTCxHQUFnQnhVLFlBQVksQ0FBQ3dELFNBQXhDOztBQUVBLGVBQU8zRSxDQUFDLElBQUksQ0FBQ3dWLE1BQWIsRUFBcUI7QUFDbkI7QUFDQUEsVUFBQUEsTUFBTSxHQUFHclEsT0FBTyxDQUFDbkYsQ0FBQyxDQUFDb0YsVUFBSCxDQUFoQjtBQUNBd0ssVUFBQUEsTUFBTSxHQUFHNEYsTUFBTSxHQUFHclUsWUFBSCxHQUFrQm5CLENBQUMsQ0FBQ29GLFVBQW5DO0FBQ0FxUSxVQUFBQSxJQUFJLEdBQUdELE1BQU0sR0FBRztBQUNkbk8sWUFBQUEsTUFBTSxFQUFFN0gsSUFBSSxDQUFDb0csR0FBTCxDQUFTaEksV0FBVyxDQUFDMkosWUFBckIsRUFBbUM3SixJQUFJLENBQUM0SixXQUFMLElBQW9CLENBQXZELENBRE07QUFFZEwsWUFBQUEsS0FBSyxFQUFFekgsSUFBSSxDQUFDb0csR0FBTCxDQUFTaEksV0FBVyxDQUFDc0osV0FBckIsRUFBa0N4SixJQUFJLENBQUN5SixVQUFMLElBQW1CLENBQXJELENBRk87QUFHZEwsWUFBQUEsSUFBSSxFQUFFLENBSFE7QUFJZEMsWUFBQUEsR0FBRyxFQUFFO0FBSlMsV0FBSCxHQUtUNkksTUFBTSxDQUFDaEkscUJBQVAsRUFMSjtBQU1BZ08sVUFBQUEsT0FBTyxHQUFHQyxPQUFPLEdBQUcsQ0FBcEI7O0FBRUEsY0FBSTdELE1BQUosRUFBWTtBQUNWOEQsWUFBQUEsR0FBRyxHQUFHbEcsTUFBTSxDQUFDMUosYUFBUCxHQUF1QjBKLE1BQU0sQ0FBQ2pMLFNBQXBDOztBQUVBLGdCQUFJbVIsR0FBRyxHQUFHLENBQVYsRUFBYTtBQUNYRCxjQUFBQSxPQUFPLEdBQUdDLEdBQVY7QUFDRCxhQUZELE1BRU8sSUFBSUgsUUFBUSxHQUFHRixJQUFJLENBQUNwTyxNQUFMLEdBQWNxTCxzQkFBekIsSUFBbURvRCxHQUF2RCxFQUE0RDtBQUNqRXZELGNBQUFBLHFCQUFxQixHQUFHLElBQXhCO0FBQ0FzRCxjQUFBQSxPQUFPLEdBQUdyVyxJQUFJLENBQUNrSixHQUFMLENBQVNvTixHQUFULEVBQWNQLGdCQUFnQixJQUFJLElBQUkvVixJQUFJLENBQUNvRyxHQUFMLENBQVMsQ0FBVCxFQUFZNlAsSUFBSSxDQUFDcE8sTUFBTCxHQUFjc08sUUFBMUIsSUFBc0NqRCxzQkFBOUMsQ0FBaEIsR0FBd0YsQ0FBdEcsQ0FBVjtBQUNELGFBSE0sTUFHQSxJQUFJaUQsUUFBUSxHQUFHRixJQUFJLENBQUMxTyxHQUFMLEdBQVd5TCxtQkFBdEIsSUFBNkM1QyxNQUFNLENBQUNqTCxTQUF4RCxFQUFtRTtBQUN4RTROLGNBQUFBLHFCQUFxQixHQUFHLElBQXhCO0FBQ0FzRCxjQUFBQSxPQUFPLEdBQUcsQ0FBQ3JXLElBQUksQ0FBQ2tKLEdBQUwsQ0FBU2tILE1BQU0sQ0FBQ2pMLFNBQWhCLEVBQTJCNFEsZ0JBQWdCLElBQUksSUFBSS9WLElBQUksQ0FBQ29HLEdBQUwsQ0FBUyxDQUFULEVBQVkrUCxRQUFRLEdBQUdGLElBQUksQ0FBQzFPLEdBQTVCLElBQW1DeUwsbUJBQTNDLENBQWhCLEdBQWtGLENBQTdHLENBQVg7QUFDRDs7QUFFRCxnQkFBSXFELE9BQUosRUFBYTtBQUNYakcsY0FBQUEsTUFBTSxDQUFDakwsU0FBUCxJQUFvQmtSLE9BQXBCO0FBQ0Q7QUFDRjs7QUFFRCxjQUFJOUQsTUFBSixFQUFZO0FBQ1YrRCxZQUFBQSxHQUFHLEdBQUdsRyxNQUFNLENBQUMzSixhQUFQLEdBQXVCMkosTUFBTSxDQUFDNUssVUFBcEM7O0FBRUEsZ0JBQUk4USxHQUFHLEdBQUcsQ0FBVixFQUFhO0FBQ1hGLGNBQUFBLE9BQU8sR0FBR0UsR0FBVjtBQUNELGFBRkQsTUFFTyxJQUFJSixRQUFRLEdBQUdELElBQUksQ0FBQ3hPLEtBQUwsR0FBYXdMLHFCQUF4QixJQUFpRHFELEdBQXJELEVBQTBEO0FBQy9EdkQsY0FBQUEscUJBQXFCLEdBQUcsSUFBeEI7QUFDQXFELGNBQUFBLE9BQU8sR0FBR3BXLElBQUksQ0FBQ2tKLEdBQUwsQ0FBU29OLEdBQVQsRUFBY1AsZ0JBQWdCLElBQUksSUFBSS9WLElBQUksQ0FBQ29HLEdBQUwsQ0FBUyxDQUFULEVBQVk2UCxJQUFJLENBQUN4TyxLQUFMLEdBQWF5TyxRQUF6QixJQUFxQ2pELHFCQUE3QyxDQUFoQixHQUFzRixDQUFwRyxDQUFWO0FBQ0QsYUFITSxNQUdBLElBQUlpRCxRQUFRLEdBQUdELElBQUksQ0FBQzNPLElBQUwsR0FBWTZMLG9CQUF2QixJQUErQy9DLE1BQU0sQ0FBQzVLLFVBQTFELEVBQXNFO0FBQzNFdU4sY0FBQUEscUJBQXFCLEdBQUcsSUFBeEI7QUFDQXFELGNBQUFBLE9BQU8sR0FBRyxDQUFDcFcsSUFBSSxDQUFDa0osR0FBTCxDQUFTa0gsTUFBTSxDQUFDNUssVUFBaEIsRUFBNEJ1USxnQkFBZ0IsSUFBSSxJQUFJL1YsSUFBSSxDQUFDb0csR0FBTCxDQUFTLENBQVQsRUFBWThQLFFBQVEsR0FBR0QsSUFBSSxDQUFDM08sSUFBNUIsSUFBb0M2TCxvQkFBNUMsQ0FBaEIsR0FBb0YsQ0FBaEgsQ0FBWDtBQUNEOztBQUVELGdCQUFJaUQsT0FBSixFQUFhO0FBQ1hoRyxjQUFBQSxNQUFNLENBQUM1SyxVQUFQLElBQXFCNFEsT0FBckI7QUFDRDtBQUNGOztBQUVELGNBQUlKLE1BQU0sS0FBS0ksT0FBTyxJQUFJQyxPQUFoQixDQUFWLEVBQW9DO0FBQ2xDblksWUFBQUEsSUFBSSxDQUFDcVksUUFBTCxDQUFjbkcsTUFBTSxDQUFDNUssVUFBckIsRUFBaUM0SyxNQUFNLENBQUNqTCxTQUF4Qzs7QUFFQXFSLFlBQUFBLGtCQUFrQixDQUFDblosSUFBSSxDQUFDNlksUUFBTCxHQUFnQkUsT0FBakIsRUFBMEIvWSxJQUFJLENBQUM4WSxRQUFMLEdBQWdCRSxPQUExQyxDQUFsQjtBQUNEOztBQUVEN1YsVUFBQUEsQ0FBQyxHQUFHNFAsTUFBSjtBQUNEO0FBQ0Y7O0FBRUQsVUFBSXVFLEtBQUosRUFBVztBQUNULFlBQUlwTyxDQUFDLEdBQUdsSixJQUFJLENBQUNrSixDQUFiO0FBQUEsWUFDSUMsQ0FBQyxHQUFHbkosSUFBSSxDQUFDbUosQ0FEYjs7QUFHQSxZQUFJNEwsWUFBSixFQUFrQjtBQUNoQi9VLFVBQUFBLElBQUksQ0FBQ29aLE1BQUwsR0FBY2xRLENBQUMsR0FBR2tFLFVBQVUsQ0FBQzhJLE9BQU8sQ0FBQzdCLFFBQVQsQ0FBNUI7QUFDQXJVLFVBQUFBLElBQUksQ0FBQ3FVLFFBQUwsR0FBZ0JuTCxDQUFoQjtBQUNBZ04sVUFBQUEsT0FBTyxDQUFDN0IsUUFBUixHQUFtQm5MLENBQUMsR0FBRyxLQUF2QjtBQUNBZ04sVUFBQUEsT0FBTyxDQUFDbUQsZUFBUixDQUF3QixDQUF4QixFQUEyQm5ELE9BQTNCO0FBQ0QsU0FMRCxNQUtPO0FBQ0wsY0FBSVMsV0FBSixFQUFpQjtBQUNmLGdCQUFJeEIsTUFBSixFQUFZO0FBQ1ZuVixjQUFBQSxJQUFJLENBQUNzWixNQUFMLEdBQWNuUSxDQUFDLEdBQUd3TixXQUFXLENBQUN6TSxHQUFaLEVBQWxCO0FBQ0F5TSxjQUFBQSxXQUFXLENBQUN6TSxHQUFaLENBQWdCZixDQUFoQjtBQUNEOztBQUVELGdCQUFJK0wsTUFBSixFQUFZO0FBQ1ZsVixjQUFBQSxJQUFJLENBQUNvWixNQUFMLEdBQWNsUSxDQUFDLEdBQUd5TixXQUFXLENBQUMxTSxJQUFaLEVBQWxCO0FBQ0EwTSxjQUFBQSxXQUFXLENBQUMxTSxJQUFaLENBQWlCZixDQUFqQjtBQUNEO0FBQ0YsV0FWRCxNQVVPLElBQUk0TCxNQUFKLEVBQVk7QUFDakIsZ0JBQUlLLE1BQUosRUFBWTtBQUNWblYsY0FBQUEsSUFBSSxDQUFDc1osTUFBTCxHQUFjblEsQ0FBQyxHQUFHaUUsVUFBVSxDQUFDOEksT0FBTyxDQUFDL00sQ0FBVCxDQUE1QjtBQUNBK00sY0FBQUEsT0FBTyxDQUFDL00sQ0FBUixHQUFZQSxDQUFDLEdBQUcsSUFBaEI7QUFDRDs7QUFFRCxnQkFBSStMLE1BQUosRUFBWTtBQUNWbFYsY0FBQUEsSUFBSSxDQUFDb1osTUFBTCxHQUFjbFEsQ0FBQyxHQUFHa0UsVUFBVSxDQUFDOEksT0FBTyxDQUFDaE4sQ0FBVCxDQUE1QjtBQUNBZ04sY0FBQUEsT0FBTyxDQUFDaE4sQ0FBUixHQUFZQSxDQUFDLEdBQUcsSUFBaEI7QUFDRDs7QUFFRGdOLFlBQUFBLE9BQU8sQ0FBQ21ELGVBQVIsQ0FBd0IsQ0FBeEIsRUFBMkJuRCxPQUEzQjtBQUNELFdBWk0sTUFZQTtBQUNMLGdCQUFJZixNQUFKLEVBQVk7QUFDVm5WLGNBQUFBLElBQUksQ0FBQ3NaLE1BQUwsR0FBY25RLENBQUMsR0FBR2lFLFVBQVUsQ0FBQzNGLE1BQU0sQ0FBQ2xFLEtBQVAsQ0FBYTJHLEdBQWIsSUFBb0IsQ0FBckIsQ0FBNUI7QUFDQXpDLGNBQUFBLE1BQU0sQ0FBQ2xFLEtBQVAsQ0FBYTJHLEdBQWIsR0FBbUJmLENBQUMsR0FBRyxJQUF2QjtBQUNEOztBQUVELGdCQUFJK0wsTUFBSixFQUFZO0FBQ1ZsVixjQUFBQSxJQUFJLENBQUNvWixNQUFMLEdBQWNsUSxDQUFDLEdBQUdrRSxVQUFVLENBQUMzRixNQUFNLENBQUNsRSxLQUFQLENBQWEwRyxJQUFiLElBQXFCLENBQXRCLENBQTVCO0FBQ0F4QyxjQUFBQSxNQUFNLENBQUNsRSxLQUFQLENBQWEwRyxJQUFiLEdBQW9CZixDQUFDLEdBQUcsSUFBeEI7QUFDRDtBQUNGO0FBQ0Y7O0FBRUQsWUFBSStOLGVBQWUsSUFBSSxDQUFDdUIsY0FBcEIsSUFBc0MsQ0FBQ1IsYUFBM0MsRUFBMEQ7QUFDeERBLFVBQUFBLGFBQWEsR0FBRyxJQUFoQixDQUR3RCxDQUNsQzs7QUFFdEIsY0FBSWhOLGNBQWMsQ0FBQ2hMLElBQUQsRUFBTyxNQUFQLEVBQWUsUUFBZixDQUFkLEtBQTJDLEtBQS9DLEVBQXNEO0FBQ3BELGdCQUFJa1YsTUFBSixFQUFZO0FBQ1ZsVixjQUFBQSxJQUFJLENBQUNrSixDQUFMLElBQVVsSixJQUFJLENBQUNvWixNQUFmO0FBQ0Q7O0FBRUQsZ0JBQUlqRSxNQUFKLEVBQVk7QUFDVm5WLGNBQUFBLElBQUksQ0FBQ21KLENBQUwsSUFBVW5KLElBQUksQ0FBQ3NaLE1BQWY7QUFDRDs7QUFFRGYsWUFBQUEsTUFBTSxDQUFDLElBQUQsQ0FBTjtBQUNEOztBQUVEUCxVQUFBQSxhQUFhLEdBQUcsS0FBaEI7QUFDRDtBQUNGOztBQUVEVixNQUFBQSxLQUFLLEdBQUcsS0FBUjtBQUNELEtBaE5EO0FBQUEsUUFpTkk7QUFDSmlDLElBQUFBLE1BQU0sR0FBRyxTQUFTQSxNQUFULENBQWdCQyxZQUFoQixFQUE4QkMsUUFBOUIsRUFBd0M7QUFDL0MsVUFBSXZRLENBQUMsR0FBR2xKLElBQUksQ0FBQ2tKLENBQWI7QUFBQSxVQUNJQyxDQUFDLEdBQUduSixJQUFJLENBQUNtSixDQURiO0FBQUEsVUFFSXVRLFlBRko7QUFBQSxVQUdJM00sRUFISjs7QUFLQSxVQUFJLENBQUN0RixNQUFNLENBQUMwTyxLQUFaLEVBQW1CO0FBQ2pCO0FBQ0FELFFBQUFBLE9BQU8sR0FBR3RWLElBQUksQ0FBQ3dWLElBQUwsQ0FBVUMsUUFBVixDQUFtQjVPLE1BQW5CLENBQVY7QUFDRDs7QUFFRHlPLE1BQUFBLE9BQU8sQ0FBQ3lELE9BQVIsSUFBbUIvWSxJQUFJLENBQUNpVSxXQUFMLENBQWlCcE4sTUFBakIsRUFBeUIsR0FBekIsQ0FBbkIsQ0FYK0MsQ0FXRzs7QUFFbEQsVUFBSXFOLE1BQUosRUFBWTtBQUNWOVUsUUFBQUEsSUFBSSxDQUFDa0osQ0FBTCxHQUFTa0UsVUFBVSxDQUFDOEksT0FBTyxDQUFDaE4sQ0FBVCxDQUFuQjtBQUNBbEosUUFBQUEsSUFBSSxDQUFDbUosQ0FBTCxHQUFTaUUsVUFBVSxDQUFDOEksT0FBTyxDQUFDL00sQ0FBVCxDQUFuQjtBQUNELE9BSEQsTUFHTyxJQUFJNEwsWUFBSixFQUFrQjtBQUN2Qi9VLFFBQUFBLElBQUksQ0FBQ2tKLENBQUwsR0FBU2xKLElBQUksQ0FBQ3FVLFFBQUwsR0FBZ0JqSCxVQUFVLENBQUM4SSxPQUFPLENBQUM3QixRQUFULENBQW5DO0FBQ0QsT0FGTSxNQUVBLElBQUlzQyxXQUFKLEVBQWlCO0FBQ3RCM1csUUFBQUEsSUFBSSxDQUFDbUosQ0FBTCxHQUFTd04sV0FBVyxDQUFDek0sR0FBWixFQUFUO0FBQ0FsSyxRQUFBQSxJQUFJLENBQUNrSixDQUFMLEdBQVN5TixXQUFXLENBQUMxTSxJQUFaLEVBQVQ7QUFDRCxPQUhNLE1BR0E7QUFDTGpLLFFBQUFBLElBQUksQ0FBQ21KLENBQUwsR0FBU2lFLFVBQVUsQ0FBQzNGLE1BQU0sQ0FBQ2xFLEtBQVAsQ0FBYTJHLEdBQWIsSUFBb0IsQ0FBQzZDLEVBQUUsR0FBR3BELGlCQUFpQixDQUFDbEMsTUFBRCxDQUF2QixLQUFvQ3NGLEVBQUUsQ0FBQzdDLEdBQTVELENBQVYsSUFBOEUsQ0FBdkY7QUFDQWxLLFFBQUFBLElBQUksQ0FBQ2tKLENBQUwsR0FBU2tFLFVBQVUsQ0FBQzNGLE1BQU0sQ0FBQ2xFLEtBQVAsQ0FBYTBHLElBQWIsSUFBcUIsQ0FBQzhDLEVBQUUsSUFBSSxFQUFQLEVBQVc5QyxJQUFqQyxDQUFWLElBQW9ELENBQTdEO0FBQ0Q7O0FBRUQsVUFBSSxDQUFDdU4sS0FBSyxJQUFJQyxLQUFULElBQWtCQyxNQUFuQixLQUE4QixDQUFDK0IsUUFBL0IsS0FBNEN6WixJQUFJLENBQUN5WSxVQUFMLElBQW1CelksSUFBSSxDQUFDNFosVUFBcEUsQ0FBSixFQUFxRjtBQUNuRixZQUFJbEMsTUFBSixFQUFZO0FBQ1ZyVCxVQUFBQSxNQUFNLENBQUM2RSxDQUFQLEdBQVdsSixJQUFJLENBQUNrSixDQUFoQjtBQUNBN0UsVUFBQUEsTUFBTSxDQUFDOEUsQ0FBUCxHQUFXbkosSUFBSSxDQUFDbUosQ0FBaEI7QUFDQXVRLFVBQUFBLFlBQVksR0FBR2hDLE1BQU0sQ0FBQ3JULE1BQUQsQ0FBckI7O0FBRUEsY0FBSXFWLFlBQVksQ0FBQ3hRLENBQWIsS0FBbUJsSixJQUFJLENBQUNrSixDQUE1QixFQUErQjtBQUM3QmxKLFlBQUFBLElBQUksQ0FBQ2tKLENBQUwsR0FBU3dRLFlBQVksQ0FBQ3hRLENBQXRCO0FBQ0FvTyxZQUFBQSxLQUFLLEdBQUcsSUFBUjtBQUNEOztBQUVELGNBQUlvQyxZQUFZLENBQUN2USxDQUFiLEtBQW1CbkosSUFBSSxDQUFDbUosQ0FBNUIsRUFBK0I7QUFDN0JuSixZQUFBQSxJQUFJLENBQUNtSixDQUFMLEdBQVN1USxZQUFZLENBQUN2USxDQUF0QjtBQUNBbU8sWUFBQUEsS0FBSyxHQUFHLElBQVI7QUFDRDtBQUNGOztBQUVELFlBQUlFLEtBQUosRUFBVztBQUNUa0MsVUFBQUEsWUFBWSxHQUFHbEMsS0FBSyxDQUFDeFgsSUFBSSxDQUFDa0osQ0FBTixDQUFwQjs7QUFFQSxjQUFJd1EsWUFBWSxLQUFLMVosSUFBSSxDQUFDa0osQ0FBMUIsRUFBNkI7QUFDM0JsSixZQUFBQSxJQUFJLENBQUNrSixDQUFMLEdBQVN3USxZQUFUOztBQUVBLGdCQUFJM0UsWUFBSixFQUFrQjtBQUNoQi9VLGNBQUFBLElBQUksQ0FBQ3FVLFFBQUwsR0FBZ0JxRixZQUFoQjtBQUNEOztBQUVEcEMsWUFBQUEsS0FBSyxHQUFHLElBQVI7QUFDRDtBQUNGOztBQUVELFlBQUlHLEtBQUosRUFBVztBQUNUaUMsVUFBQUEsWUFBWSxHQUFHakMsS0FBSyxDQUFDelgsSUFBSSxDQUFDbUosQ0FBTixDQUFwQjs7QUFFQSxjQUFJdVEsWUFBWSxLQUFLMVosSUFBSSxDQUFDbUosQ0FBMUIsRUFBNkI7QUFDM0JuSixZQUFBQSxJQUFJLENBQUNtSixDQUFMLEdBQVN1USxZQUFUO0FBQ0Q7O0FBRURwQyxVQUFBQSxLQUFLLEdBQUcsSUFBUjtBQUNEO0FBQ0Y7O0FBRURBLE1BQUFBLEtBQUssSUFBSWlCLE1BQU0sQ0FBQyxJQUFELENBQWY7O0FBRUEsVUFBSSxDQUFDaUIsWUFBTCxFQUFtQjtBQUNqQnhaLFFBQUFBLElBQUksQ0FBQ29aLE1BQUwsR0FBY3BaLElBQUksQ0FBQ2tKLENBQUwsR0FBU0EsQ0FBdkI7QUFDQWxKLFFBQUFBLElBQUksQ0FBQ3NaLE1BQUwsR0FBY3RaLElBQUksQ0FBQ21KLENBQUwsR0FBU0EsQ0FBdkI7O0FBRUE2QixRQUFBQSxjQUFjLENBQUNoTCxJQUFELEVBQU8sYUFBUCxFQUFzQixlQUF0QixDQUFkO0FBQ0Q7QUFDRixLQTlSRDtBQUFBLFFBK1JJNlosYUFBYSxHQUFHLFNBQVNBLGFBQVQsQ0FBdUJqTSxJQUF2QixFQUE2Qi9CLEdBQTdCLEVBQWtDOUMsR0FBbEMsRUFBdUN0RSxNQUF2QyxFQUErQztBQUNqRSxVQUFJb0gsR0FBRyxJQUFJLElBQVgsRUFBaUI7QUFDZkEsUUFBQUEsR0FBRyxHQUFHLENBQUNuSSxPQUFQO0FBQ0Q7O0FBRUQsVUFBSXFGLEdBQUcsSUFBSSxJQUFYLEVBQWlCO0FBQ2ZBLFFBQUFBLEdBQUcsR0FBR3JGLE9BQU47QUFDRDs7QUFFRCxVQUFJdkIsV0FBVyxDQUFDeUwsSUFBRCxDQUFmLEVBQXVCO0FBQ3JCLGVBQU8sVUFBVWtNLENBQVYsRUFBYTtBQUNsQixjQUFJQyxhQUFhLEdBQUcsQ0FBQy9aLElBQUksQ0FBQ3dULFNBQU4sR0FBa0IsQ0FBbEIsR0FBc0IsSUFBSXhULElBQUksQ0FBQ3VVLGNBQW5ELENBRGtCLENBQ2lEOztBQUVuRSxpQkFBTzNHLElBQUksQ0FBQ0ssSUFBTCxDQUFVak8sSUFBVixFQUFnQjhaLENBQUMsR0FBRy9RLEdBQUosR0FBVUEsR0FBRyxHQUFHLENBQUMrUSxDQUFDLEdBQUcvUSxHQUFMLElBQVlnUixhQUE1QixHQUE0Q0QsQ0FBQyxHQUFHak8sR0FBSixHQUFVQSxHQUFHLEdBQUcsQ0FBQ2lPLENBQUMsR0FBR2pPLEdBQUwsSUFBWWtPLGFBQTVCLEdBQTRDRCxDQUF4RyxJQUE2R3JWLE1BQXBIO0FBQ0QsU0FKRDtBQUtEOztBQUVELFVBQUk1QixRQUFRLENBQUMrSyxJQUFELENBQVosRUFBb0I7QUFDbEIsZUFBTyxVQUFVa00sQ0FBVixFQUFhO0FBQ2xCLGNBQUk5VSxDQUFDLEdBQUc0SSxJQUFJLENBQUMzSSxNQUFiO0FBQUEsY0FDSStVLE9BQU8sR0FBRyxDQURkO0FBQUEsY0FFSUMsTUFBTSxHQUFHdlcsT0FGYjtBQUFBLGNBR0lzUCxHQUhKO0FBQUEsY0FJSXBDLEdBSko7O0FBTUEsaUJBQU8sRUFBRTVMLENBQUYsR0FBTSxDQUFDLENBQWQsRUFBaUI7QUFDZmdPLFlBQUFBLEdBQUcsR0FBR3BGLElBQUksQ0FBQzVJLENBQUQsQ0FBVjtBQUNBNEwsWUFBQUEsR0FBRyxHQUFHb0MsR0FBRyxHQUFHOEcsQ0FBWjs7QUFFQSxnQkFBSWxKLEdBQUcsR0FBRyxDQUFWLEVBQWE7QUFDWEEsY0FBQUEsR0FBRyxHQUFHLENBQUNBLEdBQVA7QUFDRDs7QUFFRCxnQkFBSUEsR0FBRyxHQUFHcUosTUFBTixJQUFnQmpILEdBQUcsSUFBSW5ILEdBQXZCLElBQThCbUgsR0FBRyxJQUFJakssR0FBekMsRUFBOEM7QUFDNUNpUixjQUFBQSxPQUFPLEdBQUdoVixDQUFWO0FBQ0FpVixjQUFBQSxNQUFNLEdBQUdySixHQUFUO0FBQ0Q7QUFDRjs7QUFFRCxpQkFBT2hELElBQUksQ0FBQ29NLE9BQUQsQ0FBWDtBQUNELFNBdEJEO0FBdUJEOztBQUVELGFBQU94RixLQUFLLENBQUM1RyxJQUFELENBQUwsR0FBYyxVQUFVa00sQ0FBVixFQUFhO0FBQ2hDLGVBQU9BLENBQVA7QUFDRCxPQUZNLEdBRUgsWUFBWTtBQUNkLGVBQU9sTSxJQUFJLEdBQUduSixNQUFkO0FBQ0QsT0FKRDtBQUtELEtBL1VEO0FBQUEsUUFnVkl5VixrQkFBa0IsR0FBRyxTQUFTQSxrQkFBVCxDQUE0QnRNLElBQTVCLEVBQWtDOUIsSUFBbEMsRUFBd0NHLElBQXhDLEVBQThDRCxJQUE5QyxFQUFvREcsSUFBcEQsRUFBMERnTyxNQUExRCxFQUFrRTFWLE1BQWxFLEVBQTBFO0FBQ2pHMFYsTUFBQUEsTUFBTSxHQUFHQSxNQUFNLElBQUlBLE1BQU0sR0FBR3pXLE9BQW5CLEdBQTZCeVcsTUFBTSxHQUFHQSxNQUF0QyxHQUErQ3pXLE9BQXhELENBRGlHLENBQ2hDOztBQUVqRSxVQUFJdkIsV0FBVyxDQUFDeUwsSUFBRCxDQUFmLEVBQXVCO0FBQ3JCLGVBQU8sVUFBVXdNLEtBQVYsRUFBaUI7QUFDdEIsY0FBSUwsYUFBYSxHQUFHLENBQUMvWixJQUFJLENBQUN3VCxTQUFOLEdBQWtCLENBQWxCLEdBQXNCLElBQUl4VCxJQUFJLENBQUN1VSxjQUFuRDtBQUFBLGNBQ0lyTCxDQUFDLEdBQUdrUixLQUFLLENBQUNsUixDQURkO0FBQUEsY0FFSUMsQ0FBQyxHQUFHaVIsS0FBSyxDQUFDalIsQ0FGZDtBQUFBLGNBR0lrQyxNQUhKO0FBQUEsY0FJSWdQLEVBSko7QUFBQSxjQUtJQyxFQUxKLENBRHNCLENBTWQ7O0FBRVJGLFVBQUFBLEtBQUssQ0FBQ2xSLENBQU4sR0FBVUEsQ0FBQyxHQUFHQSxDQUFDLEdBQUcrQyxJQUFKLEdBQVdBLElBQUksR0FBRyxDQUFDL0MsQ0FBQyxHQUFHK0MsSUFBTCxJQUFhOE4sYUFBL0IsR0FBK0M3USxDQUFDLEdBQUc0QyxJQUFKLEdBQVdBLElBQUksR0FBRyxDQUFDNUMsQ0FBQyxHQUFHNEMsSUFBTCxJQUFhaU8sYUFBL0IsR0FBK0M3USxDQUE1RztBQUNBa1IsVUFBQUEsS0FBSyxDQUFDalIsQ0FBTixHQUFVQSxDQUFDLEdBQUdBLENBQUMsR0FBR2dELElBQUosR0FBV0EsSUFBSSxHQUFHLENBQUNoRCxDQUFDLEdBQUdnRCxJQUFMLElBQWE0TixhQUEvQixHQUErQzVRLENBQUMsR0FBRzZDLElBQUosR0FBV0EsSUFBSSxHQUFHLENBQUM3QyxDQUFDLEdBQUc2QyxJQUFMLElBQWErTixhQUEvQixHQUErQzVRLENBQTVHO0FBQ0FrQyxVQUFBQSxNQUFNLEdBQUd1QyxJQUFJLENBQUNLLElBQUwsQ0FBVWpPLElBQVYsRUFBZ0JvYSxLQUFoQixDQUFUOztBQUVBLGNBQUkvTyxNQUFNLEtBQUsrTyxLQUFmLEVBQXNCO0FBQ3BCQSxZQUFBQSxLQUFLLENBQUNsUixDQUFOLEdBQVVtQyxNQUFNLENBQUNuQyxDQUFqQjtBQUNBa1IsWUFBQUEsS0FBSyxDQUFDalIsQ0FBTixHQUFVa0MsTUFBTSxDQUFDbEMsQ0FBakI7QUFDRDs7QUFFRCxjQUFJMUUsTUFBTSxLQUFLLENBQWYsRUFBa0I7QUFDaEIyVixZQUFBQSxLQUFLLENBQUNsUixDQUFOLElBQVd6RSxNQUFYO0FBQ0EyVixZQUFBQSxLQUFLLENBQUNqUixDQUFOLElBQVcxRSxNQUFYO0FBQ0Q7O0FBRUQsY0FBSTBWLE1BQU0sR0FBR3pXLE9BQWIsRUFBc0I7QUFDcEIyVyxZQUFBQSxFQUFFLEdBQUdELEtBQUssQ0FBQ2xSLENBQU4sR0FBVUEsQ0FBZjtBQUNBb1IsWUFBQUEsRUFBRSxHQUFHRixLQUFLLENBQUNqUixDQUFOLEdBQVVBLENBQWY7O0FBRUEsZ0JBQUlrUixFQUFFLEdBQUdBLEVBQUwsR0FBVUMsRUFBRSxHQUFHQSxFQUFmLEdBQW9CSCxNQUF4QixFQUFnQztBQUM5QkMsY0FBQUEsS0FBSyxDQUFDbFIsQ0FBTixHQUFVQSxDQUFWO0FBQ0FrUixjQUFBQSxLQUFLLENBQUNqUixDQUFOLEdBQVVBLENBQVY7QUFDRDtBQUNGOztBQUVELGlCQUFPaVIsS0FBUDtBQUNELFNBakNEO0FBa0NEOztBQUVELFVBQUl2WCxRQUFRLENBQUMrSyxJQUFELENBQVosRUFBb0I7QUFDbEIsZUFBTyxVQUFVakosQ0FBVixFQUFhO0FBQ2xCLGNBQUlLLENBQUMsR0FBRzRJLElBQUksQ0FBQzNJLE1BQWI7QUFBQSxjQUNJK1UsT0FBTyxHQUFHLENBRGQ7QUFBQSxjQUVJTyxPQUFPLEdBQUc3VyxPQUZkO0FBQUEsY0FHSXdGLENBSEo7QUFBQSxjQUlJQyxDQUpKO0FBQUEsY0FLSWlSLEtBTEo7QUFBQSxjQU1JSSxJQU5KOztBQVFBLGlCQUFPLEVBQUV4VixDQUFGLEdBQU0sQ0FBQyxDQUFkLEVBQWlCO0FBQ2ZvVixZQUFBQSxLQUFLLEdBQUd4TSxJQUFJLENBQUM1SSxDQUFELENBQVo7QUFDQWtFLFlBQUFBLENBQUMsR0FBR2tSLEtBQUssQ0FBQ2xSLENBQU4sR0FBVXZFLENBQUMsQ0FBQ3VFLENBQWhCO0FBQ0FDLFlBQUFBLENBQUMsR0FBR2lSLEtBQUssQ0FBQ2pSLENBQU4sR0FBVXhFLENBQUMsQ0FBQ3dFLENBQWhCO0FBQ0FxUixZQUFBQSxJQUFJLEdBQUd0UixDQUFDLEdBQUdBLENBQUosR0FBUUMsQ0FBQyxHQUFHQSxDQUFuQjs7QUFFQSxnQkFBSXFSLElBQUksR0FBR0QsT0FBWCxFQUFvQjtBQUNsQlAsY0FBQUEsT0FBTyxHQUFHaFYsQ0FBVjtBQUNBdVYsY0FBQUEsT0FBTyxHQUFHQyxJQUFWO0FBQ0Q7QUFDRjs7QUFFRCxpQkFBT0QsT0FBTyxJQUFJSixNQUFYLEdBQW9Cdk0sSUFBSSxDQUFDb00sT0FBRCxDQUF4QixHQUFvQ3JWLENBQTNDO0FBQ0QsU0F0QkQ7QUF1QkQ7O0FBRUQsYUFBTyxVQUFVbVYsQ0FBVixFQUFhO0FBQ2xCLGVBQU9BLENBQVA7QUFDRCxPQUZEO0FBR0QsS0FyWkQ7QUFBQSxRQXNaSVcsZUFBZSxHQUFHLFNBQVNBLGVBQVQsR0FBMkI7QUFDL0MsVUFBSUMsTUFBSixFQUFZQyxZQUFaLEVBQTBCL00sSUFBMUIsRUFBZ0NnTixTQUFoQztBQUNBNUQsTUFBQUEsU0FBUyxHQUFHLEtBQVo7O0FBRUEsVUFBSUwsV0FBSixFQUFpQjtBQUNmQSxRQUFBQSxXQUFXLENBQUNsRixTQUFaO0FBQ0F6UixRQUFBQSxJQUFJLENBQUM4TCxJQUFMLEdBQVlBLElBQUksR0FBRyxDQUFDNkssV0FBVyxDQUFDeEYsYUFBWixFQUFwQjtBQUNBblIsUUFBQUEsSUFBSSxDQUFDZ00sSUFBTCxHQUFZQSxJQUFJLEdBQUcsQ0FBQzJLLFdBQVcsQ0FBQ3pGLFlBQVosRUFBcEI7QUFDQWxSLFFBQUFBLElBQUksQ0FBQ2lNLElBQUwsR0FBWUEsSUFBSSxHQUFHak0sSUFBSSxDQUFDbU0sSUFBTCxHQUFZQSxJQUFJLEdBQUcsQ0FBdEM7QUFDQTZLLFFBQUFBLFNBQVMsR0FBRyxJQUFaO0FBQ0QsT0FORCxNQU1PLElBQUksQ0FBQyxDQUFDOUwsSUFBSSxDQUFDd1AsTUFBWCxFQUFtQjtBQUN4QkEsUUFBQUEsTUFBTSxHQUFHaFAsVUFBVSxDQUFDUixJQUFJLENBQUN3UCxNQUFOLEVBQWNqVCxNQUFNLENBQUNjLFVBQXJCLENBQW5CLENBRHdCLENBQzZCOztBQUVyRCxZQUFJd00sWUFBSixFQUFrQjtBQUNoQi9VLFVBQUFBLElBQUksQ0FBQzhMLElBQUwsR0FBWUEsSUFBSSxHQUFHNE8sTUFBTSxDQUFDelEsSUFBMUI7QUFDQWpLLFVBQUFBLElBQUksQ0FBQ2lNLElBQUwsR0FBWUEsSUFBSSxHQUFHeU8sTUFBTSxDQUFDelEsSUFBUCxHQUFjeVEsTUFBTSxDQUFDdlEsS0FBeEM7QUFDQW5LLFVBQUFBLElBQUksQ0FBQ2dNLElBQUwsR0FBWUEsSUFBSSxHQUFHaE0sSUFBSSxDQUFDbU0sSUFBTCxHQUFZQSxJQUFJLEdBQUcsQ0FBdEM7QUFDRCxTQUpELE1BSU8sSUFBSSxDQUFDN0osWUFBWSxDQUFDNEksSUFBSSxDQUFDd1AsTUFBTCxDQUFZek8sSUFBYixDQUFiLElBQW1DLENBQUMzSixZQUFZLENBQUM0SSxJQUFJLENBQUN3UCxNQUFMLENBQVl2TyxJQUFiLENBQXBELEVBQXdFO0FBQzdFdU8sVUFBQUEsTUFBTSxHQUFHeFAsSUFBSSxDQUFDd1AsTUFBZDtBQUNBMWEsVUFBQUEsSUFBSSxDQUFDOEwsSUFBTCxHQUFZQSxJQUFJLEdBQUc0TyxNQUFNLENBQUM1TyxJQUExQjtBQUNBOUwsVUFBQUEsSUFBSSxDQUFDZ00sSUFBTCxHQUFZQSxJQUFJLEdBQUcwTyxNQUFNLENBQUMxTyxJQUExQjtBQUNBaE0sVUFBQUEsSUFBSSxDQUFDaU0sSUFBTCxHQUFZQSxJQUFJLEdBQUd5TyxNQUFNLENBQUN6TyxJQUExQjtBQUNBak0sVUFBQUEsSUFBSSxDQUFDbU0sSUFBTCxHQUFZQSxJQUFJLEdBQUd1TyxNQUFNLENBQUN2TyxJQUExQjtBQUNELFNBTk0sTUFNQTtBQUNMd08sVUFBQUEsWUFBWSxHQUFHalAsVUFBVSxDQUFDakUsTUFBRCxFQUFTQSxNQUFNLENBQUNjLFVBQWhCLENBQXpCO0FBQ0F2SSxVQUFBQSxJQUFJLENBQUM4TCxJQUFMLEdBQVlBLElBQUksR0FBR25KLElBQUksQ0FBQ0MsS0FBTCxDQUFXMlQsWUFBWSxDQUFDdkIsS0FBRCxFQUFRLElBQVIsQ0FBWixHQUE0QjBGLE1BQU0sQ0FBQ3pRLElBQW5DLEdBQTBDMFEsWUFBWSxDQUFDMVEsSUFBbEUsQ0FBbkI7QUFDQWpLLFVBQUFBLElBQUksQ0FBQ2dNLElBQUwsR0FBWUEsSUFBSSxHQUFHckosSUFBSSxDQUFDQyxLQUFMLENBQVcyVCxZQUFZLENBQUN0QixLQUFELEVBQVEsSUFBUixDQUFaLEdBQTRCeUYsTUFBTSxDQUFDeFEsR0FBbkMsR0FBeUN5USxZQUFZLENBQUN6USxHQUFqRSxDQUFuQjtBQUNBbEssVUFBQUEsSUFBSSxDQUFDaU0sSUFBTCxHQUFZQSxJQUFJLEdBQUd0SixJQUFJLENBQUNDLEtBQUwsQ0FBV2tKLElBQUksSUFBSTRPLE1BQU0sQ0FBQ3ZRLEtBQVAsR0FBZXdRLFlBQVksQ0FBQ3hRLEtBQWhDLENBQWYsQ0FBbkI7QUFDQW5LLFVBQUFBLElBQUksQ0FBQ21NLElBQUwsR0FBWUEsSUFBSSxHQUFHeEosSUFBSSxDQUFDQyxLQUFMLENBQVdvSixJQUFJLElBQUkwTyxNQUFNLENBQUNuUSxNQUFQLEdBQWdCb1EsWUFBWSxDQUFDcFEsTUFBakMsQ0FBZixDQUFuQjtBQUNEOztBQUVELFlBQUl1QixJQUFJLEdBQUdHLElBQVgsRUFBaUI7QUFDZmpNLFVBQUFBLElBQUksQ0FBQzhMLElBQUwsR0FBWUcsSUFBWjtBQUNBak0sVUFBQUEsSUFBSSxDQUFDaU0sSUFBTCxHQUFZQSxJQUFJLEdBQUdILElBQW5CO0FBQ0FBLFVBQUFBLElBQUksR0FBRzlMLElBQUksQ0FBQzhMLElBQVo7QUFDRDs7QUFFRCxZQUFJRSxJQUFJLEdBQUdHLElBQVgsRUFBaUI7QUFDZm5NLFVBQUFBLElBQUksQ0FBQ2dNLElBQUwsR0FBWUcsSUFBWjtBQUNBbk0sVUFBQUEsSUFBSSxDQUFDbU0sSUFBTCxHQUFZQSxJQUFJLEdBQUdILElBQW5CO0FBQ0FBLFVBQUFBLElBQUksR0FBR2hNLElBQUksQ0FBQ2dNLElBQVo7QUFDRDs7QUFFRCxZQUFJK0ksWUFBSixFQUFrQjtBQUNoQi9VLFVBQUFBLElBQUksQ0FBQytMLFdBQUwsR0FBbUJELElBQW5CO0FBQ0E5TCxVQUFBQSxJQUFJLENBQUNrTSxXQUFMLEdBQW1CRCxJQUFuQjtBQUNEOztBQUVEK0ssUUFBQUEsU0FBUyxHQUFHLElBQVo7QUFDRDs7QUFFRCxVQUFJOUwsSUFBSSxDQUFDMlAsUUFBVCxFQUFtQjtBQUNqQmpOLFFBQUFBLElBQUksR0FBRzFDLElBQUksQ0FBQzJQLFFBQUwsS0FBa0IsSUFBbEIsR0FBeUIzUCxJQUFJLENBQUMwQyxJQUFMLElBQWEsRUFBdEMsR0FBMkMxQyxJQUFJLENBQUMyUCxRQUF2RDtBQUNBRCxRQUFBQSxTQUFTLEdBQUcvWCxRQUFRLENBQUMrSyxJQUFELENBQVIsSUFBa0J6TCxXQUFXLENBQUN5TCxJQUFELENBQXpDOztBQUVBLFlBQUltSCxZQUFKLEVBQWtCO0FBQ2hCeUMsVUFBQUEsS0FBSyxHQUFHcUMsYUFBYSxDQUFDZSxTQUFTLEdBQUdoTixJQUFILEdBQVVBLElBQUksQ0FBQ3lHLFFBQXpCLEVBQW1DdkksSUFBbkMsRUFBeUNHLElBQXpDLEVBQStDLENBQS9DLENBQXJCO0FBQ0F3TCxVQUFBQSxLQUFLLEdBQUcsSUFBUjtBQUNELFNBSEQsTUFHTztBQUNMLGNBQUk3SixJQUFJLENBQUNrTixNQUFULEVBQWlCO0FBQ2ZwRCxZQUFBQSxNQUFNLEdBQUd3QyxrQkFBa0IsQ0FBQ1UsU0FBUyxHQUFHaE4sSUFBSCxHQUFVQSxJQUFJLENBQUNrTixNQUF6QixFQUFpQ2hQLElBQWpDLEVBQXVDRyxJQUF2QyxFQUE2Q0QsSUFBN0MsRUFBbURHLElBQW5ELEVBQXlEeUIsSUFBSSxDQUFDdU0sTUFBOUQsRUFBc0V4RCxXQUFXLEdBQUcsQ0FBQyxDQUFKLEdBQVEsQ0FBekYsQ0FBM0I7QUFDRCxXQUZELE1BRU87QUFDTCxnQkFBSXpCLE1BQUosRUFBWTtBQUNWc0MsY0FBQUEsS0FBSyxHQUFHcUMsYUFBYSxDQUFDZSxTQUFTLEdBQUdoTixJQUFILEdBQVVBLElBQUksQ0FBQzFFLENBQUwsSUFBVTBFLElBQUksQ0FBQzNELElBQWYsSUFBdUIyRCxJQUFJLENBQUN6RixVQUFoRCxFQUE0RDJELElBQTVELEVBQWtFRyxJQUFsRSxFQUF3RTBLLFdBQVcsR0FBRyxDQUFDLENBQUosR0FBUSxDQUEzRixDQUFyQjtBQUNEOztBQUVELGdCQUFJeEIsTUFBSixFQUFZO0FBQ1ZzQyxjQUFBQSxLQUFLLEdBQUdvQyxhQUFhLENBQUNlLFNBQVMsR0FBR2hOLElBQUgsR0FBVUEsSUFBSSxDQUFDekUsQ0FBTCxJQUFVeUUsSUFBSSxDQUFDMUQsR0FBZixJQUFzQjBELElBQUksQ0FBQzlGLFNBQS9DLEVBQTBEa0UsSUFBMUQsRUFBZ0VHLElBQWhFLEVBQXNFd0ssV0FBVyxHQUFHLENBQUMsQ0FBSixHQUFRLENBQXpGLENBQXJCO0FBQ0Q7QUFDRjtBQUNGO0FBQ0Y7QUFDRixLQTlkRDtBQUFBLFFBK2RJb0UsZUFBZSxHQUFHLFNBQVNBLGVBQVQsR0FBMkI7QUFDL0MvYSxNQUFBQSxJQUFJLENBQUM0WixVQUFMLEdBQWtCLEtBQWxCOztBQUVBNU8sTUFBQUEsY0FBYyxDQUFDaEwsSUFBRCxFQUFPLGVBQVAsRUFBd0IsaUJBQXhCLENBQWQ7QUFDRCxLQW5lRDtBQUFBLFFBb2VJZ2IsZ0JBQWdCLEdBQUcsU0FBU0EsZ0JBQVQsR0FBNEI7QUFDakRoYixNQUFBQSxJQUFJLENBQUM0WixVQUFMLEdBQWtCLEtBQWxCO0FBQ0QsS0F0ZUQ7QUFBQSxRQXVlSXFCLE9BQU8sR0FBRyxTQUFTQSxPQUFULENBQWlCdEgsT0FBakIsRUFBMEI5RixpQkFBMUIsRUFBNkM7QUFDekQsVUFBSUQsSUFBSixFQUFVZ04sU0FBVixFQUFxQk0sS0FBckIsRUFBNEJDLGtCQUE1Qjs7QUFFQSxVQUFJeEgsT0FBTyxJQUFJL1IsYUFBZixFQUE4QjtBQUM1QixZQUFJK1IsT0FBTyxLQUFLLElBQWhCLEVBQXNCO0FBQ3BCL0YsVUFBQUEsSUFBSSxHQUFHMUMsSUFBSSxDQUFDMEMsSUFBTCxJQUFhMUMsSUFBSSxDQUFDMlAsUUFBbEIsSUFBOEIsRUFBckM7QUFDQUQsVUFBQUEsU0FBUyxHQUFHL1gsUUFBUSxDQUFDK0ssSUFBRCxDQUFSLElBQWtCekwsV0FBVyxDQUFDeUwsSUFBRCxDQUF6QztBQUNBK0YsVUFBQUEsT0FBTyxHQUFHO0FBQ1J5SCxZQUFBQSxVQUFVLEVBQUUsQ0FBQ2xRLElBQUksQ0FBQ21RLGVBQUwsSUFBd0JuUSxJQUFJLENBQUNrUSxVQUE3QixJQUEyQyxJQUE1QyxLQUFxRHJHLFlBQVksR0FBRyxFQUFILEdBQVEsQ0FBekU7QUFESixXQUFWOztBQUlBLGNBQUlBLFlBQUosRUFBa0I7QUFDaEJwQixZQUFBQSxPQUFPLENBQUNVLFFBQVIsR0FBbUIzRyxhQUFhLENBQUMxTixJQUFELEVBQU80YSxTQUFTLEdBQUdoTixJQUFILEdBQVVBLElBQUksQ0FBQ3lHLFFBQS9CLEVBQXlDcEksSUFBekMsRUFBK0NILElBQS9DLEVBQXFELENBQXJELEVBQXdEK0IsaUJBQXhELENBQWhDO0FBQ0QsV0FGRCxNQUVPO0FBQ0wsZ0JBQUlxSCxNQUFKLEVBQVk7QUFDVnZCLGNBQUFBLE9BQU8sQ0FBQ3FCLEtBQUQsQ0FBUCxHQUFpQnRILGFBQWEsQ0FBQzFOLElBQUQsRUFBTzRhLFNBQVMsR0FBR2hOLElBQUgsR0FBVUEsSUFBSSxDQUFDa04sTUFBTCxJQUFlbE4sSUFBSSxDQUFDMUUsQ0FBcEIsSUFBeUIwRSxJQUFJLENBQUMzRCxJQUF4RCxFQUE4RGdDLElBQTlELEVBQW9FSCxJQUFwRSxFQUEwRTZLLFdBQVcsR0FBRyxDQUFDLENBQUosR0FBUSxDQUE3RixFQUFnRzlJLGlCQUFpQixJQUFJN04sSUFBSSxDQUFDMlUsVUFBTCxLQUFvQixHQUF6SSxDQUE5QjtBQUNEOztBQUVELGdCQUFJUSxNQUFKLEVBQVk7QUFDVnhCLGNBQUFBLE9BQU8sQ0FBQ3NCLEtBQUQsQ0FBUCxHQUFpQnZILGFBQWEsQ0FBQzFOLElBQUQsRUFBTzRhLFNBQVMsR0FBR2hOLElBQUgsR0FBVUEsSUFBSSxDQUFDa04sTUFBTCxJQUFlbE4sSUFBSSxDQUFDekUsQ0FBcEIsSUFBeUJ5RSxJQUFJLENBQUMxRCxHQUF4RCxFQUE2RGlDLElBQTdELEVBQW1FSCxJQUFuRSxFQUF5RTJLLFdBQVcsR0FBRyxDQUFDLENBQUosR0FBUSxDQUE1RixFQUErRjlJLGlCQUFpQixJQUFJN04sSUFBSSxDQUFDMlUsVUFBTCxLQUFvQixHQUF4SSxDQUE5QjtBQUNEOztBQUVELGdCQUFJL0csSUFBSSxDQUFDa04sTUFBTCxJQUFlalksUUFBUSxDQUFDK0ssSUFBRCxDQUFSLElBQWtCdkwsU0FBUyxDQUFDdUwsSUFBSSxDQUFDLENBQUQsQ0FBTCxDQUE5QyxFQUF5RDtBQUN2RCtGLGNBQUFBLE9BQU8sQ0FBQzJILFdBQVIsR0FBc0J0RyxLQUFLLEdBQUcsR0FBUixHQUFjQyxLQUFwQztBQUNBdEIsY0FBQUEsT0FBTyxDQUFDd0csTUFBUixHQUFpQnZNLElBQUksQ0FBQ3VNLE1BQXRCLENBRnVELENBRXpCO0FBQy9CO0FBQ0Y7QUFDRjs7QUFFRG5hLFFBQUFBLElBQUksQ0FBQzRaLFVBQUwsR0FBa0IsSUFBbEI7QUFDQXVCLFFBQUFBLGtCQUFrQixHQUFHLENBQUMzRyxLQUFLLENBQUN0SixJQUFJLENBQUNpUSxrQkFBTixDQUFOLEdBQWtDalEsSUFBSSxDQUFDaVEsa0JBQXZDLEdBQTREalEsSUFBSSxDQUFDcUosY0FBTCxLQUF3QixDQUF4QixHQUE0QixDQUE1QixHQUFnQyxJQUFJdlUsSUFBSSxDQUFDdVUsY0FBVCxHQUEwQixHQUEzSTs7QUFFQSxZQUFJLENBQUNaLE9BQU8sQ0FBQ3hOLFFBQWIsRUFBdUI7QUFDckJ3TixVQUFBQSxPQUFPLENBQUN4TixRQUFSLEdBQW1CO0FBQ2pCNEMsWUFBQUEsR0FBRyxFQUFFcEcsSUFBSSxDQUFDb0csR0FBTCxDQUFTbUMsSUFBSSxDQUFDcVEsV0FBTCxJQUFvQixDQUE3QixFQUFnQyxpQkFBaUJyUSxJQUFqQixHQUF3QkEsSUFBSSxDQUFDc1EsV0FBN0IsR0FBMkMsQ0FBM0UsQ0FEWTtBQUVqQjNQLFlBQUFBLEdBQUcsRUFBRSxDQUFDMkksS0FBSyxDQUFDdEosSUFBSSxDQUFDcVEsV0FBTixDQUFOLEdBQTJCclEsSUFBSSxDQUFDcVEsV0FBaEMsR0FBOENKLGtCQUFrQixLQUFLLENBQXZCLElBQTRCOVksU0FBUyxDQUFDc1IsT0FBRCxDQUFULElBQXNCQSxPQUFPLENBQUN5SCxVQUFSLEdBQXFCLElBQXZFLEdBQThFLENBQTlFLEdBQWtGLEdBRnBIO0FBR2pCSyxZQUFBQSxTQUFTLEVBQUVOO0FBSE0sV0FBbkI7QUFLRDs7QUFFRG5iLFFBQUFBLElBQUksQ0FBQ2tiLEtBQUwsR0FBYUEsS0FBSyxHQUFHdGEsSUFBSSxDQUFDb0YsRUFBTCxDQUFRMlEsV0FBVyxJQUFJbFAsTUFBdkIsRUFBK0I7QUFDbERrTSxVQUFBQSxPQUFPLEVBQUVBLE9BRHlDO0FBRWxEdE4sVUFBQUEsSUFBSSxFQUFFLFlBRjRDO0FBR2xERCxVQUFBQSxVQUFVLEVBQUUyVSxlQUhzQztBQUlsRFcsVUFBQUEsV0FBVyxFQUFFVixnQkFKcUM7QUFLbERXLFVBQUFBLFFBQVEsRUFBRXpRLElBQUksQ0FBQzBRLFFBQUwsR0FBZ0I1USxjQUFoQixHQUFpQ3VPLE1BTE87QUFNbERzQyxVQUFBQSxjQUFjLEVBQUUzUSxJQUFJLENBQUMwUSxRQUFMLEdBQWdCLENBQUM1YixJQUFELEVBQU8sZUFBUCxFQUF3QixlQUF4QixDQUFoQixHQUEyRDROLElBQUksSUFBSUEsSUFBSSxDQUFDdU0sTUFBYixHQUFzQixDQUFDLEtBQUQsRUFBUSxJQUFSLENBQXRCLEdBQXNDO0FBTi9ELFNBQS9CLENBQXJCOztBQVNBLFlBQUksQ0FBQ2pQLElBQUksQ0FBQzBRLFFBQVYsRUFBb0I7QUFDbEIsY0FBSWpGLFdBQUosRUFBaUI7QUFDZkEsWUFBQUEsV0FBVyxDQUFDM0YsS0FBWixHQUFvQixJQUFwQixDQURlLENBQ1c7QUFDM0I7O0FBRURrSyxVQUFBQSxLQUFLLENBQUMzQyxNQUFOLENBQWEsR0FBYixFQUFrQixJQUFsQixFQUF3QixJQUF4QixFQUxrQixDQUthOztBQUUvQmdCLFVBQUFBLE1BQU0sQ0FBQyxJQUFELEVBQU8sSUFBUCxDQUFOO0FBQ0F2WixVQUFBQSxJQUFJLENBQUM4YixJQUFMLEdBQVk5YixJQUFJLENBQUNrSixDQUFqQjtBQUNBbEosVUFBQUEsSUFBSSxDQUFDK2IsSUFBTCxHQUFZL2IsSUFBSSxDQUFDbUosQ0FBakI7O0FBRUEsY0FBSTRMLFlBQUosRUFBa0I7QUFDaEIvVSxZQUFBQSxJQUFJLENBQUNnYyxXQUFMLEdBQW1CaGMsSUFBSSxDQUFDa0osQ0FBeEI7QUFDRDs7QUFFRGdTLFVBQUFBLEtBQUssQ0FBQ2UsSUFBTixDQUFXLENBQVg7QUFDQTFDLFVBQUFBLE1BQU0sQ0FBQyxJQUFELEVBQU8sSUFBUCxDQUFOOztBQUVBLGNBQUk1QyxXQUFKLEVBQWlCO0FBQ2ZBLFlBQUFBLFdBQVcsQ0FBQzNGLEtBQVosR0FBb0IsS0FBcEIsQ0FEZSxDQUNZO0FBQzVCO0FBQ0Y7QUFDRixPQXBFRCxNQW9FTyxJQUFJZ0csU0FBSixFQUFlO0FBQ3BCaFgsUUFBQUEsSUFBSSxDQUFDa2MsV0FBTDtBQUNEO0FBQ0YsS0FqakJEO0FBQUEsUUFrakJJQyxZQUFZLEdBQUcsU0FBU0EsWUFBVCxDQUFzQkMsVUFBdEIsRUFBa0M7QUFDbkQsVUFBSUMsS0FBSyxHQUFHNVAsTUFBWjtBQUFBLFVBQ0k5SCxDQURKO0FBRUE4SCxNQUFBQSxNQUFNLEdBQUcvTCwyRUFBZSxDQUFDK0csTUFBTSxDQUFDYyxVQUFSLEVBQW9CLElBQXBCLENBQXhCOztBQUVBLFVBQUk2VCxVQUFVLElBQUlwYyxJQUFJLENBQUN3VCxTQUFuQixJQUFnQyxDQUFDL0csTUFBTSxDQUFDNlAsTUFBUCxDQUFjRCxLQUFLLElBQUksSUFBSTFiLGdFQUFKLEVBQXZCLENBQXJDLEVBQTZFO0FBQzNFO0FBQ0FnRSxRQUFBQSxDQUFDLEdBQUcwWCxLQUFLLENBQUNFLE9BQU4sR0FBZ0JqUixLQUFoQixDQUFzQjtBQUN4QnBDLFVBQUFBLENBQUMsRUFBRTBOLGFBRHFCO0FBRXhCek4sVUFBQUEsQ0FBQyxFQUFFME47QUFGcUIsU0FBdEIsQ0FBSjtBQUlBcEssUUFBQUEsTUFBTSxDQUFDbkIsS0FBUCxDQUFhM0csQ0FBYixFQUFnQkEsQ0FBaEI7QUFDQWlTLFFBQUFBLGFBQWEsR0FBR2pTLENBQUMsQ0FBQ3VFLENBQWxCO0FBQ0EyTixRQUFBQSxhQUFhLEdBQUdsUyxDQUFDLENBQUN3RSxDQUFsQjtBQUNEOztBQUVELFVBQUlzRCxNQUFNLENBQUM2UCxNQUFQLENBQWMzWSxlQUFkLENBQUosRUFBb0M7QUFDbEM7QUFDQThJLFFBQUFBLE1BQU0sR0FBRyxJQUFUO0FBQ0Q7QUFDRixLQXRrQkQ7QUFBQSxRQXVrQkkrUCxvQkFBb0IsR0FBRyxTQUFTQSxvQkFBVCxHQUFnQztBQUN6RCxVQUFJekMsYUFBYSxHQUFHLElBQUkvWixJQUFJLENBQUN1VSxjQUE3QjtBQUFBLFVBQ0lrSSxPQUFPLEdBQUduRyxPQUFPLEdBQUdyTyxpQkFBaUIsQ0FBQ3dPLFFBQUQsQ0FBcEIsR0FBaUMsQ0FEdEQ7QUFBQSxVQUVJaUcsT0FBTyxHQUFHcEcsT0FBTyxHQUFHM08sZ0JBQWdCLENBQUM4TyxRQUFELENBQW5CLEdBQWdDLENBRnJEO0FBQUEsVUFHSWtHLFlBSEo7QUFBQSxVQUlJelQsQ0FKSjtBQUFBLFVBS0lDLENBTEo7QUFNQWdULE1BQUFBLFlBQVksQ0FBQyxLQUFELENBQVo7QUFDQTlQLE1BQUFBLE9BQU8sQ0FBQ25ELENBQVIsR0FBWWxKLElBQUksQ0FBQzZZLFFBQUwsR0FBZ0I0RCxPQUE1QjtBQUNBcFEsTUFBQUEsT0FBTyxDQUFDbEQsQ0FBUixHQUFZbkosSUFBSSxDQUFDOFksUUFBTCxHQUFnQjRELE9BQTVCO0FBQ0FqUSxNQUFBQSxNQUFNLElBQUlBLE1BQU0sQ0FBQ25CLEtBQVAsQ0FBYWUsT0FBYixFQUFzQkEsT0FBdEIsQ0FBVjtBQUNBdUssTUFBQUEsYUFBYSxHQUFHdkssT0FBTyxDQUFDbkQsQ0FBeEIsQ0FYeUQsQ0FXOUI7O0FBRTNCMk4sTUFBQUEsYUFBYSxHQUFHeEssT0FBTyxDQUFDbEQsQ0FBeEI7O0FBRUEsVUFBSW1PLEtBQUosRUFBVztBQUNUNkIsUUFBQUEsa0JBQWtCLENBQUNuWixJQUFJLENBQUM2WSxRQUFOLEVBQWdCN1ksSUFBSSxDQUFDOFksUUFBckIsQ0FBbEI7QUFDQVAsUUFBQUEsTUFBTSxDQUFDLElBQUQsQ0FBTjtBQUNEOztBQUVESCxNQUFBQSxXQUFXLEdBQUcxWCwyRUFBZSxDQUFDK0csTUFBRCxDQUE3Qjs7QUFFQSxVQUFJa1AsV0FBSixFQUFpQjtBQUNmOEQsUUFBQUEsZUFBZTtBQUNmMUQsUUFBQUEsYUFBYSxHQUFHSixXQUFXLENBQUN6TSxHQUFaLEVBQWhCO0FBQ0E0TSxRQUFBQSxhQUFhLEdBQUdILFdBQVcsQ0FBQzFNLElBQVosRUFBaEI7QUFDRCxPQUpELE1BSU87QUFDTDtBQUNBLFlBQUkyUyxVQUFVLEVBQWQsRUFBa0I7QUFDaEJyRCxVQUFBQSxNQUFNLENBQUMsSUFBRCxFQUFPLElBQVAsQ0FBTjtBQUNBa0IsVUFBQUEsZUFBZTtBQUNoQixTQUhELE1BR087QUFDTHphLFVBQUFBLElBQUksQ0FBQ2tjLFdBQUw7QUFDRDs7QUFFRCxZQUFJbkgsWUFBSixFQUFrQjtBQUNoQjRILFVBQUFBLFlBQVksR0FBR2xWLE1BQU0sQ0FBQytFLGVBQVAsR0FBeUIsQ0FBQzBKLE9BQU8sQ0FBQzJHLE9BQVIsR0FBa0JwVixNQUFNLENBQUM4RSxPQUFQLEdBQWlCckQsQ0FBcEMsRUFBdUNnTixPQUFPLENBQUM0RyxPQUFSLEdBQWtCclYsTUFBTSxDQUFDOEUsT0FBUCxHQUFpQnBELENBQTFFLENBQXpCLEdBQXdHLENBQUNRLGlCQUFpQixDQUFDbEMsTUFBRCxDQUFqQixDQUEwQmhGLG9CQUExQixLQUFtRCxLQUFwRCxFQUEyRDJRLEtBQTNELENBQWlFLEdBQWpFLENBQXZIO0FBQ0FpRSxVQUFBQSxjQUFjLEdBQUdyWCxJQUFJLENBQUNxWCxjQUFMLEdBQXNCM1csMkVBQWUsQ0FBQytHLE1BQUQsQ0FBZixDQUF3QjZELEtBQXhCLENBQThCO0FBQ25FcEMsWUFBQUEsQ0FBQyxFQUFFa0UsVUFBVSxDQUFDdVAsWUFBWSxDQUFDLENBQUQsQ0FBYixDQUFWLElBQStCLENBRGlDO0FBRW5FeFQsWUFBQUEsQ0FBQyxFQUFFaUUsVUFBVSxDQUFDdVAsWUFBWSxDQUFDLENBQUQsQ0FBYixDQUFWLElBQStCO0FBRmlDLFdBQTlCLENBQXZDO0FBSUFwRCxVQUFBQSxNQUFNLENBQUMsSUFBRCxFQUFPLElBQVAsQ0FBTjtBQUNBclEsVUFBQUEsQ0FBQyxHQUFHbEosSUFBSSxDQUFDNlksUUFBTCxHQUFnQnhCLGNBQWMsQ0FBQ25PLENBQS9CLEdBQW1DdVQsT0FBdkM7QUFDQXRULFVBQUFBLENBQUMsR0FBR2tPLGNBQWMsQ0FBQ2xPLENBQWYsR0FBbUJuSixJQUFJLENBQUM4WSxRQUF4QixHQUFtQzRELE9BQXZDO0FBQ0E1RixVQUFBQSxhQUFhLEdBQUc5VyxJQUFJLENBQUNrSixDQUFyQixDQVRnQixDQVNROztBQUV4QjZOLFVBQUFBLGFBQWEsR0FBRy9XLElBQUksQ0FBQ21KLENBQUwsR0FBU3hHLElBQUksQ0FBQ29hLEtBQUwsQ0FBVzVULENBQVgsRUFBY0QsQ0FBZCxJQUFtQjFGLFFBQTVDO0FBQ0QsU0FaRCxNQVlPO0FBQ0w7QUFDQTtBQUNBO0FBQ0F1VCxVQUFBQSxhQUFhLEdBQUdSLFlBQVksQ0FBQ3RCLEtBQUQsRUFBUSxJQUFSLENBQTVCLENBSkssQ0FJc0M7O0FBRTNDNkIsVUFBQUEsYUFBYSxHQUFHUCxZQUFZLENBQUN2QixLQUFELEVBQVEsSUFBUixDQUE1QjtBQUNEO0FBQ0Y7O0FBRUQsVUFBSWdDLFNBQVMsSUFBSStDLGFBQWpCLEVBQWdDO0FBQzlCLFlBQUlqRCxhQUFhLEdBQUc3SyxJQUFwQixFQUEwQjtBQUN4QjZLLFVBQUFBLGFBQWEsR0FBRzdLLElBQUksR0FBRyxDQUFDNkssYUFBYSxHQUFHN0ssSUFBakIsSUFBeUI4TixhQUFoRDtBQUNELFNBRkQsTUFFTyxJQUFJakQsYUFBYSxHQUFHaEwsSUFBcEIsRUFBMEI7QUFDL0JnTCxVQUFBQSxhQUFhLEdBQUdoTCxJQUFJLEdBQUcsQ0FBQ0EsSUFBSSxHQUFHZ0wsYUFBUixJQUF5QmlELGFBQWhEO0FBQ0Q7O0FBRUQsWUFBSSxDQUFDaEYsWUFBTCxFQUFtQjtBQUNqQixjQUFJZ0MsYUFBYSxHQUFHNUssSUFBcEIsRUFBMEI7QUFDeEI0SyxZQUFBQSxhQUFhLEdBQUc1SyxJQUFJLEdBQUcsQ0FBQzRLLGFBQWEsR0FBRzVLLElBQWpCLElBQXlCNE4sYUFBaEQ7QUFDRCxXQUZELE1BRU8sSUFBSWhELGFBQWEsR0FBRy9LLElBQXBCLEVBQTBCO0FBQy9CK0ssWUFBQUEsYUFBYSxHQUFHL0ssSUFBSSxHQUFHLENBQUNBLElBQUksR0FBRytLLGFBQVIsSUFBeUJnRCxhQUFoRDtBQUNEO0FBQ0Y7QUFDRjs7QUFFRC9aLE1BQUFBLElBQUksQ0FBQ2dkLE1BQUwsR0FBY2xHLGFBQWEsR0FBR3BVLE1BQU0sQ0FBQ29VLGFBQUQsQ0FBcEM7QUFDQTlXLE1BQUFBLElBQUksQ0FBQ2lkLE1BQUwsR0FBY2xHLGFBQWEsR0FBR3JVLE1BQU0sQ0FBQ3FVLGFBQUQsQ0FBcEM7QUFDRCxLQWxwQkQ7QUFBQSxRQW1wQkk2RixVQUFVLEdBQUcsU0FBU0EsVUFBVCxHQUFzQjtBQUNyQyxhQUFPNWMsSUFBSSxDQUFDa2IsS0FBTCxJQUFjbGIsSUFBSSxDQUFDa2IsS0FBTCxDQUFXZ0MsUUFBWCxFQUFyQjtBQUNELEtBcnBCRDtBQUFBLFFBc3BCSUMsaUJBQWlCLEdBQUcsU0FBU0EsaUJBQVQsR0FBNkI7QUFDbkQsVUFBSWpjLGVBQWUsQ0FBQ3FILFVBQWhCLElBQThCLENBQUNxVSxVQUFVLEVBQXpDLElBQStDLENBQUM1YyxJQUFJLENBQUN5WSxVQUF6RCxFQUFxRTtBQUNuRTtBQUNBdlgsUUFBQUEsZUFBZSxDQUFDcUgsVUFBaEIsQ0FBMkJnSixXQUEzQixDQUF1Q3JRLGVBQXZDO0FBQ0Q7QUFDRixLQTNwQkQ7QUFBQSxRQTRwQkk7QUFDSmtjLElBQUFBLE9BQU8sR0FBRyxTQUFTQSxPQUFULENBQWlCamEsQ0FBakIsRUFBb0J1TixLQUFwQixFQUEyQjtBQUNuQyxVQUFJMUwsQ0FBSjs7QUFFQSxVQUFJLENBQUMwUixPQUFELElBQVkxVyxJQUFJLENBQUN3VCxTQUFqQixJQUE4QixDQUFDclEsQ0FBL0IsSUFBb0MsQ0FBQ0EsQ0FBQyxDQUFDRixJQUFGLEtBQVcsV0FBWCxJQUEwQkUsQ0FBQyxDQUFDRixJQUFGLEtBQVcsYUFBdEMsS0FBd0QsQ0FBQ3lOLEtBQXpELElBQWtFOU0sUUFBUSxLQUFLcVMsU0FBYixHQUF5QixFQUEzRixJQUFpR3pVLGlCQUFpQixDQUFDeEIsSUFBSSxDQUFDd0wsWUFBTCxDQUFrQnZJLElBQW5CLENBQTFKLEVBQW9MO0FBQ2xMO0FBQ0FrVixRQUFBQSxtQkFBbUIsSUFBSWhWLENBQXZCLElBQTRCdVQsT0FBNUIsSUFBdUMzUCxlQUFlLENBQUM1RCxDQUFELENBQXRELENBRmtMLENBRXZIOztBQUUzRDtBQUNEOztBQUVEMFUsTUFBQUEsV0FBVyxHQUFHK0UsVUFBVSxFQUF4QjtBQUNBNWMsTUFBQUEsSUFBSSxDQUFDd0wsWUFBTCxHQUFvQnJJLENBQXBCOztBQUVBLFVBQUkzQixpQkFBaUIsQ0FBQzJCLENBQUMsQ0FBQ0YsSUFBSCxDQUFyQixFQUErQjtBQUM3QjtBQUNBMlUsUUFBQUEsZ0JBQWdCLEdBQUcsQ0FBQ3pVLENBQUMsQ0FBQ0YsSUFBRixDQUFPd1AsT0FBUCxDQUFlLE9BQWYsQ0FBRCxHQUEyQnRQLENBQUMsQ0FBQ2thLGFBQUYsSUFBbUJsYSxDQUFDLENBQUNzRSxNQUFoRCxHQUF5RGdQLFFBQTVFLENBRjZCLENBRXlEOztBQUV0RmxRLFFBQUFBLFlBQVksQ0FBQ3FSLGdCQUFELEVBQW1CLFVBQW5CLEVBQStCMEYsU0FBL0IsQ0FBWjs7QUFFQS9XLFFBQUFBLFlBQVksQ0FBQ3FSLGdCQUFELEVBQW1CLFdBQW5CLEVBQWdDMkYsTUFBaEMsQ0FBWixDQU42QixDQU13Qjs7O0FBR3JEaFgsUUFBQUEsWUFBWSxDQUFDcVIsZ0JBQUQsRUFBbUIsYUFBbkIsRUFBa0MwRixTQUFsQyxDQUFaOztBQUVBL1csUUFBQUEsWUFBWSxDQUFDa1EsUUFBRCxFQUFXLFlBQVgsRUFBeUIvTyxxQkFBekIsQ0FBWjtBQUNELE9BWkQsTUFZTztBQUNMa1EsUUFBQUEsZ0JBQWdCLEdBQUcsSUFBbkI7O0FBRUFyUixRQUFBQSxZQUFZLENBQUNrUSxRQUFELEVBQVcsV0FBWCxFQUF3QjhHLE1BQXhCLENBQVosQ0FISyxDQUd3Qzs7QUFFOUM7O0FBRUR4RixNQUFBQSxhQUFhLEdBQUcsSUFBaEI7O0FBRUEsVUFBSSxDQUFDalcsZ0JBQUQsSUFBcUIsQ0FBQzhWLGdCQUExQixFQUE0QztBQUMxQ3JSLFFBQUFBLFlBQVksQ0FBQ2tRLFFBQUQsRUFBVyxTQUFYLEVBQXNCNkcsU0FBdEIsQ0FBWjs7QUFFQW5hLFFBQUFBLENBQUMsSUFBSUEsQ0FBQyxDQUFDc0UsTUFBUCxJQUFpQmxCLFlBQVksQ0FBQ3BELENBQUMsQ0FBQ3NFLE1BQUgsRUFBVyxTQUFYLEVBQXNCNlYsU0FBdEIsQ0FBN0IsQ0FIMEMsQ0FHcUI7QUFDaEU7O0FBRUQzRixNQUFBQSxVQUFVLEdBQUc1QixXQUFXLENBQUM5SCxJQUFaLENBQWlCak8sSUFBakIsRUFBdUJtRCxDQUFDLENBQUNzRSxNQUF6QixLQUFvQ3lELElBQUksQ0FBQ3NTLGNBQUwsS0FBd0IsS0FBNUQsSUFBcUUsQ0FBQzlNLEtBQW5GOztBQUVBLFVBQUlpSCxVQUFKLEVBQWdCO0FBQ2RwUixRQUFBQSxZQUFZLENBQUNwRCxDQUFDLENBQUNzRSxNQUFILEVBQVcsUUFBWCxFQUFxQjZWLFNBQXJCLENBQVosQ0FEYyxDQUMrQjs7O0FBRzdDdFMsUUFBQUEsY0FBYyxDQUFDaEwsSUFBRCxFQUFPLFdBQVAsRUFBb0IsYUFBcEIsQ0FBZDs7QUFFQWdMLFFBQUFBLGNBQWMsQ0FBQ2hMLElBQUQsRUFBTyxPQUFQLEVBQWdCLFNBQWhCLENBQWQ7O0FBRUF3TyxRQUFBQSxjQUFjLENBQUM2RyxRQUFELEVBQVcsSUFBWCxDQUFkLENBUmMsQ0FRa0I7OztBQUdoQzhDLFFBQUFBLG1CQUFtQixHQUFHLEtBQXRCO0FBQ0E7QUFDRDs7QUFFREwsTUFBQUEseUJBQXlCLEdBQUcsQ0FBQ0YsZ0JBQUQsSUFBcUIxQyxNQUFNLEtBQUtDLE1BQWhDLElBQTBDblYsSUFBSSxDQUFDa0wsSUFBTCxDQUFVNE0seUJBQVYsS0FBd0MsS0FBbEYsSUFBMkY5WCxJQUFJLENBQUNrTCxJQUFMLENBQVV1UyxnQkFBVixJQUE4QnRhLENBQTlCLEtBQW9DQSxDQUFDLENBQUN1YSxPQUFGLElBQWF2YSxDQUFDLENBQUN3YSxLQUFGLEdBQVUsQ0FBM0QsQ0FBM0YsR0FBMkosS0FBM0osR0FBbUt6SSxNQUFNLEdBQUcsR0FBSCxHQUFTLEdBQTlNLENBekRtQyxDQXlEZ0w7O0FBRW5OaUQsTUFBQUEsbUJBQW1CLEdBQUcsQ0FBQ0wseUJBQUQsSUFBOEIsQ0FBQzlYLElBQUksQ0FBQzRVLGlCQUExRDs7QUFFQSxVQUFJdUQsbUJBQUosRUFBeUI7QUFDdkJwUixRQUFBQSxlQUFlLENBQUM1RCxDQUFELENBQWY7O0FBRUFvRCxRQUFBQSxZQUFZLENBQUMxRixJQUFELEVBQU8sa0JBQVAsRUFBMkJrRyxlQUEzQixDQUFaLENBSHVCLENBR2tDOztBQUUxRDs7QUFFRCxVQUFJNUQsQ0FBQyxDQUFDeWEsY0FBTixFQUFzQjtBQUNwQjtBQUNBemEsUUFBQUEsQ0FBQyxHQUFHZ1UsS0FBSyxHQUFHaFUsQ0FBQyxDQUFDeWEsY0FBRixDQUFpQixDQUFqQixDQUFaO0FBQ0F4RyxRQUFBQSxPQUFPLEdBQUdqVSxDQUFDLENBQUNtRSxVQUFaO0FBQ0QsT0FKRCxNQUlPLElBQUluRSxDQUFDLENBQUMwYSxTQUFOLEVBQWlCO0FBQ3RCekcsUUFBQUEsT0FBTyxHQUFHalUsQ0FBQyxDQUFDMGEsU0FBWixDQURzQixDQUNDO0FBQ3hCLE9BRk0sTUFFQTtBQUNMMUcsUUFBQUEsS0FBSyxHQUFHQyxPQUFPLEdBQUcsSUFBbEI7QUFDRDs7QUFFRDNWLE1BQUFBLFVBQVU7O0FBRVYrRCxNQUFBQSxpQkFBaUIsQ0FBQytTLE1BQUQsQ0FBakIsQ0FoRm1DLENBZ0ZSOzs7QUFHM0IxQixNQUFBQSxhQUFhLEdBQUc3VyxJQUFJLENBQUM4WSxRQUFMLEdBQWdCM1YsQ0FBQyxDQUFDMkgsS0FBbEMsQ0FuRm1DLENBbUZNOztBQUV6QzhMLE1BQUFBLGFBQWEsR0FBRzVXLElBQUksQ0FBQzZZLFFBQUwsR0FBZ0IxVixDQUFDLENBQUMwSCxLQUFsQzs7QUFFQUcsTUFBQUEsY0FBYyxDQUFDaEwsSUFBRCxFQUFPLFdBQVAsRUFBb0IsYUFBcEIsQ0FBZDs7QUFFQSxVQUFJOFgseUJBQXlCLElBQUk5WCxJQUFJLENBQUMwVSxVQUF0QyxFQUFrRDtBQUNoRDFMLFFBQUFBLGlCQUFpQixDQUFDdkIsTUFBTSxDQUFDYyxVQUFSLENBQWpCO0FBQ0Q7O0FBRUQsVUFBSWQsTUFBTSxDQUFDYyxVQUFQLElBQXFCdkksSUFBSSxDQUFDMFUsVUFBMUIsSUFBd0MsQ0FBQ2lDLFdBQXpDLElBQXdELENBQUM1QixZQUF6RCxJQUF5RXROLE1BQU0sQ0FBQ2MsVUFBUCxDQUFrQmEsYUFBM0YsSUFBNEcsQ0FBQ2xJLGVBQWUsQ0FBQ3FILFVBQTdILElBQTJJLENBQUNkLE1BQU0sQ0FBQzhFLE9BQXZKLEVBQWdLO0FBQzlKO0FBQ0FyTCxRQUFBQSxlQUFlLENBQUNxQyxLQUFoQixDQUFzQjRHLEtBQXRCLEdBQThCMUMsTUFBTSxDQUFDYyxVQUFQLENBQWtCdUgsV0FBbEIsR0FBZ0MsSUFBOUQ7QUFDQXJJLFFBQUFBLE1BQU0sQ0FBQ2MsVUFBUCxDQUFrQitJLFdBQWxCLENBQThCcFEsZUFBOUI7QUFDRDs7QUFFRHNiLE1BQUFBLG9CQUFvQjtBQUNwQnhjLE1BQUFBLElBQUksQ0FBQ2tiLEtBQUwsSUFBY2xiLElBQUksQ0FBQ2tiLEtBQUwsQ0FBVzRDLElBQVgsRUFBZDtBQUNBOWQsTUFBQUEsSUFBSSxDQUFDNFosVUFBTCxHQUFrQixLQUFsQjtBQUNBaFosTUFBQUEsSUFBSSxDQUFDa1EsWUFBTCxDQUFrQjZGLFdBQVcsSUFBSWxQLE1BQWpDLEVBQXlDK04sU0FBekMsRUFBb0QsSUFBcEQsRUF0R21DLENBc0d3Qjs7QUFFM0RtQixNQUFBQSxXQUFXLElBQUkvVixJQUFJLENBQUNrUSxZQUFMLENBQWtCckosTUFBbEIsRUFBMEI7QUFDdkN5UixRQUFBQSxRQUFRLEVBQUU7QUFENkIsT0FBMUIsRUFFWixJQUZZLENBQWYsQ0F4R21DLENBMEd6Qjs7QUFFVmxaLE1BQUFBLElBQUksQ0FBQ2tiLEtBQUwsR0FBYWxiLElBQUksQ0FBQzJVLFVBQUwsR0FBa0IsSUFBL0I7O0FBRUEsVUFBSXpKLElBQUksQ0FBQzZTLFdBQUwsSUFBb0IsQ0FBQ2hKLFlBQUQsSUFBaUIsQ0FBQzRCLFdBQWxCLElBQWlDekwsSUFBSSxDQUFDNlMsV0FBTCxLQUFxQixLQUE5RSxFQUFxRjtBQUNuRnRXLFFBQUFBLE1BQU0sQ0FBQ2xFLEtBQVAsQ0FBYXlhLE1BQWIsR0FBc0I5SixTQUFTLENBQUM4SixNQUFWLEVBQXRCO0FBQ0Q7O0FBRURoZSxNQUFBQSxJQUFJLENBQUN3VCxTQUFMLEdBQWlCLElBQWpCO0FBQ0F5RCxNQUFBQSxlQUFlLEdBQUcsQ0FBQyxFQUFFL0wsSUFBSSxDQUFDK1MsTUFBTCxJQUFlamUsSUFBSSxDQUFDb0wsVUFBTCxDQUFnQjhTLElBQWpDLENBQW5CO0FBQ0FoSCxNQUFBQSxlQUFlLEdBQUcsQ0FBQyxFQUFFaE0sSUFBSSxDQUFDcVMsTUFBTCxJQUFldmQsSUFBSSxDQUFDb0wsVUFBTCxDQUFnQitTLElBQWpDLENBQW5COztBQUVBLFVBQUlqVCxJQUFJLENBQUNxSCxNQUFMLEtBQWdCLEtBQWhCLElBQXlCckgsSUFBSSxDQUFDa1QsWUFBbEMsRUFBZ0Q7QUFDOUNwWixRQUFBQSxDQUFDLEdBQUdxUSxRQUFRLENBQUNwUSxNQUFiOztBQUVBLGVBQU8sRUFBRUQsQ0FBRixHQUFNLENBQUMsQ0FBZCxFQUFpQjtBQUNmcEUsVUFBQUEsSUFBSSxDQUFDZ08sR0FBTCxDQUFTeUcsUUFBUSxDQUFDclEsQ0FBRCxDQUFqQixFQUFzQjtBQUNwQnVOLFlBQUFBLE1BQU0sRUFBRXJILElBQUksQ0FBQ2tULFlBQUwsSUFBcUJsVCxJQUFJLENBQUNxSCxNQUExQixLQUFxQzFRLGNBQWMsS0FBSyxNQUFuQixHQUE0QixVQUE1QixHQUF5Q0EsY0FBOUU7QUFEWSxXQUF0QjtBQUdEO0FBQ0Y7O0FBRURtSixNQUFBQSxjQUFjLENBQUNoTCxJQUFELEVBQU8sT0FBUCxFQUFnQixTQUFoQixDQUFkO0FBQ0QsS0E5eEJEO0FBQUEsUUEreEJJO0FBQ0p1ZCxJQUFBQSxNQUFNLEdBQUcsU0FBU0EsTUFBVCxDQUFnQnBhLENBQWhCLEVBQW1CO0FBQzFCLFVBQUlrYixhQUFhLEdBQUdsYixDQUFwQjtBQUFBLFVBQ0lxRSxPQURKO0FBQUEsVUFFSXFSLFFBRko7QUFBQSxVQUdJQyxRQUhKO0FBQUEsVUFJSTlULENBSko7QUFBQSxVQUtJcVYsRUFMSjtBQUFBLFVBTUlDLEVBTko7O0FBUUEsVUFBSSxDQUFDNUQsT0FBRCxJQUFZaFYsZ0JBQVosSUFBZ0MsQ0FBQzFCLElBQUksQ0FBQ3dULFNBQXRDLElBQW1ELENBQUNyUSxDQUF4RCxFQUEyRDtBQUN6RGdWLFFBQUFBLG1CQUFtQixJQUFJaFYsQ0FBdkIsSUFBNEJ1VCxPQUE1QixJQUF1QzNQLGVBQWUsQ0FBQzVELENBQUQsQ0FBdEQsQ0FEeUQsQ0FDRTs7QUFFM0Q7QUFDRDs7QUFFRG5ELE1BQUFBLElBQUksQ0FBQ3dMLFlBQUwsR0FBb0JySSxDQUFwQjtBQUNBcUUsTUFBQUEsT0FBTyxHQUFHckUsQ0FBQyxDQUFDeWEsY0FBWjs7QUFFQSxVQUFJcFcsT0FBSixFQUFhO0FBQ1g7QUFDQXJFLFFBQUFBLENBQUMsR0FBR3FFLE9BQU8sQ0FBQyxDQUFELENBQVg7O0FBRUEsWUFBSXJFLENBQUMsS0FBS2dVLEtBQU4sSUFBZWhVLENBQUMsQ0FBQ21FLFVBQUYsS0FBaUI4UCxPQUFwQyxFQUE2QztBQUMzQztBQUNBcFMsVUFBQUEsQ0FBQyxHQUFHd0MsT0FBTyxDQUFDdkMsTUFBWjs7QUFFQSxpQkFBTyxFQUFFRCxDQUFGLEdBQU0sQ0FBQyxDQUFQLElBQVksQ0FBQzdCLENBQUMsR0FBR3FFLE9BQU8sQ0FBQ3hDLENBQUQsQ0FBWixFQUFpQnNDLFVBQWpCLEtBQWdDOFAsT0FBNUMsSUFBdURqVSxDQUFDLENBQUNzRSxNQUFGLEtBQWFBLE1BQTNFLEVBQW1GLENBQUUsQ0FKMUMsQ0FJMkM7OztBQUd0RixjQUFJekMsQ0FBQyxHQUFHLENBQVIsRUFBVztBQUNUO0FBQ0Q7QUFDRjtBQUNGLE9BZkQsTUFlTyxJQUFJN0IsQ0FBQyxDQUFDMGEsU0FBRixJQUFlekcsT0FBZixJQUEwQmpVLENBQUMsQ0FBQzBhLFNBQUYsS0FBZ0J6RyxPQUE5QyxFQUF1RDtBQUM1RDtBQUNBO0FBQ0Q7O0FBRUQsVUFBSVEsZ0JBQWdCLElBQUlFLHlCQUFwQixJQUFpRCxDQUFDQyxhQUF0RCxFQUFxRTtBQUNuRTtBQUNBMUwsUUFBQUEsT0FBTyxDQUFDbkQsQ0FBUixHQUFZL0YsQ0FBQyxDQUFDMEgsS0FBRixJQUFXeUwsT0FBTyxHQUFHck8saUJBQWlCLENBQUN3TyxRQUFELENBQXBCLEdBQWlDLENBQW5ELENBQVo7QUFDQXBLLFFBQUFBLE9BQU8sQ0FBQ2xELENBQVIsR0FBWWhHLENBQUMsQ0FBQzJILEtBQUYsSUFBV3dMLE9BQU8sR0FBRzNPLGdCQUFnQixDQUFDOE8sUUFBRCxDQUFuQixHQUFnQyxDQUFsRCxDQUFaO0FBQ0FoSyxRQUFBQSxNQUFNLElBQUlBLE1BQU0sQ0FBQ25CLEtBQVAsQ0FBYWUsT0FBYixFQUFzQkEsT0FBdEIsQ0FBVjtBQUNBd00sUUFBQUEsUUFBUSxHQUFHeE0sT0FBTyxDQUFDbkQsQ0FBbkI7QUFDQTRQLFFBQUFBLFFBQVEsR0FBR3pNLE9BQU8sQ0FBQ2xELENBQW5CO0FBQ0FrUixRQUFBQSxFQUFFLEdBQUcxWCxJQUFJLENBQUMyYixHQUFMLENBQVN6RixRQUFRLEdBQUdqQyxhQUFwQixDQUFMO0FBQ0EwRCxRQUFBQSxFQUFFLEdBQUczWCxJQUFJLENBQUMyYixHQUFMLENBQVN4RixRQUFRLEdBQUdqQyxhQUFwQixDQUFMOztBQUVBLFlBQUl3RCxFQUFFLEtBQUtDLEVBQVAsS0FBY0QsRUFBRSxHQUFHakYsZUFBTCxJQUF3QmtGLEVBQUUsR0FBR2xGLGVBQTNDLEtBQStEelQsVUFBVSxJQUFJbVcseUJBQXlCLEtBQUtDLGFBQS9HLEVBQThIO0FBQzVIQSxVQUFBQSxhQUFhLEdBQUdzQyxFQUFFLEdBQUdDLEVBQUwsSUFBV3BGLE1BQVgsR0FBb0IsR0FBcEIsR0FBMEIsR0FBMUM7O0FBRUEsY0FBSTRDLHlCQUF5QixJQUFJQyxhQUFhLEtBQUtELHlCQUFuRCxFQUE4RTtBQUM1RXZSLFlBQUFBLFlBQVksQ0FBQzFGLElBQUQsRUFBTyxrQkFBUCxFQUEyQmtHLGVBQTNCLENBQVosQ0FENEUsQ0FDbkI7O0FBRTFEOztBQUVELGNBQUkvRyxJQUFJLENBQUNrTCxJQUFMLENBQVVxVCxxQkFBVixLQUFvQyxLQUFwQyxJQUE2Q3JKLE1BQTdDLElBQXVEQyxNQUEzRCxFQUFtRTtBQUNqRW5WLFlBQUFBLElBQUksQ0FBQzJVLFVBQUwsR0FBa0JvRCxhQUFhLEtBQUssR0FBbEIsR0FBd0IsR0FBeEIsR0FBOEIsR0FBaEQ7QUFDQTVWLFlBQUFBLFdBQVcsQ0FBQ25DLElBQUksQ0FBQ2tMLElBQUwsQ0FBVXNULFVBQVgsQ0FBWCxJQUFxQ3hlLElBQUksQ0FBQ2tMLElBQUwsQ0FBVXNULFVBQVYsQ0FBcUJ2USxJQUFyQixDQUEwQmpPLElBQTFCLEVBQWdDcWUsYUFBaEMsQ0FBckM7QUFDRDs7QUFFRCxjQUFJMWMsVUFBVSxJQUFJbVcseUJBQXlCLEtBQUtDLGFBQWhELEVBQStEO0FBQzdEdUYsWUFBQUEsU0FBUyxDQUFDZSxhQUFELENBQVQ7QUFDQTtBQUNEO0FBQ0Y7QUFDRjs7QUFFRCxVQUFJLENBQUNyZSxJQUFJLENBQUM0VSxpQkFBTixLQUE0QixDQUFDa0QseUJBQUQsSUFBOEJDLGFBQWEsSUFBSUQseUJBQXlCLEtBQUtDLGFBQXpHLEtBQTJIc0csYUFBYSxDQUFDSSxVQUFkLEtBQTZCLEtBQTVKLEVBQW1LO0FBQ2pLMVgsUUFBQUEsZUFBZSxDQUFDc1gsYUFBRCxDQUFmOztBQUVBbEcsUUFBQUEsbUJBQW1CLEdBQUcsSUFBdEI7QUFDRCxPQUpELE1BSU8sSUFBSUEsbUJBQUosRUFBeUI7QUFDOUJBLFFBQUFBLG1CQUFtQixHQUFHLEtBQXRCO0FBQ0Q7O0FBRUQsVUFBSW5ZLElBQUksQ0FBQzBVLFVBQVQsRUFBcUI7QUFDbkJnQixRQUFBQSxxQkFBcUIsR0FBRyxJQUF4QjtBQUNEOztBQUVEeUQsTUFBQUEsa0JBQWtCLENBQUNoVyxDQUFDLENBQUMwSCxLQUFILEVBQVUxSCxDQUFDLENBQUMySCxLQUFaLEVBQW1Cb00sZUFBbkIsQ0FBbEI7QUFDRCxLQWozQkQ7QUFBQSxRQWszQklpQyxrQkFBa0IsR0FBRyxTQUFTQSxrQkFBVCxDQUE0Qk4sUUFBNUIsRUFBc0NDLFFBQXRDLEVBQWdENEYsWUFBaEQsRUFBOEQ7QUFDckYsVUFBSUMsYUFBYSxHQUFHLElBQUkzZSxJQUFJLENBQUNzVSxjQUE3QjtBQUFBLFVBQ0l5RixhQUFhLEdBQUcsSUFBSS9aLElBQUksQ0FBQ3VVLGNBRDdCO0FBQUEsVUFFSXFLLFlBQVksR0FBRzVlLElBQUksQ0FBQzZZLFFBRnhCO0FBQUEsVUFHSWdHLFlBQVksR0FBRzdlLElBQUksQ0FBQzhZLFFBSHhCO0FBQUEsVUFJSWdHLGlCQUFpQixHQUFHL0gsYUFKeEI7QUFBQSxVQUtJZ0ksS0FBSyxHQUFHL2UsSUFBSSxDQUFDa0osQ0FMakI7QUFBQSxVQU1JOFYsS0FBSyxHQUFHaGYsSUFBSSxDQUFDbUosQ0FOakI7QUFBQSxVQU9JOFYsUUFBUSxHQUFHamYsSUFBSSxDQUFDOGIsSUFQcEI7QUFBQSxVQVFJb0QsUUFBUSxHQUFHbGYsSUFBSSxDQUFDK2IsSUFScEI7QUFBQSxVQVNJb0QsZUFBZSxHQUFHbmYsSUFBSSxDQUFDZ2MsV0FUM0I7QUFBQSxVQVVJb0QsU0FBUyxHQUFHOUgsS0FWaEI7QUFBQSxVQVdJK0gsT0FYSjtBQUFBLFVBWUlDLE9BWko7QUFBQSxVQWFJcFcsQ0FiSjtBQUFBLFVBY0lDLENBZEo7QUFBQSxVQWVJeUgsR0FmSjtBQUFBLFVBZ0JJMk8sSUFoQko7QUFpQkF2ZixNQUFBQSxJQUFJLENBQUM2WSxRQUFMLEdBQWdCQSxRQUFoQjtBQUNBN1ksTUFBQUEsSUFBSSxDQUFDOFksUUFBTCxHQUFnQkEsUUFBaEI7O0FBRUEsVUFBSXhDLE9BQUosRUFBYTtBQUNYdUMsUUFBQUEsUUFBUSxJQUFJNVEsaUJBQWlCLENBQUN3TyxRQUFELENBQTdCO0FBQ0FxQyxRQUFBQSxRQUFRLElBQUluUixnQkFBZ0IsQ0FBQzhPLFFBQUQsQ0FBNUI7QUFDRDs7QUFFRCxVQUFJMUIsWUFBSixFQUFrQjtBQUNoQjVMLFFBQUFBLENBQUMsR0FBR3hHLElBQUksQ0FBQ29hLEtBQUwsQ0FBVzFGLGNBQWMsQ0FBQ2xPLENBQWYsR0FBbUIyUCxRQUE5QixFQUF3Q0QsUUFBUSxHQUFHeEIsY0FBYyxDQUFDbk8sQ0FBbEUsSUFBdUUxRixRQUEzRTtBQUNBb04sUUFBQUEsR0FBRyxHQUFHNVEsSUFBSSxDQUFDbUosQ0FBTCxHQUFTQSxDQUFmOztBQUVBLFlBQUl5SCxHQUFHLEdBQUcsR0FBVixFQUFlO0FBQ2JtRyxVQUFBQSxhQUFhLElBQUksR0FBakI7QUFDQS9XLFVBQUFBLElBQUksQ0FBQ21KLENBQUwsR0FBU0EsQ0FBVDtBQUNELFNBSEQsTUFHTyxJQUFJeUgsR0FBRyxHQUFHLENBQUMsR0FBWCxFQUFnQjtBQUNyQm1HLFVBQUFBLGFBQWEsSUFBSSxHQUFqQjtBQUNBL1csVUFBQUEsSUFBSSxDQUFDbUosQ0FBTCxHQUFTQSxDQUFUO0FBQ0Q7O0FBRUQsWUFBSW5KLElBQUksQ0FBQ2tKLENBQUwsS0FBVzROLGFBQVgsSUFBNEJuVSxJQUFJLENBQUMyYixHQUFMLENBQVN2SCxhQUFhLEdBQUc1TixDQUF6QixJQUE4QmlNLGVBQTlELEVBQStFO0FBQzdFcFYsVUFBQUEsSUFBSSxDQUFDbUosQ0FBTCxHQUFTQSxDQUFUO0FBQ0FELFVBQUFBLENBQUMsR0FBRzROLGFBQWEsR0FBRyxDQUFDQyxhQUFhLEdBQUc1TixDQUFqQixJQUFzQndWLGFBQTFDO0FBQ0QsU0FIRCxNQUdPO0FBQ0x6VixVQUFBQSxDQUFDLEdBQUc0TixhQUFKO0FBQ0Q7QUFDRixPQWxCRCxNQWtCTztBQUNMLFlBQUlySyxNQUFKLEVBQVk7QUFDVjhTLFVBQUFBLElBQUksR0FBRzFHLFFBQVEsR0FBR3BNLE1BQU0sQ0FBQ3FCLENBQWxCLEdBQXNCZ0wsUUFBUSxHQUFHck0sTUFBTSxDQUFDK1MsQ0FBeEMsR0FBNEMvUyxNQUFNLENBQUN0SixDQUExRDtBQUNBMlYsVUFBQUEsUUFBUSxHQUFHRCxRQUFRLEdBQUdwTSxNQUFNLENBQUNnVCxDQUFsQixHQUFzQjNHLFFBQVEsR0FBR3JNLE1BQU0sQ0FBQ2lULENBQXhDLEdBQTRDalQsTUFBTSxDQUFDa1QsQ0FBOUQ7QUFDQTlHLFVBQUFBLFFBQVEsR0FBRzBHLElBQVg7QUFDRDs7QUFFREQsUUFBQUEsT0FBTyxHQUFHeEcsUUFBUSxHQUFHakMsYUFBckI7QUFDQXdJLFFBQUFBLE9BQU8sR0FBR3hHLFFBQVEsR0FBR2pDLGFBQXJCOztBQUVBLFlBQUkwSSxPQUFPLEdBQUdsSyxlQUFWLElBQTZCa0ssT0FBTyxHQUFHLENBQUNsSyxlQUE1QyxFQUE2RDtBQUMzRGtLLFVBQUFBLE9BQU8sR0FBRyxDQUFWO0FBQ0Q7O0FBRUQsWUFBSUQsT0FBTyxHQUFHakssZUFBVixJQUE2QmlLLE9BQU8sR0FBRyxDQUFDakssZUFBNUMsRUFBNkQ7QUFDM0RpSyxVQUFBQSxPQUFPLEdBQUcsQ0FBVjtBQUNEOztBQUVELFlBQUksQ0FBQ3JmLElBQUksQ0FBQ3lVLFFBQUwsSUFBaUJ6VSxJQUFJLENBQUMyVSxVQUF2QixNQUF1QzBLLE9BQU8sSUFBSUMsT0FBbEQsQ0FBSixFQUFnRTtBQUM5REMsVUFBQUEsSUFBSSxHQUFHdmYsSUFBSSxDQUFDMlUsVUFBWjs7QUFFQSxjQUFJLENBQUM0SyxJQUFMLEVBQVc7QUFDVHZmLFlBQUFBLElBQUksQ0FBQzJVLFVBQUwsR0FBa0I0SyxJQUFJLEdBQUdySyxNQUFNLElBQUl2UyxJQUFJLENBQUMyYixHQUFMLENBQVNlLE9BQVQsSUFBb0IxYyxJQUFJLENBQUMyYixHQUFMLENBQVNnQixPQUFULENBQTlCLEdBQWtELEdBQWxELEdBQXdEbkssTUFBTSxHQUFHLEdBQUgsR0FBUyxJQUFoRzs7QUFFQSxnQkFBSW9LLElBQUksSUFBSXBkLFdBQVcsQ0FBQ25DLElBQUksQ0FBQ2tMLElBQUwsQ0FBVXNULFVBQVgsQ0FBdkIsRUFBK0M7QUFDN0N4ZSxjQUFBQSxJQUFJLENBQUNrTCxJQUFMLENBQVVzVCxVQUFWLENBQXFCdlEsSUFBckIsQ0FBMEJqTyxJQUExQixFQUFnQ0EsSUFBSSxDQUFDd0wsWUFBckM7QUFDRDtBQUNGOztBQUVELGNBQUkrVCxJQUFJLEtBQUssR0FBYixFQUFrQjtBQUNoQkQsWUFBQUEsT0FBTyxHQUFHLENBQVY7QUFDRCxXQUZELE1BRU8sSUFBSUMsSUFBSSxLQUFLLEdBQWIsRUFBa0I7QUFDdkJGLFlBQUFBLE9BQU8sR0FBRyxDQUFWO0FBQ0Q7QUFDRjs7QUFFRG5XLFFBQUFBLENBQUMsR0FBR3hHLE1BQU0sQ0FBQ29VLGFBQWEsR0FBR3VJLE9BQU8sR0FBR1YsYUFBM0IsQ0FBVjtBQUNBeFYsUUFBQUEsQ0FBQyxHQUFHekcsTUFBTSxDQUFDcVUsYUFBYSxHQUFHdUksT0FBTyxHQUFHWCxhQUEzQixDQUFWO0FBQ0Q7O0FBRUQsVUFBSSxDQUFDbkgsS0FBSyxJQUFJQyxLQUFULElBQWtCQyxNQUFuQixNQUErQjFYLElBQUksQ0FBQ2tKLENBQUwsS0FBV0EsQ0FBWCxJQUFnQmxKLElBQUksQ0FBQ21KLENBQUwsS0FBV0EsQ0FBWCxJQUFnQixDQUFDNEwsWUFBaEUsQ0FBSixFQUFtRjtBQUNqRixZQUFJMkMsTUFBSixFQUFZO0FBQ1ZyVCxVQUFBQSxNQUFNLENBQUM2RSxDQUFQLEdBQVdBLENBQVg7QUFDQTdFLFVBQUFBLE1BQU0sQ0FBQzhFLENBQVAsR0FBV0EsQ0FBWDtBQUNBb1csVUFBQUEsSUFBSSxHQUFHN0gsTUFBTSxDQUFDclQsTUFBRCxDQUFiO0FBQ0E2RSxVQUFBQSxDQUFDLEdBQUd4RyxNQUFNLENBQUM2YyxJQUFJLENBQUNyVyxDQUFOLENBQVY7QUFDQUMsVUFBQUEsQ0FBQyxHQUFHekcsTUFBTSxDQUFDNmMsSUFBSSxDQUFDcFcsQ0FBTixDQUFWO0FBQ0Q7O0FBRUQsWUFBSXFPLEtBQUosRUFBVztBQUNUdE8sVUFBQUEsQ0FBQyxHQUFHeEcsTUFBTSxDQUFDOFUsS0FBSyxDQUFDdE8sQ0FBRCxDQUFOLENBQVY7QUFDRDs7QUFFRCxZQUFJdU8sS0FBSixFQUFXO0FBQ1R0TyxVQUFBQSxDQUFDLEdBQUd6RyxNQUFNLENBQUMrVSxLQUFLLENBQUN0TyxDQUFELENBQU4sQ0FBVjtBQUNEO0FBQ0Y7O0FBRUQsVUFBSTZOLFNBQUosRUFBZTtBQUNiLFlBQUk5TixDQUFDLEdBQUcrQyxJQUFSLEVBQWM7QUFDWi9DLFVBQUFBLENBQUMsR0FBRytDLElBQUksR0FBR3RKLElBQUksQ0FBQ0MsS0FBTCxDQUFXLENBQUNzRyxDQUFDLEdBQUcrQyxJQUFMLElBQWE4TixhQUF4QixDQUFYO0FBQ0QsU0FGRCxNQUVPLElBQUk3USxDQUFDLEdBQUc0QyxJQUFSLEVBQWM7QUFDbkI1QyxVQUFBQSxDQUFDLEdBQUc0QyxJQUFJLEdBQUduSixJQUFJLENBQUNDLEtBQUwsQ0FBVyxDQUFDc0csQ0FBQyxHQUFHNEMsSUFBTCxJQUFhaU8sYUFBeEIsQ0FBWDtBQUNEOztBQUVELFlBQUksQ0FBQ2hGLFlBQUwsRUFBbUI7QUFDakIsY0FBSTVMLENBQUMsR0FBR2dELElBQVIsRUFBYztBQUNaaEQsWUFBQUEsQ0FBQyxHQUFHeEcsSUFBSSxDQUFDQyxLQUFMLENBQVd1SixJQUFJLEdBQUcsQ0FBQ2hELENBQUMsR0FBR2dELElBQUwsSUFBYTROLGFBQS9CLENBQUo7QUFDRCxXQUZELE1BRU8sSUFBSTVRLENBQUMsR0FBRzZDLElBQVIsRUFBYztBQUNuQjdDLFlBQUFBLENBQUMsR0FBR3hHLElBQUksQ0FBQ0MsS0FBTCxDQUFXb0osSUFBSSxHQUFHLENBQUM3QyxDQUFDLEdBQUc2QyxJQUFMLElBQWErTixhQUEvQixDQUFKO0FBQ0Q7QUFDRjtBQUNGOztBQUVELFVBQUkvWixJQUFJLENBQUNrSixDQUFMLEtBQVdBLENBQVgsSUFBZ0JsSixJQUFJLENBQUNtSixDQUFMLEtBQVdBLENBQVgsSUFBZ0IsQ0FBQzRMLFlBQXJDLEVBQW1EO0FBQ2pELFlBQUlBLFlBQUosRUFBa0I7QUFDaEIvVSxVQUFBQSxJQUFJLENBQUNnYyxXQUFMLEdBQW1CaGMsSUFBSSxDQUFDa0osQ0FBTCxHQUFTbEosSUFBSSxDQUFDOGIsSUFBTCxHQUFZNVMsQ0FBeEM7QUFDQW9PLFVBQUFBLEtBQUssR0FBRyxJQUFSO0FBQ0QsU0FIRCxNQUdPO0FBQ0wsY0FBSW5DLE1BQUosRUFBWTtBQUNWblYsWUFBQUEsSUFBSSxDQUFDbUosQ0FBTCxHQUFTbkosSUFBSSxDQUFDK2IsSUFBTCxHQUFZNVMsQ0FBckI7QUFDQW1PLFlBQUFBLEtBQUssR0FBRyxJQUFSLENBRlUsQ0FFSTtBQUNmOztBQUVELGNBQUlwQyxNQUFKLEVBQVk7QUFDVmxWLFlBQUFBLElBQUksQ0FBQ2tKLENBQUwsR0FBU2xKLElBQUksQ0FBQzhiLElBQUwsR0FBWTVTLENBQXJCO0FBQ0FvTyxZQUFBQSxLQUFLLEdBQUcsSUFBUjtBQUNEO0FBQ0Y7O0FBRUQsWUFBSSxDQUFDb0gsWUFBRCxJQUFpQjFULGNBQWMsQ0FBQ2hMLElBQUQsRUFBTyxNQUFQLEVBQWUsUUFBZixDQUFkLEtBQTJDLEtBQWhFLEVBQXVFO0FBQ3JFLGNBQUksQ0FBQ0EsSUFBSSxDQUFDeVksVUFBTixJQUFvQnpZLElBQUksQ0FBQ3dULFNBQTdCLEVBQXdDO0FBQ3RDeFQsWUFBQUEsSUFBSSxDQUFDeVksVUFBTCxHQUFrQixJQUFsQjs7QUFFQXpOLFlBQUFBLGNBQWMsQ0FBQ2hMLElBQUQsRUFBTyxXQUFQLEVBQW9CLGFBQXBCLENBQWQ7QUFDRDtBQUNGLFNBTkQsTUFNTztBQUNMO0FBQ0FBLFVBQUFBLElBQUksQ0FBQzZZLFFBQUwsR0FBZ0IrRixZQUFoQjtBQUNBNWUsVUFBQUEsSUFBSSxDQUFDOFksUUFBTCxHQUFnQitGLFlBQWhCO0FBQ0E5SCxVQUFBQSxhQUFhLEdBQUcrSCxpQkFBaEI7QUFDQTllLFVBQUFBLElBQUksQ0FBQ2tKLENBQUwsR0FBUzZWLEtBQVQ7QUFDQS9lLFVBQUFBLElBQUksQ0FBQ21KLENBQUwsR0FBUzZWLEtBQVQ7QUFDQWhmLFVBQUFBLElBQUksQ0FBQzhiLElBQUwsR0FBWW1ELFFBQVo7QUFDQWpmLFVBQUFBLElBQUksQ0FBQytiLElBQUwsR0FBWW1ELFFBQVo7QUFDQWxmLFVBQUFBLElBQUksQ0FBQ2djLFdBQUwsR0FBbUJtRCxlQUFuQjtBQUNBN0gsVUFBQUEsS0FBSyxHQUFHOEgsU0FBUjtBQUNEO0FBQ0Y7QUFDRixLQTNnQ0Q7QUFBQSxRQTRnQ0k7QUFDSjlCLElBQUFBLFNBQVMsR0FBRyxTQUFTQSxTQUFULENBQW1CbmEsQ0FBbkIsRUFBc0J1TixLQUF0QixFQUE2QjtBQUN2QyxVQUFJLENBQUNnRyxPQUFELElBQVksQ0FBQzFXLElBQUksQ0FBQ3dULFNBQWxCLElBQStCclEsQ0FBQyxJQUFJaVUsT0FBTyxJQUFJLElBQWhCLElBQXdCLENBQUMxRyxLQUF6QixLQUFtQ3ZOLENBQUMsQ0FBQzBhLFNBQUYsSUFBZTFhLENBQUMsQ0FBQzBhLFNBQUYsS0FBZ0J6RyxPQUEvQixJQUEwQ2pVLENBQUMsQ0FBQ3NFLE1BQUYsS0FBYUEsTUFBdkQsSUFBaUV0RSxDQUFDLENBQUN5YSxjQUFGLElBQW9CLENBQUN6VyxXQUFXLENBQUNoRSxDQUFDLENBQUN5YSxjQUFILEVBQW1CeEcsT0FBbkIsQ0FBcEksQ0FBbkMsRUFBcU07QUFDbk07QUFDQWUsUUFBQUEsbUJBQW1CLElBQUloVixDQUF2QixJQUE0QnVULE9BQTVCLElBQXVDM1AsZUFBZSxDQUFDNUQsQ0FBRCxDQUF0RCxDQUZtTSxDQUV4STs7QUFFM0Q7QUFDRDs7QUFFRG5ELE1BQUFBLElBQUksQ0FBQ3dULFNBQUwsR0FBaUIsS0FBakI7QUFDQSxVQUFJNkssYUFBYSxHQUFHbGIsQ0FBcEI7QUFBQSxVQUNJeWMsV0FBVyxHQUFHNWYsSUFBSSxDQUFDeVksVUFEdkI7QUFBQSxVQUVJb0gsb0JBQW9CLEdBQUc3ZixJQUFJLENBQUNrTCxJQUFMLENBQVV1UyxnQkFBVixJQUE4QnRhLENBQTlCLEtBQW9DQSxDQUFDLENBQUN1YSxPQUFGLElBQWF2YSxDQUFDLENBQUN3YSxLQUFGLEdBQVUsQ0FBM0QsQ0FGM0I7QUFBQSxVQUdJbUMsc0JBQXNCLEdBQUdsZixJQUFJLENBQUNtZixXQUFMLENBQWlCLEtBQWpCLEVBQXdCNUMsaUJBQXhCLENBSDdCO0FBQUEsVUFJSTNWLE9BSko7QUFBQSxVQUtJeEMsQ0FMSjtBQUFBLFVBTUlnYixjQU5KO0FBQUEsVUFPSUMsV0FQSjtBQUFBLFVBUUlDLGNBUko7O0FBVUEsVUFBSXRJLGdCQUFKLEVBQXNCO0FBQ3BCL1EsUUFBQUEsZUFBZSxDQUFDK1EsZ0JBQUQsRUFBbUIsVUFBbkIsRUFBK0IwRixTQUEvQixDQUFmOztBQUVBelcsUUFBQUEsZUFBZSxDQUFDK1EsZ0JBQUQsRUFBbUIsV0FBbkIsRUFBZ0MyRixNQUFoQyxDQUFmOztBQUVBMVcsUUFBQUEsZUFBZSxDQUFDK1EsZ0JBQUQsRUFBbUIsYUFBbkIsRUFBa0MwRixTQUFsQyxDQUFmOztBQUVBelcsUUFBQUEsZUFBZSxDQUFDNFAsUUFBRCxFQUFXLFlBQVgsRUFBeUIvTyxxQkFBekIsQ0FBZjtBQUNELE9BUkQsTUFRTztBQUNMYixRQUFBQSxlQUFlLENBQUM0UCxRQUFELEVBQVcsV0FBWCxFQUF3QjhHLE1BQXhCLENBQWY7QUFDRDs7QUFFRDFXLE1BQUFBLGVBQWUsQ0FBQ2hHLElBQUQsRUFBTyxrQkFBUCxFQUEyQmtHLGVBQTNCLENBQWY7O0FBRUEsVUFBSSxDQUFDakYsZ0JBQUQsSUFBcUIsQ0FBQzhWLGdCQUExQixFQUE0QztBQUMxQy9RLFFBQUFBLGVBQWUsQ0FBQzRQLFFBQUQsRUFBVyxTQUFYLEVBQXNCNkcsU0FBdEIsQ0FBZjs7QUFFQW5hLFFBQUFBLENBQUMsSUFBSUEsQ0FBQyxDQUFDc0UsTUFBUCxJQUFpQlosZUFBZSxDQUFDMUQsQ0FBQyxDQUFDc0UsTUFBSCxFQUFXLFNBQVgsRUFBc0I2VixTQUF0QixDQUFoQztBQUNEOztBQUVEaEcsTUFBQUEsS0FBSyxHQUFHLEtBQVI7O0FBRUEsVUFBSXNJLFdBQUosRUFBaUI7QUFDZm5LLFFBQUFBLFdBQVcsR0FBR3JSLGFBQWEsR0FBR1IsUUFBUSxFQUF0QztBQUNBNUQsUUFBQUEsSUFBSSxDQUFDeVksVUFBTCxHQUFrQixLQUFsQjtBQUNEOztBQUVELFVBQUlkLFVBQVUsSUFBSSxDQUFDa0ksb0JBQW5CLEVBQXlDO0FBQ3ZDLFlBQUkxYyxDQUFKLEVBQU87QUFDTDBELFVBQUFBLGVBQWUsQ0FBQzFELENBQUMsQ0FBQ3NFLE1BQUgsRUFBVyxRQUFYLEVBQXFCNlYsU0FBckIsQ0FBZjs7QUFFQXRkLFVBQUFBLElBQUksQ0FBQ3dMLFlBQUwsR0FBb0I2UyxhQUFwQjtBQUNEOztBQUVEN1AsUUFBQUEsY0FBYyxDQUFDNkcsUUFBRCxFQUFXLEtBQVgsQ0FBZDs7QUFFQXJLLFFBQUFBLGNBQWMsQ0FBQ2hMLElBQUQsRUFBTyxTQUFQLEVBQWtCLFdBQWxCLENBQWQ7O0FBRUFnTCxRQUFBQSxjQUFjLENBQUNoTCxJQUFELEVBQU8sT0FBUCxFQUFnQixTQUFoQixDQUFkOztBQUVBMlgsUUFBQUEsVUFBVSxHQUFHLEtBQWI7QUFDQTtBQUNEOztBQUVEN1IsTUFBQUEsc0JBQXNCLENBQUN5UyxNQUFELENBQXRCOztBQUVBdlQsTUFBQUEsQ0FBQyxHQUFHcVEsUUFBUSxDQUFDcFEsTUFBYjs7QUFFQSxhQUFPLEVBQUVELENBQUYsR0FBTSxDQUFDLENBQWQsRUFBaUI7QUFDZndFLFFBQUFBLFNBQVMsQ0FBQzZMLFFBQVEsQ0FBQ3JRLENBQUQsQ0FBVCxFQUFjLFFBQWQsRUFBd0JrRyxJQUFJLENBQUNxSCxNQUFMLEtBQWdCckgsSUFBSSxDQUFDcUgsTUFBTCxLQUFnQixLQUFoQixHQUF3QjFRLGNBQXhCLEdBQXlDLElBQXpELENBQXhCLENBQVQ7QUFDRDs7QUFFREosTUFBQUEsVUFBVTs7QUFFVixVQUFJMEIsQ0FBSixFQUFPO0FBQ0xxRSxRQUFBQSxPQUFPLEdBQUdyRSxDQUFDLENBQUN5YSxjQUFaOztBQUVBLFlBQUlwVyxPQUFKLEVBQWE7QUFDWDtBQUNBckUsVUFBQUEsQ0FBQyxHQUFHcUUsT0FBTyxDQUFDLENBQUQsQ0FBWDs7QUFFQSxjQUFJckUsQ0FBQyxLQUFLZ1UsS0FBTixJQUFlaFUsQ0FBQyxDQUFDbUUsVUFBRixLQUFpQjhQLE9BQXBDLEVBQTZDO0FBQzNDO0FBQ0FwUyxZQUFBQSxDQUFDLEdBQUd3QyxPQUFPLENBQUN2QyxNQUFaOztBQUVBLG1CQUFPLEVBQUVELENBQUYsR0FBTSxDQUFDLENBQVAsSUFBWSxDQUFDN0IsQ0FBQyxHQUFHcUUsT0FBTyxDQUFDeEMsQ0FBRCxDQUFaLEVBQWlCc0MsVUFBakIsS0FBZ0M4UCxPQUE1QyxJQUF1RGpVLENBQUMsQ0FBQ3NFLE1BQUYsS0FBYUEsTUFBM0UsRUFBbUYsQ0FBRTs7QUFFckYsZ0JBQUl6QyxDQUFDLEdBQUcsQ0FBUixFQUFXO0FBQ1Q7QUFDRDtBQUNGO0FBQ0Y7O0FBRURoRixRQUFBQSxJQUFJLENBQUN3TCxZQUFMLEdBQW9CNlMsYUFBcEI7QUFDQXJlLFFBQUFBLElBQUksQ0FBQzZZLFFBQUwsR0FBZ0IxVixDQUFDLENBQUMwSCxLQUFsQjtBQUNBN0ssUUFBQUEsSUFBSSxDQUFDOFksUUFBTCxHQUFnQjNWLENBQUMsQ0FBQzJILEtBQWxCO0FBQ0Q7O0FBRUQsVUFBSStVLG9CQUFvQixJQUFJeEIsYUFBNUIsRUFBMkM7QUFDekN0WCxRQUFBQSxlQUFlLENBQUNzWCxhQUFELENBQWY7O0FBRUFsRyxRQUFBQSxtQkFBbUIsR0FBRyxJQUF0Qjs7QUFFQW5OLFFBQUFBLGNBQWMsQ0FBQ2hMLElBQUQsRUFBTyxTQUFQLEVBQWtCLFdBQWxCLENBQWQ7QUFDRCxPQU5ELE1BTU8sSUFBSXFlLGFBQWEsSUFBSSxDQUFDdUIsV0FBdEIsRUFBbUM7QUFDeEN6SCxRQUFBQSxtQkFBbUIsR0FBRyxLQUF0Qjs7QUFFQSxZQUFJTixXQUFXLEtBQUszTSxJQUFJLENBQUMwQyxJQUFMLElBQWExQyxJQUFJLENBQUN3UCxNQUF2QixDQUFmLEVBQStDO0FBQzdDO0FBQ0FPLFVBQUFBLE9BQU8sQ0FBQy9QLElBQUksQ0FBQ3lJLE9BQUwsSUFBZ0J6SSxJQUFJLENBQUNpVixVQUF0QixDQUFQO0FBQ0Q7O0FBRURuVixRQUFBQSxjQUFjLENBQUNoTCxJQUFELEVBQU8sU0FBUCxFQUFrQixXQUFsQixDQUFkOztBQUVBLFlBQUksQ0FBQyxDQUFDMkIsVUFBRCxJQUFlMGMsYUFBYSxDQUFDcGIsSUFBZCxLQUF1QixXQUF2QyxLQUF1RG9iLGFBQWEsQ0FBQ3BiLElBQWQsQ0FBbUJ3UCxPQUFuQixDQUEyQixRQUEzQixNQUF5QyxDQUFDLENBQXJHLEVBQXdHO0FBQ3RHO0FBQ0F6SCxVQUFBQSxjQUFjLENBQUNoTCxJQUFELEVBQU8sT0FBUCxFQUFnQixTQUFoQixDQUFkOztBQUVBLGNBQUk0RCxRQUFRLEtBQUtxUyxTQUFiLEdBQXlCLEdBQTdCLEVBQWtDO0FBQ2hDakwsWUFBQUEsY0FBYyxDQUFDaEwsSUFBRCxFQUFPLGFBQVAsRUFBc0IsZUFBdEIsQ0FBZDtBQUNEOztBQUVEaWdCLFVBQUFBLFdBQVcsR0FBRzVCLGFBQWEsQ0FBQzVXLE1BQWQsSUFBd0JBLE1BQXRDLENBUnNHLENBUXhEOztBQUU5Q3dPLFVBQUFBLFNBQVMsR0FBR3JTLFFBQVEsRUFBcEI7O0FBRUFzYyxVQUFBQSxjQUFjLEdBQUcsU0FBU0EsY0FBVCxHQUEwQjtBQUN6QztBQUNBLGdCQUFJakssU0FBUyxLQUFLZ0MsYUFBZCxJQUErQmpZLElBQUksQ0FBQzBXLE9BQUwsRUFBL0IsSUFBaUQsQ0FBQzFXLElBQUksQ0FBQ3dULFNBQXZELElBQW9FLENBQUM2SyxhQUFhLENBQUMrQixnQkFBdkYsRUFBeUc7QUFDdkcsa0JBQUlILFdBQVcsQ0FBQ0ksS0FBaEIsRUFBdUI7QUFDckI7QUFDQUosZ0JBQUFBLFdBQVcsQ0FBQ0ksS0FBWjtBQUNELGVBSEQsTUFHTyxJQUFJNUosUUFBUSxDQUFDNkosV0FBYixFQUEwQjtBQUMvQk4sZ0JBQUFBLGNBQWMsR0FBR3ZKLFFBQVEsQ0FBQzZKLFdBQVQsQ0FBcUIsYUFBckIsQ0FBakI7QUFDQU4sZ0JBQUFBLGNBQWMsQ0FBQ08sY0FBZixDQUE4QixPQUE5QixFQUF1QyxJQUF2QyxFQUE2QyxJQUE3QyxFQUFtRDFmLElBQW5ELEVBQXlELENBQXpELEVBQTREYixJQUFJLENBQUN3TCxZQUFMLENBQWtCZ1YsT0FBOUUsRUFBdUZ4Z0IsSUFBSSxDQUFDd0wsWUFBTCxDQUFrQmlWLE9BQXpHLEVBQWtIemdCLElBQUksQ0FBQzZZLFFBQXZILEVBQWlJN1ksSUFBSSxDQUFDOFksUUFBdEksRUFBZ0osS0FBaEosRUFBdUosS0FBdkosRUFBOEosS0FBOUosRUFBcUssS0FBckssRUFBNEssQ0FBNUssRUFBK0ssSUFBL0s7QUFDQW1ILGdCQUFBQSxXQUFXLENBQUN4VSxhQUFaLENBQTBCdVUsY0FBMUI7QUFDRDtBQUNGO0FBQ0YsV0FaRDs7QUFjQSxjQUFJLENBQUNyZSxVQUFELElBQWUsQ0FBQzBjLGFBQWEsQ0FBQytCLGdCQUFsQyxFQUFvRDtBQUNsRDtBQUNBeGYsWUFBQUEsSUFBSSxDQUFDbWYsV0FBTCxDQUFpQixJQUFqQixFQUF1QkcsY0FBdkIsRUFGa0QsQ0FFVjtBQUN6QztBQUNGO0FBQ0YsT0F6Q00sTUF5Q0E7QUFDTGpGLFFBQUFBLE9BQU8sQ0FBQy9QLElBQUksQ0FBQ3lJLE9BQUwsSUFBZ0J6SSxJQUFJLENBQUNpVixVQUF0QixDQUFQLENBREssQ0FDcUM7O0FBRTFDLFlBQUksQ0FBQ25nQixJQUFJLENBQUM0VSxpQkFBTixJQUEyQnlKLGFBQTNCLEtBQTZDblQsSUFBSSxDQUFDc1MsY0FBTCxLQUF3QixLQUF4QixJQUFpQyxDQUFDekgsV0FBVyxDQUFDOUgsSUFBWixDQUFpQmpPLElBQWpCLEVBQXVCcWUsYUFBYSxDQUFDNVcsTUFBckMsQ0FBL0UsS0FBZ0ltWSxXQUFoSSxLQUFnSixDQUFDOUgseUJBQUQsSUFBOEJDLGFBQWEsSUFBSUQseUJBQXlCLEtBQUtDLGFBQTdOLEtBQStPc0csYUFBYSxDQUFDSSxVQUFkLEtBQTZCLEtBQWhSLEVBQXVSO0FBQ3JSdEcsVUFBQUEsbUJBQW1CLEdBQUcsSUFBdEI7O0FBRUFwUixVQUFBQSxlQUFlLENBQUNzWCxhQUFELENBQWY7QUFDRCxTQUpELE1BSU87QUFDTGxHLFVBQUFBLG1CQUFtQixHQUFHLEtBQXRCO0FBQ0Q7O0FBRURuTixRQUFBQSxjQUFjLENBQUNoTCxJQUFELEVBQU8sU0FBUCxFQUFrQixXQUFsQixDQUFkO0FBQ0Q7O0FBRUQ0YyxNQUFBQSxVQUFVLE1BQU1rRCxzQkFBc0IsQ0FBQzNaLFFBQXZCLENBQWdDbkcsSUFBSSxDQUFDa2IsS0FBTCxDQUFXL1UsUUFBWCxFQUFoQyxDQUFoQixDQTlKdUMsQ0E4SmlDOztBQUV4RXlaLE1BQUFBLFdBQVcsSUFBSTVVLGNBQWMsQ0FBQ2hMLElBQUQsRUFBTyxTQUFQLEVBQWtCLFdBQWxCLENBQTdCO0FBQ0EsYUFBTyxJQUFQO0FBQ0QsS0EvcUNEO0FBQUEsUUFnckNJMGdCLFlBQVksR0FBRyxTQUFTQSxZQUFULENBQXNCdmQsQ0FBdEIsRUFBeUI7QUFDMUMsVUFBSUEsQ0FBQyxJQUFJbkQsSUFBSSxDQUFDeVksVUFBVixJQUF3QixDQUFDOUIsV0FBN0IsRUFBMEM7QUFDeEMsWUFBSTVELE1BQU0sR0FBRzVQLENBQUMsQ0FBQ3NFLE1BQUYsSUFBWUEsTUFBTSxDQUFDYyxVQUFoQztBQUFBLFlBQ0k2USxNQUFNLEdBQUdyRyxNQUFNLENBQUM1SyxVQUFQLEdBQW9CNEssTUFBTSxDQUFDekosVUFEeEM7QUFBQSxZQUVJZ1EsTUFBTSxHQUFHdkcsTUFBTSxDQUFDakwsU0FBUCxHQUFtQmlMLE1BQU0sQ0FBQ3hKLFVBRnZDOztBQUlBLFlBQUk2UCxNQUFNLElBQUlFLE1BQWQsRUFBc0I7QUFDcEIsY0FBSTdNLE1BQUosRUFBWTtBQUNWbUssWUFBQUEsYUFBYSxJQUFJd0MsTUFBTSxHQUFHM00sTUFBTSxDQUFDcUIsQ0FBaEIsR0FBb0J3TCxNQUFNLEdBQUc3TSxNQUFNLENBQUMrUyxDQUFyRDtBQUNBM0ksWUFBQUEsYUFBYSxJQUFJeUMsTUFBTSxHQUFHN00sTUFBTSxDQUFDaVQsQ0FBaEIsR0FBb0J0RyxNQUFNLEdBQUczTSxNQUFNLENBQUNnVCxDQUFyRDtBQUNELFdBSEQsTUFHTztBQUNMN0ksWUFBQUEsYUFBYSxJQUFJd0MsTUFBakI7QUFDQXZDLFlBQUFBLGFBQWEsSUFBSXlDLE1BQWpCO0FBQ0Q7O0FBRUR2RyxVQUFBQSxNQUFNLENBQUN6SixVQUFQLElBQXFCOFAsTUFBckI7QUFDQXJHLFVBQUFBLE1BQU0sQ0FBQ3hKLFVBQVAsSUFBcUIrUCxNQUFyQjtBQUNBSCxVQUFBQSxrQkFBa0IsQ0FBQ25aLElBQUksQ0FBQzZZLFFBQU4sRUFBZ0I3WSxJQUFJLENBQUM4WSxRQUFyQixDQUFsQjtBQUNEO0FBQ0Y7QUFDRixLQXBzQ0Q7QUFBQSxRQXFzQ0k2SCxPQUFPLEdBQUcsU0FBU0EsT0FBVCxDQUFpQnhkLENBQWpCLEVBQW9CO0FBQ2hDO0FBQ0EsVUFBSXlkLElBQUksR0FBR2hkLFFBQVEsRUFBbkI7QUFBQSxVQUNJaWQsZUFBZSxHQUFHRCxJQUFJLEdBQUczSyxTQUFQLEdBQW1CLEdBRHpDO0FBQUEsVUFFSTZLLGVBQWUsR0FBR0YsSUFBSSxHQUFHbkwsV0FBUCxHQUFxQixFQUYzQztBQUFBLFVBR0lzTCxpQkFBaUIsR0FBR0YsZUFBZSxJQUFJNUksYUFBYSxLQUFLaEMsU0FIN0Q7QUFBQSxVQUlJbUssZ0JBQWdCLEdBQUdwZ0IsSUFBSSxDQUFDd0wsWUFBTCxJQUFxQnhMLElBQUksQ0FBQ3dMLFlBQUwsQ0FBa0I0VSxnQkFKOUQ7QUFBQSxVQUtJWSx3QkFBd0IsR0FBR0gsZUFBZSxJQUFJM0ksb0JBQW9CLEtBQUtqQyxTQUwzRTtBQUFBLFVBTUlnTCxPQUFPLEdBQUc5ZCxDQUFDLENBQUMrZCxTQUFGLElBQWUvZCxDQUFDLENBQUMrZCxTQUFGLElBQWUsSUFBZixJQUF1QkwsZUFBdkIsSUFBMENFLGlCQU52RSxDQUZnQyxDQVEwRDs7O0FBRzFGLFVBQUksQ0FBQ0EsaUJBQWlCLElBQUlELGVBQWUsSUFBSTlnQixJQUFJLENBQUNrTCxJQUFMLENBQVVpVyxtQkFBVixLQUFrQyxLQUEzRSxLQUFxRmhlLENBQUMsQ0FBQ21WLHdCQUEzRixFQUFxSDtBQUNuSG5WLFFBQUFBLENBQUMsQ0FBQ21WLHdCQUFGO0FBQ0Q7O0FBRUQsVUFBSXVJLGVBQWUsSUFBSSxFQUFFN2dCLElBQUksQ0FBQ3dMLFlBQUwsSUFBcUJ4TCxJQUFJLENBQUN3TCxZQUFMLENBQWtCNFUsZ0JBQXpDLENBQW5CLEtBQWtGLENBQUNXLGlCQUFELElBQXNCRSxPQUFPLElBQUksQ0FBQ0Qsd0JBQXBILENBQUosRUFBbUo7QUFDako7QUFDQSxZQUFJQyxPQUFPLElBQUlGLGlCQUFmLEVBQWtDO0FBQ2hDN0ksVUFBQUEsb0JBQW9CLEdBQUdqQyxTQUF2QjtBQUNEOztBQUVEZ0MsUUFBQUEsYUFBYSxHQUFHaEMsU0FBaEI7QUFDQTtBQUNEOztBQUVELFVBQUlqVyxJQUFJLENBQUN3VCxTQUFMLElBQWtCc04sZUFBbEIsSUFBcUNELGVBQXpDLEVBQTBEO0FBQ3hELFlBQUksQ0FBQ0ksT0FBRCxJQUFZLENBQUM5ZCxDQUFDLENBQUNpZSxNQUFmLElBQXlCLENBQUNQLGVBQTFCLElBQTZDVCxnQkFBakQsRUFBbUU7QUFDakVyWixVQUFBQSxlQUFlLENBQUM1RCxDQUFELENBQWY7QUFDRDtBQUNGOztBQUVELFVBQUksQ0FBQzBkLGVBQUQsSUFBb0IsQ0FBQ0MsZUFBekIsRUFBMEM7QUFDeEM7QUFDQTNkLFFBQUFBLENBQUMsSUFBSUEsQ0FBQyxDQUFDc0UsTUFBUCxLQUFrQnpILElBQUksQ0FBQ3dMLFlBQUwsR0FBb0JySSxDQUF0Qzs7QUFFQTZILFFBQUFBLGNBQWMsQ0FBQ2hMLElBQUQsRUFBTyxPQUFQLEVBQWdCLFNBQWhCLENBQWQ7QUFDRDtBQUNGLEtBMXVDRDtBQUFBLFFBMnVDSXFoQixhQUFhLEdBQUcsU0FBU0EsYUFBVCxDQUF1QjFjLENBQXZCLEVBQTBCO0FBQzVDLGFBQU84SCxNQUFNLEdBQUc7QUFDZHZELFFBQUFBLENBQUMsRUFBRXZFLENBQUMsQ0FBQ3VFLENBQUYsR0FBTXVELE1BQU0sQ0FBQ3FCLENBQWIsR0FBaUJuSixDQUFDLENBQUN3RSxDQUFGLEdBQU1zRCxNQUFNLENBQUMrUyxDQUE5QixHQUFrQy9TLE1BQU0sQ0FBQ3RKLENBRDlCO0FBRWRnRyxRQUFBQSxDQUFDLEVBQUV4RSxDQUFDLENBQUN1RSxDQUFGLEdBQU11RCxNQUFNLENBQUNnVCxDQUFiLEdBQWlCOWEsQ0FBQyxDQUFDd0UsQ0FBRixHQUFNc0QsTUFBTSxDQUFDaVQsQ0FBOUIsR0FBa0NqVCxNQUFNLENBQUNrVDtBQUY5QixPQUFILEdBR1Q7QUFDRnpXLFFBQUFBLENBQUMsRUFBRXZFLENBQUMsQ0FBQ3VFLENBREg7QUFFRkMsUUFBQUEsQ0FBQyxFQUFFeEUsQ0FBQyxDQUFDd0U7QUFGSCxPQUhKO0FBT0QsS0FudkNEOztBQXF2Q0FvTyxJQUFBQSxHQUFHLEdBQUdyRCxTQUFTLENBQUNYLEdBQVYsQ0FBYzlMLE1BQWQsQ0FBTjtBQUNBOFAsSUFBQUEsR0FBRyxJQUFJQSxHQUFHLENBQUN1RyxJQUFKLEVBQVAsQ0E1d0MrQixDQTR3Q1o7QUFDbkI7O0FBRUExSixJQUFBQSxNQUFNLENBQUNrTixTQUFQLEdBQW1CLFVBQVV0YSxLQUFWLEVBQWlCdWEsS0FBakIsRUFBd0I7QUFDekMsVUFBSUMsRUFBSixFQUFRQyxFQUFSLEVBQVkvVSxFQUFaLEVBQWdCQyxFQUFoQjtBQUNBeVEsTUFBQUEsT0FBTyxDQUFDcFcsS0FBSyxJQUFJaEgsSUFBSSxDQUFDd0wsWUFBZixFQUE2QixJQUE3QixDQUFQLENBRnlDLENBRUU7O0FBRTNDLFVBQUkrVixLQUFLLElBQUksQ0FBQ3ZoQixJQUFJLENBQUMwaEIsT0FBTCxDQUFhMWEsS0FBSyxJQUFJaEgsSUFBSSxDQUFDd0wsWUFBM0IsQ0FBZCxFQUF3RDtBQUN0RGdXLFFBQUFBLEVBQUUsR0FBR3hYLFVBQVUsQ0FBQ2hELEtBQUssSUFBSWhILElBQUksQ0FBQ3dMLFlBQWYsQ0FBZjtBQUNBaVcsUUFBQUEsRUFBRSxHQUFHelgsVUFBVSxDQUFDdkMsTUFBRCxDQUFmO0FBQ0FpRixRQUFBQSxFQUFFLEdBQUcyVSxhQUFhLENBQUM7QUFDakJuWSxVQUFBQSxDQUFDLEVBQUVzWSxFQUFFLENBQUN2WCxJQUFILEdBQVV1WCxFQUFFLENBQUNyWCxLQUFILEdBQVcsQ0FEUDtBQUVqQmhCLFVBQUFBLENBQUMsRUFBRXFZLEVBQUUsQ0FBQ3RYLEdBQUgsR0FBU3NYLEVBQUUsQ0FBQ2pYLE1BQUgsR0FBWTtBQUZQLFNBQUQsQ0FBbEI7QUFJQW9DLFFBQUFBLEVBQUUsR0FBRzBVLGFBQWEsQ0FBQztBQUNqQm5ZLFVBQUFBLENBQUMsRUFBRXVZLEVBQUUsQ0FBQ3hYLElBQUgsR0FBVXdYLEVBQUUsQ0FBQ3RYLEtBQUgsR0FBVyxDQURQO0FBRWpCaEIsVUFBQUEsQ0FBQyxFQUFFc1ksRUFBRSxDQUFDdlgsR0FBSCxHQUFTdVgsRUFBRSxDQUFDbFgsTUFBSCxHQUFZO0FBRlAsU0FBRCxDQUFsQjtBQUlBcU0sUUFBQUEsYUFBYSxJQUFJbEssRUFBRSxDQUFDeEQsQ0FBSCxHQUFPeUQsRUFBRSxDQUFDekQsQ0FBM0I7QUFDQTJOLFFBQUFBLGFBQWEsSUFBSW5LLEVBQUUsQ0FBQ3ZELENBQUgsR0FBT3dELEVBQUUsQ0FBQ3hELENBQTNCO0FBQ0Q7O0FBRUQsVUFBSSxDQUFDbkosSUFBSSxDQUFDeVksVUFBVixFQUFzQjtBQUNwQnpZLFFBQUFBLElBQUksQ0FBQ3lZLFVBQUwsR0FBa0IsSUFBbEI7O0FBRUF6TixRQUFBQSxjQUFjLENBQUNoTCxJQUFELEVBQU8sV0FBUCxFQUFvQixhQUFwQixDQUFkO0FBQ0Q7QUFDRixLQXhCRDs7QUEwQkFvVSxJQUFBQSxNQUFNLENBQUM4SixJQUFQLEdBQWNYLE1BQWQ7O0FBRUFuSixJQUFBQSxNQUFNLENBQUNYLE9BQVAsR0FBaUIsVUFBVXRRLENBQVYsRUFBYTtBQUM1QixhQUFPbWEsU0FBUyxDQUFDbmEsQ0FBQyxJQUFJbkQsSUFBSSxDQUFDd0wsWUFBWCxFQUF5QixJQUF6QixDQUFoQjtBQUNELEtBRkQ7O0FBSUE0SSxJQUFBQSxNQUFNLENBQUN1TixhQUFQLEdBQXVCLFlBQVk7QUFDakMsYUFBTzNoQixJQUFJLENBQUN5WSxVQUFMLEdBQWtCLENBQWxCLEdBQXNCLENBQUM3VSxRQUFRLEtBQUs2UixXQUFkLElBQTZCLElBQTFEO0FBQ0QsS0FGRDs7QUFJQXJCLElBQUFBLE1BQU0sQ0FBQ3dOLGNBQVAsR0FBd0IsWUFBWTtBQUNsQyxhQUFPLENBQUNoZSxRQUFRLEtBQUtxUyxTQUFkLElBQTJCLElBQWxDO0FBQ0QsS0FGRDs7QUFJQTdCLElBQUFBLE1BQU0sQ0FBQ3NOLE9BQVAsR0FBaUIsVUFBVWphLE1BQVYsRUFBa0JvYSxTQUFsQixFQUE2QjtBQUM1QyxhQUFPM04sU0FBUyxDQUFDd04sT0FBVixDQUFrQjFoQixJQUFJLENBQUN5SCxNQUF2QixFQUErQkEsTUFBL0IsRUFBdUNvYSxTQUF2QyxDQUFQO0FBQ0QsS0FGRDs7QUFJQXpOLElBQUFBLE1BQU0sQ0FBQzBOLFlBQVAsR0FBc0IsVUFBVUMsSUFBVixFQUFnQkMsaUJBQWhCLEVBQW1DO0FBQ3ZEO0FBQ0EsVUFBSUMsSUFBSSxHQUFHRixJQUFJLEtBQUssVUFBVCxJQUF1Qm5nQixhQUF2QixHQUF1Q21nQixJQUF2QyxHQUE4QzFmLFNBQVMsQ0FBQzBmLElBQUQsQ0FBVCxJQUFtQixDQUFDaE4sWUFBcEIsR0FBbUMsU0FBbkMsR0FBK0MsT0FBeEc7QUFBQSxVQUNJc0ssT0FESjtBQUFBLFVBRUlDLE9BRko7QUFBQSxVQUdJNEMsS0FISjtBQUFBLFVBSUlDLFNBSko7QUFBQSxVQUtJWCxFQUxKO0FBQUEsVUFNSUMsRUFOSjs7QUFRQSxVQUFJUSxJQUFJLEtBQUssU0FBYixFQUF3QjtBQUN0QlQsUUFBQUEsRUFBRSxHQUFHeFgsVUFBVSxDQUFDaEssSUFBSSxDQUFDeUgsTUFBTixDQUFmO0FBQ0FnYSxRQUFBQSxFQUFFLEdBQUd6WCxVQUFVLENBQUMrWCxJQUFELENBQWY7QUFDRDs7QUFFRDFDLE1BQUFBLE9BQU8sR0FBRzRDLElBQUksS0FBSyxPQUFULEdBQW1CamlCLElBQUksQ0FBQ2tKLENBQUwsR0FBUzROLGFBQTVCLEdBQTRDbUwsSUFBSSxLQUFLLFVBQVQsR0FBc0JyZ0IsYUFBYSxDQUFDd2dCLFdBQWQsQ0FBMEIzYSxNQUExQixFQUFrQ3VOLEtBQWxDLENBQXRCLEdBQWlFd00sRUFBRSxDQUFDdlgsSUFBSCxHQUFVdVgsRUFBRSxDQUFDclgsS0FBSCxHQUFXLENBQXJCLElBQTBCc1gsRUFBRSxDQUFDeFgsSUFBSCxHQUFVd1gsRUFBRSxDQUFDdFgsS0FBSCxHQUFXLENBQS9DLENBQXZIOztBQUVBLFVBQUk0SyxZQUFKLEVBQWtCO0FBQ2hCLGVBQU9zSyxPQUFPLEdBQUcsQ0FBVixHQUFjLG1CQUFkLEdBQW9DLFdBQTNDO0FBQ0QsT0FGRCxNQUVPO0FBQ0wyQyxRQUFBQSxpQkFBaUIsR0FBR0EsaUJBQWlCLElBQUksQ0FBekM7QUFDQTFDLFFBQUFBLE9BQU8sR0FBRzJDLElBQUksS0FBSyxPQUFULEdBQW1CamlCLElBQUksQ0FBQ21KLENBQUwsR0FBUzROLGFBQTVCLEdBQTRDa0wsSUFBSSxLQUFLLFVBQVQsR0FBc0JyZ0IsYUFBYSxDQUFDd2dCLFdBQWQsQ0FBMEIzYSxNQUExQixFQUFrQ3dOLEtBQWxDLENBQXRCLEdBQWlFdU0sRUFBRSxDQUFDdFgsR0FBSCxHQUFTc1gsRUFBRSxDQUFDalgsTUFBSCxHQUFZLENBQXJCLElBQTBCa1gsRUFBRSxDQUFDdlgsR0FBSCxHQUFTdVgsRUFBRSxDQUFDbFgsTUFBSCxHQUFZLENBQS9DLENBQXZIO0FBQ0EyWCxRQUFBQSxLQUFLLEdBQUd2ZixJQUFJLENBQUMyYixHQUFMLENBQVNlLE9BQU8sR0FBR0MsT0FBbkIsQ0FBUjtBQUNBNkMsUUFBQUEsU0FBUyxHQUFHRCxLQUFLLEdBQUcsSUFBSUYsaUJBQVosR0FBZ0MsRUFBaEMsR0FBcUMzQyxPQUFPLEdBQUcsQ0FBVixHQUFjLE1BQWQsR0FBdUIsT0FBeEU7O0FBRUEsWUFBSTZDLEtBQUssR0FBR0YsaUJBQVosRUFBK0I7QUFDN0IsY0FBSUcsU0FBUyxLQUFLLEVBQWxCLEVBQXNCO0FBQ3BCQSxZQUFBQSxTQUFTLElBQUksR0FBYjtBQUNEOztBQUVEQSxVQUFBQSxTQUFTLElBQUk3QyxPQUFPLEdBQUcsQ0FBVixHQUFjLElBQWQsR0FBcUIsTUFBbEM7QUFDRDtBQUNGOztBQUVELGFBQU82QyxTQUFQO0FBQ0QsS0FuQ0Q7O0FBcUNBL04sSUFBQUEsTUFBTSxDQUFDOEgsV0FBUCxHQUFxQixVQUFVbUcsU0FBVixFQUFxQkMsTUFBckIsRUFBNkI7QUFDaEQsVUFBSXBaLENBQUosRUFBT0MsQ0FBUCxFQUFVMEUsaUJBQVYsRUFBNkIxSyxDQUE3QixFQUFnQzRQLE1BQWhDLEVBQXdDNEYsTUFBeEM7O0FBRUEsVUFBSTBKLFNBQVMsSUFBSW5YLElBQUksQ0FBQ3dQLE1BQUwsS0FBZ0IySCxTQUFqQyxFQUE0QztBQUMxQ25YLFFBQUFBLElBQUksQ0FBQ3dQLE1BQUwsR0FBYzJILFNBQWQ7QUFDQSxlQUFPcmlCLElBQUksQ0FBQ3VpQixNQUFMLENBQVksSUFBWixFQUFrQkQsTUFBbEIsQ0FBUDtBQUNEOztBQUVEL0ksTUFBQUEsTUFBTSxDQUFDLElBQUQsQ0FBTjtBQUNBa0IsTUFBQUEsZUFBZTs7QUFFZixVQUFJekQsU0FBUyxJQUFJLENBQUM0RixVQUFVLEVBQTVCLEVBQWdDO0FBQzlCMVQsUUFBQUEsQ0FBQyxHQUFHbEosSUFBSSxDQUFDa0osQ0FBVDtBQUNBQyxRQUFBQSxDQUFDLEdBQUduSixJQUFJLENBQUNtSixDQUFUOztBQUVBLFlBQUlELENBQUMsR0FBRytDLElBQVIsRUFBYztBQUNaL0MsVUFBQUEsQ0FBQyxHQUFHK0MsSUFBSjtBQUNELFNBRkQsTUFFTyxJQUFJL0MsQ0FBQyxHQUFHNEMsSUFBUixFQUFjO0FBQ25CNUMsVUFBQUEsQ0FBQyxHQUFHNEMsSUFBSjtBQUNEOztBQUVELFlBQUkzQyxDQUFDLEdBQUdnRCxJQUFSLEVBQWM7QUFDWmhELFVBQUFBLENBQUMsR0FBR2dELElBQUo7QUFDRCxTQUZELE1BRU8sSUFBSWhELENBQUMsR0FBRzZDLElBQVIsRUFBYztBQUNuQjdDLFVBQUFBLENBQUMsR0FBRzZDLElBQUo7QUFDRDs7QUFFRCxZQUFJaE0sSUFBSSxDQUFDa0osQ0FBTCxLQUFXQSxDQUFYLElBQWdCbEosSUFBSSxDQUFDbUosQ0FBTCxLQUFXQSxDQUEvQixFQUFrQztBQUNoQzBFLFVBQUFBLGlCQUFpQixHQUFHLElBQXBCO0FBQ0E3TixVQUFBQSxJQUFJLENBQUNrSixDQUFMLEdBQVNsSixJQUFJLENBQUM4YixJQUFMLEdBQVk1UyxDQUFyQjs7QUFFQSxjQUFJNkwsWUFBSixFQUFrQjtBQUNoQi9VLFlBQUFBLElBQUksQ0FBQ2djLFdBQUwsR0FBbUI5UyxDQUFuQjtBQUNELFdBRkQsTUFFTztBQUNMbEosWUFBQUEsSUFBSSxDQUFDbUosQ0FBTCxHQUFTbkosSUFBSSxDQUFDK2IsSUFBTCxHQUFZNVMsQ0FBckI7QUFDRDs7QUFFRG1PLFVBQUFBLEtBQUssR0FBRyxJQUFSO0FBQ0FpQixVQUFBQSxNQUFNLENBQUMsSUFBRCxDQUFOOztBQUVBLGNBQUl2WSxJQUFJLENBQUMwVSxVQUFMLElBQW1CLENBQUMxVSxJQUFJLENBQUN5WSxVQUE3QixFQUF5QztBQUN2Q3pQLFlBQUFBLGlCQUFpQixDQUFDdkIsTUFBTSxDQUFDYyxVQUFSLENBQWpCOztBQUVBcEYsWUFBQUEsQ0FBQyxHQUFHc0UsTUFBSjtBQUNBbkQsWUFBQUEsWUFBWSxDQUFDd0QsU0FBYixHQUF5QmpILElBQUksQ0FBQ2dILFdBQUwsSUFBb0IsSUFBcEIsR0FBMkJoSCxJQUFJLENBQUNnSCxXQUFoQyxHQUE4QzRPLFFBQVEsQ0FBQzFPLGVBQVQsQ0FBeUJELFNBQXpCLElBQXNDLElBQXRDLEdBQTZDMk8sUUFBUSxDQUFDMU8sZUFBVCxDQUF5QkQsU0FBdEUsR0FBa0YyTyxRQUFRLENBQUN6TyxJQUFULENBQWNGLFNBQXZLO0FBQ0F4RCxZQUFBQSxZQUFZLENBQUM2RCxVQUFiLEdBQTBCdEgsSUFBSSxDQUFDcUgsV0FBTCxJQUFvQixJQUFwQixHQUEyQnJILElBQUksQ0FBQ3FILFdBQWhDLEdBQThDdU8sUUFBUSxDQUFDMU8sZUFBVCxDQUF5QkksVUFBekIsSUFBdUMsSUFBdkMsR0FBOENzTyxRQUFRLENBQUMxTyxlQUFULENBQXlCSSxVQUF2RSxHQUFvRnNPLFFBQVEsQ0FBQ3pPLElBQVQsQ0FBY0csVUFBMUs7O0FBRUEsbUJBQU9oRixDQUFDLElBQUksQ0FBQ3dWLE1BQWIsRUFBcUI7QUFDbkI7QUFDQUEsY0FBQUEsTUFBTSxHQUFHclEsT0FBTyxDQUFDbkYsQ0FBQyxDQUFDb0YsVUFBSCxDQUFoQjtBQUNBd0ssY0FBQUEsTUFBTSxHQUFHNEYsTUFBTSxHQUFHclUsWUFBSCxHQUFrQm5CLENBQUMsQ0FBQ29GLFVBQW5DOztBQUVBLGtCQUFJNE0sTUFBTSxJQUFJcEMsTUFBTSxDQUFDakwsU0FBUCxHQUFtQmlMLE1BQU0sQ0FBQzFKLGFBQXhDLEVBQXVEO0FBQ3JEMEosZ0JBQUFBLE1BQU0sQ0FBQ2pMLFNBQVAsR0FBbUJpTCxNQUFNLENBQUMxSixhQUExQjtBQUNEOztBQUVELGtCQUFJNkwsTUFBTSxJQUFJbkMsTUFBTSxDQUFDNUssVUFBUCxHQUFvQjRLLE1BQU0sQ0FBQzNKLGFBQXpDLEVBQXdEO0FBQ3REMkosZ0JBQUFBLE1BQU0sQ0FBQzVLLFVBQVAsR0FBb0I0SyxNQUFNLENBQUMzSixhQUEzQjtBQUNEOztBQUVEakcsY0FBQUEsQ0FBQyxHQUFHNFAsTUFBSjtBQUNEO0FBQ0Y7QUFDRjs7QUFFRCxZQUFJL1MsSUFBSSxDQUFDNFosVUFBTCxLQUFvQi9MLGlCQUFpQixJQUFJN04sSUFBSSxDQUFDOGIsSUFBTCxHQUFZN1AsSUFBakMsSUFBeUNqTSxJQUFJLENBQUM4YixJQUFMLEdBQVloUSxJQUFyRCxJQUE2RDlMLElBQUksQ0FBQytiLElBQUwsR0FBWTVQLElBQXpFLElBQWlGbk0sSUFBSSxDQUFDK2IsSUFBTCxHQUFZL1AsSUFBakgsQ0FBSixFQUE0SDtBQUMxSGlQLFVBQUFBLE9BQU8sQ0FBQy9QLElBQUksQ0FBQ3lJLE9BQUwsSUFBZ0J6SSxJQUFJLENBQUNpVixVQUF0QixFQUFrQ3RTLGlCQUFsQyxDQUFQO0FBQ0Q7QUFDRjs7QUFFRCxhQUFPN04sSUFBUDtBQUNELEtBdkVEOztBQXlFQW9VLElBQUFBLE1BQU0sQ0FBQ21PLE1BQVAsR0FBZ0IsVUFBVXJHLFdBQVYsRUFBdUJvRyxNQUF2QixFQUErQkUscUJBQS9CLEVBQXNEO0FBQ3BFLFVBQUlGLE1BQU0sSUFBSXRpQixJQUFJLENBQUN3VCxTQUFuQixFQUE4QjtBQUM1QjtBQUNBLFlBQUlpUCxDQUFDLEdBQUcvaEIsMkVBQWUsQ0FBQytHLE1BQUQsQ0FBdkI7QUFBQSxZQUNJOUMsQ0FBQyxHQUFHeVQsV0FBVyxDQUFDOU0sS0FBWixDQUFrQjtBQUN4QnBDLFVBQUFBLENBQUMsRUFBRWxKLElBQUksQ0FBQ2tKLENBQUwsR0FBUzROLGFBRFk7QUFFeEIzTixVQUFBQSxDQUFDLEVBQUVuSixJQUFJLENBQUNtSixDQUFMLEdBQVM0TjtBQUZZLFNBQWxCLENBRFI7QUFBQSxZQUtJMkwsRUFBRSxHQUFHaGlCLDJFQUFlLENBQUMrRyxNQUFNLENBQUNjLFVBQVIsRUFBb0IsSUFBcEIsQ0FMeEI7QUFNQW1hLFFBQUFBLEVBQUUsQ0FBQ3BYLEtBQUgsQ0FBUztBQUNQcEMsVUFBQUEsQ0FBQyxFQUFFdVosQ0FBQyxDQUFDdGYsQ0FBRixHQUFNd0IsQ0FBQyxDQUFDdUUsQ0FESjtBQUVQQyxVQUFBQSxDQUFDLEVBQUVzWixDQUFDLENBQUM5QyxDQUFGLEdBQU1oYixDQUFDLENBQUN3RTtBQUZKLFNBQVQsRUFHR3hFLENBSEg7QUFJQTNFLFFBQUFBLElBQUksQ0FBQ2tKLENBQUwsSUFBVXZFLENBQUMsQ0FBQ3VFLENBQUYsR0FBTXdaLEVBQUUsQ0FBQ3ZmLENBQW5CO0FBQ0FuRCxRQUFBQSxJQUFJLENBQUNtSixDQUFMLElBQVV4RSxDQUFDLENBQUN3RSxDQUFGLEdBQU11WixFQUFFLENBQUMvQyxDQUFuQjtBQUNBcEgsUUFBQUEsTUFBTSxDQUFDLElBQUQsQ0FBTjtBQUNBaUUsUUFBQUEsb0JBQW9CO0FBQ3JCOztBQUVELFVBQUl0VCxDQUFDLEdBQUdsSixJQUFJLENBQUNrSixDQUFiO0FBQUEsVUFDSUMsQ0FBQyxHQUFHbkosSUFBSSxDQUFDbUosQ0FEYjtBQUVBZ1QsTUFBQUEsWUFBWSxDQUFDLENBQUNtRyxNQUFGLENBQVo7O0FBRUEsVUFBSXBHLFdBQUosRUFBaUI7QUFDZmxjLFFBQUFBLElBQUksQ0FBQ2tjLFdBQUw7QUFDRCxPQUZELE1BRU87QUFDTDVFLFFBQUFBLEtBQUssSUFBSWtMLHFCQUFULElBQWtDakssTUFBTSxDQUFDLElBQUQsQ0FBeEM7QUFDQWdCLFFBQUFBLE1BQU0sQ0FBQyxJQUFELENBQU47QUFDRDs7QUFFRCxVQUFJK0ksTUFBSixFQUFZO0FBQ1ZuSixRQUFBQSxrQkFBa0IsQ0FBQ25aLElBQUksQ0FBQzZZLFFBQU4sRUFBZ0I3WSxJQUFJLENBQUM4WSxRQUFyQixDQUFsQjtBQUNBeEIsUUFBQUEsS0FBSyxJQUFJaUIsTUFBTSxDQUFDLElBQUQsQ0FBZjtBQUNEOztBQUVELFVBQUl2WSxJQUFJLENBQUN3VCxTQUFMLElBQWtCLENBQUM4TyxNQUFuQixLQUE4QnBOLE1BQU0sSUFBSXZTLElBQUksQ0FBQzJiLEdBQUwsQ0FBU3BWLENBQUMsR0FBR2xKLElBQUksQ0FBQ2tKLENBQWxCLElBQXVCLElBQWpDLElBQXlDaU0sTUFBTSxJQUFJeFMsSUFBSSxDQUFDMmIsR0FBTCxDQUFTblYsQ0FBQyxHQUFHbkosSUFBSSxDQUFDbUosQ0FBbEIsSUFBdUIsSUFBakMsSUFBeUMsQ0FBQzRMLFlBQWpILENBQUosRUFBb0k7QUFDbEl5SCxRQUFBQSxvQkFBb0I7QUFDckI7O0FBRUQsVUFBSXhjLElBQUksQ0FBQzBVLFVBQVQsRUFBcUI7QUFDbkIxTCxRQUFBQSxpQkFBaUIsQ0FBQ3ZCLE1BQU0sQ0FBQ2MsVUFBUixFQUFvQnZJLElBQUksQ0FBQ3lZLFVBQXpCLENBQWpCOztBQUVBL0MsUUFBQUEscUJBQXFCLEdBQUcxVixJQUFJLENBQUN5WSxVQUE3QjtBQUNBRixRQUFBQSxNQUFNLENBQUMsSUFBRCxDQUFOLENBSm1CLENBSUw7O0FBRWQvUCxRQUFBQSxxQkFBcUIsQ0FBQ2YsTUFBRCxFQUFTaVosWUFBVCxDQUFyQjs7QUFFQXRZLFFBQUFBLGtCQUFrQixDQUFDWCxNQUFELEVBQVNpWixZQUFULENBQWxCO0FBQ0Q7O0FBRUQsYUFBTzFnQixJQUFQO0FBQ0QsS0FuREQ7O0FBcURBb1UsSUFBQUEsTUFBTSxDQUFDNUMsTUFBUCxHQUFnQixVQUFVdk8sSUFBVixFQUFnQjtBQUM5QixVQUFJMGYsT0FBTyxHQUFHO0FBQ1o5VCxRQUFBQSxJQUFJLEVBQUU7QUFETSxPQUFkO0FBQUEsVUFHSStULEVBSEo7QUFBQSxVQUlJNWQsQ0FKSjtBQUFBLFVBS0lzUSxPQUxKOztBQU9BLFVBQUlwSyxJQUFJLENBQUNxSCxNQUFMLEtBQWdCLEtBQXBCLEVBQTJCO0FBQ3pCb1EsUUFBQUEsT0FBTyxDQUFDcFEsTUFBUixHQUFpQnJILElBQUksQ0FBQ3FILE1BQUwsSUFBZTFRLGNBQWhDO0FBQ0Q7O0FBRUQsVUFBSWpCLElBQUksQ0FBQ3dPLEtBQUwsQ0FBV3dFLFdBQVgsQ0FBdUIsY0FBdkIsQ0FBSixFQUE0QztBQUMxQytPLFFBQUFBLE9BQU8sQ0FBQ0UsWUFBUixHQUF1QixNQUF2QjtBQUNEOztBQUVELFVBQUk1ZixJQUFJLEtBQUssTUFBYixFQUFxQjtBQUNuQjZCLFFBQUFBLGdDQUFnQyxDQUFDdVEsUUFBRCxFQUFXSCxNQUFNLEtBQUtDLE1BQVgsR0FBb0IsTUFBcEIsR0FBNkJqSyxJQUFJLENBQUM0TSx5QkFBTCxJQUFrQ3JRLE1BQU0sQ0FBQ3NJLFlBQVAsS0FBd0J0SSxNQUFNLENBQUNpRCxZQUEvQixNQUFpRGpELE1BQU0sQ0FBQ3FJLFdBQVAsS0FBdUJySSxNQUFNLENBQUNpRCxZQUEvRSxDQUFsQyxJQUFrSVEsSUFBSSxDQUFDMEosaUJBQXZJLEdBQTJKLGNBQTNKLEdBQTRLTSxNQUFNLEdBQUcsT0FBSCxHQUFhLE9BQXZPLENBQWhDLENBRG1CLENBQzhQOzs7QUFHalJsUSxRQUFBQSxDQUFDLEdBQUdxUSxRQUFRLENBQUNwUSxNQUFiOztBQUVBLGVBQU8sRUFBRUQsQ0FBRixHQUFNLENBQUMsQ0FBZCxFQUFpQjtBQUNmc1EsVUFBQUEsT0FBTyxHQUFHRCxRQUFRLENBQUNyUSxDQUFELENBQWxCO0FBQ0FsRCxVQUFBQSxnQkFBZ0IsSUFBSXlFLFlBQVksQ0FBQytPLE9BQUQsRUFBVSxXQUFWLEVBQXVCOEgsT0FBdkIsQ0FBaEM7O0FBRUE3VyxVQUFBQSxZQUFZLENBQUMrTyxPQUFELEVBQVUsWUFBVixFQUF3QjhILE9BQXhCLENBQVo7O0FBRUE3VyxVQUFBQSxZQUFZLENBQUMrTyxPQUFELEVBQVUsT0FBVixFQUFtQnFMLE9BQW5CLEVBQTRCLElBQTVCLENBQVosQ0FOZSxDQU1nQzs7O0FBRy9DL2YsVUFBQUEsSUFBSSxDQUFDZ08sR0FBTCxDQUFTMEcsT0FBVCxFQUFrQnFOLE9BQWxCOztBQUVBLGNBQUlyTixPQUFPLENBQUMvSSxPQUFSLElBQW1CK0ksT0FBTyxDQUFDOUksZUFBL0IsRUFBZ0Q7QUFDOUM7QUFDQTVMLFlBQUFBLElBQUksQ0FBQ2dPLEdBQUwsQ0FBUzBHLE9BQU8sQ0FBQzlJLGVBQWpCLEVBQWtDO0FBQ2hDckgsY0FBQUEsV0FBVyxFQUFFK1AsTUFBTSxLQUFLQyxNQUFYLEdBQW9CLE1BQXBCLEdBQTZCakssSUFBSSxDQUFDNE0seUJBQUwsSUFBa0M1TSxJQUFJLENBQUMwSixpQkFBdkMsR0FBMkQsY0FBM0QsR0FBNEVNLE1BQU0sR0FBRyxPQUFILEdBQWE7QUFEekcsYUFBbEM7QUFHRDs7QUFFRGhLLFVBQUFBLElBQUksQ0FBQ3VTLGdCQUFMLElBQXlCbFgsWUFBWSxDQUFDK08sT0FBRCxFQUFVLGFBQVYsRUFBeUIrQyxhQUF6QixDQUFyQztBQUNEOztBQUVEN0osUUFBQUEsY0FBYyxDQUFDNkcsUUFBRCxFQUFXLEtBQVgsQ0FBZDtBQUNEOztBQUVEak4sTUFBQUEsa0JBQWtCLENBQUNYLE1BQUQsRUFBU2laLFlBQVQsQ0FBbEI7O0FBRUFoSyxNQUFBQSxPQUFPLEdBQUcsSUFBVjs7QUFFQSxVQUFJOVUsYUFBYSxJQUFJcUIsSUFBSSxLQUFLLE1BQTlCLEVBQXNDO0FBQ3BDckIsUUFBQUEsYUFBYSxDQUFDa2hCLEtBQWQsQ0FBb0JuTSxXQUFXLElBQUlsUCxNQUFuQyxFQUEyQ3FOLE1BQU0sR0FBRyxLQUFILEdBQVdDLFlBQVksR0FBRyxVQUFILEdBQWdCLFVBQXhGO0FBQ0Q7O0FBRUR0TixNQUFBQSxNQUFNLENBQUNzYixTQUFQLEdBQW1CSCxFQUFFLEdBQUcsTUFBTTFlLFlBQVksRUFBMUM7QUFDQUQsTUFBQUEsT0FBTyxDQUFDMmUsRUFBRCxDQUFQLEdBQWM1aUIsSUFBZDs7QUFFQSxVQUFJMlcsV0FBSixFQUFpQjtBQUNmQSxRQUFBQSxXQUFXLENBQUNuRixNQUFaO0FBQ0FtRixRQUFBQSxXQUFXLENBQUNuUSxPQUFaLENBQW9CdWMsU0FBcEIsR0FBZ0NILEVBQWhDO0FBQ0Q7O0FBRUQsT0FBQzFYLElBQUksQ0FBQ3dQLE1BQUwsSUFBZTNGLFlBQWhCLEtBQWlDeUgsb0JBQW9CLEVBQXJEO0FBQ0F0UixNQUFBQSxJQUFJLENBQUN3UCxNQUFMLElBQWUxYSxJQUFJLENBQUNrYyxXQUFMLEVBQWY7QUFDQSxhQUFPbGMsSUFBUDtBQUNELEtBakVEOztBQW1FQW9VLElBQUFBLE1BQU0sQ0FBQ2hELE9BQVAsR0FBaUIsVUFBVW5PLElBQVYsRUFBZ0I7QUFDL0IsVUFBSStmLFFBQVEsR0FBR2hqQixJQUFJLENBQUN5WSxVQUFwQjtBQUFBLFVBQ0l6VCxDQUFDLEdBQUdxUSxRQUFRLENBQUNwUSxNQURqQjtBQUFBLFVBRUlxUSxPQUZKOztBQUlBLGFBQU8sRUFBRXRRLENBQUYsR0FBTSxDQUFDLENBQWQsRUFBaUI7QUFDZndFLFFBQUFBLFNBQVMsQ0FBQzZMLFFBQVEsQ0FBQ3JRLENBQUQsQ0FBVCxFQUFjLFFBQWQsRUFBd0IsSUFBeEIsQ0FBVDtBQUNEOztBQUVELFVBQUkvQixJQUFJLEtBQUssTUFBYixFQUFxQjtBQUNuQjZCLFFBQUFBLGdDQUFnQyxDQUFDdVEsUUFBRCxFQUFXLElBQVgsQ0FBaEM7O0FBRUFyUSxRQUFBQSxDQUFDLEdBQUdxUSxRQUFRLENBQUNwUSxNQUFiOztBQUVBLGVBQU8sRUFBRUQsQ0FBRixHQUFNLENBQUMsQ0FBZCxFQUFpQjtBQUNmc1EsVUFBQUEsT0FBTyxHQUFHRCxRQUFRLENBQUNyUSxDQUFELENBQWxCOztBQUVBd0UsVUFBQUEsU0FBUyxDQUFDOEwsT0FBRCxFQUFVLGNBQVYsRUFBMEIsSUFBMUIsQ0FBVDs7QUFFQXpPLFVBQUFBLGVBQWUsQ0FBQ3lPLE9BQUQsRUFBVSxXQUFWLEVBQXVCOEgsT0FBdkIsQ0FBZjs7QUFFQXZXLFVBQUFBLGVBQWUsQ0FBQ3lPLE9BQUQsRUFBVSxZQUFWLEVBQXdCOEgsT0FBeEIsQ0FBZjs7QUFFQXZXLFVBQUFBLGVBQWUsQ0FBQ3lPLE9BQUQsRUFBVSxPQUFWLEVBQW1CcUwsT0FBbkIsQ0FBZjs7QUFFQTlaLFVBQUFBLGVBQWUsQ0FBQ3lPLE9BQUQsRUFBVSxhQUFWLEVBQXlCK0MsYUFBekIsQ0FBZjtBQUNEOztBQUVEN0osUUFBQUEsY0FBYyxDQUFDNkcsUUFBRCxFQUFXLElBQVgsQ0FBZDs7QUFFQSxZQUFJdUMsZ0JBQUosRUFBc0I7QUFDcEIvUSxVQUFBQSxlQUFlLENBQUMrUSxnQkFBRCxFQUFtQixhQUFuQixFQUFrQzBGLFNBQWxDLENBQWY7O0FBRUF6VyxVQUFBQSxlQUFlLENBQUMrUSxnQkFBRCxFQUFtQixVQUFuQixFQUErQjBGLFNBQS9CLENBQWY7O0FBRUF6VyxVQUFBQSxlQUFlLENBQUMrUSxnQkFBRCxFQUFtQixXQUFuQixFQUFnQzJGLE1BQWhDLENBQWY7QUFDRDs7QUFFRDFXLFFBQUFBLGVBQWUsQ0FBQzRQLFFBQUQsRUFBVyxTQUFYLEVBQXNCNkcsU0FBdEIsQ0FBZjs7QUFFQXpXLFFBQUFBLGVBQWUsQ0FBQzRQLFFBQUQsRUFBVyxXQUFYLEVBQXdCOEcsTUFBeEIsQ0FBZjtBQUNEOztBQUVEL1UsTUFBQUEscUJBQXFCLENBQUNmLE1BQUQsRUFBU2laLFlBQVQsQ0FBckI7O0FBRUFoSyxNQUFBQSxPQUFPLEdBQUcsS0FBVjtBQUNBOVUsTUFBQUEsYUFBYSxJQUFJcUIsSUFBSSxLQUFLLE1BQTFCLElBQW9DckIsYUFBYSxDQUFDcWhCLE9BQWQsQ0FBc0J0TSxXQUFXLElBQUlsUCxNQUFyQyxFQUE2Q3FOLE1BQU0sR0FBRyxLQUFILEdBQVdDLFlBQVksR0FBRyxVQUFILEdBQWdCLFVBQTFGLENBQXBDO0FBQ0E0QixNQUFBQSxXQUFXLElBQUlBLFdBQVcsQ0FBQ3ZGLE9BQVosRUFBZjs7QUFFQXRMLE1BQUFBLHNCQUFzQixDQUFDeVMsTUFBRCxDQUF0Qjs7QUFFQXZZLE1BQUFBLElBQUksQ0FBQ3lZLFVBQUwsR0FBa0J6WSxJQUFJLENBQUN3VCxTQUFMLEdBQWlCbUUsVUFBVSxHQUFHLEtBQWhEO0FBQ0FxTCxNQUFBQSxRQUFRLElBQUloWSxjQUFjLENBQUNoTCxJQUFELEVBQU8sU0FBUCxFQUFrQixXQUFsQixDQUExQjtBQUNBLGFBQU9BLElBQVA7QUFDRCxLQXRERDs7QUF3REFvVSxJQUFBQSxNQUFNLENBQUNzQyxPQUFQLEdBQWlCLFVBQVV0VSxLQUFWLEVBQWlCYSxJQUFqQixFQUF1QjtBQUN0QyxhQUFPME4sU0FBUyxDQUFDMUwsTUFBVixHQUFtQjdDLEtBQUssR0FBR3BDLElBQUksQ0FBQ3dSLE1BQUwsQ0FBWXZPLElBQVosQ0FBSCxHQUF1QmpELElBQUksQ0FBQ29SLE9BQUwsQ0FBYW5PLElBQWIsQ0FBL0MsR0FBb0V5VCxPQUEzRTtBQUNELEtBRkQ7O0FBSUF0QyxJQUFBQSxNQUFNLENBQUMwSixJQUFQLEdBQWMsWUFBWTtBQUN4QjlkLE1BQUFBLElBQUksQ0FBQzRaLFVBQUwsR0FBa0IsS0FBbEI7QUFDQTVaLE1BQUFBLElBQUksQ0FBQ2tiLEtBQUwsSUFBY2xiLElBQUksQ0FBQ2tiLEtBQUwsQ0FBVzRDLElBQVgsRUFBZDtBQUNBOWQsTUFBQUEsSUFBSSxDQUFDb1IsT0FBTDtBQUNBeFEsTUFBQUEsSUFBSSxDQUFDZ08sR0FBTCxDQUFTeUcsUUFBVCxFQUFtQjtBQUNqQjZOLFFBQUFBLFVBQVUsRUFBRTtBQURLLE9BQW5CO0FBR0EsYUFBT2pmLE9BQU8sQ0FBQ3dELE1BQU0sQ0FBQ3NiLFNBQVIsQ0FBZDtBQUNBLGFBQU8vaUIsSUFBUDtBQUNELEtBVEQ7O0FBV0EsUUFBSSxDQUFDaUQsSUFBSSxDQUFDd1AsT0FBTCxDQUFhLFFBQWIsQ0FBTCxFQUE2QjtBQUMzQmtFLE1BQUFBLFdBQVcsR0FBR3ZDLE1BQU0sQ0FBQ3VDLFdBQVAsR0FBcUIsSUFBSXhILFdBQUosQ0FBZ0IxSCxNQUFoQixFQUF3QjdDLE9BQU8sQ0FBQztBQUNqRW1NLFFBQUFBLE1BQU0sRUFBRSxTQUFTQSxNQUFULEdBQWtCO0FBQ3hCO0FBQ0EvUSxVQUFBQSxJQUFJLENBQUN3VCxTQUFMLElBQWtCOEosU0FBUyxDQUFDLElBQUQsQ0FBM0I7QUFDRDtBQUpnRSxPQUFELEVBSy9EcFMsSUFMK0QsQ0FBL0IsQ0FBbkMsQ0FEMkIsQ0FNaEI7O0FBRVh6RCxNQUFBQSxNQUFNLENBQUNsRSxLQUFQLENBQWE0ZixTQUFiLEdBQXlCaE8sTUFBTSxJQUFJLENBQUM1VCxjQUFYLEdBQTRCLE1BQTVCLEdBQXFDLFFBQTlEO0FBQ0FrRyxNQUFBQSxNQUFNLENBQUNsRSxLQUFQLENBQWE2ZixTQUFiLEdBQXlCbE8sTUFBTSxJQUFJLENBQUMzVCxjQUFYLEdBQTRCLE1BQTVCLEdBQXFDLFFBQTlEO0FBQ0FrRyxNQUFBQSxNQUFNLEdBQUdrUCxXQUFXLENBQUNySCxPQUFyQjtBQUNEOztBQUVELFFBQUl5RixZQUFKLEVBQWtCO0FBQ2hCUyxNQUFBQSxTQUFTLENBQUNuQixRQUFWLEdBQXFCLENBQXJCO0FBQ0QsS0FGRCxNQUVPO0FBQ0wsVUFBSWEsTUFBSixFQUFZO0FBQ1ZNLFFBQUFBLFNBQVMsQ0FBQ1IsS0FBRCxDQUFULEdBQW1CLENBQW5CO0FBQ0Q7O0FBRUQsVUFBSUcsTUFBSixFQUFZO0FBQ1ZLLFFBQUFBLFNBQVMsQ0FBQ1AsS0FBRCxDQUFULEdBQW1CLENBQW5CO0FBQ0Q7QUFDRjs7QUFFRGlCLElBQUFBLE9BQU8sQ0FBQ3pGLE9BQVIsR0FBa0IsYUFBYXZGLElBQWIsR0FBb0JBLElBQUksQ0FBQ3VGLE9BQXpCLEdBQW1DLElBQXJELENBam9EK0IsQ0Fpb0Q0Qjs7QUFFM0QyRCxJQUFBQSxNQUFNLENBQUM1QyxNQUFQOztBQUVBLFdBQU80QyxNQUFQO0FBQ0Q7O0FBRURGLEVBQUFBLFNBQVMsQ0FBQ21QLFFBQVYsR0FBcUIsU0FBU0EsUUFBVCxDQUFrQmpOLElBQWxCLEVBQXdCO0FBQzNDeFYsSUFBQUEsSUFBSSxHQUFHd1YsSUFBUDs7QUFFQW5FLElBQUFBLFNBQVM7QUFDVixHQUpEOztBQU1BaUMsRUFBQUEsU0FBUyxDQUFDM1QsTUFBVixHQUFtQixTQUFTQSxNQUFULENBQWdCK2lCLE9BQWhCLEVBQXlCcFksSUFBekIsRUFBK0I7QUFDaEQvSixJQUFBQSxZQUFZLElBQUk4USxTQUFTLENBQUMsSUFBRCxDQUF6QjtBQUNBLFdBQU81USxRQUFRLENBQUNpaUIsT0FBRCxDQUFSLENBQWtCQyxHQUFsQixDQUFzQixVQUFVOWIsTUFBVixFQUFrQjtBQUM3QyxhQUFPLElBQUl5TSxTQUFKLENBQWN6TSxNQUFkLEVBQXNCeUQsSUFBdEIsQ0FBUDtBQUNELEtBRk0sQ0FBUDtBQUdELEdBTEQ7O0FBT0FnSixFQUFBQSxTQUFTLENBQUNYLEdBQVYsR0FBZ0IsU0FBU0EsR0FBVCxDQUFhOUwsTUFBYixFQUFxQjtBQUNuQyxXQUFPeEQsT0FBTyxDQUFDLENBQUM1QyxRQUFRLENBQUNvRyxNQUFELENBQVIsQ0FBaUIsQ0FBakIsS0FBdUIsRUFBeEIsRUFBNEJzYixTQUE3QixDQUFkO0FBQ0QsR0FGRDs7QUFJQTdPLEVBQUFBLFNBQVMsQ0FBQ3lOLGFBQVYsR0FBMEIsU0FBU0EsYUFBVCxHQUF5QjtBQUNqRCxXQUFPLENBQUMvZCxRQUFRLEtBQUtRLGFBQWQsSUFBK0IsSUFBdEM7QUFDRCxHQUZEOztBQUlBOFAsRUFBQUEsU0FBUyxDQUFDd04sT0FBVixHQUFvQixTQUFTQSxPQUFULENBQWlCOEIsSUFBakIsRUFBdUJDLElBQXZCLEVBQTZCNUIsU0FBN0IsRUFBd0M7QUFDMUQsUUFBSTJCLElBQUksS0FBS0MsSUFBYixFQUFtQjtBQUNqQixhQUFPLEtBQVA7QUFDRDs7QUFFRCxRQUFJakMsRUFBRSxHQUFHeFgsVUFBVSxDQUFDd1osSUFBRCxDQUFuQjtBQUFBLFFBQ0kvQixFQUFFLEdBQUd6WCxVQUFVLENBQUN5WixJQUFELENBRG5CO0FBQUEsUUFFSXZaLEdBQUcsR0FBR3NYLEVBQUUsQ0FBQ3RYLEdBRmI7QUFBQSxRQUdJRCxJQUFJLEdBQUd1WCxFQUFFLENBQUN2WCxJQUhkO0FBQUEsUUFJSUcsS0FBSyxHQUFHb1gsRUFBRSxDQUFDcFgsS0FKZjtBQUFBLFFBS0lJLE1BQU0sR0FBR2dYLEVBQUUsQ0FBQ2hYLE1BTGhCO0FBQUEsUUFNSUwsS0FBSyxHQUFHcVgsRUFBRSxDQUFDclgsS0FOZjtBQUFBLFFBT0lJLE1BQU0sR0FBR2lYLEVBQUUsQ0FBQ2pYLE1BUGhCO0FBQUEsUUFRSW1aLFNBQVMsR0FBR2pDLEVBQUUsQ0FBQ3hYLElBQUgsR0FBVUcsS0FBVixJQUFtQnFYLEVBQUUsQ0FBQ3JYLEtBQUgsR0FBV0gsSUFBOUIsSUFBc0N3WCxFQUFFLENBQUN2WCxHQUFILEdBQVNNLE1BQS9DLElBQXlEaVgsRUFBRSxDQUFDalgsTUFBSCxHQUFZTixHQVJyRjtBQUFBLFFBU0l5WixPQVRKO0FBQUEsUUFVSUMsSUFWSjtBQUFBLFFBV0lDLE9BWEo7O0FBYUEsUUFBSUgsU0FBUyxJQUFJLENBQUM3QixTQUFsQixFQUE2QjtBQUMzQixhQUFPLENBQUM2QixTQUFSO0FBQ0Q7O0FBRURHLElBQUFBLE9BQU8sR0FBRyxDQUFDaEMsU0FBUyxHQUFHLEVBQWIsRUFBaUJwUCxPQUFqQixDQUF5QixHQUF6QixNQUFrQyxDQUFDLENBQTdDO0FBQ0FvUCxJQUFBQSxTQUFTLEdBQUd6VSxVQUFVLENBQUN5VSxTQUFELENBQVYsSUFBeUIsQ0FBckM7QUFDQThCLElBQUFBLE9BQU8sR0FBRztBQUNSMVosTUFBQUEsSUFBSSxFQUFFdEgsSUFBSSxDQUFDb0csR0FBTCxDQUFTa0IsSUFBVCxFQUFld1gsRUFBRSxDQUFDeFgsSUFBbEIsQ0FERTtBQUVSQyxNQUFBQSxHQUFHLEVBQUV2SCxJQUFJLENBQUNvRyxHQUFMLENBQVNtQixHQUFULEVBQWN1WCxFQUFFLENBQUN2WCxHQUFqQjtBQUZHLEtBQVY7QUFJQXlaLElBQUFBLE9BQU8sQ0FBQ3haLEtBQVIsR0FBZ0J4SCxJQUFJLENBQUNrSixHQUFMLENBQVN6QixLQUFULEVBQWdCcVgsRUFBRSxDQUFDclgsS0FBbkIsSUFBNEJ1WixPQUFPLENBQUMxWixJQUFwRDtBQUNBMFosSUFBQUEsT0FBTyxDQUFDcFosTUFBUixHQUFpQjVILElBQUksQ0FBQ2tKLEdBQUwsQ0FBU3JCLE1BQVQsRUFBaUJpWCxFQUFFLENBQUNqWCxNQUFwQixJQUE4Qm1aLE9BQU8sQ0FBQ3paLEdBQXZEOztBQUVBLFFBQUl5WixPQUFPLENBQUN4WixLQUFSLEdBQWdCLENBQWhCLElBQXFCd1osT0FBTyxDQUFDcFosTUFBUixHQUFpQixDQUExQyxFQUE2QztBQUMzQyxhQUFPLEtBQVA7QUFDRDs7QUFFRCxRQUFJc1osT0FBSixFQUFhO0FBQ1hoQyxNQUFBQSxTQUFTLElBQUksSUFBYjtBQUNBK0IsTUFBQUEsSUFBSSxHQUFHRCxPQUFPLENBQUN4WixLQUFSLEdBQWdCd1osT0FBTyxDQUFDcFosTUFBL0I7QUFDQSxhQUFPcVosSUFBSSxJQUFJelosS0FBSyxHQUFHSSxNQUFSLEdBQWlCc1gsU0FBekIsSUFBc0MrQixJQUFJLElBQUluQyxFQUFFLENBQUN0WCxLQUFILEdBQVdzWCxFQUFFLENBQUNsWCxNQUFkLEdBQXVCc1gsU0FBNUU7QUFDRDs7QUFFRCxXQUFPOEIsT0FBTyxDQUFDeFosS0FBUixHQUFnQjBYLFNBQWhCLElBQTZCOEIsT0FBTyxDQUFDcFosTUFBUixHQUFpQnNYLFNBQXJEO0FBQ0QsR0ExQ0Q7O0FBNENBLFNBQU8zTixTQUFQO0FBQ0QsQ0E3c0RtQyxDQTZzRGxDSCxlQTdzRGtDLENBQTdCOztBQStzRFB6TixZQUFZLENBQUM0TixTQUFTLENBQUM3VCxTQUFYLEVBQXNCO0FBQ2hDd1ksRUFBQUEsUUFBUSxFQUFFLENBRHNCO0FBRWhDQyxFQUFBQSxRQUFRLEVBQUUsQ0FGc0I7QUFHaENrRSxFQUFBQSxNQUFNLEVBQUUsQ0FId0I7QUFJaENDLEVBQUFBLE1BQU0sRUFBRSxDQUp3QjtBQUtoQzdELEVBQUFBLE1BQU0sRUFBRSxDQUx3QjtBQU1oQ0UsRUFBQUEsTUFBTSxFQUFFLENBTndCO0FBT2hDYixFQUFBQSxVQUFVLEVBQUUsS0FQb0I7QUFRaENqRixFQUFBQSxTQUFTLEVBQUU7QUFScUIsQ0FBdEIsQ0FBWjs7QUFXQVUsU0FBUyxDQUFDOEosTUFBVixHQUFtQixJQUFuQjtBQUNBOUosU0FBUyxDQUFDNFAsT0FBVixHQUFvQixRQUFwQjtBQUNBN2hCLFFBQVEsTUFBTXJCLElBQUksQ0FBQ3NCLGNBQUwsQ0FBb0JnUyxTQUFwQixDQUFkOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUMzbUZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk4UCxXQUFXLEdBQUcsa0RBQWxCO0FBQUEsSUFDSUMsV0FBVyxHQUFHLHlDQURsQjtBQUFBLElBRUlDLFdBQVcsR0FBRywrQkFGbEI7QUFBQSxJQUdJQyxZQUFZLEdBQUcsMkJBSG5CO0FBQUEsSUFJSUMsUUFBUSxHQUFHemhCLElBQUksQ0FBQ2MsRUFBTCxHQUFVLEdBSnpCO0FBQUEsSUFLSUQsUUFBUSxHQUFHLE1BQU1iLElBQUksQ0FBQ2MsRUFMMUI7QUFBQSxJQU1JNGdCLElBQUksR0FBRzFoQixJQUFJLENBQUMyaEIsR0FOaEI7QUFBQSxJQU9JQyxJQUFJLEdBQUc1aEIsSUFBSSxDQUFDNmhCLEdBUGhCO0FBQUEsSUFRSUMsSUFBSSxHQUFHOWhCLElBQUksQ0FBQzJiLEdBUmhCO0FBQUEsSUFTSW9HLEtBQUssR0FBRy9oQixJQUFJLENBQUNnaUIsSUFUakI7QUFBQSxJQVVJQyxNQUFNLEdBQUdqaUIsSUFBSSxDQUFDb2EsS0FWbEI7QUFBQSxJQVdJOEgsU0FBUyxHQUFHLEdBWGhCO0FBQUEsSUFZSUMsU0FBUyxHQUFHLFNBQVNBLFNBQVQsQ0FBbUIxaUIsS0FBbkIsRUFBMEI7QUFDeEMsU0FBTyxPQUFPQSxLQUFQLEtBQWlCLFFBQXhCO0FBQ0QsQ0FkRDtBQUFBLElBZUkyaUIsU0FBUyxHQUFHLFNBQVNBLFNBQVQsQ0FBbUIzaUIsS0FBbkIsRUFBMEI7QUFDeEMsU0FBTyxPQUFPQSxLQUFQLEtBQWlCLFFBQXhCO0FBQ0QsQ0FqQkQ7QUFBQSxJQWtCSUUsWUFBWSxHQUFHLFNBQVNBLFlBQVQsQ0FBc0JGLEtBQXRCLEVBQTZCO0FBQzlDLFNBQU8sT0FBT0EsS0FBUCxLQUFpQixXQUF4QjtBQUNELENBcEJEO0FBQUEsSUFxQkk0aUIsS0FBSyxHQUFHLEVBckJaO0FBQUEsSUFzQklDLE1BQU0sR0FBRyxFQXRCYjtBQUFBLElBdUJJQyxZQUFZLEdBQUcsR0F2Qm5CO0FBQUEsSUF3QklDLGFBQWEsR0FBRyxTQUFTQSxhQUFULENBQXVCQyxRQUF2QixFQUFpQztBQUNuRCxTQUFPemlCLElBQUksQ0FBQ0MsS0FBTCxDQUFXLENBQUN3aUIsUUFBUSxHQUFHUCxTQUFaLElBQXlCLENBQXpCLEdBQTZCSyxZQUF4QyxJQUF3REEsWUFBeEQsS0FBeUVFLFFBQVEsR0FBRyxDQUFYLEdBQWUsQ0FBZixHQUFtQixDQUE1RixDQUFQO0FBQ0QsQ0ExQkQ7QUFBQSxJQTJCSTtBQUNKMWlCLE1BQU0sR0FBRyxTQUFTQSxNQUFULENBQWdCTixLQUFoQixFQUF1QjtBQUM5QixTQUFPTyxJQUFJLENBQUNDLEtBQUwsQ0FBV1IsS0FBSyxHQUFHOGlCLFlBQW5CLElBQW1DQSxZQUFuQyxJQUFtRCxDQUExRDtBQUNELENBOUJEO0FBQUEsSUErQklHLGFBQWEsR0FBRyxTQUFTQSxhQUFULENBQXVCampCLEtBQXZCLEVBQThCO0FBQ2hELFNBQU9PLElBQUksQ0FBQ0MsS0FBTCxDQUFXUixLQUFLLEdBQUcsSUFBbkIsSUFBMkIsSUFBM0IsSUFBbUMsQ0FBMUM7QUFDRCxDQWpDRDtBQUFBLElBa0NJa2pCLGFBQWEsR0FBRyxTQUFTQSxhQUFULENBQXVCQyxPQUF2QixFQUFnQ0MsUUFBaEMsRUFBMEN4Z0IsQ0FBMUMsRUFBNkN5Z0IsQ0FBN0MsRUFBZ0Q7QUFDbEUsTUFBSUMsT0FBTyxHQUFHSCxPQUFPLENBQUNDLFFBQUQsQ0FBckI7QUFBQSxNQUNJRyxLQUFLLEdBQUdGLENBQUMsS0FBSyxDQUFOLEdBQVUsQ0FBVixHQUFjRyxnQkFBZ0IsQ0FBQ0YsT0FBRCxFQUFVMWdCLENBQVYsRUFBYXlnQixDQUFiLENBRDFDOztBQUdBLE1BQUlFLEtBQUssSUFBSUEsS0FBSyxHQUFHM2dCLENBQVIsR0FBWSxDQUFaLEdBQWdCMGdCLE9BQU8sQ0FBQ3pnQixNQUFyQyxFQUE2QztBQUMzQ3NnQixJQUFBQSxPQUFPLENBQUN4ZixNQUFSLENBQWV5ZixRQUFmLEVBQXlCLENBQXpCLEVBQTRCRSxPQUFPLENBQUNHLEtBQVIsQ0FBYyxDQUFkLEVBQWlCN2dCLENBQUMsR0FBRzJnQixLQUFKLEdBQVksQ0FBN0IsQ0FBNUI7QUFDQUQsSUFBQUEsT0FBTyxDQUFDM2YsTUFBUixDQUFlLENBQWYsRUFBa0JmLENBQUMsR0FBRzJnQixLQUF0QjtBQUNBLFdBQU8sQ0FBUDtBQUNEO0FBQ0YsQ0EzQ0Q7QUFBQSxJQTRDSUcsZUFBZSxHQUFHLFNBQVNBLGVBQVQsQ0FBeUJDLE9BQXpCLEVBQWtDOWdCLE1BQWxDLEVBQTBDbWdCLFFBQTFDLEVBQW9EO0FBQ3hFO0FBQ0EsTUFBSXJYLENBQUMsR0FBR2dZLE9BQU8sQ0FBQzlnQixNQUFoQjtBQUFBLE1BQ0lELENBQUMsR0FBRyxDQUFDLEVBQUVvZ0IsUUFBUSxHQUFHclgsQ0FBYixDQURUOztBQUdBLE1BQUlnWSxPQUFPLENBQUMvZ0IsQ0FBRCxDQUFQLEdBQWFDLE1BQWpCLEVBQXlCO0FBQ3ZCLFdBQU8sRUFBRUQsQ0FBRixJQUFPK2dCLE9BQU8sQ0FBQy9nQixDQUFELENBQVAsR0FBYUMsTUFBM0IsRUFBbUMsQ0FBRTs7QUFFckNELElBQUFBLENBQUMsR0FBRyxDQUFKLEtBQVVBLENBQUMsR0FBRyxDQUFkO0FBQ0QsR0FKRCxNQUlPO0FBQ0wsV0FBTytnQixPQUFPLENBQUMsRUFBRS9nQixDQUFILENBQVAsR0FBZUMsTUFBZixJQUF5QkQsQ0FBQyxHQUFHK0ksQ0FBcEMsRUFBdUMsQ0FBRTtBQUMxQzs7QUFFRCxTQUFPL0ksQ0FBQyxHQUFHK0ksQ0FBSixHQUFRL0ksQ0FBUixHQUFZK0ksQ0FBQyxHQUFHLENBQXZCO0FBQ0QsQ0ExREQ7QUFBQSxJQTJESWlZLGVBQWUsR0FBRyxTQUFTQSxlQUFULENBQXlCVCxPQUF6QixFQUFrQ1UsU0FBbEMsRUFBNkM7QUFDakUsTUFBSWpoQixDQUFDLEdBQUd1Z0IsT0FBTyxDQUFDdGdCLE1BQWhCO0FBQ0FnaEIsRUFBQUEsU0FBUyxJQUFJVixPQUFPLENBQUNXLE9BQVIsRUFBYjs7QUFFQSxTQUFPbGhCLENBQUMsRUFBUixFQUFZO0FBQ1Z1Z0IsSUFBQUEsT0FBTyxDQUFDdmdCLENBQUQsQ0FBUCxDQUFXbWhCLFFBQVgsSUFBdUJDLGNBQWMsQ0FBQ2IsT0FBTyxDQUFDdmdCLENBQUQsQ0FBUixDQUFyQztBQUNEO0FBQ0YsQ0FsRUQ7QUFBQSxJQW1FSXFoQixhQUFhLEdBQUcsU0FBU0EsYUFBVCxDQUF1QkMsTUFBdkIsRUFBK0I1aEIsSUFBL0IsRUFBcUM7QUFDdkRBLEVBQUFBLElBQUksQ0FBQzZoQixXQUFMLEdBQW1CRCxNQUFNLENBQUNDLFdBQTFCOztBQUVBLE1BQUlELE1BQU0sQ0FBQ1AsT0FBWCxFQUFvQjtBQUNsQjtBQUNBcmhCLElBQUFBLElBQUksQ0FBQ3FoQixPQUFMLEdBQWVPLE1BQU0sQ0FBQ1AsT0FBUCxDQUFlRixLQUFmLENBQXFCLENBQXJCLENBQWY7QUFDQW5oQixJQUFBQSxJQUFJLENBQUM4aEIsTUFBTCxHQUFjRixNQUFNLENBQUNFLE1BQVAsQ0FBY1gsS0FBZCxDQUFvQixDQUFwQixDQUFkO0FBQ0FuaEIsSUFBQUEsSUFBSSxDQUFDK2hCLFNBQUwsR0FBaUJILE1BQU0sQ0FBQ0csU0FBeEI7QUFDQS9oQixJQUFBQSxJQUFJLENBQUNnaUIsVUFBTCxHQUFrQkosTUFBTSxDQUFDSSxVQUF6QjtBQUNELEdBTkQsTUFNTyxJQUFJSixNQUFNLENBQUNLLFdBQVgsRUFBd0I7QUFDN0I7QUFDQWppQixJQUFBQSxJQUFJLENBQUNpaUIsV0FBTCxHQUFtQkwsTUFBTSxDQUFDSyxXQUExQjtBQUNEOztBQUVELFNBQU9qaUIsSUFBUDtBQUNELENBbEZEO0FBQUEsSUFtRkk7QUFDSmtpQixjQUFjLEdBQUcsU0FBU0EsY0FBVCxDQUF3QnJCLE9BQXhCLEVBQWlDRyxPQUFqQyxFQUEwQztBQUN6RCxNQUFJbUIsS0FBSyxHQUFHdEIsT0FBTyxDQUFDdGdCLE1BQXBCO0FBQUEsTUFDSTZoQixPQUFPLEdBQUd2QixPQUFPLENBQUNzQixLQUFLLEdBQUcsQ0FBVCxDQUFQLElBQXNCLEVBRHBDO0FBQUEsTUFFSTlZLENBQUMsR0FBRytZLE9BQU8sQ0FBQzdoQixNQUZoQjs7QUFJQSxNQUFJNGhCLEtBQUssSUFBSW5CLE9BQU8sQ0FBQyxDQUFELENBQVAsS0FBZW9CLE9BQU8sQ0FBQy9ZLENBQUMsR0FBRyxDQUFMLENBQS9CLElBQTBDMlgsT0FBTyxDQUFDLENBQUQsQ0FBUCxLQUFlb0IsT0FBTyxDQUFDL1ksQ0FBQyxHQUFHLENBQUwsQ0FBcEUsRUFBNkU7QUFDM0UyWCxJQUFBQSxPQUFPLEdBQUdvQixPQUFPLENBQUNDLE1BQVIsQ0FBZXJCLE9BQU8sQ0FBQ0csS0FBUixDQUFjLENBQWQsQ0FBZixDQUFWO0FBQ0FnQixJQUFBQSxLQUFLO0FBQ047O0FBRUR0QixFQUFBQSxPQUFPLENBQUNzQixLQUFELENBQVAsR0FBaUJuQixPQUFqQjtBQUNELENBL0ZEO0FBQUEsSUFnR0lzQixhQWhHSjtBQWlHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR08sU0FBU0MsVUFBVCxDQUFvQjdrQixLQUFwQixFQUEyQjtBQUNoQ0EsRUFBQUEsS0FBSyxHQUFHMGlCLFNBQVMsQ0FBQzFpQixLQUFELENBQVQsSUFBb0IraEIsWUFBWSxDQUFDN1YsSUFBYixDQUFrQmxNLEtBQWxCLENBQXBCLEdBQStDbU4sUUFBUSxDQUFDMlgsYUFBVCxDQUF1QjlrQixLQUF2QixLQUFpQ0EsS0FBaEYsR0FBd0ZBLEtBQWhHO0FBQ0EsTUFBSWUsQ0FBQyxHQUFHZixLQUFLLENBQUNnTSxZQUFOLEdBQXFCaE0sS0FBckIsR0FBNkIsQ0FBckM7QUFBQSxNQUNJbWpCLE9BREo7O0FBR0EsTUFBSXBpQixDQUFDLEtBQUtmLEtBQUssR0FBR0EsS0FBSyxDQUFDZ00sWUFBTixDQUFtQixHQUFuQixDQUFiLENBQUwsRUFBNEM7QUFDMUM7QUFDQSxRQUFJLENBQUNqTCxDQUFDLENBQUNna0IsT0FBUCxFQUFnQjtBQUNkaGtCLE1BQUFBLENBQUMsQ0FBQ2drQixPQUFGLEdBQVksRUFBWjtBQUNEOztBQUVENUIsSUFBQUEsT0FBTyxHQUFHcGlCLENBQUMsQ0FBQ2drQixPQUFGLENBQVUva0IsS0FBVixDQUFWO0FBQ0EsV0FBT21qQixPQUFPLElBQUksQ0FBQ0EsT0FBTyxDQUFDNkIsTUFBcEIsR0FBNkI3QixPQUE3QixHQUF1Q3BpQixDQUFDLENBQUNna0IsT0FBRixDQUFVL2tCLEtBQVYsSUFBbUJpbEIsZUFBZSxDQUFDamxCLEtBQUQsQ0FBaEY7QUFDRDs7QUFFRCxTQUFPLENBQUNBLEtBQUQsR0FBU3lSLE9BQU8sQ0FBQ0MsSUFBUixDQUFhLHVEQUFiLENBQVQsR0FBaUZnUixTQUFTLENBQUMxaUIsS0FBRCxDQUFULEdBQW1CaWxCLGVBQWUsQ0FBQ2psQixLQUFELENBQWxDLEdBQTRDMmlCLFNBQVMsQ0FBQzNpQixLQUFLLENBQUMsQ0FBRCxDQUFOLENBQVQsR0FBc0IsQ0FBQ0EsS0FBRCxDQUF0QixHQUFnQ0EsS0FBcEs7QUFDRCxFQUFDOztBQUVLLFNBQVNrbEIsV0FBVCxDQUFxQi9CLE9BQXJCLEVBQThCO0FBQ25DLE1BQUl6WCxDQUFDLEdBQUcsRUFBUjtBQUFBLE1BQ0k5SSxDQUFDLEdBQUcsQ0FEUjs7QUFHQSxTQUFPQSxDQUFDLEdBQUd1Z0IsT0FBTyxDQUFDdGdCLE1BQW5CLEVBQTJCRCxDQUFDLEVBQTVCLEVBQWdDO0FBQzlCOEksSUFBQUEsQ0FBQyxDQUFDOUksQ0FBRCxDQUFELEdBQU9xaEIsYUFBYSxDQUFDZCxPQUFPLENBQUN2Z0IsQ0FBRCxDQUFSLEVBQWF1Z0IsT0FBTyxDQUFDdmdCLENBQUQsQ0FBUCxDQUFXNmdCLEtBQVgsQ0FBaUIsQ0FBakIsQ0FBYixDQUFwQjtBQUNEOztBQUVELFNBQU9RLGFBQWEsQ0FBQ2QsT0FBRCxFQUFVelgsQ0FBVixDQUFwQjtBQUNEO0FBQ00sU0FBU3NZLGNBQVQsQ0FBd0JWLE9BQXhCLEVBQWlDO0FBQ3RDLE1BQUkxZ0IsQ0FBQyxHQUFHLENBQVI7QUFBQSxNQUNJbUUsQ0FESjtBQUVBdWMsRUFBQUEsT0FBTyxDQUFDUSxPQUFSLEdBSHNDLENBR25COztBQUVuQixTQUFPbGhCLENBQUMsR0FBRzBnQixPQUFPLENBQUN6Z0IsTUFBbkIsRUFBMkJELENBQUMsSUFBSSxDQUFoQyxFQUFtQztBQUNqQ21FLElBQUFBLENBQUMsR0FBR3VjLE9BQU8sQ0FBQzFnQixDQUFELENBQVg7QUFDQTBnQixJQUFBQSxPQUFPLENBQUMxZ0IsQ0FBRCxDQUFQLEdBQWEwZ0IsT0FBTyxDQUFDMWdCLENBQUMsR0FBRyxDQUFMLENBQXBCO0FBQ0EwZ0IsSUFBQUEsT0FBTyxDQUFDMWdCLENBQUMsR0FBRyxDQUFMLENBQVAsR0FBaUJtRSxDQUFqQjtBQUNEOztBQUVEdWMsRUFBQUEsT0FBTyxDQUFDUyxRQUFSLEdBQW1CLENBQUNULE9BQU8sQ0FBQ1MsUUFBNUI7QUFDRDs7QUFFRCxJQUFJb0IsV0FBVyxHQUFHLFNBQVNBLFdBQVQsQ0FBcUJwa0IsQ0FBckIsRUFBd0Jxa0IsTUFBeEIsRUFBZ0M7QUFDaEQsTUFBSUMsSUFBSSxHQUFHbFksUUFBUSxDQUFDbk0sZUFBVCxDQUF5Qiw0QkFBekIsRUFBdUQsTUFBdkQsQ0FBWDtBQUFBLE1BQ0lza0IsSUFBSSxHQUFHLEdBQUc3QixLQUFILENBQVM1WCxJQUFULENBQWM5SyxDQUFDLENBQUN3a0IsVUFBaEIsQ0FEWDtBQUFBLE1BRUkzaUIsQ0FBQyxHQUFHMGlCLElBQUksQ0FBQ3ppQixNQUZiO0FBQUEsTUFHSTJpQixJQUhKO0FBSUFKLEVBQUFBLE1BQU0sR0FBRyxNQUFNQSxNQUFOLEdBQWUsR0FBeEI7O0FBRUEsU0FBTyxFQUFFeGlCLENBQUYsR0FBTSxDQUFDLENBQWQsRUFBaUI7QUFDZjRpQixJQUFBQSxJQUFJLEdBQUdGLElBQUksQ0FBQzFpQixDQUFELENBQUosQ0FBUXVKLFFBQVIsQ0FBaUI3RSxXQUFqQixFQUFQLENBRGUsQ0FDd0I7O0FBRXZDLFFBQUk4ZCxNQUFNLENBQUMvVSxPQUFQLENBQWUsTUFBTW1WLElBQU4sR0FBYSxHQUE1QixJQUFtQyxDQUF2QyxFQUEwQztBQUN4Q0gsTUFBQUEsSUFBSSxDQUFDSSxjQUFMLENBQW9CLElBQXBCLEVBQTBCRCxJQUExQixFQUFnQ0YsSUFBSSxDQUFDMWlCLENBQUQsQ0FBSixDQUFROGlCLFNBQXhDO0FBQ0Q7QUFDRjs7QUFFRCxTQUFPTCxJQUFQO0FBQ0QsQ0FoQkQ7QUFBQSxJQWlCSU0sVUFBVSxHQUFHO0FBQ2ZuUCxFQUFBQSxJQUFJLEVBQUUsd0JBRFM7QUFFZm9QLEVBQUFBLE1BQU0sRUFBRSxTQUZPO0FBR2ZDLEVBQUFBLE9BQU8sRUFBRSxhQUhNO0FBSWZDLEVBQUFBLElBQUksRUFBRTtBQUpTLENBakJqQjtBQUFBLElBdUJJQyxVQUFVLEdBQUcsU0FBU0EsVUFBVCxDQUFvQmhsQixDQUFwQixFQUF1QmlsQixLQUF2QixFQUE4QjtBQUM3QyxNQUFJQyxLQUFLLEdBQUdELEtBQUssR0FBR0EsS0FBSyxDQUFDaFYsS0FBTixDQUFZLEdBQVosQ0FBSCxHQUFzQixFQUF2QztBQUFBLE1BQ0k1TyxHQUFHLEdBQUcsRUFEVjtBQUFBLE1BRUlRLENBQUMsR0FBR3FqQixLQUFLLENBQUNwakIsTUFGZDs7QUFJQSxTQUFPLEVBQUVELENBQUYsR0FBTSxDQUFDLENBQWQsRUFBaUI7QUFDZlIsSUFBQUEsR0FBRyxDQUFDNmpCLEtBQUssQ0FBQ3JqQixDQUFELENBQU4sQ0FBSCxHQUFnQixDQUFDN0IsQ0FBQyxDQUFDaUwsWUFBRixDQUFlaWEsS0FBSyxDQUFDcmpCLENBQUQsQ0FBcEIsQ0FBRCxJQUE2QixDQUE3QztBQUNEOztBQUVELFNBQU9SLEdBQVA7QUFDRCxDQWpDRCxFQWlDRzs7O0FBR0ksU0FBUzhqQixtQkFBVCxDQUF1QjloQixPQUF2QixFQUFnQytoQixJQUFoQyxFQUFzQztBQUMzQyxNQUFJdGxCLElBQUksR0FBR3VELE9BQU8sQ0FBQ2dpQixPQUFSLENBQWdCOWUsV0FBaEIsRUFBWDtBQUFBLE1BQ0krZSxJQUFJLEdBQUcsY0FEWDtBQUFBLE1BRUlwaUIsSUFGSjtBQUFBLE1BR0k2QyxDQUhKO0FBQUEsTUFJSUMsQ0FKSjtBQUFBLE1BS0l5QixDQUxKO0FBQUEsTUFNSThkLEVBTko7QUFBQSxNQU9JakIsSUFQSjtBQUFBLE1BUUlrQixLQVJKO0FBQUEsTUFTSUMsTUFUSjtBQUFBLE1BVUk5TixNQVZKO0FBQUEsTUFXSStOLENBWEo7QUFBQSxNQVlJQyxDQVpKO0FBQUEsTUFhSUMsRUFiSjtBQUFBLE1BY0lDLEVBZEo7QUFBQSxNQWVJQyxFQWZKO0FBQUEsTUFnQklDLEVBaEJKO0FBQUEsTUFpQklDLEVBakJKO0FBQUEsTUFrQklDLEVBbEJKO0FBQUEsTUFtQklDLEVBbkJKO0FBQUEsTUFvQklDLEVBcEJKO0FBQUEsTUFxQklDLEVBckJKO0FBQUEsTUFzQklDLEVBdEJKO0FBQUEsTUF1Qkk5QixJQXZCSjs7QUF5QkEsTUFBSXprQixJQUFJLEtBQUssTUFBVCxJQUFtQixDQUFDdUQsT0FBTyxDQUFDK0YsT0FBaEMsRUFBeUM7QUFDdkMsV0FBTy9GLE9BQVA7QUFDRDs7QUFFRGloQixFQUFBQSxJQUFJLEdBQUdGLFdBQVcsQ0FBQy9nQixPQUFELEVBQVUsbURBQVYsQ0FBbEI7QUFDQWtoQixFQUFBQSxJQUFJLEdBQUdTLFVBQVUsQ0FBQzNoQixPQUFELEVBQVV1aEIsVUFBVSxDQUFDOWtCLElBQUQsQ0FBcEIsQ0FBakI7O0FBRUEsTUFBSUEsSUFBSSxLQUFLLE1BQWIsRUFBcUI7QUFDbkIySCxJQUFBQSxDQUFDLEdBQUc4YyxJQUFJLENBQUMrQixFQUFUO0FBQ0FmLElBQUFBLEVBQUUsR0FBR2hCLElBQUksQ0FBQ2dCLEVBQUwsSUFBVzlkLENBQWhCO0FBQ0ExQixJQUFBQSxDQUFDLEdBQUd3ZSxJQUFJLENBQUN4ZSxDQUFUO0FBQ0FDLElBQUFBLENBQUMsR0FBR3VlLElBQUksQ0FBQ3ZlLENBQVQ7QUFDQTBmLElBQUFBLENBQUMsR0FBR25CLElBQUksQ0FBQ3ZkLEtBQUwsR0FBYVMsQ0FBQyxHQUFHLENBQXJCO0FBQ0FrZSxJQUFBQSxDQUFDLEdBQUdwQixJQUFJLENBQUNuZCxNQUFMLEdBQWNtZSxFQUFFLEdBQUcsQ0FBdkI7O0FBRUEsUUFBSTlkLENBQUMsSUFBSThkLEVBQVQsRUFBYTtBQUNYO0FBQ0FLLE1BQUFBLEVBQUUsR0FBRzdmLENBQUMsR0FBRzBCLENBQUMsSUFBSSxJQUFJNmQsSUFBUixDQUFWO0FBQ0FPLE1BQUFBLEVBQUUsR0FBRzlmLENBQUMsR0FBRzBCLENBQVQ7QUFDQXFlLE1BQUFBLEVBQUUsR0FBR0QsRUFBRSxHQUFHSCxDQUFWO0FBQ0FLLE1BQUFBLEVBQUUsR0FBR0QsRUFBRSxHQUFHcmUsQ0FBQyxHQUFHNmQsSUFBZDtBQUNBVSxNQUFBQSxFQUFFLEdBQUdGLEVBQUUsR0FBR3JlLENBQVY7QUFDQXdlLE1BQUFBLEVBQUUsR0FBR2pnQixDQUFDLEdBQUd1ZixFQUFFLElBQUksSUFBSUQsSUFBUixDQUFYO0FBQ0FZLE1BQUFBLEVBQUUsR0FBR2xnQixDQUFDLEdBQUd1ZixFQUFUO0FBQ0FZLE1BQUFBLEVBQUUsR0FBR0QsRUFBRSxHQUFHUCxDQUFWO0FBQ0FTLE1BQUFBLEVBQUUsR0FBR0QsRUFBRSxHQUFHWixFQUFFLEdBQUdELElBQWY7QUFDQWUsTUFBQUEsRUFBRSxHQUFHRixFQUFFLEdBQUdaLEVBQVY7QUFDQXJpQixNQUFBQSxJQUFJLEdBQUcsTUFBTThpQixFQUFOLEdBQVcsR0FBWCxHQUFpQkUsRUFBakIsR0FBc0IsSUFBdEIsR0FBNkJDLEVBQTdCLEdBQWtDLElBQWxDLEdBQXlDLENBQUNILEVBQUQsRUFBS0ksRUFBTCxFQUFTTCxFQUFULEVBQWFNLEVBQWIsRUFBaUJQLEVBQWpCLEVBQXFCTyxFQUFyQixFQUF5QlAsRUFBRSxHQUFHLENBQUNBLEVBQUUsR0FBR0QsRUFBTixJQUFZLENBQTFDLEVBQTZDUSxFQUE3QyxFQUFpRFIsRUFBRSxHQUFHLENBQUNDLEVBQUUsR0FBR0QsRUFBTixJQUFZLENBQWxFLEVBQXFFUSxFQUFyRSxFQUF5RVIsRUFBekUsRUFBNkVRLEVBQTdFLEVBQWlGVCxFQUFqRixFQUFxRlMsRUFBckYsRUFBeUZ0Z0IsQ0FBekYsRUFBNEZxZ0IsRUFBNUYsRUFBZ0dyZ0IsQ0FBaEcsRUFBbUdvZ0IsRUFBbkcsRUFBdUdwZ0IsQ0FBdkcsRUFBMEdvZ0IsRUFBRSxHQUFHLENBQUNBLEVBQUUsR0FBR0QsRUFBTixJQUFZLENBQTNILEVBQThIbmdCLENBQTlILEVBQWlJbWdCLEVBQUUsR0FBRyxDQUFDQyxFQUFFLEdBQUdELEVBQU4sSUFBWSxDQUFsSixFQUFxSm5nQixDQUFySixFQUF3Sm1nQixFQUF4SixFQUE0Sm5nQixDQUE1SixFQUErSmtnQixFQUEvSixFQUFtS0wsRUFBbkssRUFBdUs1ZixDQUF2SyxFQUEwSzZmLEVBQTFLLEVBQThLN2YsQ0FBOUssRUFBaUw2ZixFQUFFLEdBQUcsQ0FBQ0MsRUFBRSxHQUFHRCxFQUFOLElBQVksQ0FBbE0sRUFBcU03ZixDQUFyTSxFQUF3TThmLEVBQUUsR0FBRyxDQUFDQSxFQUFFLEdBQUdELEVBQU4sSUFBWSxDQUF6TixFQUE0TjdmLENBQTVOLEVBQStOOGYsRUFBL04sRUFBbU85ZixDQUFuTyxFQUFzTytmLEVBQXRPLEVBQTBPL2YsQ0FBMU8sRUFBNk9nZ0IsRUFBN08sRUFBaVBDLEVBQWpQLEVBQXFQRCxFQUFyUCxFQUF5UEUsRUFBelAsRUFBNlBLLElBQTdQLENBQWtRLEdBQWxRLENBQXpDLEdBQWtULEdBQXpUO0FBQ0QsS0FiRCxNQWFPO0FBQ0xyakIsTUFBQUEsSUFBSSxHQUFHLE9BQU82QyxDQUFDLEdBQUcyZixDQUFYLElBQWdCLEdBQWhCLEdBQXNCMWYsQ0FBdEIsR0FBMEIsSUFBMUIsR0FBaUMyZixDQUFqQyxHQUFxQyxJQUFyQyxHQUE0QyxDQUFDRCxDQUE3QyxHQUFpRCxJQUFqRCxHQUF3RCxDQUFDQyxDQUF6RCxHQUE2RCxJQUE3RCxHQUFvRUQsQ0FBcEUsR0FBd0UsR0FBL0U7QUFDRDtBQUNGLEdBeEJELE1Bd0JPLElBQUk1bEIsSUFBSSxLQUFLLFFBQVQsSUFBcUJBLElBQUksS0FBSyxTQUFsQyxFQUE2QztBQUNsRCxRQUFJQSxJQUFJLEtBQUssUUFBYixFQUF1QjtBQUNyQjJILE1BQUFBLENBQUMsR0FBRzhkLEVBQUUsR0FBR2hCLElBQUksQ0FBQzljLENBQWQ7QUFDQWdlLE1BQUFBLE1BQU0sR0FBR2hlLENBQUMsR0FBRzZkLElBQWI7QUFDRCxLQUhELE1BR087QUFDTDdkLE1BQUFBLENBQUMsR0FBRzhjLElBQUksQ0FBQytCLEVBQVQ7QUFDQWYsTUFBQUEsRUFBRSxHQUFHaEIsSUFBSSxDQUFDZ0IsRUFBVjtBQUNBRSxNQUFBQSxNQUFNLEdBQUdGLEVBQUUsR0FBR0QsSUFBZDtBQUNEOztBQUVEdmYsSUFBQUEsQ0FBQyxHQUFHd2UsSUFBSSxDQUFDaUMsRUFBVDtBQUNBeGdCLElBQUFBLENBQUMsR0FBR3VlLElBQUksQ0FBQ2tDLEVBQVQ7QUFDQWpCLElBQUFBLEtBQUssR0FBRy9kLENBQUMsR0FBRzZkLElBQVo7QUFDQXBpQixJQUFBQSxJQUFJLEdBQUcsT0FBTzZDLENBQUMsR0FBRzBCLENBQVgsSUFBZ0IsR0FBaEIsR0FBc0J6QixDQUF0QixHQUEwQixJQUExQixHQUFpQyxDQUFDRCxDQUFDLEdBQUcwQixDQUFMLEVBQVF6QixDQUFDLEdBQUd5ZixNQUFaLEVBQW9CMWYsQ0FBQyxHQUFHeWYsS0FBeEIsRUFBK0J4ZixDQUFDLEdBQUd1ZixFQUFuQyxFQUF1Q3hmLENBQXZDLEVBQTBDQyxDQUFDLEdBQUd1ZixFQUE5QyxFQUFrRHhmLENBQUMsR0FBR3lmLEtBQXRELEVBQTZEeGYsQ0FBQyxHQUFHdWYsRUFBakUsRUFBcUV4ZixDQUFDLEdBQUcwQixDQUF6RSxFQUE0RXpCLENBQUMsR0FBR3lmLE1BQWhGLEVBQXdGMWYsQ0FBQyxHQUFHMEIsQ0FBNUYsRUFBK0Z6QixDQUEvRixFQUFrR0QsQ0FBQyxHQUFHMEIsQ0FBdEcsRUFBeUd6QixDQUFDLEdBQUd5ZixNQUE3RyxFQUFxSDFmLENBQUMsR0FBR3lmLEtBQXpILEVBQWdJeGYsQ0FBQyxHQUFHdWYsRUFBcEksRUFBd0l4ZixDQUF4SSxFQUEySUMsQ0FBQyxHQUFHdWYsRUFBL0ksRUFBbUp4ZixDQUFDLEdBQUd5ZixLQUF2SixFQUE4SnhmLENBQUMsR0FBR3VmLEVBQWxLLEVBQXNLeGYsQ0FBQyxHQUFHMEIsQ0FBMUssRUFBNkt6QixDQUFDLEdBQUd5ZixNQUFqTCxFQUF5TDFmLENBQUMsR0FBRzBCLENBQTdMLEVBQWdNekIsQ0FBaE0sRUFBbU11Z0IsSUFBbk0sQ0FBd00sR0FBeE0sQ0FBakMsR0FBZ1AsR0FBdlA7QUFDRCxHQWRNLE1BY0EsSUFBSXptQixJQUFJLEtBQUssTUFBYixFQUFxQjtBQUMxQm9ELElBQUFBLElBQUksR0FBRyxNQUFNcWhCLElBQUksQ0FBQ21DLEVBQVgsR0FBZ0IsR0FBaEIsR0FBc0JuQyxJQUFJLENBQUNvQyxFQUEzQixHQUFnQyxJQUFoQyxHQUF1Q3BDLElBQUksQ0FBQ3FCLEVBQTVDLEdBQWlELEdBQWpELEdBQXVEckIsSUFBSSxDQUFDMEIsRUFBbkUsQ0FEMEIsQ0FDNkM7QUFDeEUsR0FGTSxNQUVBLElBQUlubUIsSUFBSSxLQUFLLFVBQVQsSUFBdUJBLElBQUksS0FBSyxTQUFwQyxFQUErQztBQUNwRDZYLElBQUFBLE1BQU0sR0FBRyxDQUFDdFUsT0FBTyxDQUFDNEgsWUFBUixDQUFxQixRQUFyQixJQUFpQyxFQUFsQyxFQUFzQzJiLEtBQXRDLENBQTRDOUYsV0FBNUMsS0FBNEQsRUFBckU7QUFDQS9hLElBQUFBLENBQUMsR0FBRzRSLE1BQU0sQ0FBQzZLLEtBQVAsRUFBSjtBQUNBeGMsSUFBQUEsQ0FBQyxHQUFHMlIsTUFBTSxDQUFDNkssS0FBUCxFQUFKO0FBQ0F0ZixJQUFBQSxJQUFJLEdBQUcsTUFBTTZDLENBQU4sR0FBVSxHQUFWLEdBQWdCQyxDQUFoQixHQUFvQixJQUFwQixHQUEyQjJSLE1BQU0sQ0FBQzRPLElBQVAsQ0FBWSxHQUFaLENBQWxDOztBQUVBLFFBQUl6bUIsSUFBSSxLQUFLLFNBQWIsRUFBd0I7QUFDdEJvRCxNQUFBQSxJQUFJLElBQUksTUFBTTZDLENBQU4sR0FBVSxHQUFWLEdBQWdCQyxDQUFoQixHQUFvQixHQUE1QjtBQUNEO0FBQ0Y7O0FBRURzZSxFQUFBQSxJQUFJLENBQUN1QyxZQUFMLENBQWtCLEdBQWxCLEVBQXVCQyxlQUFlLENBQUN4QyxJQUFJLENBQUN5QyxVQUFMLEdBQWtCN0MsZUFBZSxDQUFDaGhCLElBQUQsQ0FBbEMsQ0FBdEM7O0FBRUEsTUFBSWtpQixJQUFJLElBQUkvaEIsT0FBTyxDQUFDK0IsVUFBcEIsRUFBZ0M7QUFDOUIvQixJQUFBQSxPQUFPLENBQUMrQixVQUFSLENBQW1CNGhCLFlBQW5CLENBQWdDMUMsSUFBaEMsRUFBc0NqaEIsT0FBdEM7QUFDQUEsSUFBQUEsT0FBTyxDQUFDK0IsVUFBUixDQUFtQmdKLFdBQW5CLENBQStCL0ssT0FBL0I7QUFDRDs7QUFFRCxTQUFPaWhCLElBQVA7QUFDRCxFQUFDOztBQUVLLFNBQVMyQyxxQkFBVCxDQUErQjdFLE9BQS9CLEVBQXdDSCxRQUF4QyxFQUFrRDtBQUN2RCxNQUFJMUYsQ0FBQyxHQUFHMkssZUFBZSxDQUFDOUUsT0FBRCxFQUFVSCxRQUFRLElBQUksQ0FBWixHQUFnQixJQUFJLElBQXBCLEdBQTJCQSxRQUFRLEdBQUdBLFFBQUgsR0FBYyxJQUEzRCxDQUF2QjtBQUNBLFNBQU9rRixvQkFBb0IsQ0FBQzVLLENBQUMsQ0FBQ2dHLE9BQUgsRUFBWWhHLENBQUMsQ0FBQzFhLENBQWQsRUFBaUIwYSxDQUFDLENBQUMrRixDQUFuQixDQUEzQjtBQUNEOztBQUVELFNBQVM2RSxvQkFBVCxDQUE4QjVFLE9BQTlCLEVBQXVDMWdCLENBQXZDLEVBQTBDeWdCLENBQTFDLEVBQTZDO0FBQzNDLE1BQUkzWCxDQUFDLEdBQUc0WCxPQUFPLENBQUMxZ0IsQ0FBRCxDQUFmO0FBQUEsTUFDSXlhLENBQUMsR0FBR2lHLE9BQU8sQ0FBQzFnQixDQUFDLEdBQUcsQ0FBTCxDQURmO0FBQUEsTUFFSXdhLENBQUMsR0FBR2tHLE9BQU8sQ0FBQzFnQixDQUFDLEdBQUcsQ0FBTCxDQUZmO0FBQUEsTUFHSWtFLENBSEo7QUFJQTRFLEVBQUFBLENBQUMsSUFBSSxDQUFDMlIsQ0FBQyxHQUFHM1IsQ0FBTCxJQUFVMlgsQ0FBZjtBQUNBaEcsRUFBQUEsQ0FBQyxJQUFJLENBQUNELENBQUMsR0FBR0MsQ0FBTCxJQUFVZ0csQ0FBZjtBQUNBM1gsRUFBQUEsQ0FBQyxJQUFJLENBQUMyUixDQUFDLEdBQUczUixDQUFMLElBQVUyWCxDQUFmO0FBQ0F2YyxFQUFBQSxDQUFDLEdBQUd1VyxDQUFDLEdBQUcsQ0FBQ0QsQ0FBQyxHQUFHLENBQUNrRyxPQUFPLENBQUMxZ0IsQ0FBQyxHQUFHLENBQUwsQ0FBUCxHQUFpQndhLENBQWxCLElBQXVCaUcsQ0FBM0IsR0FBK0JoRyxDQUFoQyxJQUFxQ2dHLENBQXpDLEdBQTZDM1gsQ0FBakQ7QUFDQUEsRUFBQUEsQ0FBQyxHQUFHNFgsT0FBTyxDQUFDMWdCLENBQUMsR0FBRyxDQUFMLENBQVg7QUFDQXlhLEVBQUFBLENBQUMsR0FBR2lHLE9BQU8sQ0FBQzFnQixDQUFDLEdBQUcsQ0FBTCxDQUFYO0FBQ0F3YSxFQUFBQSxDQUFDLEdBQUdrRyxPQUFPLENBQUMxZ0IsQ0FBQyxHQUFHLENBQUwsQ0FBWDtBQUNBOEksRUFBQUEsQ0FBQyxJQUFJLENBQUMyUixDQUFDLEdBQUczUixDQUFMLElBQVUyWCxDQUFmO0FBQ0FoRyxFQUFBQSxDQUFDLElBQUksQ0FBQ0QsQ0FBQyxHQUFHQyxDQUFMLElBQVVnRyxDQUFmO0FBQ0EzWCxFQUFBQSxDQUFDLElBQUksQ0FBQzJSLENBQUMsR0FBRzNSLENBQUwsSUFBVTJYLENBQWY7QUFDQSxTQUFPL2lCLE1BQU0sQ0FBQ2tpQixNQUFNLENBQUNuRixDQUFDLEdBQUcsQ0FBQ0QsQ0FBQyxHQUFHLENBQUNrRyxPQUFPLENBQUMxZ0IsQ0FBQyxHQUFHLENBQUwsQ0FBUCxHQUFpQndhLENBQWxCLElBQXVCaUcsQ0FBM0IsR0FBK0JoRyxDQUFoQyxJQUFxQ2dHLENBQXpDLEdBQTZDM1gsQ0FBOUMsRUFBaUQ1RSxDQUFqRCxDQUFOLEdBQTREMUYsUUFBN0QsQ0FBYjtBQUNEOztBQUVNLFNBQVMrbUIsWUFBVCxDQUFzQmhGLE9BQXRCLEVBQStCbEosS0FBL0IsRUFBc0NyTyxHQUF0QyxFQUEyQztBQUNoREEsRUFBQUEsR0FBRyxHQUFHMUwsWUFBWSxDQUFDMEwsR0FBRCxDQUFaLEdBQW9CLENBQXBCLEdBQXdCcVgsYUFBYSxDQUFDclgsR0FBRCxDQUFiLElBQXNCLENBQXBELENBRGdELENBQ087O0FBRXZEcU8sRUFBQUEsS0FBSyxHQUFHZ0osYUFBYSxDQUFDaEosS0FBRCxDQUFiLElBQXdCLENBQWhDO0FBQ0EsTUFBSW1PLEtBQUssR0FBRzduQixJQUFJLENBQUNvRyxHQUFMLENBQVMsQ0FBVCxFQUFZLENBQUMsRUFBRTBiLElBQUksQ0FBQ3pXLEdBQUcsR0FBR3FPLEtBQVAsQ0FBSixHQUFvQixJQUF0QixDQUFiLENBQVo7QUFBQSxNQUNJb0wsSUFBSSxHQUFHSCxXQUFXLENBQUMvQixPQUFELENBRHRCOztBQUdBLE1BQUlsSixLQUFLLEdBQUdyTyxHQUFaLEVBQWlCO0FBQ2ZxTyxJQUFBQSxLQUFLLEdBQUcsSUFBSUEsS0FBWjtBQUNBck8sSUFBQUEsR0FBRyxHQUFHLElBQUlBLEdBQVY7O0FBRUFnWSxJQUFBQSxlQUFlLENBQUN5QixJQUFELENBQWY7O0FBRUFBLElBQUFBLElBQUksQ0FBQ2xCLFdBQUwsR0FBbUIsQ0FBbkI7QUFDRDs7QUFFRCxNQUFJbEssS0FBSyxHQUFHLENBQVIsSUFBYXJPLEdBQUcsR0FBRyxDQUF2QixFQUEwQjtBQUN4QixRQUFJcEMsTUFBTSxHQUFHakosSUFBSSxDQUFDMmIsR0FBTCxDQUFTLENBQUMsQ0FBQzNiLElBQUksQ0FBQ2tKLEdBQUwsQ0FBU3dRLEtBQVQsRUFBZ0JyTyxHQUFoQixDQUFYLElBQW1DLENBQWhEO0FBQ0FxTyxJQUFBQSxLQUFLLElBQUl6USxNQUFUO0FBQ0FvQyxJQUFBQSxHQUFHLElBQUlwQyxNQUFQO0FBQ0Q7O0FBRUQ2YixFQUFBQSxJQUFJLENBQUNsQixXQUFMLElBQW9Ca0Usd0JBQXdCLENBQUNoRCxJQUFELENBQTVDO0FBQ0EsTUFBSWlELElBQUksR0FBRzFjLEdBQUcsR0FBRyxDQUFqQjtBQUFBLE1BQ0kyYyxDQUFDLEdBQUdOLGVBQWUsQ0FBQzVDLElBQUQsRUFBT3BMLEtBQVAsRUFBYzJJLEtBQWQsRUFBcUIsSUFBckIsQ0FEdkI7QUFBQSxNQUVJN2hCLENBQUMsR0FBR2tuQixlQUFlLENBQUM1QyxJQUFELEVBQU96WixHQUFQLEVBQVlpWCxNQUFaLENBRnZCO0FBQUEsTUFHSTJGLElBQUksR0FBR3puQixDQUFDLENBQUN1aUIsT0FIYjtBQUFBLE1BSUltRixJQUFJLEdBQUdGLENBQUMsQ0FBQ2pGLE9BSmI7QUFBQSxNQUtJb0YsU0FBUyxHQUFHM25CLENBQUMsQ0FBQ3FpQixRQUxsQjtBQUFBLE1BTUl1RixTQUFTLEdBQUdKLENBQUMsQ0FBQ25GLFFBTmxCO0FBQUEsTUFPSXdGLEVBQUUsR0FBRzduQixDQUFDLENBQUM2QixDQVBYO0FBQUEsTUFRSWltQixFQUFFLEdBQUdOLENBQUMsQ0FBQzNsQixDQVJYO0FBQUEsTUFTSWttQixXQUFXLEdBQUdILFNBQVMsS0FBS0QsU0FUaEM7QUFBQSxNQVVJSyxVQUFVLEdBQUdILEVBQUUsS0FBS0MsRUFBUCxJQUFhQyxXQVY5QjtBQUFBLE1BV0lFLFdBWEo7QUFBQSxNQVlJQyxNQVpKO0FBQUEsTUFhSUMsTUFiSjtBQUFBLE1BY0l0bUIsQ0FkSjtBQUFBLE1BZUlOLElBZko7QUFBQSxNQWdCSTZtQixhQWhCSjtBQUFBLE1BaUJJeGQsQ0FqQko7QUFBQSxNQWtCSXlkLENBbEJKOztBQW9CQSxNQUFJZCxJQUFJLElBQUlGLEtBQVosRUFBbUI7QUFDakJZLElBQUFBLFdBQVcsR0FBR04sU0FBUyxHQUFHQyxTQUFaLElBQXlCRyxXQUFXLElBQUlGLEVBQUUsR0FBR0MsRUFBN0MsSUFBbURFLFVBQVUsSUFBSWhvQixDQUFDLENBQUNzaUIsQ0FBRixHQUFNa0YsQ0FBQyxDQUFDbEYsQ0FBdkY7O0FBRUEsUUFBSUgsYUFBYSxDQUFDbUMsSUFBRCxFQUFPc0QsU0FBUCxFQUFrQkUsRUFBbEIsRUFBc0JOLENBQUMsQ0FBQ2xGLENBQXhCLENBQWpCLEVBQTZDO0FBQzNDc0YsTUFBQUEsU0FBUzs7QUFFVCxVQUFJLENBQUNLLFdBQUwsRUFBa0I7QUFDaEJOLFFBQUFBLFNBQVM7O0FBRVQsWUFBSUssVUFBSixFQUFnQjtBQUNkaG9CLFVBQUFBLENBQUMsQ0FBQ3NpQixDQUFGLEdBQU0sQ0FBQ3RpQixDQUFDLENBQUNzaUIsQ0FBRixHQUFNa0YsQ0FBQyxDQUFDbEYsQ0FBVCxLQUFlLElBQUlrRixDQUFDLENBQUNsRixDQUFyQixDQUFOO0FBQ0F1RixVQUFBQSxFQUFFLEdBQUcsQ0FBTDtBQUNELFNBSEQsTUFHTyxJQUFJRSxXQUFKLEVBQWlCO0FBQ3RCRixVQUFBQSxFQUFFLElBQUlDLEVBQU47QUFDRDtBQUNGO0FBQ0Y7O0FBRUQsUUFBSXRvQixJQUFJLENBQUMyYixHQUFMLENBQVMsS0FBS3RRLEdBQUcsR0FBR3FPLEtBQVgsQ0FBVCxJQUE4QixJQUFsQyxFQUF3QztBQUN0Q3lPLE1BQUFBLFNBQVMsR0FBR0MsU0FBUyxHQUFHLENBQXhCO0FBQ0QsS0FGRCxNQUVPLElBQUksQ0FBQzVuQixDQUFDLENBQUNzaUIsQ0FBSCxJQUFRcUYsU0FBWixFQUF1QjtBQUM1QkEsTUFBQUEsU0FBUztBQUNWLEtBRk0sTUFFQSxJQUFJeEYsYUFBYSxDQUFDbUMsSUFBRCxFQUFPcUQsU0FBUCxFQUFrQkUsRUFBbEIsRUFBc0I3bkIsQ0FBQyxDQUFDc2lCLENBQXhCLENBQWIsSUFBMkMyRixXQUEvQyxFQUE0RDtBQUNqRUwsTUFBQUEsU0FBUztBQUNWOztBQUVELFFBQUlKLENBQUMsQ0FBQ2xGLENBQUYsS0FBUSxDQUFaLEVBQWU7QUFDYnNGLE1BQUFBLFNBQVMsR0FBRyxDQUFDQSxTQUFTLEdBQUcsQ0FBYixJQUFrQnRELElBQUksQ0FBQ3hpQixNQUFuQztBQUNEOztBQUVEUCxJQUFBQSxJQUFJLEdBQUcsRUFBUDtBQUNBNm1CLElBQUFBLGFBQWEsR0FBRzlELElBQUksQ0FBQ3hpQixNQUFyQjtBQUNBOEksSUFBQUEsQ0FBQyxHQUFHLElBQUl3ZCxhQUFhLEdBQUdmLEtBQXhCO0FBQ0FnQixJQUFBQSxDQUFDLEdBQUdULFNBQUo7QUFDQWhkLElBQUFBLENBQUMsSUFBSSxDQUFDd2QsYUFBYSxHQUFHUixTQUFoQixHQUE0QkQsU0FBN0IsSUFBMENTLGFBQS9DOztBQUVBLFNBQUt2bUIsQ0FBQyxHQUFHLENBQVQsRUFBWUEsQ0FBQyxHQUFHK0ksQ0FBaEIsRUFBbUIvSSxDQUFDLEVBQXBCLEVBQXdCO0FBQ3RCNGhCLE1BQUFBLGNBQWMsQ0FBQ2xpQixJQUFELEVBQU8raUIsSUFBSSxDQUFDK0QsQ0FBQyxLQUFLRCxhQUFQLENBQVgsQ0FBZDtBQUNEOztBQUVEOUQsSUFBQUEsSUFBSSxHQUFHL2lCLElBQVA7QUFDRCxHQXpDRCxNQXlDTztBQUNMNG1CLElBQUFBLE1BQU0sR0FBR25vQixDQUFDLENBQUNzaUIsQ0FBRixLQUFRLENBQVIsR0FBWSxDQUFaLEdBQWdCRyxnQkFBZ0IsQ0FBQ2dGLElBQUQsRUFBT0ksRUFBUCxFQUFXN25CLENBQUMsQ0FBQ3NpQixDQUFiLENBQXpDOztBQUVBLFFBQUlwSixLQUFLLEtBQUtyTyxHQUFkLEVBQW1CO0FBQ2pCcWQsTUFBQUEsTUFBTSxHQUFHekYsZ0JBQWdCLENBQUNpRixJQUFELEVBQU9JLEVBQVAsRUFBV0UsVUFBVSxHQUFHUixDQUFDLENBQUNsRixDQUFGLEdBQU10aUIsQ0FBQyxDQUFDc2lCLENBQVgsR0FBZWtGLENBQUMsQ0FBQ2xGLENBQXRDLENBQXpCO0FBQ0F5RixNQUFBQSxXQUFXLEtBQUtJLE1BQU0sSUFBSUQsTUFBZixDQUFYO0FBQ0FULE1BQUFBLElBQUksQ0FBQzdrQixNQUFMLENBQVlpbEIsRUFBRSxHQUFHTSxNQUFMLEdBQWMsQ0FBMUI7QUFDQSxPQUFDRCxNQUFNLElBQUlKLEVBQVgsS0FBa0JKLElBQUksQ0FBQzlrQixNQUFMLENBQVksQ0FBWixFQUFla2xCLEVBQUUsR0FBR0ksTUFBcEIsQ0FBbEI7QUFDQXJtQixNQUFBQSxDQUFDLEdBQUd5aUIsSUFBSSxDQUFDeGlCLE1BQVQ7O0FBRUEsYUFBT0QsQ0FBQyxFQUFSLEVBQVk7QUFDVjtBQUNBLFNBQUNBLENBQUMsR0FBRytsQixTQUFKLElBQWlCL2xCLENBQUMsR0FBRzhsQixTQUF0QixLQUFvQ3JELElBQUksQ0FBQzFoQixNQUFMLENBQVlmLENBQVosRUFBZSxDQUFmLENBQXBDO0FBQ0Q7QUFDRixLQVhELE1BV087QUFDTDRsQixNQUFBQSxJQUFJLENBQUNhLEtBQUwsR0FBYW5CLG9CQUFvQixDQUFDTSxJQUFELEVBQU9JLEVBQUUsR0FBR00sTUFBWixFQUFvQixDQUFwQixDQUFqQyxDQURLLENBQ29EOztBQUV6RE4sTUFBQUEsRUFBRSxJQUFJTSxNQUFOO0FBQ0FYLE1BQUFBLENBQUMsR0FBR0MsSUFBSSxDQUFDSSxFQUFELENBQVI7QUFDQTduQixNQUFBQSxDQUFDLEdBQUd5bkIsSUFBSSxDQUFDSSxFQUFFLEdBQUcsQ0FBTixDQUFSO0FBQ0FKLE1BQUFBLElBQUksQ0FBQzNsQixNQUFMLEdBQWMybEIsSUFBSSxDQUFDckUsV0FBTCxHQUFtQixDQUFqQztBQUNBcUUsTUFBQUEsSUFBSSxDQUFDakUsV0FBTCxHQUFtQmMsSUFBSSxDQUFDZCxXQUFMLEdBQW1CLENBQXRDO0FBQ0FpRSxNQUFBQSxJQUFJLENBQUNubEIsSUFBTCxDQUFVa2xCLENBQVYsRUFBYXhuQixDQUFiLEVBQWdCd25CLENBQWhCLEVBQW1CeG5CLENBQW5CLEVBQXNCd25CLENBQXRCLEVBQXlCeG5CLENBQXpCLEVBQTRCd25CLENBQTVCLEVBQStCeG5CLENBQS9CO0FBQ0Q7QUFDRjs7QUFFRHNrQixFQUFBQSxJQUFJLENBQUNsQixXQUFMLEdBQW1CLENBQW5CO0FBQ0EsU0FBT2tCLElBQVA7QUFDRCxFQUFDOztBQUVGLFNBQVNpRSxjQUFULENBQXdCaEcsT0FBeEIsRUFBaUNpRyxVQUFqQyxFQUE2Q0MsU0FBN0MsRUFBd0Q7QUFDdERELEVBQUFBLFVBQVUsR0FBR0EsVUFBVSxJQUFJLENBQTNCOztBQUVBLE1BQUksQ0FBQ2pHLE9BQU8sQ0FBQ0ssT0FBYixFQUFzQjtBQUNwQkwsSUFBQUEsT0FBTyxDQUFDSyxPQUFSLEdBQWtCLEVBQWxCO0FBQ0FMLElBQUFBLE9BQU8sQ0FBQ2MsTUFBUixHQUFpQixFQUFqQjtBQUNEOztBQUVELE1BQUlFLFVBQVUsR0FBRyxDQUFDLENBQUNoQixPQUFPLENBQUNnQixVQUFWLElBQXdCLEVBQXpDO0FBQUEsTUFDSW1GLEdBQUcsR0FBRyxJQUFJbkYsVUFEZDtBQUFBLE1BRUlvRixRQUFRLEdBQUdGLFNBQVMsR0FBR0QsVUFBVSxHQUFHQyxTQUFTLEdBQUcsQ0FBekIsR0FBNkIsQ0FBaEMsR0FBb0NsRyxPQUFPLENBQUN6Z0IsTUFGcEU7QUFBQSxNQUdJNGtCLEVBQUUsR0FBR25FLE9BQU8sQ0FBQ2lHLFVBQUQsQ0FIaEI7QUFBQSxNQUlJN0IsRUFBRSxHQUFHcEUsT0FBTyxDQUFDaUcsVUFBVSxHQUFHLENBQWQsQ0FKaEI7QUFBQSxNQUtJSSxZQUFZLEdBQUdKLFVBQVUsR0FBR0EsVUFBVSxHQUFHLENBQWIsR0FBaUJqRixVQUFwQixHQUFpQyxDQUw5RDtBQUFBLE1BTUlYLE9BQU8sR0FBR0wsT0FBTyxDQUFDSyxPQU50QjtBQUFBLE1BT0lTLE1BQU0sR0FBR2QsT0FBTyxDQUFDYyxNQVByQjtBQUFBLE1BUUkzYSxHQUFHLEdBQUcsQ0FBQzhmLFVBQVUsR0FBR2pHLE9BQU8sQ0FBQ2UsU0FBWCxHQUF1QjVCLFNBQWxDLEtBQWdEQSxTQVIxRDtBQUFBLE1BU0ltSCxVQUFVLEdBQUdqRyxPQUFPLENBQUNnRyxZQUFZLEdBQUdILFNBQVMsR0FBR2xGLFVBQTNCLEdBQXdDLENBQXpDLENBVHhCO0FBQUEsTUFVSXpoQixNQUFNLEdBQUcwbUIsVUFBVSxHQUFHNUYsT0FBTyxDQUFDZ0csWUFBWSxHQUFHLENBQWhCLENBQVYsR0FBK0IsQ0FWdEQ7QUFBQSxNQVdJL21CLENBWEo7QUFBQSxNQVlJd21CLENBWko7QUFBQSxNQWFJdkMsRUFiSjtBQUFBLE1BY0lELEVBZEo7QUFBQSxNQWVJRCxFQWZKO0FBQUEsTUFnQklrRCxFQWhCSjtBQUFBLE1BaUJJQyxHQWpCSjtBQUFBLE1Ba0JJNUMsRUFsQko7QUFBQSxNQW1CSUQsRUFuQko7QUFBQSxNQW9CSUQsRUFwQko7QUFBQSxNQXFCSStDLEVBckJKO0FBQUEsTUFzQklDLEdBdEJKO0FBQUEsTUF1QklDLEdBdkJKO0FBQUEsTUF3Qkk1RyxDQXhCSjtBQUFBLE1BeUJJNkcsV0F6Qko7QUFBQSxNQTBCSXZlLENBMUJKO0FBQUEsTUEyQkl3ZSxTQTNCSjtBQTRCQXhHLEVBQUFBLE9BQU8sQ0FBQzlnQixNQUFSLEdBQWlCdWhCLE1BQU0sQ0FBQ3ZoQixNQUFQLEdBQWdCLENBQWpDOztBQUVBLE9BQUt1bUIsQ0FBQyxHQUFHRyxVQUFVLEdBQUcsQ0FBdEIsRUFBeUJILENBQUMsR0FBR00sUUFBN0IsRUFBdUNOLENBQUMsSUFBSSxDQUE1QyxFQUErQztBQUM3Q3ZDLElBQUFBLEVBQUUsR0FBR3ZELE9BQU8sQ0FBQzhGLENBQUMsR0FBRyxDQUFMLENBQVAsR0FBaUIzQixFQUF0QjtBQUNBYixJQUFBQSxFQUFFLEdBQUd0RCxPQUFPLENBQUM4RixDQUFDLEdBQUcsQ0FBTCxDQUFQLEdBQWlCM0IsRUFBdEI7QUFDQWQsSUFBQUEsRUFBRSxHQUFHckQsT0FBTyxDQUFDOEYsQ0FBRCxDQUFQLEdBQWEzQixFQUFsQjtBQUNBUCxJQUFBQSxFQUFFLEdBQUc1RCxPQUFPLENBQUM4RixDQUFDLEdBQUcsQ0FBTCxDQUFQLEdBQWlCMUIsRUFBdEI7QUFDQVQsSUFBQUEsRUFBRSxHQUFHM0QsT0FBTyxDQUFDOEYsQ0FBQyxHQUFHLENBQUwsQ0FBUCxHQUFpQjFCLEVBQXRCO0FBQ0FWLElBQUFBLEVBQUUsR0FBRzFELE9BQU8sQ0FBQzhGLENBQUMsR0FBRyxDQUFMLENBQVAsR0FBaUIxQixFQUF0QjtBQUNBbUMsSUFBQUEsRUFBRSxHQUFHQyxHQUFHLEdBQUdDLEVBQUUsR0FBR0MsR0FBRyxHQUFHLENBQXRCOztBQUVBLFFBQUkzSCxJQUFJLENBQUN3RSxFQUFELENBQUosR0FBVyxHQUFYLElBQWtCeEUsSUFBSSxDQUFDNkUsRUFBRCxDQUFKLEdBQVcsR0FBN0IsSUFBb0M3RSxJQUFJLENBQUNzRSxFQUFELENBQUosR0FBV3RFLElBQUksQ0FBQzJFLEVBQUQsQ0FBZixHQUFzQixHQUE5RCxFQUFtRTtBQUNqRTtBQUNBLFVBQUkxRCxPQUFPLENBQUN6Z0IsTUFBUixHQUFpQixDQUFyQixFQUF3QjtBQUN0QnlnQixRQUFBQSxPQUFPLENBQUMzZixNQUFSLENBQWV5bEIsQ0FBZixFQUFrQixDQUFsQjtBQUNBQSxRQUFBQSxDQUFDLElBQUksQ0FBTDtBQUNBTSxRQUFBQSxRQUFRLElBQUksQ0FBWjtBQUNEO0FBQ0YsS0FQRCxNQU9PO0FBQ0wsV0FBSzltQixDQUFDLEdBQUcsQ0FBVCxFQUFZQSxDQUFDLElBQUkwaEIsVUFBakIsRUFBNkIxaEIsQ0FBQyxFQUE5QixFQUFrQztBQUNoQ3lnQixRQUFBQSxDQUFDLEdBQUdvRyxHQUFHLEdBQUc3bUIsQ0FBVjtBQUNBcW5CLFFBQUFBLEdBQUcsR0FBRyxJQUFJNUcsQ0FBVjtBQUNBd0csUUFBQUEsRUFBRSxHQUFHQyxHQUFHLElBQUlBLEdBQUcsR0FBRyxDQUFDekcsQ0FBQyxHQUFHQSxDQUFKLEdBQVF3RCxFQUFSLEdBQWEsSUFBSW9ELEdBQUosSUFBVzVHLENBQUMsR0FBR3VELEVBQUosR0FBU3FELEdBQUcsR0FBR3RELEVBQTFCLENBQWQsSUFBK0N0RCxDQUF6RCxDQUFSO0FBQ0EwRyxRQUFBQSxFQUFFLEdBQUdDLEdBQUcsSUFBSUEsR0FBRyxHQUFHLENBQUMzRyxDQUFDLEdBQUdBLENBQUosR0FBUTZELEVBQVIsR0FBYSxJQUFJK0MsR0FBSixJQUFXNUcsQ0FBQyxHQUFHNEQsRUFBSixHQUFTZ0QsR0FBRyxHQUFHakQsRUFBMUIsQ0FBZCxJQUErQzNELENBQXpELENBQVI7QUFDQTFYLFFBQUFBLENBQUMsR0FBRzJXLEtBQUssQ0FBQ3lILEVBQUUsR0FBR0EsRUFBTCxHQUFVRixFQUFFLEdBQUdBLEVBQWhCLENBQVQ7O0FBRUEsWUFBSWxlLENBQUMsR0FBR2xDLEdBQVIsRUFBYTtBQUNYQSxVQUFBQSxHQUFHLEdBQUdrQyxDQUFOO0FBQ0Q7O0FBRUQ5SSxRQUFBQSxNQUFNLElBQUk4SSxDQUFWO0FBQ0FnWSxRQUFBQSxPQUFPLENBQUNnRyxZQUFZLEVBQWIsQ0FBUCxHQUEwQjltQixNQUExQjtBQUNEO0FBQ0Y7O0FBRUQ0a0IsSUFBQUEsRUFBRSxJQUFJWixFQUFOO0FBQ0FhLElBQUFBLEVBQUUsSUFBSVIsRUFBTjtBQUNEOztBQUVELE1BQUkwQyxVQUFKLEVBQWdCO0FBQ2RBLElBQUFBLFVBQVUsSUFBSS9tQixNQUFkOztBQUVBLFdBQU84bUIsWUFBWSxHQUFHaEcsT0FBTyxDQUFDOWdCLE1BQTlCLEVBQXNDOG1CLFlBQVksRUFBbEQsRUFBc0Q7QUFDcERoRyxNQUFBQSxPQUFPLENBQUNnRyxZQUFELENBQVAsSUFBeUJDLFVBQXpCO0FBQ0Q7QUFDRjs7QUFFRCxNQUFJakcsT0FBTyxDQUFDOWdCLE1BQVIsSUFBa0I0RyxHQUF0QixFQUEyQjtBQUN6QjZaLElBQUFBLE9BQU8sQ0FBQ2EsV0FBUixHQUFzQmdHLFNBQVMsR0FBR3hHLE9BQU8sQ0FBQ0EsT0FBTyxDQUFDOWdCLE1BQVIsR0FBaUIsQ0FBbEIsQ0FBUCxJQUErQixDQUFqRTtBQUNBeWdCLElBQUFBLE9BQU8sQ0FBQ2UsU0FBUixHQUFvQjVhLEdBQXBCOztBQUVBLFFBQUkwZ0IsU0FBUyxHQUFHMWdCLEdBQVosR0FBa0IsSUFBdEIsRUFBNEI7QUFDMUI7QUFDQWtDLE1BQUFBLENBQUMsR0FBR3VlLFdBQVcsR0FBRyxDQUFsQjs7QUFFQSxXQUFLdG5CLENBQUMsR0FBRyxDQUFULEVBQVlBLENBQUMsR0FBR3VuQixTQUFoQixFQUEyQnZuQixDQUFDLElBQUk2RyxHQUFoQyxFQUFxQztBQUNuQzJhLFFBQUFBLE1BQU0sQ0FBQ3pZLENBQUMsRUFBRixDQUFOLEdBQWNnWSxPQUFPLENBQUN1RyxXQUFELENBQVAsR0FBdUJ0bkIsQ0FBdkIsR0FBMkIsRUFBRXNuQixXQUE3QixHQUEyQ0EsV0FBekQ7QUFDRDtBQUNGO0FBQ0YsR0FaRCxNQVlPO0FBQ0w1RyxJQUFBQSxPQUFPLENBQUNhLFdBQVIsR0FBc0JSLE9BQU8sQ0FBQyxDQUFELENBQVAsR0FBYSxDQUFuQztBQUNEOztBQUVELFNBQU80RixVQUFVLEdBQUcxbUIsTUFBTSxHQUFHOGdCLE9BQU8sQ0FBQzRGLFVBQVUsR0FBRyxDQUFiLEdBQWlCLENBQWxCLENBQW5CLEdBQTBDMW1CLE1BQTNEO0FBQ0Q7O0FBRU0sU0FBU3dsQix3QkFBVCxDQUFrQ2xGLE9BQWxDLEVBQTJDbUIsVUFBM0MsRUFBdUQ7QUFDNUQsTUFBSThGLFVBQUosRUFBZ0IxUixNQUFoQixFQUF3QjlWLENBQXhCOztBQUVBLE9BQUtBLENBQUMsR0FBR3duQixVQUFVLEdBQUcxUixNQUFNLEdBQUcsQ0FBL0IsRUFBa0M5VixDQUFDLEdBQUd1Z0IsT0FBTyxDQUFDdGdCLE1BQTlDLEVBQXNERCxDQUFDLEVBQXZELEVBQTJEO0FBQ3pEdWdCLElBQUFBLE9BQU8sQ0FBQ3ZnQixDQUFELENBQVAsQ0FBVzBoQixVQUFYLEdBQXdCLENBQUMsQ0FBQ0EsVUFBRixJQUFnQixFQUF4QyxDQUR5RCxDQUNiOztBQUU1QzVMLElBQUFBLE1BQU0sSUFBSXlLLE9BQU8sQ0FBQ3ZnQixDQUFELENBQVAsQ0FBV0MsTUFBckI7QUFDQXVuQixJQUFBQSxVQUFVLElBQUlkLGNBQWMsQ0FBQ25HLE9BQU8sQ0FBQ3ZnQixDQUFELENBQVIsQ0FBNUI7QUFDRDs7QUFFRHVnQixFQUFBQSxPQUFPLENBQUNvQixXQUFSLEdBQXNCN0wsTUFBdEI7QUFDQXlLLEVBQUFBLE9BQU8sQ0FBQ2dCLFdBQVIsR0FBc0JpRyxVQUF0QjtBQUNBLFNBQU9qSCxPQUFQO0FBQ0QsRUFBQzs7QUFFSyxTQUFTSyxnQkFBVCxDQUEwQkYsT0FBMUIsRUFBbUMxZ0IsQ0FBbkMsRUFBc0N5Z0IsQ0FBdEMsRUFBeUM7QUFDOUMsTUFBSUEsQ0FBQyxJQUFJLENBQUwsSUFBVUEsQ0FBQyxJQUFJLENBQW5CLEVBQXNCO0FBQ3BCLFdBQU8sQ0FBUDtBQUNEOztBQUVELE1BQUlnSCxFQUFFLEdBQUcvRyxPQUFPLENBQUMxZ0IsQ0FBRCxDQUFoQjtBQUFBLE1BQ0kwbkIsRUFBRSxHQUFHaEgsT0FBTyxDQUFDMWdCLENBQUMsR0FBRyxDQUFMLENBRGhCO0FBQUEsTUFFSTJuQixJQUFJLEdBQUdqSCxPQUFPLENBQUMxZ0IsQ0FBQyxHQUFHLENBQUwsQ0FGbEI7QUFBQSxNQUdJNG5CLElBQUksR0FBR2xILE9BQU8sQ0FBQzFnQixDQUFDLEdBQUcsQ0FBTCxDQUhsQjtBQUFBLE1BSUk2bkIsSUFBSSxHQUFHbkgsT0FBTyxDQUFDMWdCLENBQUMsR0FBRyxDQUFMLENBSmxCO0FBQUEsTUFLSThuQixJQUFJLEdBQUdwSCxPQUFPLENBQUMxZ0IsQ0FBQyxHQUFHLENBQUwsQ0FMbEI7QUFBQSxNQU1JK25CLEVBQUUsR0FBR3JILE9BQU8sQ0FBQzFnQixDQUFDLEdBQUcsQ0FBTCxDQU5oQjtBQUFBLE1BT0lnb0IsRUFBRSxHQUFHdEgsT0FBTyxDQUFDMWdCLENBQUMsR0FBRyxDQUFMLENBUGhCO0FBQUEsTUFRSWlvQixHQUFHLEdBQUdSLEVBQUUsR0FBRyxDQUFDRSxJQUFJLEdBQUdGLEVBQVIsSUFBY2hILENBUjdCO0FBQUEsTUFTSXNELEVBQUUsR0FBRzRELElBQUksR0FBRyxDQUFDRSxJQUFJLEdBQUdGLElBQVIsSUFBZ0JsSCxDQVRoQztBQUFBLE1BVUl5SCxHQUFHLEdBQUdSLEVBQUUsR0FBRyxDQUFDRSxJQUFJLEdBQUdGLEVBQVIsSUFBY2pILENBVjdCO0FBQUEsTUFXSTJELEVBQUUsR0FBR3dELElBQUksR0FBRyxDQUFDRSxJQUFJLEdBQUdGLElBQVIsSUFBZ0JuSCxDQVhoQztBQUFBLE1BWUlvRSxFQUFFLEdBQUdvRCxHQUFHLEdBQUcsQ0FBQ2xFLEVBQUUsR0FBR2tFLEdBQU4sSUFBYXhILENBWjVCO0FBQUEsTUFhSXFFLEVBQUUsR0FBR29ELEdBQUcsR0FBRyxDQUFDOUQsRUFBRSxHQUFHOEQsR0FBTixJQUFhekgsQ0FiNUI7QUFBQSxNQWNJMEgsR0FBRyxHQUFHTixJQUFJLEdBQUcsQ0FBQ0UsRUFBRSxHQUFHRixJQUFOLElBQWNwSCxDQWQvQjtBQUFBLE1BZUkySCxHQUFHLEdBQUdOLElBQUksR0FBRyxDQUFDRSxFQUFFLEdBQUdGLElBQU4sSUFBY3JILENBZi9CO0FBZ0JBc0QsRUFBQUEsRUFBRSxJQUFJLENBQUNvRSxHQUFHLEdBQUdwRSxFQUFQLElBQWF0RCxDQUFuQjtBQUNBMkQsRUFBQUEsRUFBRSxJQUFJLENBQUNnRSxHQUFHLEdBQUdoRSxFQUFQLElBQWEzRCxDQUFuQjtBQUNBQyxFQUFBQSxPQUFPLENBQUMzZixNQUFSLENBQWVmLENBQUMsR0FBRyxDQUFuQixFQUFzQixDQUF0QixFQUF5QnRDLE1BQU0sQ0FBQ3VxQixHQUFELENBQS9CLEVBQXNDO0FBQ3RDdnFCLEVBQUFBLE1BQU0sQ0FBQ3dxQixHQUFELENBRE4sRUFDYXhxQixNQUFNLENBQUNtbkIsRUFBRCxDQURuQixFQUN5QjtBQUN6Qm5uQixFQUFBQSxNQUFNLENBQUNvbkIsRUFBRCxDQUZOLEVBRVlwbkIsTUFBTSxDQUFDbW5CLEVBQUUsR0FBRyxDQUFDZCxFQUFFLEdBQUdjLEVBQU4sSUFBWXBFLENBQWxCLENBRmxCLEVBRXdDO0FBQ3hDL2lCLEVBQUFBLE1BQU0sQ0FBQ29uQixFQUFFLEdBQUcsQ0FBQ1YsRUFBRSxHQUFHVSxFQUFOLElBQVlyRSxDQUFsQixDQUhOLEVBRzRCL2lCLE1BQU0sQ0FBQ3FtQixFQUFELENBSGxDLEVBR3dDO0FBQ3hDcm1CLEVBQUFBLE1BQU0sQ0FBQzBtQixFQUFELENBSk4sRUFJWTFtQixNQUFNLENBQUN5cUIsR0FBRCxDQUpsQixFQUl5QjtBQUN6QnpxQixFQUFBQSxNQUFNLENBQUMwcUIsR0FBRCxDQUxOO0FBTUExSCxFQUFBQSxPQUFPLENBQUNLLE9BQVIsSUFBbUJMLE9BQU8sQ0FBQ0ssT0FBUixDQUFnQmhnQixNQUFoQixDQUF1QmYsQ0FBQyxHQUFHLENBQUosR0FBUTBnQixPQUFPLENBQUNnQixVQUFoQixHQUE2QixDQUFwRCxFQUF1RCxDQUF2RCxFQUEwRCxDQUExRCxFQUE2RCxDQUE3RCxFQUFnRSxDQUFoRSxFQUFtRSxDQUFuRSxFQUFzRSxDQUF0RSxFQUF5RSxDQUF6RSxDQUFuQjtBQUNBLFNBQU8sQ0FBUDtBQUNELEVBQUM7O0FBRUYsU0FBUzJELGVBQVQsQ0FBeUI5RSxPQUF6QixFQUFrQ0gsUUFBbEMsRUFBNENpSSxTQUE1QyxFQUF1REMsaUJBQXZELEVBQTBFO0FBQ3hFRCxFQUFBQSxTQUFTLEdBQUdBLFNBQVMsSUFBSSxFQUF6QjtBQUNBOUgsRUFBQUEsT0FBTyxDQUFDZ0IsV0FBUixJQUF1QmtFLHdCQUF3QixDQUFDbEYsT0FBRCxDQUEvQzs7QUFFQSxNQUFJSCxRQUFRLEdBQUcsQ0FBWCxJQUFnQkEsUUFBUSxHQUFHLENBQS9CLEVBQWtDO0FBQ2hDQSxJQUFBQSxRQUFRLEdBQUdELGFBQWEsQ0FBQ0MsUUFBRCxDQUF4QjtBQUNEOztBQUVELE1BQUlJLFFBQVEsR0FBRyxDQUFmO0FBQUEsTUFDSUUsT0FBTyxHQUFHSCxPQUFPLENBQUMsQ0FBRCxDQURyQjtBQUFBLE1BRUlRLE9BRko7QUFBQSxNQUdJVyxVQUhKO0FBQUEsTUFJSXpoQixNQUpKO0FBQUEsTUFLSTRHLEdBTEo7QUFBQSxNQU1JOUMsR0FOSjtBQUFBLE1BT0kvRCxDQVBKO0FBQUEsTUFRSXlnQixDQVJKOztBQVVBLE1BQUksQ0FBQ0wsUUFBTCxFQUFlO0FBQ2JLLElBQUFBLENBQUMsR0FBR3pnQixDQUFDLEdBQUd3Z0IsUUFBUSxHQUFHLENBQW5CO0FBQ0FFLElBQUFBLE9BQU8sR0FBR0gsT0FBTyxDQUFDLENBQUQsQ0FBakI7QUFDRCxHQUhELE1BR08sSUFBSUgsUUFBUSxLQUFLLENBQWpCLEVBQW9CO0FBQ3pCSyxJQUFBQSxDQUFDLEdBQUcsQ0FBSjtBQUNBRCxJQUFBQSxRQUFRLEdBQUdELE9BQU8sQ0FBQ3RnQixNQUFSLEdBQWlCLENBQTVCO0FBQ0F5Z0IsSUFBQUEsT0FBTyxHQUFHSCxPQUFPLENBQUNDLFFBQUQsQ0FBakI7QUFDQXhnQixJQUFBQSxDQUFDLEdBQUcwZ0IsT0FBTyxDQUFDemdCLE1BQVIsR0FBaUIsQ0FBckI7QUFDRCxHQUxNLE1BS0E7QUFDTCxRQUFJc2dCLE9BQU8sQ0FBQ3RnQixNQUFSLEdBQWlCLENBQXJCLEVBQXdCO0FBQ3RCO0FBQ0FBLE1BQUFBLE1BQU0sR0FBR3NnQixPQUFPLENBQUNnQixXQUFSLEdBQXNCbkIsUUFBL0I7QUFDQXJjLE1BQUFBLEdBQUcsR0FBRy9ELENBQUMsR0FBRyxDQUFWOztBQUVBLGFBQU8sQ0FBQytELEdBQUcsSUFBSXdjLE9BQU8sQ0FBQ3ZnQixDQUFDLEVBQUYsQ0FBUCxDQUFhdWhCLFdBQXJCLElBQW9DdGhCLE1BQTNDLEVBQW1EO0FBQ2pEdWdCLFFBQUFBLFFBQVEsR0FBR3hnQixDQUFYO0FBQ0Q7O0FBRUQwZ0IsTUFBQUEsT0FBTyxHQUFHSCxPQUFPLENBQUNDLFFBQUQsQ0FBakI7QUFDQTNaLE1BQUFBLEdBQUcsR0FBRzlDLEdBQUcsR0FBRzJjLE9BQU8sQ0FBQ2EsV0FBcEI7QUFDQW5CLE1BQUFBLFFBQVEsR0FBRyxDQUFDbmdCLE1BQU0sR0FBRzRHLEdBQVYsS0FBa0I5QyxHQUFHLEdBQUc4QyxHQUF4QixLQUFnQyxDQUEzQztBQUNEOztBQUVEa2EsSUFBQUEsT0FBTyxHQUFHTCxPQUFPLENBQUNLLE9BQWxCO0FBQ0FXLElBQUFBLFVBQVUsR0FBR2hCLE9BQU8sQ0FBQ2dCLFVBQXJCLENBaEJLLENBZ0I0Qjs7QUFFakN6aEIsSUFBQUEsTUFBTSxHQUFHeWdCLE9BQU8sQ0FBQ2EsV0FBUixHQUFzQm5CLFFBQS9CO0FBQ0FwZ0IsSUFBQUEsQ0FBQyxHQUFHMGdCLE9BQU8sQ0FBQ2MsTUFBUixDQUFldmhCLE1BQWYsR0FBd0J5Z0IsT0FBTyxDQUFDYyxNQUFSLENBQWUsQ0FBQyxFQUFFdmhCLE1BQU0sR0FBR3lnQixPQUFPLENBQUNlLFNBQW5CLENBQWhCLEtBQWtELENBQTFFLEdBQThFWCxlQUFlLENBQUNDLE9BQUQsRUFBVTlnQixNQUFWLEVBQWtCbWdCLFFBQWxCLENBQWpHO0FBQ0F2WixJQUFBQSxHQUFHLEdBQUc3RyxDQUFDLEdBQUcrZ0IsT0FBTyxDQUFDL2dCLENBQUMsR0FBRyxDQUFMLENBQVYsR0FBb0IsQ0FBM0I7QUFDQStELElBQUFBLEdBQUcsR0FBR2dkLE9BQU8sQ0FBQy9nQixDQUFELENBQWI7O0FBRUEsUUFBSStELEdBQUcsR0FBRzlELE1BQVYsRUFBa0I7QUFDaEI0RyxNQUFBQSxHQUFHLEdBQUc5QyxHQUFOO0FBQ0FBLE1BQUFBLEdBQUcsR0FBR2dkLE9BQU8sQ0FBQyxFQUFFL2dCLENBQUgsQ0FBYjtBQUNEOztBQUVEeWdCLElBQUFBLENBQUMsR0FBRyxJQUFJaUIsVUFBSixJQUFrQixDQUFDemhCLE1BQU0sR0FBRzRHLEdBQVYsS0FBa0I5QyxHQUFHLEdBQUc4QyxHQUF4QixJQUErQjdHLENBQUMsR0FBRzBoQixVQUFyRCxDQUFKO0FBQ0ExaEIsSUFBQUEsQ0FBQyxHQUFHLENBQUMsRUFBRUEsQ0FBQyxHQUFHMGhCLFVBQU4sQ0FBRCxHQUFxQixDQUF6Qjs7QUFFQSxRQUFJNEcsaUJBQWlCLElBQUk3SCxDQUFDLEtBQUssQ0FBL0IsRUFBa0M7QUFDaEMsVUFBSXpnQixDQUFDLEdBQUcsQ0FBSixHQUFRMGdCLE9BQU8sQ0FBQ3pnQixNQUFwQixFQUE0QjtBQUMxQkQsUUFBQUEsQ0FBQyxJQUFJLENBQUw7QUFDQXlnQixRQUFBQSxDQUFDLEdBQUcsQ0FBSjtBQUNELE9BSEQsTUFHTyxJQUFJRCxRQUFRLEdBQUcsQ0FBWCxHQUFlRCxPQUFPLENBQUN0Z0IsTUFBM0IsRUFBbUM7QUFDeENELFFBQUFBLENBQUMsR0FBR3lnQixDQUFDLEdBQUcsQ0FBUjtBQUNBQyxRQUFBQSxPQUFPLEdBQUdILE9BQU8sQ0FBQyxFQUFFQyxRQUFILENBQWpCO0FBQ0Q7QUFDRjtBQUNGOztBQUVENkgsRUFBQUEsU0FBUyxDQUFDNUgsQ0FBVixHQUFjQSxDQUFkO0FBQ0E0SCxFQUFBQSxTQUFTLENBQUNyb0IsQ0FBVixHQUFjQSxDQUFkO0FBQ0Fxb0IsRUFBQUEsU0FBUyxDQUFDNUYsSUFBVixHQUFpQmxDLE9BQWpCO0FBQ0E4SCxFQUFBQSxTQUFTLENBQUMzSCxPQUFWLEdBQW9CQSxPQUFwQjtBQUNBMkgsRUFBQUEsU0FBUyxDQUFDN0gsUUFBVixHQUFxQkEsUUFBckI7QUFDQSxTQUFPNkgsU0FBUDtBQUNEOztBQUVNLFNBQVNFLGlCQUFULENBQTJCaEksT0FBM0IsRUFBb0NILFFBQXBDLEVBQThDb0ksWUFBOUMsRUFBNERwVCxLQUE1RCxFQUFtRTtBQUN4RSxNQUFJc0wsT0FBTyxHQUFHSCxPQUFPLENBQUMsQ0FBRCxDQUFyQjtBQUFBLE1BQ0lsYSxNQUFNLEdBQUcrTyxLQUFLLElBQUksRUFEdEI7QUFBQSxNQUVJMkwsT0FGSjtBQUFBLE1BR0lXLFVBSEo7QUFBQSxNQUlJemhCLE1BSko7QUFBQSxNQUtJNEcsR0FMSjtBQUFBLE1BTUk5QyxHQU5KO0FBQUEsTUFPSS9ELENBUEo7QUFBQSxNQVFJeWdCLENBUko7QUFBQSxNQVNJM1gsQ0FUSjtBQUFBLE1BVUl1ZSxHQVZKOztBQVlBLE1BQUlqSCxRQUFRLEdBQUcsQ0FBWCxJQUFnQkEsUUFBUSxHQUFHLENBQS9CLEVBQWtDO0FBQ2hDQSxJQUFBQSxRQUFRLEdBQUdELGFBQWEsQ0FBQ0MsUUFBRCxDQUF4QjtBQUNEOztBQUVELE1BQUlHLE9BQU8sQ0FBQ3RnQixNQUFSLEdBQWlCLENBQXJCLEVBQXdCO0FBQ3RCO0FBQ0FBLElBQUFBLE1BQU0sR0FBR3NnQixPQUFPLENBQUNnQixXQUFSLEdBQXNCbkIsUUFBL0I7QUFDQXJjLElBQUFBLEdBQUcsR0FBRy9ELENBQUMsR0FBRyxDQUFWOztBQUVBLFdBQU8sQ0FBQytELEdBQUcsSUFBSXdjLE9BQU8sQ0FBQ3ZnQixDQUFDLEVBQUYsQ0FBUCxDQUFhdWhCLFdBQXJCLElBQW9DdGhCLE1BQTNDLEVBQW1EO0FBQ2pEeWdCLE1BQUFBLE9BQU8sR0FBR0gsT0FBTyxDQUFDdmdCLENBQUQsQ0FBakI7QUFDRDs7QUFFRDZHLElBQUFBLEdBQUcsR0FBRzlDLEdBQUcsR0FBRzJjLE9BQU8sQ0FBQ2EsV0FBcEI7QUFDQW5CLElBQUFBLFFBQVEsR0FBRyxDQUFDbmdCLE1BQU0sR0FBRzRHLEdBQVYsS0FBa0I5QyxHQUFHLEdBQUc4QyxHQUF4QixLQUFnQyxDQUEzQztBQUNEOztBQUVEa2EsRUFBQUEsT0FBTyxHQUFHTCxPQUFPLENBQUNLLE9BQWxCO0FBQ0FXLEVBQUFBLFVBQVUsR0FBR2hCLE9BQU8sQ0FBQ2dCLFVBQXJCO0FBQ0F6aEIsRUFBQUEsTUFBTSxHQUFHeWdCLE9BQU8sQ0FBQ2EsV0FBUixHQUFzQm5CLFFBQS9CO0FBQ0FwZ0IsRUFBQUEsQ0FBQyxHQUFHMGdCLE9BQU8sQ0FBQ2MsTUFBUixDQUFldmhCLE1BQWYsR0FBd0J5Z0IsT0FBTyxDQUFDYyxNQUFSLENBQWVwQixRQUFRLEdBQUcsQ0FBWCxHQUFlLENBQUMsRUFBRW5nQixNQUFNLEdBQUd5Z0IsT0FBTyxDQUFDZSxTQUFuQixDQUFoQixHQUFnRGYsT0FBTyxDQUFDYyxNQUFSLENBQWV2aEIsTUFBZixHQUF3QixDQUF2RixLQUE2RixDQUFySCxHQUF5SDZnQixlQUFlLENBQUNDLE9BQUQsRUFBVTlnQixNQUFWLEVBQWtCbWdCLFFBQWxCLENBQTVJO0FBQ0F2WixFQUFBQSxHQUFHLEdBQUc3RyxDQUFDLEdBQUcrZ0IsT0FBTyxDQUFDL2dCLENBQUMsR0FBRyxDQUFMLENBQVYsR0FBb0IsQ0FBM0I7QUFDQStELEVBQUFBLEdBQUcsR0FBR2dkLE9BQU8sQ0FBQy9nQixDQUFELENBQWI7O0FBRUEsTUFBSStELEdBQUcsR0FBRzlELE1BQVYsRUFBa0I7QUFDaEI0RyxJQUFBQSxHQUFHLEdBQUc5QyxHQUFOO0FBQ0FBLElBQUFBLEdBQUcsR0FBR2dkLE9BQU8sQ0FBQyxFQUFFL2dCLENBQUgsQ0FBYjtBQUNEOztBQUVEeWdCLEVBQUFBLENBQUMsR0FBRyxJQUFJaUIsVUFBSixJQUFrQixDQUFDemhCLE1BQU0sR0FBRzRHLEdBQVYsS0FBa0I5QyxHQUFHLEdBQUc4QyxHQUF4QixJQUErQjdHLENBQUMsR0FBRzBoQixVQUFyRCxLQUFvRSxDQUF4RTtBQUNBMkYsRUFBQUEsR0FBRyxHQUFHLElBQUk1RyxDQUFWO0FBQ0F6Z0IsRUFBQUEsQ0FBQyxHQUFHLENBQUMsRUFBRUEsQ0FBQyxHQUFHMGhCLFVBQU4sQ0FBRCxHQUFxQixDQUF6QjtBQUNBNVksRUFBQUEsQ0FBQyxHQUFHNFgsT0FBTyxDQUFDMWdCLENBQUQsQ0FBWDtBQUNBcUcsRUFBQUEsTUFBTSxDQUFDbkMsQ0FBUCxHQUFXeEcsTUFBTSxDQUFDLENBQUMraUIsQ0FBQyxHQUFHQSxDQUFKLElBQVNDLE9BQU8sQ0FBQzFnQixDQUFDLEdBQUcsQ0FBTCxDQUFQLEdBQWlCOEksQ0FBMUIsSUFBK0IsSUFBSXVlLEdBQUosSUFBVzVHLENBQUMsSUFBSUMsT0FBTyxDQUFDMWdCLENBQUMsR0FBRyxDQUFMLENBQVAsR0FBaUI4SSxDQUFyQixDQUFELEdBQTJCdWUsR0FBRyxJQUFJM0csT0FBTyxDQUFDMWdCLENBQUMsR0FBRyxDQUFMLENBQVAsR0FBaUI4SSxDQUFyQixDQUF6QyxDQUFoQyxJQUFxRzJYLENBQXJHLEdBQXlHM1gsQ0FBMUcsQ0FBakI7QUFDQXpDLEVBQUFBLE1BQU0sQ0FBQ2xDLENBQVAsR0FBV3pHLE1BQU0sQ0FBQyxDQUFDK2lCLENBQUMsR0FBR0EsQ0FBSixJQUFTQyxPQUFPLENBQUMxZ0IsQ0FBQyxHQUFHLENBQUwsQ0FBUCxJQUFrQjhJLENBQUMsR0FBRzRYLE9BQU8sQ0FBQzFnQixDQUFDLEdBQUcsQ0FBTCxDQUE3QixDQUFULElBQWtELElBQUlxbkIsR0FBSixJQUFXNUcsQ0FBQyxJQUFJQyxPQUFPLENBQUMxZ0IsQ0FBQyxHQUFHLENBQUwsQ0FBUCxHQUFpQjhJLENBQXJCLENBQUQsR0FBMkJ1ZSxHQUFHLElBQUkzRyxPQUFPLENBQUMxZ0IsQ0FBQyxHQUFHLENBQUwsQ0FBUCxHQUFpQjhJLENBQXJCLENBQXpDLENBQW5ELElBQXdIMlgsQ0FBeEgsR0FBNEgzWCxDQUE3SCxDQUFqQjs7QUFFQSxNQUFJMGYsWUFBSixFQUFrQjtBQUNoQm5pQixJQUFBQSxNQUFNLENBQUNvZ0IsS0FBUCxHQUFlL0YsT0FBTyxDQUFDYSxXQUFSLEdBQXNCK0Qsb0JBQW9CLENBQUM1RSxPQUFELEVBQVUxZ0IsQ0FBVixFQUFheWdCLENBQUMsSUFBSSxDQUFMLEdBQVMsSUFBSSxJQUFiLEdBQW9CQSxDQUFDLEdBQUdBLENBQUgsR0FBTyxJQUF6QyxDQUExQyxHQUEyRkMsT0FBTyxDQUFDK0YsS0FBUixJQUFpQixDQUEzSDtBQUNEOztBQUVELFNBQU9wZ0IsTUFBUDtBQUNELEVBQUM7O0FBRUssU0FBU29pQixnQkFBVCxDQUEwQmxJLE9BQTFCLEVBQW1DelgsQ0FBbkMsRUFBc0MyUixDQUF0QyxFQUF5Q0QsQ0FBekMsRUFBNENFLENBQTVDLEVBQStDZ08sRUFBL0MsRUFBbURDLEVBQW5ELEVBQXVEO0FBQzVELE1BQUluQyxDQUFDLEdBQUdqRyxPQUFPLENBQUN0Z0IsTUFBaEI7QUFBQSxNQUNJeWdCLE9BREo7QUFBQSxNQUVJM1gsQ0FGSjtBQUFBLE1BR0kvSSxDQUhKO0FBQUEsTUFJSWtFLENBSko7QUFBQSxNQUtJQyxDQUxKOztBQU9BLFNBQU8sRUFBRXFpQixDQUFGLEdBQU0sQ0FBQyxDQUFkLEVBQWlCO0FBQ2Y5RixJQUFBQSxPQUFPLEdBQUdILE9BQU8sQ0FBQ2lHLENBQUQsQ0FBakI7QUFDQXpkLElBQUFBLENBQUMsR0FBRzJYLE9BQU8sQ0FBQ3pnQixNQUFaOztBQUVBLFNBQUtELENBQUMsR0FBRyxDQUFULEVBQVlBLENBQUMsR0FBRytJLENBQWhCLEVBQW1CL0ksQ0FBQyxJQUFJLENBQXhCLEVBQTJCO0FBQ3pCa0UsTUFBQUEsQ0FBQyxHQUFHd2MsT0FBTyxDQUFDMWdCLENBQUQsQ0FBWDtBQUNBbUUsTUFBQUEsQ0FBQyxHQUFHdWMsT0FBTyxDQUFDMWdCLENBQUMsR0FBRyxDQUFMLENBQVg7QUFDQTBnQixNQUFBQSxPQUFPLENBQUMxZ0IsQ0FBRCxDQUFQLEdBQWFrRSxDQUFDLEdBQUc0RSxDQUFKLEdBQVEzRSxDQUFDLEdBQUdxVyxDQUFaLEdBQWdCa08sRUFBN0I7QUFDQWhJLE1BQUFBLE9BQU8sQ0FBQzFnQixDQUFDLEdBQUcsQ0FBTCxDQUFQLEdBQWlCa0UsQ0FBQyxHQUFHdVcsQ0FBSixHQUFRdFcsQ0FBQyxHQUFHdVcsQ0FBWixHQUFnQmlPLEVBQWpDO0FBQ0Q7QUFDRjs7QUFFRHBJLEVBQUFBLE9BQU8sQ0FBQzZCLE1BQVIsR0FBaUIsQ0FBakI7QUFDQSxTQUFPN0IsT0FBUDtBQUNELEVBQUM7O0FBRUYsU0FBU3FJLFlBQVQsQ0FBc0JDLEtBQXRCLEVBQTZCQyxLQUE3QixFQUFvQ3JFLEVBQXBDLEVBQXdDZixFQUF4QyxFQUE0QytDLEtBQTVDLEVBQW1Ec0MsWUFBbkQsRUFBaUVDLFNBQWpFLEVBQTRFOWtCLENBQTVFLEVBQStFQyxDQUEvRSxFQUFrRjtBQUNoRixNQUFJMGtCLEtBQUssS0FBSzNrQixDQUFWLElBQWU0a0IsS0FBSyxLQUFLM2tCLENBQTdCLEVBQWdDO0FBQzlCO0FBQ0Q7O0FBRURzZ0IsRUFBQUEsRUFBRSxHQUFHaEYsSUFBSSxDQUFDZ0YsRUFBRCxDQUFUO0FBQ0FmLEVBQUFBLEVBQUUsR0FBR2pFLElBQUksQ0FBQ2lFLEVBQUQsQ0FBVDs7QUFFQSxNQUFJdUYsUUFBUSxHQUFHeEMsS0FBSyxHQUFHLEdBQVIsR0FBY3JILFFBQTdCO0FBQUEsTUFDSThKLFFBQVEsR0FBRzNKLElBQUksQ0FBQzBKLFFBQUQsQ0FEbkI7QUFBQSxNQUVJRSxRQUFRLEdBQUc5SixJQUFJLENBQUM0SixRQUFELENBRm5CO0FBQUEsTUFHSXhxQixFQUFFLEdBQUdkLElBQUksQ0FBQ2MsRUFIZDtBQUFBLE1BSUkycUIsS0FBSyxHQUFHM3FCLEVBQUUsR0FBRyxDQUpqQjtBQUFBLE1BS0k0cUIsR0FBRyxHQUFHLENBQUNSLEtBQUssR0FBRzNrQixDQUFULElBQWMsQ0FMeEI7QUFBQSxNQU1Jb2xCLEdBQUcsR0FBRyxDQUFDUixLQUFLLEdBQUcza0IsQ0FBVCxJQUFjLENBTnhCO0FBQUEsTUFPSTBnQixFQUFFLEdBQUdxRSxRQUFRLEdBQUdHLEdBQVgsR0FBaUJGLFFBQVEsR0FBR0csR0FQckM7QUFBQSxNQVFJeEUsRUFBRSxHQUFHLENBQUNxRSxRQUFELEdBQVlFLEdBQVosR0FBa0JILFFBQVEsR0FBR0ksR0FSdEM7QUFBQSxNQVNJQyxLQUFLLEdBQUcxRSxFQUFFLEdBQUdBLEVBVGpCO0FBQUEsTUFVSTJFLEtBQUssR0FBRzFFLEVBQUUsR0FBR0EsRUFWakI7QUFBQSxNQVdJMkUsVUFBVSxHQUFHRixLQUFLLElBQUk5RSxFQUFFLEdBQUdBLEVBQVQsQ0FBTCxHQUFvQitFLEtBQUssSUFBSTlGLEVBQUUsR0FBR0EsRUFBVCxDQVgxQzs7QUFhQSxNQUFJK0YsVUFBVSxHQUFHLENBQWpCLEVBQW9CO0FBQ2xCaEYsSUFBQUEsRUFBRSxHQUFHL0UsS0FBSyxDQUFDK0osVUFBRCxDQUFMLEdBQW9CaEYsRUFBekI7QUFDQWYsSUFBQUEsRUFBRSxHQUFHaEUsS0FBSyxDQUFDK0osVUFBRCxDQUFMLEdBQW9CL0YsRUFBekI7QUFDRDs7QUFFRCxNQUFJZ0csS0FBSyxHQUFHakYsRUFBRSxHQUFHQSxFQUFqQjtBQUFBLE1BQ0lrRixLQUFLLEdBQUdqRyxFQUFFLEdBQUdBLEVBRGpCO0FBQUEsTUFFSWtHLEVBQUUsR0FBRyxDQUFDRixLQUFLLEdBQUdDLEtBQVIsR0FBZ0JELEtBQUssR0FBR0YsS0FBeEIsR0FBZ0NHLEtBQUssR0FBR0osS0FBekMsS0FBbURHLEtBQUssR0FBR0YsS0FBUixHQUFnQkcsS0FBSyxHQUFHSixLQUEzRSxDQUZUOztBQUlBLE1BQUlLLEVBQUUsR0FBRyxDQUFULEVBQVk7QUFDVkEsSUFBQUEsRUFBRSxHQUFHLENBQUw7QUFDRDs7QUFFRCxNQUFJQyxJQUFJLEdBQUcsQ0FBQ2QsWUFBWSxLQUFLQyxTQUFqQixHQUE2QixDQUFDLENBQTlCLEdBQWtDLENBQW5DLElBQXdDdEosS0FBSyxDQUFDa0ssRUFBRCxDQUF4RDtBQUFBLE1BQ0lFLEdBQUcsR0FBR0QsSUFBSSxJQUFJcEYsRUFBRSxHQUFHSyxFQUFMLEdBQVVwQixFQUFkLENBRGQ7QUFBQSxNQUVJcUcsR0FBRyxHQUFHRixJQUFJLEdBQUcsRUFBRW5HLEVBQUUsR0FBR21CLEVBQUwsR0FBVUosRUFBWixDQUZqQjtBQUFBLE1BR0l1RixHQUFHLEdBQUcsQ0FBQ25CLEtBQUssR0FBRzNrQixDQUFULElBQWMsQ0FIeEI7QUFBQSxNQUlJK2xCLEdBQUcsR0FBRyxDQUFDbkIsS0FBSyxHQUFHM2tCLENBQVQsSUFBYyxDQUp4QjtBQUFBLE1BS0l3Z0IsRUFBRSxHQUFHcUYsR0FBRyxJQUFJZCxRQUFRLEdBQUdZLEdBQVgsR0FBaUJYLFFBQVEsR0FBR1ksR0FBaEMsQ0FMWjtBQUFBLE1BTUluRixFQUFFLEdBQUdxRixHQUFHLElBQUlkLFFBQVEsR0FBR1csR0FBWCxHQUFpQlosUUFBUSxHQUFHYSxHQUFoQyxDQU5aO0FBQUEsTUFPSUcsRUFBRSxHQUFHLENBQUNyRixFQUFFLEdBQUdpRixHQUFOLElBQWFyRixFQVB0QjtBQUFBLE1BUUkwRixFQUFFLEdBQUcsQ0FBQ3JGLEVBQUUsR0FBR2lGLEdBQU4sSUFBYXJHLEVBUnRCO0FBQUEsTUFTSTBHLEVBQUUsR0FBRyxDQUFDLENBQUN2RixFQUFELEdBQU1pRixHQUFQLElBQWNyRixFQVR2QjtBQUFBLE1BVUk0RixFQUFFLEdBQUcsQ0FBQyxDQUFDdkYsRUFBRCxHQUFNaUYsR0FBUCxJQUFjckcsRUFWdkI7QUFBQSxNQVdJbkosSUFBSSxHQUFHMlAsRUFBRSxHQUFHQSxFQUFMLEdBQVVDLEVBQUUsR0FBR0EsRUFYMUI7QUFBQSxNQVlJRyxVQUFVLEdBQUcsQ0FBQ0gsRUFBRSxHQUFHLENBQUwsR0FBUyxDQUFDLENBQVYsR0FBYyxDQUFmLElBQW9CeHNCLElBQUksQ0FBQzRzQixJQUFMLENBQVVMLEVBQUUsR0FBR3hLLEtBQUssQ0FBQ25GLElBQUQsQ0FBcEIsQ0FackM7QUFBQSxNQWFJaVEsV0FBVyxHQUFHLENBQUNOLEVBQUUsR0FBR0csRUFBTCxHQUFVRixFQUFFLEdBQUdDLEVBQWYsR0FBb0IsQ0FBcEIsR0FBd0IsQ0FBQyxDQUF6QixHQUE2QixDQUE5QixJQUFtQ3pzQixJQUFJLENBQUM0c0IsSUFBTCxDQUFVLENBQUNMLEVBQUUsR0FBR0UsRUFBTCxHQUFVRCxFQUFFLEdBQUdFLEVBQWhCLElBQXNCM0ssS0FBSyxDQUFDbkYsSUFBSSxJQUFJNlAsRUFBRSxHQUFHQSxFQUFMLEdBQVVDLEVBQUUsR0FBR0EsRUFBbkIsQ0FBTCxDQUFyQyxDQWJyRDs7QUFlQTdhLEVBQUFBLEtBQUssQ0FBQ2diLFdBQUQsQ0FBTCxLQUF1QkEsV0FBVyxHQUFHL3JCLEVBQXJDLEVBakRnRixDQWlEdEM7O0FBRTFDLE1BQUksQ0FBQ3VxQixTQUFELElBQWN3QixXQUFXLEdBQUcsQ0FBaEMsRUFBbUM7QUFDakNBLElBQUFBLFdBQVcsSUFBSXBCLEtBQWY7QUFDRCxHQUZELE1BRU8sSUFBSUosU0FBUyxJQUFJd0IsV0FBVyxHQUFHLENBQS9CLEVBQWtDO0FBQ3ZDQSxJQUFBQSxXQUFXLElBQUlwQixLQUFmO0FBQ0Q7O0FBRURrQixFQUFBQSxVQUFVLElBQUlsQixLQUFkO0FBQ0FvQixFQUFBQSxXQUFXLElBQUlwQixLQUFmOztBQUVBLE1BQUlxQixRQUFRLEdBQUc5c0IsSUFBSSxDQUFDK3NCLElBQUwsQ0FBVWpMLElBQUksQ0FBQytLLFdBQUQsQ0FBSixJQUFxQnBCLEtBQUssR0FBRyxDQUE3QixDQUFWLENBQWY7QUFBQSxNQUNJN0ksT0FBTyxHQUFHLEVBRGQ7QUFBQSxNQUVJb0ssY0FBYyxHQUFHSCxXQUFXLEdBQUdDLFFBRm5DO0FBQUEsTUFHSUcsYUFBYSxHQUFHLElBQUksQ0FBSixHQUFRdkwsSUFBSSxDQUFDc0wsY0FBYyxHQUFHLENBQWxCLENBQVosSUFBb0MsSUFBSXBMLElBQUksQ0FBQ29MLGNBQWMsR0FBRyxDQUFsQixDQUE1QyxDQUhwQjtBQUFBLE1BSUlFLEVBQUUsR0FBRzNCLFFBQVEsR0FBR3pFLEVBSnBCO0FBQUEsTUFLSXFHLEVBQUUsR0FBRzNCLFFBQVEsR0FBRzFFLEVBTHBCO0FBQUEsTUFNSXNHLEVBQUUsR0FBRzVCLFFBQVEsR0FBRyxDQUFDekYsRUFOckI7QUFBQSxNQU9Jc0gsRUFBRSxHQUFHOUIsUUFBUSxHQUFHeEYsRUFQcEI7QUFBQSxNQVFJMWpCLENBUko7O0FBVUEsT0FBS0EsQ0FBQyxHQUFHLENBQVQsRUFBWUEsQ0FBQyxHQUFHeXFCLFFBQWhCLEVBQTBCenFCLENBQUMsRUFBM0IsRUFBK0I7QUFDN0J5bUIsSUFBQUEsS0FBSyxHQUFHNkQsVUFBVSxHQUFHdHFCLENBQUMsR0FBRzJxQixjQUF6QjtBQUNBOUYsSUFBQUEsRUFBRSxHQUFHdEYsSUFBSSxDQUFDa0gsS0FBRCxDQUFUO0FBQ0EzQixJQUFBQSxFQUFFLEdBQUd6RixJQUFJLENBQUNvSCxLQUFELENBQVQ7QUFDQXlELElBQUFBLEVBQUUsR0FBRzNLLElBQUksQ0FBQ2tILEtBQUssSUFBSWtFLGNBQVYsQ0FBVDtBQUNBUixJQUFBQSxFQUFFLEdBQUc5SyxJQUFJLENBQUNvSCxLQUFELENBQVQ7QUFDQWxHLElBQUFBLE9BQU8sQ0FBQzlmLElBQVIsQ0FBYW9rQixFQUFFLEdBQUcrRixhQUFhLEdBQUc5RixFQUFsQyxFQUFzQ0EsRUFBRSxHQUFHOEYsYUFBYSxHQUFHL0YsRUFBM0QsRUFBK0RxRixFQUFFLEdBQUdVLGFBQWEsR0FBR1QsRUFBcEYsRUFBd0ZBLEVBQUUsR0FBR1MsYUFBYSxHQUFHVixFQUE3RyxFQUFpSEEsRUFBakgsRUFBcUhDLEVBQXJIO0FBQ0QsR0E3RStFLENBNkU5RTs7O0FBR0YsT0FBS25xQixDQUFDLEdBQUcsQ0FBVCxFQUFZQSxDQUFDLEdBQUd1Z0IsT0FBTyxDQUFDdGdCLE1BQXhCLEVBQWdDRCxDQUFDLElBQUksQ0FBckMsRUFBd0M7QUFDdEM2a0IsSUFBQUEsRUFBRSxHQUFHdEUsT0FBTyxDQUFDdmdCLENBQUQsQ0FBWjtBQUNBOGtCLElBQUFBLEVBQUUsR0FBR3ZFLE9BQU8sQ0FBQ3ZnQixDQUFDLEdBQUcsQ0FBTCxDQUFaO0FBQ0F1Z0IsSUFBQUEsT0FBTyxDQUFDdmdCLENBQUQsQ0FBUCxHQUFhNmtCLEVBQUUsR0FBR2dHLEVBQUwsR0FBVS9GLEVBQUUsR0FBR2lHLEVBQWYsR0FBb0JwRyxFQUFqQztBQUNBcEUsSUFBQUEsT0FBTyxDQUFDdmdCLENBQUMsR0FBRyxDQUFMLENBQVAsR0FBaUI2a0IsRUFBRSxHQUFHaUcsRUFBTCxHQUFVaEcsRUFBRSxHQUFHa0csRUFBZixHQUFvQnBHLEVBQXJDO0FBQ0Q7O0FBRURyRSxFQUFBQSxPQUFPLENBQUN2Z0IsQ0FBQyxHQUFHLENBQUwsQ0FBUCxHQUFpQmtFLENBQWpCLENBdkZnRixDQXVGNUQ7O0FBRXBCcWMsRUFBQUEsT0FBTyxDQUFDdmdCLENBQUMsR0FBRyxDQUFMLENBQVAsR0FBaUJtRSxDQUFqQjtBQUNBLFNBQU9vYyxPQUFQO0FBQ0QsRUFBQzs7O0FBR0ssU0FBUzhCLGVBQVQsQ0FBeUIzSCxDQUF6QixFQUE0QjtBQUNqQyxNQUFJNVIsQ0FBQyxHQUFHLENBQUM0UixDQUFDLEdBQUcsRUFBTCxFQUFTcmMsT0FBVCxDQUFpQjZnQixXQUFqQixFQUE4QixVQUFVekIsQ0FBVixFQUFhO0FBQ2pELFFBQUkzSSxDQUFDLEdBQUcsQ0FBQzJJLENBQVQ7QUFDQSxXQUFPM0ksQ0FBQyxHQUFHLE1BQUosSUFBY0EsQ0FBQyxHQUFHLENBQUMsTUFBbkIsR0FBNEIsQ0FBNUIsR0FBZ0NBLENBQXZDO0FBQ0QsR0FITyxFQUdMaVEsS0FISyxDQUdDL0YsV0FIRCxLQUdpQixFQUh6QjtBQUFBLE1BSUk7QUFDSnlELEVBQUFBLElBQUksR0FBRyxFQUxQO0FBQUEsTUFNSXdJLFNBQVMsR0FBRyxDQU5oQjtBQUFBLE1BT0lDLFNBQVMsR0FBRyxDQVBoQjtBQUFBLE1BUUlDLFNBQVMsR0FBRyxJQUFJLENBUnBCO0FBQUEsTUFTSXByQixRQUFRLEdBQUcrSSxDQUFDLENBQUM3SSxNQVRqQjtBQUFBLE1BVUk2VixNQUFNLEdBQUcsQ0FWYjtBQUFBLE1BV0lzVixZQUFZLEdBQUcsNEJBQTRCMVEsQ0FYL0M7QUFBQSxNQVlJMWEsQ0FaSjtBQUFBLE1BYUl3bUIsQ0FiSjtBQUFBLE1BY0l0aUIsQ0FkSjtBQUFBLE1BZUlDLENBZko7QUFBQSxNQWdCSWtuQixPQWhCSjtBQUFBLE1BaUJJQyxVQWpCSjtBQUFBLE1Ba0JJNUssT0FsQko7QUFBQSxNQW1CSTFJLE1BbkJKO0FBQUEsTUFvQklDLE1BcEJKO0FBQUEsTUFxQklzVCxJQXJCSjtBQUFBLE1Bc0JJQyxJQXRCSjtBQUFBLE1BdUJJQyxPQXZCSjtBQUFBLE1Bd0JJQyxXQXhCSjtBQUFBLE1BeUJJQyxLQXpCSjtBQUFBLE1BMEJJQyxLQTFCSjtBQUFBLE1BMkJJMUksSUFBSSxHQUFHLFNBQVNBLElBQVQsQ0FBYzJJLEVBQWQsRUFBa0JDLEVBQWxCLEVBQXNCQyxFQUF0QixFQUEwQkMsRUFBMUIsRUFBOEI7QUFDdkNULElBQUFBLElBQUksR0FBRyxDQUFDUSxFQUFFLEdBQUdGLEVBQU4sSUFBWSxDQUFuQjtBQUNBTCxJQUFBQSxJQUFJLEdBQUcsQ0FBQ1EsRUFBRSxHQUFHRixFQUFOLElBQVksQ0FBbkI7QUFDQXBMLElBQUFBLE9BQU8sQ0FBQ2pnQixJQUFSLENBQWFvckIsRUFBRSxHQUFHTixJQUFsQixFQUF3Qk8sRUFBRSxHQUFHTixJQUE3QixFQUFtQ08sRUFBRSxHQUFHUixJQUF4QyxFQUE4Q1MsRUFBRSxHQUFHUixJQUFuRCxFQUF5RE8sRUFBekQsRUFBNkRDLEVBQTdEO0FBQ0QsR0EvQkQ7O0FBaUNBLE1BQUksQ0FBQ3RSLENBQUQsSUFBTSxDQUFDbEwsS0FBSyxDQUFDMUcsQ0FBQyxDQUFDLENBQUQsQ0FBRixDQUFaLElBQXNCMEcsS0FBSyxDQUFDMUcsQ0FBQyxDQUFDLENBQUQsQ0FBRixDQUEvQixFQUF1QztBQUNyQytGLElBQUFBLE9BQU8sQ0FBQ29kLEdBQVIsQ0FBWWIsWUFBWjtBQUNBLFdBQU8zSSxJQUFQO0FBQ0Q7O0FBRUQsT0FBS3ppQixDQUFDLEdBQUcsQ0FBVCxFQUFZQSxDQUFDLEdBQUdELFFBQWhCLEVBQTBCQyxDQUFDLEVBQTNCLEVBQStCO0FBQzdCMHJCLElBQUFBLFdBQVcsR0FBR0wsT0FBZDs7QUFFQSxRQUFJN2IsS0FBSyxDQUFDMUcsQ0FBQyxDQUFDOUksQ0FBRCxDQUFGLENBQVQsRUFBaUI7QUFDZnFyQixNQUFBQSxPQUFPLEdBQUd2aUIsQ0FBQyxDQUFDOUksQ0FBRCxDQUFELENBQUtrc0IsV0FBTCxFQUFWO0FBQ0FaLE1BQUFBLFVBQVUsR0FBR0QsT0FBTyxLQUFLdmlCLENBQUMsQ0FBQzlJLENBQUQsQ0FBMUIsQ0FGZSxDQUVnQjtBQUNoQyxLQUhELE1BR087QUFDTDtBQUNBQSxNQUFBQSxDQUFDO0FBQ0Y7O0FBRURrRSxJQUFBQSxDQUFDLEdBQUcsQ0FBQzRFLENBQUMsQ0FBQzlJLENBQUMsR0FBRyxDQUFMLENBQU47QUFDQW1FLElBQUFBLENBQUMsR0FBRyxDQUFDMkUsQ0FBQyxDQUFDOUksQ0FBQyxHQUFHLENBQUwsQ0FBTjs7QUFFQSxRQUFJc3JCLFVBQUosRUFBZ0I7QUFDZHBuQixNQUFBQSxDQUFDLElBQUkrbUIsU0FBTDtBQUNBOW1CLE1BQUFBLENBQUMsSUFBSSttQixTQUFMO0FBQ0Q7O0FBRUQsUUFBSSxDQUFDbHJCLENBQUwsRUFBUTtBQUNOZ1ksTUFBQUEsTUFBTSxHQUFHOVQsQ0FBVDtBQUNBK1QsTUFBQUEsTUFBTSxHQUFHOVQsQ0FBVDtBQUNELEtBdEI0QixDQXNCM0I7OztBQUdGLFFBQUlrbkIsT0FBTyxLQUFLLEdBQWhCLEVBQXFCO0FBQ25CLFVBQUkzSyxPQUFKLEVBQWE7QUFDWCxZQUFJQSxPQUFPLENBQUN6Z0IsTUFBUixHQUFpQixDQUFyQixFQUF3QjtBQUN0QjtBQUNBd2lCLFVBQUFBLElBQUksQ0FBQ3hpQixNQUFMLElBQWUsQ0FBZjtBQUNELFNBSEQsTUFHTztBQUNMNlYsVUFBQUEsTUFBTSxJQUFJNEssT0FBTyxDQUFDemdCLE1BQWxCO0FBQ0Q7QUFDRjs7QUFFRGdyQixNQUFBQSxTQUFTLEdBQUdqVCxNQUFNLEdBQUc5VCxDQUFyQjtBQUNBZ25CLE1BQUFBLFNBQVMsR0FBR2pULE1BQU0sR0FBRzlULENBQXJCO0FBQ0F1YyxNQUFBQSxPQUFPLEdBQUcsQ0FBQ3hjLENBQUQsRUFBSUMsQ0FBSixDQUFWO0FBQ0FzZSxNQUFBQSxJQUFJLENBQUNoaUIsSUFBTCxDQUFVaWdCLE9BQVY7QUFDQTFnQixNQUFBQSxDQUFDLElBQUksQ0FBTDtBQUNBcXJCLE1BQUFBLE9BQU8sR0FBRyxHQUFWLENBZm1CLENBZUo7QUFDZjtBQUNELEtBakJELE1BaUJPLElBQUlBLE9BQU8sS0FBSyxHQUFoQixFQUFxQjtBQUMxQixVQUFJLENBQUMzSyxPQUFMLEVBQWM7QUFDWkEsUUFBQUEsT0FBTyxHQUFHLENBQUMsQ0FBRCxFQUFJLENBQUosQ0FBVjtBQUNEOztBQUVELFVBQUksQ0FBQzRLLFVBQUwsRUFBaUI7QUFDZkwsUUFBQUEsU0FBUyxHQUFHQyxTQUFTLEdBQUcsQ0FBeEI7QUFDRCxPQVB5QixDQU94Qjs7O0FBR0Z4SyxNQUFBQSxPQUFPLENBQUNqZ0IsSUFBUixDQUFheUQsQ0FBYixFQUFnQkMsQ0FBaEIsRUFBbUI4bUIsU0FBUyxHQUFHbmlCLENBQUMsQ0FBQzlJLENBQUMsR0FBRyxDQUFMLENBQUQsR0FBVyxDQUExQyxFQUE2Q2tyQixTQUFTLEdBQUdwaUIsQ0FBQyxDQUFDOUksQ0FBQyxHQUFHLENBQUwsQ0FBRCxHQUFXLENBQXBFLEVBQXVFaXJCLFNBQVMsSUFBSW5pQixDQUFDLENBQUM5SSxDQUFDLEdBQUcsQ0FBTCxDQUFELEdBQVcsQ0FBL0YsRUFBa0drckIsU0FBUyxJQUFJcGlCLENBQUMsQ0FBQzlJLENBQUMsR0FBRyxDQUFMLENBQUQsR0FBVyxDQUExSDtBQUNBQSxNQUFBQSxDQUFDLElBQUksQ0FBTCxDQVgwQixDQVdsQjtBQUNULEtBWk0sTUFZQSxJQUFJcXJCLE9BQU8sS0FBSyxHQUFoQixFQUFxQjtBQUMxQkUsTUFBQUEsSUFBSSxHQUFHTixTQUFQO0FBQ0FPLE1BQUFBLElBQUksR0FBR04sU0FBUDs7QUFFQSxVQUFJUSxXQUFXLEtBQUssR0FBaEIsSUFBdUJBLFdBQVcsS0FBSyxHQUEzQyxFQUFnRDtBQUM5Q0gsUUFBQUEsSUFBSSxJQUFJTixTQUFTLEdBQUd2SyxPQUFPLENBQUNBLE9BQU8sQ0FBQ3pnQixNQUFSLEdBQWlCLENBQWxCLENBQTNCO0FBQ0F1ckIsUUFBQUEsSUFBSSxJQUFJTixTQUFTLEdBQUd4SyxPQUFPLENBQUNBLE9BQU8sQ0FBQ3pnQixNQUFSLEdBQWlCLENBQWxCLENBQTNCO0FBQ0Q7O0FBRUQsVUFBSSxDQUFDcXJCLFVBQUwsRUFBaUI7QUFDZkwsUUFBQUEsU0FBUyxHQUFHQyxTQUFTLEdBQUcsQ0FBeEI7QUFDRDs7QUFFRHhLLE1BQUFBLE9BQU8sQ0FBQ2pnQixJQUFSLENBQWE4cUIsSUFBYixFQUFtQkMsSUFBbkIsRUFBeUJ0bkIsQ0FBekIsRUFBNEJDLENBQTVCLEVBQStCOG1CLFNBQVMsSUFBSW5pQixDQUFDLENBQUM5SSxDQUFDLEdBQUcsQ0FBTCxDQUFELEdBQVcsQ0FBdkQsRUFBMERrckIsU0FBUyxJQUFJcGlCLENBQUMsQ0FBQzlJLENBQUMsR0FBRyxDQUFMLENBQUQsR0FBVyxDQUFsRjtBQUNBQSxNQUFBQSxDQUFDLElBQUksQ0FBTCxDQWQwQixDQWNsQjtBQUNULEtBZk0sTUFlQSxJQUFJcXJCLE9BQU8sS0FBSyxHQUFoQixFQUFxQjtBQUMxQkUsTUFBQUEsSUFBSSxHQUFHTixTQUFTLEdBQUcsQ0FBQy9tQixDQUFDLEdBQUcrbUIsU0FBTCxJQUFrQkUsU0FBckM7QUFDQUssTUFBQUEsSUFBSSxHQUFHTixTQUFTLEdBQUcsQ0FBQy9tQixDQUFDLEdBQUcrbUIsU0FBTCxJQUFrQkMsU0FBckM7O0FBRUEsVUFBSSxDQUFDRyxVQUFMLEVBQWlCO0FBQ2ZMLFFBQUFBLFNBQVMsR0FBR0MsU0FBUyxHQUFHLENBQXhCO0FBQ0Q7O0FBRURELE1BQUFBLFNBQVMsSUFBSW5pQixDQUFDLENBQUM5SSxDQUFDLEdBQUcsQ0FBTCxDQUFELEdBQVcsQ0FBeEI7QUFDQWtyQixNQUFBQSxTQUFTLElBQUlwaUIsQ0FBQyxDQUFDOUksQ0FBQyxHQUFHLENBQUwsQ0FBRCxHQUFXLENBQXhCO0FBQ0EwZ0IsTUFBQUEsT0FBTyxDQUFDamdCLElBQVIsQ0FBYThxQixJQUFiLEVBQW1CQyxJQUFuQixFQUF5QlAsU0FBUyxHQUFHLENBQUMvbUIsQ0FBQyxHQUFHK21CLFNBQUwsSUFBa0JFLFNBQXZELEVBQWtFRCxTQUFTLEdBQUcsQ0FBQy9tQixDQUFDLEdBQUcrbUIsU0FBTCxJQUFrQkMsU0FBaEcsRUFBMkdGLFNBQTNHLEVBQXNIQyxTQUF0SDtBQUNBbHJCLE1BQUFBLENBQUMsSUFBSSxDQUFMLENBWDBCLENBV2xCO0FBQ1QsS0FaTSxNQVlBLElBQUlxckIsT0FBTyxLQUFLLEdBQWhCLEVBQXFCO0FBQzFCRSxNQUFBQSxJQUFJLEdBQUdOLFNBQVMsR0FBR3ZLLE9BQU8sQ0FBQ0EsT0FBTyxDQUFDemdCLE1BQVIsR0FBaUIsQ0FBbEIsQ0FBMUI7QUFDQXVyQixNQUFBQSxJQUFJLEdBQUdOLFNBQVMsR0FBR3hLLE9BQU8sQ0FBQ0EsT0FBTyxDQUFDemdCLE1BQVIsR0FBaUIsQ0FBbEIsQ0FBMUI7QUFDQXlnQixNQUFBQSxPQUFPLENBQUNqZ0IsSUFBUixDQUFhd3FCLFNBQVMsR0FBR00sSUFBekIsRUFBK0JMLFNBQVMsR0FBR00sSUFBM0MsRUFBaUR0bkIsQ0FBQyxHQUFHLENBQUMrbUIsU0FBUyxHQUFHTSxJQUFJLEdBQUcsR0FBbkIsR0FBeUJybkIsQ0FBMUIsSUFBK0JpbkIsU0FBcEYsRUFBK0ZobkIsQ0FBQyxHQUFHLENBQUMrbUIsU0FBUyxHQUFHTSxJQUFJLEdBQUcsR0FBbkIsR0FBeUJybkIsQ0FBMUIsSUFBK0JnbkIsU0FBbEksRUFBNklGLFNBQVMsR0FBRy9tQixDQUF6SixFQUE0SmduQixTQUFTLEdBQUcvbUIsQ0FBeEs7QUFDQW5FLE1BQUFBLENBQUMsSUFBSSxDQUFMLENBSjBCLENBSWxCO0FBQ1QsS0FMTSxNQUtBLElBQUlxckIsT0FBTyxLQUFLLEdBQWhCLEVBQXFCO0FBQzFCbkksTUFBQUEsSUFBSSxDQUFDK0gsU0FBRCxFQUFZQyxTQUFaLEVBQXVCRCxTQUFTLEdBQUcvbUIsQ0FBbkMsRUFBc0NnbkIsU0FBdEMsQ0FBSjtBQUNBbHJCLE1BQUFBLENBQUMsSUFBSSxDQUFMLENBRjBCLENBRWxCO0FBQ1QsS0FITSxNQUdBLElBQUlxckIsT0FBTyxLQUFLLEdBQWhCLEVBQXFCO0FBQzFCO0FBQ0FuSSxNQUFBQSxJQUFJLENBQUMrSCxTQUFELEVBQVlDLFNBQVosRUFBdUJELFNBQXZCLEVBQWtDQyxTQUFTLEdBQUdobkIsQ0FBQyxJQUFJb25CLFVBQVUsR0FBR0osU0FBUyxHQUFHRCxTQUFmLEdBQTJCLENBQXpDLENBQS9DLENBQUo7QUFDQWpyQixNQUFBQSxDQUFDLElBQUksQ0FBTCxDQUgwQixDQUdsQjtBQUNULEtBSk0sTUFJQSxJQUFJcXJCLE9BQU8sS0FBSyxHQUFaLElBQW1CQSxPQUFPLEtBQUssR0FBbkMsRUFBd0M7QUFDN0MsVUFBSUEsT0FBTyxLQUFLLEdBQWhCLEVBQXFCO0FBQ25Cbm5CLFFBQUFBLENBQUMsR0FBRzhULE1BQUo7QUFDQTdULFFBQUFBLENBQUMsR0FBRzhULE1BQUo7QUFDQXlJLFFBQUFBLE9BQU8sQ0FBQ3lMLE1BQVIsR0FBaUIsSUFBakI7QUFDRDs7QUFFRCxVQUFJZCxPQUFPLEtBQUssR0FBWixJQUFtQjVMLElBQUksQ0FBQ3dMLFNBQVMsR0FBRy9tQixDQUFiLENBQUosR0FBc0IsR0FBekMsSUFBZ0R1YixJQUFJLENBQUN5TCxTQUFTLEdBQUcvbUIsQ0FBYixDQUFKLEdBQXNCLEdBQTFFLEVBQStFO0FBQzdFK2UsUUFBQUEsSUFBSSxDQUFDK0gsU0FBRCxFQUFZQyxTQUFaLEVBQXVCaG5CLENBQXZCLEVBQTBCQyxDQUExQixDQUFKOztBQUVBLFlBQUlrbkIsT0FBTyxLQUFLLEdBQWhCLEVBQXFCO0FBQ25CcnJCLFVBQUFBLENBQUMsSUFBSSxDQUFMO0FBQ0Q7QUFDRjs7QUFFRGlyQixNQUFBQSxTQUFTLEdBQUcvbUIsQ0FBWjtBQUNBZ25CLE1BQUFBLFNBQVMsR0FBRy9tQixDQUFaLENBaEI2QyxDQWdCOUI7QUFDaEIsS0FqQk0sTUFpQkEsSUFBSWtuQixPQUFPLEtBQUssR0FBaEIsRUFBcUI7QUFDMUJNLE1BQUFBLEtBQUssR0FBRzdpQixDQUFDLENBQUM5SSxDQUFDLEdBQUcsQ0FBTCxDQUFUO0FBQ0E0ckIsTUFBQUEsS0FBSyxHQUFHOWlCLENBQUMsQ0FBQzlJLENBQUMsR0FBRyxDQUFMLENBQVQ7QUFDQXVyQixNQUFBQSxJQUFJLEdBQUd6aUIsQ0FBQyxDQUFDOUksQ0FBQyxHQUFHLENBQUwsQ0FBUjtBQUNBd3JCLE1BQUFBLElBQUksR0FBRzFpQixDQUFDLENBQUM5SSxDQUFDLEdBQUcsQ0FBTCxDQUFSO0FBQ0F3bUIsTUFBQUEsQ0FBQyxHQUFHLENBQUo7O0FBRUEsVUFBSW1GLEtBQUssQ0FBQzFyQixNQUFOLEdBQWUsQ0FBbkIsRUFBc0I7QUFDcEI7QUFDQSxZQUFJMHJCLEtBQUssQ0FBQzFyQixNQUFOLEdBQWUsQ0FBbkIsRUFBc0I7QUFDcEJ1ckIsVUFBQUEsSUFBSSxHQUFHRCxJQUFQO0FBQ0FBLFVBQUFBLElBQUksR0FBR0ssS0FBUDtBQUNBcEYsVUFBQUEsQ0FBQztBQUNGLFNBSkQsTUFJTztBQUNMZ0YsVUFBQUEsSUFBSSxHQUFHSSxLQUFQO0FBQ0FMLFVBQUFBLElBQUksR0FBR0ksS0FBSyxDQUFDUyxNQUFOLENBQWEsQ0FBYixDQUFQO0FBQ0E1RixVQUFBQSxDQUFDLElBQUksQ0FBTDtBQUNEOztBQUVEb0YsUUFBQUEsS0FBSyxHQUFHRCxLQUFLLENBQUNVLE1BQU4sQ0FBYSxDQUFiLENBQVI7QUFDQVYsUUFBQUEsS0FBSyxHQUFHQSxLQUFLLENBQUNVLE1BQU4sQ0FBYSxDQUFiLENBQVI7QUFDRDs7QUFFRFosTUFBQUEsT0FBTyxHQUFHN0MsWUFBWSxDQUFDcUMsU0FBRCxFQUFZQyxTQUFaLEVBQXVCLENBQUNwaUIsQ0FBQyxDQUFDOUksQ0FBQyxHQUFHLENBQUwsQ0FBekIsRUFBa0MsQ0FBQzhJLENBQUMsQ0FBQzlJLENBQUMsR0FBRyxDQUFMLENBQXBDLEVBQTZDLENBQUM4SSxDQUFDLENBQUM5SSxDQUFDLEdBQUcsQ0FBTCxDQUEvQyxFQUF3RCxDQUFDMnJCLEtBQXpELEVBQWdFLENBQUNDLEtBQWpFLEVBQXdFLENBQUNOLFVBQVUsR0FBR0wsU0FBSCxHQUFlLENBQTFCLElBQStCTSxJQUFJLEdBQUcsQ0FBOUcsRUFBaUgsQ0FBQ0QsVUFBVSxHQUFHSixTQUFILEdBQWUsQ0FBMUIsSUFBK0JNLElBQUksR0FBRyxDQUF2SixDQUF0QjtBQUNBeHJCLE1BQUFBLENBQUMsSUFBSXdtQixDQUFMOztBQUVBLFVBQUlpRixPQUFKLEVBQWE7QUFDWCxhQUFLakYsQ0FBQyxHQUFHLENBQVQsRUFBWUEsQ0FBQyxHQUFHaUYsT0FBTyxDQUFDeHJCLE1BQXhCLEVBQWdDdW1CLENBQUMsRUFBakMsRUFBcUM7QUFDbkM5RixVQUFBQSxPQUFPLENBQUNqZ0IsSUFBUixDQUFhZ3JCLE9BQU8sQ0FBQ2pGLENBQUQsQ0FBcEI7QUFDRDtBQUNGOztBQUVEeUUsTUFBQUEsU0FBUyxHQUFHdkssT0FBTyxDQUFDQSxPQUFPLENBQUN6Z0IsTUFBUixHQUFpQixDQUFsQixDQUFuQjtBQUNBaXJCLE1BQUFBLFNBQVMsR0FBR3hLLE9BQU8sQ0FBQ0EsT0FBTyxDQUFDemdCLE1BQVIsR0FBaUIsQ0FBbEIsQ0FBbkI7QUFDRCxLQWxDTSxNQWtDQTtBQUNMNE8sTUFBQUEsT0FBTyxDQUFDb2QsR0FBUixDQUFZYixZQUFaO0FBQ0Q7QUFDRjs7QUFFRHByQixFQUFBQSxDQUFDLEdBQUcwZ0IsT0FBTyxDQUFDemdCLE1BQVo7O0FBRUEsTUFBSUQsQ0FBQyxHQUFHLENBQVIsRUFBVztBQUNUO0FBQ0F5aUIsSUFBQUEsSUFBSSxDQUFDNkosR0FBTDtBQUNBdHNCLElBQUFBLENBQUMsR0FBRyxDQUFKO0FBQ0QsR0FKRCxNQUlPLElBQUkwZ0IsT0FBTyxDQUFDLENBQUQsQ0FBUCxLQUFlQSxPQUFPLENBQUMxZ0IsQ0FBQyxHQUFHLENBQUwsQ0FBdEIsSUFBaUMwZ0IsT0FBTyxDQUFDLENBQUQsQ0FBUCxLQUFlQSxPQUFPLENBQUMxZ0IsQ0FBQyxHQUFHLENBQUwsQ0FBM0QsRUFBb0U7QUFDekUwZ0IsSUFBQUEsT0FBTyxDQUFDeUwsTUFBUixHQUFpQixJQUFqQjtBQUNEOztBQUVEMUosRUFBQUEsSUFBSSxDQUFDZCxXQUFMLEdBQW1CN0wsTUFBTSxHQUFHOVYsQ0FBNUI7QUFDQSxTQUFPeWlCLElBQVA7QUFDRCxFQUFDOztBQUVLLFNBQVM4SixjQUFULENBQXdCMUgsRUFBeEIsRUFBNEJDLEVBQTVCLEVBQWdDZixFQUFoQyxFQUFvQ0ssRUFBcEMsRUFBd0NKLEVBQXhDLEVBQTRDSyxFQUE1QyxFQUFnREosRUFBaEQsRUFBb0RLLEVBQXBELEVBQXdEekgsU0FBeEQsRUFBbUUvRyxNQUFuRSxFQUEyRStMLEtBQTNFLEVBQWtGO0FBQ3ZGLE1BQUkySyxHQUFHLEdBQUcsQ0FBQzNILEVBQUUsR0FBR2QsRUFBTixJQUFZLENBQXRCO0FBQUEsTUFDSTBJLEdBQUcsR0FBRyxDQUFDM0gsRUFBRSxHQUFHVixFQUFOLElBQVksQ0FEdEI7QUFBQSxNQUVJc0ksR0FBRyxHQUFHLENBQUMzSSxFQUFFLEdBQUdDLEVBQU4sSUFBWSxDQUZ0QjtBQUFBLE1BR0kySSxHQUFHLEdBQUcsQ0FBQ3ZJLEVBQUUsR0FBR0MsRUFBTixJQUFZLENBSHRCO0FBQUEsTUFJSXVJLEdBQUcsR0FBRyxDQUFDNUksRUFBRSxHQUFHQyxFQUFOLElBQVksQ0FKdEI7QUFBQSxNQUtJNEksR0FBRyxHQUFHLENBQUN4SSxFQUFFLEdBQUdDLEVBQU4sSUFBWSxDQUx0QjtBQUFBLE1BTUl3SSxJQUFJLEdBQUcsQ0FBQ04sR0FBRyxHQUFHRSxHQUFQLElBQWMsQ0FOekI7QUFBQSxNQU9JSyxJQUFJLEdBQUcsQ0FBQ04sR0FBRyxHQUFHRSxHQUFQLElBQWMsQ0FQekI7QUFBQSxNQVFJSyxJQUFJLEdBQUcsQ0FBQ04sR0FBRyxHQUFHRSxHQUFQLElBQWMsQ0FSekI7QUFBQSxNQVNJSyxJQUFJLEdBQUcsQ0FBQ04sR0FBRyxHQUFHRSxHQUFQLElBQWMsQ0FUekI7QUFBQSxNQVVJSyxLQUFLLEdBQUcsQ0FBQ0osSUFBSSxHQUFHRSxJQUFSLElBQWdCLENBVjVCO0FBQUEsTUFXSUcsS0FBSyxHQUFHLENBQUNKLElBQUksR0FBR0UsSUFBUixJQUFnQixDQVg1QjtBQUFBLE1BWUk1WCxFQUFFLEdBQUc0TyxFQUFFLEdBQUdZLEVBWmQ7QUFBQSxNQWFJdlAsRUFBRSxHQUFHZ1AsRUFBRSxHQUFHUSxFQWJkO0FBQUEsTUFjSXNJLEVBQUUsR0FBRzNOLElBQUksQ0FBQyxDQUFDc0UsRUFBRSxHQUFHRSxFQUFOLElBQVkzTyxFQUFaLEdBQWlCLENBQUM4TyxFQUFFLEdBQUdFLEVBQU4sSUFBWWpQLEVBQTlCLENBZGI7QUFBQSxNQWVJZ1ksRUFBRSxHQUFHNU4sSUFBSSxDQUFDLENBQUN1RSxFQUFFLEdBQUdDLEVBQU4sSUFBWTNPLEVBQVosR0FBaUIsQ0FBQytPLEVBQUUsR0FBR0MsRUFBTixJQUFZalAsRUFBOUIsQ0FmYjtBQUFBLE1BZ0JJcFYsTUFoQko7O0FBa0JBLE1BQUksQ0FBQzZWLE1BQUwsRUFBYTtBQUNYQSxJQUFBQSxNQUFNLEdBQUcsQ0FBQytPLEVBQUQsRUFBS0MsRUFBTCxFQUFTYixFQUFULEVBQWFLLEVBQWIsQ0FBVDtBQUNBekMsSUFBQUEsS0FBSyxHQUFHLENBQVI7QUFDRDs7QUFFRC9MLEVBQUFBLE1BQU0sQ0FBQy9VLE1BQVAsQ0FBYzhnQixLQUFLLElBQUkvTCxNQUFNLENBQUM3VixNQUFQLEdBQWdCLENBQXZDLEVBQTBDLENBQTFDLEVBQTZDaXRCLEtBQTdDLEVBQW9EQyxLQUFwRDs7QUFFQSxNQUFJLENBQUNDLEVBQUUsR0FBR0MsRUFBTixLQUFhRCxFQUFFLEdBQUdDLEVBQWxCLElBQXdCeFEsU0FBUyxJQUFJeEgsRUFBRSxHQUFHQSxFQUFMLEdBQVVDLEVBQUUsR0FBR0EsRUFBbkIsQ0FBckMsRUFBNkQ7QUFDM0RyVixJQUFBQSxNQUFNLEdBQUc2VixNQUFNLENBQUM3VixNQUFoQjtBQUNBc3NCLElBQUFBLGNBQWMsQ0FBQzFILEVBQUQsRUFBS0MsRUFBTCxFQUFTMEgsR0FBVCxFQUFjQyxHQUFkLEVBQW1CSyxJQUFuQixFQUF5QkMsSUFBekIsRUFBK0JHLEtBQS9CLEVBQXNDQyxLQUF0QyxFQUE2Q3RRLFNBQTdDLEVBQXdEL0csTUFBeEQsRUFBZ0UrTCxLQUFoRSxDQUFkO0FBQ0EwSyxJQUFBQSxjQUFjLENBQUNXLEtBQUQsRUFBUUMsS0FBUixFQUFlSCxJQUFmLEVBQXFCQyxJQUFyQixFQUEyQkwsR0FBM0IsRUFBZ0NDLEdBQWhDLEVBQXFDNUksRUFBckMsRUFBeUNLLEVBQXpDLEVBQTZDekgsU0FBN0MsRUFBd0QvRyxNQUF4RCxFQUFnRStMLEtBQUssR0FBRyxDQUFSLElBQWEvTCxNQUFNLENBQUM3VixNQUFQLEdBQWdCQSxNQUE3QixDQUFoRSxDQUFkO0FBQ0Q7O0FBRUQsU0FBTzZWLE1BQVA7QUFDRDtBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTyxTQUFTd1gsbUJBQVQsQ0FBNkJ4WCxNQUE3QixFQUFxQ3lYLFNBQXJDLEVBQWdEO0FBQ3JELE1BQUlBLFNBQVMsS0FBSyxLQUFLLENBQXZCLEVBQTBCO0FBQ3hCQSxJQUFBQSxTQUFTLEdBQUcsQ0FBWjtBQUNEOztBQUVELE1BQUlycEIsQ0FBQyxHQUFHNFIsTUFBTSxDQUFDLENBQUQsQ0FBZDtBQUFBLE1BQ0kzUixDQUFDLEdBQUcsQ0FEUjtBQUFBLE1BRUl1YyxPQUFPLEdBQUcsQ0FBQ3hjLENBQUQsRUFBSUMsQ0FBSixDQUZkO0FBQUEsTUFHSW5FLENBQUMsR0FBRyxDQUhSOztBQUtBLFNBQU9BLENBQUMsR0FBRzhWLE1BQU0sQ0FBQzdWLE1BQWxCLEVBQTBCRCxDQUFDLElBQUksQ0FBL0IsRUFBa0M7QUFDaEMwZ0IsSUFBQUEsT0FBTyxDQUFDamdCLElBQVIsQ0FBYXlELENBQWIsRUFBZ0JDLENBQWhCLEVBQW1CMlIsTUFBTSxDQUFDOVYsQ0FBRCxDQUF6QixFQUE4Qm1FLENBQUMsR0FBRyxDQUFDMlIsTUFBTSxDQUFDOVYsQ0FBRCxDQUFOLEdBQVlrRSxDQUFiLElBQWtCcXBCLFNBQWxCLEdBQThCLENBQWhFLEVBQW1FcnBCLENBQUMsR0FBRzRSLE1BQU0sQ0FBQzlWLENBQUQsQ0FBN0UsRUFBa0YsQ0FBQ21FLENBQW5GO0FBQ0Q7O0FBRUQsU0FBT3VjLE9BQVA7QUFDRCxFQUFDOztBQUVLLFNBQVM4TSxlQUFULENBQXlCMVgsTUFBekIsRUFBaUN5WCxTQUFqQyxFQUE0QztBQUNqRDtBQUNBOU4sRUFBQUEsSUFBSSxDQUFDM0osTUFBTSxDQUFDLENBQUQsQ0FBTixHQUFZQSxNQUFNLENBQUMsQ0FBRCxDQUFuQixDQUFKLEdBQThCLElBQTlCLElBQXNDMkosSUFBSSxDQUFDM0osTUFBTSxDQUFDLENBQUQsQ0FBTixHQUFZQSxNQUFNLENBQUMsQ0FBRCxDQUFuQixDQUFKLEdBQThCLElBQXBFLEtBQTZFQSxNQUFNLEdBQUdBLE1BQU0sQ0FBQytLLEtBQVAsQ0FBYSxDQUFiLENBQXRGLEVBRmlELENBRXVEOztBQUV4RyxNQUFJOVgsQ0FBQyxHQUFHK00sTUFBTSxDQUFDN1YsTUFBUCxHQUFnQixDQUF4QjtBQUFBLE1BQ0lpRSxDQUFDLEdBQUcsQ0FBQzRSLE1BQU0sQ0FBQyxDQUFELENBRGY7QUFBQSxNQUVJM1IsQ0FBQyxHQUFHLENBQUMyUixNQUFNLENBQUMsQ0FBRCxDQUZmO0FBQUEsTUFHSTJYLEtBQUssR0FBRyxDQUFDM1gsTUFBTSxDQUFDLENBQUQsQ0FIbkI7QUFBQSxNQUlJNFgsS0FBSyxHQUFHLENBQUM1WCxNQUFNLENBQUMsQ0FBRCxDQUpuQjtBQUFBLE1BS0k0SyxPQUFPLEdBQUcsQ0FBQ3hjLENBQUQsRUFBSUMsQ0FBSixFQUFPRCxDQUFQLEVBQVVDLENBQVYsQ0FMZDtBQUFBLE1BTUlrbEIsR0FBRyxHQUFHb0UsS0FBSyxHQUFHdnBCLENBTmxCO0FBQUEsTUFPSW9sQixHQUFHLEdBQUdvRSxLQUFLLEdBQUd2cEIsQ0FQbEI7QUFBQSxNQVFJZ29CLE1BQU0sR0FBR3h1QixJQUFJLENBQUMyYixHQUFMLENBQVN4RCxNQUFNLENBQUMvTSxDQUFELENBQU4sR0FBWTdFLENBQXJCLElBQTBCLEtBQTFCLElBQW1DdkcsSUFBSSxDQUFDMmIsR0FBTCxDQUFTeEQsTUFBTSxDQUFDL00sQ0FBQyxHQUFHLENBQUwsQ0FBTixHQUFnQjVFLENBQXpCLElBQThCLEtBUjlFO0FBQUEsTUFTSTRWLEtBVEo7QUFBQSxNQVVJQyxLQVZKO0FBQUEsTUFXSWhhLENBWEo7QUFBQSxNQVlJMnRCLEdBWko7QUFBQSxNQWFJQyxHQWJKO0FBQUEsTUFjSXBSLEVBZEo7QUFBQSxNQWVJQyxFQWZKO0FBQUEsTUFnQklvUixFQWhCSjtBQUFBLE1BaUJJQyxFQWpCSjtBQUFBLE1Ba0JJQyxHQWxCSjtBQUFBLE1BbUJJQyxHQW5CSjtBQUFBLE1Bb0JJQyxHQXBCSjtBQUFBLE1BcUJJQyxHQXJCSjtBQUFBLE1Bc0JJQyxHQXRCSjtBQUFBLE1BdUJJQyxHQXZCSjs7QUF5QkEsTUFBSWpDLE1BQUosRUFBWTtBQUNWO0FBQ0FyVyxJQUFBQSxNQUFNLENBQUNyVixJQUFQLENBQVlndEIsS0FBWixFQUFtQkMsS0FBbkI7QUFDQUQsSUFBQUEsS0FBSyxHQUFHdnBCLENBQVI7QUFDQXdwQixJQUFBQSxLQUFLLEdBQUd2cEIsQ0FBUjtBQUNBRCxJQUFBQSxDQUFDLEdBQUc0UixNQUFNLENBQUMvTSxDQUFDLEdBQUcsQ0FBTCxDQUFWO0FBQ0E1RSxJQUFBQSxDQUFDLEdBQUcyUixNQUFNLENBQUMvTSxDQUFDLEdBQUcsQ0FBTCxDQUFWO0FBQ0ErTSxJQUFBQSxNQUFNLENBQUN1WSxPQUFQLENBQWVucUIsQ0FBZixFQUFrQkMsQ0FBbEI7QUFDQTRFLElBQUFBLENBQUMsSUFBSSxDQUFMO0FBQ0Q7O0FBRUR3a0IsRUFBQUEsU0FBUyxHQUFHQSxTQUFTLElBQUlBLFNBQVMsS0FBSyxDQUEzQixHQUErQixDQUFDQSxTQUFoQyxHQUE0QyxDQUF4RDs7QUFFQSxPQUFLdnRCLENBQUMsR0FBRyxDQUFULEVBQVlBLENBQUMsR0FBRytJLENBQWhCLEVBQW1CL0ksQ0FBQyxJQUFJLENBQXhCLEVBQTJCO0FBQ3pCK1osSUFBQUEsS0FBSyxHQUFHN1YsQ0FBUjtBQUNBOFYsSUFBQUEsS0FBSyxHQUFHN1YsQ0FBUjtBQUNBRCxJQUFBQSxDQUFDLEdBQUd1cEIsS0FBSjtBQUNBdHBCLElBQUFBLENBQUMsR0FBR3VwQixLQUFKO0FBQ0FELElBQUFBLEtBQUssR0FBRyxDQUFDM1gsTUFBTSxDQUFDOVYsQ0FBQyxHQUFHLENBQUwsQ0FBZjtBQUNBMHRCLElBQUFBLEtBQUssR0FBRyxDQUFDNVgsTUFBTSxDQUFDOVYsQ0FBQyxHQUFHLENBQUwsQ0FBZjs7QUFFQSxRQUFJa0UsQ0FBQyxLQUFLdXBCLEtBQU4sSUFBZXRwQixDQUFDLEtBQUt1cEIsS0FBekIsRUFBZ0M7QUFDOUI7QUFDRDs7QUFFREMsSUFBQUEsR0FBRyxHQUFHdEUsR0FBTjtBQUNBdUUsSUFBQUEsR0FBRyxHQUFHdEUsR0FBTjtBQUNBRCxJQUFBQSxHQUFHLEdBQUdvRSxLQUFLLEdBQUd2cEIsQ0FBZDtBQUNBb2xCLElBQUFBLEdBQUcsR0FBR29FLEtBQUssR0FBR3ZwQixDQUFkO0FBQ0FxWSxJQUFBQSxFQUFFLEdBQUdrRCxLQUFLLENBQUNpTyxHQUFHLEdBQUdBLEdBQU4sR0FBWUMsR0FBRyxHQUFHQSxHQUFuQixDQUFWLENBaEJ5QixDQWdCVTs7QUFFbkNuUixJQUFBQSxFQUFFLEdBQUdpRCxLQUFLLENBQUMySixHQUFHLEdBQUdBLEdBQU4sR0FBWUMsR0FBRyxHQUFHQSxHQUFuQixDQUFWO0FBQ0F1RSxJQUFBQSxFQUFFLEdBQUduTyxLQUFLLENBQUMvaEIsSUFBSSxDQUFDMndCLEdBQUwsQ0FBU2pGLEdBQUcsR0FBRzVNLEVBQU4sR0FBV2tSLEdBQUcsR0FBR25SLEVBQTFCLEVBQThCLENBQTlCLElBQW1DN2UsSUFBSSxDQUFDMndCLEdBQUwsQ0FBU2hGLEdBQUcsR0FBRzdNLEVBQU4sR0FBV21SLEdBQUcsR0FBR3BSLEVBQTFCLEVBQThCLENBQTlCLENBQXBDLENBQVY7QUFDQXNSLElBQUFBLEVBQUUsR0FBRyxDQUFDdFIsRUFBRSxHQUFHQyxFQUFOLElBQVk4USxTQUFaLEdBQXdCLElBQXhCLEdBQStCTSxFQUFwQztBQUNBRSxJQUFBQSxHQUFHLEdBQUc3cEIsQ0FBQyxHQUFHLENBQUNBLENBQUMsR0FBRzZWLEtBQUwsS0FBZXlDLEVBQUUsR0FBR3NSLEVBQUUsR0FBR3RSLEVBQVIsR0FBYSxDQUE5QixDQUFWO0FBQ0F3UixJQUFBQSxHQUFHLEdBQUc5cEIsQ0FBQyxHQUFHLENBQUN1cEIsS0FBSyxHQUFHdnBCLENBQVQsS0FBZXVZLEVBQUUsR0FBR3FSLEVBQUUsR0FBR3JSLEVBQVIsR0FBYSxDQUE5QixDQUFWO0FBQ0F3UixJQUFBQSxHQUFHLEdBQUcvcEIsQ0FBQyxJQUFJNnBCLEdBQUcsSUFBSSxDQUFDQyxHQUFHLEdBQUdELEdBQVAsS0FBZXZSLEVBQUUsR0FBRyxDQUFMLElBQVVBLEVBQUUsR0FBR0MsRUFBZixJQUFxQixHQUFwQyxJQUEyQyxDQUEzQyxJQUFnRCxDQUFwRCxDQUFQLENBQVA7QUFDQXlSLElBQUFBLEdBQUcsR0FBRy9wQixDQUFDLEdBQUcsQ0FBQ0EsQ0FBQyxHQUFHNlYsS0FBTCxLQUFld0MsRUFBRSxHQUFHc1IsRUFBRSxHQUFHdFIsRUFBUixHQUFhLENBQTlCLENBQVY7QUFDQTJSLElBQUFBLEdBQUcsR0FBR2hxQixDQUFDLEdBQUcsQ0FBQ3VwQixLQUFLLEdBQUd2cEIsQ0FBVCxLQUFlc1ksRUFBRSxHQUFHcVIsRUFBRSxHQUFHclIsRUFBUixHQUFhLENBQTlCLENBQVY7QUFDQTJSLElBQUFBLEdBQUcsR0FBR2pxQixDQUFDLElBQUkrcEIsR0FBRyxJQUFJLENBQUNDLEdBQUcsR0FBR0QsR0FBUCxLQUFlMVIsRUFBRSxHQUFHLENBQUwsSUFBVUEsRUFBRSxHQUFHQyxFQUFmLElBQXFCLEdBQXBDLElBQTJDLENBQTNDLElBQWdELENBQXBELENBQVAsQ0FBUDs7QUFFQSxRQUFJdlksQ0FBQyxLQUFLNlYsS0FBTixJQUFlNVYsQ0FBQyxLQUFLNlYsS0FBekIsRUFBZ0M7QUFDOUIwRyxNQUFBQSxPQUFPLENBQUNqZ0IsSUFBUixDQUFhL0MsTUFBTSxDQUFDcXdCLEdBQUcsR0FBR0UsR0FBUCxDQUFuQixFQUFnQztBQUNoQ3Z3QixNQUFBQSxNQUFNLENBQUN3d0IsR0FBRyxHQUFHRSxHQUFQLENBRE4sRUFDbUIxd0IsTUFBTSxDQUFDd0csQ0FBRCxDQUR6QixFQUM4QjtBQUM5QnhHLE1BQUFBLE1BQU0sQ0FBQ3lHLENBQUQsQ0FGTixFQUVXekcsTUFBTSxDQUFDc3dCLEdBQUcsR0FBR0MsR0FBUCxDQUZqQixFQUU4QjtBQUM5QnZ3QixNQUFBQSxNQUFNLENBQUN5d0IsR0FBRyxHQUFHQyxHQUFQLENBSE47QUFJRDtBQUNGOztBQUVEbHFCLEVBQUFBLENBQUMsS0FBS3VwQixLQUFOLElBQWV0cEIsQ0FBQyxLQUFLdXBCLEtBQXJCLElBQThCaE4sT0FBTyxDQUFDemdCLE1BQVIsR0FBaUIsQ0FBL0MsR0FBbUR5Z0IsT0FBTyxDQUFDamdCLElBQVIsQ0FBYS9DLE1BQU0sQ0FBQyt2QixLQUFELENBQW5CLEVBQTRCL3ZCLE1BQU0sQ0FBQ2d3QixLQUFELENBQWxDLEVBQTJDaHdCLE1BQU0sQ0FBQyt2QixLQUFELENBQWpELEVBQTBEL3ZCLE1BQU0sQ0FBQ2d3QixLQUFELENBQWhFLENBQW5ELEdBQThIaE4sT0FBTyxDQUFDemdCLE1BQVIsSUFBa0IsQ0FBaEo7O0FBRUEsTUFBSXlnQixPQUFPLENBQUN6Z0IsTUFBUixLQUFtQixDQUF2QixFQUEwQjtBQUN4QjtBQUNBeWdCLElBQUFBLE9BQU8sQ0FBQ2pnQixJQUFSLENBQWF5RCxDQUFiLEVBQWdCQyxDQUFoQixFQUFtQkQsQ0FBbkIsRUFBc0JDLENBQXRCLEVBQXlCRCxDQUF6QixFQUE0QkMsQ0FBNUI7QUFDRCxHQUhELE1BR08sSUFBSWdvQixNQUFKLEVBQVk7QUFDakJ6TCxJQUFBQSxPQUFPLENBQUMzZixNQUFSLENBQWUsQ0FBZixFQUFrQixDQUFsQjtBQUNBMmYsSUFBQUEsT0FBTyxDQUFDemdCLE1BQVIsR0FBaUJ5Z0IsT0FBTyxDQUFDemdCLE1BQVIsR0FBaUIsQ0FBbEM7QUFDRDs7QUFFRCxTQUFPeWdCLE9BQVA7QUFDRCxFQUFDOztBQUVGLFNBQVM2TixjQUFULENBQXdCcnFCLENBQXhCLEVBQTJCQyxDQUEzQixFQUE4QjBnQixFQUE5QixFQUFrQ0MsRUFBbEMsRUFBc0NmLEVBQXRDLEVBQTBDSyxFQUExQyxFQUE4QztBQUM1QyxNQUFJL08sRUFBRSxHQUFHME8sRUFBRSxHQUFHYyxFQUFkO0FBQUEsTUFDSXZQLEVBQUUsR0FBRzhPLEVBQUUsR0FBR1UsRUFEZDtBQUFBLE1BRUlyRSxDQUZKOztBQUlBLE1BQUlwTCxFQUFFLElBQUlDLEVBQVYsRUFBYztBQUNabUwsSUFBQUEsQ0FBQyxHQUFHLENBQUMsQ0FBQ3ZjLENBQUMsR0FBRzJnQixFQUFMLElBQVd4UCxFQUFYLEdBQWdCLENBQUNsUixDQUFDLEdBQUcyZ0IsRUFBTCxJQUFXeFAsRUFBNUIsS0FBbUNELEVBQUUsR0FBR0EsRUFBTCxHQUFVQyxFQUFFLEdBQUdBLEVBQWxELENBQUo7O0FBRUEsUUFBSW1MLENBQUMsR0FBRyxDQUFSLEVBQVc7QUFDVG9FLE1BQUFBLEVBQUUsR0FBR2QsRUFBTDtBQUNBZSxNQUFBQSxFQUFFLEdBQUdWLEVBQUw7QUFDRCxLQUhELE1BR08sSUFBSTNELENBQUMsR0FBRyxDQUFSLEVBQVc7QUFDaEJvRSxNQUFBQSxFQUFFLElBQUl4UCxFQUFFLEdBQUdvTCxDQUFYO0FBQ0FxRSxNQUFBQSxFQUFFLElBQUl4UCxFQUFFLEdBQUdtTCxDQUFYO0FBQ0Q7QUFDRjs7QUFFRCxTQUFPOWlCLElBQUksQ0FBQzJ3QixHQUFMLENBQVNwcUIsQ0FBQyxHQUFHMmdCLEVBQWIsRUFBaUIsQ0FBakIsSUFBc0JsbkIsSUFBSSxDQUFDMndCLEdBQUwsQ0FBU25xQixDQUFDLEdBQUcyZ0IsRUFBYixFQUFpQixDQUFqQixDQUE3QjtBQUNEOztBQUVELFNBQVMwSixZQUFULENBQXNCMVksTUFBdEIsRUFBOEIyWSxLQUE5QixFQUFxQ0MsSUFBckMsRUFBMkNDLFNBQTNDLEVBQXNEQyxVQUF0RCxFQUFrRTtBQUNoRSxNQUFJQyxTQUFTLEdBQUdGLFNBQWhCO0FBQUEsTUFDSUcsTUFBTSxHQUFHaFosTUFBTSxDQUFDMlksS0FBRCxDQURuQjtBQUFBLE1BRUlNLE1BQU0sR0FBR2paLE1BQU0sQ0FBQzJZLEtBQUssR0FBRyxDQUFULENBRm5CO0FBQUEsTUFHSTVGLEtBQUssR0FBRy9TLE1BQU0sQ0FBQzRZLElBQUQsQ0FIbEI7QUFBQSxNQUlJNUYsS0FBSyxHQUFHaFQsTUFBTSxDQUFDNFksSUFBSSxHQUFHLENBQVIsQ0FKbEI7QUFBQSxNQUtJN00sS0FMSjtBQUFBLE1BTUk3aEIsQ0FOSjtBQUFBLE1BT0kwYSxDQVBKOztBQVNBLE9BQUsxYSxDQUFDLEdBQUd5dUIsS0FBSyxHQUFHLENBQWpCLEVBQW9CenVCLENBQUMsR0FBRzB1QixJQUF4QixFQUE4QjF1QixDQUFDLElBQUksQ0FBbkMsRUFBc0M7QUFDcEMwYSxJQUFBQSxDQUFDLEdBQUc2VCxjQUFjLENBQUN6WSxNQUFNLENBQUM5VixDQUFELENBQVAsRUFBWThWLE1BQU0sQ0FBQzlWLENBQUMsR0FBRyxDQUFMLENBQWxCLEVBQTJCOHVCLE1BQTNCLEVBQW1DQyxNQUFuQyxFQUEyQ2xHLEtBQTNDLEVBQWtEQyxLQUFsRCxDQUFsQjs7QUFFQSxRQUFJcE8sQ0FBQyxHQUFHbVUsU0FBUixFQUFtQjtBQUNqQmhOLE1BQUFBLEtBQUssR0FBRzdoQixDQUFSO0FBQ0E2dUIsTUFBQUEsU0FBUyxHQUFHblUsQ0FBWjtBQUNEO0FBQ0Y7O0FBRUQsTUFBSW1VLFNBQVMsR0FBR0YsU0FBaEIsRUFBMkI7QUFDekI5TSxJQUFBQSxLQUFLLEdBQUc0TSxLQUFSLEdBQWdCLENBQWhCLElBQXFCRCxZQUFZLENBQUMxWSxNQUFELEVBQVMyWSxLQUFULEVBQWdCNU0sS0FBaEIsRUFBdUI4TSxTQUF2QixFQUFrQ0MsVUFBbEMsQ0FBakM7QUFDQUEsSUFBQUEsVUFBVSxDQUFDbnVCLElBQVgsQ0FBZ0JxVixNQUFNLENBQUMrTCxLQUFELENBQXRCLEVBQStCL0wsTUFBTSxDQUFDK0wsS0FBSyxHQUFHLENBQVQsQ0FBckM7QUFDQTZNLElBQUFBLElBQUksR0FBRzdNLEtBQVAsR0FBZSxDQUFmLElBQW9CMk0sWUFBWSxDQUFDMVksTUFBRCxFQUFTK0wsS0FBVCxFQUFnQjZNLElBQWhCLEVBQXNCQyxTQUF0QixFQUFpQ0MsVUFBakMsQ0FBaEM7QUFDRDtBQUNGLEVBQUM7OztBQUdLLFNBQVNJLGNBQVQsQ0FBd0JsWixNQUF4QixFQUFnQzZZLFNBQWhDLEVBQTJDO0FBQ2hELE1BQUk1VSxLQUFLLEdBQUczUixVQUFVLENBQUMwTixNQUFNLENBQUMsQ0FBRCxDQUFQLENBQXRCO0FBQUEsTUFDSWtFLEtBQUssR0FBRzVSLFVBQVUsQ0FBQzBOLE1BQU0sQ0FBQyxDQUFELENBQVAsQ0FEdEI7QUFBQSxNQUVJeUUsSUFBSSxHQUFHLENBQUNSLEtBQUQsRUFBUUMsS0FBUixDQUZYO0FBQUEsTUFHSWpSLENBQUMsR0FBRytNLE1BQU0sQ0FBQzdWLE1BQVAsR0FBZ0IsQ0FIeEI7QUFBQSxNQUlJRCxDQUpKO0FBQUEsTUFLSWtFLENBTEo7QUFBQSxNQU1JQyxDQU5KO0FBQUEsTUFPSWtSLEVBUEo7QUFBQSxNQVFJQyxFQVJKO0FBQUEsTUFTSWpQLE1BVEo7QUFBQSxNQVVJcW9CLElBVko7QUFXQUMsRUFBQUEsU0FBUyxHQUFHaHhCLElBQUksQ0FBQzJ3QixHQUFMLENBQVNLLFNBQVMsSUFBSSxDQUF0QixFQUF5QixDQUF6QixDQUFaOztBQUVBLE9BQUszdUIsQ0FBQyxHQUFHLENBQVQsRUFBWUEsQ0FBQyxHQUFHK0ksQ0FBaEIsRUFBbUIvSSxDQUFDLElBQUksQ0FBeEIsRUFBMkI7QUFDekJrRSxJQUFBQSxDQUFDLEdBQUdrRSxVQUFVLENBQUMwTixNQUFNLENBQUM5VixDQUFELENBQVAsQ0FBZDtBQUNBbUUsSUFBQUEsQ0FBQyxHQUFHaUUsVUFBVSxDQUFDME4sTUFBTSxDQUFDOVYsQ0FBQyxHQUFHLENBQUwsQ0FBUCxDQUFkO0FBQ0FxVixJQUFBQSxFQUFFLEdBQUcwRSxLQUFLLEdBQUc3VixDQUFiO0FBQ0FvUixJQUFBQSxFQUFFLEdBQUcwRSxLQUFLLEdBQUc3VixDQUFiOztBQUVBLFFBQUlrUixFQUFFLEdBQUdBLEVBQUwsR0FBVUMsRUFBRSxHQUFHQSxFQUFmLEdBQW9CcVosU0FBeEIsRUFBbUM7QUFDakNwVSxNQUFBQSxJQUFJLENBQUM5WixJQUFMLENBQVV5RCxDQUFWLEVBQWFDLENBQWI7QUFDQTRWLE1BQUFBLEtBQUssR0FBRzdWLENBQVI7QUFDQThWLE1BQUFBLEtBQUssR0FBRzdWLENBQVI7QUFDRDtBQUNGOztBQUVEb1csRUFBQUEsSUFBSSxDQUFDOVosSUFBTCxDQUFVMkgsVUFBVSxDQUFDME4sTUFBTSxDQUFDL00sQ0FBRCxDQUFQLENBQXBCLEVBQWlDWCxVQUFVLENBQUMwTixNQUFNLENBQUMvTSxDQUFDLEdBQUcsQ0FBTCxDQUFQLENBQTNDO0FBQ0EybEIsRUFBQUEsSUFBSSxHQUFHblUsSUFBSSxDQUFDdGEsTUFBTCxHQUFjLENBQXJCO0FBQ0FvRyxFQUFBQSxNQUFNLEdBQUcsQ0FBQ2tVLElBQUksQ0FBQyxDQUFELENBQUwsRUFBVUEsSUFBSSxDQUFDLENBQUQsQ0FBZCxDQUFUO0FBQ0FpVSxFQUFBQSxZQUFZLENBQUNqVSxJQUFELEVBQU8sQ0FBUCxFQUFVbVUsSUFBVixFQUFnQkMsU0FBaEIsRUFBMkJ0b0IsTUFBM0IsQ0FBWjtBQUNBQSxFQUFBQSxNQUFNLENBQUM1RixJQUFQLENBQVk4WixJQUFJLENBQUNtVSxJQUFELENBQWhCLEVBQXdCblUsSUFBSSxDQUFDbVUsSUFBSSxHQUFHLENBQVIsQ0FBNUI7QUFDQSxTQUFPcm9CLE1BQVA7QUFDRDs7QUFFRCxTQUFTNG9CLDBCQUFULENBQW9DQyxVQUFwQyxFQUFnREMsRUFBaEQsRUFBb0RDLEVBQXBELEVBQXdEL1gsS0FBeEQsRUFBK0RyTyxHQUEvRCxFQUFvRXFtQixNQUFwRSxFQUE0RUMsRUFBNUUsRUFBZ0ZDLEVBQWhGLEVBQW9GMUssRUFBcEYsRUFBd0ZDLEVBQXhGLEVBQTRGZixFQUE1RixFQUFnR0ssRUFBaEcsRUFBb0dKLEVBQXBHLEVBQXdHSyxFQUF4RyxFQUE0RztBQUMxRyxNQUFJd0MsR0FBRyxHQUFHLENBQUM3ZCxHQUFHLEdBQUdxTyxLQUFQLElBQWdCZ1ksTUFBMUI7QUFBQSxNQUNJRyxJQUFJLEdBQUcsQ0FEWDtBQUFBLE1BRUkvTyxDQUFDLEdBQUdwSixLQUZSO0FBQUEsTUFHSW5ULENBSEo7QUFBQSxNQUlJQyxDQUpKO0FBQUEsTUFLSXVXLENBTEo7QUFBQSxNQU1JckYsRUFOSjtBQUFBLE1BT0lDLEVBUEo7QUFBQSxNQVFJK1IsR0FSSjtBQVNBckYsRUFBQUEsYUFBYSxHQUFHbkMsU0FBaEI7O0FBRUEsU0FBT1ksQ0FBQyxJQUFJelgsR0FBWixFQUFpQjtBQUNmcWUsSUFBQUEsR0FBRyxHQUFHLElBQUk1RyxDQUFWO0FBQ0F2YyxJQUFBQSxDQUFDLEdBQUdtakIsR0FBRyxHQUFHQSxHQUFOLEdBQVlBLEdBQVosR0FBa0JpSSxFQUFsQixHQUF1QixJQUFJakksR0FBSixHQUFVQSxHQUFWLEdBQWdCNUcsQ0FBaEIsR0FBb0JvRSxFQUEzQyxHQUFnRCxJQUFJd0MsR0FBSixHQUFVNUcsQ0FBVixHQUFjQSxDQUFkLEdBQWtCc0QsRUFBbEUsR0FBdUV0RCxDQUFDLEdBQUdBLENBQUosR0FBUUEsQ0FBUixHQUFZdUQsRUFBdkY7QUFDQTdmLElBQUFBLENBQUMsR0FBR2tqQixHQUFHLEdBQUdBLEdBQU4sR0FBWUEsR0FBWixHQUFrQmtJLEVBQWxCLEdBQXVCLElBQUlsSSxHQUFKLEdBQVVBLEdBQVYsR0FBZ0I1RyxDQUFoQixHQUFvQnFFLEVBQTNDLEdBQWdELElBQUl1QyxHQUFKLEdBQVU1RyxDQUFWLEdBQWNBLENBQWQsR0FBa0IyRCxFQUFsRSxHQUF1RTNELENBQUMsR0FBR0EsQ0FBSixHQUFRQSxDQUFSLEdBQVk0RCxFQUF2RjtBQUNBaFAsSUFBQUEsRUFBRSxHQUFHblIsQ0FBQyxHQUFHaXJCLEVBQVQ7QUFDQTdaLElBQUFBLEVBQUUsR0FBR25SLENBQUMsR0FBR2lyQixFQUFUO0FBQ0ExVSxJQUFBQSxDQUFDLEdBQUdyRixFQUFFLEdBQUdBLEVBQUwsR0FBVUMsRUFBRSxHQUFHQSxFQUFuQjs7QUFFQSxRQUFJb0YsQ0FBQyxHQUFHc0gsYUFBUixFQUF1QjtBQUNyQkEsTUFBQUEsYUFBYSxHQUFHdEgsQ0FBaEI7QUFDQThVLE1BQUFBLElBQUksR0FBRy9PLENBQVA7QUFDRDs7QUFFREEsSUFBQUEsQ0FBQyxJQUFJb0csR0FBTDtBQUNEOztBQUVELFNBQU9xSSxVQUFVLEdBQUcsQ0FBYixHQUFpQkQsMEJBQTBCLENBQUNDLFVBQVUsR0FBRyxDQUFkLEVBQWlCQyxFQUFqQixFQUFxQkMsRUFBckIsRUFBeUJ6eEIsSUFBSSxDQUFDb0csR0FBTCxDQUFTeXJCLElBQUksR0FBRzNJLEdBQWhCLEVBQXFCLENBQXJCLENBQXpCLEVBQWtEbHBCLElBQUksQ0FBQ2tKLEdBQUwsQ0FBUzJvQixJQUFJLEdBQUczSSxHQUFoQixFQUFxQixDQUFyQixDQUFsRCxFQUEyRXdJLE1BQTNFLEVBQW1GQyxFQUFuRixFQUF1RkMsRUFBdkYsRUFBMkYxSyxFQUEzRixFQUErRkMsRUFBL0YsRUFBbUdmLEVBQW5HLEVBQXVHSyxFQUF2RyxFQUEyR0osRUFBM0csRUFBK0dLLEVBQS9HLENBQTNDLEdBQWdLbUwsSUFBdks7QUFDRDs7QUFFTSxTQUFTQyxjQUFULENBQXdCbFAsT0FBeEIsRUFBaUNyYyxDQUFqQyxFQUFvQ0MsQ0FBcEMsRUFBdUNrckIsTUFBdkMsRUFBK0M7QUFDcEQ7QUFDQSxNQUFJcmEsT0FBTyxHQUFHO0FBQ1p3UixJQUFBQSxDQUFDLEVBQUUsQ0FEUztBQUVaeG1CLElBQUFBLENBQUMsRUFBRSxDQUZTO0FBR1p5Z0IsSUFBQUEsQ0FBQyxFQUFFO0FBSFMsR0FBZDtBQUFBLE1BS0lpUCxZQUFZLEdBQUc3UCxTQUxuQjtBQUFBLE1BTUk3ZixDQU5KO0FBQUEsTUFPSXdtQixDQVBKO0FBQUEsTUFRSS9GLENBUko7QUFBQSxNQVNJQyxPQVRKOztBQVdBLE9BQUs4RixDQUFDLEdBQUcsQ0FBVCxFQUFZQSxDQUFDLEdBQUdqRyxPQUFPLENBQUN0Z0IsTUFBeEIsRUFBZ0N1bUIsQ0FBQyxFQUFqQyxFQUFxQztBQUNuQzlGLElBQUFBLE9BQU8sR0FBR0gsT0FBTyxDQUFDaUcsQ0FBRCxDQUFqQjs7QUFFQSxTQUFLeG1CLENBQUMsR0FBRyxDQUFULEVBQVlBLENBQUMsR0FBRzBnQixPQUFPLENBQUN6Z0IsTUFBeEIsRUFBZ0NELENBQUMsSUFBSSxDQUFyQyxFQUF3QztBQUN0Q3lnQixNQUFBQSxDQUFDLEdBQUd3TywwQkFBMEIsQ0FBQyxDQUFELEVBQUkvcUIsQ0FBSixFQUFPQyxDQUFQLEVBQVUsQ0FBVixFQUFhLENBQWIsRUFBZ0JrckIsTUFBTSxJQUFJLEVBQTFCLEVBQThCM08sT0FBTyxDQUFDMWdCLENBQUQsQ0FBckMsRUFBMEMwZ0IsT0FBTyxDQUFDMWdCLENBQUMsR0FBRyxDQUFMLENBQWpELEVBQTBEMGdCLE9BQU8sQ0FBQzFnQixDQUFDLEdBQUcsQ0FBTCxDQUFqRSxFQUEwRTBnQixPQUFPLENBQUMxZ0IsQ0FBQyxHQUFHLENBQUwsQ0FBakYsRUFBMEYwZ0IsT0FBTyxDQUFDMWdCLENBQUMsR0FBRyxDQUFMLENBQWpHLEVBQTBHMGdCLE9BQU8sQ0FBQzFnQixDQUFDLEdBQUcsQ0FBTCxDQUFqSCxFQUEwSDBnQixPQUFPLENBQUMxZ0IsQ0FBQyxHQUFHLENBQUwsQ0FBakksRUFBMEkwZ0IsT0FBTyxDQUFDMWdCLENBQUMsR0FBRyxDQUFMLENBQWpKLENBQTlCOztBQUVBLFVBQUkwdkIsWUFBWSxHQUFHMU4sYUFBbkIsRUFBa0M7QUFDaEMwTixRQUFBQSxZQUFZLEdBQUcxTixhQUFmO0FBQ0FoTixRQUFBQSxPQUFPLENBQUN3UixDQUFSLEdBQVlBLENBQVo7QUFDQXhSLFFBQUFBLE9BQU8sQ0FBQ2hWLENBQVIsR0FBWUEsQ0FBWjtBQUNBZ1YsUUFBQUEsT0FBTyxDQUFDeUwsQ0FBUixHQUFZQSxDQUFaO0FBQ0Q7QUFDRjtBQUNGOztBQUVELFNBQU96TCxPQUFQO0FBQ0QsRUFBQzs7QUFFSyxTQUFTMmEsb0JBQVQsQ0FBOEJ6ckIsQ0FBOUIsRUFBaUNDLENBQWpDLEVBQW9DdWMsT0FBcEMsRUFBNkMyTyxNQUE3QyxFQUFxREgsVUFBckQsRUFBaUU7QUFDdEUsTUFBSW5tQixDQUFDLEdBQUcyWCxPQUFPLENBQUN6Z0IsTUFBaEI7QUFBQSxNQUNJeXZCLFlBQVksR0FBRzdQLFNBRG5CO0FBQUEsTUFFSStQLEtBQUssR0FBRyxDQUZaO0FBQUEsTUFHSUMsZ0JBQWdCLEdBQUcsQ0FIdkI7QUFBQSxNQUlJcFAsQ0FKSjtBQUFBLE1BS0l6Z0IsQ0FMSjtBQU1BcXZCLEVBQUFBLE1BQU0sR0FBR0EsTUFBTSxJQUFJLEVBQW5CO0FBQ0FILEVBQUFBLFVBQVUsR0FBR0EsVUFBVSxJQUFJLENBQTNCOztBQUVBLE9BQUtsdkIsQ0FBQyxHQUFHLENBQVQsRUFBWUEsQ0FBQyxHQUFHK0ksQ0FBaEIsRUFBbUIvSSxDQUFDLElBQUksQ0FBeEIsRUFBMkI7QUFDekJ5Z0IsSUFBQUEsQ0FBQyxHQUFHd08sMEJBQTBCLENBQUMsQ0FBRCxFQUFJL3FCLENBQUosRUFBT0MsQ0FBUCxFQUFVLENBQVYsRUFBYSxDQUFiLEVBQWdCa3JCLE1BQWhCLEVBQXdCM08sT0FBTyxDQUFDMWdCLENBQUQsQ0FBL0IsRUFBb0MwZ0IsT0FBTyxDQUFDMWdCLENBQUMsR0FBRyxDQUFMLENBQTNDLEVBQW9EMGdCLE9BQU8sQ0FBQzFnQixDQUFDLEdBQUcsQ0FBTCxDQUEzRCxFQUFvRTBnQixPQUFPLENBQUMxZ0IsQ0FBQyxHQUFHLENBQUwsQ0FBM0UsRUFBb0YwZ0IsT0FBTyxDQUFDMWdCLENBQUMsR0FBRyxDQUFMLENBQTNGLEVBQW9HMGdCLE9BQU8sQ0FBQzFnQixDQUFDLEdBQUcsQ0FBTCxDQUEzRyxFQUFvSDBnQixPQUFPLENBQUMxZ0IsQ0FBQyxHQUFHLENBQUwsQ0FBM0gsRUFBb0kwZ0IsT0FBTyxDQUFDMWdCLENBQUMsR0FBRyxDQUFMLENBQTNJLENBQTlCOztBQUVBLFFBQUkwdkIsWUFBWSxHQUFHMU4sYUFBbkIsRUFBa0M7QUFDaEMwTixNQUFBQSxZQUFZLEdBQUcxTixhQUFmO0FBQ0E0TixNQUFBQSxLQUFLLEdBQUduUCxDQUFSO0FBQ0FvUCxNQUFBQSxnQkFBZ0IsR0FBRzd2QixDQUFuQjtBQUNEO0FBQ0Y7O0FBRUR5Z0IsRUFBQUEsQ0FBQyxHQUFHd08sMEJBQTBCLENBQUNDLFVBQUQsRUFBYWhyQixDQUFiLEVBQWdCQyxDQUFoQixFQUFtQnlyQixLQUFLLEdBQUcsSUFBM0IsRUFBaUNBLEtBQUssR0FBRyxJQUF6QyxFQUErQ1AsTUFBL0MsRUFBdUQzTyxPQUFPLENBQUNtUCxnQkFBRCxDQUE5RCxFQUFrRm5QLE9BQU8sQ0FBQ21QLGdCQUFnQixHQUFHLENBQXBCLENBQXpGLEVBQWlIblAsT0FBTyxDQUFDbVAsZ0JBQWdCLEdBQUcsQ0FBcEIsQ0FBeEgsRUFBZ0puUCxPQUFPLENBQUNtUCxnQkFBZ0IsR0FBRyxDQUFwQixDQUF2SixFQUErS25QLE9BQU8sQ0FBQ21QLGdCQUFnQixHQUFHLENBQXBCLENBQXRMLEVBQThNblAsT0FBTyxDQUFDbVAsZ0JBQWdCLEdBQUcsQ0FBcEIsQ0FBck4sRUFBNk9uUCxPQUFPLENBQUNtUCxnQkFBZ0IsR0FBRyxDQUFwQixDQUFwUCxFQUE0UW5QLE9BQU8sQ0FBQ21QLGdCQUFnQixHQUFHLENBQXBCLENBQW5SLENBQTlCO0FBQ0FqUCxFQUFBQSxnQkFBZ0IsQ0FBQ0YsT0FBRCxFQUFVbVAsZ0JBQVYsRUFBNEJwUCxDQUE1QixDQUFoQjtBQUNBLFNBQU9vUCxnQkFBZ0IsR0FBRyxDQUExQjtBQUNEO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTyxTQUFTNUssZUFBVCxDQUF5QjFFLE9BQXpCLEVBQWtDO0FBQ3ZDLE1BQUlSLFNBQVMsQ0FBQ1EsT0FBTyxDQUFDLENBQUQsQ0FBUixDQUFiLEVBQTJCO0FBQ3pCO0FBQ0FBLElBQUFBLE9BQU8sR0FBRyxDQUFDQSxPQUFELENBQVY7QUFDRDs7QUFFRCxNQUFJbGEsTUFBTSxHQUFHLEVBQWI7QUFBQSxNQUNJMEMsQ0FBQyxHQUFHd1gsT0FBTyxDQUFDdGdCLE1BRGhCO0FBQUEsTUFFSTZ2QixFQUZKO0FBQUEsTUFHSW5LLENBSEo7QUFBQSxNQUlJM2xCLENBSko7QUFBQSxNQUtJMGdCLE9BTEo7O0FBT0EsT0FBS2lGLENBQUMsR0FBRyxDQUFULEVBQVlBLENBQUMsR0FBRzVjLENBQWhCLEVBQW1CNGMsQ0FBQyxFQUFwQixFQUF3QjtBQUN0QmpGLElBQUFBLE9BQU8sR0FBR0gsT0FBTyxDQUFDb0YsQ0FBRCxDQUFqQjtBQUNBdGYsSUFBQUEsTUFBTSxJQUFJLE1BQU0zSSxNQUFNLENBQUNnakIsT0FBTyxDQUFDLENBQUQsQ0FBUixDQUFaLEdBQTJCLEdBQTNCLEdBQWlDaGpCLE1BQU0sQ0FBQ2dqQixPQUFPLENBQUMsQ0FBRCxDQUFSLENBQXZDLEdBQXNELElBQWhFO0FBQ0FvUCxJQUFBQSxFQUFFLEdBQUdwUCxPQUFPLENBQUN6Z0IsTUFBYjs7QUFFQSxTQUFLRCxDQUFDLEdBQUcsQ0FBVCxFQUFZQSxDQUFDLEdBQUc4dkIsRUFBaEIsRUFBb0I5dkIsQ0FBQyxFQUFyQixFQUF5QjtBQUN2QnFHLE1BQUFBLE1BQU0sSUFBSTNJLE1BQU0sQ0FBQ2dqQixPQUFPLENBQUMxZ0IsQ0FBQyxFQUFGLENBQVIsQ0FBTixHQUF1QixHQUF2QixHQUE2QnRDLE1BQU0sQ0FBQ2dqQixPQUFPLENBQUMxZ0IsQ0FBQyxFQUFGLENBQVIsQ0FBbkMsR0FBb0QsR0FBcEQsR0FBMER0QyxNQUFNLENBQUNnakIsT0FBTyxDQUFDMWdCLENBQUMsRUFBRixDQUFSLENBQWhFLEdBQWlGLEdBQWpGLEdBQXVGdEMsTUFBTSxDQUFDZ2pCLE9BQU8sQ0FBQzFnQixDQUFDLEVBQUYsQ0FBUixDQUE3RixHQUE4RyxHQUE5RyxHQUFvSHRDLE1BQU0sQ0FBQ2dqQixPQUFPLENBQUMxZ0IsQ0FBQyxFQUFGLENBQVIsQ0FBMUgsR0FBMkksR0FBM0ksR0FBaUp0QyxNQUFNLENBQUNnakIsT0FBTyxDQUFDMWdCLENBQUQsQ0FBUixDQUF2SixHQUFzSyxHQUFoTDtBQUNEOztBQUVELFFBQUkwZ0IsT0FBTyxDQUFDeUwsTUFBWixFQUFvQjtBQUNsQjlsQixNQUFBQSxNQUFNLElBQUksR0FBVjtBQUNEO0FBQ0Y7O0FBRUQsU0FBT0EsTUFBUDtBQUNEO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUM1OENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsSUFBSTJwQixPQUFPLEdBQUcsd0NBQXdDNWhCLEtBQXhDLENBQThDLEdBQTlDLENBQWQ7QUFBQSxJQUNJNmhCLE9BQU8sR0FBRyxzQ0FBc0M3aEIsS0FBdEMsQ0FBNEMsR0FBNUMsQ0FEZDtBQUFBLElBRUlnUix3QkFBUSxHQUFHemhCLElBQUksQ0FBQ2MsRUFBTCxHQUFVLEdBRnpCO0FBQUEsSUFHSTdDLElBSEo7QUFBQSxJQUlJczBCLFNBSko7QUFBQSxJQUtJQyxRQUxKO0FBQUEsSUFNSTl6QixRQU5KO0FBQUEsSUFPSVksUUFBUSxHQUFHLFNBQVNBLFFBQVQsR0FBb0I7QUFDakMsU0FBT3JCLElBQUksSUFBSSxPQUFPb0IsTUFBUCxLQUFrQixXQUFsQixLQUFrQ3BCLElBQUksR0FBR29CLE1BQU0sQ0FBQ3BCLElBQWhELEtBQXlEQSxJQUFJLENBQUNzQixjQUE5RCxJQUFnRnRCLElBQS9GO0FBQ0QsQ0FURDtBQUFBLElBVUl3MEIseUJBQXlCLEdBQUcsU0FBU0EseUJBQVQsQ0FBbUMxUCxPQUFuQyxFQUE0QzJQLE1BQTVDLEVBQW9ENXJCLFFBQXBELEVBQThEd1ksSUFBOUQsRUFBb0U7QUFDbEc7QUFDQSxNQUFJbFUsQ0FBQyxHQUFHc25CLE1BQU0sQ0FBQ3B3QixNQUFmO0FBQUEsTUFDSWdtQixFQUFFLEdBQUdoSixJQUFJLEtBQUssQ0FBVCxHQUFhLENBQWIsR0FBaUJBLElBRDFCO0FBQUEsTUFFSWpkLENBQUMsR0FBRyxDQUZSO0FBQUEsTUFHSXN3QixDQUhKOztBQUtBLFNBQU90d0IsQ0FBQyxHQUFHK0ksQ0FBWCxFQUFjL0ksQ0FBQyxFQUFmLEVBQW1CO0FBQ2pCMGdCLElBQUFBLE9BQU8sQ0FBQ3VGLEVBQUQsQ0FBUCxHQUFjcUssQ0FBQyxHQUFHbG9CLFVBQVUsQ0FBQ2lvQixNQUFNLENBQUNyd0IsQ0FBRCxDQUFOLENBQVV5RSxRQUFWLENBQUQsQ0FBNUI7QUFDQXdZLElBQUFBLElBQUksS0FBSyxDQUFULEtBQWV5RCxPQUFPLENBQUN1RixFQUFFLEdBQUcsQ0FBTixDQUFQLEdBQWtCLENBQWpDO0FBQ0FBLElBQUFBLEVBQUUsSUFBSSxDQUFOO0FBQ0Q7O0FBRUQsU0FBT3ZGLE9BQVA7QUFDRCxDQXhCRDtBQUFBLElBeUJJNlAsV0FBVyxHQUFHLFNBQVNBLFdBQVQsQ0FBcUI5dEIsTUFBckIsRUFBNkIrdEIsSUFBN0IsRUFBbUNoZixJQUFuQyxFQUF5QztBQUN6RCxTQUFPcEosVUFBVSxDQUFDM0YsTUFBTSxDQUFDME8sS0FBUCxDQUFhNUMsR0FBYixDQUFpQjlMLE1BQWpCLEVBQXlCK3RCLElBQXpCLEVBQStCaGYsSUFBSSxJQUFJLElBQXZDLENBQUQsQ0FBVixJQUE0RCxDQUFuRTtBQUNELENBM0JEO0FBQUEsSUE0QklpZixXQUFXLEdBQUcsU0FBU0EsV0FBVCxDQUFxQi9QLE9BQXJCLEVBQThCO0FBQzlDLE1BQUl4YyxDQUFDLEdBQUd3YyxPQUFPLENBQUMsQ0FBRCxDQUFmO0FBQUEsTUFDSXZjLENBQUMsR0FBR3VjLE9BQU8sQ0FBQyxDQUFELENBRGY7QUFBQSxNQUVJMWdCLENBRko7O0FBSUEsT0FBS0EsQ0FBQyxHQUFHLENBQVQsRUFBWUEsQ0FBQyxHQUFHMGdCLE9BQU8sQ0FBQ3pnQixNQUF4QixFQUFnQ0QsQ0FBQyxJQUFJLENBQXJDLEVBQXdDO0FBQ3RDa0UsSUFBQUEsQ0FBQyxHQUFHd2MsT0FBTyxDQUFDMWdCLENBQUQsQ0FBUCxJQUFja0UsQ0FBbEI7QUFDQUMsSUFBQUEsQ0FBQyxHQUFHdWMsT0FBTyxDQUFDMWdCLENBQUMsR0FBRyxDQUFMLENBQVAsSUFBa0JtRSxDQUF0QjtBQUNEO0FBQ0YsQ0FyQ0Q7QUFBQSxJQXNDSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQXVzQixpQkFBaUIsR0FBRyxTQUFTQSxpQkFBVCxDQUEyQkMsTUFBM0IsRUFBbUNqUSxPQUFuQyxFQUE0Q2plLE1BQTVDLEVBQW9EeUIsQ0FBcEQsRUFBdURDLENBQXZELEVBQTBEeXNCLE1BQTFELEVBQWtFMXFCLElBQWxFLEVBQXdFMnFCLEtBQXhFLEVBQStFQyxLQUEvRSxFQUFzRjtBQUN4RyxNQUFJNXFCLElBQUksQ0FBQ2pJLElBQUwsS0FBYyxPQUFsQixFQUEyQjtBQUN6QnlpQixJQUFBQSxPQUFPLEdBQUcsQ0FBQ0EsT0FBRCxDQUFWO0FBQ0QsR0FGRCxNQUVPO0FBQ0x4YSxJQUFBQSxJQUFJLENBQUM2cUIsV0FBTCxLQUFxQixLQUFyQixJQUE4QnJRLE9BQU8sQ0FBQzJOLE9BQVIsQ0FBZ0JrQyxXQUFXLENBQUM5dEIsTUFBRCxFQUFTeUIsQ0FBVCxFQUFZMnNCLEtBQVosQ0FBM0IsRUFBK0Mxc0IsQ0FBQyxHQUFHb3NCLFdBQVcsQ0FBQzl0QixNQUFELEVBQVMwQixDQUFULEVBQVkyc0IsS0FBWixDQUFkLEdBQW1DLENBQW5GLENBQTlCO0FBQ0E1cUIsSUFBQUEsSUFBSSxDQUFDOHFCLFFBQUwsSUFBaUJQLFdBQVcsQ0FBQy9QLE9BQUQsQ0FBNUI7QUFDQSxRQUFJdVEsU0FBUyxHQUFHOXNCLENBQUMsR0FBR3FwQixlQUFILEdBQXFCRixtQkFBdEM7QUFDQTVNLElBQUFBLE9BQU8sR0FBRyxDQUFDdVEsU0FBUyxDQUFDdlEsT0FBRCxFQUFVeGEsSUFBSSxDQUFDcW5CLFNBQWYsQ0FBVixDQUFWO0FBQ0Q7O0FBRUQ3TSxFQUFBQSxPQUFPLEdBQUdrUSxNQUFNLENBQUNNLE1BQU0sQ0FBQ3hRLE9BQUQsRUFBVWplLE1BQVYsRUFBa0J5RCxJQUFsQixDQUFQLENBQWhCOztBQUVBaXJCLEVBQUFBLHdCQUF3QixDQUFDUixNQUFELEVBQVNsdUIsTUFBVCxFQUFpQnlCLENBQWpCLEVBQW9Cd2MsT0FBcEIsRUFBNkIsR0FBN0IsRUFBa0NtUSxLQUFsQyxDQUF4Qjs7QUFFQTFzQixFQUFBQSxDQUFDLElBQUlndEIsd0JBQXdCLENBQUNSLE1BQUQsRUFBU2x1QixNQUFULEVBQWlCMEIsQ0FBakIsRUFBb0J1YyxPQUFwQixFQUE2QixHQUE3QixFQUFrQ29RLEtBQWxDLENBQTdCO0FBQ0EsU0FBT3JMLHdCQUF3QixDQUFDL0UsT0FBRCxFQUFVeGEsSUFBSSxDQUFDd2IsVUFBTCxLQUFvQnhiLElBQUksQ0FBQ3FuQixTQUFMLEtBQW1CLENBQW5CLEdBQXVCLEVBQXZCLEdBQTRCLEVBQWhELENBQVYsQ0FBL0IsQ0Fmd0csQ0FlVDtBQUNoRyxDQXJFRDtBQUFBLElBc0VJaHdCLFVBQVUsR0FBRyxTQUFTQSxVQUFULENBQW9CK3lCLENBQXBCLEVBQXVCO0FBQ3RDLFNBQU9BLENBQVA7QUFDRCxDQXhFRDtBQUFBLElBeUVJYyxPQUFPLEdBQUcsOEJBekVkO0FBQUEsSUEwRUlDLGNBQWMsR0FBRyxTQUFTQSxjQUFULENBQXdCN3ZCLE9BQXhCLEVBQWlDOHZCLE1BQWpDLEVBQXlDQyxZQUF6QyxFQUF1RDtBQUMxRTtBQUNBLE1BQUk5VCxDQUFDLEdBQUcvaEIsa0NBQWUsQ0FBQzhGLE9BQUQsQ0FBdkI7QUFBQSxNQUNJMEMsQ0FBQyxHQUFHLENBRFI7QUFBQSxNQUVJQyxDQUFDLEdBQUcsQ0FGUjtBQUFBLE1BR0lxdEIsR0FISjs7QUFLQSxNQUFJLENBQUNod0IsT0FBTyxDQUFDZ2lCLE9BQVIsR0FBa0IsRUFBbkIsRUFBdUI5ZSxXQUF2QixPQUF5QyxLQUE3QyxFQUFvRDtBQUNsRDhzQixJQUFBQSxHQUFHLEdBQUdod0IsT0FBTyxDQUFDeUcsT0FBUixDQUFnQkMsT0FBdEI7QUFDQXNwQixJQUFBQSxHQUFHLENBQUNyc0IsS0FBSixLQUFjcXNCLEdBQUcsR0FBRztBQUNsQnJzQixNQUFBQSxLQUFLLEVBQUUsQ0FBQzNELE9BQU8sQ0FBQzRILFlBQVIsQ0FBcUIsT0FBckIsQ0FEVTtBQUVsQjdELE1BQUFBLE1BQU0sRUFBRSxDQUFDL0QsT0FBTyxDQUFDNEgsWUFBUixDQUFxQixRQUFyQjtBQUZTLEtBQXBCO0FBSUQsR0FORCxNQU1PO0FBQ0xvb0IsSUFBQUEsR0FBRyxHQUFHRixNQUFNLElBQUk5dkIsT0FBTyxDQUFDK0YsT0FBbEIsSUFBNkIvRixPQUFPLENBQUMrRixPQUFSLEVBQW5DO0FBQ0Q7O0FBRUQsTUFBSStwQixNQUFNLElBQUlBLE1BQU0sS0FBSyxNQUF6QixFQUFpQztBQUMvQnB0QixJQUFBQSxDQUFDLEdBQUdvdEIsTUFBTSxDQUFDN3dCLElBQVAsR0FBYzZ3QixNQUFNLENBQUMsQ0FBRCxDQUFOLElBQWFFLEdBQUcsR0FBR0EsR0FBRyxDQUFDcnNCLEtBQVAsR0FBZTNELE9BQU8sQ0FBQ2l3QixXQUFSLElBQXVCLENBQXRELENBQWQsR0FBeUVILE1BQU0sQ0FBQ3B0QixDQUFwRjtBQUNBQyxJQUFBQSxDQUFDLEdBQUdtdEIsTUFBTSxDQUFDN3dCLElBQVAsR0FBYzZ3QixNQUFNLENBQUMsQ0FBRCxDQUFOLElBQWFFLEdBQUcsR0FBR0EsR0FBRyxDQUFDanNCLE1BQVAsR0FBZ0IvRCxPQUFPLENBQUNtTCxZQUFSLElBQXdCLENBQXhELENBQWQsR0FBMkUya0IsTUFBTSxDQUFDbnRCLENBQXRGO0FBQ0Q7O0FBRUQsU0FBT290QixZQUFZLENBQUNqckIsS0FBYixDQUFtQnBDLENBQUMsSUFBSUMsQ0FBTCxHQUFTc1osQ0FBQyxDQUFDblgsS0FBRixDQUFRO0FBQ3pDcEMsSUFBQUEsQ0FBQyxFQUFFQSxDQURzQztBQUV6Q0MsSUFBQUEsQ0FBQyxFQUFFQTtBQUZzQyxHQUFSLENBQVQsR0FHckI7QUFDSEQsSUFBQUEsQ0FBQyxFQUFFdVosQ0FBQyxDQUFDdGYsQ0FERjtBQUVIZ0csSUFBQUEsQ0FBQyxFQUFFc1osQ0FBQyxDQUFDOUM7QUFGRixHQUhFLENBQVA7QUFPRCxDQXZHRDtBQUFBLElBd0dJK1csZUFBZSxHQUFHLFNBQVNBLGVBQVQsQ0FBeUJDLFdBQXpCLEVBQXNDQyxTQUF0QyxFQUFpREMsVUFBakQsRUFBNkRDLFFBQTdELEVBQXVFO0FBQzNGLE1BQUlQLFlBQVksR0FBRzcxQixrQ0FBZSxDQUFDaTJCLFdBQVcsQ0FBQ3B1QixVQUFiLEVBQXlCLElBQXpCLEVBQStCLElBQS9CLENBQWxDO0FBQUEsTUFDSWthLENBQUMsR0FBRzhULFlBQVksQ0FBQ1EsS0FBYixHQUFxQnRwQixRQUFyQixDQUE4Qi9NLGtDQUFlLENBQUNrMkIsU0FBRCxDQUE3QyxDQURSO0FBQUEsTUFFSUksU0FBUyxHQUFHWCxjQUFjLENBQUNNLFdBQUQsRUFBY0UsVUFBZCxFQUEwQk4sWUFBMUIsQ0FGOUI7QUFBQSxNQUdJVSxlQUFlLEdBQUdaLGNBQWMsQ0FBQ08sU0FBRCxFQUFZRSxRQUFaLEVBQXNCUCxZQUF0QixDQUhwQztBQUFBLE1BSUlydEIsQ0FBQyxHQUFHK3RCLGVBQWUsQ0FBQy90QixDQUp4QjtBQUFBLE1BS0lDLENBQUMsR0FBRzh0QixlQUFlLENBQUM5dEIsQ0FMeEI7QUFBQSxNQU1JeEUsQ0FOSjs7QUFRQThkLEVBQUFBLENBQUMsQ0FBQ3RmLENBQUYsR0FBTXNmLENBQUMsQ0FBQzlDLENBQUYsR0FBTSxDQUFaOztBQUVBLE1BQUltWCxRQUFRLEtBQUssTUFBYixJQUF1QkYsU0FBUyxDQUFDTSxjQUFqQyxJQUFtRE4sU0FBUyxDQUFDcE8sT0FBVixDQUFrQjllLFdBQWxCLE9BQW9DLE1BQTNGLEVBQW1HO0FBQ2pHL0UsSUFBQUEsQ0FBQyxHQUFHaXlCLFNBQVMsQ0FBQ3hvQixZQUFWLENBQXVCLEdBQXZCLEVBQTRCMmIsS0FBNUIsQ0FBa0NxTSxPQUFsQyxLQUE4QyxFQUFsRDtBQUNBenhCLElBQUFBLENBQUMsR0FBRzhkLENBQUMsQ0FBQ25YLEtBQUYsQ0FBUTtBQUNWcEMsTUFBQUEsQ0FBQyxFQUFFLENBQUN2RSxDQUFDLENBQUMsQ0FBRCxDQURLO0FBRVZ3RSxNQUFBQSxDQUFDLEVBQUUsQ0FBQ3hFLENBQUMsQ0FBQyxDQUFEO0FBRkssS0FBUixDQUFKO0FBSUF1RSxJQUFBQSxDQUFDLElBQUl2RSxDQUFDLENBQUN1RSxDQUFQO0FBQ0FDLElBQUFBLENBQUMsSUFBSXhFLENBQUMsQ0FBQ3dFLENBQVA7QUFDRDs7QUFFRCxNQUFJeEUsQ0FBQyxJQUFJaXlCLFNBQVMsQ0FBQ3JxQixPQUFWLElBQXFCb3FCLFdBQVcsQ0FBQ3BxQixPQUFqQyxJQUE0Q3FxQixTQUFTLENBQUNwcUIsZUFBVixLQUE4Qm1xQixXQUFXLENBQUNucUIsZUFBL0YsRUFBZ0g7QUFDOUc3SCxJQUFBQSxDQUFDLEdBQUc4ZCxDQUFDLENBQUNuWCxLQUFGLENBQVFzckIsU0FBUyxDQUFDcnFCLE9BQVYsRUFBUixDQUFKO0FBQ0FyRCxJQUFBQSxDQUFDLElBQUl2RSxDQUFDLENBQUN1RSxDQUFQO0FBQ0FDLElBQUFBLENBQUMsSUFBSXhFLENBQUMsQ0FBQ3dFLENBQVA7QUFDRDs7QUFFRHNaLEVBQUFBLENBQUMsQ0FBQ3RmLENBQUYsR0FBTStGLENBQUMsR0FBRzh0QixTQUFTLENBQUM5dEIsQ0FBcEI7QUFDQXVaLEVBQUFBLENBQUMsQ0FBQzlDLENBQUYsR0FBTXhXLENBQUMsR0FBRzZ0QixTQUFTLENBQUM3dEIsQ0FBcEI7QUFDQSxTQUFPc1osQ0FBUDtBQUNELENBdElEO0FBQUEsSUF1SUl5VCxNQUFNLEdBQUcsU0FBU0EsTUFBVCxDQUFnQjNRLE9BQWhCLEVBQXlCOWQsTUFBekIsRUFBaUMwdkIsSUFBakMsRUFBdUM7QUFDbEQsTUFBSTVWLEtBQUssR0FBRzRWLElBQUksQ0FBQzVWLEtBQWpCO0FBQUEsTUFDSTlVLE1BQU0sR0FBRzBxQixJQUFJLENBQUMxcUIsTUFEbEI7QUFBQSxNQUVJZ1EsT0FBTyxHQUFHMGEsSUFBSSxDQUFDMWEsT0FGbkI7QUFBQSxNQUdJQyxPQUFPLEdBQUd5YSxJQUFJLENBQUN6YSxPQUhuQjtBQUFBLE1BSUkwYSxXQUFXLEdBQUdELElBQUksQ0FBQ0MsV0FKdkI7O0FBTUEsTUFBSWx1QixDQUFDLEdBQUdxYyxPQUFPLENBQUMsQ0FBRCxDQUFQLENBQVcsQ0FBWCxDQUFSO0FBQUEsTUFDSXBjLENBQUMsR0FBR29jLE9BQU8sQ0FBQyxDQUFELENBQVAsQ0FBVyxDQUFYLENBRFI7QUFBQSxNQUVJOFIsSUFBSSxHQUFHOUIsV0FBVyxDQUFDOXRCLE1BQUQsRUFBUyxHQUFULENBRnRCO0FBQUEsTUFHSTZ2QixJQUFJLEdBQUcvQixXQUFXLENBQUM5dEIsTUFBRCxFQUFTLEdBQVQsQ0FIdEI7QUFBQSxNQUlJOHZCLFdBSko7QUFBQSxNQUtJOVUsQ0FMSjtBQUFBLE1BTUk5ZCxDQU5KOztBQVFBLE1BQUksQ0FBQzRnQixPQUFELElBQVksQ0FBQ0EsT0FBTyxDQUFDdGdCLE1BQXpCLEVBQWlDO0FBQy9CLFdBQU9naUIsVUFBVSxDQUFDLFVBQUQsQ0FBakI7QUFDRDs7QUFFRCxNQUFJMUYsS0FBSixFQUFXO0FBQ1QsUUFBSUEsS0FBSyxLQUFLLE1BQVYsSUFBb0IsQ0FBQ2dXLFdBQVcsR0FBR2wyQixRQUFRLENBQUNrZ0IsS0FBRCxDQUFSLENBQWdCLENBQWhCLEtBQXNCOVosTUFBckMsTUFBaURBLE1BQXpFLEVBQWlGO0FBQy9FZ21CLE1BQUFBLGdCQUFnQixDQUFDbEksT0FBRCxFQUFVLENBQVYsRUFBYSxDQUFiLEVBQWdCLENBQWhCLEVBQW1CLENBQW5CLEVBQXNCOFIsSUFBSSxHQUFHbnVCLENBQTdCLEVBQWdDb3VCLElBQUksR0FBR251QixDQUF2QyxDQUFoQjtBQUNELEtBRkQsTUFFTztBQUNMLFVBQUlpdUIsV0FBVyxJQUFJQSxXQUFXLENBQUMsQ0FBRCxDQUFYLEtBQW1CLEtBQXRDLEVBQTZDO0FBQzNDeDJCLFFBQUFBLElBQUksQ0FBQ2dPLEdBQUwsQ0FBU25ILE1BQVQsRUFBaUI7QUFDZit2QixVQUFBQSxlQUFlLEVBQUVKLFdBQVcsQ0FBQyxDQUFELENBQVgsR0FBaUIsR0FBakIsR0FBdUIsSUFBdkIsR0FBOEJBLFdBQVcsQ0FBQyxDQUFELENBQVgsR0FBaUIsR0FBL0MsR0FBcUQ7QUFEdkQsU0FBakI7QUFHRCxPQUpELE1BSU87QUFDTEEsUUFBQUEsV0FBVyxHQUFHLENBQUM3QixXQUFXLENBQUM5dEIsTUFBRCxFQUFTLFVBQVQsQ0FBWCxHQUFrQyxDQUFDLEdBQXBDLEVBQXlDOHRCLFdBQVcsQ0FBQzl0QixNQUFELEVBQVMsVUFBVCxDQUFYLEdBQWtDLENBQUMsR0FBNUUsQ0FBZDtBQUNEOztBQUVEZ2IsTUFBQUEsQ0FBQyxHQUFHaVUsZUFBZSxDQUFDanZCLE1BQUQsRUFBUzh2QixXQUFULEVBQXNCSCxXQUF0QixFQUFtQyxNQUFuQyxDQUFuQjtBQUNBenlCLE1BQUFBLENBQUMsR0FBRzhkLENBQUMsQ0FBQ25YLEtBQUYsQ0FBUTtBQUNWcEMsUUFBQUEsQ0FBQyxFQUFFQSxDQURPO0FBRVZDLFFBQUFBLENBQUMsRUFBRUE7QUFGTyxPQUFSLENBQUo7QUFJQXNrQixNQUFBQSxnQkFBZ0IsQ0FBQ2xJLE9BQUQsRUFBVTlDLENBQUMsQ0FBQzNVLENBQVosRUFBZTJVLENBQUMsQ0FBQ2hELENBQWpCLEVBQW9CZ0QsQ0FBQyxDQUFDakQsQ0FBdEIsRUFBeUJpRCxDQUFDLENBQUMvQyxDQUEzQixFQUE4QjJYLElBQUksR0FBRzVVLENBQUMsQ0FBQ3RmLENBQVQsSUFBY3dCLENBQUMsQ0FBQ3VFLENBQUYsR0FBTXVaLENBQUMsQ0FBQ3RmLENBQXRCLENBQTlCLEVBQXdEbTBCLElBQUksR0FBRzdVLENBQUMsQ0FBQzlDLENBQVQsSUFBY2hiLENBQUMsQ0FBQ3dFLENBQUYsR0FBTXNaLENBQUMsQ0FBQzlDLENBQXRCLENBQXhELENBQWhCO0FBQ0Q7QUFDRjs7QUFFRCxNQUFJbFQsTUFBSixFQUFZO0FBQ1ZnaEIsSUFBQUEsZ0JBQWdCLENBQUNsSSxPQUFELEVBQVU5WSxNQUFNLENBQUNxQixDQUFqQixFQUFvQnJCLE1BQU0sQ0FBQ2dULENBQTNCLEVBQThCaFQsTUFBTSxDQUFDK1MsQ0FBckMsRUFBd0MvUyxNQUFNLENBQUNpVCxDQUEvQyxFQUFrRGpULE1BQU0sQ0FBQ3RKLENBQXpELEVBQTREc0osTUFBTSxDQUFDa1QsQ0FBbkUsQ0FBaEI7QUFDRCxHQUZELE1BRU8sSUFBSWxELE9BQU8sSUFBSUMsT0FBZixFQUF3QjtBQUM3QitRLElBQUFBLGdCQUFnQixDQUFDbEksT0FBRCxFQUFVLENBQVYsRUFBYSxDQUFiLEVBQWdCLENBQWhCLEVBQW1CLENBQW5CLEVBQXNCOUksT0FBTyxJQUFJLENBQWpDLEVBQW9DQyxPQUFPLElBQUksQ0FBL0MsQ0FBaEI7QUFDRDs7QUFFRCxTQUFPNkksT0FBUDtBQUNELENBdExEO0FBQUEsSUF1TEk0USx3QkFBd0IsR0FBRyxTQUFTQSx3QkFBVCxDQUFrQ1IsTUFBbEMsRUFBMENsdUIsTUFBMUMsRUFBa0RnQyxRQUFsRCxFQUE0RDhiLE9BQTVELEVBQXFFa1MsWUFBckUsRUFBbUZDLFNBQW5GLEVBQThGO0FBQzNILE1BQUlDLEtBQUssR0FBR2x3QixNQUFNLENBQUMwTyxLQUFuQjtBQUFBLE1BQ0l5aEIsT0FBTyxHQUFHRCxLQUFLLENBQUNDLE9BRHBCO0FBQUEsTUFFSUMsS0FBSyxHQUFHRCxPQUFPLElBQUlBLE9BQU8sQ0FBQ0UsT0FBbkIsSUFBOEJGLE9BQU8sQ0FBQ0UsT0FBUixDQUFnQnJ1QixRQUFoQixDQUYxQztBQUFBLE1BR0krckIsSUFBSSxHQUFHcUMsS0FBSyxJQUFJQSxLQUFLLENBQUNwbEIsT0FBTixDQUFjLEdBQWQsSUFBcUIsQ0FBOUIsR0FBa0NvbEIsS0FBbEMsR0FBMENwdUIsUUFIckQ7QUFBQSxNQUlJc3VCLEVBQUUsR0FBR3BDLE1BQU0sQ0FBQ3FDLEdBQVAsR0FBYSxJQUFJOUMsU0FBSixDQUFjUyxNQUFNLENBQUNxQyxHQUFyQixFQUEwQnZ3QixNQUExQixFQUFrQyt0QixJQUFsQyxFQUF3QyxDQUF4QyxFQUEyQyxDQUEzQyxFQUE4Q2p6QixVQUE5QyxFQUEwRCxDQUExRCxFQUE2RG8xQixLQUFLLENBQUMvb0IsR0FBTixDQUFVbkgsTUFBVixFQUFrQit0QixJQUFsQixFQUF3QkcsTUFBeEIsQ0FBN0QsQ0FKdEI7QUFLQW9DLEVBQUFBLEVBQUUsQ0FBQ0UsQ0FBSCxHQUFPOUMsUUFBUSxDQUFDd0MsS0FBSyxDQUFDcGtCLEdBQU4sQ0FBVTlMLE1BQVYsRUFBa0IrdEIsSUFBbEIsRUFBd0JrQyxTQUF4QixDQUFELENBQVIsSUFBZ0QsQ0FBdkQ7QUFDQUssRUFBQUEsRUFBRSxDQUFDdFEsSUFBSCxHQUFVbEMsT0FBVjtBQUNBd1MsRUFBQUEsRUFBRSxDQUFDRyxFQUFILEdBQVFULFlBQVI7O0FBRUE5QixFQUFBQSxNQUFNLENBQUN3QyxNQUFQLENBQWMxeUIsSUFBZCxDQUFtQit2QixJQUFuQjtBQUNELENBbE1EO0FBQUEsSUFtTUk0QyxjQUFjLEdBQUcsU0FBU0EsY0FBVCxDQUF3Qi9iLEtBQXhCLEVBQStCck8sR0FBL0IsRUFBb0M7QUFDdkQsU0FBTyxVQUFVdVgsT0FBVixFQUFtQjtBQUN4QixXQUFPbEosS0FBSyxJQUFJck8sR0FBRyxLQUFLLENBQWpCLEdBQXFCdWMsWUFBWSxDQUFDaEYsT0FBRCxFQUFVbEosS0FBVixFQUFpQnJPLEdBQWpCLENBQWpDLEdBQXlEdVgsT0FBaEU7QUFDRCxHQUZEO0FBR0QsQ0F2TUQ7O0FBeU1PLElBQUk4UyxnQkFBZ0IsR0FBRztBQUM1QnZVLEVBQUFBLE9BQU8sRUFBRSxRQURtQjtBQUU1QjhELEVBQUFBLElBQUksRUFBRSxZQUZzQjtBQUc1QnZFLEVBQUFBLFFBQVEsRUFBRSxTQUFTQSxRQUFULENBQWtCak4sSUFBbEIsRUFBd0JraUIsTUFBeEIsRUFBZ0NDLFNBQWhDLEVBQTJDO0FBQ25EMzNCLElBQUFBLElBQUksR0FBR3dWLElBQVA7QUFDQStlLElBQUFBLFFBQVEsR0FBR3YwQixJQUFJLENBQUN3TyxLQUFMLENBQVdvcEIsT0FBdEI7QUFDQW4zQixJQUFBQSxRQUFRLEdBQUdULElBQUksQ0FBQ3dPLEtBQUwsQ0FBV0MsT0FBdEI7QUFDQTZsQixJQUFBQSxTQUFTLEdBQUdxRCxTQUFaO0FBQ0QsR0FSMkI7QUFTNUJFLEVBQUFBLElBQUksRUFBRSxTQUFTQSxJQUFULENBQWNoeEIsTUFBZCxFQUFzQnlELElBQXRCLEVBQTRCO0FBQ2hDLFFBQUksQ0FBQ3RLLElBQUwsRUFBVztBQUNUaVQsTUFBQUEsT0FBTyxDQUFDQyxJQUFSLENBQWEsOENBQWI7QUFDQSxhQUFPLEtBQVA7QUFDRDs7QUFFRCxRQUFJLEVBQUUsUUFBTzVJLElBQVAsTUFBZ0IsUUFBaEIsSUFBNEIsQ0FBQ0EsSUFBSSxDQUFDM0gsS0FBcEMsS0FBOEMsQ0FBQzJILElBQUksQ0FBQ3VjLElBQXhELEVBQThEO0FBQzVEdmMsTUFBQUEsSUFBSSxHQUFHO0FBQ0x1YyxRQUFBQSxJQUFJLEVBQUV2YztBQURELE9BQVA7QUFHRDs7QUFFRCxRQUFJd3RCLFFBQVEsR0FBRyxFQUFmO0FBQUEsUUFDSUMsS0FBSyxHQUFHenRCLElBRFo7QUFBQSxRQUVJdWMsSUFBSSxHQUFHa1IsS0FBSyxDQUFDbFIsSUFGakI7QUFBQSxRQUdJbVIsVUFBVSxHQUFHRCxLQUFLLENBQUNDLFVBSHZCO0FBQUEsUUFJSS9DLEtBQUssR0FBRzhDLEtBQUssQ0FBQzlDLEtBSmxCO0FBQUEsUUFLSUMsS0FBSyxHQUFHNkMsS0FBSyxDQUFDN0MsS0FMbEI7QUFBQSxRQU1JNXNCLENBQUMsR0FBR3l2QixLQUFLLENBQUN6dkIsQ0FOZDtBQUFBLFFBT0lDLENBQUMsR0FBR3d2QixLQUFLLENBQUN4dkIsQ0FQZDtBQUFBLFFBUUkwdkIsUUFBUSxHQUFHcFIsSUFBSSxDQUFDLENBQUQsQ0FSbkI7QUFBQSxRQVNJbU8sTUFBTSxHQUFHd0MsY0FBYyxDQUFDbHRCLElBQUksQ0FBQ21SLEtBQU4sRUFBYSxTQUFTblIsSUFBVCxHQUFnQkEsSUFBSSxDQUFDOEMsR0FBckIsR0FBMkIsQ0FBeEMsQ0FUM0I7QUFBQSxRQVVJdVgsT0FWSjtBQUFBLFFBV0k1Z0IsQ0FYSjs7QUFhQSxTQUFLK3pCLFFBQUwsR0FBZ0JBLFFBQWhCO0FBQ0EsU0FBS2p4QixNQUFMLEdBQWNBLE1BQWQ7O0FBRUEsUUFBSSxLQUFLcXhCLE1BQUwsR0FBY0YsVUFBVSxJQUFJQSxVQUFVLEtBQUssQ0FBL0MsRUFBa0Q7QUFDaEQ7QUFDQSxXQUFLRyxPQUFMLEdBQWUzckIsVUFBVSxDQUFDd3JCLFVBQUQsQ0FBVixJQUEwQixDQUF6QztBQUNBLFdBQUtJLE9BQUwsR0FBZSxDQUFDLENBQUM5dEIsSUFBSSxDQUFDK3RCLFVBQXRCO0FBQ0EsV0FBS0MsS0FBTCxHQUFhaHVCLElBQUksQ0FBQ21KLFFBQUwsSUFBaUIsVUFBOUIsQ0FKZ0QsQ0FJTjs7QUFFMUMsV0FBSzhrQixJQUFMLEdBQVkxeEIsTUFBTSxDQUFDME8sS0FBUCxDQUFhdkgsR0FBYixDQUFpQm5ILE1BQWpCLEVBQXlCLEtBQUt5eEIsS0FBOUIsRUFBcUMsSUFBckMsQ0FBWixDQU5nRCxDQU1ROztBQUV4RCxXQUFLRSxFQUFMLEdBQVVqRSxRQUFRLENBQUMxdEIsTUFBTSxDQUFDME8sS0FBUCxDQUFhNUMsR0FBYixDQUFpQjlMLE1BQWpCLEVBQXlCLEtBQUt5eEIsS0FBOUIsQ0FBRCxDQUFSLElBQWtELENBQTVELENBUmdELENBUWU7QUFDaEU7O0FBRUQsUUFBSXAyQixLQUFLLENBQUNDLE9BQU4sQ0FBYzBrQixJQUFkLEtBQXVCLEVBQUUsWUFBWUEsSUFBZCxDQUF2QixJQUE4QyxPQUFPb1IsUUFBUCxLQUFvQixRQUF0RSxFQUFnRjtBQUM5RSxXQUFLbDBCLENBQUwsSUFBVWswQixRQUFWLEVBQW9CO0FBQ2xCLFlBQUksQ0FBQzN2QixDQUFELElBQU0sQ0FBQzhyQixPQUFPLENBQUN2aUIsT0FBUixDQUFnQjlOLENBQWhCLENBQVgsRUFBK0I7QUFDN0J1RSxVQUFBQSxDQUFDLEdBQUd2RSxDQUFKO0FBQ0QsU0FGRCxNQUVPLElBQUksQ0FBQ3dFLENBQUQsSUFBTSxDQUFDOHJCLE9BQU8sQ0FBQ3hpQixPQUFSLENBQWdCOU4sQ0FBaEIsQ0FBWCxFQUErQjtBQUNwQ3dFLFVBQUFBLENBQUMsR0FBR3hFLENBQUo7QUFDRDtBQUNGOztBQUVELFVBQUl1RSxDQUFDLElBQUlDLENBQVQsRUFBWTtBQUNWO0FBQ0F1dkIsUUFBQUEsUUFBUSxDQUFDanpCLElBQVQsQ0FBY2l3QixpQkFBaUIsQ0FBQyxJQUFELEVBQU9OLHlCQUF5QixDQUFDQSx5QkFBeUIsQ0FBQyxFQUFELEVBQUszTixJQUFMLEVBQVd2ZSxDQUFYLEVBQWMsQ0FBZCxDQUExQixFQUE0Q3VlLElBQTVDLEVBQWtEdGUsQ0FBbEQsRUFBcUQsQ0FBckQsQ0FBaEMsRUFBeUYxQixNQUF6RixFQUFpR3lCLENBQWpHLEVBQW9HQyxDQUFwRyxFQUF1R3lzQixNQUF2RyxFQUErRzFxQixJQUEvRyxFQUFxSDJxQixLQUFLLElBQUlWLFFBQVEsQ0FBQzFOLElBQUksQ0FBQyxDQUFELENBQUosQ0FBUXZlLENBQVIsQ0FBRCxDQUF0SSxFQUFvSjRzQixLQUFLLElBQUlYLFFBQVEsQ0FBQzFOLElBQUksQ0FBQyxDQUFELENBQUosQ0FBUXRlLENBQVIsQ0FBRCxDQUFySyxDQUEvQjtBQUNELE9BSEQsTUFHTztBQUNMRCxRQUFBQSxDQUFDLEdBQUdDLENBQUMsR0FBRyxDQUFSO0FBQ0Q7O0FBRUQsV0FBS3hFLENBQUwsSUFBVWswQixRQUFWLEVBQW9CO0FBQ2xCbDBCLFFBQUFBLENBQUMsS0FBS3VFLENBQU4sSUFBV3ZFLENBQUMsS0FBS3dFLENBQWpCLElBQXNCdXZCLFFBQVEsQ0FBQ2p6QixJQUFULENBQWNpd0IsaUJBQWlCLENBQUMsSUFBRCxFQUFPTix5QkFBeUIsQ0FBQyxFQUFELEVBQUszTixJQUFMLEVBQVc5aUIsQ0FBWCxFQUFjLENBQWQsQ0FBaEMsRUFBa0Q4QyxNQUFsRCxFQUEwRDlDLENBQTFELEVBQTZELENBQTdELEVBQWdFaXhCLE1BQWhFLEVBQXdFMXFCLElBQXhFLEVBQThFaXFCLFFBQVEsQ0FBQzFOLElBQUksQ0FBQyxDQUFELENBQUosQ0FBUTlpQixDQUFSLENBQUQsQ0FBdEYsQ0FBL0IsQ0FBdEI7QUFDRDtBQUNGLEtBbkJELE1BbUJPO0FBQ0w0Z0IsTUFBQUEsT0FBTyxHQUFHcVEsTUFBTSxDQUFDTSxNQUFNLENBQUNqUCxVQUFVLENBQUMvYixJQUFJLENBQUN1YyxJQUFOLENBQVgsRUFBd0JoZ0IsTUFBeEIsRUFBZ0N5RCxJQUFoQyxDQUFQLENBQWhCO0FBQ0F1ZixNQUFBQSx3QkFBd0IsQ0FBQ2xGLE9BQUQsRUFBVXJhLElBQUksQ0FBQ3diLFVBQWYsQ0FBeEI7QUFDQWdTLE1BQUFBLFFBQVEsQ0FBQ2p6QixJQUFULENBQWM4ZixPQUFkOztBQUVBNFEsTUFBQUEsd0JBQXdCLENBQUMsSUFBRCxFQUFPMXVCLE1BQVAsRUFBZXlELElBQUksQ0FBQ2hDLENBQUwsSUFBVSxHQUF6QixFQUE4QnFjLE9BQTlCLEVBQXVDLEdBQXZDLEVBQTRDcmEsSUFBSSxDQUFDMnFCLEtBQUwsSUFBYyxJQUExRCxDQUF4Qjs7QUFFQU0sTUFBQUEsd0JBQXdCLENBQUMsSUFBRCxFQUFPMXVCLE1BQVAsRUFBZXlELElBQUksQ0FBQy9CLENBQUwsSUFBVSxHQUF6QixFQUE4Qm9jLE9BQTlCLEVBQXVDLEdBQXZDLEVBQTRDcmEsSUFBSSxDQUFDNHFCLEtBQUwsSUFBYyxJQUExRCxDQUF4QjtBQUNEO0FBQ0YsR0E1RTJCO0FBNkU1QnZkLEVBQUFBLE1BQU0sRUFBRSxTQUFTQSxNQUFULENBQWdCMkosS0FBaEIsRUFBdUI3YixJQUF2QixFQUE2QjtBQUNuQyxRQUFJcXlCLFFBQVEsR0FBR3J5QixJQUFJLENBQUNxeUIsUUFBcEI7QUFBQSxRQUNJMXpCLENBQUMsR0FBRzB6QixRQUFRLENBQUN6ekIsTUFEakI7QUFBQSxRQUVJOHlCLEVBQUUsR0FBRzF4QixJQUFJLENBQUMyeEIsR0FGZDs7QUFJQSxRQUFJOVYsS0FBSyxHQUFHLENBQVosRUFBZTtBQUNiQSxNQUFBQSxLQUFLLEdBQUcsQ0FBUjtBQUNELEtBRkQsTUFFTyxJQUFJQSxLQUFLLEdBQUcsQ0FBWixFQUFlO0FBQ3BCQSxNQUFBQSxLQUFLLEdBQUcsQ0FBUjtBQUNEOztBQUVELFdBQU9sZCxDQUFDLEVBQVIsRUFBWTtBQUNWdW9CLE1BQUFBLGlCQUFpQixDQUFDbUwsUUFBUSxDQUFDMXpCLENBQUQsQ0FBVCxFQUFja2QsS0FBZCxFQUFxQixDQUFDbGQsQ0FBRCxJQUFNcUIsSUFBSSxDQUFDeXlCLE1BQWhDLEVBQXdDSixRQUFRLENBQUMxekIsQ0FBRCxDQUFoRCxDQUFqQjtBQUNEOztBQUVELFdBQU8reUIsRUFBUCxFQUFXO0FBQ1RBLE1BQUFBLEVBQUUsQ0FBQ25wQixHQUFILENBQU9tcEIsRUFBRSxDQUFDdFMsQ0FBVixFQUFhc1MsRUFBRSxDQUFDcHpCLENBQWhCLEVBQW1Cb3pCLEVBQUUsQ0FBQ3RRLElBQUgsQ0FBUXNRLEVBQUUsQ0FBQ0csRUFBWCxJQUFpQkgsRUFBRSxDQUFDRSxDQUF2QyxFQUEwQ0YsRUFBRSxDQUFDclksQ0FBN0MsRUFBZ0R3QyxLQUFoRDtBQUNBNlYsTUFBQUEsRUFBRSxHQUFHQSxFQUFFLENBQUNzQixLQUFSO0FBQ0Q7O0FBRURoekIsSUFBQUEsSUFBSSxDQUFDeXlCLE1BQUwsSUFBZXp5QixJQUFJLENBQUM4eUIsSUFBTCxDQUFVOXlCLElBQUksQ0FBQ29CLE1BQWYsRUFBdUJwQixJQUFJLENBQUM2eUIsS0FBNUIsRUFBbUNSLFFBQVEsQ0FBQyxDQUFELENBQVIsQ0FBWWpOLEtBQVosSUFBcUJwbEIsSUFBSSxDQUFDMnlCLE9BQUwsR0FBZTVVLHdCQUFmLEdBQTBCLENBQS9DLElBQW9EL2QsSUFBSSxDQUFDMHlCLE9BQXpELEdBQW1FMXlCLElBQUksQ0FBQyt5QixFQUEzRyxFQUErRy95QixJQUEvRyxFQUFxSDZiLEtBQXJILENBQWY7QUFDRCxHQWxHMkI7QUFtRzVCb1gsRUFBQUEsU0FBUyxFQUFFLFNBQVNBLFNBQVQsQ0FBbUI3UixJQUFuQixFQUF5QjtBQUNsQyxXQUFPZ0Qsd0JBQXdCLENBQUN4RCxVQUFVLENBQUNRLElBQUQsQ0FBWCxDQUF4QixDQUEyQ2xCLFdBQWxEO0FBQ0QsR0FyRzJCO0FBc0c1QmdFLEVBQUFBLFlBQVksRUFBRUEsWUF0R2M7QUF1RzVCdEQsRUFBQUEsVUFBVSxFQUFFQSxVQXZHZ0I7QUF3RzVCdUwsRUFBQUEsZUFBZSxFQUFFQSxlQXhHVztBQXlHNUJuTCxFQUFBQSxlQUFlLEVBQUVBLGVBekdXO0FBMEc1QjRDLEVBQUFBLGVBQWUsRUFBRUEsZUExR1c7QUEyRzVCd0QsRUFBQUEsZ0JBQWdCLEVBQUVBLGdCQTNHVTtBQTRHNUIvc0IsRUFBQUEsZUFBZSxFQUFFQSw4QkE1R1c7QUE2RzVCNnNCLEVBQUFBLGlCQUFpQixFQUFFQSxpQkE3R1M7QUE4RzVCOUMsRUFBQUEsd0JBQXdCLEVBQUVBLHdCQTlHRTtBQStHNUJuQyxFQUFBQSxhQUFhLEVBQUUsU0FBU0EsYUFBVCxDQUF1QmhGLE9BQXZCLEVBQWdDaUYsSUFBaEMsRUFBc0M7QUFDbkQsV0FBT2xuQixRQUFRLENBQUNpaUIsT0FBRCxDQUFSLENBQWtCQyxHQUFsQixDQUFzQixVQUFVOWIsTUFBVixFQUFrQjtBQUM3QyxhQUFPc3RCLG1CQUFjLENBQUN0dEIsTUFBRCxFQUFTOGdCLElBQUksS0FBSyxLQUFsQixDQUFyQjtBQUNELEtBRk0sQ0FBUDtBQUdELEdBbkgyQjtBQW9INUJnUixFQUFBQSxrQkFBa0IsRUFBRSxTQUFTQSxrQkFBVCxDQUE0QjVDLFdBQTVCLEVBQXlDQyxTQUF6QyxFQUFvRHhjLEtBQXBELEVBQTJEO0FBQzdFLFFBQUlxSSxDQUFDLEdBQUcvaEIsa0NBQWUsQ0FBQ2syQixTQUFELEVBQVksSUFBWixFQUFrQixJQUFsQixDQUFmLENBQXVDbnBCLFFBQXZDLENBQWdEL00sa0NBQWUsQ0FBQ2kyQixXQUFELENBQS9ELENBQVI7QUFDQSxXQUFPdmMsS0FBSyxHQUFHcUksQ0FBQyxDQUFDblgsS0FBRixDQUFROE8sS0FBUixDQUFILEdBQW9CcUksQ0FBaEM7QUFDRCxHQXZIMkI7QUF3SDVCK1csRUFBQUEsY0FBYyxFQUFFOUMsZUF4SFk7QUF5SDVCK0MsRUFBQUEsbUJBQW1CLEVBQUUsU0FBU0EsbUJBQVQsQ0FBNkI5QyxXQUE3QixFQUEwQ0MsU0FBMUMsRUFBcURDLFVBQXJELEVBQWlFQyxRQUFqRSxFQUEyRTtBQUM5RixRQUFJclUsQ0FBQyxHQUFHaVUsZUFBZSxDQUFDQyxXQUFELEVBQWNDLFNBQWQsRUFBeUJDLFVBQXpCLEVBQXFDQyxRQUFyQyxDQUF2Qjs7QUFFQSxXQUFPO0FBQ0w1dEIsTUFBQUEsQ0FBQyxFQUFFdVosQ0FBQyxDQUFDdGYsQ0FEQTtBQUVMZ0csTUFBQUEsQ0FBQyxFQUFFc1osQ0FBQyxDQUFDOUM7QUFGQSxLQUFQO0FBSUQsR0FoSTJCO0FBaUk1QitaLEVBQUFBLGNBQWMsRUFBRSxTQUFTQSxjQUFULENBQXdCdDNCLEtBQXhCLEVBQStCOEksSUFBL0IsRUFBcUM7QUFDbkRBLElBQUFBLElBQUksR0FBR0EsSUFBSSxJQUFJLEVBQWY7O0FBRUEsUUFBSXdhLE9BQU8sR0FBRzBQLHlCQUF5QixDQUFDQSx5QkFBeUIsQ0FBQyxFQUFELEVBQUtoekIsS0FBTCxFQUFZOEksSUFBSSxDQUFDaEMsQ0FBTCxJQUFVLEdBQXRCLEVBQTJCLENBQTNCLENBQTFCLEVBQXlEOUcsS0FBekQsRUFBZ0U4SSxJQUFJLENBQUMvQixDQUFMLElBQVUsR0FBMUUsRUFBK0UsQ0FBL0UsQ0FBdkM7O0FBRUErQixJQUFBQSxJQUFJLENBQUM4cUIsUUFBTCxJQUFpQlAsV0FBVyxDQUFDL1AsT0FBRCxDQUE1QjtBQUNBLFdBQU8sQ0FBQ3hhLElBQUksQ0FBQ2pJLElBQUwsS0FBYyxPQUFkLEdBQXdCeWlCLE9BQXhCLEdBQWtDOE0sZUFBZSxDQUFDOU0sT0FBRCxFQUFVeGEsSUFBSSxDQUFDcW5CLFNBQWYsQ0FBbEQsQ0FBUDtBQUNEO0FBeEkyQixDQUF2QjtBQTBJUHR3QixRQUFRLE1BQU1yQixJQUFJLENBQUNzQixjQUFMLENBQW9CbTJCLGdCQUFwQixDQUFkOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNqV0EsU0FBU3NCLGlCQUFULENBQTJCbHlCLE1BQTNCLEVBQW1DNGdCLEtBQW5DLEVBQTBDO0FBQUUsT0FBSyxJQUFJcmpCLENBQUMsR0FBRyxDQUFiLEVBQWdCQSxDQUFDLEdBQUdxakIsS0FBSyxDQUFDcGpCLE1BQTFCLEVBQWtDRCxDQUFDLEVBQW5DLEVBQXVDO0FBQUUsUUFBSTQwQixVQUFVLEdBQUd2UixLQUFLLENBQUNyakIsQ0FBRCxDQUF0QjtBQUEyQjQwQixJQUFBQSxVQUFVLENBQUNDLFVBQVgsR0FBd0JELFVBQVUsQ0FBQ0MsVUFBWCxJQUF5QixLQUFqRDtBQUF3REQsSUFBQUEsVUFBVSxDQUFDRSxZQUFYLEdBQTBCLElBQTFCO0FBQWdDLFFBQUksV0FBV0YsVUFBZixFQUEyQkEsVUFBVSxDQUFDRyxRQUFYLEdBQXNCLElBQXRCO0FBQTRCejVCLElBQUFBLE1BQU0sQ0FBQ2dULGNBQVAsQ0FBc0I3TCxNQUF0QixFQUE4Qm15QixVQUFVLENBQUNJLEdBQXpDLEVBQThDSixVQUE5QztBQUE0RDtBQUFFOztBQUU3VCxTQUFTSyxZQUFULENBQXNCQyxXQUF0QixFQUFtQ0MsVUFBbkMsRUFBK0NDLFdBQS9DLEVBQTREO0FBQUUsTUFBSUQsVUFBSixFQUFnQlIsaUJBQWlCLENBQUNPLFdBQVcsQ0FBQzc1QixTQUFiLEVBQXdCODVCLFVBQXhCLENBQWpCO0FBQXNELE1BQUlDLFdBQUosRUFBaUJULGlCQUFpQixDQUFDTyxXQUFELEVBQWNFLFdBQWQsQ0FBakI7QUFBNkMsU0FBT0YsV0FBUDtBQUFxQjtBQUV2TjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7OztBQUNBLElBQUl0NUIsSUFBSjtBQUFBLElBQ0lPLFlBREo7QUFBQSxJQUVJazVCLE1BRko7QUFBQSxJQUdJeDVCLElBSEo7QUFBQSxJQUlJQyxJQUpKO0FBQUEsSUFLSXc1QixNQUxKO0FBQUEsSUFNSXQ1QixLQU5KO0FBQUEsSUFPSXU1QixRQVBKO0FBQUEsSUFRSUMsWUFSSjtBQUFBLElBU0lDLGFBVEo7QUFBQSxJQVVJQyxLQVZKO0FBQUEsSUFXSUMsV0FYSjtBQUFBLElBWUlDLFdBWko7QUFBQSxJQWFJMzRCLFFBQVEsR0FBRyxTQUFTQSxRQUFULEdBQW9CO0FBQ2pDLFNBQU9yQixJQUFJLElBQUksT0FBT29CLE1BQVAsS0FBa0IsV0FBbEIsS0FBa0NwQixJQUFJLEdBQUdvQixNQUFNLENBQUNwQixJQUFoRCxLQUF5REEsSUFBSSxDQUFDc0IsY0FBOUQsSUFBZ0Z0QixJQUEvRjtBQUNELENBZkQ7QUFBQSxJQWdCSWk2QixZQUFZLEdBQUcsU0FBU0EsWUFBVCxDQUFzQmwyQixDQUF0QixFQUF5QjtBQUMxQyxTQUFPQSxDQUFQO0FBQ0QsQ0FsQkQ7QUFBQSxJQW1CSW0yQixRQUFRLEdBQUcsQ0FuQmY7QUFBQSxJQW9CSUMsVUFBVSxHQUFHLEVBcEJqQjtBQUFBLElBcUJJQyxVQUFVLEdBQUcsRUFyQmpCO0FBQUEsSUFzQklDLFFBQVEsR0FBRyxFQXRCZjtBQUFBLElBdUJJcjNCLFFBQVEsR0FBR0MsSUFBSSxDQUFDQyxHQXZCcEI7QUFBQSxJQXdCSW8zQixPQUFPLEdBQUcsU0FBU0EsT0FBVCxDQUFpQnRULElBQWpCLEVBQXVCeGxCLEtBQXZCLEVBQThCO0FBQzFDLFNBQU9BLEtBQVA7QUFDRCxDQTFCRDtBQUFBLElBMkJJKzRCLFVBQVUsR0FBRyxTQUFTQSxVQUFULEdBQXNCO0FBQ3JDLE1BQUkva0IsSUFBSSxHQUFHcWtCLGFBQWEsQ0FBQ3JrQixJQUF6QjtBQUFBLE1BQ0kvUCxJQUFJLEdBQUcrUCxJQUFJLENBQUNnbEIsTUFBTCxJQUFlLEVBRDFCO0FBQUEsTUFFSUMsU0FBUyxHQUFHamxCLElBQUksQ0FBQzRrQixVQUZyQjtBQUFBLE1BR0lNLE9BQU8sR0FBR2xsQixJQUFJLENBQUM2a0IsUUFIbkI7QUFJQUksRUFBQUEsU0FBUyxDQUFDNTFCLElBQVYsQ0FBZTZGLEtBQWYsQ0FBcUIrdkIsU0FBckIsRUFBZ0NMLFVBQWhDO0FBQ0FNLEVBQUFBLE9BQU8sQ0FBQzcxQixJQUFSLENBQWE2RixLQUFiLENBQW1CZ3dCLE9BQW5CLEVBQTRCTCxRQUE1QjtBQUNBRCxFQUFBQSxVQUFVLEdBQUdLLFNBQWI7QUFDQUosRUFBQUEsUUFBUSxHQUFHSyxPQUFYOztBQUVBSixFQUFBQSxPQUFPLEdBQUcsU0FBU0EsT0FBVCxDQUFpQnRULElBQWpCLEVBQXVCeGxCLEtBQXZCLEVBQThCO0FBQ3RDLFdBQU9pRSxJQUFJLENBQUN1aEIsSUFBRCxDQUFKLENBQVd4bEIsS0FBWCxDQUFQO0FBQ0QsR0FGRDtBQUdELENBeENEO0FBQUEsSUF5Q0ltNUIsYUFBYSxHQUFHLFNBQVNBLGFBQVQsQ0FBdUIvMEIsT0FBdkIsRUFBZ0NpRCxRQUFoQyxFQUEwQztBQUM1RCxTQUFPLENBQUN3eEIsUUFBUSxDQUFDeG9CLE9BQVQsQ0FBaUJqTSxPQUFqQixDQUFELElBQThCeTBCLFFBQVEsQ0FBQ0EsUUFBUSxDQUFDeG9CLE9BQVQsQ0FBaUJqTSxPQUFqQixJQUE0QixDQUE3QixDQUFSLENBQXdDaUQsUUFBeEMsQ0FBckM7QUFDRCxDQTNDRDtBQUFBLElBNENJK3hCLFdBQVcsR0FBRyxTQUFTQSxXQUFULENBQXFCQyxFQUFyQixFQUF5QjtBQUN6QyxTQUFPLENBQUMsQ0FBQyxDQUFDZixLQUFLLENBQUNqb0IsT0FBTixDQUFjZ3BCLEVBQWQsQ0FBVjtBQUNELENBOUNEO0FBQUEsSUErQ0lsMUIsWUFBWSxHQUFHLFNBQVNBLFlBQVQsQ0FBc0JDLE9BQXRCLEVBQStCdkQsSUFBL0IsRUFBcUNzQyxJQUFyQyxFQUEyQ20yQixVQUEzQyxFQUF1RGoxQixPQUF2RCxFQUFnRTtBQUNqRixTQUFPRCxPQUFPLENBQUNFLGdCQUFSLENBQXlCekQsSUFBekIsRUFBK0JzQyxJQUEvQixFQUFxQztBQUMxQ3FCLElBQUFBLE9BQU8sRUFBRSxDQUFDODBCLFVBRGdDO0FBRTFDajFCLElBQUFBLE9BQU8sRUFBRSxDQUFDLENBQUNBO0FBRitCLEdBQXJDLENBQVA7QUFJRCxDQXBERDtBQUFBLElBcURJSSxlQUFlLEdBQUcsU0FBU0EsZUFBVCxDQUF5QkwsT0FBekIsRUFBa0N2RCxJQUFsQyxFQUF3Q3NDLElBQXhDLEVBQThDa0IsT0FBOUMsRUFBdUQ7QUFDM0UsU0FBT0QsT0FBTyxDQUFDTSxtQkFBUixDQUE0QjdELElBQTVCLEVBQWtDc0MsSUFBbEMsRUFBd0MsQ0FBQyxDQUFDa0IsT0FBMUMsQ0FBUDtBQUNELENBdkREO0FBQUEsSUF3RElrMUIsV0FBVyxHQUFHLFlBeERsQjtBQUFBLElBeURJQyxVQUFVLEdBQUcsV0F6RGpCO0FBQUEsSUEwRElDLFNBQVMsR0FBRyxTQUFTQSxTQUFULEdBQXFCO0FBQ25DLFNBQU9sQixXQUFXLElBQUlBLFdBQVcsQ0FBQ25uQixTQUEzQixJQUF3Q3duQixVQUFVLENBQUNyRCxLQUFYLEVBQS9DO0FBQ0QsQ0E1REQ7QUFBQSxJQTZESW1FLGdCQUFnQixHQUFHLFNBQVNBLGdCQUFULENBQTBCbmMsQ0FBMUIsRUFBNkJvYyxVQUE3QixFQUF5QztBQUM5RCxNQUFJQyxXQUFXLEdBQUcsU0FBU0EsV0FBVCxDQUFxQjU1QixLQUFyQixFQUE0QjtBQUM1QztBQUNBLFFBQUlBLEtBQUssSUFBSUEsS0FBSyxLQUFLLENBQXZCLEVBQTBCO0FBQ3hCMDRCLE1BQUFBLFFBQVEsS0FBS2o2QixJQUFJLENBQUNvN0IsT0FBTCxDQUFhQyxpQkFBYixHQUFpQyxRQUF0QyxDQUFSLENBRHdCLENBQ2lDOztBQUV6RCxVQUFJQyxhQUFhLEdBQUd4QixXQUFXLElBQUlBLFdBQVcsQ0FBQ25uQixTQUEvQztBQUNBcFIsTUFBQUEsS0FBSyxHQUFHNDVCLFdBQVcsQ0FBQzFHLENBQVosR0FBZ0IzeUIsSUFBSSxDQUFDQyxLQUFMLENBQVdSLEtBQVgsTUFBc0J1NEIsV0FBVyxJQUFJQSxXQUFXLENBQUN5QixHQUEzQixHQUFpQyxDQUFqQyxHQUFxQyxDQUEzRCxDQUF4QixDQUp3QixDQUkrRDs7QUFFdkZ6YyxNQUFBQSxDQUFDLENBQUN2ZCxLQUFELENBQUQ7QUFDQTQ1QixNQUFBQSxXQUFXLENBQUNLLE9BQVosR0FBc0JyQixVQUFVLENBQUNyRCxLQUFqQztBQUNBd0UsTUFBQUEsYUFBYSxJQUFJakIsT0FBTyxDQUFDLElBQUQsRUFBTzk0QixLQUFQLENBQXhCLENBUndCLENBUWU7QUFDeEMsS0FURCxNQVNPLElBQUkyNUIsVUFBVSxJQUFJZixVQUFVLENBQUNyRCxLQUFYLEtBQXFCcUUsV0FBVyxDQUFDSyxPQUEvQyxJQUEwRG5CLE9BQU8sQ0FBQyxLQUFELENBQXJFLEVBQThFO0FBQ25GYyxNQUFBQSxXQUFXLENBQUNLLE9BQVosR0FBc0JyQixVQUFVLENBQUNyRCxLQUFqQztBQUNBcUUsTUFBQUEsV0FBVyxDQUFDMUcsQ0FBWixHQUFnQjNWLENBQUMsRUFBakI7QUFDRDs7QUFFRCxXQUFPcWMsV0FBVyxDQUFDMUcsQ0FBWixHQUFnQjBHLFdBQVcsQ0FBQ3B3QixNQUFuQztBQUNELEdBakJEOztBQW1CQW93QixFQUFBQSxXQUFXLENBQUNwd0IsTUFBWixHQUFxQixDQUFyQjtBQUNBLFNBQU8rVCxDQUFDLElBQUlxYyxXQUFaO0FBQ0QsQ0FuRkQ7QUFBQSxJQW9GSU0sV0FBVyxHQUFHO0FBQ2hCM1IsRUFBQUEsQ0FBQyxFQUFFZ1IsV0FEYTtBQUVoQmgzQixFQUFBQSxDQUFDLEVBQUUsTUFGYTtBQUdoQmdJLEVBQUFBLEVBQUUsRUFBRSxNQUhZO0FBSWhCNHZCLEVBQUFBLEVBQUUsRUFBRSxPQUpZO0FBS2hCQyxFQUFBQSxHQUFHLEVBQUUsT0FMVztBQU1oQjljLEVBQUFBLENBQUMsRUFBRSxPQU5hO0FBT2hCMFMsRUFBQUEsRUFBRSxFQUFFLE9BUFk7QUFRaEJ0a0IsRUFBQUEsQ0FBQyxFQUFFLEdBUmE7QUFTaEIydUIsRUFBQUEsRUFBRSxFQUFFWCxnQkFBZ0IsQ0FBQyxVQUFVMTVCLEtBQVYsRUFBaUI7QUFDcEMsV0FBT3VPLFNBQVMsQ0FBQzFMLE1BQVYsR0FBbUJwRSxJQUFJLENBQUNxWSxRQUFMLENBQWM5VyxLQUFkLEVBQXFCczZCLFNBQVMsQ0FBQ0QsRUFBVixFQUFyQixDQUFuQixHQUEwRDU3QixJQUFJLENBQUNxSCxXQUFMLElBQW9CcEgsSUFBSSxDQUFDNjZCLFdBQUQsQ0FBeEIsSUFBeUNyQixNQUFNLENBQUNxQixXQUFELENBQS9DLElBQWdFMzZCLEtBQUssQ0FBQzI2QixXQUFELENBQXJFLElBQXNGLENBQXZKO0FBQ0QsR0FGbUI7QUFUSixDQXBGbEI7QUFBQSxJQWlHSWUsU0FBUyxHQUFHO0FBQ2QvUixFQUFBQSxDQUFDLEVBQUVpUixVQURXO0FBRWRqM0IsRUFBQUEsQ0FBQyxFQUFFLEtBRlc7QUFHZGdJLEVBQUFBLEVBQUUsRUFBRSxLQUhVO0FBSWQ0dkIsRUFBQUEsRUFBRSxFQUFFLFFBSlU7QUFLZEMsRUFBQUEsR0FBRyxFQUFFLFFBTFM7QUFNZDljLEVBQUFBLENBQUMsRUFBRSxRQU5XO0FBT2QwUyxFQUFBQSxFQUFFLEVBQUUsUUFQVTtBQVFkdGtCLEVBQUFBLENBQUMsRUFBRSxHQVJXO0FBU2Q2dUIsRUFBQUEsRUFBRSxFQUFFTCxXQVRVO0FBVWRHLEVBQUFBLEVBQUUsRUFBRVgsZ0JBQWdCLENBQUMsVUFBVTE1QixLQUFWLEVBQWlCO0FBQ3BDLFdBQU91TyxTQUFTLENBQUMxTCxNQUFWLEdBQW1CcEUsSUFBSSxDQUFDcVksUUFBTCxDQUFjb2pCLFdBQVcsQ0FBQ0csRUFBWixFQUFkLEVBQWdDcjZCLEtBQWhDLENBQW5CLEdBQTREdkIsSUFBSSxDQUFDZ0gsV0FBTCxJQUFvQi9HLElBQUksQ0FBQzg2QixVQUFELENBQXhCLElBQXdDdEIsTUFBTSxDQUFDc0IsVUFBRCxDQUE5QyxJQUE4RDU2QixLQUFLLENBQUM0NkIsVUFBRCxDQUFuRSxJQUFtRixDQUF0SjtBQUNELEdBRm1CO0FBVk4sQ0FqR2hCO0FBQUEsSUErR0lnQixVQUFVLEdBQUcsU0FBU0EsVUFBVCxDQUFvQm5YLENBQXBCLEVBQXVCO0FBQ3RDLFNBQU83a0IsSUFBSSxDQUFDd08sS0FBTCxDQUFXQyxPQUFYLENBQW1Cb1csQ0FBbkIsRUFBc0IsQ0FBdEIsTUFBNkIsT0FBT0EsQ0FBUCxLQUFhLFFBQWIsSUFBeUI3a0IsSUFBSSxDQUFDaThCLE1BQUwsR0FBY0MsY0FBZCxLQUFpQyxLQUExRCxHQUFrRWpwQixPQUFPLENBQUNDLElBQVIsQ0FBYSxvQkFBYixFQUFtQzJSLENBQW5DLENBQWxFLEdBQTBHLElBQXZJLENBQVA7QUFDRCxDQWpIRDtBQUFBLElBa0hJc1gsY0FBYyxHQUFHLFNBQVNBLGNBQVQsQ0FBd0J2MkIsT0FBeEIsRUFBaUMyd0IsSUFBakMsRUFBdUM7QUFDMUQsTUFBSXhNLENBQUMsR0FBR3dNLElBQUksQ0FBQ3hNLENBQWI7QUFBQSxNQUNJOFIsRUFBRSxHQUFHdEYsSUFBSSxDQUFDc0YsRUFEZCxDQUQwRCxDQUkxRDs7QUFDQSxNQUFJejNCLENBQUMsR0FBR2cyQixVQUFVLENBQUN2b0IsT0FBWCxDQUFtQmpNLE9BQW5CLENBQVI7QUFBQSxNQUNJb0YsTUFBTSxHQUFHNndCLEVBQUUsS0FBS0MsU0FBUyxDQUFDRCxFQUFqQixHQUFzQixDQUF0QixHQUEwQixDQUR2Qzs7QUFHQSxHQUFDLENBQUN6M0IsQ0FBRixLQUFRQSxDQUFDLEdBQUdnMkIsVUFBVSxDQUFDdjFCLElBQVgsQ0FBZ0JlLE9BQWhCLElBQTJCLENBQXZDO0FBQ0EsU0FBT3cwQixVQUFVLENBQUNoMkIsQ0FBQyxHQUFHNEcsTUFBTCxDQUFWLEtBQTJCb3ZCLFVBQVUsQ0FBQ2gyQixDQUFDLEdBQUc0RyxNQUFMLENBQVYsR0FBeUJrd0IsZ0JBQWdCLENBQUNQLGFBQWEsQ0FBQy8wQixPQUFELEVBQVVta0IsQ0FBVixDQUFkLEVBQTRCLElBQTVCLENBQWhCLEtBQXNENlEsV0FBVyxDQUFDaDFCLE9BQUQsQ0FBWCxHQUF1QmkyQixFQUF2QixHQUE0QlgsZ0JBQWdCLENBQUMsVUFBVTE1QixLQUFWLEVBQWlCO0FBQzdLLFdBQU91TyxTQUFTLENBQUMxTCxNQUFWLEdBQW1CdUIsT0FBTyxDQUFDbWtCLENBQUQsQ0FBUCxHQUFhdm9CLEtBQWhDLEdBQXdDb0UsT0FBTyxDQUFDbWtCLENBQUQsQ0FBdEQ7QUFDRCxHQUY0SixDQUFsRyxDQUFwRCxDQUFQO0FBR0QsQ0E5SEQ7QUFBQSxJQStISXFTLGdCQUFnQixHQUFHLFNBQVNBLGdCQUFULENBQTBCNTZCLEtBQTFCLEVBQWlDNjZCLGNBQWpDLEVBQWlEQyxRQUFqRCxFQUEyRDtBQUNoRixNQUFJQyxFQUFFLEdBQUcvNkIsS0FBVDtBQUFBLE1BQ0lnN0IsRUFBRSxHQUFHaDdCLEtBRFQ7QUFBQSxNQUVJaTdCLEVBQUUsR0FBR3o1QixRQUFRLEVBRmpCO0FBQUEsTUFHSTA1QixFQUFFLEdBQUdELEVBSFQ7QUFBQSxNQUlJeHhCLEdBQUcsR0FBR294QixjQUFjLElBQUksRUFKNUI7QUFBQSxNQUtJTSxjQUFjLEdBQUc1NkIsSUFBSSxDQUFDb0csR0FBTCxDQUFTLEdBQVQsRUFBYzhDLEdBQUcsR0FBRyxDQUFwQixDQUxyQjtBQUFBLE1BTUkwVyxNQUFNLEdBQUcsU0FBU0EsTUFBVCxDQUFnQm5nQixLQUFoQixFQUF1QnNPLEtBQXZCLEVBQThCO0FBQ3pDLFFBQUkrVSxDQUFDLEdBQUc3aEIsUUFBUSxFQUFoQjs7QUFFQSxRQUFJOE0sS0FBSyxJQUFJK1UsQ0FBQyxHQUFHNFgsRUFBSixHQUFTeHhCLEdBQXRCLEVBQTJCO0FBQ3pCdXhCLE1BQUFBLEVBQUUsR0FBR0QsRUFBTDtBQUNBQSxNQUFBQSxFQUFFLEdBQUcvNkIsS0FBTDtBQUNBazdCLE1BQUFBLEVBQUUsR0FBR0QsRUFBTDtBQUNBQSxNQUFBQSxFQUFFLEdBQUc1WCxDQUFMO0FBQ0QsS0FMRCxNQUtPLElBQUl5WCxRQUFKLEVBQWM7QUFDbkJDLE1BQUFBLEVBQUUsSUFBSS82QixLQUFOO0FBQ0QsS0FGTSxNQUVBO0FBQ0w7QUFDQSs2QixNQUFBQSxFQUFFLEdBQUdDLEVBQUUsR0FBRyxDQUFDaDdCLEtBQUssR0FBR2c3QixFQUFULEtBQWdCM1gsQ0FBQyxHQUFHNlgsRUFBcEIsS0FBMkJELEVBQUUsR0FBR0MsRUFBaEMsQ0FBVjtBQUNEO0FBQ0YsR0FwQkQ7QUFBQSxNQXFCSUUsS0FBSyxHQUFHLFNBQVNBLEtBQVQsR0FBaUI7QUFDM0JKLElBQUFBLEVBQUUsR0FBR0QsRUFBRSxHQUFHRCxRQUFRLEdBQUcsQ0FBSCxHQUFPQyxFQUF6QjtBQUNBRyxJQUFBQSxFQUFFLEdBQUdELEVBQUUsR0FBRyxDQUFWO0FBQ0QsR0F4QkQ7QUFBQSxNQXlCSWpiLFdBQVcsR0FBRyxTQUFTQSxXQUFULENBQXFCcWIsV0FBckIsRUFBa0M7QUFDbEQsUUFBSUMsSUFBSSxHQUFHSixFQUFYO0FBQUEsUUFDSUssSUFBSSxHQUFHUCxFQURYO0FBQUEsUUFFSTNYLENBQUMsR0FBRzdoQixRQUFRLEVBRmhCOztBQUlBLEtBQUM2NUIsV0FBVyxJQUFJQSxXQUFXLEtBQUssQ0FBaEMsS0FBc0NBLFdBQVcsS0FBS04sRUFBdEQsSUFBNEQ1YSxNQUFNLENBQUNrYixXQUFELENBQWxFO0FBQ0EsV0FBT0osRUFBRSxLQUFLQyxFQUFQLElBQWE3WCxDQUFDLEdBQUc2WCxFQUFKLEdBQVNDLGNBQXRCLEdBQXVDLENBQXZDLEdBQTJDLENBQUNKLEVBQUUsSUFBSUQsUUFBUSxHQUFHUyxJQUFILEdBQVUsQ0FBQ0EsSUFBdkIsQ0FBSCxLQUFvQyxDQUFDVCxRQUFRLEdBQUd6WCxDQUFILEdBQU80WCxFQUFoQixJQUFzQkssSUFBMUQsSUFBa0UsSUFBcEg7QUFDRCxHQWhDRDs7QUFrQ0EsU0FBTztBQUNMbmIsSUFBQUEsTUFBTSxFQUFFQSxNQURIO0FBRUxpYixJQUFBQSxLQUFLLEVBQUVBLEtBRkY7QUFHTHBiLElBQUFBLFdBQVcsRUFBRUE7QUFIUixHQUFQO0FBS0QsQ0F2S0Q7QUFBQSxJQXdLSXdiLFNBQVMsR0FBRyxTQUFTQSxTQUFULENBQW1CejZCLENBQW5CLEVBQXNCOEQsY0FBdEIsRUFBc0M7QUFDcERBLEVBQUFBLGNBQWMsSUFBSSxDQUFDOUQsQ0FBQyxDQUFDMDZCLFVBQXJCLElBQW1DMTZCLENBQUMsQ0FBQzhELGNBQUYsRUFBbkM7QUFDQSxTQUFPOUQsQ0FBQyxDQUFDeWEsY0FBRixHQUFtQnphLENBQUMsQ0FBQ3lhLGNBQUYsQ0FBaUIsQ0FBakIsQ0FBbkIsR0FBeUN6YSxDQUFoRDtBQUNELENBM0tEO0FBQUEsSUE0S0kyNkIsZUFBZSxHQUFHLFNBQVNBLGVBQVQsQ0FBeUJod0IsQ0FBekIsRUFBNEI7QUFDaEQsTUFBSS9FLEdBQUcsR0FBR3BHLElBQUksQ0FBQ29HLEdBQUwsQ0FBU3VDLEtBQVQsQ0FBZTNJLElBQWYsRUFBcUJtTCxDQUFyQixDQUFWO0FBQUEsTUFDSWpDLEdBQUcsR0FBR2xKLElBQUksQ0FBQ2tKLEdBQUwsQ0FBU1AsS0FBVCxDQUFlM0ksSUFBZixFQUFxQm1MLENBQXJCLENBRFY7QUFFQSxTQUFPbkwsSUFBSSxDQUFDMmIsR0FBTCxDQUFTdlYsR0FBVCxLQUFpQnBHLElBQUksQ0FBQzJiLEdBQUwsQ0FBU3pTLEdBQVQsQ0FBakIsR0FBaUM5QyxHQUFqQyxHQUF1QzhDLEdBQTlDO0FBQ0QsQ0FoTEQ7QUFBQSxJQWlMSWt5QixpQkFBaUIsR0FBRyxTQUFTQSxpQkFBVCxHQUE2QjtBQUNuRHRELEVBQUFBLGFBQWEsR0FBRzc1QixJQUFJLENBQUN3VixJQUFMLENBQVU0bkIsT0FBVixHQUFvQnZELGFBQXBDO0FBQ0FBLEVBQUFBLGFBQWEsSUFBSUEsYUFBYSxDQUFDcmtCLElBQS9CLElBQXVDK2tCLFVBQVUsRUFBakQ7QUFDRCxDQXBMRDtBQUFBLElBcUxJbHBCLFNBQVMsR0FBRyxTQUFTQSxTQUFULENBQW1CbUUsSUFBbkIsRUFBeUI7QUFDdkN4VixFQUFBQSxJQUFJLEdBQUd3VixJQUFJLElBQUluVSxRQUFRLEVBQXZCOztBQUVBLE1BQUlyQixJQUFJLElBQUksT0FBTzJPLFFBQVAsS0FBb0IsV0FBNUIsSUFBMkNBLFFBQVEsQ0FBQ3ZILElBQXhELEVBQThEO0FBQzVEbkgsSUFBQUEsSUFBSSxHQUFHbUIsTUFBUDtBQUNBbEIsSUFBQUEsSUFBSSxHQUFHeU8sUUFBUDtBQUNBK3FCLElBQUFBLE1BQU0sR0FBR3g1QixJQUFJLENBQUNpSCxlQUFkO0FBQ0EvRyxJQUFBQSxLQUFLLEdBQUdGLElBQUksQ0FBQ2tILElBQWI7QUFDQTB5QixJQUFBQSxLQUFLLEdBQUcsQ0FBQzc1QixJQUFELEVBQU9DLElBQVAsRUFBYXc1QixNQUFiLEVBQXFCdDVCLEtBQXJCLENBQVI7QUFDQXE1QixJQUFBQSxNQUFNLEdBQUd6NUIsSUFBSSxDQUFDd08sS0FBTCxDQUFXNnVCLEtBQXBCO0FBQ0F6RCxJQUFBQSxZQUFZLEdBQUcsb0JBQW9CeDVCLEtBQXBCLEdBQTRCLFNBQTVCLEdBQXdDLE9BQXZELENBUDRELENBT0k7O0FBRWhFdTVCLElBQUFBLFFBQVEsR0FBRzJELFFBQVEsQ0FBQ0MsT0FBVCxHQUFtQnQ5QixJQUFJLENBQUN1OUIsVUFBTCxJQUFtQnY5QixJQUFJLENBQUN1OUIsVUFBTCxDQUFnQixrQ0FBaEIsRUFBb0RDLE9BQXZFLEdBQWlGLENBQWpGLEdBQXFGLGtCQUFrQng5QixJQUFsQixJQUEwQnVSLFNBQVMsQ0FBQ2tzQixjQUFWLEdBQTJCLENBQXJELElBQTBEbHNCLFNBQVMsQ0FBQ08sZ0JBQVYsR0FBNkIsQ0FBdkYsR0FBMkYsQ0FBM0YsR0FBK0YsQ0FBbE47QUFDQWlvQixJQUFBQSxXQUFXLEdBQUdzRCxRQUFRLENBQUNLLFVBQVQsR0FBc0IsQ0FBQyxrQkFBa0JqRSxNQUFsQixHQUEyQiwyQ0FBM0IsR0FBeUUsRUFBRSxtQkFBbUJBLE1BQXJCLElBQStCLHFDQUEvQixHQUF1RSxpREFBakosRUFBb01sbkIsS0FBcE0sQ0FBME0sR0FBMU0sQ0FBcEM7QUFDQW9yQixJQUFBQSxVQUFVLENBQUMsWUFBWTtBQUNyQixhQUFPMUQsUUFBUSxHQUFHLENBQWxCO0FBQ0QsS0FGUyxFQUVQLEdBRk8sQ0FBVjs7QUFJQWlELElBQUFBLGlCQUFpQjs7QUFFakI1OEIsSUFBQUEsWUFBWSxHQUFHLENBQWY7QUFDRDs7QUFFRCxTQUFPQSxZQUFQO0FBQ0QsQ0E3TUQ7O0FBK01BbTdCLFdBQVcsQ0FBQ0ssRUFBWixHQUFpQkQsU0FBakI7QUFDQTFCLFVBQVUsQ0FBQ3JELEtBQVgsR0FBbUIsQ0FBbkI7QUFDTyxJQUFJdUcsUUFBUSxHQUFHLGFBQWEsWUFBWTtBQUM3QyxXQUFTQSxRQUFULENBQWtCaHpCLElBQWxCLEVBQXdCO0FBQ3RCLFNBQUt1dEIsSUFBTCxDQUFVdnRCLElBQVY7QUFDRDs7QUFFRCxNQUFJOEksTUFBTSxHQUFHa3FCLFFBQVEsQ0FBQzc5QixTQUF0Qjs7QUFFQTJULEVBQUFBLE1BQU0sQ0FBQ3lrQixJQUFQLEdBQWMsU0FBU0EsSUFBVCxDQUFjdnRCLElBQWQsRUFBb0I7QUFDaEMvSixJQUFBQSxZQUFZLElBQUk4USxTQUFTLENBQUNyUixJQUFELENBQXpCLElBQW1DaVQsT0FBTyxDQUFDQyxJQUFSLENBQWEsc0NBQWIsQ0FBbkM7QUFDQTJtQixJQUFBQSxhQUFhLElBQUlzRCxpQkFBaUIsRUFBbEM7QUFDQSxRQUFJcEssU0FBUyxHQUFHem9CLElBQUksQ0FBQ3lvQixTQUFyQjtBQUFBLFFBQ0k4SyxXQUFXLEdBQUd2ekIsSUFBSSxDQUFDdXpCLFdBRHZCO0FBQUEsUUFFSXg3QixJQUFJLEdBQUdpSSxJQUFJLENBQUNqSSxJQUZoQjtBQUFBLFFBR0l3RSxNQUFNLEdBQUd5RCxJQUFJLENBQUN6RCxNQUhsQjtBQUFBLFFBSUlpM0IsVUFBVSxHQUFHeHpCLElBQUksQ0FBQ3d6QixVQUp0QjtBQUFBLFFBS0lDLFFBQVEsR0FBR3p6QixJQUFJLENBQUN5ekIsUUFMcEI7QUFBQSxRQU1JMTNCLGNBQWMsR0FBR2lFLElBQUksQ0FBQ2pFLGNBTjFCO0FBQUEsUUFPSTIzQixNQUFNLEdBQUcxekIsSUFBSSxDQUFDMHpCLE1BUGxCO0FBQUEsUUFRSUMsV0FBVyxHQUFHM3pCLElBQUksQ0FBQzJ6QixXQVJ2QjtBQUFBLFFBU0lyWCxNQUFNLEdBQUd0YyxJQUFJLENBQUNzYyxNQVRsQjtBQUFBLFFBVUlzWCxVQUFVLEdBQUc1ekIsSUFBSSxDQUFDNHpCLFVBVnRCO0FBQUEsUUFXSTkzQixLQUFLLEdBQUdrRSxJQUFJLENBQUNsRSxLQVhqQjtBQUFBLFFBWUkrM0IsV0FBVyxHQUFHN3pCLElBQUksQ0FBQzZ6QixXQVp2QjtBQUFBLFFBYUlDLFNBQVMsR0FBRzl6QixJQUFJLENBQUM4ekIsU0FickI7QUFBQSxRQWNJL2dCLE1BQU0sR0FBRy9TLElBQUksQ0FBQytTLE1BZGxCO0FBQUEsUUFlSWIsT0FBTyxHQUFHbFMsSUFBSSxDQUFDa1MsT0FmbkI7QUFBQSxRQWdCSUUsU0FBUyxHQUFHcFMsSUFBSSxDQUFDb1MsU0FoQnJCO0FBQUEsUUFpQkkyaEIsT0FBTyxHQUFHL3pCLElBQUksQ0FBQyt6QixPQWpCbkI7QUFBQSxRQWtCSUMsTUFBTSxHQUFHaDBCLElBQUksQ0FBQ2cwQixNQWxCbEI7QUFBQSxRQW1CSUMsSUFBSSxHQUFHajBCLElBQUksQ0FBQ2kwQixJQW5CaEI7QUFBQSxRQW9CSUMsTUFBTSxHQUFHbDBCLElBQUksQ0FBQ2swQixNQXBCbEI7QUFBQSxRQXFCSUMsU0FBUyxHQUFHbjBCLElBQUksQ0FBQ20wQixTQXJCckI7QUFBQSxRQXNCSUMsU0FBUyxHQUFHcDBCLElBQUksQ0FBQ28wQixTQXRCckI7QUFBQSxRQXVCSUMsUUFBUSxHQUFHcjBCLElBQUksQ0FBQ3EwQixRQXZCcEI7QUFBQSxRQXdCSUMsU0FBUyxHQUFHdDBCLElBQUksQ0FBQ3MwQixTQXhCckI7QUFBQSxRQXlCSUMsU0FBUyxHQUFHdjBCLElBQUksQ0FBQ3UwQixTQXpCckI7QUFBQSxRQTBCSUMsT0FBTyxHQUFHeDBCLElBQUksQ0FBQ3cwQixPQTFCbkI7QUFBQSxRQTJCSUMsVUFBVSxHQUFHejBCLElBQUksQ0FBQ3kwQixVQTNCdEI7QUFBQSxRQTRCSXBpQixNQUFNLEdBQUdyUyxJQUFJLENBQUNxUyxNQTVCbEI7QUFBQSxRQTZCSXFpQixXQUFXLEdBQUcxMEIsSUFBSSxDQUFDMDBCLFdBN0J2QjtBQUFBLFFBOEJJQyxZQUFZLEdBQUczMEIsSUFBSSxDQUFDMjBCLFlBOUJ4QjtBQUFBLFFBK0JJQyxjQUFjLEdBQUc1MEIsSUFBSSxDQUFDNDBCLGNBL0IxQjtBQUFBLFFBZ0NJQyxZQUFZLEdBQUc3MEIsSUFBSSxDQUFDNjBCLFlBaEN4QjtBQUFBLFFBaUNJQyxPQUFPLEdBQUc5MEIsSUFBSSxDQUFDODBCLE9BakNuQjtBQUFBLFFBa0NJQyxRQUFRLEdBQUcvMEIsSUFBSSxDQUFDKzBCLFFBbENwQjtBQUFBLFFBbUNJQyxTQUFTLEdBQUdoMUIsSUFBSSxDQUFDZzFCLFNBbkNyQjtBQUFBLFFBb0NJdmYsT0FBTyxHQUFHelYsSUFBSSxDQUFDeVYsT0FwQ25CO0FBQUEsUUFxQ0l3ZixXQUFXLEdBQUdqMUIsSUFBSSxDQUFDaTFCLFdBckN2QjtBQUFBLFFBc0NJMTVCLE9BQU8sR0FBR3lFLElBQUksQ0FBQ3pFLE9BdENuQjtBQUFBLFFBdUNJMjVCLFdBQVcsR0FBR2wxQixJQUFJLENBQUNrMUIsV0F2Q3ZCO0FBQUEsUUF3Q0kzckIsUUFBUSxHQUFHdkosSUFBSSxDQUFDdUosUUF4Q3BCO0FBQUEsUUF5Q0krSixVQUFVLEdBQUd0VCxJQUFJLENBQUNzVCxVQXpDdEI7QUEwQ0EsU0FBSy9XLE1BQUwsR0FBY0EsTUFBTSxHQUFHbTFCLFVBQVUsQ0FBQ24xQixNQUFELENBQVYsSUFBc0I2eUIsTUFBN0M7QUFDQSxTQUFLcHZCLElBQUwsR0FBWUEsSUFBWjtBQUNBc2MsSUFBQUEsTUFBTSxLQUFLQSxNQUFNLEdBQUc1bUIsSUFBSSxDQUFDd08sS0FBTCxDQUFXQyxPQUFYLENBQW1CbVksTUFBbkIsQ0FBZCxDQUFOO0FBQ0FtTSxJQUFBQSxTQUFTLEdBQUdBLFNBQVMsSUFBSSxDQUF6QjtBQUNBOEssSUFBQUEsV0FBVyxHQUFHQSxXQUFXLElBQUksQ0FBN0I7QUFDQUssSUFBQUEsVUFBVSxHQUFHQSxVQUFVLElBQUksQ0FBM0I7QUFDQXFCLElBQUFBLFdBQVcsR0FBR0EsV0FBVyxJQUFJLENBQTdCO0FBQ0FsOUIsSUFBQUEsSUFBSSxHQUFHQSxJQUFJLElBQUkscUJBQWY7QUFDQTA3QixJQUFBQSxRQUFRLEdBQUdBLFFBQVEsS0FBSyxLQUF4QjtBQUNBRCxJQUFBQSxVQUFVLEtBQUtBLFVBQVUsR0FBR3R4QixVQUFVLENBQUN2TSxJQUFJLENBQUMrSSxnQkFBTCxDQUFzQjVJLEtBQXRCLEVBQTZCMDlCLFVBQTlCLENBQVYsSUFBdUQsRUFBekUsQ0FBVixDQXREZ0MsQ0FzRHdEOztBQUV4RixRQUFJOWIsRUFBSjtBQUFBLFFBQ0l5ZCxpQkFESjtBQUFBLFFBRUlDLE9BRko7QUFBQSxRQUdJQyxLQUhKO0FBQUEsUUFJSUMsT0FKSjtBQUFBLFFBS0lDLE1BTEo7QUFBQSxRQU1JOTNCLElBTko7QUFBQSxRQU9JM0ksSUFBSSxHQUFHLElBUFg7QUFBQSxRQVFJMGdDLFVBQVUsR0FBRyxDQVJqQjtBQUFBLFFBU0lDLFVBQVUsR0FBRyxDQVRqQjtBQUFBLFFBVUlDLFdBQVcsR0FBRzdELGNBQWMsQ0FBQ3QxQixNQUFELEVBQVM2MEIsV0FBVCxDQVZoQztBQUFBLFFBV0l1RSxXQUFXLEdBQUc5RCxjQUFjLENBQUN0MUIsTUFBRCxFQUFTaTFCLFNBQVQsQ0FYaEM7QUFBQSxRQVlJb0UsT0FBTyxHQUFHRixXQUFXLEVBWnpCO0FBQUEsUUFhSUcsT0FBTyxHQUFHRixXQUFXLEVBYnpCO0FBQUEsUUFjSUcsWUFBWSxHQUFHLENBQUMvOUIsSUFBSSxDQUFDd1AsT0FBTCxDQUFhLE9BQWIsQ0FBRCxJQUEwQixDQUFDLENBQUN4UCxJQUFJLENBQUN3UCxPQUFMLENBQWEsU0FBYixDQUE1QixJQUF1RG1vQixXQUFXLENBQUMsQ0FBRCxDQUFYLEtBQW1CLGFBZDdGO0FBQUEsUUFlSTtBQUNKcUcsSUFBQUEsVUFBVSxHQUFHekYsV0FBVyxDQUFDL3pCLE1BQUQsQ0FoQnhCO0FBQUEsUUFpQklnUCxRQUFRLEdBQUdoUCxNQUFNLENBQUNrRCxhQUFQLElBQXdCN0osSUFqQnZDO0FBQUEsUUFrQklzWSxNQUFNLEdBQUcsQ0FBQyxDQUFELEVBQUksQ0FBSixFQUFPLENBQVAsQ0FsQmI7QUFBQSxRQW1CSTtBQUNKRSxJQUFBQSxNQUFNLEdBQUcsQ0FBQyxDQUFELEVBQUksQ0FBSixFQUFPLENBQVAsQ0FwQlQ7QUFBQSxRQXFCSTRuQixXQUFXLEdBQUcsQ0FyQmxCO0FBQUEsUUFzQklDLFlBQVksR0FBRyxTQUFTQSxZQUFULEdBQXdCO0FBQ3pDLGFBQU9ELFdBQVcsR0FBR3Q5QixRQUFRLEVBQTdCO0FBQ0QsS0F4QkQ7QUFBQSxRQXlCSXc5QixZQUFZLEdBQUcsU0FBU0EsWUFBVCxDQUFzQmorQixDQUF0QixFQUF5QmsrQixnQkFBekIsRUFBMkM7QUFDNUQsYUFBTyxDQUFDcmhDLElBQUksQ0FBQ2dILEtBQUwsR0FBYTdELENBQWQsS0FBb0Jxa0IsTUFBcEIsSUFBOEIsQ0FBQ0EsTUFBTSxDQUFDL1UsT0FBUCxDQUFldFAsQ0FBQyxDQUFDc0UsTUFBakIsQ0FBL0IsSUFBMkQ0NUIsZ0JBQWdCLElBQUlMLFlBQXBCLElBQW9DNzlCLENBQUMsQ0FBQ20rQixXQUFGLEtBQWtCLE9BQWpILElBQTRIMUIsV0FBVyxJQUFJQSxXQUFXLENBQUN6OEIsQ0FBRCxFQUFJaytCLGdCQUFKLENBQTdKO0FBQ0QsS0EzQkQ7QUFBQSxRQTRCSUUsVUFBVSxHQUFHLFNBQVNBLFVBQVQsR0FBc0I7QUFDckN2aEMsTUFBQUEsSUFBSSxDQUFDd2hDLEdBQUwsQ0FBU2hFLEtBQVQ7O0FBRUF4OUIsTUFBQUEsSUFBSSxDQUFDeWhDLEdBQUwsQ0FBU2pFLEtBQVQ7O0FBRUE2QyxNQUFBQSxpQkFBaUIsQ0FBQ3FCLEtBQWxCO0FBQ0E5QyxNQUFBQSxNQUFNLElBQUlBLE1BQU0sQ0FBQzUrQixJQUFELENBQWhCO0FBQ0QsS0FuQ0Q7QUFBQSxRQW9DSXVpQixNQUFNLEdBQUcsU0FBU0EsTUFBVCxHQUFrQjtBQUM3QixVQUFJbEksRUFBRSxHQUFHcmEsSUFBSSxDQUFDb1osTUFBTCxHQUFjMGtCLGVBQWUsQ0FBQzFrQixNQUFELENBQXRDO0FBQUEsVUFDSWtCLEVBQUUsR0FBR3RhLElBQUksQ0FBQ3NaLE1BQUwsR0FBY3drQixlQUFlLENBQUN4a0IsTUFBRCxDQUR0QztBQUFBLFVBRUlxb0IsUUFBUSxHQUFHaC9CLElBQUksQ0FBQzJiLEdBQUwsQ0FBU2pFLEVBQVQsS0FBZ0JzWixTQUYvQjtBQUFBLFVBR0lpTyxRQUFRLEdBQUdqL0IsSUFBSSxDQUFDMmIsR0FBTCxDQUFTaEUsRUFBVCxLQUFnQnFaLFNBSC9COztBQUtBNEwsTUFBQUEsUUFBUSxLQUFLb0MsUUFBUSxJQUFJQyxRQUFqQixDQUFSLElBQXNDckMsUUFBUSxDQUFDdi9CLElBQUQsRUFBT3FhLEVBQVAsRUFBV0MsRUFBWCxFQUFlbEIsTUFBZixFQUF1QkUsTUFBdkIsQ0FBOUMsQ0FONkIsQ0FNaUQ7O0FBRTlFLFVBQUlxb0IsUUFBSixFQUFjO0FBQ1oxQyxRQUFBQSxPQUFPLElBQUlqL0IsSUFBSSxDQUFDb1osTUFBTCxHQUFjLENBQXpCLElBQThCNmxCLE9BQU8sQ0FBQ2ovQixJQUFELENBQXJDO0FBQ0FrL0IsUUFBQUEsTUFBTSxJQUFJbC9CLElBQUksQ0FBQ29aLE1BQUwsR0FBYyxDQUF4QixJQUE2QjhsQixNQUFNLENBQUNsL0IsSUFBRCxDQUFuQztBQUNBcS9CLFFBQUFBLFNBQVMsSUFBSUEsU0FBUyxDQUFDci9CLElBQUQsQ0FBdEI7QUFDQXcvQixRQUFBQSxTQUFTLElBQUl4L0IsSUFBSSxDQUFDb1osTUFBTCxHQUFjLENBQWQsS0FBb0JzbkIsVUFBVSxHQUFHLENBQTlDLElBQW1EbEIsU0FBUyxDQUFDeC9CLElBQUQsQ0FBNUQ7QUFDQTBnQyxRQUFBQSxVQUFVLEdBQUcxZ0MsSUFBSSxDQUFDb1osTUFBbEI7QUFDQUEsUUFBQUEsTUFBTSxDQUFDLENBQUQsQ0FBTixHQUFZQSxNQUFNLENBQUMsQ0FBRCxDQUFOLEdBQVlBLE1BQU0sQ0FBQyxDQUFELENBQU4sR0FBWSxDQUFwQztBQUNEOztBQUVELFVBQUl3b0IsUUFBSixFQUFjO0FBQ1p4QyxRQUFBQSxNQUFNLElBQUlwL0IsSUFBSSxDQUFDc1osTUFBTCxHQUFjLENBQXhCLElBQTZCOGxCLE1BQU0sQ0FBQ3AvQixJQUFELENBQW5DO0FBQ0FtL0IsUUFBQUEsSUFBSSxJQUFJbi9CLElBQUksQ0FBQ3NaLE1BQUwsR0FBYyxDQUF0QixJQUEyQjZsQixJQUFJLENBQUNuL0IsSUFBRCxDQUEvQjtBQUNBcy9CLFFBQUFBLFNBQVMsSUFBSUEsU0FBUyxDQUFDdC9CLElBQUQsQ0FBdEI7QUFDQXkvQixRQUFBQSxTQUFTLElBQUl6L0IsSUFBSSxDQUFDc1osTUFBTCxHQUFjLENBQWQsS0FBb0JxbkIsVUFBVSxHQUFHLENBQTlDLElBQW1EbEIsU0FBUyxDQUFDei9CLElBQUQsQ0FBNUQ7QUFDQTJnQyxRQUFBQSxVQUFVLEdBQUczZ0MsSUFBSSxDQUFDc1osTUFBbEI7QUFDQUEsUUFBQUEsTUFBTSxDQUFDLENBQUQsQ0FBTixHQUFZQSxNQUFNLENBQUMsQ0FBRCxDQUFOLEdBQVlBLE1BQU0sQ0FBQyxDQUFELENBQU4sR0FBWSxDQUFwQztBQUNEOztBQUVELFVBQUlpbkIsS0FBSyxJQUFJRCxPQUFiLEVBQXNCO0FBQ3BCL2lCLFFBQUFBLE1BQU0sSUFBSUEsTUFBTSxDQUFDdmQsSUFBRCxDQUFoQjtBQUNBd2UsUUFBQUEsVUFBVSxJQUFJaWlCLE1BQWQsSUFBd0JqaUIsVUFBVSxDQUFDeGUsSUFBRCxDQUFsQzs7QUFFQSxZQUFJc2dDLE9BQUosRUFBYTtBQUNYcmlCLFVBQUFBLE1BQU0sQ0FBQ2plLElBQUQsQ0FBTjtBQUNBc2dDLFVBQUFBLE9BQU8sR0FBRyxLQUFWO0FBQ0Q7O0FBRURDLFFBQUFBLEtBQUssR0FBR0UsTUFBTSxHQUFHLEtBQWpCO0FBQ0Q7O0FBRUQsVUFBSUQsT0FBSixFQUFhO0FBQ1hSLFFBQUFBLE9BQU8sQ0FBQ2hnQyxJQUFELENBQVA7QUFDQXdnQyxRQUFBQSxPQUFPLEdBQUcsS0FBVjtBQUNEOztBQUVENWQsTUFBQUEsRUFBRSxHQUFHLENBQUw7QUFDRCxLQWhGRDtBQUFBLFFBaUZJaWYsT0FBTyxHQUFHLFNBQVNBLE9BQVQsQ0FBaUIzNEIsQ0FBakIsRUFBb0JDLENBQXBCLEVBQXVCMGQsS0FBdkIsRUFBOEI7QUFDMUN6TixNQUFBQSxNQUFNLENBQUN5TixLQUFELENBQU4sSUFBaUIzZCxDQUFqQjtBQUNBb1EsTUFBQUEsTUFBTSxDQUFDdU4sS0FBRCxDQUFOLElBQWlCMWQsQ0FBakI7O0FBRUFuSixNQUFBQSxJQUFJLENBQUN3aEMsR0FBTCxDQUFTamYsTUFBVCxDQUFnQnJaLENBQWhCOztBQUVBbEosTUFBQUEsSUFBSSxDQUFDeWhDLEdBQUwsQ0FBU2xmLE1BQVQsQ0FBZ0JwWixDQUFoQjs7QUFFQXcxQixNQUFBQSxRQUFRLEdBQUcvYixFQUFFLEtBQUtBLEVBQUUsR0FBR2tmLHFCQUFxQixDQUFDdmYsTUFBRCxDQUEvQixDQUFMLEdBQWdEQSxNQUFNLEVBQTlEO0FBQ0QsS0ExRkQ7QUFBQSxRQTJGSXdmLHFCQUFxQixHQUFHLFNBQVNBLHFCQUFULENBQStCNzRCLENBQS9CLEVBQWtDQyxDQUFsQyxFQUFxQztBQUMvRCxVQUFJUixJQUFJLEtBQUssR0FBYixFQUFrQjtBQUNoQnlRLFFBQUFBLE1BQU0sQ0FBQyxDQUFELENBQU4sSUFBYWxRLENBQWI7O0FBRUFsSixRQUFBQSxJQUFJLENBQUN3aEMsR0FBTCxDQUFTamYsTUFBVCxDQUFnQnJaLENBQWhCLEVBQW1CLElBQW5CLEVBSGdCLENBR1U7O0FBRTNCOztBQUVELFVBQUlQLElBQUksS0FBSyxHQUFiLEVBQWtCO0FBQ2hCMlEsUUFBQUEsTUFBTSxDQUFDLENBQUQsQ0FBTixJQUFhblEsQ0FBYjs7QUFFQW5KLFFBQUFBLElBQUksQ0FBQ3loQyxHQUFMLENBQVNsZixNQUFULENBQWdCcFosQ0FBaEIsRUFBbUIsSUFBbkI7QUFDRDs7QUFFRCxVQUFJc0wsUUFBUSxJQUFJLENBQUM5TCxJQUFqQixFQUF1QjtBQUNyQjNJLFFBQUFBLElBQUksQ0FBQzJJLElBQUwsR0FBWUEsSUFBSSxHQUFHaEcsSUFBSSxDQUFDMmIsR0FBTCxDQUFTcFYsQ0FBVCxJQUFjdkcsSUFBSSxDQUFDMmIsR0FBTCxDQUFTblYsQ0FBVCxDQUFkLEdBQTRCLEdBQTVCLEdBQWtDLEdBQXJEO0FBQ0FzM0IsUUFBQUEsTUFBTSxHQUFHLElBQVQ7QUFDRDs7QUFFRDlCLE1BQUFBLFFBQVEsR0FBRy9iLEVBQUUsS0FBS0EsRUFBRSxHQUFHa2YscUJBQXFCLENBQUN2ZixNQUFELENBQS9CLENBQUwsR0FBZ0RBLE1BQU0sRUFBOUQ7QUFDRCxLQS9HRDtBQUFBLFFBZ0hJeWYsT0FBTyxHQUFHLFNBQVNBLE9BQVQsQ0FBaUI3K0IsQ0FBakIsRUFBb0I7QUFDaEMsVUFBSWkrQixZQUFZLENBQUNqK0IsQ0FBRCxFQUFJLENBQUosQ0FBaEIsRUFBd0I7QUFDdEI7QUFDRDs7QUFFREEsTUFBQUEsQ0FBQyxHQUFHeTZCLFNBQVMsQ0FBQ3o2QixDQUFELEVBQUk4RCxjQUFKLENBQWI7QUFDQSxVQUFJaUMsQ0FBQyxHQUFHL0YsQ0FBQyxDQUFDOCtCLE9BQVY7QUFBQSxVQUNJOTRCLENBQUMsR0FBR2hHLENBQUMsQ0FBQysrQixPQURWO0FBQUEsVUFFSTduQixFQUFFLEdBQUduUixDQUFDLEdBQUdsSixJQUFJLENBQUNrSixDQUZsQjtBQUFBLFVBR0lvUixFQUFFLEdBQUduUixDQUFDLEdBQUduSixJQUFJLENBQUNtSixDQUhsQjtBQUFBLFVBSUlzUCxVQUFVLEdBQUd6WSxJQUFJLENBQUN5WSxVQUp0QjtBQUtBelksTUFBQUEsSUFBSSxDQUFDa0osQ0FBTCxHQUFTQSxDQUFUO0FBQ0FsSixNQUFBQSxJQUFJLENBQUNtSixDQUFMLEdBQVNBLENBQVQ7O0FBRUEsVUFBSXNQLFVBQVUsSUFBSTlWLElBQUksQ0FBQzJiLEdBQUwsQ0FBU3RlLElBQUksQ0FBQ2dkLE1BQUwsR0FBYzlULENBQXZCLEtBQTZCdTFCLFdBQTNDLElBQTBEOTdCLElBQUksQ0FBQzJiLEdBQUwsQ0FBU3RlLElBQUksQ0FBQ2lkLE1BQUwsR0FBYzlULENBQXZCLEtBQTZCczFCLFdBQTNGLEVBQXdHO0FBQ3RHeGdCLFFBQUFBLE1BQU0sS0FBS3FpQixPQUFPLEdBQUcsSUFBZixDQUFOO0FBQ0E3bkIsUUFBQUEsVUFBVSxLQUFLelksSUFBSSxDQUFDeVksVUFBTCxHQUFrQixJQUF2QixDQUFWO0FBQ0FzcEIsUUFBQUEscUJBQXFCLENBQUMxbkIsRUFBRCxFQUFLQyxFQUFMLENBQXJCO0FBQ0E3QixRQUFBQSxVQUFVLElBQUlzbUIsV0FBVyxJQUFJQSxXQUFXLENBQUMvK0IsSUFBRCxDQUF4QztBQUNEO0FBQ0YsS0FwSUQ7QUFBQSxRQXFJSW1pQyxRQUFRLEdBQUduaUMsSUFBSSxDQUFDb2QsT0FBTCxHQUFlLFVBQVVqYSxDQUFWLEVBQWE7QUFDekMsVUFBSWkrQixZQUFZLENBQUNqK0IsQ0FBRCxFQUFJLENBQUosQ0FBaEIsRUFBd0I7QUFDdEI7QUFDRDs7QUFFRG5ELE1BQUFBLElBQUksQ0FBQzJJLElBQUwsR0FBWUEsSUFBSSxHQUFHLElBQW5CO0FBQ0EwM0IsTUFBQUEsaUJBQWlCLENBQUNxQixLQUFsQjtBQUNBMWhDLE1BQUFBLElBQUksQ0FBQ3dULFNBQUwsR0FBaUIsSUFBakI7QUFDQXJRLE1BQUFBLENBQUMsR0FBR3k2QixTQUFTLENBQUN6NkIsQ0FBRCxDQUFiLENBUnlDLENBUXZCOztBQUVsQnU5QixNQUFBQSxVQUFVLEdBQUdDLFVBQVUsR0FBRyxDQUExQjtBQUNBM2dDLE1BQUFBLElBQUksQ0FBQ2dkLE1BQUwsR0FBY2hkLElBQUksQ0FBQ2tKLENBQUwsR0FBUy9GLENBQUMsQ0FBQzgrQixPQUF6QjtBQUNBamlDLE1BQUFBLElBQUksQ0FBQ2lkLE1BQUwsR0FBY2pkLElBQUksQ0FBQ21KLENBQUwsR0FBU2hHLENBQUMsQ0FBQysrQixPQUF6Qjs7QUFFQWxpQyxNQUFBQSxJQUFJLENBQUN3aEMsR0FBTCxDQUFTaEUsS0FBVCxHQWR5QyxDQWN2Qjs7O0FBR2xCeDlCLE1BQUFBLElBQUksQ0FBQ3loQyxHQUFMLENBQVNqRSxLQUFUOztBQUVBajNCLE1BQUFBLFlBQVksQ0FBQ3M1QixZQUFZLEdBQUdwNEIsTUFBSCxHQUFZZ1AsUUFBekIsRUFBbUNta0IsV0FBVyxDQUFDLENBQUQsQ0FBOUMsRUFBbURvSCxPQUFuRCxFQUE0RC82QixjQUE1RCxFQUE0RSxJQUE1RSxDQUFaOztBQUVBakgsTUFBQUEsSUFBSSxDQUFDb1osTUFBTCxHQUFjcFosSUFBSSxDQUFDc1osTUFBTCxHQUFjLENBQTVCO0FBQ0E4RCxNQUFBQSxPQUFPLElBQUlBLE9BQU8sQ0FBQ3BkLElBQUQsQ0FBbEI7QUFDRCxLQTVKRDtBQUFBLFFBNkpJb2lDLFVBQVUsR0FBRyxTQUFTQSxVQUFULENBQW9Cai9CLENBQXBCLEVBQXVCO0FBQ3RDLFVBQUlpK0IsWUFBWSxDQUFDaitCLENBQUQsRUFBSSxDQUFKLENBQWhCLEVBQXdCO0FBQ3RCO0FBQ0Q7O0FBRUQwRCxNQUFBQSxlQUFlLENBQUNnNUIsWUFBWSxHQUFHcDRCLE1BQUgsR0FBWWdQLFFBQXpCLEVBQW1DbWtCLFdBQVcsQ0FBQyxDQUFELENBQTlDLEVBQW1Eb0gsT0FBbkQsRUFBNEQsSUFBNUQsQ0FBZjs7QUFFQSxVQUFJcGlCLFdBQVcsR0FBRzVmLElBQUksQ0FBQ3lZLFVBQUwsS0FBb0I5VixJQUFJLENBQUMyYixHQUFMLENBQVN0ZSxJQUFJLENBQUNrSixDQUFMLEdBQVNsSixJQUFJLENBQUNnZCxNQUF2QixJQUFpQyxDQUFqQyxJQUFzQ3JhLElBQUksQ0FBQzJiLEdBQUwsQ0FBU3RlLElBQUksQ0FBQ21KLENBQUwsR0FBU25KLElBQUksQ0FBQ2lkLE1BQXZCLElBQWlDLENBQTNGLENBQWxCO0FBQUEsVUFDSTtBQUNKb2xCLE1BQUFBLFNBQVMsR0FBR3pFLFNBQVMsQ0FBQ3o2QixDQUFELENBRnJCOztBQUlBLFVBQUksQ0FBQ3ljLFdBQUwsRUFBa0I7QUFDaEI1ZixRQUFBQSxJQUFJLENBQUN3aEMsR0FBTCxDQUFTaEUsS0FBVDs7QUFFQXg5QixRQUFBQSxJQUFJLENBQUN5aEMsR0FBTCxDQUFTakUsS0FBVDs7QUFFQSxZQUFJdjJCLGNBQWMsSUFBSW01QixXQUF0QixFQUFtQztBQUNqQ3gvQixVQUFBQSxJQUFJLENBQUNtZixXQUFMLENBQWlCLElBQWpCLEVBQXVCLFlBQVk7QUFDakM7QUFDQSxnQkFBSW5jLFFBQVEsS0FBS3M5QixXQUFiLEdBQTJCLEdBQTNCLElBQWtDLENBQUMvOUIsQ0FBQyxDQUFDaWQsZ0JBQXpDLEVBQTJEO0FBQ3pELGtCQUFJamQsQ0FBQyxDQUFDc0UsTUFBRixDQUFTNFksS0FBYixFQUFvQjtBQUNsQjtBQUNBbGQsZ0JBQUFBLENBQUMsQ0FBQ3NFLE1BQUYsQ0FBUzRZLEtBQVQ7QUFDRCxlQUhELE1BR08sSUFBSTVKLFFBQVEsQ0FBQzZKLFdBQWIsRUFBMEI7QUFDL0Isb0JBQUlOLGNBQWMsR0FBR3ZKLFFBQVEsQ0FBQzZKLFdBQVQsQ0FBcUIsYUFBckIsQ0FBckI7QUFDQU4sZ0JBQUFBLGNBQWMsQ0FBQ08sY0FBZixDQUE4QixPQUE5QixFQUF1QyxJQUF2QyxFQUE2QyxJQUE3QyxFQUFtRDFmLElBQW5ELEVBQXlELENBQXpELEVBQTREd2hDLFNBQVMsQ0FBQzdoQixPQUF0RSxFQUErRTZoQixTQUFTLENBQUM1aEIsT0FBekYsRUFBa0c0aEIsU0FBUyxDQUFDSixPQUE1RyxFQUFxSEksU0FBUyxDQUFDSCxPQUEvSCxFQUF3SSxLQUF4SSxFQUErSSxLQUEvSSxFQUFzSixLQUF0SixFQUE2SixLQUE3SixFQUFvSyxDQUFwSyxFQUF1SyxJQUF2SztBQUNBLytCLGdCQUFBQSxDQUFDLENBQUNzRSxNQUFGLENBQVNnRSxhQUFULENBQXVCdVUsY0FBdkI7QUFDRDtBQUNGO0FBQ0YsV0FaRDtBQWFEO0FBQ0Y7O0FBRURoZ0IsTUFBQUEsSUFBSSxDQUFDeVksVUFBTCxHQUFrQnpZLElBQUksQ0FBQ3NpQyxXQUFMLEdBQW1CdGlDLElBQUksQ0FBQ3dULFNBQUwsR0FBaUIsS0FBdEQ7QUFDQW9yQixNQUFBQSxNQUFNLElBQUksQ0FBQ2lCLFlBQVgsSUFBMkJRLGlCQUFpQixDQUFDa0MsT0FBbEIsQ0FBMEIsSUFBMUIsQ0FBM0I7QUFDQXZELE1BQUFBLFNBQVMsSUFBSXBmLFdBQWIsSUFBNEJvZixTQUFTLENBQUNoL0IsSUFBRCxDQUFyQztBQUNBc2QsTUFBQUEsU0FBUyxJQUFJQSxTQUFTLENBQUN0ZCxJQUFELEVBQU80ZixXQUFQLENBQXRCO0FBQ0QsS0FsTUQ7QUFBQSxRQW1NSTRpQixlQUFlLEdBQUcsU0FBU0EsZUFBVCxDQUF5QnIvQixDQUF6QixFQUE0QjtBQUNoRCxhQUFPQSxDQUFDLENBQUNxRSxPQUFGLElBQWFyRSxDQUFDLENBQUNxRSxPQUFGLENBQVV2QyxNQUFWLEdBQW1CLENBQWhDLEtBQXNDakYsSUFBSSxDQUFDc2lDLFdBQUwsR0FBbUIsSUFBekQsS0FBa0V4QyxjQUFjLENBQUMzOEIsQ0FBRCxFQUFJbkQsSUFBSSxDQUFDeVksVUFBVCxDQUF2RjtBQUNELEtBck1EO0FBQUEsUUFzTUlncUIsYUFBYSxHQUFHLFNBQVNBLGFBQVQsR0FBeUI7QUFDM0MsYUFBTyxDQUFDemlDLElBQUksQ0FBQ3NpQyxXQUFMLEdBQW1CLEtBQXBCLEtBQThCdkMsWUFBWSxDQUFDLy9CLElBQUQsQ0FBakQ7QUFDRCxLQXhNRDtBQUFBLFFBeU1JMGlDLFFBQVEsR0FBRyxTQUFTQSxRQUFULENBQWtCdi9CLENBQWxCLEVBQXFCO0FBQ2xDLFVBQUlpK0IsWUFBWSxDQUFDaitCLENBQUQsQ0FBaEIsRUFBcUI7QUFDbkI7QUFDRDs7QUFFRCxVQUFJK0YsQ0FBQyxHQUFHMDNCLFdBQVcsRUFBbkI7QUFBQSxVQUNJejNCLENBQUMsR0FBRzAzQixXQUFXLEVBRG5CO0FBRUFnQixNQUFBQSxPQUFPLENBQUMsQ0FBQzM0QixDQUFDLEdBQUc0M0IsT0FBTCxJQUFnQlgsV0FBakIsRUFBOEIsQ0FBQ2gzQixDQUFDLEdBQUc0M0IsT0FBTCxJQUFnQlosV0FBOUMsRUFBMkQsQ0FBM0QsQ0FBUDtBQUNBVyxNQUFBQSxPQUFPLEdBQUc1M0IsQ0FBVjtBQUNBNjNCLE1BQUFBLE9BQU8sR0FBRzUzQixDQUFWO0FBQ0F5MUIsTUFBQUEsTUFBTSxJQUFJeUIsaUJBQWlCLENBQUNrQyxPQUFsQixDQUEwQixJQUExQixDQUFWO0FBQ0QsS0FwTkQ7QUFBQSxRQXFOSUksUUFBUSxHQUFHLFNBQVNBLFFBQVQsQ0FBa0J4L0IsQ0FBbEIsRUFBcUI7QUFDbEMsVUFBSWkrQixZQUFZLENBQUNqK0IsQ0FBRCxDQUFoQixFQUFxQjtBQUNuQjtBQUNEOztBQUVEQSxNQUFBQSxDQUFDLEdBQUd5NkIsU0FBUyxDQUFDejZCLENBQUQsRUFBSThELGNBQUosQ0FBYjtBQUNBKzRCLE1BQUFBLE9BQU8sS0FBS1EsT0FBTyxHQUFHLElBQWYsQ0FBUDtBQUNBLFVBQUlvQyxVQUFVLEdBQUcsQ0FBQ3ovQixDQUFDLENBQUMwL0IsU0FBRixLQUFnQixDQUFoQixHQUFvQm5FLFVBQXBCLEdBQWlDdjdCLENBQUMsQ0FBQzAvQixTQUFGLEtBQWdCLENBQWhCLEdBQW9CaGlDLElBQUksQ0FBQzRKLFdBQXpCLEdBQXVDLENBQXpFLElBQThFcTBCLFVBQS9GO0FBQ0ErQyxNQUFBQSxPQUFPLENBQUMxK0IsQ0FBQyxDQUFDaVcsTUFBRixHQUFXd3BCLFVBQVosRUFBd0J6L0IsQ0FBQyxDQUFDbVcsTUFBRixHQUFXc3BCLFVBQW5DLEVBQStDLENBQS9DLENBQVA7QUFDQWhFLE1BQUFBLE1BQU0sSUFBSSxDQUFDaUIsWUFBWCxJQUEyQlEsaUJBQWlCLENBQUNrQyxPQUFsQixDQUEwQixJQUExQixDQUEzQjtBQUNELEtBL05EO0FBQUEsUUFnT0lPLE9BQU8sR0FBRyxTQUFTQSxPQUFULENBQWlCMy9CLENBQWpCLEVBQW9CO0FBQ2hDLFVBQUlpK0IsWUFBWSxDQUFDaitCLENBQUQsQ0FBaEIsRUFBcUI7QUFDbkI7QUFDRDs7QUFFRCxVQUFJK0YsQ0FBQyxHQUFHL0YsQ0FBQyxDQUFDOCtCLE9BQVY7QUFBQSxVQUNJOTRCLENBQUMsR0FBR2hHLENBQUMsQ0FBQysrQixPQURWO0FBQUEsVUFFSTduQixFQUFFLEdBQUduUixDQUFDLEdBQUdsSixJQUFJLENBQUNrSixDQUZsQjtBQUFBLFVBR0lvUixFQUFFLEdBQUduUixDQUFDLEdBQUduSixJQUFJLENBQUNtSixDQUhsQjtBQUlBbkosTUFBQUEsSUFBSSxDQUFDa0osQ0FBTCxHQUFTQSxDQUFUO0FBQ0FsSixNQUFBQSxJQUFJLENBQUNtSixDQUFMLEdBQVNBLENBQVQ7QUFDQW8zQixNQUFBQSxLQUFLLEdBQUcsSUFBUjtBQUNBLE9BQUNsbUIsRUFBRSxJQUFJQyxFQUFQLEtBQWN5bkIscUJBQXFCLENBQUMxbkIsRUFBRCxFQUFLQyxFQUFMLENBQW5DO0FBQ0QsS0E3T0Q7QUFBQSxRQThPSXlvQixRQUFRLEdBQUcsU0FBU0EsUUFBVCxDQUFrQjUvQixDQUFsQixFQUFxQjtBQUNsQ25ELE1BQUFBLElBQUksQ0FBQ2dILEtBQUwsR0FBYTdELENBQWI7QUFDQXU4QixNQUFBQSxPQUFPLENBQUMxL0IsSUFBRCxDQUFQO0FBQ0QsS0FqUEQ7QUFBQSxRQWtQSWdqQyxXQUFXLEdBQUcsU0FBU0EsV0FBVCxDQUFxQjcvQixDQUFyQixFQUF3QjtBQUN4Q25ELE1BQUFBLElBQUksQ0FBQ2dILEtBQUwsR0FBYTdELENBQWI7QUFDQXc4QixNQUFBQSxVQUFVLENBQUMzL0IsSUFBRCxDQUFWO0FBQ0QsS0FyUEQ7QUFBQSxRQXNQSWlqQyxRQUFRLEdBQUcsU0FBU0EsUUFBVCxDQUFrQjkvQixDQUFsQixFQUFxQjtBQUNsQyxhQUFPaStCLFlBQVksQ0FBQ2orQixDQUFELENBQVosSUFBbUJ5NkIsU0FBUyxDQUFDejZCLENBQUQsRUFBSThELGNBQUosQ0FBVCxJQUFnQzBaLE9BQU8sQ0FBQzNnQixJQUFELENBQWpFO0FBQ0QsS0F4UEQ7O0FBMFBBcWdDLElBQUFBLGlCQUFpQixHQUFHcmdDLElBQUksQ0FBQ2tqQyxHQUFMLEdBQVd0aUMsSUFBSSxDQUFDbWYsV0FBTCxDQUFpQjhlLFdBQVcsSUFBSSxJQUFoQyxFQUFzQzBDLFVBQXRDLEVBQWtERyxLQUFsRCxFQUEvQjtBQUNBMWhDLElBQUFBLElBQUksQ0FBQ29aLE1BQUwsR0FBY3BaLElBQUksQ0FBQ3NaLE1BQUwsR0FBYyxDQUE1QjtBQUNBdFosSUFBQUEsSUFBSSxDQUFDd2hDLEdBQUwsR0FBV3hFLGdCQUFnQixDQUFDLENBQUQsRUFBSSxFQUFKLEVBQVEsSUFBUixDQUEzQjtBQUNBaDlCLElBQUFBLElBQUksQ0FBQ3loQyxHQUFMLEdBQVd6RSxnQkFBZ0IsQ0FBQyxDQUFELEVBQUksRUFBSixFQUFRLElBQVIsQ0FBM0I7QUFDQWg5QixJQUFBQSxJQUFJLENBQUM4Z0MsT0FBTCxHQUFlRixXQUFmO0FBQ0E1Z0MsSUFBQUEsSUFBSSxDQUFDK2dDLE9BQUwsR0FBZUYsV0FBZjtBQUNBN2dDLElBQUFBLElBQUksQ0FBQ3lZLFVBQUwsR0FBa0J6WSxJQUFJLENBQUNzaUMsV0FBTCxHQUFtQnRpQyxJQUFJLENBQUN3VCxTQUFMLEdBQWlCLEtBQXREOztBQUVBeFQsSUFBQUEsSUFBSSxDQUFDd1IsTUFBTCxHQUFjLFVBQVVyTyxDQUFWLEVBQWE7QUFDekIsVUFBSSxDQUFDbkQsSUFBSSxDQUFDbWpDLFNBQVYsRUFBcUI7QUFDbkI1OEIsUUFBQUEsWUFBWSxDQUFDMDZCLFVBQVUsR0FBR3hxQixRQUFILEdBQWNoUCxNQUF6QixFQUFpQyxRQUFqQyxFQUEyQ28wQixTQUEzQyxDQUFaOztBQUVBNTRCLFFBQUFBLElBQUksQ0FBQ3dQLE9BQUwsQ0FBYSxRQUFiLEtBQTBCLENBQTFCLElBQStCbE0sWUFBWSxDQUFDMDZCLFVBQVUsR0FBR3hxQixRQUFILEdBQWNoUCxNQUF6QixFQUFpQyxRQUFqQyxFQUEyQ2k3QixRQUEzQyxFQUFxRHo3QixjQUFyRCxFQUFxRVIsT0FBckUsQ0FBM0M7QUFDQXhELFFBQUFBLElBQUksQ0FBQ3dQLE9BQUwsQ0FBYSxPQUFiLEtBQXlCLENBQXpCLElBQThCbE0sWUFBWSxDQUFDa0IsTUFBRCxFQUFTLE9BQVQsRUFBa0JrN0IsUUFBbEIsRUFBNEIxN0IsY0FBNUIsRUFBNENSLE9BQTVDLENBQTFDOztBQUVBLFlBQUl4RCxJQUFJLENBQUN3UCxPQUFMLENBQWEsT0FBYixLQUF5QixDQUF6QixJQUE4QjhuQixRQUE5QixJQUEwQ3QzQixJQUFJLENBQUN3UCxPQUFMLENBQWEsU0FBYixLQUEyQixDQUF6RSxFQUE0RTtBQUMxRWxNLFVBQUFBLFlBQVksQ0FBQ2tCLE1BQUQsRUFBU216QixXQUFXLENBQUMsQ0FBRCxDQUFwQixFQUF5QnVILFFBQXpCLEVBQW1DbDdCLGNBQW5DLEVBQW1EUixPQUFuRCxDQUFaOztBQUVBRixVQUFBQSxZQUFZLENBQUNrUSxRQUFELEVBQVdta0IsV0FBVyxDQUFDLENBQUQsQ0FBdEIsRUFBMkJ3SCxVQUEzQixDQUFaOztBQUVBNzdCLFVBQUFBLFlBQVksQ0FBQ2tRLFFBQUQsRUFBV21rQixXQUFXLENBQUMsQ0FBRCxDQUF0QixFQUEyQndILFVBQTNCLENBQVo7O0FBRUFoQyxVQUFBQSxXQUFXLElBQUk3NUIsWUFBWSxDQUFDa0IsTUFBRCxFQUFTLE9BQVQsRUFBa0IwNUIsWUFBbEIsRUFBZ0MsS0FBaEMsRUFBdUMsSUFBdkMsQ0FBM0I7QUFDQXhnQixVQUFBQSxPQUFPLElBQUlwYSxZQUFZLENBQUNrQixNQUFELEVBQVMsT0FBVCxFQUFrQnc3QixRQUFsQixDQUF2QjtBQUNBbkQsVUFBQUEsY0FBYyxJQUFJdjVCLFlBQVksQ0FBQ2tRLFFBQUQsRUFBVyxjQUFYLEVBQTJCK3JCLGVBQTNCLENBQTlCO0FBQ0F6QyxVQUFBQSxZQUFZLElBQUl4NUIsWUFBWSxDQUFDa1EsUUFBRCxFQUFXLFlBQVgsRUFBeUJnc0IsYUFBekIsQ0FBNUI7QUFDQS9DLFVBQUFBLE9BQU8sSUFBSW41QixZQUFZLENBQUNrQixNQUFELEVBQVMreUIsWUFBWSxHQUFHLE9BQXhCLEVBQWlDdUksUUFBakMsQ0FBdkI7QUFDQXBELFVBQUFBLFVBQVUsSUFBSXA1QixZQUFZLENBQUNrQixNQUFELEVBQVMreUIsWUFBWSxHQUFHLE9BQXhCLEVBQWlDd0ksV0FBakMsQ0FBMUI7QUFDQXpsQixVQUFBQSxNQUFNLElBQUloWCxZQUFZLENBQUNrQixNQUFELEVBQVMreUIsWUFBWSxHQUFHLE1BQXhCLEVBQWdDc0ksT0FBaEMsQ0FBdEI7QUFDRDs7QUFFRDlpQyxRQUFBQSxJQUFJLENBQUNtakMsU0FBTCxHQUFpQixJQUFqQjtBQUNBaGdDLFFBQUFBLENBQUMsSUFBSUEsQ0FBQyxDQUFDRixJQUFQLElBQWVrL0IsUUFBUSxDQUFDaC9CLENBQUQsQ0FBdkI7QUFDQTg4QixRQUFBQSxRQUFRLElBQUlBLFFBQVEsQ0FBQ2pnQyxJQUFELENBQXBCO0FBQ0Q7O0FBRUQsYUFBT0EsSUFBUDtBQUNELEtBN0JEOztBQStCQUEsSUFBQUEsSUFBSSxDQUFDb1IsT0FBTCxHQUFlLFlBQVk7QUFDekIsVUFBSXBSLElBQUksQ0FBQ21qQyxTQUFULEVBQW9CO0FBQ2xCO0FBQ0FwSSxRQUFBQSxVQUFVLENBQUNxSSxNQUFYLENBQWtCLFVBQVVDLENBQVYsRUFBYTtBQUM3QixpQkFBT0EsQ0FBQyxLQUFLcmpDLElBQU4sSUFBY3c3QixXQUFXLENBQUM2SCxDQUFDLENBQUM1N0IsTUFBSCxDQUFoQztBQUNELFNBRkQsRUFFR3hDLE1BRkgsSUFFYTRCLGVBQWUsQ0FBQ282QixVQUFVLEdBQUd4cUIsUUFBSCxHQUFjaFAsTUFBekIsRUFBaUMsUUFBakMsRUFBMkNvMEIsU0FBM0MsQ0FGNUI7O0FBSUEsWUFBSTc3QixJQUFJLENBQUN3VCxTQUFULEVBQW9CO0FBQ2xCeFQsVUFBQUEsSUFBSSxDQUFDd2hDLEdBQUwsQ0FBU2hFLEtBQVQ7O0FBRUF4OUIsVUFBQUEsSUFBSSxDQUFDeWhDLEdBQUwsQ0FBU2pFLEtBQVQ7O0FBRUEzMkIsVUFBQUEsZUFBZSxDQUFDZzVCLFlBQVksR0FBR3A0QixNQUFILEdBQVlnUCxRQUF6QixFQUFtQ21rQixXQUFXLENBQUMsQ0FBRCxDQUE5QyxFQUFtRG9ILE9BQW5ELEVBQTRELElBQTVELENBQWY7QUFDRDs7QUFFRG43QixRQUFBQSxlQUFlLENBQUNvNkIsVUFBVSxHQUFHeHFCLFFBQUgsR0FBY2hQLE1BQXpCLEVBQWlDLFFBQWpDLEVBQTJDaTdCLFFBQTNDLEVBQXFEajhCLE9BQXJELENBQWY7O0FBRUFJLFFBQUFBLGVBQWUsQ0FBQ1ksTUFBRCxFQUFTLE9BQVQsRUFBa0JrN0IsUUFBbEIsRUFBNEJsOEIsT0FBNUIsQ0FBZjs7QUFFQUksUUFBQUEsZUFBZSxDQUFDWSxNQUFELEVBQVNtekIsV0FBVyxDQUFDLENBQUQsQ0FBcEIsRUFBeUJ1SCxRQUF6QixFQUFtQzE3QixPQUFuQyxDQUFmOztBQUVBSSxRQUFBQSxlQUFlLENBQUM0UCxRQUFELEVBQVdta0IsV0FBVyxDQUFDLENBQUQsQ0FBdEIsRUFBMkJ3SCxVQUEzQixDQUFmOztBQUVBdjdCLFFBQUFBLGVBQWUsQ0FBQzRQLFFBQUQsRUFBV21rQixXQUFXLENBQUMsQ0FBRCxDQUF0QixFQUEyQndILFVBQTNCLENBQWY7O0FBRUF2N0IsUUFBQUEsZUFBZSxDQUFDWSxNQUFELEVBQVMsT0FBVCxFQUFrQjA1QixZQUFsQixFQUFnQyxJQUFoQyxDQUFmOztBQUVBdDZCLFFBQUFBLGVBQWUsQ0FBQ1ksTUFBRCxFQUFTLE9BQVQsRUFBa0J3N0IsUUFBbEIsQ0FBZjs7QUFFQXA4QixRQUFBQSxlQUFlLENBQUM0UCxRQUFELEVBQVcsY0FBWCxFQUEyQityQixlQUEzQixDQUFmOztBQUVBMzdCLFFBQUFBLGVBQWUsQ0FBQzRQLFFBQUQsRUFBVyxZQUFYLEVBQXlCZ3NCLGFBQXpCLENBQWY7O0FBRUE1N0IsUUFBQUEsZUFBZSxDQUFDWSxNQUFELEVBQVMreUIsWUFBWSxHQUFHLE9BQXhCLEVBQWlDdUksUUFBakMsQ0FBZjs7QUFFQWw4QixRQUFBQSxlQUFlLENBQUNZLE1BQUQsRUFBUyt5QixZQUFZLEdBQUcsT0FBeEIsRUFBaUN3SSxXQUFqQyxDQUFmOztBQUVBbjhCLFFBQUFBLGVBQWUsQ0FBQ1ksTUFBRCxFQUFTK3lCLFlBQVksR0FBRyxNQUF4QixFQUFnQ3NJLE9BQWhDLENBQWY7O0FBRUE5aUMsUUFBQUEsSUFBSSxDQUFDbWpDLFNBQUwsR0FBaUJuakMsSUFBSSxDQUFDd1QsU0FBTCxHQUFpQnhULElBQUksQ0FBQ3lZLFVBQUwsR0FBa0IsS0FBcEQ7QUFDQXluQixRQUFBQSxTQUFTLElBQUlBLFNBQVMsQ0FBQ2xnQyxJQUFELENBQXRCO0FBQ0Q7QUFDRixLQTFDRDs7QUE0Q0FBLElBQUFBLElBQUksQ0FBQzhkLElBQUwsR0FBWSxZQUFZO0FBQ3RCOWQsTUFBQUEsSUFBSSxDQUFDb1IsT0FBTDs7QUFFQSxVQUFJcE0sQ0FBQyxHQUFHKzFCLFVBQVUsQ0FBQ3RvQixPQUFYLENBQW1CelMsSUFBbkIsQ0FBUjs7QUFFQWdGLE1BQUFBLENBQUMsSUFBSSxDQUFMLElBQVUrMUIsVUFBVSxDQUFDaDFCLE1BQVgsQ0FBa0JmLENBQWxCLEVBQXFCLENBQXJCLENBQVY7QUFDQTIxQixNQUFBQSxXQUFXLEtBQUszNkIsSUFBaEIsS0FBeUIyNkIsV0FBVyxHQUFHLENBQXZDO0FBQ0QsS0FQRDs7QUFTQUksSUFBQUEsVUFBVSxDQUFDdDFCLElBQVgsQ0FBZ0J6RixJQUFoQjs7QUFFQTYvQixJQUFBQSxZQUFZLElBQUlyRSxXQUFXLENBQUMvekIsTUFBRCxDQUEzQixLQUF3Q2t6QixXQUFXLEdBQUczNkIsSUFBdEQ7QUFDQUEsSUFBQUEsSUFBSSxDQUFDd1IsTUFBTCxDQUFZeEssS0FBWjtBQUNELEdBbFpEOztBQW9aQWl6QixFQUFBQSxZQUFZLENBQUNpRSxRQUFELEVBQVcsQ0FBQztBQUN0QmxFLElBQUFBLEdBQUcsRUFBRSxXQURpQjtBQUV0QnptQixJQUFBQSxHQUFHLEVBQUUsU0FBU0EsR0FBVCxHQUFlO0FBQ2xCLGFBQU8sS0FBS2l1QixHQUFMLENBQVNwZixXQUFULEVBQVA7QUFDRDtBQUpxQixHQUFELEVBS3BCO0FBQ0Q0WCxJQUFBQSxHQUFHLEVBQUUsV0FESjtBQUVEem1CLElBQUFBLEdBQUcsRUFBRSxTQUFTQSxHQUFULEdBQWU7QUFDbEIsYUFBTyxLQUFLa3VCLEdBQUwsQ0FBU3JmLFdBQVQsRUFBUDtBQUNEO0FBSkEsR0FMb0IsQ0FBWCxDQUFaOztBQVlBLFNBQU84YixRQUFQO0FBQ0QsQ0F4YWtDLEVBQTVCO0FBeWFQQSxRQUFRLENBQUNwYSxPQUFULEdBQW1CLFFBQW5COztBQUVBb2EsUUFBUSxDQUFDMzlCLE1BQVQsR0FBa0IsVUFBVTJLLElBQVYsRUFBZ0I7QUFDaEMsU0FBTyxJQUFJZ3pCLFFBQUosQ0FBYWh6QixJQUFiLENBQVA7QUFDRCxDQUZEOztBQUlBZ3pCLFFBQVEsQ0FBQzdhLFFBQVQsR0FBb0JwUixTQUFwQjs7QUFFQWlzQixRQUFRLENBQUNvRixNQUFULEdBQWtCLFlBQVk7QUFDNUIsU0FBT3ZJLFVBQVUsQ0FBQ2xWLEtBQVgsRUFBUDtBQUNELENBRkQ7O0FBSUFxWSxRQUFRLENBQUNxRixPQUFULEdBQW1CLFVBQVUzZ0IsRUFBVixFQUFjO0FBQy9CLFNBQU9tWSxVQUFVLENBQUNxSSxNQUFYLENBQWtCLFVBQVVDLENBQVYsRUFBYTtBQUNwQyxXQUFPQSxDQUFDLENBQUNuNEIsSUFBRixDQUFPMFgsRUFBUCxLQUFjQSxFQUFyQjtBQUNELEdBRk0sRUFFSixDQUZJLENBQVA7QUFHRCxDQUpEOztBQU1BM2dCLFFBQVEsTUFBTXJCLElBQUksQ0FBQ3NCLGNBQUwsQ0FBb0JnOEIsUUFBcEIsQ0FBZDs7Ozs7QUMzcEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLElBQUl0OUIsa0JBQUo7QUFBQSxJQUNJTyx5QkFESjtBQUFBLElBRUlOLGlCQUZKO0FBQUEsSUFHSUMsaUJBSEo7QUFBQSxJQUlJdzVCLG1CQUpKO0FBQUEsSUFLSXQ1QixrQkFMSjtBQUFBLElBTUkwNUIsa0JBTko7QUFBQSxJQU9JOEksWUFQSjtBQUFBLElBUUluaUMsUUFSSjtBQUFBLElBU0lnNUIsbUJBVEo7QUFBQSxJQVVJb0osTUFWSjtBQUFBLElBV0lDLGFBWEo7QUFBQSxJQVlJQyxXQVpKO0FBQUEsSUFhSUMsY0FiSjtBQUFBLElBY0lwaEMsY0FkSjtBQUFBLElBZUlxaEMsRUFmSjtBQUFBLElBZ0JJQyxVQWhCSjtBQUFBLElBaUJJQyxXQWpCSjtBQUFBLElBa0JJQyxZQWxCSjtBQUFBLElBbUJJQyxLQW5CSjtBQUFBLElBb0JJQyxtQkFwQko7QUFBQSxJQXFCSUMsYUFyQko7QUFBQSxJQXNCSXhKLHdCQXRCSjtBQUFBLElBdUJJeUosbUJBdkJKO0FBQUEsSUF3QklDLGlCQXhCSjtBQUFBLElBeUJJQyxnQkF6Qko7QUFBQSxJQTBCSUMsVUExQko7QUFBQSxJQTJCSUMsZUEzQko7QUFBQSxJQTRCSTtBQUNKMUoscUJBQVEsR0FBRyxDQTdCWDtBQUFBLElBOEJJbDNCLHFCQUFRLEdBQUdDLElBQUksQ0FBQ0MsR0E5QnBCO0FBQUEsSUErQkkyZ0MsTUFBTSxHQUFHN2dDLHFCQUFRLEVBL0JyQjtBQUFBLElBZ0NJOGdDLGVBQWUsR0FBRyxDQWhDdEI7QUFBQSxJQWlDSUMsUUFBUSxHQUFHLENBakNmO0FBQUEsSUFrQ0lDLG1CQUFtQixHQUFHLFNBQVNBLG1CQUFULEdBQStCO0FBQ3ZELFNBQU9oQixjQUFjLEdBQUcsQ0FBeEI7QUFDRCxDQXBDRDtBQUFBLElBcUNJaUIsaUJBQWlCLEdBQUcsU0FBU0EsaUJBQVQsR0FBNkI7QUFDbkQsU0FBT2pCLGNBQWMsR0FBRyxDQUF4QjtBQUNELENBdkNEO0FBQUEsSUF3Q0kvSSx5QkFBWSxHQUFHLFNBQVNBLFlBQVQsQ0FBc0J2RixDQUF0QixFQUF5QjtBQUMxQyxTQUFPQSxDQUFQO0FBQ0QsQ0ExQ0Q7QUFBQSxJQTJDSTV5QixNQUFNLEdBQUcsU0FBU0EsTUFBVCxDQUFnQk4sS0FBaEIsRUFBdUI7QUFDbEMsU0FBT08sSUFBSSxDQUFDQyxLQUFMLENBQVdSLEtBQUssR0FBRyxNQUFuQixJQUE2QixNQUE3QixJQUF1QyxDQUE5QztBQUNELENBN0NEO0FBQUEsSUE4Q0lMLGFBQWEsR0FBRyxTQUFTQSxhQUFULEdBQXlCO0FBQzNDLFNBQU8sT0FBT0MsTUFBUCxLQUFrQixXQUF6QjtBQUNELENBaEREO0FBQUEsSUFpRElDLHFCQUFRLEdBQUcsU0FBU0EsUUFBVCxHQUFvQjtBQUNqQyxTQUFPckIsa0JBQUksSUFBSW1CLGFBQWEsT0FBT25CLGtCQUFJLEdBQUdvQixNQUFNLENBQUNwQixJQUFyQixDQUFiLElBQTJDQSxrQkFBSSxDQUFDc0IsY0FBaEQsSUFBa0V0QixrQkFBakY7QUFDRCxDQW5ERDtBQUFBLElBb0RJNDZCLHdCQUFXLEdBQUcsU0FBU0EsV0FBVCxDQUFxQnI0QixDQUFyQixFQUF3QjtBQUN4QyxTQUFPLENBQUMsQ0FBQyxDQUFDdTNCLGtCQUFLLENBQUNqb0IsT0FBTixDQUFjdFAsQ0FBZCxDQUFWO0FBQ0QsQ0F0REQ7QUFBQSxJQXVESTJoQyxjQUFjLEdBQUcsU0FBU0EsY0FBVCxDQUF3QnQrQixPQUF4QixFQUFpQztBQUNwRCxTQUFPKzBCLGFBQWEsQ0FBQy8wQixPQUFELEVBQVUsdUJBQVYsQ0FBYixLQUFvRGcxQix3QkFBVyxDQUFDaDFCLE9BQUQsQ0FBWCxHQUF1QixZQUFZO0FBQzVGdStCLElBQUFBLFdBQVcsQ0FBQzU2QixLQUFaLEdBQW9CdEosaUJBQUksQ0FBQ3lKLFVBQXpCO0FBQ0F5NkIsSUFBQUEsV0FBVyxDQUFDeDZCLE1BQVosR0FBcUIxSixpQkFBSSxDQUFDNEosV0FBMUI7QUFDQSxXQUFPczZCLFdBQVA7QUFDRCxHQUowRCxHQUl2RCxZQUFZO0FBQ2QsV0FBT3I1QixVQUFVLENBQUNsRixPQUFELENBQWpCO0FBQ0QsR0FOTSxDQUFQO0FBT0QsQ0EvREQ7QUFBQSxJQWdFSXcrQixZQUFZLEdBQUcsU0FBU0EsWUFBVCxDQUFzQkMsUUFBdEIsRUFBZ0NoRSxVQUFoQyxFQUE0QzlKLElBQTVDLEVBQWtEO0FBQ25FLE1BQUl6WCxDQUFDLEdBQUd5WCxJQUFJLENBQUN6WCxDQUFiO0FBQUEsTUFDSTBTLEVBQUUsR0FBRytFLElBQUksQ0FBQy9FLEVBRGQ7QUFBQSxNQUVJdGtCLENBQUMsR0FBR3FwQixJQUFJLENBQUNycEIsQ0FGYjtBQUdBLFNBQU8sQ0FBQ0EsQ0FBQyxHQUFHeXRCLGFBQWEsQ0FBQzBKLFFBQUQsRUFBVyx1QkFBWCxDQUFsQixJQUF5RCxZQUFZO0FBQzFFLFdBQU9uM0IsQ0FBQyxHQUFHNFIsQ0FBSCxDQUFSO0FBQ0QsR0FGTSxHQUVILFlBQVk7QUFDZCxXQUFPLENBQUN1aEIsVUFBVSxHQUFHcGdDLGlCQUFJLENBQUMsVUFBVXV4QixFQUFYLENBQVAsR0FBd0I2UyxRQUFRLENBQUMsV0FBVzdTLEVBQVosQ0FBM0MsS0FBK0QsQ0FBdEU7QUFDRCxHQUpEO0FBS0QsQ0F6RUQ7QUFBQSxJQTBFSThTLGVBQWUsR0FBRyxTQUFTQSxlQUFULENBQXlCMStCLE9BQXpCLEVBQWtDeTZCLFVBQWxDLEVBQThDO0FBQ2xFLFNBQU8sQ0FBQ0EsVUFBRCxJQUFlLENBQUNoRyxnQkFBQSxDQUFpQnowQixPQUFqQixDQUFoQixHQUE0Q3MrQixjQUFjLENBQUN0K0IsT0FBRCxDQUExRCxHQUFzRSxZQUFZO0FBQ3ZGLFdBQU91K0IsV0FBUDtBQUNELEdBRkQ7QUFHRCxDQTlFRDtBQUFBLElBK0VJSSxVQUFVLEdBQUcsU0FBU0EsVUFBVCxDQUFvQjMrQixPQUFwQixFQUE2QjQrQixLQUE3QixFQUFvQztBQUNuRCxNQUFJemEsQ0FBQyxHQUFHeWEsS0FBSyxDQUFDemEsQ0FBZDtBQUFBLE1BQ0l5SCxFQUFFLEdBQUdnVCxLQUFLLENBQUNoVCxFQURmO0FBQUEsTUFFSTFTLENBQUMsR0FBRzBsQixLQUFLLENBQUMxbEIsQ0FGZDtBQUFBLE1BR0k1UixDQUFDLEdBQUdzM0IsS0FBSyxDQUFDdDNCLENBSGQ7QUFJQSxTQUFPLENBQUM2YyxDQUFDLEdBQUcsV0FBV3lILEVBQWhCLE1BQXdCdGtCLENBQUMsR0FBR3l0QixhQUFhLENBQUMvMEIsT0FBRCxFQUFVbWtCLENBQVYsQ0FBekMsSUFBeUQ3YyxDQUFDLEtBQUtnM0IsY0FBYyxDQUFDdCtCLE9BQUQsQ0FBZCxHQUEwQmtaLENBQTFCLENBQS9ELEdBQThGOGIsd0JBQVcsQ0FBQ2gxQixPQUFELENBQVgsR0FBdUIsQ0FBQzh6QixtQkFBTSxDQUFDM1AsQ0FBRCxDQUFOLElBQWEzcEIsa0JBQUssQ0FBQzJwQixDQUFELENBQW5CLEtBQTJCOXBCLGlCQUFJLENBQUMsVUFBVXV4QixFQUFYLENBQUosSUFBc0JrSSxtQkFBTSxDQUFDLFdBQVdsSSxFQUFaLENBQTVCLElBQStDcHhCLGtCQUFLLENBQUMsV0FBV294QixFQUFaLENBQS9FLENBQXZCLEdBQXlINXJCLE9BQU8sQ0FBQ21rQixDQUFELENBQVAsR0FBYW5rQixPQUFPLENBQUMsV0FBVzRyQixFQUFaLENBQWxQO0FBQ0QsQ0FyRkQ7QUFBQSxJQXNGSWlULG1CQUFtQixHQUFHLFNBQVNBLG1CQUFULENBQTZCOS9CLElBQTdCLEVBQW1DKy9CLE1BQW5DLEVBQTJDO0FBQ25FLE9BQUssSUFBSXRnQyxDQUFDLEdBQUcsQ0FBYixFQUFnQkEsQ0FBQyxHQUFHZy9CLFlBQVksQ0FBQy8rQixNQUFqQyxFQUF5Q0QsQ0FBQyxJQUFJLENBQTlDLEVBQWlEO0FBQy9DLEtBQUMsQ0FBQ3NnQyxNQUFELElBQVcsQ0FBQ0EsTUFBTSxDQUFDN3lCLE9BQVAsQ0FBZXV4QixZQUFZLENBQUNoL0IsQ0FBQyxHQUFHLENBQUwsQ0FBM0IsQ0FBYixLQUFxRE8sSUFBSSxDQUFDeStCLFlBQVksQ0FBQ2gvQixDQUFELENBQWIsRUFBa0JnL0IsWUFBWSxDQUFDaC9CLENBQUMsR0FBRyxDQUFMLENBQTlCLEVBQXVDZy9CLFlBQVksQ0FBQ2gvQixDQUFDLEdBQUcsQ0FBTCxDQUFuRCxDQUF6RDtBQUNEO0FBQ0YsQ0ExRkQ7QUFBQSxJQTJGSThmLFNBQVMsR0FBRyxTQUFTQSxTQUFULENBQW1CMWlCLEtBQW5CLEVBQTBCO0FBQ3hDLFNBQU8sT0FBT0EsS0FBUCxLQUFpQixRQUF4QjtBQUNELENBN0ZEO0FBQUEsSUE4RklELFdBQVcsR0FBRyxTQUFTQSxXQUFULENBQXFCQyxLQUFyQixFQUE0QjtBQUM1QyxTQUFPLE9BQU9BLEtBQVAsS0FBaUIsVUFBeEI7QUFDRCxDQWhHRDtBQUFBLElBaUdJMmlCLFNBQVMsR0FBRyxTQUFTQSxTQUFULENBQW1CM2lCLEtBQW5CLEVBQTBCO0FBQ3hDLFNBQU8sT0FBT0EsS0FBUCxLQUFpQixRQUF4QjtBQUNELENBbkdEO0FBQUEsSUFvR0lDLFNBQVMsR0FBRyxTQUFTQSxTQUFULENBQW1CRCxLQUFuQixFQUEwQjtBQUN4QyxTQUFPLFFBQU9BLEtBQVAsTUFBaUIsUUFBeEI7QUFDRCxDQXRHRDtBQUFBLElBdUdJbWpDLFdBQVcsR0FBRyxTQUFTQSxXQUFULENBQXFCbmpDLEtBQXJCLEVBQTRCO0FBQzVDLFNBQU9ELFdBQVcsQ0FBQ0MsS0FBRCxDQUFYLElBQXNCQSxLQUFLLEVBQWxDO0FBQ0QsQ0F6R0Q7QUFBQSxJQTBHSW9qQyxZQUFZLEdBQUcsU0FBU0EsWUFBVCxDQUFzQkMsRUFBdEIsRUFBMEJDLEVBQTFCLEVBQThCO0FBQy9DLFNBQU8sWUFBWTtBQUNqQixRQUFJQyxPQUFPLEdBQUdKLFdBQVcsQ0FBQ0UsRUFBRCxDQUF6QjtBQUFBLFFBQ0lHLE9BQU8sR0FBR0wsV0FBVyxDQUFDRyxFQUFELENBRHpCOztBQUdBLFdBQU8sWUFBWTtBQUNqQkgsTUFBQUEsV0FBVyxDQUFDSSxPQUFELENBQVg7O0FBRUFKLE1BQUFBLFdBQVcsQ0FBQ0ssT0FBRCxDQUFYO0FBQ0QsS0FKRDtBQUtELEdBVEQ7QUFVRCxDQXJIRDtBQUFBLElBc0hJQyxhQUFhLEdBQUcsU0FBU0EsYUFBVCxDQUF1QkMsU0FBdkIsRUFBa0MzZixRQUFsQyxFQUE0Q3ViLEtBQTVDLEVBQW1EO0FBQ3JFLFNBQU9vRSxTQUFTLElBQUlBLFNBQVMsQ0FBQzFnQixRQUFWLENBQW1CZSxRQUFRLEdBQUcsQ0FBSCxHQUFPLENBQWxDLENBQWIsSUFBcUR1YixLQUFyRCxJQUE4RG9FLFNBQVMsQ0FBQ3BFLEtBQVYsRUFBckU7QUFDRCxDQXhIRDtBQUFBLElBeUhJcUUsU0FBUyxHQUFHLFNBQVNBLFNBQVQsQ0FBbUIvbEMsSUFBbkIsRUFBeUJ1RixJQUF6QixFQUErQjtBQUM3QyxNQUFJdkYsSUFBSSxDQUFDMFcsT0FBVCxFQUFrQjtBQUNoQixRQUFJckwsTUFBTSxHQUFHOUYsSUFBSSxDQUFDdkYsSUFBRCxDQUFqQjtBQUNBcUwsSUFBQUEsTUFBTSxJQUFJQSxNQUFNLENBQUMyNkIsU0FBakIsS0FBK0JobUMsSUFBSSxDQUFDaW1DLGlCQUFMLEdBQXlCNTZCLE1BQXhEO0FBQ0Q7QUFDRixDQTlIRDtBQUFBLElBK0hJb1osSUFBSSxHQUFHOWhCLElBQUksQ0FBQzJiLEdBL0hoQjtBQUFBLElBZ0lJcWQsd0JBQVcsR0FBRyxZQWhJbEI7QUFBQSxJQWlJSUMsdUJBQVUsR0FBRyxXQWpJakI7QUFBQSxJQWtJSXNLLEtBQUssR0FBRyxNQWxJWjtBQUFBLElBbUlJQyxJQUFJLEdBQUcsS0FuSVg7QUFBQSxJQW9JSUMsTUFBTSxHQUFHLE9BcEliO0FBQUEsSUFxSUlDLE9BQU8sR0FBRyxRQXJJZDtBQUFBLElBc0lJQyxNQUFNLEdBQUcsT0F0SWI7QUFBQSxJQXVJSUMsT0FBTyxHQUFHLFFBdklkO0FBQUEsSUF3SUlDLE1BQU0sR0FBRyxPQXhJYjtBQUFBLElBeUlJQyxLQUFLLEdBQUcsTUF6SVo7QUFBQSxJQTBJSUMsSUFBSSxHQUFHLEtBMUlYO0FBQUEsSUEySUlDLE9BQU8sR0FBRyxRQTNJZDtBQUFBLElBNElJQyxRQUFRLEdBQUcsU0E1SWY7QUFBQSxJQTZJSUMsT0FBTyxHQUFHLFFBN0lkO0FBQUEsSUE4SUlDLE1BQU0sR0FBRyxPQTlJYjtBQUFBLElBK0lJQyxPQUFPLEdBQUcsUUEvSWQ7QUFBQSxJQWdKSUMsR0FBRyxHQUFHLElBaEpWO0FBQUEsSUFpSklyOUIsaUJBQWlCLEdBQUcsU0FBU0EsaUJBQVQsQ0FBMkJuRCxPQUEzQixFQUFvQztBQUMxRCxTQUFPM0YsaUJBQUksQ0FBQytJLGdCQUFMLENBQXNCcEQsT0FBdEIsQ0FBUDtBQUNELENBbkpEO0FBQUEsSUFvSkl5Z0MsaUJBQWlCLEdBQUcsU0FBU0EsaUJBQVQsQ0FBMkJ6Z0MsT0FBM0IsRUFBb0M7QUFDMUQ7QUFDQSxNQUFJd0ksUUFBUSxHQUFHckYsaUJBQWlCLENBQUNuRCxPQUFELENBQWpCLENBQTJCd0ksUUFBMUM7O0FBRUF4SSxFQUFBQSxPQUFPLENBQUNqRCxLQUFSLENBQWN5TCxRQUFkLEdBQXlCQSxRQUFRLEtBQUssVUFBYixJQUEyQkEsUUFBUSxLQUFLLE9BQXhDLEdBQWtEQSxRQUFsRCxHQUE2RCxVQUF0RjtBQUNELENBekpEO0FBQUEsSUEwSkkxSSxZQUFZLEdBQUcsU0FBU0EsWUFBVCxDQUFzQjlCLEdBQXRCLEVBQTJCSyxRQUEzQixFQUFxQztBQUN0RCxPQUFLLElBQUlGLENBQVQsSUFBY0UsUUFBZCxFQUF3QjtBQUN0QkYsSUFBQUEsQ0FBQyxJQUFJSCxHQUFMLEtBQWFBLEdBQUcsQ0FBQ0csQ0FBRCxDQUFILEdBQVNFLFFBQVEsQ0FBQ0YsQ0FBRCxDQUE5QjtBQUNEOztBQUVELFNBQU9ILEdBQVA7QUFDRCxDQWhLRDtBQUFBLElBaUtJa0gsVUFBVSxHQUFHLFNBQVNBLFVBQVQsQ0FBb0JsRixPQUFwQixFQUE2QjBnQyxpQkFBN0IsRUFBZ0Q7QUFDL0QsTUFBSWhzQixLQUFLLEdBQUdnc0IsaUJBQWlCLElBQUl2OUIsaUJBQWlCLENBQUNuRCxPQUFELENBQWpCLENBQTJCaEUsY0FBM0IsTUFBK0MsMEJBQXBFLElBQWtHNUIsa0JBQUksQ0FBQ29GLEVBQUwsQ0FBUVEsT0FBUixFQUFpQjtBQUM3SDBDLElBQUFBLENBQUMsRUFBRSxDQUQwSDtBQUU3SEMsSUFBQUEsQ0FBQyxFQUFFLENBRjBIO0FBRzdIZytCLElBQUFBLFFBQVEsRUFBRSxDQUhtSDtBQUk3SEMsSUFBQUEsUUFBUSxFQUFFLENBSm1IO0FBSzdIL3lCLElBQUFBLFFBQVEsRUFBRSxDQUxtSDtBQU03SGd6QixJQUFBQSxTQUFTLEVBQUUsQ0FOa0g7QUFPN0hDLElBQUFBLFNBQVMsRUFBRSxDQVBrSDtBQVE3SEMsSUFBQUEsS0FBSyxFQUFFLENBUnNIO0FBUzdIQyxJQUFBQSxLQUFLLEVBQUUsQ0FUc0g7QUFVN0hDLElBQUFBLEtBQUssRUFBRTtBQVZzSCxHQUFqQixFQVczR3JpQixRQVgyRyxDQVdsRyxDQVhrRyxDQUE5RztBQUFBLE1BWUkxSyxNQUFNLEdBQUdsVSxPQUFPLENBQUN1RSxxQkFBUixFQVpiO0FBYUFtUSxFQUFBQSxLQUFLLElBQUlBLEtBQUssQ0FBQ2tLLFFBQU4sQ0FBZSxDQUFmLEVBQWtCdEgsSUFBbEIsRUFBVDtBQUNBLFNBQU9wRCxNQUFQO0FBQ0QsQ0FqTEQ7QUFBQSxJQWtMSWd0QixRQUFRLEdBQUcsU0FBU0EsUUFBVCxDQUFrQmxoQyxPQUFsQixFQUEyQm1oQyxLQUEzQixFQUFrQztBQUMvQyxNQUFJdlYsRUFBRSxHQUFHdVYsS0FBSyxDQUFDdlYsRUFBZjtBQUNBLFNBQU81ckIsT0FBTyxDQUFDLFdBQVc0ckIsRUFBWixDQUFQLElBQTBCNXJCLE9BQU8sQ0FBQyxXQUFXNHJCLEVBQVosQ0FBakMsSUFBb0QsQ0FBM0Q7QUFDRCxDQXJMRDtBQUFBLElBc0xJd1YsbUJBQW1CLEdBQUcsU0FBU0EsbUJBQVQsQ0FBNkJDLFFBQTdCLEVBQXVDO0FBQy9ELE1BQUkvNUIsQ0FBQyxHQUFHLEVBQVI7QUFBQSxNQUNJZzZCLE1BQU0sR0FBR0QsUUFBUSxDQUFDQyxNQUR0QjtBQUFBLE1BRUkzaEMsUUFBUSxHQUFHMGhDLFFBQVEsQ0FBQzFoQyxRQUFULEVBRmY7QUFBQSxNQUdJeEIsQ0FISjs7QUFLQSxPQUFLQSxDQUFMLElBQVVtakMsTUFBVixFQUFrQjtBQUNoQmg2QixJQUFBQSxDQUFDLENBQUNySSxJQUFGLENBQU9xaUMsTUFBTSxDQUFDbmpDLENBQUQsQ0FBTixHQUFZd0IsUUFBbkI7QUFDRDs7QUFFRCxTQUFPMkgsQ0FBUDtBQUNELENBak1EO0FBQUEsSUFrTUlpNkIsZ0JBQWdCLEdBQUcsU0FBU0EsZ0JBQVQsQ0FBMEJqQyxTQUExQixFQUFxQztBQUMxRCxTQUFPLFVBQVUxakMsS0FBVixFQUFpQjtBQUN0QixXQUFPeEIsa0JBQUksQ0FBQ3dPLEtBQUwsQ0FBV3hCLElBQVgsQ0FBZ0JnNkIsbUJBQW1CLENBQUM5QixTQUFELENBQW5DLEVBQWdEMWpDLEtBQWhELENBQVA7QUFDRCxHQUZEO0FBR0QsQ0F0TUQ7QUFBQSxJQXVNSTRsQyxnQkFBZ0IsR0FBRyxTQUFTQSxnQkFBVCxDQUEwQkMsb0JBQTFCLEVBQWdEO0FBQ3JFLE1BQUlyNkIsSUFBSSxHQUFHaE4sa0JBQUksQ0FBQ3dPLEtBQUwsQ0FBV3hCLElBQVgsQ0FBZ0JxNkIsb0JBQWhCLENBQVg7QUFBQSxNQUNJbjZCLENBQUMsR0FBR2hMLEtBQUssQ0FBQ0MsT0FBTixDQUFja2xDLG9CQUFkLEtBQXVDQSxvQkFBb0IsQ0FBQ3BpQixLQUFyQixDQUEyQixDQUEzQixFQUE4QnFpQixJQUE5QixDQUFtQyxVQUFVcDZCLENBQVYsRUFBYTJSLENBQWIsRUFBZ0I7QUFDaEcsV0FBTzNSLENBQUMsR0FBRzJSLENBQVg7QUFDRCxHQUY4QyxDQUQvQztBQUlBLFNBQU8zUixDQUFDLEdBQUcsVUFBVTFMLEtBQVYsRUFBaUIrZixTQUFqQixFQUE0Qk4sU0FBNUIsRUFBdUM7QUFDaEQsUUFBSUEsU0FBUyxLQUFLLEtBQUssQ0FBdkIsRUFBMEI7QUFDeEJBLE1BQUFBLFNBQVMsR0FBRyxJQUFaO0FBQ0Q7O0FBRUQsUUFBSTdjLENBQUo7O0FBRUEsUUFBSSxDQUFDbWQsU0FBTCxFQUFnQjtBQUNkLGFBQU92VSxJQUFJLENBQUN4TCxLQUFELENBQVg7QUFDRDs7QUFFRCxRQUFJK2YsU0FBUyxHQUFHLENBQWhCLEVBQW1CO0FBQ2pCL2YsTUFBQUEsS0FBSyxJQUFJeWYsU0FBVCxDQURpQixDQUNHOztBQUVwQixXQUFLN2MsQ0FBQyxHQUFHLENBQVQsRUFBWUEsQ0FBQyxHQUFHOEksQ0FBQyxDQUFDN0ksTUFBbEIsRUFBMEJELENBQUMsRUFBM0IsRUFBK0I7QUFDN0IsWUFBSThJLENBQUMsQ0FBQzlJLENBQUQsQ0FBRCxJQUFRNUMsS0FBWixFQUFtQjtBQUNqQixpQkFBTzBMLENBQUMsQ0FBQzlJLENBQUQsQ0FBUjtBQUNEO0FBQ0Y7O0FBRUQsYUFBTzhJLENBQUMsQ0FBQzlJLENBQUMsR0FBRyxDQUFMLENBQVI7QUFDRCxLQVZELE1BVU87QUFDTEEsTUFBQUEsQ0FBQyxHQUFHOEksQ0FBQyxDQUFDN0ksTUFBTjtBQUNBN0MsTUFBQUEsS0FBSyxJQUFJeWYsU0FBVDs7QUFFQSxhQUFPN2MsQ0FBQyxFQUFSLEVBQVk7QUFDVixZQUFJOEksQ0FBQyxDQUFDOUksQ0FBRCxDQUFELElBQVE1QyxLQUFaLEVBQW1CO0FBQ2pCLGlCQUFPMEwsQ0FBQyxDQUFDOUksQ0FBRCxDQUFSO0FBQ0Q7QUFDRjtBQUNGOztBQUVELFdBQU84SSxDQUFDLENBQUMsQ0FBRCxDQUFSO0FBQ0QsR0FqQ08sR0FpQ0osVUFBVTFMLEtBQVYsRUFBaUIrZixTQUFqQixFQUE0Qk4sU0FBNUIsRUFBdUM7QUFDekMsUUFBSUEsU0FBUyxLQUFLLEtBQUssQ0FBdkIsRUFBMEI7QUFDeEJBLE1BQUFBLFNBQVMsR0FBRyxJQUFaO0FBQ0Q7O0FBRUQsUUFBSXNtQixPQUFPLEdBQUd2NkIsSUFBSSxDQUFDeEwsS0FBRCxDQUFsQjtBQUNBLFdBQU8sQ0FBQytmLFNBQUQsSUFBY3hmLElBQUksQ0FBQzJiLEdBQUwsQ0FBUzZwQixPQUFPLEdBQUcvbEMsS0FBbkIsSUFBNEJ5ZixTQUExQyxJQUF1RHNtQixPQUFPLEdBQUcvbEMsS0FBVixHQUFrQixDQUFsQixLQUF3QitmLFNBQVMsR0FBRyxDQUEzRixHQUErRmdtQixPQUEvRixHQUF5R3Y2QixJQUFJLENBQUN1VSxTQUFTLEdBQUcsQ0FBWixHQUFnQi9mLEtBQUssR0FBRzZsQyxvQkFBeEIsR0FBK0M3bEMsS0FBSyxHQUFHNmxDLG9CQUF4RCxDQUFwSDtBQUNELEdBeENEO0FBeUNELENBclBEO0FBQUEsSUFzUElHLG9CQUFvQixHQUFHLFNBQVNBLG9CQUFULENBQThCUCxRQUE5QixFQUF3QztBQUNqRSxTQUFPLFVBQVV6bEMsS0FBVixFQUFpQmltQyxFQUFqQixFQUFxQjtBQUMxQixXQUFPTCxnQkFBZ0IsQ0FBQ0osbUJBQW1CLENBQUNDLFFBQUQsQ0FBcEIsQ0FBaEIsQ0FBZ0R6bEMsS0FBaEQsRUFBdURpbUMsRUFBRSxDQUFDbG1CLFNBQTFELENBQVA7QUFDRCxHQUZEO0FBR0QsQ0ExUEQ7QUFBQSxJQTJQSW1tQixjQUFjLEdBQUcsU0FBU0EsY0FBVCxDQUF3Qi9pQyxJQUF4QixFQUE4QmlCLE9BQTlCLEVBQXVDME0sS0FBdkMsRUFBOEM3SyxRQUE5QyxFQUF3RDtBQUMzRSxTQUFPNkssS0FBSyxDQUFDRSxLQUFOLENBQVksR0FBWixFQUFpQjlOLE9BQWpCLENBQXlCLFVBQVVyQyxJQUFWLEVBQWdCO0FBQzlDLFdBQU9zQyxJQUFJLENBQUNpQixPQUFELEVBQVV2RCxJQUFWLEVBQWdCb0YsUUFBaEIsQ0FBWDtBQUNELEdBRk0sQ0FBUDtBQUdELENBL1BEO0FBQUEsSUFnUUk5Qix5QkFBWSxHQUFHLFNBQVNBLFlBQVQsQ0FBc0JDLE9BQXRCLEVBQStCdkQsSUFBL0IsRUFBcUNzQyxJQUFyQyxFQUEyQ20yQixVQUEzQyxFQUF1RGoxQixPQUF2RCxFQUFnRTtBQUNqRixTQUFPRCxPQUFPLENBQUNFLGdCQUFSLENBQXlCekQsSUFBekIsRUFBK0JzQyxJQUEvQixFQUFxQztBQUMxQ3FCLElBQUFBLE9BQU8sRUFBRSxDQUFDODBCLFVBRGdDO0FBRTFDajFCLElBQUFBLE9BQU8sRUFBRSxDQUFDLENBQUNBO0FBRitCLEdBQXJDLENBQVA7QUFJRCxDQXJRRDtBQUFBLElBc1FJSSw0QkFBZSxHQUFHLFNBQVNBLGVBQVQsQ0FBeUJMLE9BQXpCLEVBQWtDdkQsSUFBbEMsRUFBd0NzQyxJQUF4QyxFQUE4Q2tCLE9BQTlDLEVBQXVEO0FBQzNFLFNBQU9ELE9BQU8sQ0FBQ00sbUJBQVIsQ0FBNEI3RCxJQUE1QixFQUFrQ3NDLElBQWxDLEVBQXdDLENBQUMsQ0FBQ2tCLE9BQTFDLENBQVA7QUFDRCxDQXhRRDtBQUFBLElBeVFJOGhDLGNBQWMsR0FBRyxTQUFTQSxjQUFULENBQXdCaGpDLElBQXhCLEVBQThCazJCLEVBQTlCLEVBQWtDK00sVUFBbEMsRUFBOEM7QUFDakUsU0FBT0EsVUFBVSxJQUFJQSxVQUFVLENBQUNDLFlBQXpCLElBQXlDbGpDLElBQUksQ0FBQ2syQixFQUFELEVBQUssT0FBTCxFQUFjK00sVUFBZCxDQUFwRDtBQUNELENBM1FEO0FBQUEsSUE0UUlFLGVBQWUsR0FBRztBQUNwQkMsRUFBQUEsVUFBVSxFQUFFLE9BRFE7QUFFcEJDLEVBQUFBLFFBQVEsRUFBRSxLQUZVO0FBR3BCQyxFQUFBQSxNQUFNLEVBQUUsQ0FIWTtBQUlwQkMsRUFBQUEsUUFBUSxFQUFFLE1BSlU7QUFLcEJDLEVBQUFBLFVBQVUsRUFBRTtBQUxRLENBNVF0QjtBQUFBLElBbVJJQyxTQUFTLEdBQUc7QUFDZEMsRUFBQUEsYUFBYSxFQUFFLE1BREQ7QUFFZEMsRUFBQUEsYUFBYSxFQUFFO0FBRkQsQ0FuUmhCO0FBQUEsSUF1UklDLFNBQVMsR0FBRztBQUNkai9CLEVBQUFBLEdBQUcsRUFBRSxDQURTO0FBRWRELEVBQUFBLElBQUksRUFBRSxDQUZRO0FBR2RtL0IsRUFBQUEsTUFBTSxFQUFFLEdBSE07QUFJZDUrQixFQUFBQSxNQUFNLEVBQUUsQ0FKTTtBQUtkSixFQUFBQSxLQUFLLEVBQUU7QUFMTyxDQXZSaEI7QUFBQSxJQThSSWkvQixXQUFXLEdBQUcsU0FBU0EsV0FBVCxDQUFxQmpuQyxLQUFyQixFQUE0QmtuQyxJQUE1QixFQUFrQztBQUNsRCxNQUFJeGtCLFNBQVMsQ0FBQzFpQixLQUFELENBQWIsRUFBc0I7QUFDcEIsUUFBSW1uQyxPQUFPLEdBQUdubkMsS0FBSyxDQUFDcVEsT0FBTixDQUFjLEdBQWQsQ0FBZDtBQUFBLFFBQ0l1akIsUUFBUSxHQUFHLENBQUN1VCxPQUFELEdBQVcsRUFBRW5uQyxLQUFLLENBQUNpdkIsTUFBTixDQUFha1ksT0FBTyxHQUFHLENBQXZCLElBQTRCLENBQTlCLElBQW1DbjhCLFVBQVUsQ0FBQ2hMLEtBQUssQ0FBQ2d2QixNQUFOLENBQWFtWSxPQUFPLEdBQUcsQ0FBdkIsQ0FBRCxDQUF4RCxHQUFzRixDQURyRzs7QUFHQSxRQUFJLENBQUNBLE9BQUwsRUFBYztBQUNabm5DLE1BQUFBLEtBQUssQ0FBQ3FRLE9BQU4sQ0FBYyxHQUFkLElBQXFCODJCLE9BQXJCLEtBQWlDdlQsUUFBUSxJQUFJc1QsSUFBSSxHQUFHLEdBQXBEO0FBQ0FsbkMsTUFBQUEsS0FBSyxHQUFHQSxLQUFLLENBQUNndkIsTUFBTixDQUFhLENBQWIsRUFBZ0JtWSxPQUFPLEdBQUcsQ0FBMUIsQ0FBUjtBQUNEOztBQUVEbm5DLElBQUFBLEtBQUssR0FBRzR6QixRQUFRLElBQUk1ekIsS0FBSyxJQUFJK21DLFNBQVQsR0FBcUJBLFNBQVMsQ0FBQy9tQyxLQUFELENBQVQsR0FBbUJrbkMsSUFBeEMsR0FBK0MsQ0FBQ2xuQyxLQUFLLENBQUNxUSxPQUFOLENBQWMsR0FBZCxDQUFELEdBQXNCckYsVUFBVSxDQUFDaEwsS0FBRCxDQUFWLEdBQW9Ca25DLElBQXBCLEdBQTJCLEdBQWpELEdBQXVEbDhCLFVBQVUsQ0FBQ2hMLEtBQUQsQ0FBVixJQUFxQixDQUEvSCxDQUFoQjtBQUNEOztBQUVELFNBQU9BLEtBQVA7QUFDRCxDQTVTRDtBQUFBLElBNlNJb25DLGFBQWEsR0FBRyxTQUFTQSxhQUFULENBQXVCdm1DLElBQXZCLEVBQTZCMmtCLElBQTdCLEVBQW1DNmhCLFNBQW5DLEVBQThDdG5CLFNBQTlDLEVBQXlEdW5CLEtBQXpELEVBQWdFOTlCLE1BQWhFLEVBQXdFKzlCLFlBQXhFLEVBQXNGQyxrQkFBdEYsRUFBMEc7QUFDNUgsTUFBSWpCLFVBQVUsR0FBR2UsS0FBSyxDQUFDZixVQUF2QjtBQUFBLE1BQ0lDLFFBQVEsR0FBR2MsS0FBSyxDQUFDZCxRQURyQjtBQUFBLE1BRUlFLFFBQVEsR0FBR1ksS0FBSyxDQUFDWixRQUZyQjtBQUFBLE1BR0lELE1BQU0sR0FBR2EsS0FBSyxDQUFDYixNQUhuQjtBQUFBLE1BSUlFLFVBQVUsR0FBR1csS0FBSyxDQUFDWCxVQUp2Qjs7QUFNQSxNQUFJNWxDLENBQUMsR0FBR3JDLGlCQUFJLENBQUN3QyxhQUFMLENBQW1CLEtBQW5CLENBQVI7QUFBQSxNQUNJdW1DLGdCQUFnQixHQUFHck8sd0JBQVcsQ0FBQ2lPLFNBQUQsQ0FBWCxJQUEwQmxPLGFBQWEsQ0FBQ2tPLFNBQUQsRUFBWSxTQUFaLENBQWIsS0FBd0MsT0FEekY7QUFBQSxNQUVJSyxVQUFVLEdBQUc3bUMsSUFBSSxDQUFDd1AsT0FBTCxDQUFhLFVBQWIsTUFBNkIsQ0FBQyxDQUYvQztBQUFBLE1BR0lNLE1BQU0sR0FBRzgyQixnQkFBZ0IsR0FBRzdvQyxrQkFBSCxHQUFXeW9DLFNBSHhDO0FBQUEsTUFJSU0sT0FBTyxHQUFHOW1DLElBQUksQ0FBQ3dQLE9BQUwsQ0FBYSxPQUFiLE1BQTBCLENBQUMsQ0FKekM7QUFBQSxNQUtJdTNCLEtBQUssR0FBR0QsT0FBTyxHQUFHcEIsVUFBSCxHQUFnQkMsUUFMbkM7QUFBQSxNQU1JcUIsR0FBRyxHQUFHLGtCQUFrQkQsS0FBbEIsR0FBMEIsYUFBMUIsR0FBMENsQixRQUExQyxHQUFxRCxTQUFyRCxHQUFpRWtCLEtBQWpFLEdBQXlFLGVBQXpFLEdBQTJGakIsVUFBM0YsR0FBd0csc0lBTmxIOztBQVFBa0IsRUFBQUEsR0FBRyxJQUFJLGVBQWUsQ0FBQ0gsVUFBVSxJQUFJRixrQkFBZixLQUFzQ0MsZ0JBQXRDLEdBQXlELFFBQXpELEdBQW9FLFdBQW5GLENBQVA7QUFDQSxHQUFDQyxVQUFVLElBQUlGLGtCQUFkLElBQW9DLENBQUNDLGdCQUF0QyxNQUE0REksR0FBRyxJQUFJLENBQUM5bkIsU0FBUyxLQUFLdWEsU0FBZCxHQUEwQjBKLE1BQTFCLEdBQW1DQyxPQUFwQyxJQUErQyxHQUEvQyxJQUFzRHo2QixNQUFNLEdBQUd3QixVQUFVLENBQUN5N0IsTUFBRCxDQUF6RSxJQUFxRixLQUF4SjtBQUNBYyxFQUFBQSxZQUFZLEtBQUtNLEdBQUcsSUFBSSxpREFBaUROLFlBQVksQ0FBQ2xULFdBQTlELEdBQTRFLEtBQXhGLENBQVo7QUFDQXR6QixFQUFBQSxDQUFDLENBQUMrbUMsUUFBRixHQUFhSCxPQUFiO0FBQ0E1bUMsRUFBQUEsQ0FBQyxDQUFDNm1CLFlBQUYsQ0FBZSxPQUFmLEVBQXdCLGlCQUFpQi9tQixJQUFqQixJQUF5QjJrQixJQUFJLEdBQUcsYUFBYUEsSUFBaEIsR0FBdUIsRUFBcEQsQ0FBeEI7QUFDQXprQixFQUFBQSxDQUFDLENBQUNJLEtBQUYsQ0FBUStPLE9BQVIsR0FBa0IyM0IsR0FBbEI7QUFDQTltQyxFQUFBQSxDQUFDLENBQUNnbkMsU0FBRixHQUFjdmlCLElBQUksSUFBSUEsSUFBSSxLQUFLLENBQWpCLEdBQXFCM2tCLElBQUksR0FBRyxHQUFQLEdBQWEya0IsSUFBbEMsR0FBeUMza0IsSUFBdkQ7QUFDQThQLEVBQUFBLE1BQU0sQ0FBQzdOLFFBQVAsQ0FBZ0IsQ0FBaEIsSUFBcUI2TixNQUFNLENBQUNvWCxZQUFQLENBQW9CaG5CLENBQXBCLEVBQXVCNFAsTUFBTSxDQUFDN04sUUFBUCxDQUFnQixDQUFoQixDQUF2QixDQUFyQixHQUFrRTZOLE1BQU0sQ0FBQ3pCLFdBQVAsQ0FBbUJuTyxDQUFuQixDQUFsRTtBQUNBQSxFQUFBQSxDQUFDLENBQUNpbkMsT0FBRixHQUFZam5DLENBQUMsQ0FBQyxXQUFXZ2YsU0FBUyxDQUFDd2EsRUFBVixDQUFhdkssRUFBekIsQ0FBYjs7QUFFQWlZLEVBQUFBLGVBQWUsQ0FBQ2xuQyxDQUFELEVBQUksQ0FBSixFQUFPZ2YsU0FBUCxFQUFrQjRuQixPQUFsQixDQUFmOztBQUVBLFNBQU81bUMsQ0FBUDtBQUNELENBelVEO0FBQUEsSUEwVUlrbkMsZUFBZSxHQUFHLFNBQVNBLGVBQVQsQ0FBeUJDLE1BQXpCLEVBQWlDanVCLEtBQWpDLEVBQXdDOEYsU0FBeEMsRUFBbURvb0IsT0FBbkQsRUFBNEQ7QUFDaEYsTUFBSXIvQixJQUFJLEdBQUc7QUFDVDBHLElBQUFBLE9BQU8sRUFBRTtBQURBLEdBQVg7QUFBQSxNQUdJNDRCLElBQUksR0FBR3JvQixTQUFTLENBQUNvb0IsT0FBTyxHQUFHLEtBQUgsR0FBVyxJQUFuQixDQUhwQjtBQUFBLE1BSUlFLFlBQVksR0FBR3RvQixTQUFTLENBQUNvb0IsT0FBTyxHQUFHLElBQUgsR0FBVSxLQUFsQixDQUo1QjtBQUtBRCxFQUFBQSxNQUFNLENBQUNJLFVBQVAsR0FBb0JILE9BQXBCO0FBQ0FyL0IsRUFBQUEsSUFBSSxDQUFDaVgsU0FBUyxDQUFDclUsQ0FBVixHQUFjLFNBQWYsQ0FBSixHQUFnQ3k4QixPQUFPLEdBQUcsQ0FBQyxHQUFKLEdBQVUsQ0FBakQ7QUFDQXIvQixFQUFBQSxJQUFJLENBQUNpWCxTQUFTLENBQUNyVSxDQUFYLENBQUosR0FBb0J5OEIsT0FBTyxHQUFHLEtBQUgsR0FBVyxDQUF0QztBQUNBci9CLEVBQUFBLElBQUksQ0FBQyxXQUFXcy9CLElBQVgsR0FBa0IxRCxNQUFuQixDQUFKLEdBQWlDLENBQWpDO0FBQ0E1N0IsRUFBQUEsSUFBSSxDQUFDLFdBQVd1L0IsWUFBWCxHQUEwQjNELE1BQTNCLENBQUosR0FBeUMsQ0FBekM7QUFDQTU3QixFQUFBQSxJQUFJLENBQUNpWCxTQUFTLENBQUN4ZCxDQUFYLENBQUosR0FBb0IwWCxLQUFLLEdBQUcsSUFBNUI7QUFDQXpiLEVBQUFBLGtCQUFJLENBQUNnTyxHQUFMLENBQVMwN0IsTUFBVCxFQUFpQnAvQixJQUFqQjtBQUNELENBdlZEO0FBQUEsSUF3Vkl5L0IsU0FBUyxHQUFHLEVBeFZoQjtBQUFBLElBeVZJQyxJQUFJLEdBQUcsRUF6Vlg7QUFBQSxJQTBWSUMsTUExVko7QUFBQSxJQTJWSUMsS0FBSyxHQUFHLFNBQVNBLEtBQVQsR0FBaUI7QUFDM0IsU0FBT2xuQyxxQkFBUSxLQUFLOGdDLGVBQWIsR0FBK0IsRUFBL0IsSUFBcUNxRyxVQUFVLEVBQXREO0FBQ0QsQ0E3VkQ7QUFBQSxJQThWSWxQLHNCQUFTLEdBQUcsU0FBU0EsU0FBVCxHQUFxQjtBQUNuQztBQUNBLE1BQUksQ0FBQ2xCLHdCQUFELElBQWdCLENBQUNBLHdCQUFXLENBQUNubkIsU0FBN0IsSUFBMENtbkIsd0JBQVcsQ0FBQzNkLE1BQVosR0FBcUJoYyxrQkFBSyxDQUFDcUosV0FBekUsRUFBc0Y7QUFDcEY7QUFDQTJ3QixJQUFBQSxnQkFBQTtBQUNBNlAsSUFBQUEsTUFBTSxLQUFLQSxNQUFNLEdBQUcvSSxxQkFBcUIsQ0FBQ2lKLFVBQUQsQ0FBbkMsQ0FBTjtBQUNBckcsSUFBQUEsZUFBZSxJQUFJc0csU0FBUyxDQUFDLGFBQUQsQ0FBNUI7QUFDQXRHLElBQUFBLGVBQWUsR0FBRzlnQyxxQkFBUSxFQUExQjtBQUNEO0FBQ0YsQ0F2V0Q7QUFBQSxJQXdXSXFuQyxrQkFBa0IsR0FBRyxTQUFTQSxrQkFBVCxHQUE4QjtBQUNyRDNHLEVBQUFBLGdCQUFnQixHQUFHempDLGlCQUFJLENBQUN5SixVQUF4QjtBQUNBKzVCLEVBQUFBLGlCQUFpQixHQUFHeGpDLGlCQUFJLENBQUM0SixXQUF6QjtBQUNELENBM1dEO0FBQUEsSUE0V0l5Z0MsU0FBUyxHQUFHLFNBQVNBLFNBQVQsR0FBcUI7QUFDbkNsUSxFQUFBQSxnQkFBQTtBQUNBLEdBQUMySSxXQUFELElBQWdCLENBQUNRLGFBQWpCLElBQWtDLENBQUNyakMsaUJBQUksQ0FBQ3FxQyxpQkFBeEMsSUFBNkQsQ0FBQ3JxQyxpQkFBSSxDQUFDc3FDLHVCQUFuRSxLQUErRixDQUFDaEgsbUJBQUQsSUFBd0JFLGdCQUFnQixLQUFLempDLGlCQUFJLENBQUN5SixVQUFsRCxJQUFnRTNILElBQUksQ0FBQzJiLEdBQUwsQ0FBU3pkLGlCQUFJLENBQUM0SixXQUFMLEdBQW1CNDVCLGlCQUE1QixJQUFpRHhqQyxpQkFBSSxDQUFDNEosV0FBTCxHQUFtQixJQUFuTyxLQUE0Tys0QixZQUFZLENBQUNqQixPQUFiLENBQXFCLElBQXJCLENBQTVPO0FBQ0QsQ0EvV0Q7QUFBQSxJQWdYSTtBQUNKbjNCLFVBQVUsR0FBRyxFQWpYYjtBQUFBLElBa1hJaWdDLFdBQVcsR0FBRyxFQWxYbEI7QUFBQSxJQW1YSUMsTUFBTSxHQUFHLEVBblhiO0FBQUEsSUFvWElDLGNBcFhKO0FBQUEsSUFxWEk7QUFDSkMsY0F0WEE7QUFBQSxJQXVYSUMsY0FBYyxHQUFHLFNBQVNBLGNBQVQsQ0FBd0J0b0MsQ0FBeEIsRUFBMkI7QUFDOUMsTUFBSXVvQyxJQUFJLEdBQUc5cUMsa0JBQUksQ0FBQzhFLE1BQUwsQ0FBWWltQyxLQUF2QjtBQUFBLE1BQ0l0TixPQUFPLEdBQUcsRUFEZDtBQUFBLE1BRUlyNUIsQ0FBQyxHQUFHLENBRlI7QUFBQSxNQUdJNmhCLEtBSEo7O0FBS0EsTUFBSTJrQixjQUFjLEtBQUtFLElBQW5CLElBQTJCNVEscUJBQS9CLEVBQXlDO0FBQ3ZDOFEsSUFBQUEsVUFBVTs7QUFFVixXQUFPNW1DLENBQUMsR0FBR3NtQyxNQUFNLENBQUNybUMsTUFBbEIsRUFBMEJELENBQUMsSUFBSSxDQUEvQixFQUFrQztBQUNoQzZoQixNQUFBQSxLQUFLLEdBQUdobUIsaUJBQUksQ0FBQ3U5QixVQUFMLENBQWdCa04sTUFBTSxDQUFDdG1DLENBQUQsQ0FBdEIsRUFBMkJxNUIsT0FBbkM7O0FBRUEsVUFBSXhYLEtBQUssS0FBS3lrQixNQUFNLENBQUN0bUMsQ0FBQyxHQUFHLENBQUwsQ0FBcEIsRUFBNkI7QUFDM0I7QUFDQXNtQyxRQUFBQSxNQUFNLENBQUN0bUMsQ0FBQyxHQUFHLENBQUwsQ0FBTixHQUFnQjZoQixLQUFoQjtBQUNBQSxRQUFBQSxLQUFLLEdBQUd3WCxPQUFPLENBQUM1NEIsSUFBUixDQUFhVCxDQUFiLENBQUgsR0FBcUI0bUMsVUFBVSxDQUFDLENBQUQsRUFBSU4sTUFBTSxDQUFDdG1DLENBQUQsQ0FBVixDQUFWLElBQTRCN0MsV0FBVyxDQUFDbXBDLE1BQU0sQ0FBQ3RtQyxDQUFDLEdBQUcsQ0FBTCxDQUFQLENBQVgsSUFBOEJzbUMsTUFBTSxDQUFDdG1DLENBQUMsR0FBRyxDQUFMLENBQU4sRUFBcEYsQ0FIMkIsQ0FHMEU7QUFDdEc7QUFDRjs7QUFFRDZtQyxJQUFBQSxlQUFlLEdBYndCLENBYXBCOzs7QUFHbkIsU0FBSzdtQyxDQUFDLEdBQUcsQ0FBVCxFQUFZQSxDQUFDLEdBQUdxNUIsT0FBTyxDQUFDcDVCLE1BQXhCLEVBQWdDRCxDQUFDLEVBQWpDLEVBQXFDO0FBQ25DNmhCLE1BQUFBLEtBQUssR0FBR3dYLE9BQU8sQ0FBQ3I1QixDQUFELENBQWY7QUFDQXVtQyxNQUFBQSxjQUFjLEdBQUdELE1BQU0sQ0FBQ3prQixLQUFELENBQXZCO0FBQ0F5a0IsTUFBQUEsTUFBTSxDQUFDemtCLEtBQUssR0FBRyxDQUFULENBQU4sR0FBb0J5a0IsTUFBTSxDQUFDemtCLEtBQUssR0FBRyxDQUFULENBQU4sQ0FBa0IxakIsQ0FBbEIsQ0FBcEI7QUFDRDs7QUFFRG9vQyxJQUFBQSxjQUFjLEdBQUcsQ0FBakI7QUFDQXBxQyxJQUFBQSx5QkFBWSxJQUFJMnFDLFdBQVcsQ0FBQyxDQUFELEVBQUksQ0FBSixDQUEzQjtBQUNBTixJQUFBQSxjQUFjLEdBQUdFLElBQWpCOztBQUVBVixJQUFBQSxTQUFTLENBQUMsWUFBRCxDQUFUO0FBQ0Q7QUFDRixDQXpaRDtBQUFBLElBMFpJZSxZQUFZLEdBQUcsU0FBU0EsWUFBVCxHQUF3QjtBQUN6QyxTQUFPbGxDLDRCQUFlLENBQUM0ekIsMkJBQUQsRUFBZ0IsV0FBaEIsRUFBNkJzUixZQUE3QixDQUFmLElBQTZERCxXQUFXLENBQUMsSUFBRCxDQUEvRTtBQUNELENBNVpEO0FBQUEsSUE2WklkLFNBQVMsR0FBRyxTQUFTQSxTQUFULENBQW1CL25DLElBQW5CLEVBQXlCO0FBQ3ZDLFNBQU9tSSxVQUFVLENBQUNuSSxJQUFELENBQVYsSUFBb0JtSSxVQUFVLENBQUNuSSxJQUFELENBQVYsQ0FBaUJzZ0IsR0FBakIsQ0FBcUIsVUFBVTVELENBQVYsRUFBYTtBQUMzRCxXQUFPQSxDQUFDLEVBQVI7QUFDRCxHQUYwQixDQUFwQixJQUVEMHJCLFdBRk47QUFHRCxDQWphRDtBQUFBLElBa2FJVyxZQUFZLEdBQUcsRUFsYW5CO0FBQUEsSUFtYUk7QUFDSkgsZUFBZSxHQUFHLFNBQVNBLGVBQVQsQ0FBeUJJLEtBQXpCLEVBQWdDO0FBQ2hELE9BQUssSUFBSWpuQyxDQUFDLEdBQUcsQ0FBYixFQUFnQkEsQ0FBQyxHQUFHZ25DLFlBQVksQ0FBQy9tQyxNQUFqQyxFQUF5Q0QsQ0FBQyxJQUFJLENBQTlDLEVBQWlEO0FBQy9DLFFBQUksQ0FBQ2luQyxLQUFELElBQVVELFlBQVksQ0FBQ2huQyxDQUFDLEdBQUcsQ0FBTCxDQUFaLEtBQXdCaW5DLEtBQXRDLEVBQTZDO0FBQzNDRCxNQUFBQSxZQUFZLENBQUNobkMsQ0FBRCxDQUFaLENBQWdCekIsS0FBaEIsQ0FBc0IrTyxPQUF0QixHQUFnQzA1QixZQUFZLENBQUNobkMsQ0FBQyxHQUFHLENBQUwsQ0FBNUM7QUFDQWduQyxNQUFBQSxZQUFZLENBQUNobkMsQ0FBRCxDQUFaLENBQWdCdUgsT0FBaEIsSUFBMkJ5L0IsWUFBWSxDQUFDaG5DLENBQUQsQ0FBWixDQUFnQmdsQixZQUFoQixDQUE2QixXQUE3QixFQUEwQ2dpQixZQUFZLENBQUNobkMsQ0FBQyxHQUFHLENBQUwsQ0FBWixJQUF1QixFQUFqRSxDQUEzQjtBQUNBZ25DLE1BQUFBLFlBQVksQ0FBQ2huQyxDQUFDLEdBQUcsQ0FBTCxDQUFaLENBQW9CMlUsT0FBcEIsR0FBOEIsQ0FBOUI7QUFDRDtBQUNGO0FBQ0YsQ0E1YUQ7QUFBQSxJQTZhSWl5QixVQUFVLEdBQUcsU0FBU0EsVUFBVCxDQUFvQjl0QixJQUFwQixFQUEwQm11QixLQUExQixFQUFpQztBQUNoRCxNQUFJMzJCLE9BQUo7O0FBRUEsT0FBS3V1QixFQUFFLEdBQUcsQ0FBVixFQUFhQSxFQUFFLEdBQUc4RyxTQUFTLENBQUMxbEMsTUFBNUIsRUFBb0M0K0IsRUFBRSxFQUF0QyxFQUEwQztBQUN4Q3Z1QixJQUFBQSxPQUFPLEdBQUdxMUIsU0FBUyxDQUFDOUcsRUFBRCxDQUFuQjs7QUFFQSxRQUFJLENBQUNvSSxLQUFELElBQVUzMkIsT0FBTyxDQUFDMjJCLEtBQVIsS0FBa0JBLEtBQWhDLEVBQXVDO0FBQ3JDLFVBQUludUIsSUFBSixFQUFVO0FBQ1J4SSxRQUFBQSxPQUFPLENBQUN3SSxJQUFSLENBQWEsQ0FBYjtBQUNELE9BRkQsTUFFTztBQUNMeEksUUFBQUEsT0FBTyxDQUFDNDJCLE1BQVI7QUFDRDtBQUNGO0FBQ0Y7O0FBRURELEVBQUFBLEtBQUssSUFBSUosZUFBZSxDQUFDSSxLQUFELENBQXhCO0FBQ0FBLEVBQUFBLEtBQUssSUFBSWpCLFNBQVMsQ0FBQyxRQUFELENBQWxCO0FBQ0QsQ0E5YkQ7QUFBQSxJQStiSW1CLGtCQUFrQixHQUFHLFNBQVNBLGtCQUFULEdBQThCO0FBQ3JELFNBQU9uUixnQkFBQSxNQUFzQkEsa0JBQUEsQ0FBbUIsVUFBVXgyQixHQUFWLEVBQWU7QUFDN0QsV0FBTyxPQUFPQSxHQUFQLEtBQWUsVUFBZixLQUE4QkEsR0FBRyxDQUFDNG5DLEdBQUosR0FBVSxDQUF4QyxDQUFQO0FBQ0QsR0FGNEIsQ0FBN0I7QUFHRCxDQW5jRDtBQUFBLElBb2NJO0FBQ0pDLGNBcmNBO0FBQUEsSUFzY0lDLFVBQVUsR0FBRyxDQXRjakI7QUFBQSxJQXVjSVIsV0FBVyxHQUFHLFNBQVNBLFdBQVQsQ0FBcUJwN0IsS0FBckIsRUFBNEI2N0IsVUFBNUIsRUFBd0M7QUFDeEQsTUFBSTdILGVBQWUsSUFBSSxDQUFDaDBCLEtBQXhCLEVBQStCO0FBQzdCbkssSUFBQUEseUJBQVksQ0FBQ2swQiwyQkFBRCxFQUFnQixXQUFoQixFQUE2QnNSLFlBQTdCLENBQVo7O0FBRUE7QUFDRDs7QUFFRE0sRUFBQUEsY0FBYyxHQUFHLElBQWpCOztBQUVBLE1BQUlHLFlBQVksR0FBR3hCLFNBQVMsQ0FBQyxhQUFELENBQTVCOztBQUVBL0csRUFBQUEsS0FBSyxJQUFJeEosMkJBQWEsQ0FBQ3lOLElBQWQsRUFBVDtBQUNBcUUsRUFBQUEsVUFBVSxJQUFJWCxVQUFVLEVBQXhCOztBQUVBakIsRUFBQUEsU0FBUyxDQUFDOWtCLEtBQVYsQ0FBZ0IsQ0FBaEIsRUFBbUJ2Z0IsT0FBbkIsQ0FBMkIsVUFBVW1nQixDQUFWLEVBQWE7QUFDdEMsV0FBT0EsQ0FBQyxDQUFDZ25CLE9BQUYsRUFBUDtBQUNELEdBRkQsRUFkd0QsQ0FnQnBEOzs7QUFHSjlCLEVBQUFBLFNBQVMsQ0FBQ3JsQyxPQUFWLENBQWtCLFVBQVVtZ0IsQ0FBVixFQUFhO0FBQzdCLFdBQU9BLENBQUMsQ0FBQ3ZhLElBQUYsQ0FBTzhDLEdBQVAsS0FBZSxLQUFmLElBQXdCeVgsQ0FBQyxDQUFDaW5CLFlBQUYsQ0FBZWpuQixDQUFDLENBQUNwSixLQUFqQixFQUF3QjhvQixVQUFVLENBQUMxZixDQUFDLENBQUN3ZixRQUFILEVBQWF4ZixDQUFDLENBQUNrbkIsSUFBZixDQUFsQyxDQUEvQjtBQUNELEdBRkQsRUFuQndELENBcUJwRDs7O0FBR0pILEVBQUFBLFlBQVksQ0FBQ2xuQyxPQUFiLENBQXFCLFVBQVUrRixNQUFWLEVBQWtCO0FBQ3JDLFdBQU9BLE1BQU0sSUFBSUEsTUFBTSxDQUFDa04sTUFBakIsSUFBMkJsTixNQUFNLENBQUNrTixNQUFQLENBQWMsQ0FBQyxDQUFmLENBQWxDO0FBQ0QsR0FGRCxFQXhCd0QsQ0EwQnBEOztBQUVKNHpCLEVBQUFBLGtCQUFrQjs7QUFFbEIzSSxFQUFBQSxZQUFZLENBQUM5QixLQUFiOztBQUVBNEssRUFBQUEsVUFBVTtBQUNWRCxFQUFBQSxjQUFjLEdBQUcsS0FBakI7O0FBRUFyQixFQUFBQSxTQUFTLENBQUMsU0FBRCxDQUFUO0FBQ0QsQ0EzZUQ7QUFBQSxJQTRlSTRCLFdBQVcsR0FBRyxDQTVlbEI7QUFBQSxJQTZlSUMsVUFBVSxHQUFHLENBN2VqQjtBQUFBLElBOGVJQyxRQTllSjtBQUFBLElBK2VJL0IsVUFBVSxHQUFHLFNBQVNBLFVBQVQsR0FBc0I7QUFDckMsTUFBSSxDQUFDc0IsY0FBTCxFQUFxQjtBQUNuQjVSLElBQUFBLDJCQUFhLENBQUNzUyxVQUFkLEdBQTJCLElBQTNCO0FBQ0FELElBQUFBLFFBQVEsSUFBSUEsUUFBUSxDQUFDdnFCLE1BQVQsQ0FBZ0IsQ0FBaEIsQ0FBWixDQUZtQixDQUVhOztBQUVoQyxRQUFJeFUsQ0FBQyxHQUFHNDhCLFNBQVMsQ0FBQzFsQyxNQUFsQjtBQUFBLFFBQ0kyYixJQUFJLEdBQUdoZCxxQkFBUSxFQURuQjtBQUFBLFFBRUlvcEMsY0FBYyxHQUFHcHNCLElBQUksR0FBRzZqQixNQUFQLElBQWlCLEVBRnRDO0FBQUEsUUFHSTU3QixNQUFNLEdBQUdrRixDQUFDLElBQUk0OEIsU0FBUyxDQUFDLENBQUQsQ0FBVCxDQUFhOWhDLE1BQWIsRUFIbEI7O0FBS0Fna0MsSUFBQUEsVUFBVSxHQUFHRCxXQUFXLEdBQUcvakMsTUFBZCxHQUF1QixDQUFDLENBQXhCLEdBQTRCLENBQXpDO0FBQ0ErakMsSUFBQUEsV0FBVyxHQUFHL2pDLE1BQWQ7O0FBRUEsUUFBSW1rQyxjQUFKLEVBQW9CO0FBQ2xCLFVBQUl0SSxlQUFlLElBQUksQ0FBQ2QsY0FBcEIsSUFBc0NoakIsSUFBSSxHQUFHOGpCLGVBQVAsR0FBeUIsR0FBbkUsRUFBd0U7QUFDdEVBLFFBQUFBLGVBQWUsR0FBRyxDQUFsQjs7QUFFQXNHLFFBQUFBLFNBQVMsQ0FBQyxXQUFELENBQVQ7QUFDRDs7QUFFRHZILE1BQUFBLE1BQU0sR0FBR2dCLE1BQVQ7QUFDQUEsTUFBQUEsTUFBTSxHQUFHN2pCLElBQVQ7QUFDRDs7QUFFRCxRQUFJaXNCLFVBQVUsR0FBRyxDQUFqQixFQUFvQjtBQUNsQmhKLE1BQUFBLEVBQUUsR0FBRzkxQixDQUFMOztBQUVBLGFBQU84MUIsRUFBRSxLQUFLLENBQWQsRUFBaUI7QUFDZjhHLFFBQUFBLFNBQVMsQ0FBQzlHLEVBQUQsQ0FBVCxJQUFpQjhHLFNBQVMsQ0FBQzlHLEVBQUQsQ0FBVCxDQUFjdGhCLE1BQWQsQ0FBcUIsQ0FBckIsRUFBd0J5cUIsY0FBeEIsQ0FBakI7QUFDRDs7QUFFREgsTUFBQUEsVUFBVSxHQUFHLENBQWI7QUFDRCxLQVJELE1BUU87QUFDTCxXQUFLaEosRUFBRSxHQUFHLENBQVYsRUFBYUEsRUFBRSxHQUFHOTFCLENBQWxCLEVBQXFCODFCLEVBQUUsRUFBdkIsRUFBMkI7QUFDekI4RyxRQUFBQSxTQUFTLENBQUM5RyxFQUFELENBQVQsSUFBaUI4RyxTQUFTLENBQUM5RyxFQUFELENBQVQsQ0FBY3RoQixNQUFkLENBQXFCLENBQXJCLEVBQXdCeXFCLGNBQXhCLENBQWpCO0FBQ0Q7QUFDRjs7QUFFRHZTLElBQUFBLDJCQUFhLENBQUNzUyxVQUFkLEdBQTJCLEtBQTNCO0FBQ0Q7O0FBRURsQyxFQUFBQSxNQUFNLEdBQUcsQ0FBVDtBQUNELENBemhCRDtBQUFBLElBMGhCSW9DLGdCQUFnQixHQUFHLENBQUMvRyxLQUFELEVBQVFDLElBQVIsRUFBY0UsT0FBZCxFQUF1QkQsTUFBdkIsRUFBK0JTLE9BQU8sR0FBR0YsT0FBekMsRUFBa0RFLE9BQU8sR0FBR0wsTUFBNUQsRUFBb0VLLE9BQU8sR0FBR0gsSUFBOUUsRUFBb0ZHLE9BQU8sR0FBR0osS0FBOUYsRUFBcUcsU0FBckcsRUFBZ0gsWUFBaEgsRUFBOEgsT0FBOUgsRUFBdUksUUFBdkksRUFBaUosaUJBQWpKLEVBQW9LLGVBQXBLLEVBQXFMLGNBQXJMLEVBQXFNLFlBQXJNLEVBQW1OLFVBQW5OLEVBQStOLGFBQS9OLEVBQThPLFdBQTlPLEVBQTJQLFdBQTNQLEVBQXdRLE9BQXhRLENBMWhCdkI7QUFBQSxJQTJoQkl5RyxXQUFXLEdBQUdELGdCQUFnQixDQUFDbG1CLE1BQWpCLENBQXdCLENBQUN1ZixNQUFELEVBQVNDLE9BQVQsRUFBa0IsV0FBbEIsRUFBK0IsUUFBUU8sTUFBdkMsRUFBK0MsUUFBUUMsT0FBdkQsRUFBZ0UsVUFBaEUsRUFBNEVGLE9BQTVFLEVBQXFGRCxRQUFyRixFQUErRkEsUUFBUSxHQUFHRixJQUExRyxFQUFnSEUsUUFBUSxHQUFHSixNQUEzSCxFQUFtSUksUUFBUSxHQUFHRCxPQUE5SSxFQUF1SkMsUUFBUSxHQUFHSCxLQUFsSyxDQUF4QixDQTNoQmxCO0FBQUEsSUE0aEJJMEcsV0FBVyxHQUFHLFNBQVNBLFdBQVQsQ0FBcUJDLEdBQXJCLEVBQTBCQyxNQUExQixFQUFrQ0MsS0FBbEMsRUFBeUM7QUFDekRDLEVBQUFBLFNBQVMsQ0FBQ0QsS0FBRCxDQUFUOztBQUVBLE1BQUkzVixLQUFLLEdBQUd5VixHQUFHLENBQUNqM0IsS0FBaEI7O0FBRUEsTUFBSXdoQixLQUFLLENBQUM2VixjQUFWLEVBQTBCO0FBQ3hCRCxJQUFBQSxTQUFTLENBQUM1VixLQUFLLENBQUM4VixXQUFQLENBQVQ7QUFDRCxHQUZELE1BRU8sSUFBSUwsR0FBRyxDQUFDN2tDLFVBQUosS0FBbUI4a0MsTUFBdkIsRUFBK0I7QUFDcEMsUUFBSXQ2QixNQUFNLEdBQUdzNkIsTUFBTSxDQUFDOWtDLFVBQXBCOztBQUVBLFFBQUl3SyxNQUFKLEVBQVk7QUFDVkEsTUFBQUEsTUFBTSxDQUFDb1gsWUFBUCxDQUFvQmlqQixHQUFwQixFQUF5QkMsTUFBekI7QUFDQXQ2QixNQUFBQSxNQUFNLENBQUN4QixXQUFQLENBQW1CODdCLE1BQW5CO0FBQ0Q7QUFDRjtBQUNGLENBM2lCRDtBQUFBLElBNGlCSUssVUFBVSxHQUFHLFNBQVNBLFVBQVQsQ0FBb0JOLEdBQXBCLEVBQXlCQyxNQUF6QixFQUFpQ3RnQyxFQUFqQyxFQUFxQzBnQyxXQUFyQyxFQUFrRDtBQUNqRSxNQUFJTCxHQUFHLENBQUM3a0MsVUFBSixLQUFtQjhrQyxNQUF2QixFQUErQjtBQUM3QixRQUFJcm9DLENBQUMsR0FBR2lvQyxnQkFBZ0IsQ0FBQ2hvQyxNQUF6QjtBQUFBLFFBQ0kwb0MsV0FBVyxHQUFHTixNQUFNLENBQUM5cEMsS0FEekI7QUFBQSxRQUVJcXFDLFFBQVEsR0FBR1IsR0FBRyxDQUFDN3BDLEtBRm5CO0FBQUEsUUFHSW9CLENBSEo7O0FBS0EsV0FBT0ssQ0FBQyxFQUFSLEVBQVk7QUFDVkwsTUFBQUEsQ0FBQyxHQUFHc29DLGdCQUFnQixDQUFDam9DLENBQUQsQ0FBcEI7QUFDQTJvQyxNQUFBQSxXQUFXLENBQUNocEMsQ0FBRCxDQUFYLEdBQWlCb0ksRUFBRSxDQUFDcEksQ0FBRCxDQUFuQjtBQUNEOztBQUVEZ3BDLElBQUFBLFdBQVcsQ0FBQzMrQixRQUFaLEdBQXVCakMsRUFBRSxDQUFDaUMsUUFBSCxLQUFnQixVQUFoQixHQUE2QixVQUE3QixHQUEwQyxVQUFqRTtBQUNBakMsSUFBQUEsRUFBRSxDQUFDNkUsT0FBSCxLQUFlLFFBQWYsS0FBNEIrN0IsV0FBVyxDQUFDLzdCLE9BQVosR0FBc0IsY0FBbEQ7QUFDQWc4QixJQUFBQSxRQUFRLENBQUN2SCxPQUFELENBQVIsR0FBb0J1SCxRQUFRLENBQUN4SCxNQUFELENBQVIsR0FBbUJ1SCxXQUFXLENBQUNFLFNBQVosR0FBd0IsTUFBL0Q7QUFDQUYsSUFBQUEsV0FBVyxDQUFDNzdCLFFBQVosR0FBdUIsU0FBdkI7QUFDQTY3QixJQUFBQSxXQUFXLENBQUN4Z0MsU0FBWixHQUF3QixZQUF4QjtBQUNBd2dDLElBQUFBLFdBQVcsQ0FBQ3JILE1BQUQsQ0FBWCxHQUFzQm9CLFFBQVEsQ0FBQzBGLEdBQUQsRUFBTTlRLFdBQU4sQ0FBUixHQUE2QjBLLEdBQW5EO0FBQ0EyRyxJQUFBQSxXQUFXLENBQUNwSCxPQUFELENBQVgsR0FBdUJtQixRQUFRLENBQUMwRixHQUFELEVBQU0xUSxTQUFOLENBQVIsR0FBMkJzSyxHQUFsRDtBQUNBMkcsSUFBQUEsV0FBVyxDQUFDL0csUUFBRCxDQUFYLEdBQXdCZ0gsUUFBUSxDQUFDL0csT0FBRCxDQUFSLEdBQW9CK0csUUFBUSxDQUFDekgsSUFBRCxDQUFSLEdBQWlCeUgsUUFBUSxDQUFDMUgsS0FBRCxDQUFSLEdBQWtCLEdBQS9FOztBQUVBcUgsSUFBQUEsU0FBUyxDQUFDRSxXQUFELENBQVQ7O0FBRUFHLElBQUFBLFFBQVEsQ0FBQ3RILE1BQUQsQ0FBUixHQUFtQnNILFFBQVEsQ0FBQyxRQUFROUcsTUFBVCxDQUFSLEdBQTJCLzVCLEVBQUUsQ0FBQ3U1QixNQUFELENBQWhEO0FBQ0FzSCxJQUFBQSxRQUFRLENBQUNySCxPQUFELENBQVIsR0FBb0JxSCxRQUFRLENBQUMsUUFBUTdHLE9BQVQsQ0FBUixHQUE0Qmg2QixFQUFFLENBQUN3NUIsT0FBRCxDQUFsRDtBQUNBcUgsSUFBQUEsUUFBUSxDQUFDaEgsUUFBRCxDQUFSLEdBQXFCNzVCLEVBQUUsQ0FBQzY1QixRQUFELENBQXZCO0FBQ0F3RyxJQUFBQSxHQUFHLENBQUM3a0MsVUFBSixDQUFlNGhCLFlBQWYsQ0FBNEJrakIsTUFBNUIsRUFBb0NELEdBQXBDO0FBQ0FDLElBQUFBLE1BQU0sQ0FBQy83QixXQUFQLENBQW1CODdCLEdBQW5CO0FBQ0Q7QUFDRixDQXprQkQ7QUFBQSxJQTBrQklVLFFBQVEsR0FBRyxVQTFrQmY7QUFBQSxJQTJrQklQLFNBQVMsR0FBRyxTQUFTQSxTQUFULENBQW1CRCxLQUFuQixFQUEwQjtBQUN4QyxNQUFJQSxLQUFKLEVBQVc7QUFDVCxRQUFJL3BDLEtBQUssR0FBRytwQyxLQUFLLENBQUM3bkIsQ0FBTixDQUFRbGlCLEtBQXBCO0FBQUEsUUFDSXdLLENBQUMsR0FBR3UvQixLQUFLLENBQUNyb0MsTUFEZDtBQUFBLFFBRUlELENBQUMsR0FBRyxDQUZSO0FBQUEsUUFHSUwsQ0FISjtBQUFBLFFBSUl2QyxLQUpKO0FBS0EsS0FBQ2tyQyxLQUFLLENBQUM3bkIsQ0FBTixDQUFRdFAsS0FBUixJQUFpQnZWLGtCQUFJLENBQUN3VixJQUFMLENBQVVDLFFBQVYsQ0FBbUJpM0IsS0FBSyxDQUFDN25CLENBQXpCLENBQWxCLEVBQStDOUwsT0FBL0MsR0FBeUQsQ0FBekQsQ0FOUyxDQU1tRDs7QUFFNUQsV0FBTzNVLENBQUMsR0FBRytJLENBQVgsRUFBYy9JLENBQUMsSUFBSSxDQUFuQixFQUFzQjtBQUNwQjVDLE1BQUFBLEtBQUssR0FBR2tyQyxLQUFLLENBQUN0b0MsQ0FBQyxHQUFHLENBQUwsQ0FBYjtBQUNBTCxNQUFBQSxDQUFDLEdBQUcyb0MsS0FBSyxDQUFDdG9DLENBQUQsQ0FBVDs7QUFFQSxVQUFJNUMsS0FBSixFQUFXO0FBQ1RtQixRQUFBQSxLQUFLLENBQUNvQixDQUFELENBQUwsR0FBV3ZDLEtBQVg7QUFDRCxPQUZELE1BRU8sSUFBSW1CLEtBQUssQ0FBQ29CLENBQUQsQ0FBVCxFQUFjO0FBQ25CcEIsUUFBQUEsS0FBSyxDQUFDNkIsY0FBTixDQUFxQlQsQ0FBQyxDQUFDdEIsT0FBRixDQUFVeXFDLFFBQVYsRUFBb0IsS0FBcEIsRUFBMkJwa0MsV0FBM0IsRUFBckI7QUFDRDtBQUNGO0FBQ0Y7QUFDRixDQS9sQkQ7QUFBQSxJQWdtQklxa0MsU0FBUyxHQUFHLFNBQVNBLFNBQVQsQ0FBbUJ2bkMsT0FBbkIsRUFBNEI7QUFDMUM7QUFDQSxNQUFJdUgsQ0FBQyxHQUFHbS9CLFdBQVcsQ0FBQ2pvQyxNQUFwQjtBQUFBLE1BQ0kxQixLQUFLLEdBQUdpRCxPQUFPLENBQUNqRCxLQURwQjtBQUFBLE1BRUkrcEMsS0FBSyxHQUFHLEVBRlo7QUFBQSxNQUdJdG9DLENBQUMsR0FBRyxDQUhSOztBQUtBLFNBQU9BLENBQUMsR0FBRytJLENBQVgsRUFBYy9JLENBQUMsRUFBZixFQUFtQjtBQUNqQnNvQyxJQUFBQSxLQUFLLENBQUM3bkMsSUFBTixDQUFXeW5DLFdBQVcsQ0FBQ2xvQyxDQUFELENBQXRCLEVBQTJCekIsS0FBSyxDQUFDMnBDLFdBQVcsQ0FBQ2xvQyxDQUFELENBQVosQ0FBaEM7QUFDRDs7QUFFRHNvQyxFQUFBQSxLQUFLLENBQUM3bkIsQ0FBTixHQUFVamYsT0FBVjtBQUNBLFNBQU84bUMsS0FBUDtBQUNELENBN21CRDtBQUFBLElBOG1CSVUsVUFBVSxHQUFHLFNBQVNBLFVBQVQsQ0FBb0JWLEtBQXBCLEVBQTJCVyxRQUEzQixFQUFxQ0MsV0FBckMsRUFBa0Q7QUFDakUsTUFBSTdpQyxNQUFNLEdBQUcsRUFBYjtBQUFBLE1BQ0kwQyxDQUFDLEdBQUd1L0IsS0FBSyxDQUFDcm9DLE1BRGQ7QUFBQSxNQUVJRCxDQUFDLEdBQUdrcEMsV0FBVyxHQUFHLENBQUgsR0FBTyxDQUYxQjtBQUFBLE1BR0k7QUFDSnZwQyxFQUFBQSxDQUpBOztBQU1BLFNBQU9LLENBQUMsR0FBRytJLENBQVgsRUFBYy9JLENBQUMsSUFBSSxDQUFuQixFQUFzQjtBQUNwQkwsSUFBQUEsQ0FBQyxHQUFHMm9DLEtBQUssQ0FBQ3RvQyxDQUFELENBQVQ7QUFDQXFHLElBQUFBLE1BQU0sQ0FBQzVGLElBQVAsQ0FBWWQsQ0FBWixFQUFlQSxDQUFDLElBQUlzcEMsUUFBTCxHQUFnQkEsUUFBUSxDQUFDdHBDLENBQUQsQ0FBeEIsR0FBOEIyb0MsS0FBSyxDQUFDdG9DLENBQUMsR0FBRyxDQUFMLENBQWxEO0FBQ0Q7O0FBRURxRyxFQUFBQSxNQUFNLENBQUNvYSxDQUFQLEdBQVc2bkIsS0FBSyxDQUFDN25CLENBQWpCO0FBQ0EsU0FBT3BhLE1BQVA7QUFDRCxDQTVuQkQ7QUFBQSxJQTZuQkkwNUIsV0FBVyxHQUFHO0FBQ2hCOTZCLEVBQUFBLElBQUksRUFBRSxDQURVO0FBRWhCQyxFQUFBQSxHQUFHLEVBQUU7QUFGVyxDQTduQmxCO0FBQUEsSUFpb0JJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQWlrQyxjQUFjLEdBQUcsU0FBU0EsY0FBVCxDQUF3Qi9yQyxLQUF4QixFQUErQmtULE9BQS9CLEVBQXdDODRCLFlBQXhDLEVBQXNEanNCLFNBQXRELEVBQWlFdFosTUFBakUsRUFBeUV5aEMsTUFBekUsRUFBaUYrRCxjQUFqRixFQUFpR3J1QyxJQUFqRyxFQUF1R3N1QyxjQUF2RyxFQUF1SEMsV0FBdkgsRUFBb0kxRSxnQkFBcEksRUFBc0oyRSxXQUF0SixFQUFtSzVFLGtCQUFuSyxFQUF1TDtBQUN0TXpuQyxFQUFBQSxXQUFXLENBQUNDLEtBQUQsQ0FBWCxLQUF1QkEsS0FBSyxHQUFHQSxLQUFLLENBQUNwQyxJQUFELENBQXBDOztBQUVBLE1BQUk4a0IsU0FBUyxDQUFDMWlCLEtBQUQsQ0FBVCxJQUFvQkEsS0FBSyxDQUFDZ3ZCLE1BQU4sQ0FBYSxDQUFiLEVBQWdCLENBQWhCLE1BQXVCLEtBQS9DLEVBQXNEO0FBQ3BEaHZCLElBQUFBLEtBQUssR0FBR29zQyxXQUFXLElBQUlwc0MsS0FBSyxDQUFDaXZCLE1BQU4sQ0FBYSxDQUFiLE1BQW9CLEdBQXBCLEdBQTBCZ1ksV0FBVyxDQUFDLE1BQU1qbkMsS0FBSyxDQUFDZ3ZCLE1BQU4sQ0FBYSxDQUFiLENBQVAsRUFBd0JnZCxZQUF4QixDQUFyQyxHQUE2RSxDQUFqRixDQUFuQjtBQUNEOztBQUVELE1BQUl4dEIsSUFBSSxHQUFHZ3BCLGtCQUFrQixHQUFHQSxrQkFBa0IsQ0FBQ2hwQixJQUFuQixFQUFILEdBQStCLENBQTVEO0FBQUEsTUFDSWxVLEVBREo7QUFBQSxNQUVJQyxFQUZKO0FBQUEsTUFHSW5HLE9BSEo7QUFJQW9qQyxFQUFBQSxrQkFBa0IsSUFBSUEsa0JBQWtCLENBQUM2RSxJQUFuQixDQUF3QixDQUF4QixDQUF0Qjs7QUFFQSxNQUFJLENBQUMxcEIsU0FBUyxDQUFDM2lCLEtBQUQsQ0FBZCxFQUF1QjtBQUNyQkQsSUFBQUEsV0FBVyxDQUFDbVQsT0FBRCxDQUFYLEtBQXlCQSxPQUFPLEdBQUdBLE9BQU8sQ0FBQ3RWLElBQUQsQ0FBMUM7QUFDQSxRQUFJMHVDLE9BQU8sR0FBR3RzQyxLQUFLLENBQUNnUixLQUFOLENBQVksR0FBWixDQUFkO0FBQUEsUUFDSXNILE1BREo7QUFBQSxRQUVJaTBCLFdBRko7QUFBQSxRQUdJQyxZQUhKO0FBQUEsUUFJSWg5QixPQUpKO0FBS0FwTCxJQUFBQSxPQUFPLEdBQUdvMkIsVUFBVSxDQUFDdG5CLE9BQUQsQ0FBVixJQUF1QnRVLGtCQUFqQztBQUNBMFosSUFBQUEsTUFBTSxHQUFHaFAsVUFBVSxDQUFDbEYsT0FBRCxDQUFWLElBQXVCLEVBQWhDOztBQUVBLFFBQUksQ0FBQyxDQUFDa1UsTUFBRCxJQUFXLENBQUNBLE1BQU0sQ0FBQ3pRLElBQVIsSUFBZ0IsQ0FBQ3lRLE1BQU0sQ0FBQ3hRLEdBQXBDLEtBQTRDUCxpQkFBaUIsQ0FBQ25ELE9BQUQsQ0FBakIsQ0FBMkJvTCxPQUEzQixLQUF1QyxNQUF2RixFQUErRjtBQUM3RjtBQUNBQSxNQUFBQSxPQUFPLEdBQUdwTCxPQUFPLENBQUNqRCxLQUFSLENBQWNxTyxPQUF4QjtBQUNBcEwsTUFBQUEsT0FBTyxDQUFDakQsS0FBUixDQUFjcU8sT0FBZCxHQUF3QixPQUF4QjtBQUNBOEksTUFBQUEsTUFBTSxHQUFHaFAsVUFBVSxDQUFDbEYsT0FBRCxDQUFuQjtBQUNBb0wsTUFBQUEsT0FBTyxHQUFHcEwsT0FBTyxDQUFDakQsS0FBUixDQUFjcU8sT0FBZCxHQUF3QkEsT0FBM0IsR0FBcUNwTCxPQUFPLENBQUNqRCxLQUFSLENBQWM2QixjQUFkLENBQTZCLFNBQTdCLENBQTVDO0FBQ0Q7O0FBRUR1cEMsSUFBQUEsV0FBVyxHQUFHdEYsV0FBVyxDQUFDcUYsT0FBTyxDQUFDLENBQUQsQ0FBUixFQUFhaDBCLE1BQU0sQ0FBQ3lILFNBQVMsQ0FBQ3pDLENBQVgsQ0FBbkIsQ0FBekI7QUFDQWt2QixJQUFBQSxZQUFZLEdBQUd2RixXQUFXLENBQUNxRixPQUFPLENBQUMsQ0FBRCxDQUFQLElBQWMsR0FBZixFQUFvQk4sWUFBcEIsQ0FBMUI7QUFDQWhzQyxJQUFBQSxLQUFLLEdBQUdzWSxNQUFNLENBQUN5SCxTQUFTLENBQUN4ZCxDQUFYLENBQU4sR0FBc0IycEMsY0FBYyxDQUFDbnNCLFNBQVMsQ0FBQ3hkLENBQVgsQ0FBcEMsR0FBb0Q0cEMsV0FBcEQsR0FBa0VJLFdBQWxFLEdBQWdGOWxDLE1BQWhGLEdBQXlGK2xDLFlBQWpHO0FBQ0FQLElBQUFBLGNBQWMsSUFBSWhFLGVBQWUsQ0FBQ2dFLGNBQUQsRUFBaUJPLFlBQWpCLEVBQStCenNCLFNBQS9CLEVBQTBDaXNCLFlBQVksR0FBR1EsWUFBZixHQUE4QixFQUE5QixJQUFvQ1AsY0FBYyxDQUFDbkUsUUFBZixJQUEyQjBFLFlBQVksR0FBRyxFQUF4SCxDQUFqQztBQUNBUixJQUFBQSxZQUFZLElBQUlBLFlBQVksR0FBR1EsWUFBL0IsQ0F0QnFCLENBc0J3QjtBQUM5QyxHQXZCRCxNQXVCTyxJQUFJUCxjQUFKLEVBQW9CO0FBQ3pCaEUsSUFBQUEsZUFBZSxDQUFDZ0UsY0FBRCxFQUFpQkQsWUFBakIsRUFBK0Jqc0IsU0FBL0IsRUFBMEMsSUFBMUMsQ0FBZjtBQUNEOztBQUVELE1BQUltb0IsTUFBSixFQUFZO0FBQ1YsUUFBSXQ3QixRQUFRLEdBQUc1TSxLQUFLLEdBQUdnc0MsWUFBdkI7QUFBQSxRQUNJckUsT0FBTyxHQUFHTyxNQUFNLENBQUNKLFFBRHJCO0FBRUF4OUIsSUFBQUEsRUFBRSxHQUFHLFdBQVd5VixTQUFTLENBQUNpUSxFQUExQjs7QUFFQWlZLElBQUFBLGVBQWUsQ0FBQ0MsTUFBRCxFQUFTdDdCLFFBQVQsRUFBbUJtVCxTQUFuQixFQUE4QjRuQixPQUFPLElBQUkvNkIsUUFBUSxHQUFHLEVBQXRCLElBQTRCLENBQUMrNkIsT0FBRCxJQUFZLENBQUNGLGdCQUFnQixHQUFHbG5DLElBQUksQ0FBQ29HLEdBQUwsQ0FBUy9ILGtCQUFLLENBQUMwTCxFQUFELENBQWQsRUFBb0I0dEIsbUJBQU0sQ0FBQzV0QixFQUFELENBQTFCLENBQUgsR0FBcUM0OUIsTUFBTSxDQUFDL2hDLFVBQVAsQ0FBa0JtRSxFQUFsQixDQUF0RCxLQUFnRnNDLFFBQVEsR0FBRyxDQUFqSyxDQUFmOztBQUVBLFFBQUk2NkIsZ0JBQUosRUFBc0I7QUFDcEJ5RSxNQUFBQSxjQUFjLEdBQUc1aUMsVUFBVSxDQUFDMmlDLGNBQUQsQ0FBM0I7QUFDQXhFLE1BQUFBLGdCQUFnQixLQUFLUyxNQUFNLENBQUMvbUMsS0FBUCxDQUFhNGUsU0FBUyxDQUFDd2EsRUFBVixDQUFhaDRCLENBQTFCLElBQStCMnBDLGNBQWMsQ0FBQ25zQixTQUFTLENBQUN3YSxFQUFWLENBQWFoNEIsQ0FBZCxDQUFkLEdBQWlDd2QsU0FBUyxDQUFDd2EsRUFBVixDQUFhbGEsQ0FBOUMsR0FBa0Q2bkIsTUFBTSxDQUFDRixPQUF6RCxHQUFtRXBELEdBQXZHLENBQWhCO0FBQ0Q7QUFDRjs7QUFFRCxNQUFJNEMsa0JBQWtCLElBQUlwakMsT0FBMUIsRUFBbUM7QUFDakNrRyxJQUFBQSxFQUFFLEdBQUdoQixVQUFVLENBQUNsRixPQUFELENBQWY7QUFDQW9qQyxJQUFBQSxrQkFBa0IsQ0FBQzZFLElBQW5CLENBQXdCRCxXQUF4QjtBQUNBN2hDLElBQUFBLEVBQUUsR0FBR2pCLFVBQVUsQ0FBQ2xGLE9BQUQsQ0FBZjtBQUNBb2pDLElBQUFBLGtCQUFrQixDQUFDaUYsYUFBbkIsR0FBbUNuaUMsRUFBRSxDQUFDeVYsU0FBUyxDQUFDeGQsQ0FBWCxDQUFGLEdBQWtCZ0ksRUFBRSxDQUFDd1YsU0FBUyxDQUFDeGQsQ0FBWCxDQUF2RDtBQUNBdkMsSUFBQUEsS0FBSyxHQUFHQSxLQUFLLEdBQUd3bkMsa0JBQWtCLENBQUNpRixhQUEzQixHQUEyQ0wsV0FBbkQ7QUFDRDs7QUFFRDVFLEVBQUFBLGtCQUFrQixJQUFJQSxrQkFBa0IsQ0FBQzZFLElBQW5CLENBQXdCN3RCLElBQXhCLENBQXRCO0FBQ0EsU0FBT2dwQixrQkFBa0IsR0FBR3huQyxLQUFILEdBQVdPLElBQUksQ0FBQ0MsS0FBTCxDQUFXUixLQUFYLENBQXBDO0FBQ0QsQ0F4c0JEO0FBQUEsSUF5c0JJMHNDLFVBQVUsR0FBRyxvQ0F6c0JqQjtBQUFBLElBMHNCSUMsU0FBUyxHQUFHLFNBQVNBLFNBQVQsQ0FBbUJ2b0MsT0FBbkIsRUFBNEJ1TSxNQUE1QixFQUFvQzdJLEdBQXBDLEVBQXlDRCxJQUF6QyxFQUErQztBQUM3RCxNQUFJekQsT0FBTyxDQUFDK0IsVUFBUixLQUF1QndLLE1BQTNCLEVBQW1DO0FBQ2pDLFFBQUl4UCxLQUFLLEdBQUdpRCxPQUFPLENBQUNqRCxLQUFwQjtBQUFBLFFBQ0lvQixDQURKO0FBQUEsUUFFSW9JLEVBRko7O0FBSUEsUUFBSWdHLE1BQU0sS0FBSy9SLGtCQUFmLEVBQXNCO0FBQ3BCd0YsTUFBQUEsT0FBTyxDQUFDd29DLE9BQVIsR0FBa0J6ckMsS0FBSyxDQUFDK08sT0FBeEIsQ0FEb0IsQ0FDYTs7QUFFakN2RixNQUFBQSxFQUFFLEdBQUdwRCxpQkFBaUIsQ0FBQ25ELE9BQUQsQ0FBdEI7O0FBRUEsV0FBSzdCLENBQUwsSUFBVW9JLEVBQVYsRUFBYztBQUNaO0FBQ0EsWUFBSSxDQUFDLENBQUNwSSxDQUFGLElBQU8sQ0FBQ21xQyxVQUFVLENBQUN4Z0MsSUFBWCxDQUFnQjNKLENBQWhCLENBQVIsSUFBOEJvSSxFQUFFLENBQUNwSSxDQUFELENBQWhDLElBQXVDLE9BQU9wQixLQUFLLENBQUNvQixDQUFELENBQVosS0FBb0IsUUFBM0QsSUFBdUVBLENBQUMsS0FBSyxHQUFqRixFQUFzRjtBQUNwRnBCLFVBQUFBLEtBQUssQ0FBQ29CLENBQUQsQ0FBTCxHQUFXb0ksRUFBRSxDQUFDcEksQ0FBRCxDQUFiO0FBQ0Q7QUFDRjs7QUFFRHBCLE1BQUFBLEtBQUssQ0FBQzJHLEdBQU4sR0FBWUEsR0FBWjtBQUNBM0csTUFBQUEsS0FBSyxDQUFDMEcsSUFBTixHQUFhQSxJQUFiO0FBQ0QsS0FkRCxNQWNPO0FBQ0wxRyxNQUFBQSxLQUFLLENBQUMrTyxPQUFOLEdBQWdCOUwsT0FBTyxDQUFDd29DLE9BQXhCO0FBQ0Q7O0FBRURwdUMsSUFBQUEsa0JBQUksQ0FBQ3dWLElBQUwsQ0FBVUMsUUFBVixDQUFtQjdQLE9BQW5CLEVBQTRCbVQsT0FBNUIsR0FBc0MsQ0FBdEM7QUFDQTVHLElBQUFBLE1BQU0sQ0FBQ3pCLFdBQVAsQ0FBbUI5SyxPQUFuQjtBQUNEO0FBQ0YsQ0FydUJEO0FBQUEsSUFzdUJJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0F5b0MsZ0JBQWdCLEdBQUcsU0FBU0EsZ0JBQVQsQ0FBMEJoSyxRQUExQixFQUFvQzlpQixTQUFwQyxFQUErQztBQUNoRSxNQUFJK3NCLFNBQVMsR0FBR25TLGNBQWMsQ0FBQ2tJLFFBQUQsRUFBVzlpQixTQUFYLENBQTlCO0FBQUEsTUFDSXFULElBQUksR0FBRyxZQUFZclQsU0FBUyxDQUFDeFYsRUFEakM7QUFBQSxNQUVJO0FBQ0p3aUMsRUFBQUEsV0FIQTtBQUFBLE1BSUlDLFdBSko7QUFBQSxNQUtJQyxRQUFRLEdBQUcsU0FBU0EsUUFBVCxDQUFrQm4yQixRQUFsQixFQUE0QmhPLElBQTVCLEVBQWtDb2tDLFlBQWxDLEVBQWdEQyxPQUFoRCxFQUF5REMsT0FBekQsRUFBa0U7QUFDL0UsUUFBSXQwQixLQUFLLEdBQUdtMEIsUUFBUSxDQUFDbjBCLEtBQXJCO0FBQUEsUUFDSTlVLFVBQVUsR0FBRzhFLElBQUksQ0FBQzlFLFVBRHRCO0FBQUEsUUFFSXFwQyxTQUFTLEdBQUcsRUFGaEI7QUFHQUgsSUFBQUEsWUFBWSxHQUFHQSxZQUFZLElBQUlKLFNBQVMsRUFBeEM7QUFDQU0sSUFBQUEsT0FBTyxHQUFHRCxPQUFPLElBQUlDLE9BQVgsSUFBc0IsQ0FBaEMsQ0FMK0UsQ0FLNUM7O0FBRW5DRCxJQUFBQSxPQUFPLEdBQUdBLE9BQU8sSUFBSXIyQixRQUFRLEdBQUdvMkIsWUFBaEM7QUFDQXAwQixJQUFBQSxLQUFLLElBQUlBLEtBQUssQ0FBQzRDLElBQU4sRUFBVDtBQUNBcXhCLElBQUFBLFdBQVcsR0FBR3hzQyxJQUFJLENBQUNDLEtBQUwsQ0FBVzBzQyxZQUFYLENBQWQ7QUFDQXBrQyxJQUFBQSxJQUFJLENBQUNzcUIsSUFBRCxDQUFKLEdBQWF0YyxRQUFiO0FBQ0FoTyxJQUFBQSxJQUFJLENBQUN1a0MsU0FBTCxHQUFpQkEsU0FBakI7O0FBRUFBLElBQUFBLFNBQVMsQ0FBQ2phLElBQUQsQ0FBVCxHQUFrQixVQUFVcHpCLEtBQVYsRUFBaUI7QUFDakNBLE1BQUFBLEtBQUssR0FBR00sTUFBTSxDQUFDd3NDLFNBQVMsRUFBVixDQUFkLENBRGlDLENBQ0o7O0FBRTdCLFVBQUk5c0MsS0FBSyxLQUFLK3NDLFdBQVYsSUFBeUIvc0MsS0FBSyxLQUFLZ3RDLFdBQW5DLElBQWtEenNDLElBQUksQ0FBQzJiLEdBQUwsQ0FBU2xjLEtBQUssR0FBRytzQyxXQUFqQixJQUFnQyxDQUFsRixJQUF1RnhzQyxJQUFJLENBQUMyYixHQUFMLENBQVNsYyxLQUFLLEdBQUdndEMsV0FBakIsSUFBZ0MsQ0FBM0gsRUFBOEg7QUFDNUg7QUFDQWwwQixRQUFBQSxLQUFLLENBQUM0QyxJQUFOO0FBQ0F1eEIsUUFBQUEsUUFBUSxDQUFDbjBCLEtBQVQsR0FBaUIsQ0FBakI7QUFDRCxPQUpELE1BSU87QUFDTDlZLFFBQUFBLEtBQUssR0FBR2t0QyxZQUFZLEdBQUdDLE9BQU8sR0FBR3IwQixLQUFLLENBQUNnSCxLQUEvQixHQUF1Q3N0QixPQUFPLEdBQUd0MEIsS0FBSyxDQUFDZ0gsS0FBaEIsR0FBd0JoSCxLQUFLLENBQUNnSCxLQUE3RTtBQUNEOztBQUVEa3RCLE1BQUFBLFdBQVcsR0FBR0QsV0FBZDtBQUNBLGFBQU9BLFdBQVcsR0FBR3pzQyxNQUFNLENBQUNOLEtBQUQsQ0FBM0I7QUFDRCxLQWJEOztBQWVBOEksSUFBQUEsSUFBSSxDQUFDOUUsVUFBTCxHQUFrQixZQUFZO0FBQzVCaXBDLE1BQUFBLFFBQVEsQ0FBQ24wQixLQUFULEdBQWlCLENBQWpCO0FBQ0E5VSxNQUFBQSxVQUFVLElBQUlBLFVBQVUsQ0FBQzZILElBQVgsQ0FBZ0JpTixLQUFoQixDQUFkO0FBQ0QsS0FIRDs7QUFLQUEsSUFBQUEsS0FBSyxHQUFHbTBCLFFBQVEsQ0FBQ24wQixLQUFULEdBQWlCdGEsa0JBQUksQ0FBQ29GLEVBQUwsQ0FBUWkvQixRQUFSLEVBQWtCLzVCLElBQWxCLENBQXpCO0FBQ0EsV0FBT2dRLEtBQVA7QUFDRCxHQXhDRDs7QUEwQ0ErcEIsRUFBQUEsUUFBUSxDQUFDelAsSUFBRCxDQUFSLEdBQWlCMFosU0FBakI7O0FBRUFBLEVBQUFBLFNBQVMsQ0FBQ3pHLFlBQVYsR0FBeUIsWUFBWTtBQUNuQyxXQUFPNEcsUUFBUSxDQUFDbjBCLEtBQVQsSUFBa0JtMEIsUUFBUSxDQUFDbjBCLEtBQVQsQ0FBZTRDLElBQWYsRUFBbEIsS0FBNEN1eEIsUUFBUSxDQUFDbjBCLEtBQVQsR0FBaUIsQ0FBN0QsQ0FBUDtBQUNELEdBRkQ7O0FBSUEzVSxFQUFBQSx5QkFBWSxDQUFDMCtCLFFBQUQsRUFBVyxPQUFYLEVBQW9CaUssU0FBUyxDQUFDekcsWUFBOUIsQ0FBWixDQWpEZ0UsQ0FpRFA7OztBQUd6RCxTQUFPNEcsUUFBUDtBQUNELENBbHlCRDs7QUFveUJPLElBQUk1VSwyQkFBYSxHQUFHLGFBQWEsWUFBWTtBQUNsRCxXQUFTQSxhQUFULENBQXVCdnZCLElBQXZCLEVBQTZCNDZCLFNBQTdCLEVBQXdDO0FBQ3RDM2tDLElBQUFBLHlCQUFZLElBQUlzNUIsYUFBYSxDQUFDcFgsUUFBZCxDQUF1QnppQixrQkFBdkIsQ0FBaEIsSUFBZ0RpVCxPQUFPLENBQUNDLElBQVIsQ0FBYSwyQ0FBYixDQUFoRDtBQUNBLFNBQUsya0IsSUFBTCxDQUFVdnRCLElBQVYsRUFBZ0I0NkIsU0FBaEI7QUFDRDs7QUFFRCxNQUFJOXhCLE1BQU0sR0FBR3ltQixhQUFhLENBQUNwNkIsU0FBM0I7O0FBRUEyVCxFQUFBQSxNQUFNLENBQUN5a0IsSUFBUCxHQUFjLFNBQVNBLElBQVQsQ0FBY3Z0QixJQUFkLEVBQW9CNDZCLFNBQXBCLEVBQStCO0FBQzNDLFNBQUsxZ0IsUUFBTCxHQUFnQixLQUFLL0ksS0FBTCxHQUFhLENBQTdCO0FBQ0EsU0FBS25SLElBQUwsSUFBYSxLQUFLNFMsSUFBTCxDQUFVLElBQVYsRUFBZ0IsSUFBaEIsQ0FBYixDQUYyQyxDQUVQOztBQUVwQyxRQUFJLENBQUM2bUIsUUFBTCxFQUFlO0FBQ2IsV0FBS3BpQixNQUFMLEdBQWMsS0FBS2txQixPQUFMLEdBQWUsS0FBSzN1QixJQUFMLEdBQVkrYyx5QkFBekM7QUFDQTtBQUNEOztBQUVEM3ZCLElBQUFBLElBQUksR0FBRzVFLFlBQVksQ0FBQ3dlLFNBQVMsQ0FBQzVaLElBQUQsQ0FBVCxJQUFtQjZaLFNBQVMsQ0FBQzdaLElBQUQsQ0FBNUIsSUFBc0NBLElBQUksQ0FBQ3pDLFFBQTNDLEdBQXNEO0FBQ3hFNk0sTUFBQUEsT0FBTyxFQUFFcEs7QUFEK0QsS0FBdEQsR0FFaEJBLElBRmUsRUFFVDg5QixTQUZTLENBQW5COztBQUlBLFFBQUlyUSxLQUFLLEdBQUd6dEIsSUFBWjtBQUFBLFFBQ0l5USxRQUFRLEdBQUdnZCxLQUFLLENBQUNoZCxRQURyQjtBQUFBLFFBRUkrekIsV0FBVyxHQUFHL1csS0FBSyxDQUFDK1csV0FGeEI7QUFBQSxRQUdJOXNCLEVBQUUsR0FBRytWLEtBQUssQ0FBQy9WLEVBSGY7QUFBQSxRQUlJK3NCLFFBQVEsR0FBR2hYLEtBQUssQ0FBQ2dYLFFBSnJCO0FBQUEsUUFLSUMsU0FBUyxHQUFHalgsS0FBSyxDQUFDaVgsU0FMdEI7QUFBQSxRQU1JQyxLQUFLLEdBQUdsWCxLQUFLLENBQUNrWCxLQU5sQjtBQUFBLFFBT0l2NkIsT0FBTyxHQUFHcWpCLEtBQUssQ0FBQ3JqQixPQVBwQjtBQUFBLFFBUUk4M0IsR0FBRyxHQUFHelUsS0FBSyxDQUFDeVUsR0FSaEI7QUFBQSxRQVNJMEMsVUFBVSxHQUFHblgsS0FBSyxDQUFDbVgsVUFUdkI7QUFBQSxRQVVJQyxtQkFBbUIsR0FBR3BYLEtBQUssQ0FBQ29YLG1CQVZoQztBQUFBLFFBV0k3RyxhQUFhLEdBQUd2USxLQUFLLENBQUN1USxhQVgxQjtBQUFBLFFBWUk4RyxlQUFlLEdBQUdyWCxLQUFLLENBQUNxWCxlQVo1QjtBQUFBLFFBYUlDLGNBQWMsR0FBR3RYLEtBQUssQ0FBQ3NYLGNBYjNCO0FBQUEsUUFjSUMsSUFBSSxHQUFHdlgsS0FBSyxDQUFDdVgsSUFkakI7QUFBQSxRQWVJdGlDLElBQUksR0FBRytxQixLQUFLLENBQUMvcUIsSUFmakI7QUFBQSxRQWdCSXVpQyxXQUFXLEdBQUd4WCxLQUFLLENBQUN3WCxXQWhCeEI7QUFBQSxRQWlCSUMsU0FBUyxHQUFHelgsS0FBSyxDQUFDeVgsU0FqQnRCO0FBQUEsUUFrQkl4RyxrQkFBa0IsR0FBR2pSLEtBQUssQ0FBQ2lSLGtCQWxCL0I7QUFBQSxRQW1CSXlHLGFBQWEsR0FBRzFYLEtBQUssQ0FBQzBYLGFBbkIxQjtBQUFBLFFBb0JJQyxlQUFlLEdBQUczWCxLQUFLLENBQUMyWCxlQXBCNUI7QUFBQSxRQXFCSW51QixTQUFTLEdBQUdqWCxJQUFJLENBQUNxbEMsVUFBTCxJQUFtQnJsQyxJQUFJLENBQUMwK0Isa0JBQUwsSUFBMkIxK0IsSUFBSSxDQUFDcWxDLFVBQUwsS0FBb0IsS0FBbEUsR0FBMEVqVSxXQUExRSxHQUF3RkksU0FyQnhHO0FBQUEsUUFzQkk4VCxRQUFRLEdBQUcsQ0FBQ1gsS0FBRCxJQUFVQSxLQUFLLEtBQUssQ0F0Qm5DO0FBQUEsUUF1Qkk1SyxRQUFRLEdBQUdySSxVQUFVLENBQUMxeEIsSUFBSSxDQUFDKzVCLFFBQUwsSUFBaUJwa0MsaUJBQWxCLENBdkJ6QjtBQUFBLFFBd0JJNHZDLGFBQWEsR0FBRzd2QyxrQkFBSSxDQUFDd1YsSUFBTCxDQUFVQyxRQUFWLENBQW1CNHVCLFFBQW5CLENBeEJwQjtBQUFBLFFBeUJJaEUsVUFBVSxHQUFHekYsd0JBQVcsQ0FBQ3lKLFFBQUQsQ0F6QjVCO0FBQUEsUUEwQkk0RSxnQkFBZ0IsR0FBRyxDQUFDLGFBQWEzK0IsSUFBYixHQUFvQkEsSUFBSSxDQUFDd2xDLE9BQXpCLEdBQW1DblYsYUFBYSxDQUFDMEosUUFBRCxFQUFXLFNBQVgsQ0FBYixJQUFzQ2hFLFVBQVUsSUFBSSxPQUF4RixNQUFxRyxPQTFCNUg7QUFBQSxRQTJCSTBQLFNBQVMsR0FBRyxDQUFDemxDLElBQUksQ0FBQzBsQyxPQUFOLEVBQWUxbEMsSUFBSSxDQUFDMmxDLE9BQXBCLEVBQTZCM2xDLElBQUksQ0FBQzRsQyxXQUFsQyxFQUErQzVsQyxJQUFJLENBQUM2bEMsV0FBcEQsQ0EzQmhCO0FBQUEsUUE0Qkk5SCxhQUFhLEdBQUd1SCxRQUFRLElBQUl0bEMsSUFBSSxDQUFDKzlCLGFBQUwsQ0FBbUI3MUIsS0FBbkIsQ0FBeUIsR0FBekIsQ0E1QmhDO0FBQUEsUUE2Qkk0OUIsT0FBTyxHQUFHLGFBQWE5bEMsSUFBYixHQUFvQkEsSUFBSSxDQUFDOGxDLE9BQXpCLEdBQW1DaEksU0FBUyxDQUFDZ0ksT0E3QjNEO0FBQUEsUUE4Qkl6QyxXQUFXLEdBQUd0TixVQUFVLEdBQUcsQ0FBSCxHQUFPN3pCLFVBQVUsQ0FBQ3pELGlCQUFpQixDQUFDczdCLFFBQUQsQ0FBakIsQ0FBNEIsV0FBVzlpQixTQUFTLENBQUN4VixFQUFyQixHQUEwQm02QixNQUF0RCxDQUFELENBQVYsSUFBNkUsQ0E5QmhIO0FBQUEsUUErQkk5bUMsSUFBSSxHQUFHLElBL0JYO0FBQUEsUUFnQ0lpeEMsYUFBYSxHQUFHL2xDLElBQUksQ0FBQytsQyxhQUFMLElBQXNCLFlBQVk7QUFDcEQsYUFBTy9sQyxJQUFJLENBQUMrbEMsYUFBTCxDQUFtQmp4QyxJQUFuQixDQUFQO0FBQ0QsS0FsQ0Q7QUFBQSxRQW1DSWt4QyxlQUFlLEdBQUdsTSxZQUFZLENBQUNDLFFBQUQsRUFBV2hFLFVBQVgsRUFBdUI5ZSxTQUF2QixDQW5DbEM7QUFBQSxRQW9DSWd2QixrQkFBa0IsR0FBR2pNLGVBQWUsQ0FBQ0QsUUFBRCxFQUFXaEUsVUFBWCxDQXBDeEM7QUFBQSxRQXFDSW1RLFFBQVEsR0FBRyxDQXJDZjtBQUFBLFFBc0NJQyxXQUFXLEdBQUcsQ0F0Q2xCO0FBQUEsUUF1Q0k3SSxVQUFVLEdBQUd6TCxjQUFjLENBQUNrSSxRQUFELEVBQVc5aUIsU0FBWCxDQXZDL0I7QUFBQSxRQXdDSW12QixPQXhDSjtBQUFBLFFBeUNJQyxRQXpDSjtBQUFBLFFBMENJQyxRQTFDSjtBQUFBLFFBMkNJQyxPQTNDSjtBQUFBLFFBNENJQyxPQTVDSjtBQUFBLFFBNkNJcjFCLEtBN0NKO0FBQUEsUUE4Q0lyTyxHQTlDSjtBQUFBLFFBK0NJMmpDLFdBL0NKO0FBQUEsUUFnRElDLFNBaERKO0FBQUEsUUFpRElDLGtCQWpESjtBQUFBLFFBa0RJQyxnQkFsREo7QUFBQSxRQW1ESUMsVUFuREo7QUFBQSxRQW9ESUMsTUFwREo7QUFBQSxRQXFESUMsZ0JBckRKO0FBQUEsUUFzRElDLGNBdERKO0FBQUEsUUF1RElDLFFBdkRKO0FBQUEsUUF3REk5RSxNQXhESjtBQUFBLFFBeURJemhDLE1BekRKO0FBQUEsUUEwREl3bUMsU0ExREo7QUFBQSxRQTJESUMsU0EzREo7QUFBQSxRQTRESUMsUUE1REo7QUFBQSxRQTZESUMsU0E3REo7QUFBQSxRQThESUMsWUE5REo7QUFBQSxRQStESS9FLFdBL0RKO0FBQUEsUUFnRUlnRixpQkFoRUo7QUFBQSxRQWlFSUMsZUFqRUo7QUFBQSxRQWtFSTNsQyxFQWxFSjtBQUFBLFFBbUVJNGxDLEtBbkVKO0FBQUEsUUFvRUlDLEtBcEVKO0FBQUEsUUFxRUlDLFVBckVKO0FBQUEsUUFzRUlDLFdBdEVKO0FBQUEsUUF1RUlDLFlBdkVKO0FBQUEsUUF3RUlDLGVBeEVKO0FBQUEsUUF5RUlDLFlBekVKO0FBQUEsUUEwRUlDLFVBMUVKO0FBQUEsUUEyRUlDLGdCQTNFSjtBQUFBLFFBNEVJQyxjQTVFSjtBQUFBLFFBNkVJQyxrQkE3RUo7O0FBK0VBcnpDLElBQUFBLElBQUksQ0FBQ2lzQyxLQUFMLEdBQWFWLGNBQWI7QUFDQXZyQyxJQUFBQSxJQUFJLENBQUMyc0MsSUFBTCxHQUFZeHFCLFNBQVo7QUFDQSttQixJQUFBQSxhQUFhLElBQUksRUFBakI7QUFDQWxwQyxJQUFBQSxJQUFJLENBQUNpbEMsUUFBTCxHQUFnQkEsUUFBaEI7QUFDQWpsQyxJQUFBQSxJQUFJLENBQUM2SSxNQUFMLEdBQWMrZ0Msa0JBQWtCLEdBQUdBLGtCQUFrQixDQUFDaHBCLElBQW5CLENBQXdCMHlCLElBQXhCLENBQTZCMUosa0JBQTdCLENBQUgsR0FBc0RwQixVQUF0RjtBQUNBaUosSUFBQUEsT0FBTyxHQUFHakosVUFBVSxFQUFwQjtBQUNBeG9DLElBQUFBLElBQUksQ0FBQ2tMLElBQUwsR0FBWUEsSUFBWjtBQUNBNDZCLElBQUFBLFNBQVMsR0FBR0EsU0FBUyxJQUFJNTZCLElBQUksQ0FBQzQ2QixTQUE5Qjs7QUFFQSxRQUFJLHFCQUFxQjU2QixJQUF6QixFQUErQjtBQUM3Qis0QixNQUFBQSxLQUFLLEdBQUcsQ0FBUjtBQUNBLzRCLE1BQUFBLElBQUksQ0FBQ3FvQyxlQUFMLEtBQXlCLENBQUMsSUFBMUIsS0FBbUN6RyxRQUFRLEdBQUc5c0MsSUFBOUMsRUFGNkIsQ0FFd0I7QUFDdEQ7O0FBRUR5d0MsSUFBQUEsYUFBYSxDQUFDK0MsV0FBZCxHQUE0Qi9DLGFBQWEsQ0FBQytDLFdBQWQsSUFBNkI7QUFDdkR0cEMsTUFBQUEsR0FBRyxFQUFFK2tDLGdCQUFnQixDQUFDaEssUUFBRCxFQUFXdkksU0FBWCxDQURrQztBQUV2RHp5QixNQUFBQSxJQUFJLEVBQUVnbEMsZ0JBQWdCLENBQUNoSyxRQUFELEVBQVczSSxXQUFYO0FBRmlDLEtBQXpEO0FBSUF0OEIsSUFBQUEsSUFBSSxDQUFDc3hDLE9BQUwsR0FBZUEsT0FBTyxHQUFHYixhQUFhLENBQUMrQyxXQUFkLENBQTBCcnhCLFNBQVMsQ0FBQ3hkLENBQXBDLENBQXpCOztBQUVBM0UsSUFBQUEsSUFBSSxDQUFDeXpDLGFBQUwsR0FBcUIsVUFBVXJ4QyxLQUFWLEVBQWlCO0FBQ3BDMHdDLE1BQUFBLFdBQVcsR0FBRy90QixTQUFTLENBQUMzaUIsS0FBRCxDQUFULElBQW9CQSxLQUFsQzs7QUFFQSxVQUFJLENBQUMwd0MsV0FBTCxFQUFrQjtBQUNoQkQsUUFBQUEsVUFBVSxJQUFJQSxVQUFVLENBQUN6dEIsUUFBWCxDQUFvQixDQUFwQixFQUF1QnRILElBQXZCLEVBQWQ7QUFDQSswQixRQUFBQSxVQUFVLEdBQUcsQ0FBYjtBQUNELE9BSEQsTUFHTztBQUNMQSxRQUFBQSxVQUFVLEdBQUdBLFVBQVUsQ0FBQzFzQyxRQUFYLENBQW9CL0QsS0FBcEIsQ0FBSCxHQUFnQ3l3QyxVQUFVLEdBQUdqeUMsa0JBQUksQ0FBQ29GLEVBQUwsQ0FBUTgvQixTQUFSLEVBQW1CO0FBQ3hFNE4sVUFBQUEsSUFBSSxFQUFFLE1BRGtFO0FBRXhFQyxVQUFBQSxhQUFhLEVBQUUsU0FGeUQ7QUFHeEV4dEMsVUFBQUEsUUFBUSxFQUFFMnNDLFdBSDhEO0FBSXhFYyxVQUFBQSxNQUFNLEVBQUUsSUFKZ0U7QUFLeEV4dEMsVUFBQUEsVUFBVSxFQUFFLFNBQVNBLFVBQVQsR0FBc0I7QUFDaEMsbUJBQU80cEMsZUFBZSxJQUFJQSxlQUFlLENBQUNod0MsSUFBRCxDQUF6QztBQUNEO0FBUHVFLFNBQW5CLENBQXZEO0FBU0Q7QUFDRixLQWpCRDs7QUFtQkEsUUFBSThsQyxTQUFKLEVBQWU7QUFDYkEsTUFBQUEsU0FBUyxDQUFDNTZCLElBQVYsQ0FBZTJELElBQWYsR0FBc0IsS0FBdEI7QUFDQWkzQixNQUFBQSxTQUFTLENBQUMrTixRQUFWLElBQXNCL04sU0FBUyxDQUFDNTZCLElBQVYsQ0FBZTRvQyxlQUFmLEtBQW1DLEtBQW5DLElBQTRDNW9DLElBQUksQ0FBQzRvQyxlQUFMLEtBQXlCLEtBQXJFLElBQThFaE8sU0FBUyxDQUFDdnRCLE1BQVYsQ0FBaUIsQ0FBakIsRUFBb0IsSUFBcEIsRUFBMEIsSUFBMUIsQ0FBcEc7QUFDQXZZLE1BQUFBLElBQUksQ0FBQzhsQyxTQUFMLEdBQWlCQSxTQUFTLENBQUNwRSxLQUFWLEVBQWpCO0FBQ0FvRSxNQUFBQSxTQUFTLENBQUNpTyxhQUFWLEdBQTBCL3pDLElBQTFCO0FBQ0FBLE1BQUFBLElBQUksQ0FBQ3l6QyxhQUFMLENBQW1CNUQsS0FBbkI7QUFDQThDLE1BQUFBLEtBQUssR0FBRyxDQUFSO0FBQ0EvdkIsTUFBQUEsRUFBRSxLQUFLQSxFQUFFLEdBQUdrakIsU0FBUyxDQUFDNTZCLElBQVYsQ0FBZTBYLEVBQXpCLENBQUY7QUFDRDs7QUFFRCtuQixJQUFBQSxTQUFTLENBQUNsbEMsSUFBVixDQUFlekYsSUFBZjs7QUFFQSxRQUFJNE4sSUFBSixFQUFVO0FBQ1IsVUFBSSxDQUFDdkwsU0FBUyxDQUFDdUwsSUFBRCxDQUFWLElBQW9CQSxJQUFJLENBQUNuSSxJQUE3QixFQUFtQztBQUNqQ21JLFFBQUFBLElBQUksR0FBRztBQUNMb21DLFVBQUFBLE1BQU0sRUFBRXBtQztBQURILFNBQVA7QUFHRDs7QUFFRCwwQkFBb0I1TSxrQkFBSyxDQUFDdUMsS0FBMUIsSUFBbUMzQyxrQkFBSSxDQUFDZ08sR0FBTCxDQUFTcXlCLFVBQVUsR0FBRyxDQUFDamdDLGtCQUFELEVBQVFzNUIsbUJBQVIsQ0FBSCxHQUFxQjJLLFFBQXhDLEVBQWtEO0FBQ25GZ1AsUUFBQUEsY0FBYyxFQUFFO0FBRG1FLE9BQWxELENBQW5DLENBUFEsQ0FTSjs7QUFFSnpDLE1BQUFBLFFBQVEsR0FBR3J2QyxXQUFXLENBQUN5TCxJQUFJLENBQUNvbUMsTUFBTixDQUFYLEdBQTJCcG1DLElBQUksQ0FBQ29tQyxNQUFoQyxHQUF5Q3BtQyxJQUFJLENBQUNvbUMsTUFBTCxLQUFnQixRQUFoQixHQUEyQmpNLGdCQUFnQixDQUFDakMsU0FBRCxDQUEzQyxHQUF5RGw0QixJQUFJLENBQUNvbUMsTUFBTCxLQUFnQixtQkFBaEIsR0FBc0M1TCxvQkFBb0IsQ0FBQ3RDLFNBQUQsQ0FBMUQsR0FBd0VsNEIsSUFBSSxDQUFDc21DLFdBQUwsS0FBcUIsS0FBckIsR0FBNkIsVUFBVTl4QyxLQUFWLEVBQWlCaW1DLEVBQWpCLEVBQXFCO0FBQ3JPLGVBQU9MLGdCQUFnQixDQUFDcDZCLElBQUksQ0FBQ29tQyxNQUFOLENBQWhCLENBQThCNXhDLEtBQTlCLEVBQXFDd0IscUJBQVEsS0FBS3l0QyxXQUFiLEdBQTJCLEdBQTNCLEdBQWlDLENBQWpDLEdBQXFDaEosRUFBRSxDQUFDbG1CLFNBQTdFLENBQVA7QUFDRCxPQUZvTCxHQUVqTHZoQixrQkFBSSxDQUFDd08sS0FBTCxDQUFXeEIsSUFBWCxDQUFnQkEsSUFBSSxDQUFDb21DLE1BQXJCLENBRko7QUFHQWpCLE1BQUFBLFlBQVksR0FBR25sQyxJQUFJLENBQUN6SCxRQUFMLElBQWlCO0FBQzlCMEYsUUFBQUEsR0FBRyxFQUFFLEdBRHlCO0FBRTlCOUMsUUFBQUEsR0FBRyxFQUFFO0FBRnlCLE9BQWhDO0FBSUFncUMsTUFBQUEsWUFBWSxHQUFHMXdDLFNBQVMsQ0FBQzB3QyxZQUFELENBQVQsR0FBMEIxWSxtQkFBTSxDQUFDMFksWUFBWSxDQUFDbG5DLEdBQWQsRUFBbUJrbkMsWUFBWSxDQUFDaHFDLEdBQWhDLENBQWhDLEdBQXVFc3hCLG1CQUFNLENBQUMwWSxZQUFELEVBQWVBLFlBQWYsQ0FBNUY7QUFDQUMsTUFBQUEsZUFBZSxHQUFHcHlDLGtCQUFJLENBQUNtZixXQUFMLENBQWlCblMsSUFBSSxDQUFDMUgsS0FBTCxJQUFjNHNDLFdBQVcsR0FBRyxDQUE1QixJQUFpQyxHQUFsRCxFQUF1RCxZQUFZO0FBQ25GLFlBQUlqcUMsTUFBTSxHQUFHMi9CLFVBQVUsRUFBdkI7QUFBQSxZQUNJMkwsaUJBQWlCLEdBQUd2d0MscUJBQVEsS0FBS3l0QyxXQUFiLEdBQTJCLEdBRG5EO0FBQUEsWUFFSW4yQixLQUFLLEdBQUdvMkIsT0FBTyxDQUFDcDJCLEtBRnBCOztBQUlBLFlBQUksQ0FBQ2k1QixpQkFBaUIsSUFBSXh4QyxJQUFJLENBQUMyYixHQUFMLENBQVN0ZSxJQUFJLENBQUNvaUIsV0FBTCxFQUFULElBQStCLEVBQXJELEtBQTRELENBQUNsSCxLQUE3RCxJQUFzRSxDQUFDMG9CLGNBQXZFLElBQXlGd04sUUFBUSxLQUFLdm9DLE1BQTFHLEVBQWtIO0FBQ2hILGNBQUl1YyxRQUFRLEdBQUcsQ0FBQ3ZjLE1BQU0sR0FBR3dULEtBQVYsSUFBbUIyMUIsTUFBbEM7QUFBQSxjQUNJMkIsYUFBYSxHQUFHN04sU0FBUyxJQUFJLENBQUMwSyxRQUFkLEdBQXlCMUssU0FBUyxDQUFDNk4sYUFBVixFQUF6QixHQUFxRHZ1QixRQUR6RTtBQUFBLGNBRUlsWCxRQUFRLEdBQUdpbUMsaUJBQWlCLEdBQUcsQ0FBSCxHQUFPLENBQUNSLGFBQWEsR0FBR2YsS0FBakIsS0FBMkJodkMscUJBQVEsS0FBSzYvQixNQUF4QyxJQUFrRCxJQUFsRCxJQUEwRCxDQUZqRztBQUFBLGNBR0k4TCxPQUFPLEdBQUczdUMsa0JBQUksQ0FBQ3dPLEtBQUwsQ0FBVzZ1QixLQUFYLENBQWlCLENBQUM3WSxRQUFsQixFQUE0QixJQUFJQSxRQUFoQyxFQUEwQ1gsSUFBSSxDQUFDdlcsUUFBUSxHQUFHLENBQVosQ0FBSixHQUFxQkEsUUFBckIsR0FBZ0MsS0FBMUUsQ0FIZDtBQUFBLGNBSUlrbUMsVUFBVSxHQUFHaHZCLFFBQVEsSUFBSXhYLElBQUksQ0FBQytGLE9BQUwsS0FBaUIsS0FBakIsR0FBeUIsQ0FBekIsR0FBNkI0N0IsT0FBakMsQ0FKekI7QUFBQSxjQUtJOEUsUUFBUSxHQUFHaGEsbUJBQU0sQ0FBQyxDQUFELEVBQUksQ0FBSixFQUFPbVgsUUFBUSxDQUFDNEMsVUFBRCxFQUFhcDBDLElBQWIsQ0FBZixDQUxyQjtBQUFBLGNBTUlzMEMsU0FBUyxHQUFHM3hDLElBQUksQ0FBQ0MsS0FBTCxDQUFXeVosS0FBSyxHQUFHZzRCLFFBQVEsR0FBR3JDLE1BQTlCLENBTmhCO0FBQUEsY0FPSXVDLEtBQUssR0FBRzNtQyxJQVBaO0FBQUEsY0FRSTRtQyxPQUFPLEdBQUdELEtBQUssQ0FBQ0MsT0FScEI7QUFBQSxjQVNJQyxZQUFZLEdBQUdGLEtBQUssQ0FBQzc0QixXQVR6QjtBQUFBLGNBVUlnNUIsV0FBVyxHQUFHSCxLQUFLLENBQUNudUMsVUFWeEI7O0FBWUEsY0FBSXlDLE1BQU0sSUFBSW1GLEdBQVYsSUFBaUJuRixNQUFNLElBQUl3VCxLQUEzQixJQUFvQ2k0QixTQUFTLEtBQUt6ckMsTUFBdEQsRUFBOEQ7QUFDNUQsZ0JBQUlxUyxLQUFLLElBQUksQ0FBQ0EsS0FBSyxDQUFDMjRCLFFBQWhCLElBQTRCMzRCLEtBQUssQ0FBQzdVLElBQU4sSUFBY29lLElBQUksQ0FBQzZ2QixTQUFTLEdBQUd6ckMsTUFBYixDQUFsRCxFQUF3RTtBQUN0RTtBQUNBO0FBQ0Q7O0FBRUQsZ0JBQUkrRSxJQUFJLENBQUMrRixPQUFMLEtBQWlCLEtBQXJCLEVBQTRCO0FBQzFCNDdCLGNBQUFBLE9BQU8sR0FBRzhFLFFBQVEsR0FBR2p2QixRQUFyQjtBQUNEOztBQUVEa3NCLFlBQUFBLE9BQU8sQ0FBQ2dELFNBQUQsRUFBWTtBQUNqQm51QyxjQUFBQSxRQUFRLEVBQUU0c0MsWUFBWSxDQUFDdHVCLElBQUksQ0FBQzloQixJQUFJLENBQUNvRyxHQUFMLENBQVMwYixJQUFJLENBQUMydkIsVUFBVSxHQUFHVCxhQUFkLENBQWIsRUFBMkNsdkIsSUFBSSxDQUFDNHZCLFFBQVEsR0FBR1YsYUFBWixDQUEvQyxJQUE2RSxLQUE3RSxHQUFxRnpsQyxRQUFyRixHQUFnRyxJQUFoRyxJQUF3RyxDQUF6RyxDQUFMLENBREw7QUFFakJ3bEMsY0FBQUEsSUFBSSxFQUFFOWxDLElBQUksQ0FBQzhsQyxJQUFMLElBQWEsUUFGRjtBQUdqQnJ0QyxjQUFBQSxJQUFJLEVBQUVvZSxJQUFJLENBQUM2dkIsU0FBUyxHQUFHenJDLE1BQWIsQ0FITztBQUlqQjtBQUNBNlMsY0FBQUEsV0FBVyxFQUFFLFNBQVNBLFdBQVQsR0FBdUI7QUFDbEMsdUJBQU9zM0IsZUFBZSxDQUFDelEsT0FBaEIsQ0FBd0IsSUFBeEIsS0FBaUNrUyxZQUFqQyxJQUFpREEsWUFBWSxDQUFDejBDLElBQUQsQ0FBcEU7QUFDRCxlQVBnQjtBQVFqQm9HLGNBQUFBLFVBQVUsRUFBRSxTQUFTQSxVQUFULEdBQXNCO0FBQ2hDcEcsZ0JBQUFBLElBQUksQ0FBQ3VpQixNQUFMO0FBQ0E2dUIsZ0JBQUFBLFFBQVEsR0FBRzVJLFVBQVUsRUFBckI7QUFDQW1LLGdCQUFBQSxLQUFLLEdBQUdDLEtBQUssR0FBRzlNLFNBQVMsSUFBSSxDQUFDMEssUUFBZCxHQUF5QjFLLFNBQVMsQ0FBQzZOLGFBQVYsRUFBekIsR0FBcUQzekMsSUFBSSxDQUFDb2xCLFFBQTFFO0FBQ0E2cUIsZ0JBQUFBLGNBQWMsSUFBSUEsY0FBYyxDQUFDandDLElBQUQsQ0FBaEM7QUFDQTAwQyxnQkFBQUEsV0FBVyxJQUFJQSxXQUFXLENBQUMxMEMsSUFBRCxDQUExQjtBQUNEO0FBZGdCLGFBQVosRUFlSjZJLE1BZkksRUFlSTBtQyxPQUFPLEdBQUd5QyxNQWZkLEVBZXNCc0MsU0FBUyxHQUFHenJDLE1BQVosR0FBcUIwbUMsT0FBTyxHQUFHeUMsTUFmckQsQ0FBUDtBQWdCQXdDLFlBQUFBLE9BQU8sSUFBSUEsT0FBTyxDQUFDeDBDLElBQUQsRUFBT3N4QyxPQUFPLENBQUNwMkIsS0FBZixDQUFsQjtBQUNEO0FBQ0YsU0F6Q0QsTUF5Q08sSUFBSWxiLElBQUksQ0FBQ2tkLFFBQUwsSUFBaUJrMEIsUUFBUSxLQUFLdm9DLE1BQWxDLEVBQTBDO0FBQy9DbXFDLFVBQUFBLGVBQWUsQ0FBQ3pRLE9BQWhCLENBQXdCLElBQXhCO0FBQ0Q7QUFDRixPQWpEaUIsRUFpRGZiLEtBakRlLEVBQWxCO0FBa0REOztBQUVEOWUsSUFBQUEsRUFBRSxLQUFLZ29CLElBQUksQ0FBQ2hvQixFQUFELENBQUosR0FBVzVpQixJQUFoQixDQUFGO0FBQ0FzVixJQUFBQSxPQUFPLEdBQUd0VixJQUFJLENBQUNzVixPQUFMLEdBQWVzbkIsVUFBVSxDQUFDdG5CLE9BQU8sSUFBSTgzQixHQUFaLENBQW5DLENBdk4yQyxDQXVOVTs7QUFFckRpRyxJQUFBQSxrQkFBa0IsR0FBRy85QixPQUFPLElBQUlBLE9BQU8sQ0FBQ2EsS0FBbkIsSUFBNEJiLE9BQU8sQ0FBQ2EsS0FBUixDQUFjdytCLFFBQS9EO0FBQ0F0QixJQUFBQSxrQkFBa0IsS0FBS0Esa0JBQWtCLEdBQUdBLGtCQUFrQixDQUFDcnpDLElBQUQsQ0FBNUMsQ0FBbEI7QUFDQW90QyxJQUFBQSxHQUFHLEdBQUdBLEdBQUcsS0FBSyxJQUFSLEdBQWU5M0IsT0FBZixHQUF5QnNuQixVQUFVLENBQUN3USxHQUFELENBQXpDO0FBQ0F0b0IsSUFBQUEsU0FBUyxDQUFDNHFCLFdBQUQsQ0FBVCxLQUEyQkEsV0FBVyxHQUFHO0FBQ3ZDcHNCLE1BQUFBLE9BQU8sRUFBRWhPLE9BRDhCO0FBRXZDcy9CLE1BQUFBLFNBQVMsRUFBRWxGO0FBRjRCLEtBQXpDOztBQUtBLFFBQUl0QyxHQUFKLEVBQVM7QUFDUDBDLE1BQUFBLFVBQVUsS0FBSyxLQUFmLElBQXdCQSxVQUFVLEtBQUtqSixPQUF2QyxLQUFtRGlKLFVBQVUsR0FBRyxDQUFDQSxVQUFELElBQWVubUMsaUJBQWlCLENBQUN5akMsR0FBRyxDQUFDN2tDLFVBQUwsQ0FBakIsQ0FBa0NxSixPQUFsQyxLQUE4QyxNQUE3RCxHQUFzRSxLQUF0RSxHQUE4RWcxQixRQUE5SSxFQURPLENBQ2tKOztBQUV6SjVtQyxNQUFBQSxJQUFJLENBQUNvdEMsR0FBTCxHQUFXQSxHQUFYO0FBQ0FsaUMsTUFBQUEsSUFBSSxDQUFDdUYsT0FBTCxLQUFpQixLQUFqQixJQUEwQjdQLGtCQUFJLENBQUNnTyxHQUFMLENBQVN3K0IsR0FBVCxFQUFjO0FBQ3RDMzhCLFFBQUFBLE9BQU8sRUFBRTtBQUQ2QixPQUFkLENBQTFCO0FBR0E4Z0MsTUFBQUEsUUFBUSxHQUFHM3dDLGtCQUFJLENBQUN3VixJQUFMLENBQVVDLFFBQVYsQ0FBbUIrMkIsR0FBbkIsQ0FBWDs7QUFFQSxVQUFJLENBQUNtRSxRQUFRLENBQUNsRSxNQUFkLEVBQXNCO0FBQ3BCO0FBQ0EsWUFBSStDLFNBQUosRUFBZTtBQUNiQSxVQUFBQSxTQUFTLEdBQUd4VCxVQUFVLENBQUN3VCxTQUFELENBQXRCO0FBQ0FBLFVBQUFBLFNBQVMsSUFBSSxDQUFDQSxTQUFTLENBQUMzbkMsUUFBeEIsS0FBcUMybkMsU0FBUyxHQUFHQSxTQUFTLENBQUN5RSxPQUFWLElBQXFCekUsU0FBUyxDQUFDMEUsYUFBaEYsRUFGYSxDQUVtRjs7QUFFaEd2RCxVQUFBQSxRQUFRLENBQUMvRCxjQUFULEdBQTBCLENBQUMsQ0FBQzRDLFNBQTVCO0FBQ0FBLFVBQUFBLFNBQVMsS0FBS21CLFFBQVEsQ0FBQzlELFdBQVQsR0FBdUJNLFNBQVMsQ0FBQ3FDLFNBQUQsQ0FBckMsQ0FBVDtBQUNEOztBQUVEbUIsUUFBQUEsUUFBUSxDQUFDbEUsTUFBVCxHQUFrQkEsTUFBTSxHQUFHK0MsU0FBUyxJQUFJdHZDLGlCQUFJLENBQUN3QyxhQUFMLENBQW1CLEtBQW5CLENBQXhDO0FBQ0ErcEMsUUFBQUEsTUFBTSxDQUFDMEgsU0FBUCxDQUFpQnB2QyxHQUFqQixDQUFxQixZQUFyQjtBQUNBaWQsUUFBQUEsRUFBRSxJQUFJeXFCLE1BQU0sQ0FBQzBILFNBQVAsQ0FBaUJwdkMsR0FBakIsQ0FBcUIsZ0JBQWdCaWQsRUFBckMsQ0FBTjtBQUNBMnVCLFFBQUFBLFFBQVEsQ0FBQ1ksUUFBVCxHQUFvQkYsZ0JBQWdCLEdBQUdsRSxTQUFTLENBQUNYLEdBQUQsQ0FBaEQ7QUFDRCxPQWRELE1BY087QUFDTDZFLFFBQUFBLGdCQUFnQixHQUFHVixRQUFRLENBQUNZLFFBQTVCO0FBQ0Q7O0FBRURueUMsTUFBQUEsSUFBSSxDQUFDcXRDLE1BQUwsR0FBY0EsTUFBTSxHQUFHa0UsUUFBUSxDQUFDbEUsTUFBaEM7QUFDQXRnQyxNQUFBQSxFQUFFLEdBQUdwRCxpQkFBaUIsQ0FBQ3lqQyxHQUFELENBQXRCO0FBQ0FvRixNQUFBQSxZQUFZLEdBQUd6bEMsRUFBRSxDQUFDK2lDLFVBQVUsR0FBRzN0QixTQUFTLENBQUNxYSxHQUF4QixDQUFqQjtBQUNBNFYsTUFBQUEsU0FBUyxHQUFHeHhDLGtCQUFJLENBQUNpVSxXQUFMLENBQWlCdTRCLEdBQWpCLENBQVo7QUFDQWlGLE1BQUFBLFNBQVMsR0FBR3p4QyxrQkFBSSxDQUFDbzBDLFdBQUwsQ0FBaUI1SCxHQUFqQixFQUFzQmpyQixTQUFTLENBQUNyVSxDQUFoQyxFQUFtQ2s1QixHQUFuQyxDQUFaLENBL0JPLENBK0I4Qzs7QUFFckQwRyxNQUFBQSxVQUFVLENBQUNOLEdBQUQsRUFBTUMsTUFBTixFQUFjdGdDLEVBQWQsQ0FBVjs7QUFFQW9sQyxNQUFBQSxRQUFRLEdBQUdwRSxTQUFTLENBQUNYLEdBQUQsQ0FBcEI7QUFDRDs7QUFFRCxRQUFJNEQsT0FBSixFQUFhO0FBQ1hlLE1BQUFBLFVBQVUsR0FBRzF2QyxTQUFTLENBQUMydUMsT0FBRCxDQUFULEdBQXFCMXFDLFlBQVksQ0FBQzBxQyxPQUFELEVBQVV0SSxlQUFWLENBQWpDLEdBQThEQSxlQUEzRTtBQUNBbUosTUFBQUEsa0JBQWtCLEdBQUdySSxhQUFhLENBQUMsZ0JBQUQsRUFBbUI1bUIsRUFBbkIsRUFBdUJxaUIsUUFBdkIsRUFBaUM5aUIsU0FBakMsRUFBNEM0dkIsVUFBNUMsRUFBd0QsQ0FBeEQsQ0FBbEM7QUFDQUQsTUFBQUEsZ0JBQWdCLEdBQUd0SSxhQUFhLENBQUMsY0FBRCxFQUFpQjVtQixFQUFqQixFQUFxQnFpQixRQUFyQixFQUErQjlpQixTQUEvQixFQUEwQzR2QixVQUExQyxFQUFzRCxDQUF0RCxFQUF5REYsa0JBQXpELENBQWhDO0FBQ0FqbUMsTUFBQUEsTUFBTSxHQUFHaW1DLGtCQUFrQixDQUFDLFdBQVcxdkIsU0FBUyxDQUFDd2EsRUFBVixDQUFhdkssRUFBekIsQ0FBM0I7O0FBRUEsVUFBSTlpQixPQUFPLEdBQUdzdEIsVUFBVSxDQUFDckIsYUFBYSxDQUFDMEosUUFBRCxFQUFXLFNBQVgsQ0FBYixJQUFzQ0EsUUFBdkMsQ0FBeEI7O0FBRUEwTSxNQUFBQSxXQUFXLEdBQUcsS0FBS0EsV0FBTCxHQUFtQm5JLGFBQWEsQ0FBQyxPQUFELEVBQVU1bUIsRUFBVixFQUFjdFQsT0FBZCxFQUF1QjZTLFNBQXZCLEVBQWtDNHZCLFVBQWxDLEVBQThDbm1DLE1BQTlDLEVBQXNELENBQXRELEVBQXlEZytCLGtCQUF6RCxDQUE5QztBQUNBZ0ksTUFBQUEsU0FBUyxHQUFHLEtBQUtBLFNBQUwsR0FBaUJwSSxhQUFhLENBQUMsS0FBRCxFQUFRNW1CLEVBQVIsRUFBWXRULE9BQVosRUFBcUI2UyxTQUFyQixFQUFnQzR2QixVQUFoQyxFQUE0Q25tQyxNQUE1QyxFQUFvRCxDQUFwRCxFQUF1RGcrQixrQkFBdkQsQ0FBMUM7QUFDQUEsTUFBQUEsa0JBQWtCLEtBQUt3SixjQUFjLEdBQUd4eUMsa0JBQUksQ0FBQ28wQyxXQUFMLENBQWlCLENBQUNyRCxXQUFELEVBQWNDLFNBQWQsQ0FBakIsRUFBMkN6dkIsU0FBUyxDQUFDclUsQ0FBckQsRUFBd0RrNUIsR0FBeEQsQ0FBdEIsQ0FBbEI7O0FBRUEsVUFBSSxDQUFDNkMsZ0JBQUQsSUFBcUIsRUFBRTVPLGVBQUEsSUFBbUJNLGFBQWEsQ0FBQzBKLFFBQUQsRUFBVyxjQUFYLENBQWIsS0FBNEMsSUFBakUsQ0FBekIsRUFBaUc7QUFDL0ZnQyxRQUFBQSxpQkFBaUIsQ0FBQ2hHLFVBQVUsR0FBR2pnQyxrQkFBSCxHQUFXaWtDLFFBQXRCLENBQWpCOztBQUVBcmtDLFFBQUFBLGtCQUFJLENBQUNnTyxHQUFMLENBQVMsQ0FBQ2lqQyxrQkFBRCxFQUFxQkMsZ0JBQXJCLENBQVQsRUFBaUQ7QUFDL0NyaEMsVUFBQUEsT0FBTyxFQUFFO0FBRHNDLFNBQWpEO0FBR0FnaUMsUUFBQUEsaUJBQWlCLEdBQUc3eEMsa0JBQUksQ0FBQ28wQyxXQUFMLENBQWlCbkQsa0JBQWpCLEVBQXFDMXZCLFNBQVMsQ0FBQ3JVLENBQS9DLEVBQWtEazVCLEdBQWxELENBQXBCO0FBQ0EwTCxRQUFBQSxlQUFlLEdBQUc5eEMsa0JBQUksQ0FBQ28wQyxXQUFMLENBQWlCbEQsZ0JBQWpCLEVBQW1DM3ZCLFNBQVMsQ0FBQ3JVLENBQTdDLEVBQWdEazVCLEdBQWhELENBQWxCO0FBQ0Q7QUFDRjs7QUFFRCxRQUFJNEMsa0JBQUosRUFBd0I7QUFDdEIsVUFBSXFMLFdBQVcsR0FBR3JMLGtCQUFrQixDQUFDMStCLElBQW5CLENBQXdCeVEsUUFBMUM7QUFBQSxVQUNJdTVCLFNBQVMsR0FBR3RMLGtCQUFrQixDQUFDMStCLElBQW5CLENBQXdCMlEsY0FEeEM7QUFFQSt0QixNQUFBQSxrQkFBa0IsQ0FBQ3VMLGFBQW5CLENBQWlDLFVBQWpDLEVBQTZDLFlBQVk7QUFDdkRuMUMsUUFBQUEsSUFBSSxDQUFDdWlCLE1BQUwsQ0FBWSxDQUFaLEVBQWUsQ0FBZixFQUFrQixDQUFsQjtBQUNBMHlCLFFBQUFBLFdBQVcsSUFBSUEsV0FBVyxDQUFDM3BDLEtBQVosQ0FBa0I0cEMsU0FBUyxJQUFJLEVBQS9CLENBQWY7QUFDRCxPQUhEO0FBSUQ7O0FBRURsMUMsSUFBQUEsSUFBSSxDQUFDbzFDLFFBQUwsR0FBZ0IsWUFBWTtBQUMxQixhQUFPekssU0FBUyxDQUFDQSxTQUFTLENBQUNsNEIsT0FBVixDQUFrQnpTLElBQWxCLElBQTBCLENBQTNCLENBQWhCO0FBQ0QsS0FGRDs7QUFJQUEsSUFBQUEsSUFBSSxDQUFDcTFDLElBQUwsR0FBWSxZQUFZO0FBQ3RCLGFBQU8xSyxTQUFTLENBQUNBLFNBQVMsQ0FBQ2w0QixPQUFWLENBQWtCelMsSUFBbEIsSUFBMEIsQ0FBM0IsQ0FBaEI7QUFDRCxLQUZEOztBQUlBQSxJQUFBQSxJQUFJLENBQUNrc0MsTUFBTCxHQUFjLFVBQVVBLE1BQVYsRUFBa0I7QUFDOUIsVUFBSXRoQyxDQUFDLEdBQUdzaEMsTUFBTSxLQUFLLEtBQVgsSUFBb0IsQ0FBQ2xzQyxJQUFJLENBQUMwVyxPQUFsQztBQUFBLFVBQ0k0K0IsY0FBYyxHQUFHM1IsV0FEckI7O0FBR0EsVUFBSS80QixDQUFDLEtBQUs1SyxJQUFJLENBQUN1MUMsVUFBZixFQUEyQjtBQUN6QixZQUFJM3FDLENBQUosRUFBTztBQUNMNUssVUFBQUEsSUFBSSxDQUFDNkksTUFBTCxDQUFZdWpDLEdBQVosSUFBbUIsQ0FBQ3pJLFdBQXBCLElBQW1DLENBQUMwSSxjQUFwQyxLQUF1RHJzQyxJQUFJLENBQUM2SSxNQUFMLENBQVl1akMsR0FBWixHQUFrQjVELFVBQVUsRUFBbkY7QUFDQTBLLFVBQUFBLFVBQVUsR0FBR3Z3QyxJQUFJLENBQUNvRyxHQUFMLENBQVN5L0IsVUFBVSxFQUFuQixFQUF1QnhvQyxJQUFJLENBQUM2SSxNQUFMLENBQVl1akMsR0FBWixJQUFtQixDQUExQyxDQUFiLENBRkssQ0FFc0Q7O0FBRTNENkcsVUFBQUEsWUFBWSxHQUFHanpDLElBQUksQ0FBQ29sQixRQUFwQjtBQUNBK3RCLFVBQUFBLGdCQUFnQixHQUFHck4sU0FBUyxJQUFJQSxTQUFTLENBQUMxZ0IsUUFBVixFQUFoQztBQUNEOztBQUVEdXNCLFFBQUFBLFdBQVcsSUFBSSxDQUFDQSxXQUFELEVBQWNDLFNBQWQsRUFBeUJDLGtCQUF6QixFQUE2Q0MsZ0JBQTdDLEVBQStEeHNDLE9BQS9ELENBQXVFLFVBQVVtZCxDQUFWLEVBQWE7QUFDakcsaUJBQU9BLENBQUMsQ0FBQ2xmLEtBQUYsQ0FBUXFPLE9BQVIsR0FBa0JoSCxDQUFDLEdBQUcsTUFBSCxHQUFZLE9BQXRDO0FBQ0QsU0FGYyxDQUFmO0FBR0FBLFFBQUFBLENBQUMsS0FBSys0QixXQUFXLEdBQUcsQ0FBbkIsQ0FBRDtBQUNBM2pDLFFBQUFBLElBQUksQ0FBQ3VpQixNQUFMLENBQVkzWCxDQUFaLEVBYnlCLENBYVQ7O0FBRWhCKzRCLFFBQUFBLFdBQVcsR0FBRzJSLGNBQWQ7QUFDQWxJLFFBQUFBLEdBQUcsS0FBS3hpQyxDQUFDLEdBQUd1aUMsV0FBVyxDQUFDQyxHQUFELEVBQU1DLE1BQU4sRUFBYzRFLGdCQUFkLENBQWQsR0FBZ0QsQ0FBQyxDQUFDOUIsV0FBRCxJQUFnQixDQUFDbndDLElBQUksQ0FBQ2tkLFFBQXZCLEtBQW9Dd3dCLFVBQVUsQ0FBQ04sR0FBRCxFQUFNQyxNQUFOLEVBQWMxakMsaUJBQWlCLENBQUN5akMsR0FBRCxDQUEvQixFQUFzQ0ssV0FBdEMsQ0FBcEcsQ0FBSDtBQUNBenRDLFFBQUFBLElBQUksQ0FBQ3UxQyxVQUFMLEdBQWtCM3FDLENBQWxCO0FBQ0Q7QUFDRixLQXZCRDs7QUF5QkE1SyxJQUFBQSxJQUFJLENBQUN5c0MsT0FBTCxHQUFlLFVBQVUrSSxJQUFWLEVBQWdCOWtDLEtBQWhCLEVBQXVCO0FBQ3BDLFVBQUksQ0FBQ2l6QixXQUFXLElBQUksQ0FBQzNqQyxJQUFJLENBQUMwVyxPQUF0QixLQUFrQyxDQUFDaEcsS0FBdkMsRUFBOEM7QUFDNUM7QUFDRDs7QUFFRCxVQUFJMDhCLEdBQUcsSUFBSW9JLElBQVAsSUFBZTlRLGVBQW5CLEVBQW9DO0FBQ2xDbitCLFFBQUFBLHlCQUFZLENBQUNrMEIsYUFBRCxFQUFnQixXQUFoQixFQUE2QnNSLFlBQTdCLENBQVo7O0FBRUE7QUFDRDs7QUFFRCxPQUFDTSxjQUFELElBQW1CNEUsYUFBbkIsSUFBb0NBLGFBQWEsQ0FBQ2p4QyxJQUFELENBQWpEO0FBQ0EyakMsTUFBQUEsV0FBVyxHQUFHLENBQWQ7QUFDQTBOLE1BQUFBLFdBQVcsR0FBR3p0QyxxQkFBUSxFQUF0Qjs7QUFFQSxVQUFJMHRDLE9BQU8sQ0FBQ3AyQixLQUFaLEVBQW1CO0FBQ2pCbzJCLFFBQUFBLE9BQU8sQ0FBQ3AyQixLQUFSLENBQWM0QyxJQUFkO0FBQ0F3ekIsUUFBQUEsT0FBTyxDQUFDcDJCLEtBQVIsR0FBZ0IsQ0FBaEI7QUFDRDs7QUFFRDIzQixNQUFBQSxVQUFVLElBQUlBLFVBQVUsQ0FBQ25SLEtBQVgsRUFBZDtBQUNBcU8sTUFBQUEsbUJBQW1CLElBQUlqSyxTQUF2QixJQUFvQ0EsU0FBUyxDQUFDbGxCLElBQVYsQ0FBZSxDQUFDLElBQWhCLEVBQXNCLElBQXRCLEVBQTRCNjBCLFVBQTVCLEVBQXBDO0FBQ0F6MUMsTUFBQUEsSUFBSSxDQUFDdTFDLFVBQUwsSUFBbUJ2MUMsSUFBSSxDQUFDa3NDLE1BQUwsRUFBbkI7O0FBRUEsVUFBSTVDLElBQUksR0FBRzRILGVBQWUsRUFBMUI7QUFBQSxVQUNJNUMsY0FBYyxHQUFHNkMsa0JBQWtCLEVBRHZDO0FBQUEsVUFFSXBvQyxHQUFHLEdBQUc2Z0Msa0JBQWtCLEdBQUdBLGtCQUFrQixDQUFDempDLFFBQW5CLEVBQUgsR0FBbUNnL0IsVUFBVSxDQUFDRixRQUFELEVBQVc5aUIsU0FBWCxDQUZ6RTtBQUFBLFVBR0l2VyxNQUFNLEdBQUcsQ0FIYjtBQUFBLFVBSUk4cEMsY0FBYyxHQUFHLENBSnJCO0FBQUEsVUFLSUMsU0FBUyxHQUFHenFDLElBQUksQ0FBQzhDLEdBTHJCO0FBQUEsVUFNSTRuQyxnQkFBZ0IsR0FBRzFxQyxJQUFJLENBQUMycUMsVUFBTCxJQUFtQnZnQyxPQU4xQztBQUFBLFVBT0l3Z0MsV0FBVyxHQUFHNXFDLElBQUksQ0FBQ21SLEtBQUwsS0FBZW5SLElBQUksQ0FBQ21SLEtBQUwsS0FBZSxDQUFmLElBQW9CLENBQUMvRyxPQUFyQixHQUErQixDQUEvQixHQUFtQzgzQixHQUFHLEdBQUcsS0FBSCxHQUFXLFFBQWhFLENBUGxCO0FBQUEsVUFRSTJJLGVBQWUsR0FBRy8xQyxJQUFJLENBQUMrMUMsZUFBTCxHQUF1QjdxQyxJQUFJLENBQUM2cUMsZUFBTCxJQUF3Qm5aLFVBQVUsQ0FBQzF4QixJQUFJLENBQUM2cUMsZUFBTixDQVIvRTtBQUFBLFVBU0lDLFlBQVksR0FBRzFnQyxPQUFPLElBQUkzUyxJQUFJLENBQUNvRyxHQUFMLENBQVMsQ0FBVCxFQUFZNGhDLFNBQVMsQ0FBQ2w0QixPQUFWLENBQWtCelMsSUFBbEIsQ0FBWixDQUFYLElBQW1ELENBVHRFO0FBQUEsVUFVSWdGLENBQUMsR0FBR2d4QyxZQVZSO0FBQUEsVUFXSWpwQyxFQVhKO0FBQUEsVUFZSTJOLE1BWko7QUFBQSxVQWFJN1IsTUFiSjtBQUFBLFVBY0lvdEMsVUFkSjtBQUFBLFVBZUloSSxRQWZKO0FBQUEsVUFnQklpSSxVQWhCSjtBQUFBLFVBaUJJQyxNQWpCSjtBQUFBLFVBa0JJQyxjQWxCSjtBQUFBLFVBbUJJQyxPQW5CSjtBQUFBLFVBb0JJQyxZQXBCSjs7QUFzQkEsYUFBT3R4QyxDQUFDLEVBQVIsRUFBWTtBQUNWO0FBQ0FreEMsUUFBQUEsVUFBVSxHQUFHdkwsU0FBUyxDQUFDM2xDLENBQUQsQ0FBdEI7QUFDQWt4QyxRQUFBQSxVQUFVLENBQUNsb0MsR0FBWCxJQUFrQmtvQyxVQUFVLENBQUN6SixPQUFYLENBQW1CLENBQW5CLEVBQXNCLENBQXRCLENBQWxCLEtBQStDOUksV0FBVyxHQUFHLENBQTdELEVBSFUsQ0FHdUQ7O0FBRWpFd1MsUUFBQUEsTUFBTSxHQUFHRCxVQUFVLENBQUM5SSxHQUFwQjs7QUFFQSxZQUFJK0ksTUFBTSxLQUFLQSxNQUFNLEtBQUs3Z0MsT0FBWCxJQUFzQjZnQyxNQUFNLEtBQUsvSSxHQUF0QyxDQUFOLElBQW9ELENBQUM4SSxVQUFVLENBQUNYLFVBQXBFLEVBQWdGO0FBQzlFZSxVQUFBQSxZQUFZLEtBQUtBLFlBQVksR0FBRyxFQUFwQixDQUFaO0FBQ0FBLFVBQUFBLFlBQVksQ0FBQ2pqQixPQUFiLENBQXFCNmlCLFVBQXJCLEVBRjhFLENBRTVDOztBQUVsQ0EsVUFBQUEsVUFBVSxDQUFDaEssTUFBWDtBQUNEOztBQUVELFlBQUlnSyxVQUFVLEtBQUt2TCxTQUFTLENBQUMzbEMsQ0FBRCxDQUE1QixFQUFpQztBQUMvQjtBQUNBZ3hDLFVBQUFBLFlBQVk7QUFDWmh4QyxVQUFBQSxDQUFDO0FBQ0Y7QUFDRjs7QUFFRDdDLE1BQUFBLFdBQVcsQ0FBQzJ6QyxXQUFELENBQVgsS0FBNkJBLFdBQVcsR0FBR0EsV0FBVyxDQUFDOTFDLElBQUQsQ0FBdEQ7QUFDQXFjLE1BQUFBLEtBQUssR0FBRzh4QixjQUFjLENBQUMySCxXQUFELEVBQWN4Z0MsT0FBZCxFQUF1QmcwQixJQUF2QixFQUE2Qm5uQixTQUE3QixFQUF3Q3FtQixVQUFVLEVBQWxELEVBQXNEbUosV0FBdEQsRUFBbUVFLGtCQUFuRSxFQUF1Rjd4QyxJQUF2RixFQUE2RnN1QyxjQUE3RixFQUE2R0MsV0FBN0csRUFBMEgxRSxnQkFBMUgsRUFBNEk5Z0MsR0FBNUksRUFBaUo2Z0Msa0JBQWpKLENBQWQsS0FBdUx3RCxHQUFHLEdBQUcsQ0FBQyxLQUFKLEdBQVksQ0FBdE0sQ0FBUjtBQUNBanJDLE1BQUFBLFdBQVcsQ0FBQ3d6QyxTQUFELENBQVgsS0FBMkJBLFNBQVMsR0FBR0EsU0FBUyxDQUFDMzFDLElBQUQsQ0FBaEQ7O0FBRUEsVUFBSThrQixTQUFTLENBQUM2d0IsU0FBRCxDQUFULElBQXdCLENBQUNBLFNBQVMsQ0FBQ2xqQyxPQUFWLENBQWtCLElBQWxCLENBQTdCLEVBQXNEO0FBQ3BELFlBQUksQ0FBQ2tqQyxTQUFTLENBQUNsakMsT0FBVixDQUFrQixHQUFsQixDQUFMLEVBQTZCO0FBQzNCa2pDLFVBQUFBLFNBQVMsR0FBRyxDQUFDN3dCLFNBQVMsQ0FBQ2d4QixXQUFELENBQVQsR0FBeUJBLFdBQVcsQ0FBQzFpQyxLQUFaLENBQWtCLEdBQWxCLEVBQXVCLENBQXZCLENBQXpCLEdBQXFELEVBQXRELElBQTREdWlDLFNBQXhFO0FBQ0QsU0FGRCxNQUVPO0FBQ0wvcEMsVUFBQUEsTUFBTSxHQUFHeTlCLFdBQVcsQ0FBQ3NNLFNBQVMsQ0FBQ3ZrQixNQUFWLENBQWlCLENBQWpCLENBQUQsRUFBc0JrWSxJQUF0QixDQUFwQjtBQUNBcU0sVUFBQUEsU0FBUyxHQUFHN3dCLFNBQVMsQ0FBQ2d4QixXQUFELENBQVQsR0FBeUJBLFdBQXpCLEdBQXVDejVCLEtBQUssR0FBR3pRLE1BQTNELENBRkssQ0FFOEQ7O0FBRW5FZ3FDLFVBQUFBLGdCQUFnQixHQUFHdGdDLE9BQW5CO0FBQ0Q7QUFDRjs7QUFFRHRILE1BQUFBLEdBQUcsR0FBR3JMLElBQUksQ0FBQ29HLEdBQUwsQ0FBU3NULEtBQVQsRUFBZ0I4eEIsY0FBYyxDQUFDd0gsU0FBUyxLQUFLQyxnQkFBZ0IsR0FBRyxRQUFILEdBQWM3c0MsR0FBbkMsQ0FBVixFQUFtRDZzQyxnQkFBbkQsRUFBcUV0TSxJQUFyRSxFQUEyRW5uQixTQUEzRSxFQUFzRnFtQixVQUFVLEtBQUs1OEIsTUFBckcsRUFBNkdnbUMsU0FBN0csRUFBd0hFLGdCQUF4SCxFQUEwSTl4QyxJQUExSSxFQUFnSnN1QyxjQUFoSixFQUFnS0MsV0FBaEssRUFBNksxRSxnQkFBN0ssRUFBK0w5Z0MsR0FBL0wsRUFBb002Z0Msa0JBQXBNLENBQTlCLEtBQTBQLENBQUMsS0FBalE7QUFDQW9JLE1BQUFBLE1BQU0sR0FBR2hrQyxHQUFHLEdBQUdxTyxLQUFOLElBQWUsQ0FBQ0EsS0FBSyxJQUFJLElBQVYsS0FBbUIsS0FBM0M7QUFDQXpRLE1BQUFBLE1BQU0sR0FBRyxDQUFUO0FBQ0E1RyxNQUFBQSxDQUFDLEdBQUdneEMsWUFBSjs7QUFFQSxhQUFPaHhDLENBQUMsRUFBUixFQUFZO0FBQ1ZreEMsUUFBQUEsVUFBVSxHQUFHdkwsU0FBUyxDQUFDM2xDLENBQUQsQ0FBdEI7QUFDQW14QyxRQUFBQSxNQUFNLEdBQUdELFVBQVUsQ0FBQzlJLEdBQXBCOztBQUVBLFlBQUkrSSxNQUFNLElBQUlELFVBQVUsQ0FBQzc1QixLQUFYLEdBQW1CNjVCLFVBQVUsQ0FBQ0ssUUFBOUIsR0FBeUNsNkIsS0FBbkQsSUFBNEQsQ0FBQ3V0QixrQkFBN0QsSUFBbUZzTSxVQUFVLENBQUNsb0MsR0FBWCxHQUFpQixDQUF4RyxFQUEyRztBQUN6R2pCLFVBQUFBLEVBQUUsR0FBR21wQyxVQUFVLENBQUNsb0MsR0FBWCxHQUFpQmtvQyxVQUFVLENBQUM3NUIsS0FBakM7O0FBRUEsY0FBSSxDQUFDODVCLE1BQU0sS0FBSzdnQyxPQUFYLElBQXNCNmdDLE1BQU0sS0FBS0osZUFBbEMsS0FBc0QsQ0FBQ2h4QixTQUFTLENBQUMrd0IsV0FBRCxDQUFwRSxFQUFtRjtBQUNqRjtBQUNBbHFDLFlBQUFBLE1BQU0sSUFBSW1CLEVBQUUsSUFBSSxJQUFJbXBDLFVBQVUsQ0FBQzl3QixRQUFuQixDQUFaO0FBQ0Q7O0FBRUQrd0IsVUFBQUEsTUFBTSxLQUFLL0ksR0FBWCxLQUFtQnNJLGNBQWMsSUFBSTNvQyxFQUFyQztBQUNEO0FBQ0Y7O0FBRURzUCxNQUFBQSxLQUFLLElBQUl6USxNQUFUO0FBQ0FvQyxNQUFBQSxHQUFHLElBQUlwQyxNQUFQO0FBQ0E1TCxNQUFBQSxJQUFJLENBQUN1MkMsUUFBTCxHQUFnQmIsY0FBaEI7O0FBRUEsVUFBSS9ELFdBQVcsSUFBSS9sQyxNQUFuQixFQUEyQjtBQUN6QjtBQUNBbUIsUUFBQUEsRUFBRSxHQUFHLEVBQUw7QUFDQUEsUUFBQUEsRUFBRSxDQUFDb1YsU0FBUyxDQUFDclUsQ0FBWCxDQUFGLEdBQWtCLE9BQU9sQyxNQUF6QjtBQUNBbXFDLFFBQUFBLGVBQWUsS0FBS2hwQyxFQUFFLENBQUNvVixTQUFTLENBQUN4ZCxDQUFYLENBQUYsR0FBa0IsT0FBTzZqQyxVQUFVLEVBQXhDLENBQWY7QUFDQTVuQyxRQUFBQSxrQkFBSSxDQUFDZ08sR0FBTCxDQUFTLENBQUMraUMsV0FBRCxFQUFjQyxTQUFkLENBQVQsRUFBbUM3a0MsRUFBbkM7QUFDRDs7QUFFRCxVQUFJcWdDLEdBQUosRUFBUztBQUNQcmdDLFFBQUFBLEVBQUUsR0FBR3BELGlCQUFpQixDQUFDeWpDLEdBQUQsQ0FBdEI7QUFDQTZJLFFBQUFBLFVBQVUsR0FBRzl6QixTQUFTLEtBQUt1YSxTQUEzQjtBQUNBN3pCLFFBQUFBLE1BQU0sR0FBRzIvQixVQUFVLEVBQW5CLENBSE8sQ0FHZ0I7O0FBRXZCOEosUUFBQUEsUUFBUSxHQUFHbGxDLFVBQVUsQ0FBQ2dsQyxTQUFTLENBQUNqd0IsU0FBUyxDQUFDclUsQ0FBWCxDQUFWLENBQVYsR0FBcUM0bkMsY0FBaEQ7QUFDQSxTQUFDM3NDLEdBQUQsSUFBUWlGLEdBQUcsR0FBRyxDQUFkLEtBQW9CLENBQUNpekIsVUFBVSxHQUFHamdDLGtCQUFILEdBQVdpa0MsUUFBdEIsRUFBZ0MxaEMsS0FBaEMsQ0FBc0MsY0FBYzRlLFNBQVMsQ0FBQ3JVLENBQTlELElBQW1FLFFBQXZGLEVBTk8sQ0FNMkY7O0FBRWxHNC9CLFFBQUFBLFVBQVUsQ0FBQ04sR0FBRCxFQUFNQyxNQUFOLEVBQWN0Z0MsRUFBZCxDQUFWOztBQUVBb2xDLFFBQUFBLFFBQVEsR0FBR3BFLFNBQVMsQ0FBQ1gsR0FBRCxDQUFwQixDQVZPLENBVW9COztBQUUzQjF5QixRQUFBQSxNQUFNLEdBQUdoUCxVQUFVLENBQUMwaEMsR0FBRCxFQUFNLElBQU4sQ0FBbkI7QUFDQWdKLFFBQUFBLGNBQWMsR0FBR3ZNLGdCQUFnQixJQUFJOU0sY0FBYyxDQUFDa0ksUUFBRCxFQUFXZ1IsVUFBVSxHQUFHM1osV0FBSCxHQUFpQkksU0FBdEMsQ0FBZCxFQUFyQzs7QUFFQSxZQUFJb1QsVUFBSixFQUFnQjtBQUNkckMsVUFBQUEsV0FBVyxHQUFHLENBQUNxQyxVQUFVLEdBQUczdEIsU0FBUyxDQUFDcWEsR0FBeEIsRUFBNkJ3VixNQUFNLEdBQUcwRCxjQUFULEdBQTBCMU8sR0FBdkQsQ0FBZDtBQUNBeUcsVUFBQUEsV0FBVyxDQUFDaG9CLENBQVosR0FBZ0I0bkIsTUFBaEI7QUFDQXJvQyxVQUFBQSxDQUFDLEdBQUc4cUMsVUFBVSxLQUFLbEosUUFBZixHQUEwQmMsUUFBUSxDQUFDMEYsR0FBRCxFQUFNanJCLFNBQU4sQ0FBUixHQUEyQjZ2QixNQUEzQixHQUFvQzBELGNBQTlELEdBQStFLENBQW5GO0FBQ0Exd0MsVUFBQUEsQ0FBQyxJQUFJeW9DLFdBQVcsQ0FBQ2hvQyxJQUFaLENBQWlCMGMsU0FBUyxDQUFDekMsQ0FBM0IsRUFBOEIxYSxDQUFDLEdBQUdnaUMsR0FBbEMsQ0FBTCxDQUpjLENBSStCOztBQUU3Q3VHLFVBQUFBLFNBQVMsQ0FBQ0UsV0FBRCxDQUFUOztBQUVBNUQsVUFBQUEsZ0JBQWdCLElBQUlyQixVQUFVLENBQUMwSyxVQUFELENBQTlCO0FBQ0Q7O0FBRUQsWUFBSXJKLGdCQUFKLEVBQXNCO0FBQ3BCb0UsVUFBQUEsUUFBUSxHQUFHO0FBQ1QvakMsWUFBQUEsR0FBRyxFQUFFd1EsTUFBTSxDQUFDeFEsR0FBUCxJQUFjK3JDLFVBQVUsR0FBR3B0QyxNQUFNLEdBQUd3VCxLQUFaLEdBQW9CKzVCLGNBQTVDLElBQThEcFAsR0FEMUQ7QUFFVC84QixZQUFBQSxJQUFJLEVBQUV5USxNQUFNLENBQUN6USxJQUFQLElBQWVnc0MsVUFBVSxHQUFHRyxjQUFILEdBQW9CdnRDLE1BQU0sR0FBR3dULEtBQXRELElBQStEMnFCLEdBRjVEO0FBR1Q3NUIsWUFBQUEsU0FBUyxFQUFFLFlBSEY7QUFJVDZCLFlBQUFBLFFBQVEsRUFBRTtBQUpELFdBQVg7QUFNQWkvQixVQUFBQSxRQUFRLENBQUMzSCxNQUFELENBQVIsR0FBbUIySCxRQUFRLENBQUMsUUFBUW5ILE1BQVQsQ0FBUixHQUEyQm5rQyxJQUFJLENBQUMrc0IsSUFBTCxDQUFVaFYsTUFBTSxDQUFDdlEsS0FBakIsSUFBMEI2OEIsR0FBeEU7QUFDQWlILFVBQUFBLFFBQVEsQ0FBQzFILE9BQUQsQ0FBUixHQUFvQjBILFFBQVEsQ0FBQyxRQUFRbEgsT0FBVCxDQUFSLEdBQTRCcGtDLElBQUksQ0FBQytzQixJQUFMLENBQVVoVixNQUFNLENBQUNuUSxNQUFqQixJQUEyQnk4QixHQUEzRTtBQUNBaUgsVUFBQUEsUUFBUSxDQUFDcEgsT0FBRCxDQUFSLEdBQW9Cb0gsUUFBUSxDQUFDcEgsT0FBTyxHQUFHSCxJQUFYLENBQVIsR0FBMkJ1SCxRQUFRLENBQUNwSCxPQUFPLEdBQUdMLE1BQVgsQ0FBUixHQUE2QnlILFFBQVEsQ0FBQ3BILE9BQU8sR0FBR0YsT0FBWCxDQUFSLEdBQThCc0gsUUFBUSxDQUFDcEgsT0FBTyxHQUFHSixLQUFYLENBQVIsR0FBNEIsR0FBdEk7QUFDQXdILFVBQUFBLFFBQVEsQ0FBQ3JILFFBQUQsQ0FBUixHQUFxQjc1QixFQUFFLENBQUM2NUIsUUFBRCxDQUF2QjtBQUNBcUgsVUFBQUEsUUFBUSxDQUFDckgsUUFBUSxHQUFHRixJQUFaLENBQVIsR0FBNEIzNUIsRUFBRSxDQUFDNjVCLFFBQVEsR0FBR0YsSUFBWixDQUE5QjtBQUNBdUgsVUFBQUEsUUFBUSxDQUFDckgsUUFBUSxHQUFHSixNQUFaLENBQVIsR0FBOEJ6NUIsRUFBRSxDQUFDNjVCLFFBQVEsR0FBR0osTUFBWixDQUFoQztBQUNBeUgsVUFBQUEsUUFBUSxDQUFDckgsUUFBUSxHQUFHRCxPQUFaLENBQVIsR0FBK0I1NUIsRUFBRSxDQUFDNjVCLFFBQVEsR0FBR0QsT0FBWixDQUFqQztBQUNBc0gsVUFBQUEsUUFBUSxDQUFDckgsUUFBUSxHQUFHSCxLQUFaLENBQVIsR0FBNkIxNUIsRUFBRSxDQUFDNjVCLFFBQVEsR0FBR0gsS0FBWixDQUEvQjtBQUNBeUwsVUFBQUEsY0FBYyxHQUFHbEUsVUFBVSxDQUFDaUUsZ0JBQUQsRUFBbUJoRSxRQUFuQixFQUE2QmtDLFdBQTdCLENBQTNCO0FBQ0Q7O0FBRUQsWUFBSXJLLFNBQUosRUFBZTtBQUNiO0FBQ0F1USxVQUFBQSxPQUFPLEdBQUd2USxTQUFTLENBQUMrTixRQUFwQixDQUZhLENBRWlCOztBQUU5QjNQLFVBQUFBLG1CQUFtQixDQUFDLENBQUQsQ0FBbkI7O0FBRUE0QixVQUFBQSxTQUFTLENBQUN2dEIsTUFBVixDQUFpQnV0QixTQUFTLENBQUMzL0IsUUFBVixFQUFqQixFQUF1QyxJQUF2QyxFQUE2QyxJQUE3QztBQUNBb3NDLFVBQUFBLFNBQVMsR0FBR0gsU0FBUyxDQUFDandCLFNBQVMsQ0FBQ3JVLENBQVgsQ0FBVCxHQUF5QndrQyxRQUF6QixHQUFvQ04sTUFBcEMsR0FBNkMwRCxjQUF6RDtBQUNBMUQsVUFBQUEsTUFBTSxLQUFLTyxTQUFYLElBQXdCMUksZ0JBQXhCLElBQTRDcUksY0FBYyxDQUFDbnNDLE1BQWYsQ0FBc0Jtc0MsY0FBYyxDQUFDanRDLE1BQWYsR0FBd0IsQ0FBOUMsRUFBaUQsQ0FBakQsQ0FBNUMsQ0FSYSxDQVFvRjs7QUFFakc2Z0MsVUFBQUEsU0FBUyxDQUFDdnRCLE1BQVYsQ0FBaUIsQ0FBakIsRUFBb0IsSUFBcEIsRUFBMEIsSUFBMUI7QUFDQTg5QixVQUFBQSxPQUFPLElBQUl2USxTQUFTLENBQUMyUCxVQUFWLEVBQVg7O0FBRUF2UixVQUFBQSxtQkFBbUIsQ0FBQyxDQUFELENBQW5CO0FBQ0QsU0FkRCxNQWNPO0FBQ0xxTyxVQUFBQSxTQUFTLEdBQUdQLE1BQVo7QUFDRDtBQUNGLE9BN0RELE1BNkRPLElBQUkxOEIsT0FBTyxJQUFJa3pCLFVBQVUsRUFBckIsSUFBMkIsQ0FBQ29CLGtCQUFoQyxFQUFvRDtBQUN6RDtBQUNBbHZCLFFBQUFBLE1BQU0sR0FBR3BGLE9BQU8sQ0FBQy9NLFVBQWpCOztBQUVBLGVBQU9tUyxNQUFNLElBQUlBLE1BQU0sS0FBSzFaLGtCQUE1QixFQUFtQztBQUNqQyxjQUFJMFosTUFBTSxDQUFDODdCLFVBQVgsRUFBdUI7QUFDckJuNkIsWUFBQUEsS0FBSyxJQUFJM0IsTUFBTSxDQUFDODdCLFVBQWhCO0FBQ0F4b0MsWUFBQUEsR0FBRyxJQUFJME0sTUFBTSxDQUFDODdCLFVBQWQ7QUFDRDs7QUFFRDk3QixVQUFBQSxNQUFNLEdBQUdBLE1BQU0sQ0FBQ25TLFVBQWhCO0FBQ0Q7QUFDRjs7QUFFRCt0QyxNQUFBQSxZQUFZLElBQUlBLFlBQVksQ0FBQ2h4QyxPQUFiLENBQXFCLFVBQVVtZ0IsQ0FBVixFQUFhO0FBQ2hELGVBQU9BLENBQUMsQ0FBQ3ltQixNQUFGLENBQVMsS0FBVCxDQUFQO0FBQ0QsT0FGZSxDQUFoQjtBQUdBbHNDLE1BQUFBLElBQUksQ0FBQ3FjLEtBQUwsR0FBYUEsS0FBYjtBQUNBcmMsTUFBQUEsSUFBSSxDQUFDZ08sR0FBTCxHQUFXQSxHQUFYO0FBQ0F5akMsTUFBQUEsT0FBTyxHQUFHQyxPQUFPLEdBQUdsSixVQUFVLEVBQTlCLENBbk1vQyxDQW1NRjs7QUFFbEMsVUFBSSxDQUFDb0Isa0JBQUwsRUFBeUI7QUFDdkI2SCxRQUFBQSxPQUFPLEdBQUd5QixVQUFWLElBQXdCMUssVUFBVSxDQUFDMEssVUFBRCxDQUFsQztBQUNBbHpDLFFBQUFBLElBQUksQ0FBQzZJLE1BQUwsQ0FBWXVqQyxHQUFaLEdBQWtCLENBQWxCO0FBQ0Q7O0FBRURwc0MsTUFBQUEsSUFBSSxDQUFDa3NDLE1BQUwsQ0FBWSxLQUFaOztBQUVBLFVBQUk4RyxlQUFKLEVBQXFCO0FBQ25CNUIsUUFBQUEsUUFBUSxHQUFHLENBQUMsQ0FBWjtBQUNBcHhDLFFBQUFBLElBQUksQ0FBQ2tkLFFBQUwsSUFBaUJzckIsVUFBVSxDQUFDbnNCLEtBQUssR0FBRzIxQixNQUFNLEdBQUdpQixZQUFsQixDQUEzQixDQUZtQixDQUV5Qzs7QUFFNURELFFBQUFBLGVBQWUsQ0FBQ3pRLE9BQWhCLENBQXdCLElBQXhCO0FBQ0Q7O0FBRURvQixNQUFBQSxXQUFXLEdBQUcsQ0FBZDtBQUNBbUMsTUFBQUEsU0FBUyxJQUFJMEssUUFBYixLQUEwQjFLLFNBQVMsQ0FBQytOLFFBQVYsSUFBc0JWLGdCQUFoRCxLQUFxRXJOLFNBQVMsQ0FBQzFnQixRQUFWLE9BQXlCK3RCLGdCQUE5RixJQUFrSHJOLFNBQVMsQ0FBQzFnQixRQUFWLENBQW1CK3RCLGdCQUFuQixFQUFxQyxJQUFyQyxFQUEyQzU2QixNQUEzQyxDQUFrRHV0QixTQUFTLENBQUNsbEIsSUFBVixFQUFsRCxFQUFvRSxJQUFwRSxFQUEwRSxJQUExRSxDQUFsSCxDQXBOb0MsQ0FvTitKOztBQUVuTSxVQUFJcXlCLFlBQVksS0FBS2p6QyxJQUFJLENBQUNvbEIsUUFBdEIsSUFBa0N3a0Isa0JBQXRDLEVBQTBEO0FBQ3hEO0FBQ0E5RCxRQUFBQSxTQUFTLElBQUksQ0FBQzBLLFFBQWQsSUFBMEIxSyxTQUFTLENBQUM2TixhQUFWLENBQXdCVixZQUF4QixFQUFzQyxJQUF0QyxDQUExQixDQUZ3RCxDQUVlOztBQUV2RWp6QyxRQUFBQSxJQUFJLENBQUNvbEIsUUFBTCxHQUFnQjZ0QixZQUFoQjtBQUNBanpDLFFBQUFBLElBQUksQ0FBQ3VpQixNQUFMLENBQVksQ0FBWixFQUFlLENBQWYsRUFBa0IsQ0FBbEI7QUFDRDs7QUFFRDZxQixNQUFBQSxHQUFHLElBQUkwQyxVQUFQLEtBQXNCekMsTUFBTSxDQUFDbUosVUFBUCxHQUFvQjd6QyxJQUFJLENBQUNDLEtBQUwsQ0FBVzVDLElBQUksQ0FBQ29sQixRQUFMLEdBQWdCbXRCLFNBQTNCLENBQTFDLEVBOU5vQyxDQThOOEM7O0FBRWxGM0MsTUFBQUEsU0FBUyxJQUFJQSxTQUFTLENBQUM1dkMsSUFBRCxDQUF0QjtBQUNELEtBak9EOztBQW1PQUEsSUFBQUEsSUFBSSxDQUFDb2lCLFdBQUwsR0FBbUIsWUFBWTtBQUM3QixhQUFPLENBQUNvbUIsVUFBVSxLQUFLa0osT0FBaEIsS0FBNEI5dEMscUJBQVEsS0FBSzYvQixNQUF6QyxJQUFtRCxJQUFuRCxJQUEyRCxDQUFsRTtBQUNELEtBRkQ7O0FBSUF6akMsSUFBQUEsSUFBSSxDQUFDeTJDLFlBQUwsR0FBb0IsWUFBWTtBQUM5QjVRLE1BQUFBLGFBQWEsQ0FBQzdsQyxJQUFJLENBQUNpbUMsaUJBQU4sQ0FBYjs7QUFFQSxVQUFJSCxTQUFKLEVBQWU7QUFDYitNLFFBQUFBLFVBQVUsR0FBR0EsVUFBVSxDQUFDenRCLFFBQVgsQ0FBb0IsQ0FBcEIsQ0FBSCxHQUE0QixDQUFDMGdCLFNBQVMsQ0FBQzhOLE1BQVYsRUFBRCxHQUFzQi9OLGFBQWEsQ0FBQ0MsU0FBRCxFQUFZQSxTQUFTLENBQUMzZixRQUFWLEVBQVosQ0FBbkMsR0FBdUVxcUIsUUFBUSxJQUFJM0ssYUFBYSxDQUFDQyxTQUFELEVBQVk5bEMsSUFBSSxDQUFDbWlCLFNBQUwsR0FBaUIsQ0FBN0IsRUFBZ0MsQ0FBaEMsQ0FBdEk7QUFDRDtBQUNGLEtBTkQ7O0FBUUFuaUIsSUFBQUEsSUFBSSxDQUFDMDJDLGFBQUwsR0FBcUIsVUFBVUMsS0FBVixFQUFpQjtBQUNwQyxhQUFPN1EsU0FBUyxJQUFJQSxTQUFTLENBQUNnQyxNQUF2QixJQUFpQyxDQUFDenJCLEtBQUssSUFBSXJjLElBQUksQ0FBQ3lzQyxPQUFMLEVBQVQsSUFBMkJwd0IsS0FBNUIsSUFBcUN5cEIsU0FBUyxDQUFDZ0MsTUFBVixDQUFpQjZPLEtBQWpCLElBQTBCN1EsU0FBUyxDQUFDMy9CLFFBQVYsRUFBMUIsR0FBaUQ2ckMsTUFBdkgsSUFBaUksQ0FBeEk7QUFDRCxLQUZEOztBQUlBaHlDLElBQUFBLElBQUksQ0FBQzQyQyxXQUFMLEdBQW1CLFVBQVVodkIsSUFBVixFQUFnQjtBQUNqQyxVQUFJNWlCLENBQUMsR0FBRzJsQyxTQUFTLENBQUNsNEIsT0FBVixDQUFrQnpTLElBQWxCLENBQVI7QUFBQSxVQUNJOE4sQ0FBQyxHQUFHOU4sSUFBSSxDQUFDbWlCLFNBQUwsR0FBaUIsQ0FBakIsR0FBcUJ3b0IsU0FBUyxDQUFDOWtCLEtBQVYsQ0FBZ0IsQ0FBaEIsRUFBbUI3Z0IsQ0FBbkIsRUFBc0JraEIsT0FBdEIsRUFBckIsR0FBdUR5a0IsU0FBUyxDQUFDOWtCLEtBQVYsQ0FBZ0I3Z0IsQ0FBQyxHQUFHLENBQXBCLENBRC9EOztBQUdBLGFBQU8sQ0FBQzhmLFNBQVMsQ0FBQzhDLElBQUQsQ0FBVCxHQUFrQjlaLENBQUMsQ0FBQ3MxQixNQUFGLENBQVMsVUFBVTNkLENBQVYsRUFBYTtBQUM5QyxlQUFPQSxDQUFDLENBQUN2YSxJQUFGLENBQU9vbEMsZUFBUCxLQUEyQjFvQixJQUFsQztBQUNELE9BRnlCLENBQWxCLEdBRUg5WixDQUZFLEVBRUNzMUIsTUFGRCxDQUVRLFVBQVUzZCxDQUFWLEVBQWE7QUFDMUIsZUFBT3psQixJQUFJLENBQUNtaUIsU0FBTCxHQUFpQixDQUFqQixHQUFxQnNELENBQUMsQ0FBQ3pYLEdBQUYsSUFBU3FPLEtBQTlCLEdBQXNDb0osQ0FBQyxDQUFDcEosS0FBRixJQUFXck8sR0FBeEQ7QUFDRCxPQUpNLENBQVA7QUFLRCxLQVREOztBQVdBaE8sSUFBQUEsSUFBSSxDQUFDdWlCLE1BQUwsR0FBYyxVQUFVaWIsS0FBVixFQUFpQndQLGNBQWpCLEVBQWlDNkosU0FBakMsRUFBNEM7QUFDeEQsVUFBSWpOLGtCQUFrQixJQUFJLENBQUNpTixTQUF2QixJQUFvQyxDQUFDclosS0FBekMsRUFBZ0Q7QUFDOUM7QUFDRDs7QUFFRCxVQUFJMzBCLE1BQU0sR0FBRzdJLElBQUksQ0FBQzZJLE1BQUwsRUFBYjtBQUFBLFVBQ0lsRSxDQUFDLEdBQUc2NEIsS0FBSyxHQUFHLENBQUgsR0FBTyxDQUFDMzBCLE1BQU0sR0FBR3dULEtBQVYsSUFBbUIyMUIsTUFEdkM7QUFBQSxVQUVJOEUsT0FBTyxHQUFHbnlDLENBQUMsR0FBRyxDQUFKLEdBQVEsQ0FBUixHQUFZQSxDQUFDLEdBQUcsQ0FBSixHQUFRLENBQVIsR0FBWUEsQ0FBQyxJQUFJLENBRjNDO0FBQUEsVUFHSXN1QyxZQUFZLEdBQUdqekMsSUFBSSxDQUFDb2xCLFFBSHhCO0FBQUEsVUFJSWxJLFFBSko7QUFBQSxVQUtJNjVCLFNBTEo7QUFBQSxVQU1JQyxXQU5KO0FBQUEsVUFPSUMsTUFQSjtBQUFBLFVBUUlDLFlBUko7QUFBQSxVQVNJQyxPQVRKO0FBQUEsVUFVSUMsT0FWSjtBQUFBLFVBV0lDLGNBWEo7O0FBYUEsVUFBSXJLLGNBQUosRUFBb0I7QUFDbEIwRSxRQUFBQSxPQUFPLEdBQUdELE9BQVY7QUFDQUEsUUFBQUEsT0FBTyxHQUFHN0gsa0JBQWtCLEdBQUdwQixVQUFVLEVBQWIsR0FBa0IzL0IsTUFBOUM7O0FBRUEsWUFBSStFLElBQUosRUFBVTtBQUNSZ2xDLFVBQUFBLEtBQUssR0FBR0QsS0FBUjtBQUNBQSxVQUFBQSxLQUFLLEdBQUc3TSxTQUFTLElBQUksQ0FBQzBLLFFBQWQsR0FBeUIxSyxTQUFTLENBQUM2TixhQUFWLEVBQXpCLEdBQXFEbUQsT0FBN0Q7QUFDRDtBQUNGLE9BMUJ1RCxDQTBCdEQ7OztBQUdGNU4sTUFBQUEsYUFBYSxJQUFJLENBQUM0TixPQUFsQixJQUE2QjFKLEdBQTdCLElBQW9DLENBQUN6SixXQUFyQyxJQUFvRCxDQUFDN0kscUJBQXJELElBQWlFNEosZUFBakUsSUFBb0Zyb0IsS0FBSyxHQUFHeFQsTUFBTSxHQUFHLENBQUNBLE1BQU0sR0FBRzZvQyxPQUFWLEtBQXNCOXRDLHFCQUFRLEtBQUs2L0IsTUFBbkMsSUFBNkN5RixhQUFsSixLQUFvSzROLE9BQU8sR0FBRyxNQUE5Szs7QUFFQSxVQUFJQSxPQUFPLEtBQUs3RCxZQUFaLElBQTRCanpDLElBQUksQ0FBQzBXLE9BQXJDLEVBQThDO0FBQzVDd0csUUFBQUEsUUFBUSxHQUFHbGQsSUFBSSxDQUFDa2QsUUFBTCxHQUFnQixDQUFDLENBQUM0NUIsT0FBRixJQUFhQSxPQUFPLEdBQUcsQ0FBbEQ7QUFDQUMsUUFBQUEsU0FBUyxHQUFHLENBQUMsQ0FBQzlELFlBQUYsSUFBa0JBLFlBQVksR0FBRyxDQUE3QztBQUNBa0UsUUFBQUEsT0FBTyxHQUFHajZCLFFBQVEsS0FBSzY1QixTQUF2QjtBQUNBRyxRQUFBQSxZQUFZLEdBQUdDLE9BQU8sSUFBSSxDQUFDLENBQUNMLE9BQUYsS0FBYyxDQUFDLENBQUM3RCxZQUExQyxDQUo0QyxDQUlZOztBQUV4RGp6QyxRQUFBQSxJQUFJLENBQUNtaUIsU0FBTCxHQUFpQjIwQixPQUFPLEdBQUc3RCxZQUFWLEdBQXlCLENBQXpCLEdBQTZCLENBQUMsQ0FBL0M7QUFDQWp6QyxRQUFBQSxJQUFJLENBQUNvbEIsUUFBTCxHQUFnQjB4QixPQUFoQjs7QUFFQSxZQUFJSSxZQUFZLElBQUksQ0FBQ3ZULFdBQXJCLEVBQWtDO0FBQ2hDcVQsVUFBQUEsV0FBVyxHQUFHRixPQUFPLElBQUksQ0FBQzdELFlBQVosR0FBMkIsQ0FBM0IsR0FBK0I2RCxPQUFPLEtBQUssQ0FBWixHQUFnQixDQUFoQixHQUFvQjdELFlBQVksS0FBSyxDQUFqQixHQUFxQixDQUFyQixHQUF5QixDQUExRixDQURnQyxDQUM2RDs7QUFFN0YsY0FBSXpDLFFBQUosRUFBYztBQUNaeUcsWUFBQUEsTUFBTSxHQUFHLENBQUNFLE9BQUQsSUFBWWxPLGFBQWEsQ0FBQytOLFdBQVcsR0FBRyxDQUFmLENBQWIsS0FBbUMsTUFBL0MsSUFBeUQvTixhQUFhLENBQUMrTixXQUFXLEdBQUcsQ0FBZixDQUF0RSxJQUEyRi9OLGFBQWEsQ0FBQytOLFdBQUQsQ0FBakgsQ0FEWSxDQUNvSDs7QUFFaElLLFlBQUFBLGNBQWMsR0FBR3ZSLFNBQVMsS0FBS21SLE1BQU0sS0FBSyxVQUFYLElBQXlCQSxNQUFNLEtBQUssT0FBcEMsSUFBK0NBLE1BQU0sSUFBSW5SLFNBQTlELENBQTFCO0FBQ0Q7QUFDRjs7QUFFRHdLLFFBQUFBLGVBQWUsS0FBSzZHLE9BQU8sSUFBSUUsY0FBaEIsQ0FBZixLQUFtREEsY0FBYyxJQUFJeEgsS0FBbEIsSUFBMkIsQ0FBQy9KLFNBQS9FLE1BQThGM2pDLFdBQVcsQ0FBQ211QyxlQUFELENBQVgsR0FBK0JBLGVBQWUsQ0FBQ3R3QyxJQUFELENBQTlDLEdBQXVEQSxJQUFJLENBQUM0MkMsV0FBTCxDQUFpQnRHLGVBQWpCLEVBQWtDaHJDLE9BQWxDLENBQTBDLFVBQVVtZ0IsQ0FBVixFQUFhO0FBQzFNLGlCQUFPQSxDQUFDLENBQUNneEIsWUFBRixFQUFQO0FBQ0QsU0FGb0osQ0FBcko7O0FBSUEsWUFBSSxDQUFDakcsUUFBTCxFQUFlO0FBQ2IsY0FBSXFDLFVBQVUsSUFBSSxDQUFDbFAsV0FBZixJQUE4QixDQUFDN0kscUJBQW5DLEVBQTZDO0FBQzNDLGFBQUM4TyxrQkFBa0IsSUFBSWtELFFBQVEsSUFBSUEsUUFBUSxLQUFLOXNDLElBQWhELEtBQXlENnlDLFVBQVUsQ0FBQ3Q2QixNQUFYLENBQWtCczZCLFVBQVUsQ0FBQ3lFLEdBQVgsQ0FBZUMsS0FBZixHQUF1QjFFLFVBQVUsQ0FBQzJFLE1BQXBELENBQXpELENBRDJDLENBQzJFOztBQUV0SCxnQkFBSTNFLFVBQVUsQ0FBQzRFLE9BQWYsRUFBd0I7QUFDdEI1RSxjQUFBQSxVQUFVLENBQUM0RSxPQUFYLENBQW1CLGVBQW5CLEVBQW9DWCxPQUFwQyxFQUE2Q2hSLFNBQVMsQ0FBQzRSLE1BQVYsR0FBbUI1UixTQUFTLENBQUM2UixLQUExRTtBQUNELGFBRkQsTUFFTztBQUNMO0FBQ0E5RSxjQUFBQSxVQUFVLENBQUMzbkMsSUFBWCxDQUFnQnlvQyxhQUFoQixHQUFnQ21ELE9BQWhDO0FBQ0FqRSxjQUFBQSxVQUFVLENBQUM0QyxVQUFYLEdBQXdCbFQsT0FBeEI7QUFDRDtBQUNGLFdBVkQsTUFVTyxJQUFJdUQsU0FBSixFQUFlO0FBQ3BCQSxZQUFBQSxTQUFTLENBQUM2TixhQUFWLENBQXdCbUQsT0FBeEIsRUFBaUMsQ0FBQyxDQUFDblQsV0FBbkM7QUFDRDtBQUNGOztBQUVELFlBQUl5SixHQUFKLEVBQVM7QUFDUDVQLFVBQUFBLEtBQUssSUFBSXNTLFVBQVQsS0FBd0J6QyxNQUFNLENBQUM5cEMsS0FBUCxDQUFhdXNDLFVBQVUsR0FBRzN0QixTQUFTLENBQUNxYSxHQUFwQyxJQUEyQ2dXLFlBQW5FOztBQUVBLGNBQUksQ0FBQzNJLGdCQUFMLEVBQXVCO0FBQ3JCd0ksWUFBQUEsU0FBUyxDQUFDM3ZDLE1BQU0sQ0FBQzR2QyxRQUFRLEdBQUdDLFNBQVMsR0FBR3VFLE9BQXhCLENBQVAsQ0FBVDtBQUNELFdBRkQsTUFFTyxJQUFJSSxZQUFKLEVBQWtCO0FBQ3ZCRSxZQUFBQSxPQUFPLEdBQUcsQ0FBQzVaLEtBQUQsSUFBVXNaLE9BQU8sR0FBRzdELFlBQXBCLElBQW9DamxDLEdBQUcsR0FBRyxDQUFOLEdBQVVuRixNQUE5QyxJQUF3REEsTUFBTSxHQUFHLENBQVQsSUFBY3M4QixVQUFVLENBQUNGLFFBQUQsRUFBVzlpQixTQUFYLENBQTFGLENBRHVCLENBQzBGOztBQUVqSCxnQkFBSWd1QixXQUFKLEVBQWlCO0FBQ2Ysa0JBQUksQ0FBQzNTLEtBQUQsS0FBV3RnQixRQUFRLElBQUlrNkIsT0FBdkIsQ0FBSixFQUFxQztBQUNuQyxvQkFBSTE4QixNQUFNLEdBQUdoUCxVQUFVLENBQUMwaEMsR0FBRCxFQUFNLElBQU4sQ0FBdkI7QUFBQSxvQkFDSWhELE9BQU8sR0FBR3ZoQyxNQUFNLEdBQUd3VCxLQUR2Qjs7QUFHQTB5QixnQkFBQUEsU0FBUyxDQUFDM0IsR0FBRCxFQUFNcHNDLGtCQUFOLEVBQWEwWixNQUFNLENBQUN4USxHQUFQLElBQWNpWSxTQUFTLEtBQUt1YSxTQUFkLEdBQTBCME4sT0FBMUIsR0FBb0MsQ0FBbEQsSUFBdURwRCxHQUFwRSxFQUF5RXRzQixNQUFNLENBQUN6USxJQUFQLElBQWVrWSxTQUFTLEtBQUt1YSxTQUFkLEdBQTBCLENBQTFCLEdBQThCME4sT0FBN0MsSUFBd0RwRCxHQUFqSSxDQUFUO0FBQ0QsZUFMRCxNQUtPO0FBQ0wrSCxnQkFBQUEsU0FBUyxDQUFDM0IsR0FBRCxFQUFNQyxNQUFOLENBQVQ7QUFDRDtBQUNGOztBQUVERSxZQUFBQSxTQUFTLENBQUNyd0IsUUFBUSxJQUFJazZCLE9BQVosR0FBc0JsRixjQUF0QixHQUF1Q0MsUUFBeEMsQ0FBVDs7QUFFQUksWUFBQUEsU0FBUyxLQUFLUCxNQUFkLElBQXdCOEUsT0FBTyxHQUFHLENBQWxDLElBQXVDNTVCLFFBQXZDLElBQW1EbTFCLFNBQVMsQ0FBQ0MsUUFBUSxJQUFJd0UsT0FBTyxLQUFLLENBQVosSUFBaUIsQ0FBQ00sT0FBbEIsR0FBNEI3RSxTQUE1QixHQUF3QyxDQUE1QyxDQUFULENBQTVEO0FBQ0Q7QUFDRjs7QUFFRDNrQyxRQUFBQSxJQUFJLElBQUksQ0FBQzBqQyxPQUFPLENBQUNwMkIsS0FBakIsSUFBMEIsQ0FBQ3lvQixXQUEzQixJQUEwQyxDQUFDN0kscUJBQTNDLElBQXVEa1ksZUFBZSxDQUFDelEsT0FBaEIsQ0FBd0IsSUFBeEIsQ0FBdkQ7QUFDQW1OLFFBQUFBLFdBQVcsS0FBS3lILE9BQU8sSUFBSWpILElBQUksSUFBSTRHLE9BQVIsS0FBb0JBLE9BQU8sR0FBRyxDQUFWLElBQWUsQ0FBQ3RTLGVBQXBDLENBQWhCLENBQVgsSUFBb0ZuakMsUUFBUSxDQUFDcXVDLFdBQVcsQ0FBQ3BzQixPQUFiLENBQVIsQ0FBOEJoZSxPQUE5QixDQUFzQyxVQUFVbTJCLEVBQVYsRUFBYztBQUN0SSxpQkFBT0EsRUFBRSxDQUFDc1osU0FBSCxDQUFhNzNCLFFBQVEsSUFBSWd6QixJQUFaLEdBQW1CLEtBQW5CLEdBQTJCLFFBQXhDLEVBQWtEUixXQUFXLENBQUNrRixTQUE5RCxDQUFQO0FBQ0QsU0FGbUYsQ0FBcEYsQ0FqRTRDLENBbUV4Qzs7QUFFSmo1QixRQUFBQSxRQUFRLElBQUksQ0FBQzYwQixRQUFiLElBQXlCLENBQUNoVCxLQUExQixJQUFtQzdoQixRQUFRLENBQUMzYixJQUFELENBQTNDOztBQUVBLFlBQUlrM0MsWUFBWSxJQUFJLENBQUN2VCxXQUFyQixFQUFrQztBQUNoQyxjQUFJNk0sUUFBSixFQUFjO0FBQ1osZ0JBQUk2RyxjQUFKLEVBQW9CO0FBQ2xCLGtCQUFJSixNQUFNLEtBQUssVUFBZixFQUEyQjtBQUN6Qm5SLGdCQUFBQSxTQUFTLENBQUNwRSxLQUFWLEdBQWtCaVMsYUFBbEIsQ0FBZ0MsQ0FBaEM7QUFDRCxlQUZELE1BRU8sSUFBSXNELE1BQU0sS0FBSyxPQUFmLEVBQXdCO0FBQzdCblIsZ0JBQUFBLFNBQVMsQ0FBQ3ZELE9BQVYsQ0FBa0IsSUFBbEIsRUFBd0JiLEtBQXhCO0FBQ0QsZUFGTSxNQUVBLElBQUl1VixNQUFNLEtBQUssU0FBZixFQUEwQjtBQUMvQm5SLGdCQUFBQSxTQUFTLENBQUN2RCxPQUFWLENBQWtCLElBQWxCO0FBQ0QsZUFGTSxNQUVBO0FBQ0x1RCxnQkFBQUEsU0FBUyxDQUFDbVIsTUFBRCxDQUFUO0FBQ0Q7QUFDRjs7QUFFRHQ3QixZQUFBQSxRQUFRLElBQUlBLFFBQVEsQ0FBQzNiLElBQUQsQ0FBcEI7QUFDRDs7QUFFRCxjQUFJbTNDLE9BQU8sSUFBSSxDQUFDM1MsZUFBaEIsRUFBaUM7QUFDL0I7QUFDQW1MLFlBQUFBLFFBQVEsSUFBSXdILE9BQVosSUFBdUJwUixTQUFTLENBQUMvbEMsSUFBRCxFQUFPMnZDLFFBQVAsQ0FBaEM7QUFDQWdCLFlBQUFBLFNBQVMsQ0FBQ3FHLFdBQUQsQ0FBVCxJQUEwQmpSLFNBQVMsQ0FBQy9sQyxJQUFELEVBQU8yd0MsU0FBUyxDQUFDcUcsV0FBRCxDQUFoQixDQUFuQztBQUNBOUcsWUFBQUEsSUFBSSxLQUFLNEcsT0FBTyxLQUFLLENBQVosR0FBZ0I5MkMsSUFBSSxDQUFDOGQsSUFBTCxDQUFVLEtBQVYsRUFBaUIsQ0FBakIsQ0FBaEIsR0FBc0M2eUIsU0FBUyxDQUFDcUcsV0FBRCxDQUFULEdBQXlCLENBQXBFLENBQUosQ0FKK0IsQ0FJNkM7O0FBRTVFLGdCQUFJLENBQUNHLE9BQUwsRUFBYztBQUNaO0FBQ0FILGNBQUFBLFdBQVcsR0FBR0YsT0FBTyxLQUFLLENBQVosR0FBZ0IsQ0FBaEIsR0FBb0IsQ0FBbEM7QUFDQW5HLGNBQUFBLFNBQVMsQ0FBQ3FHLFdBQUQsQ0FBVCxJQUEwQmpSLFNBQVMsQ0FBQy9sQyxJQUFELEVBQU8yd0MsU0FBUyxDQUFDcUcsV0FBRCxDQUFoQixDQUFuQztBQUNEO0FBQ0Y7O0FBRUQsY0FBSTNHLGFBQWEsSUFBSSxDQUFDbnpCLFFBQWxCLElBQThCdmEsSUFBSSxDQUFDMmIsR0FBTCxDQUFTdGUsSUFBSSxDQUFDb2lCLFdBQUwsRUFBVCxLQUFnQzJDLFNBQVMsQ0FBQ3NyQixhQUFELENBQVQsR0FBMkJBLGFBQTNCLEdBQTJDLElBQTNFLENBQWxDLEVBQW9IO0FBQ2xIeEssWUFBQUEsYUFBYSxDQUFDN2xDLElBQUksQ0FBQ2ltQyxpQkFBTixDQUFiOztBQUVBNE0sWUFBQUEsVUFBVSxHQUFHQSxVQUFVLENBQUN6dEIsUUFBWCxDQUFvQixDQUFwQixDQUFILEdBQTRCeWdCLGFBQWEsQ0FBQ0MsU0FBRCxFQUFZLENBQUNnUixPQUFiLEVBQXNCLENBQXRCLENBQW5EO0FBQ0Q7QUFDRixTQW5DRCxNQW1DTyxJQUFJdEcsUUFBUSxJQUFJNzBCLFFBQVosSUFBd0IsQ0FBQ2dvQixXQUE3QixFQUEwQztBQUMvQ2hvQixVQUFBQSxRQUFRLENBQUMzYixJQUFELENBQVI7QUFDRDtBQUNGLE9BNUl1RCxDQTRJdEQ7OztBQUdGLFVBQUkweUMsZUFBSixFQUFxQjtBQUNuQixZQUFJNTRCLENBQUMsR0FBRzh2QixrQkFBa0IsR0FBRy9nQyxNQUFNLEdBQUcrZ0Msa0JBQWtCLENBQUN6akMsUUFBbkIsRUFBVCxJQUEwQ3lqQyxrQkFBa0IsQ0FBQ2lGLGFBQW5CLElBQW9DLENBQTlFLENBQUgsR0FBc0ZobUMsTUFBaEg7QUFDQTRwQyxRQUFBQSxpQkFBaUIsQ0FBQzM0QixDQUFDLElBQUkrM0Isa0JBQWtCLENBQUNuSCxVQUFuQixHQUFnQyxDQUFoQyxHQUFvQyxDQUF4QyxDQUFGLENBQWpCO0FBQ0FnSSxRQUFBQSxlQUFlLENBQUM1NEIsQ0FBRCxDQUFmO0FBQ0Q7O0FBRURzNUIsTUFBQUEsY0FBYyxJQUFJQSxjQUFjLENBQUMsQ0FBQ3ZxQyxNQUFELEdBQVUrZ0Msa0JBQWtCLENBQUN6akMsUUFBbkIsRUFBVixJQUEyQ3lqQyxrQkFBa0IsQ0FBQ2lGLGFBQW5CLElBQW9DLENBQS9FLENBQUQsQ0FBaEM7QUFDRCxLQXRKRDs7QUF3SkE3dUMsSUFBQUEsSUFBSSxDQUFDd1IsTUFBTCxHQUFjLFVBQVVnc0IsS0FBVixFQUFpQmlQLE9BQWpCLEVBQTBCO0FBQ3RDLFVBQUksQ0FBQ3pzQyxJQUFJLENBQUMwVyxPQUFWLEVBQW1CO0FBQ2pCMVcsUUFBQUEsSUFBSSxDQUFDMFcsT0FBTCxHQUFlLElBQWY7O0FBRUFuUSxRQUFBQSx5QkFBWSxDQUFDMCtCLFFBQUQsRUFBVyxRQUFYLEVBQXFCaUcsU0FBckIsQ0FBWjs7QUFFQTNrQyxRQUFBQSx5QkFBWSxDQUFDMDZCLFVBQVUsR0FBR25nQyxpQkFBSCxHQUFVbWtDLFFBQXJCLEVBQStCLFFBQS9CLEVBQXlDcEosc0JBQXpDLENBQVo7O0FBRUFvVixRQUFBQSxhQUFhLElBQUkxcUMseUJBQVksQ0FBQ2swQixhQUFELEVBQWdCLGFBQWhCLEVBQStCd1csYUFBL0IsQ0FBN0I7O0FBRUEsWUFBSXpULEtBQUssS0FBSyxLQUFkLEVBQXFCO0FBQ25CeDlCLFVBQUFBLElBQUksQ0FBQ29sQixRQUFMLEdBQWdCNnRCLFlBQVksR0FBRyxDQUEvQjtBQUNBeEIsVUFBQUEsT0FBTyxHQUFHQyxPQUFPLEdBQUdOLFFBQVEsR0FBRzVJLFVBQVUsRUFBekM7QUFDRDs7QUFFRGlFLFFBQUFBLE9BQU8sS0FBSyxLQUFaLElBQXFCenNDLElBQUksQ0FBQ3lzQyxPQUFMLEVBQXJCO0FBQ0Q7QUFDRixLQWpCRDs7QUFtQkF6c0MsSUFBQUEsSUFBSSxDQUFDcXZDLFFBQUwsR0FBZ0IsVUFBVXpoQyxJQUFWLEVBQWdCO0FBQzlCLGFBQU9BLElBQUksSUFBSTBqQyxPQUFSLEdBQWtCQSxPQUFPLENBQUNwMkIsS0FBMUIsR0FBa0MyM0IsVUFBekM7QUFDRCxLQUZEOztBQUlBN3lDLElBQUFBLElBQUksQ0FBQzBzQyxZQUFMLEdBQW9CLFVBQVVrTCxRQUFWLEVBQW9CQyxNQUFwQixFQUE0QjtBQUM5QztBQUNBLFVBQUl6SyxHQUFKLEVBQVM7QUFDUGtGLFFBQUFBLFFBQVEsSUFBSXNGLFFBQVEsR0FBR3Y3QixLQUF2QjtBQUNBazJCLFFBQUFBLFNBQVMsSUFBSXNGLE1BQU0sR0FBR0QsUUFBVCxHQUFvQjVGLE1BQWpDO0FBQ0Q7O0FBRURoeUMsTUFBQUEsSUFBSSxDQUFDcWMsS0FBTCxHQUFhQSxLQUFLLEdBQUd1N0IsUUFBckI7QUFDQTUzQyxNQUFBQSxJQUFJLENBQUNnTyxHQUFMLEdBQVdBLEdBQUcsR0FBRzZwQyxNQUFqQjtBQUNBN0YsTUFBQUEsTUFBTSxHQUFHNkYsTUFBTSxHQUFHRCxRQUFsQjtBQUNBNTNDLE1BQUFBLElBQUksQ0FBQ3VpQixNQUFMO0FBQ0QsS0FYRDs7QUFhQXZpQixJQUFBQSxJQUFJLENBQUNvUixPQUFMLEdBQWUsVUFBVW9zQixLQUFWLEVBQWlCc2EsY0FBakIsRUFBaUM7QUFDOUMsVUFBSTkzQyxJQUFJLENBQUMwVyxPQUFULEVBQWtCO0FBQ2hCOG1CLFFBQUFBLEtBQUssS0FBSyxLQUFWLElBQW1CeDlCLElBQUksQ0FBQ2tzQyxNQUFMLEVBQW5CO0FBQ0Fsc0MsUUFBQUEsSUFBSSxDQUFDMFcsT0FBTCxHQUFlMVcsSUFBSSxDQUFDa2QsUUFBTCxHQUFnQixLQUEvQjtBQUNBNDZCLFFBQUFBLGNBQWMsSUFBSWpGLFVBQVUsSUFBSUEsVUFBVSxDQUFDblIsS0FBWCxFQUFoQztBQUNBd1IsUUFBQUEsVUFBVSxHQUFHLENBQWI7QUFDQTNCLFFBQUFBLFFBQVEsS0FBS0EsUUFBUSxDQUFDNTNCLE9BQVQsR0FBbUIsQ0FBeEIsQ0FBUjtBQUNBczNCLFFBQUFBLGFBQWEsSUFBSXBxQyw0QkFBZSxDQUFDNHpCLGFBQUQsRUFBZ0IsYUFBaEIsRUFBK0J3VyxhQUEvQixDQUFoQzs7QUFFQSxZQUFJK0IsZUFBSixFQUFxQjtBQUNuQkEsVUFBQUEsZUFBZSxDQUFDdFIsS0FBaEI7QUFDQTRQLFVBQUFBLE9BQU8sQ0FBQ3AyQixLQUFSLElBQWlCbzJCLE9BQU8sQ0FBQ3AyQixLQUFSLENBQWM0QyxJQUFkLEVBQWpCLEtBQTBDd3pCLE9BQU8sQ0FBQ3AyQixLQUFSLEdBQWdCLENBQTFEO0FBQ0Q7O0FBRUQsWUFBSSxDQUFDK2xCLFVBQUwsRUFBaUI7QUFDZixjQUFJajhCLENBQUMsR0FBRzJsQyxTQUFTLENBQUMxbEMsTUFBbEI7O0FBRUEsaUJBQU9ELENBQUMsRUFBUixFQUFZO0FBQ1YsZ0JBQUkybEMsU0FBUyxDQUFDM2xDLENBQUQsQ0FBVCxDQUFhaWdDLFFBQWIsS0FBMEJBLFFBQTFCLElBQXNDMEYsU0FBUyxDQUFDM2xDLENBQUQsQ0FBVCxLQUFpQmhGLElBQTNELEVBQWlFO0FBQy9ELHFCQUQrRCxDQUN2RDtBQUNUO0FBQ0Y7O0FBRUQ2RyxVQUFBQSw0QkFBZSxDQUFDbytCLFFBQUQsRUFBVyxRQUFYLEVBQXFCaUcsU0FBckIsQ0FBZjs7QUFFQXJrQyxVQUFBQSw0QkFBZSxDQUFDbytCLFFBQUQsRUFBVyxRQUFYLEVBQXFCcEosc0JBQXJCLENBQWY7QUFDRDtBQUNGO0FBQ0YsS0E1QkQ7O0FBOEJBNzdCLElBQUFBLElBQUksQ0FBQzhkLElBQUwsR0FBWSxVQUFVb3VCLE1BQVYsRUFBa0I0TCxjQUFsQixFQUFrQztBQUM1QzkzQyxNQUFBQSxJQUFJLENBQUNvUixPQUFMLENBQWE4NkIsTUFBYixFQUFxQjRMLGNBQXJCO0FBQ0FqRixNQUFBQSxVQUFVLElBQUksQ0FBQ2lGLGNBQWYsSUFBaUNqRixVQUFVLENBQUMvMEIsSUFBWCxFQUFqQztBQUNBOEUsTUFBQUEsRUFBRSxJQUFJLE9BQU9nb0IsSUFBSSxDQUFDaG9CLEVBQUQsQ0FBakI7O0FBRUEsVUFBSTVkLENBQUMsR0FBRzJsQyxTQUFTLENBQUNsNEIsT0FBVixDQUFrQnpTLElBQWxCLENBQVI7O0FBRUFnRixNQUFBQSxDQUFDLElBQUksQ0FBTCxJQUFVMmxDLFNBQVMsQ0FBQzVrQyxNQUFWLENBQWlCZixDQUFqQixFQUFvQixDQUFwQixDQUFWO0FBQ0FBLE1BQUFBLENBQUMsS0FBSzYrQixFQUFOLElBQVlnSixVQUFVLEdBQUcsQ0FBekIsSUFBOEJoSixFQUFFLEVBQWhDLENBUjRDLENBUVI7QUFDcEM7O0FBRUE3K0IsTUFBQUEsQ0FBQyxHQUFHLENBQUo7O0FBRUEybEMsTUFBQUEsU0FBUyxDQUFDcmxDLE9BQVYsQ0FBa0IsVUFBVW1nQixDQUFWLEVBQWE7QUFDN0IsZUFBT0EsQ0FBQyxDQUFDd2YsUUFBRixLQUFlamxDLElBQUksQ0FBQ2lsQyxRQUFwQixLQUFpQ2pnQyxDQUFDLEdBQUcsQ0FBckMsQ0FBUDtBQUNELE9BRkQ7O0FBSUFBLE1BQUFBLENBQUMsS0FBS2hGLElBQUksQ0FBQzZJLE1BQUwsQ0FBWXVqQyxHQUFaLEdBQWtCLENBQXZCLENBQUQ7O0FBRUEsVUFBSXRHLFNBQUosRUFBZTtBQUNiQSxRQUFBQSxTQUFTLENBQUNpTyxhQUFWLEdBQTBCLElBQTFCO0FBQ0E3SCxRQUFBQSxNQUFNLElBQUlwRyxTQUFTLENBQUN2dEIsTUFBVixDQUFpQixDQUFDLENBQWxCLENBQVY7QUFDQXUvQixRQUFBQSxjQUFjLElBQUloUyxTQUFTLENBQUNob0IsSUFBVixFQUFsQjtBQUNEOztBQUVENnpCLE1BQUFBLFdBQVcsSUFBSSxDQUFDQSxXQUFELEVBQWNDLFNBQWQsRUFBeUJDLGtCQUF6QixFQUE2Q0MsZ0JBQTdDLEVBQStEeHNDLE9BQS9ELENBQXVFLFVBQVVtZCxDQUFWLEVBQWE7QUFDakcsZUFBT0EsQ0FBQyxDQUFDbGEsVUFBRixJQUFnQmthLENBQUMsQ0FBQ2xhLFVBQUYsQ0FBYWdKLFdBQWIsQ0FBeUJrUixDQUF6QixDQUF2QjtBQUNELE9BRmMsQ0FBZjtBQUdBcXFCLE1BQUFBLFFBQVEsS0FBSzlzQyxJQUFiLEtBQXNCOHNDLFFBQVEsR0FBRyxDQUFqQzs7QUFFQSxVQUFJTSxHQUFKLEVBQVM7QUFDUG1FLFFBQUFBLFFBQVEsS0FBS0EsUUFBUSxDQUFDNTNCLE9BQVQsR0FBbUIsQ0FBeEIsQ0FBUjtBQUNBM1UsUUFBQUEsQ0FBQyxHQUFHLENBQUo7O0FBRUEybEMsUUFBQUEsU0FBUyxDQUFDcmxDLE9BQVYsQ0FBa0IsVUFBVW1nQixDQUFWLEVBQWE7QUFDN0IsaUJBQU9BLENBQUMsQ0FBQzJuQixHQUFGLEtBQVVBLEdBQVYsSUFBaUJwb0MsQ0FBQyxFQUF6QjtBQUNELFNBRkQ7O0FBSUFBLFFBQUFBLENBQUMsS0FBS3VzQyxRQUFRLENBQUNsRSxNQUFULEdBQWtCLENBQXZCLENBQUQsQ0FSTyxDQVFxQjtBQUM3Qjs7QUFFRG5pQyxNQUFBQSxJQUFJLENBQUM2RixNQUFMLElBQWU3RixJQUFJLENBQUM2RixNQUFMLENBQVkvUSxJQUFaLENBQWY7QUFDRCxLQTFDRDs7QUE0Q0FBLElBQUFBLElBQUksQ0FBQ3dSLE1BQUwsQ0FBWSxLQUFaLEVBQW1CLEtBQW5CO0FBQ0E2aEMsSUFBQUEsa0JBQWtCLElBQUlBLGtCQUFrQixDQUFDcnpDLElBQUQsQ0FBeEM7QUFDQSxLQUFDOGxDLFNBQUQsSUFBYyxDQUFDQSxTQUFTLENBQUNuZ0MsR0FBekIsSUFBZ0Nxc0MsTUFBaEMsR0FBeUNoeUMsSUFBSSxDQUFDeXNDLE9BQUwsRUFBekMsR0FBMEQ3ckMsa0JBQUksQ0FBQ21mLFdBQUwsQ0FBaUIsSUFBakIsRUFBdUIsWUFBWTtBQUMzRixhQUFPMUQsS0FBSyxJQUFJck8sR0FBVCxJQUFnQmhPLElBQUksQ0FBQ3lzQyxPQUFMLEVBQXZCO0FBQ0QsS0FGeUQsTUFFbkR1RixNQUFNLEdBQUcsSUFGMEMsTUFFaEMzMUIsS0FBSyxHQUFHck8sR0FBRyxHQUFHLENBRmtCLENBQTFELENBOTBCMkMsQ0FnMUJDO0FBQzdDLEdBajFCRDs7QUFtMUJBeXNCLEVBQUFBLGFBQWEsQ0FBQ3BYLFFBQWQsR0FBeUIsU0FBU0EsUUFBVCxDQUFrQmpOLElBQWxCLEVBQXdCO0FBQy9DLFFBQUksQ0FBQ2pWLHlCQUFMLEVBQW1CO0FBQ2pCUCxNQUFBQSxrQkFBSSxHQUFHd1YsSUFBSSxJQUFJblUscUJBQVEsRUFBdkI7QUFDQUYsTUFBQUEsYUFBYSxNQUFNQyxNQUFNLENBQUN1TixRQUExQixJQUFzQ2tyQixhQUFhLENBQUNqcEIsTUFBZCxFQUF0QztBQUNBclEsTUFBQUEseUJBQVksR0FBR3dqQyxRQUFmO0FBQ0Q7O0FBRUQsV0FBT3hqQyx5QkFBUDtBQUNELEdBUkQ7O0FBVUFzNUIsRUFBQUEsYUFBYSxDQUFDNTFCLFFBQWQsR0FBeUIsU0FBU0EsUUFBVCxDQUFrQmc0QixNQUFsQixFQUEwQjtBQUNqRCxRQUFJQSxNQUFKLEVBQVk7QUFDVixXQUFLLElBQUlsNEIsQ0FBVCxJQUFjazRCLE1BQWQsRUFBc0I7QUFDcEJtTSxRQUFBQSxTQUFTLENBQUNya0MsQ0FBRCxDQUFULEdBQWVrNEIsTUFBTSxDQUFDbDRCLENBQUQsQ0FBckI7QUFDRDtBQUNGOztBQUVELFdBQU9xa0MsU0FBUDtBQUNELEdBUkQ7O0FBVUF2TyxFQUFBQSxhQUFhLENBQUNycEIsT0FBZCxHQUF3QixTQUFTQSxPQUFULENBQWlCb3NCLEtBQWpCLEVBQXdCMWYsSUFBeEIsRUFBOEI7QUFDcEQ2bUIsSUFBQUEsUUFBUSxHQUFHLENBQVg7O0FBRUFnRyxJQUFBQSxTQUFTLENBQUNybEMsT0FBVixDQUFrQixVQUFVZ1EsT0FBVixFQUFtQjtBQUNuQyxhQUFPQSxPQUFPLENBQUN3SSxJQUFJLEdBQUcsTUFBSCxHQUFZLFNBQWpCLENBQVAsQ0FBbUMwZixLQUFuQyxDQUFQO0FBQ0QsS0FGRDs7QUFJQTMyQixJQUFBQSw0QkFBZSxDQUFDaEcsaUJBQUQsRUFBTyxPQUFQLEVBQWdCZzdCLHNCQUFoQixDQUFmOztBQUVBaDFCLElBQUFBLDRCQUFlLENBQUMvRixpQkFBRCxFQUFPLFFBQVAsRUFBaUIrNkIsc0JBQWpCLENBQWY7O0FBRUFrYyxJQUFBQSxhQUFhLENBQUNyVSxhQUFELENBQWI7O0FBRUE3OEIsSUFBQUEsNEJBQWUsQ0FBQy9GLGlCQUFELEVBQU8sYUFBUCxFQUFzQis1Qix5QkFBdEIsQ0FBZjs7QUFFQWgwQixJQUFBQSw0QkFBZSxDQUFDN0Ysa0JBQUQsRUFBUSxZQUFSLEVBQXNCNjVCLHlCQUF0QixDQUFmOztBQUVBeU4sSUFBQUEsY0FBYyxDQUFDemhDLDRCQUFELEVBQWtCL0YsaUJBQWxCLEVBQXdCLGtDQUF4QixFQUE0RDhqQyxtQkFBNUQsQ0FBZDs7QUFFQTBELElBQUFBLGNBQWMsQ0FBQ3poQyw0QkFBRCxFQUFrQi9GLGlCQUFsQixFQUF3Qiw0QkFBeEIsRUFBc0QrakMsaUJBQXRELENBQWQ7O0FBRUFyQixJQUFBQSxZQUFZLENBQUMxbEIsSUFBYjs7QUFFQXVuQixJQUFBQSxtQkFBbUIsQ0FBQ3grQiw0QkFBRCxDQUFuQjs7QUFFQSxTQUFLLElBQUk3QixDQUFDLEdBQUcsQ0FBYixFQUFnQkEsQ0FBQyxHQUFHZzJCLGlCQUFwQixFQUF1Q2gyQixDQUFDLElBQUksQ0FBNUMsRUFBK0M7QUFDN0N1akMsTUFBQUEsY0FBYyxDQUFDMWhDLDRCQUFELEVBQWtCbTBCLFVBQVUsQ0FBQ2gyQixDQUFELENBQTVCLEVBQWlDZzJCLFVBQVUsQ0FBQ2gyQixDQUFDLEdBQUcsQ0FBTCxDQUEzQyxDQUFkOztBQUVBdWpDLE1BQUFBLGNBQWMsQ0FBQzFoQyw0QkFBRCxFQUFrQm0wQixVQUFVLENBQUNoMkIsQ0FBRCxDQUE1QixFQUFpQ2cyQixVQUFVLENBQUNoMkIsQ0FBQyxHQUFHLENBQUwsQ0FBM0MsQ0FBZDtBQUNEO0FBQ0YsR0E5QkQ7O0FBZ0NBeTFCLEVBQUFBLGFBQWEsQ0FBQ2pwQixNQUFkLEdBQXVCLFNBQVNBLE1BQVQsR0FBa0I7QUFDdkMzUSxJQUFBQSxpQkFBSSxHQUFHbUIsTUFBUDtBQUNBbEIsSUFBQUEsaUJBQUksR0FBR3lPLFFBQVA7QUFDQStxQixJQUFBQSxtQkFBTSxHQUFHeDVCLGlCQUFJLENBQUNpSCxlQUFkO0FBQ0EvRyxJQUFBQSxrQkFBSyxHQUFHRixpQkFBSSxDQUFDa0gsSUFBYjs7QUFFQSxRQUFJcEgsa0JBQUosRUFBVTtBQUNSUyxNQUFBQSxRQUFRLEdBQUdULGtCQUFJLENBQUN3TyxLQUFMLENBQVdDLE9BQXRCO0FBQ0FnckIsTUFBQUEsbUJBQU0sR0FBR3o1QixrQkFBSSxDQUFDd08sS0FBTCxDQUFXNnVCLEtBQXBCO0FBQ0FpRyxNQUFBQSxtQkFBbUIsR0FBR3RqQyxrQkFBSSxDQUFDd1YsSUFBTCxDQUFVNGhDLGtCQUFWLElBQWdDbmQseUJBQXREO0FBQ0FqNkIsTUFBQUEsa0JBQUksQ0FBQ3dWLElBQUwsQ0FBVTRuQixPQUFWLENBQWtCLGVBQWxCLEVBQW1DdkQsYUFBbkMsRUFKUSxDQUkyQzs7QUFFbkQsVUFBSXo1QixrQkFBSixFQUFXO0FBQ1QyakMsUUFBQUEsUUFBUSxHQUFHLENBQVg7QUFDQXpHLFFBQUFBLGlCQUFBLENBQWtCdDlCLGtCQUFsQixFQUZTLENBRWdCOztBQUV6QjY1QixRQUFBQSxhQUFhLENBQUMwRCxPQUFkLEdBQXdCRCxnQkFBeEI7QUFDQXFHLFFBQUFBLFVBQVUsR0FBR3JHLGdCQUFBLElBQW9CLDBCQUEwQjV2QixJQUExQixDQUErQjhELFNBQVMsQ0FBQ0ksU0FBekMsQ0FBakMsQ0FMUyxDQUs2RTs7QUFFdEZqTSxRQUFBQSx5QkFBWSxDQUFDMUYsaUJBQUQsRUFBTyxPQUFQLEVBQWdCZzdCLHNCQUFoQixDQUFaLENBUFMsQ0FPK0I7OztBQUd4Q25CLFFBQUFBLGtCQUFLLEdBQUcsQ0FBQzc1QixpQkFBRCxFQUFPQyxpQkFBUCxFQUFhdzVCLG1CQUFiLEVBQXFCdDVCLGtCQUFyQixDQUFSO0FBQ0F5NUIsUUFBQUEsYUFBYSxDQUFDMkQsVUFBZCxDQUF5QjtBQUN2QjtBQUNBLHFDQUEyQixTQUFTNlosbUJBQVQsR0FBK0I7QUFDeERoTixZQUFBQSxrQkFBa0I7O0FBRWxCLG1CQUFPQSxrQkFBUDtBQUNEO0FBTnNCLFNBQXpCOztBQVNBMWtDLFFBQUFBLHlCQUFZLENBQUN6RixpQkFBRCxFQUFPLFFBQVAsRUFBaUIrNkIsc0JBQWpCLENBQVosQ0FwQlMsQ0FvQmdDOzs7QUFHekMsWUFBSXFjLFNBQVMsR0FBR2wzQyxrQkFBSyxDQUFDdUMsS0FBdEI7QUFBQSxZQUNJNDBDLE1BQU0sR0FBR0QsU0FBUyxDQUFDRSxjQUR2QjtBQUFBLFlBRUkxOUIsTUFGSjtBQUFBLFlBR0kxVixDQUhKO0FBSUFrekMsUUFBQUEsU0FBUyxDQUFDRSxjQUFWLEdBQTJCLE9BQTNCLENBM0JTLENBMkIyQjs7QUFFcEMxOUIsUUFBQUEsTUFBTSxHQUFHaFAsVUFBVSxDQUFDMUssa0JBQUQsQ0FBbkI7QUFDQTA3QixRQUFBQSxXQUFBLEdBQWMvNUIsSUFBSSxDQUFDQyxLQUFMLENBQVc4WCxNQUFNLENBQUN4USxHQUFQLEdBQWF3eUIsWUFBQSxFQUF4QixLQUEyQyxDQUF6RCxDQTlCUyxDQThCbUQ7O0FBRTVESixRQUFBQSxhQUFBLEdBQWdCMzVCLElBQUksQ0FBQ0MsS0FBTCxDQUFXOFgsTUFBTSxDQUFDelEsSUFBUCxHQUFjcXlCLGNBQUEsRUFBekIsS0FBOEMsQ0FBOUQ7QUFDQTZiLFFBQUFBLE1BQU0sR0FBR0QsU0FBUyxDQUFDRSxjQUFWLEdBQTJCRCxNQUE5QixHQUF1Q0QsU0FBUyxDQUFDOXlDLGNBQVYsQ0FBeUIsa0JBQXpCLENBQTdDLENBakNTLENBaUNrRjs7QUFFM0ZzK0IsUUFBQUEsYUFBYSxHQUFHMlUsV0FBVyxDQUFDdk4sS0FBRCxFQUFRLEdBQVIsQ0FBM0I7QUFDQWxxQyxRQUFBQSxrQkFBSSxDQUFDbWYsV0FBTCxDQUFpQixHQUFqQixFQUFzQixZQUFZO0FBQ2hDLGlCQUFPK2EscUJBQVEsR0FBRyxDQUFsQjtBQUNELFNBRkQ7O0FBSUF2MEIsUUFBQUEseUJBQVksQ0FBQ3pGLGlCQUFELEVBQU8sYUFBUCxFQUFzQis1Qix5QkFBdEIsQ0FBWixDQXhDUyxDQXdDd0M7OztBQUdqRHQwQixRQUFBQSx5QkFBWSxDQUFDdkYsa0JBQUQsRUFBUSxZQUFSLEVBQXNCNjVCLHlCQUF0QixDQUFaLENBM0NTLENBMkN3Qzs7O0FBR2pEeU4sUUFBQUEsY0FBYyxDQUFDL2hDLHlCQUFELEVBQWV6RixpQkFBZixFQUFxQixrQ0FBckIsRUFBeUQ4akMsbUJBQXpELENBQWQ7O0FBRUEwRCxRQUFBQSxjQUFjLENBQUMvaEMseUJBQUQsRUFBZXpGLGlCQUFmLEVBQXFCLDRCQUFyQixFQUFtRCtqQyxpQkFBbkQsQ0FBZDs7QUFFQXJpQyxRQUFBQSxjQUFjLEdBQUc1QixrQkFBSSxDQUFDd08sS0FBTCxDQUFXd0UsV0FBWCxDQUF1QixXQUF2QixDQUFqQjs7QUFFQXM1QixRQUFBQSxXQUFXLENBQUN6bkMsSUFBWixDQUFpQmpELGNBQWpCOztBQUVBckIsUUFBQUEseUJBQVksR0FBR3lDLHFCQUFRLEVBQXZCO0FBQ0E0L0IsUUFBQUEsWUFBWSxHQUFHNWlDLGtCQUFJLENBQUNtZixXQUFMLENBQWlCLEdBQWpCLEVBQXNCK3JCLFdBQXRCLEVBQW1DcEssS0FBbkMsRUFBZjtBQUNBc0MsUUFBQUEsWUFBWSxHQUFHLENBQUNsakMsaUJBQUQsRUFBTyxrQkFBUCxFQUEyQixZQUFZO0FBQ3BELGNBQUkrbkIsQ0FBQyxHQUFHaG9CLGlCQUFJLENBQUN5SixVQUFiO0FBQUEsY0FDSXdlLENBQUMsR0FBR2pvQixpQkFBSSxDQUFDNEosV0FEYjs7QUFHQSxjQUFJM0osaUJBQUksQ0FBQ3czQyxNQUFULEVBQWlCO0FBQ2Z4VSxZQUFBQSxVQUFVLEdBQUdqYixDQUFiO0FBQ0FrYixZQUFBQSxXQUFXLEdBQUdqYixDQUFkO0FBQ0QsV0FIRCxNQUdPLElBQUlnYixVQUFVLEtBQUtqYixDQUFmLElBQW9Ca2IsV0FBVyxLQUFLamIsQ0FBeEMsRUFBMkM7QUFDaERvaUIsWUFBQUEsU0FBUztBQUNWO0FBQ0YsU0FWYyxFQVVacHFDLGlCQVZZLEVBVU4sa0JBVk0sRUFVY2dyQyxXQVZkLEVBVTJCanJDLGlCQVYzQixFQVVpQyxNQVZqQyxFQVV5Q2lyQyxXQVZ6QyxFQVVzRGpyQyxpQkFWdEQsRUFVNEQsUUFWNUQsRUFVc0VxcUMsU0FWdEUsQ0FBZjs7QUFZQTdGLFFBQUFBLG1CQUFtQixDQUFDOStCLHlCQUFELENBQW5COztBQUVBb2tDLFFBQUFBLFNBQVMsQ0FBQ3JsQyxPQUFWLENBQWtCLFVBQVVnUSxPQUFWLEVBQW1CO0FBQ25DLGlCQUFPQSxPQUFPLENBQUM5RCxNQUFSLENBQWUsQ0FBZixFQUFrQixDQUFsQixDQUFQO0FBQ0QsU0FGRDs7QUFJQSxhQUFLeE0sQ0FBQyxHQUFHLENBQVQsRUFBWUEsQ0FBQyxHQUFHZzJCLGlCQUFoQixFQUFtQ2gyQixDQUFDLElBQUksQ0FBeEMsRUFBMkM7QUFDekN1akMsVUFBQUEsY0FBYyxDQUFDMWhDLDRCQUFELEVBQWtCbTBCLFVBQVUsQ0FBQ2gyQixDQUFELENBQTVCLEVBQWlDZzJCLFVBQVUsQ0FBQ2gyQixDQUFDLEdBQUcsQ0FBTCxDQUEzQyxDQUFkOztBQUVBdWpDLFVBQUFBLGNBQWMsQ0FBQzFoQyw0QkFBRCxFQUFrQm0wQixVQUFVLENBQUNoMkIsQ0FBRCxDQUE1QixFQUFpQ2cyQixVQUFVLENBQUNoMkIsQ0FBQyxHQUFHLENBQUwsQ0FBM0MsQ0FBZDtBQUNEO0FBQ0Y7QUFDRjtBQUNGLEdBN0ZEOztBQStGQXkxQixFQUFBQSxhQUFhLENBQUNvQyxNQUFkLEdBQXVCLFNBQVNBLE1BQVQsQ0FBZ0IzeEIsSUFBaEIsRUFBc0I7QUFDM0Msd0JBQW9CQSxJQUFwQixLQUE2QnM1QixlQUFlLEdBQUcsQ0FBQyxDQUFDdDVCLElBQUksQ0FBQ3F0QyxjQUF0RDtBQUNBLFFBQUlDLEVBQUUsR0FBR3R0QyxJQUFJLENBQUN1dEMsWUFBZDtBQUNBRCxJQUFBQSxFQUFFLElBQUlULGFBQWEsQ0FBQ3JVLGFBQUQsQ0FBbkIsSUFBc0MsQ0FBQ0EsYUFBYSxHQUFHOFUsRUFBakIsS0FBd0JILFdBQVcsQ0FBQ3ZOLEtBQUQsRUFBUTBOLEVBQVIsQ0FBekU7QUFDQSw0QkFBd0J0dEMsSUFBeEIsS0FBaUNrNUIsbUJBQW1CLEdBQUczSixhQUFhLENBQUMwRCxPQUFkLEtBQTBCLENBQTFCLElBQStCanpCLElBQUksQ0FBQ3d0QyxrQkFBM0Y7O0FBRUEsUUFBSSx1QkFBdUJ4dEMsSUFBM0IsRUFBaUM7QUFDL0JtNkIsTUFBQUEsbUJBQW1CLENBQUN4K0IsNEJBQUQsQ0FBbkIsSUFBd0N3K0IsbUJBQW1CLENBQUM5K0IseUJBQUQsRUFBZTJFLElBQUksQ0FBQ3l0QyxpQkFBTCxJQUEwQixNQUF6QyxDQUEzRDtBQUNBeFUsTUFBQUEsYUFBYSxHQUFHLENBQUNqNUIsSUFBSSxDQUFDeXRDLGlCQUFMLEdBQXlCLEVBQTFCLEVBQThCbG1DLE9BQTlCLENBQXNDLFFBQXRDLE1BQW9ELENBQUMsQ0FBckU7QUFDRDtBQUNGLEdBVkQ7O0FBWUFnb0IsRUFBQUEsYUFBYSxDQUFDbWUsYUFBZCxHQUE4QixTQUFTQSxhQUFULENBQXVCbnhDLE1BQXZCLEVBQStCeUQsSUFBL0IsRUFBcUM7QUFDakUsUUFBSXVhLENBQUMsR0FBR21YLFVBQVUsQ0FBQ24xQixNQUFELENBQWxCO0FBQUEsUUFDSXpDLENBQUMsR0FBR2cyQixrQkFBQSxDQUFtQnZWLENBQW5CLENBRFI7QUFBQSxRQUVJd2IsVUFBVSxHQUFHekYsd0JBQVcsQ0FBQy9WLENBQUQsQ0FGNUI7O0FBSUEsUUFBSSxDQUFDemdCLENBQUwsRUFBUTtBQUNOZzJCLE1BQUFBLGlCQUFBLENBQWtCaDJCLENBQWxCLEVBQXFCaThCLFVBQVUsR0FBRyxDQUFILEdBQU8sQ0FBdEM7QUFDRDs7QUFFRCxRQUFJLzFCLElBQUosRUFBVTtBQUNSKzFCLE1BQUFBLFVBQVUsR0FBR2hHLGdCQUFBLENBQWlCcDZCLGlCQUFqQixFQUF1QnFLLElBQXZCLEVBQTZCbEssa0JBQTdCLEVBQW9Da0ssSUFBcEMsRUFBMENvdkIsbUJBQTFDLEVBQWtEcHZCLElBQWxELENBQUgsR0FBNkQrdkIsZ0JBQUEsQ0FBaUJ4VixDQUFqQixFQUFvQnZhLElBQXBCLENBQXZFO0FBQ0Q7QUFDRixHQVpEOztBQWNBdXZCLEVBQUFBLGFBQWEsQ0FBQzJELFVBQWQsR0FBMkIsU0FBU0EsVUFBVCxDQUFvQmx6QixJQUFwQixFQUEwQjtBQUNuRDtBQUNBLFFBQUkydEMsRUFBSixFQUFRbDBDLENBQVIsRUFBV0ssQ0FBWCxFQUFjTyxJQUFkLEVBQW9COEYsTUFBcEI7O0FBRUEsU0FBSzFHLENBQUwsSUFBVXVHLElBQVYsRUFBZ0I7QUFDZGxHLE1BQUFBLENBQUMsR0FBR3NtQyxNQUFNLENBQUM3NEIsT0FBUCxDQUFlOU4sQ0FBZixDQUFKO0FBQ0FZLE1BQUFBLElBQUksR0FBRzJGLElBQUksQ0FBQ3ZHLENBQUQsQ0FBWDtBQUNBNG1DLE1BQUFBLGNBQWMsR0FBRzVtQyxDQUFqQjs7QUFFQSxVQUFJQSxDQUFDLEtBQUssS0FBVixFQUFpQjtBQUNmWSxRQUFBQSxJQUFJO0FBQ0wsT0FGRCxNQUVPO0FBQ0xzekMsUUFBQUEsRUFBRSxHQUFHaDRDLGlCQUFJLENBQUN1OUIsVUFBTCxDQUFnQno1QixDQUFoQixDQUFMOztBQUVBLFlBQUlrMEMsRUFBSixFQUFRO0FBQ05BLFVBQUFBLEVBQUUsQ0FBQ3hhLE9BQUgsS0FBZWh6QixNQUFNLEdBQUc5RixJQUFJLEVBQTVCOztBQUVBLGNBQUksQ0FBQ1AsQ0FBTCxFQUFRO0FBQ05zbUMsWUFBQUEsTUFBTSxDQUFDdG1DLENBQUMsR0FBRyxDQUFMLENBQU4sR0FBZ0J3Z0MsWUFBWSxDQUFDOEYsTUFBTSxDQUFDdG1DLENBQUMsR0FBRyxDQUFMLENBQVAsRUFBZ0JPLElBQWhCLENBQTVCO0FBQ0ErbEMsWUFBQUEsTUFBTSxDQUFDdG1DLENBQUMsR0FBRyxDQUFMLENBQU4sR0FBZ0J3Z0MsWUFBWSxDQUFDOEYsTUFBTSxDQUFDdG1DLENBQUMsR0FBRyxDQUFMLENBQVAsRUFBZ0JxRyxNQUFoQixDQUE1QjtBQUNELFdBSEQsTUFHTztBQUNMckcsWUFBQUEsQ0FBQyxHQUFHc21DLE1BQU0sQ0FBQ3JtQyxNQUFYOztBQUVBcW1DLFlBQUFBLE1BQU0sQ0FBQzdsQyxJQUFQLENBQVlkLENBQVosRUFBZVksSUFBZixFQUFxQjhGLE1BQXJCOztBQUVBd3RDLFlBQUFBLEVBQUUsQ0FBQ0MsV0FBSCxHQUFpQkQsRUFBRSxDQUFDQyxXQUFILENBQWVyTixjQUFmLENBQWpCLEdBQWtEb04sRUFBRSxDQUFDbnlDLGdCQUFILENBQW9CLFFBQXBCLEVBQThCK2tDLGNBQTlCLENBQWxEO0FBQ0Q7O0FBRURILFVBQUFBLE1BQU0sQ0FBQ3RtQyxDQUFDLEdBQUcsQ0FBTCxDQUFOLEdBQWdCNnpDLEVBQUUsQ0FBQ3hhLE9BQW5CO0FBQ0Q7QUFDRjs7QUFFRGtOLE1BQUFBLGNBQWMsR0FBRyxDQUFqQjtBQUNEOztBQUVELFdBQU9ELE1BQVA7QUFDRCxHQXBDRDs7QUFzQ0E3USxFQUFBQSxhQUFhLENBQUNzZSxlQUFkLEdBQWdDLFNBQVNBLGVBQVQsQ0FBeUJDLEtBQXpCLEVBQWdDO0FBQzlEQSxJQUFBQSxLQUFLLEtBQUsxTixNQUFNLENBQUNybUMsTUFBUCxHQUFnQixDQUFyQixDQUFMO0FBQ0ErekMsSUFBQUEsS0FBSyxHQUFHMU4sTUFBTSxDQUFDNzRCLE9BQVAsQ0FBZXVtQyxLQUFmLENBQVI7QUFDQUEsSUFBQUEsS0FBSyxJQUFJLENBQVQsSUFBYzFOLE1BQU0sQ0FBQ3ZsQyxNQUFQLENBQWNpekMsS0FBZCxFQUFxQixDQUFyQixDQUFkO0FBQ0QsR0FKRDs7QUFNQXZlLEVBQUFBLGFBQWEsQ0FBQ3dlLFlBQWQsR0FBNkIsU0FBU0EsWUFBVCxDQUFzQnp5QyxPQUF0QixFQUErQjBiLEtBQS9CLEVBQXNDcXVCLFVBQXRDLEVBQWtEO0FBQzdFLFFBQUk3MUIsTUFBTSxHQUFHLENBQUNvSyxTQUFTLENBQUN0ZSxPQUFELENBQVQsR0FBcUJvMkIsVUFBVSxDQUFDcDJCLE9BQUQsQ0FBL0IsR0FBMkNBLE9BQTVDLEVBQXFEdUUscUJBQXJELEVBQWI7QUFBQSxRQUNJYSxNQUFNLEdBQUc4TyxNQUFNLENBQUM2MUIsVUFBVSxHQUFHakssTUFBSCxHQUFZQyxPQUF2QixDQUFOLEdBQXdDcmtCLEtBQXhDLElBQWlELENBRDlEO0FBRUEsV0FBT3F1QixVQUFVLEdBQUc3MUIsTUFBTSxDQUFDdFEsS0FBUCxHQUFld0IsTUFBZixHQUF3QixDQUF4QixJQUE2QjhPLE1BQU0sQ0FBQ3pRLElBQVAsR0FBYzJCLE1BQWQsR0FBdUIvSyxpQkFBSSxDQUFDeUosVUFBNUQsR0FBeUVvUSxNQUFNLENBQUNsUSxNQUFQLEdBQWdCb0IsTUFBaEIsR0FBeUIsQ0FBekIsSUFBOEI4TyxNQUFNLENBQUN4USxHQUFQLEdBQWEwQixNQUFiLEdBQXNCL0ssaUJBQUksQ0FBQzRKLFdBQW5KO0FBQ0QsR0FKRDs7QUFNQWd3QixFQUFBQSxhQUFhLENBQUN5ZSxrQkFBZCxHQUFtQyxTQUFTQSxrQkFBVCxDQUE0QjF5QyxPQUE1QixFQUFxQzJ5QyxjQUFyQyxFQUFxRDVJLFVBQXJELEVBQWlFO0FBQ2xHenJCLElBQUFBLFNBQVMsQ0FBQ3RlLE9BQUQsQ0FBVCxLQUF1QkEsT0FBTyxHQUFHbzJCLFVBQVUsQ0FBQ3AyQixPQUFELENBQTNDO0FBQ0EsUUFBSWtVLE1BQU0sR0FBR2xVLE9BQU8sQ0FBQ3VFLHFCQUFSLEVBQWI7QUFBQSxRQUNJdStCLElBQUksR0FBRzV1QixNQUFNLENBQUM2MUIsVUFBVSxHQUFHakssTUFBSCxHQUFZQyxPQUF2QixDQURqQjtBQUFBLFFBRUkzNkIsTUFBTSxHQUFHdXRDLGNBQWMsSUFBSSxJQUFsQixHQUF5QjdQLElBQUksR0FBRyxDQUFoQyxHQUFvQzZQLGNBQWMsSUFBSWhRLFNBQWxCLEdBQThCQSxTQUFTLENBQUNnUSxjQUFELENBQVQsR0FBNEI3UCxJQUExRCxHQUFpRSxDQUFDNlAsY0FBYyxDQUFDMW1DLE9BQWYsQ0FBdUIsR0FBdkIsQ0FBRCxHQUErQnJGLFVBQVUsQ0FBQytyQyxjQUFELENBQVYsR0FBNkI3UCxJQUE3QixHQUFvQyxHQUFuRSxHQUF5RWw4QixVQUFVLENBQUMrckMsY0FBRCxDQUFWLElBQThCLENBRnpOO0FBR0EsV0FBTzVJLFVBQVUsR0FBRyxDQUFDNzFCLE1BQU0sQ0FBQ3pRLElBQVAsR0FBYzJCLE1BQWYsSUFBeUIvSyxpQkFBSSxDQUFDeUosVUFBakMsR0FBOEMsQ0FBQ29RLE1BQU0sQ0FBQ3hRLEdBQVAsR0FBYTBCLE1BQWQsSUFBd0IvSyxpQkFBSSxDQUFDNEosV0FBNUY7QUFDRCxHQU5EOztBQVFBLFNBQU9nd0IsYUFBUDtBQUNELENBbmtDdUMsRUFBakM7QUFva0NQQSwyQkFBYSxDQUFDM1csT0FBZCxHQUF3QixRQUF4Qjs7QUFFQTJXLDJCQUFhLENBQUMyZSxVQUFkLEdBQTJCLFVBQVU5MUIsT0FBVixFQUFtQjtBQUM1QyxTQUFPQSxPQUFPLEdBQUdqaUIsUUFBUSxDQUFDaWlCLE9BQUQsQ0FBUixDQUFrQmhlLE9BQWxCLENBQTBCLFVBQVVtQyxNQUFWLEVBQWtCO0FBQzNEO0FBQ0EsUUFBSUEsTUFBTSxJQUFJQSxNQUFNLENBQUNsRSxLQUFyQixFQUE0QjtBQUMxQixVQUFJeUIsQ0FBQyxHQUFHZ25DLFlBQVksQ0FBQ3Y1QixPQUFiLENBQXFCaEwsTUFBckIsQ0FBUjs7QUFFQXpDLE1BQUFBLENBQUMsSUFBSSxDQUFMLElBQVVnbkMsWUFBWSxDQUFDam1DLE1BQWIsQ0FBb0JmLENBQXBCLEVBQXVCLENBQXZCLENBQVY7O0FBRUFnbkMsTUFBQUEsWUFBWSxDQUFDdm1DLElBQWIsQ0FBa0JnQyxNQUFsQixFQUEwQkEsTUFBTSxDQUFDbEUsS0FBUCxDQUFhK08sT0FBdkMsRUFBZ0Q3SyxNQUFNLENBQUM4RSxPQUFQLElBQWtCOUUsTUFBTSxDQUFDMkcsWUFBUCxDQUFvQixXQUFwQixDQUFsRSxFQUFvR3hOLGtCQUFJLENBQUN3VixJQUFMLENBQVVDLFFBQVYsQ0FBbUI1TyxNQUFuQixDQUFwRyxFQUFnSThqQyxjQUFoSTtBQUNEO0FBQ0YsR0FUZ0IsQ0FBSCxHQVNUUyxZQVRMO0FBVUQsQ0FYRDs7QUFhQXZSLDJCQUFhLENBQUN5UixNQUFkLEdBQXVCLFVBQVVzSixJQUFWLEVBQWdCdkosS0FBaEIsRUFBdUI7QUFDNUMsU0FBT0wsVUFBVSxDQUFDLENBQUM0SixJQUFGLEVBQVF2SixLQUFSLENBQWpCO0FBQ0QsQ0FGRDs7QUFJQXhSLDJCQUFhLENBQUNsNkIsTUFBZCxHQUF1QixVQUFVMkssSUFBVixFQUFnQjQ2QixTQUFoQixFQUEyQjtBQUNoRCxTQUFPLElBQUlyTCwyQkFBSixDQUFrQnZ2QixJQUFsQixFQUF3QjQ2QixTQUF4QixDQUFQO0FBQ0QsQ0FGRDs7QUFJQXJMLDJCQUFhLENBQUNnUyxPQUFkLEdBQXdCLFVBQVU0TSxJQUFWLEVBQWdCO0FBQ3RDLFNBQU9BLElBQUksR0FBR25PLFNBQVMsRUFBWixHQUFpQixDQUFDL3BDLHlCQUFZLElBQUlzNUIsMkJBQWEsQ0FBQ3BYLFFBQWQsRUFBakIsS0FBOEN5b0IsV0FBVyxDQUFDLElBQUQsQ0FBckY7QUFDRCxDQUZEOztBQUlBclIsMkJBQWEsQ0FBQ2xZLE1BQWQsR0FBdUJ3b0IsVUFBdkI7QUFDQXRRLDJCQUFhLENBQUM2ZSxpQkFBZCxHQUFrQ25OLGtCQUFsQzs7QUFFQTFSLDJCQUFhLENBQUM4ZSxTQUFkLEdBQTBCLFVBQVUveUMsT0FBVixFQUFtQitwQyxVQUFuQixFQUErQjtBQUN2RCxTQUFPcEwsVUFBVSxDQUFDMytCLE9BQUQsRUFBVStwQyxVQUFVLEdBQUdqVSxXQUFILEdBQWlCSSxTQUFyQyxDQUFqQjtBQUNELENBRkQ7O0FBSUFqQywyQkFBYSxDQUFDK2UsYUFBZCxHQUE4QixVQUFVaHpDLE9BQVYsRUFBbUIrcEMsVUFBbkIsRUFBK0I7QUFDM0QsU0FBT3hULGNBQWMsQ0FBQ0gsVUFBVSxDQUFDcDJCLE9BQUQsQ0FBWCxFQUFzQitwQyxVQUFVLEdBQUdqVSxXQUFILEdBQWlCSSxTQUFqRCxDQUFyQjtBQUNELENBRkQ7O0FBSUFqQywyQkFBYSxDQUFDOEksT0FBZCxHQUF3QixVQUFVM2dCLEVBQVYsRUFBYztBQUNwQyxTQUFPZ29CLElBQUksQ0FBQ2hvQixFQUFELENBQVg7QUFDRCxDQUZEOztBQUlBNlgsMkJBQWEsQ0FBQzZJLE1BQWQsR0FBdUIsWUFBWTtBQUNqQyxTQUFPcUgsU0FBUyxDQUFDdkgsTUFBVixDQUFpQixVQUFVM2QsQ0FBVixFQUFhO0FBQ25DLFdBQU9BLENBQUMsQ0FBQ3ZhLElBQUYsQ0FBTzBYLEVBQVAsS0FBYyxnQkFBckI7QUFDRCxHQUZNLENBQVA7QUFHRCxDQUpELEVBSUc7OztBQUdINlgsMkJBQWEsQ0FBQ2dmLFdBQWQsR0FBNEIsWUFBWTtBQUN0QyxTQUFPLENBQUMsQ0FBQy9VLGVBQVQ7QUFDRCxDQUZEOztBQUlBakssMkJBQWEsQ0FBQ2lmLGVBQWQsR0FBZ0MxUixnQkFBaEM7O0FBRUF2TiwyQkFBYSxDQUFDL3pCLGdCQUFkLEdBQWlDLFVBQVV6RCxJQUFWLEVBQWdCb0YsUUFBaEIsRUFBMEI7QUFDekQsTUFBSXlGLENBQUMsR0FBRzFDLFVBQVUsQ0FBQ25JLElBQUQsQ0FBVixLQUFxQm1JLFVBQVUsQ0FBQ25JLElBQUQsQ0FBVixHQUFtQixFQUF4QyxDQUFSO0FBQ0EsR0FBQzZLLENBQUMsQ0FBQzJFLE9BQUYsQ0FBVXBLLFFBQVYsQ0FBRCxJQUF3QnlGLENBQUMsQ0FBQ3JJLElBQUYsQ0FBTzRDLFFBQVAsQ0FBeEI7QUFDRCxDQUhEOztBQUtBb3lCLDJCQUFhLENBQUMzekIsbUJBQWQsR0FBb0MsVUFBVTdELElBQVYsRUFBZ0JvRixRQUFoQixFQUEwQjtBQUM1RCxNQUFJeUYsQ0FBQyxHQUFHMUMsVUFBVSxDQUFDbkksSUFBRCxDQUFsQjtBQUFBLE1BQ0krQixDQUFDLEdBQUc4SSxDQUFDLElBQUlBLENBQUMsQ0FBQzJFLE9BQUYsQ0FBVXBLLFFBQVYsQ0FEYjtBQUVBckQsRUFBQUEsQ0FBQyxJQUFJLENBQUwsSUFBVThJLENBQUMsQ0FBQy9ILE1BQUYsQ0FBU2YsQ0FBVCxFQUFZLENBQVosQ0FBVjtBQUNELENBSkQ7O0FBTUF5MUIsMkJBQWEsQ0FBQ2tmLEtBQWQsR0FBc0IsVUFBVXIyQixPQUFWLEVBQW1CcFksSUFBbkIsRUFBeUI7QUFDN0MsTUFBSUcsTUFBTSxHQUFHLEVBQWI7QUFBQSxNQUNJdXVDLFFBQVEsR0FBRyxFQURmO0FBQUEsTUFFSUMsUUFBUSxHQUFHM3VDLElBQUksQ0FBQzJ1QyxRQUFMLElBQWlCLEtBRmhDO0FBQUEsTUFHSUMsUUFBUSxHQUFHNXVDLElBQUksQ0FBQzR1QyxRQUFMLElBQWlCLEdBSGhDO0FBQUEsTUFJSUMsYUFBYSxHQUFHLFNBQVNBLGFBQVQsQ0FBdUI5MkMsSUFBdkIsRUFBNkJvRixRQUE3QixFQUF1QztBQUN6RCxRQUFJdEQsUUFBUSxHQUFHLEVBQWY7QUFBQSxRQUNJc1EsUUFBUSxHQUFHLEVBRGY7QUFBQSxRQUVJblAsS0FBSyxHQUFHdEYsa0JBQUksQ0FBQ21mLFdBQUwsQ0FBaUI4NUIsUUFBakIsRUFBMkIsWUFBWTtBQUNqRHh4QyxNQUFBQSxRQUFRLENBQUN0RCxRQUFELEVBQVdzUSxRQUFYLENBQVI7QUFDQXRRLE1BQUFBLFFBQVEsR0FBRyxFQUFYO0FBQ0FzUSxNQUFBQSxRQUFRLEdBQUcsRUFBWDtBQUNELEtBSlcsRUFJVHFzQixLQUpTLEVBRlo7QUFPQSxXQUFPLFVBQVUxaEMsSUFBVixFQUFnQjtBQUNyQitFLE1BQUFBLFFBQVEsQ0FBQ0UsTUFBVCxJQUFtQmlCLEtBQUssQ0FBQ3E4QixPQUFOLENBQWMsSUFBZCxDQUFuQjtBQUNBeDlCLE1BQUFBLFFBQVEsQ0FBQ1UsSUFBVCxDQUFjekYsSUFBSSxDQUFDc1YsT0FBbkI7QUFDQUQsTUFBQUEsUUFBUSxDQUFDNVAsSUFBVCxDQUFjekYsSUFBZDtBQUNBODVDLE1BQUFBLFFBQVEsSUFBSS8wQyxRQUFRLENBQUNFLE1BQXJCLElBQStCaUIsS0FBSyxDQUFDa2YsUUFBTixDQUFlLENBQWYsQ0FBL0I7QUFDRCxLQUxEO0FBTUQsR0FsQkQ7QUFBQSxNQW1CSXpnQixDQW5CSjs7QUFxQkEsT0FBS0EsQ0FBTCxJQUFVdUcsSUFBVixFQUFnQjtBQUNkMHVDLElBQUFBLFFBQVEsQ0FBQ2oxQyxDQUFELENBQVIsR0FBY0EsQ0FBQyxDQUFDeXNCLE1BQUYsQ0FBUyxDQUFULEVBQVksQ0FBWixNQUFtQixJQUFuQixJQUEyQmp2QixXQUFXLENBQUMrSSxJQUFJLENBQUN2RyxDQUFELENBQUwsQ0FBdEMsSUFBbURBLENBQUMsS0FBSyxlQUF6RCxHQUEyRW8xQyxhQUFhLENBQUNwMUMsQ0FBRCxFQUFJdUcsSUFBSSxDQUFDdkcsQ0FBRCxDQUFSLENBQXhGLEdBQXVHdUcsSUFBSSxDQUFDdkcsQ0FBRCxDQUF6SDtBQUNEOztBQUVELE1BQUl4QyxXQUFXLENBQUMyM0MsUUFBRCxDQUFmLEVBQTJCO0FBQ3pCQSxJQUFBQSxRQUFRLEdBQUdBLFFBQVEsRUFBbkI7O0FBRUF2ekMsSUFBQUEseUJBQVksQ0FBQ2swQiwyQkFBRCxFQUFnQixTQUFoQixFQUEyQixZQUFZO0FBQ2pELGFBQU9xZixRQUFRLEdBQUc1dUMsSUFBSSxDQUFDNHVDLFFBQUwsRUFBbEI7QUFDRCxLQUZXLENBQVo7QUFHRDs7QUFFRHo0QyxFQUFBQSxRQUFRLENBQUNpaUIsT0FBRCxDQUFSLENBQWtCaGUsT0FBbEIsQ0FBMEIsVUFBVW1DLE1BQVYsRUFBa0I7QUFDMUMsUUFBSW8xQixNQUFNLEdBQUcsRUFBYjs7QUFFQSxTQUFLbDRCLENBQUwsSUFBVWkxQyxRQUFWLEVBQW9CO0FBQ2xCL2MsTUFBQUEsTUFBTSxDQUFDbDRCLENBQUQsQ0FBTixHQUFZaTFDLFFBQVEsQ0FBQ2oxQyxDQUFELENBQXBCO0FBQ0Q7O0FBRURrNEIsSUFBQUEsTUFBTSxDQUFDdm5CLE9BQVAsR0FBaUI3TixNQUFqQjtBQUNBNEQsSUFBQUEsTUFBTSxDQUFDNUYsSUFBUCxDQUFZZzFCLDJCQUFhLENBQUNsNkIsTUFBZCxDQUFxQnM4QixNQUFyQixDQUFaO0FBQ0QsR0FURDs7QUFXQSxTQUFPeHhCLE1BQVA7QUFDRCxDQTlDRCxFQThDRzs7O0FBR0gsSUFBSTJ1QyxvQ0FBb0MsR0FBRyxTQUFTQSxvQ0FBVCxDQUE4Q3hSLFVBQTlDLEVBQTBEcU0sT0FBMUQsRUFBbUU3bUMsR0FBbkUsRUFBd0VqRixHQUF4RSxFQUE2RTtBQUN0SDhyQyxFQUFBQSxPQUFPLEdBQUc5ckMsR0FBVixHQUFnQnkvQixVQUFVLENBQUN6L0IsR0FBRCxDQUExQixHQUFrQzhyQyxPQUFPLEdBQUcsQ0FBVixJQUFlck0sVUFBVSxDQUFDLENBQUQsQ0FBM0Q7QUFDQSxTQUFPeDZCLEdBQUcsR0FBR2pGLEdBQU4sR0FBWSxDQUFDQSxHQUFHLEdBQUc4ckMsT0FBUCxLQUFtQjdtQyxHQUFHLEdBQUc2bUMsT0FBekIsQ0FBWixHQUFnRDdtQyxHQUFHLEdBQUcsQ0FBTixHQUFVNm1DLE9BQU8sSUFBSUEsT0FBTyxHQUFHN21DLEdBQWQsQ0FBakIsR0FBc0MsQ0FBN0Y7QUFDRCxDQUhEO0FBQUEsSUFJSWlzQyxtQkFBbUIsR0FBRyxTQUFTQSxtQkFBVCxDQUE2Qnh5QyxNQUE3QixFQUFxQzBhLFNBQXJDLEVBQWdEO0FBQ3hFLE1BQUlBLFNBQVMsS0FBSyxJQUFsQixFQUF3QjtBQUN0QjFhLElBQUFBLE1BQU0sQ0FBQ2xFLEtBQVAsQ0FBYTZCLGNBQWIsQ0FBNEIsY0FBNUI7QUFDRCxHQUZELE1BRU87QUFDTHFDLElBQUFBLE1BQU0sQ0FBQ2xFLEtBQVAsQ0FBYTRCLFdBQWIsR0FBMkJnZCxTQUFTLEtBQUssSUFBZCxHQUFxQixNQUFyQixHQUE4QkEsU0FBUyxHQUFHLFNBQVNBLFNBQVQsSUFBc0IrYixnQkFBQSxHQUFtQixhQUFuQixHQUFtQyxFQUF6RCxDQUFILEdBQWtFLE1BQXBJLENBREssQ0FDdUk7QUFDN0k7O0FBRUR6MkIsRUFBQUEsTUFBTSxLQUFLNnlCLG1CQUFYLElBQXFCMmYsbUJBQW1CLENBQUNqNUMsa0JBQUQsRUFBUW1oQixTQUFSLENBQXhDO0FBQ0QsQ0FaRDtBQUFBLElBYUkrM0IsU0FBUyxHQUFHO0FBQ2RDLEVBQUFBLElBQUksRUFBRSxDQURRO0FBRWR0eEMsRUFBQUEsTUFBTSxFQUFFO0FBRk0sQ0FiaEI7QUFBQSxJQWlCSXV4QyxhQUFhLEdBQUcsU0FBU0EsYUFBVCxDQUF1QkMsS0FBdkIsRUFBOEI7QUFDaEQsTUFBSXJ6QyxLQUFLLEdBQUdxekMsS0FBSyxDQUFDcnpDLEtBQWxCO0FBQUEsTUFDSVMsTUFBTSxHQUFHNHlDLEtBQUssQ0FBQzV5QyxNQURuQjtBQUFBLE1BRUlrQixJQUFJLEdBQUcweEMsS0FBSyxDQUFDMXhDLElBRmpCOztBQUlBLE1BQUk2RyxJQUFJLEdBQUcsQ0FBQ3hJLEtBQUssQ0FBQzRXLGNBQU4sR0FBdUI1VyxLQUFLLENBQUM0VyxjQUFOLENBQXFCLENBQXJCLENBQXZCLEdBQWlENVcsS0FBbEQsRUFBeURTLE1BQXBFO0FBQUEsTUFDSWt3QixLQUFLLEdBQUdub0IsSUFBSSxDQUFDMkcsS0FBTCxJQUFjdlYsa0JBQUksQ0FBQ3dWLElBQUwsQ0FBVUMsUUFBVixDQUFtQjdHLElBQW5CLENBRDFCO0FBQUEsTUFFSW9SLElBQUksR0FBR2hkLHFCQUFRLEVBRm5CO0FBQUEsTUFHSW1KLEVBSEo7O0FBS0EsTUFBSSxDQUFDNHFCLEtBQUssQ0FBQzJpQixVQUFQLElBQXFCMTVCLElBQUksR0FBRytXLEtBQUssQ0FBQzJpQixVQUFiLEdBQTBCLElBQW5ELEVBQXlEO0FBQ3ZEO0FBQ0EsV0FBTzlxQyxJQUFJLElBQUlBLElBQUksQ0FBQ08sWUFBTCxJQUFxQlAsSUFBSSxDQUFDOUUsWUFBekMsRUFBdUQ7QUFDckQ4RSxNQUFBQSxJQUFJLEdBQUdBLElBQUksQ0FBQ2pILFVBQVo7QUFDRDs7QUFFRG92QixJQUFBQSxLQUFLLENBQUM0aUIsU0FBTixHQUFrQi9xQyxJQUFJLElBQUksQ0FBQ2dzQix3QkFBVyxDQUFDaHNCLElBQUQsQ0FBcEIsSUFBOEJBLElBQUksS0FBSy9ILE1BQXZDLEtBQWtEeXlDLFNBQVMsQ0FBQyxDQUFDbnRDLEVBQUUsR0FBR3BELGlCQUFpQixDQUFDNkYsSUFBRCxDQUF2QixFQUErQjJULFNBQWhDLENBQVQsSUFBdUQrMkIsU0FBUyxDQUFDbnRDLEVBQUUsQ0FBQ3FXLFNBQUosQ0FBbEgsQ0FBbEI7QUFDQXVVLElBQUFBLEtBQUssQ0FBQzJpQixVQUFOLEdBQW1CMTVCLElBQW5CO0FBQ0Q7O0FBRUQsR0FBQytXLEtBQUssQ0FBQzRpQixTQUFOLElBQW1CNXhDLElBQUksS0FBSyxHQUE3QixNQUFzQzNCLEtBQUssQ0FBQzYyQixVQUFOLEdBQW1CLElBQXpEO0FBQ0QsQ0F0Q0Q7QUFBQSxJQXVDSTtBQUNKMmMsY0FBYyxHQUFHLFNBQVNBLGNBQVQsQ0FBd0IveUMsTUFBeEIsRUFBZ0N4RSxJQUFoQyxFQUFzQ3czQyxNQUF0QyxFQUE4Q0MsTUFBOUMsRUFBc0Q7QUFDckUsU0FBT3hjLGVBQUEsQ0FBZ0I7QUFDckJ6MkIsSUFBQUEsTUFBTSxFQUFFQSxNQURhO0FBRXJCaEIsSUFBQUEsT0FBTyxFQUFFLElBRlk7QUFHckJrNEIsSUFBQUEsUUFBUSxFQUFFLEtBSFc7QUFJckJscUIsSUFBQUEsUUFBUSxFQUFFLElBSlc7QUFLckJ4UixJQUFBQSxJQUFJLEVBQUVBLElBTGU7QUFNckIrOEIsSUFBQUEsT0FBTyxFQUFFMGEsTUFBTSxHQUFHQSxNQUFNLElBQUlOLGFBTlA7QUFPckJoOUIsSUFBQUEsT0FBTyxFQUFFczlCLE1BUFk7QUFRckJ6OEIsSUFBQUEsTUFBTSxFQUFFeThCLE1BUmE7QUFTckJoWSxJQUFBQSxRQUFRLEVBQUVnWSxNQVRXO0FBVXJCemEsSUFBQUEsUUFBUSxFQUFFLFNBQVNBLFFBQVQsR0FBb0I7QUFDNUIsYUFBT3dhLE1BQU0sSUFBSWwwQyx5QkFBWSxDQUFDekYsaUJBQUQsRUFBT285QixzQkFBUCxFQUErQnljLGNBQS9CLEVBQStDLEtBQS9DLEVBQXNELElBQXRELENBQTdCO0FBQ0QsS0Fab0I7QUFhckJ6YSxJQUFBQSxTQUFTLEVBQUUsU0FBU0EsU0FBVCxHQUFxQjtBQUM5QixhQUFPcjVCLDRCQUFlLENBQUMvRixpQkFBRCxFQUFPbzlCLHNCQUFQLEVBQStCeWMsY0FBL0IsRUFBK0MsSUFBL0MsQ0FBdEI7QUFDRDtBQWZvQixHQUFoQixDQUFQO0FBaUJELENBMUREO0FBQUEsSUEyRElDLFNBQVMsR0FBRyxnQ0EzRGhCO0FBQUEsSUE0RElDLGVBNURKO0FBQUEsSUE2RElGLGNBQWMsR0FBRyxTQUFTQSxjQUFULENBQXdCeDNDLENBQXhCLEVBQTJCO0FBQzlDLE1BQUkyM0MsT0FBTyxHQUFHRixTQUFTLENBQUN0c0MsSUFBVixDQUFlbkwsQ0FBQyxDQUFDc0UsTUFBRixDQUFTK2dCLE9BQXhCLENBQWQ7O0FBRUEsTUFBSXN5QixPQUFPLElBQUlELGVBQWYsRUFBZ0M7QUFDOUIxM0MsSUFBQUEsQ0FBQyxDQUFDMDZCLFVBQUYsR0FBZSxJQUFmO0FBQ0FnZCxJQUFBQSxlQUFlLEdBQUdDLE9BQWxCO0FBQ0Q7QUFDRixDQXBFRDtBQUFBLElBcUVJQyxvQkFBb0IsR0FBRyxTQUFTQSxvQkFBVCxDQUE4Qjd2QyxJQUE5QixFQUFvQztBQUM3RDdJLEVBQUFBLFNBQVMsQ0FBQzZJLElBQUQsQ0FBVCxLQUFvQkEsSUFBSSxHQUFHLEVBQTNCO0FBQ0FBLEVBQUFBLElBQUksQ0FBQ2pFLGNBQUwsR0FBc0JpRSxJQUFJLENBQUMyMEIsWUFBTCxHQUFvQjMwQixJQUFJLENBQUNrMUIsV0FBTCxHQUFtQixJQUE3RDtBQUNBbDFCLEVBQUFBLElBQUksQ0FBQ2pJLElBQUwsS0FBY2lJLElBQUksQ0FBQ2pJLElBQUwsR0FBWSxhQUExQjtBQUNBaUksRUFBQUEsSUFBSSxDQUFDeXpCLFFBQUwsR0FBZ0IsQ0FBQyxDQUFDenpCLElBQUksQ0FBQ3l6QixRQUF2QjtBQUNBenpCLEVBQUFBLElBQUksQ0FBQzBYLEVBQUwsR0FBVTFYLElBQUksQ0FBQzBYLEVBQUwsSUFBVyxZQUFyQjs7QUFFQSxNQUFJbzRCLE1BQU0sR0FBRzl2QyxJQUFiO0FBQUEsTUFDSSt2QyxnQkFBZ0IsR0FBR0QsTUFBTSxDQUFDQyxnQkFEOUI7QUFBQSxNQUVJQyxRQUFRLEdBQUdGLE1BQU0sQ0FBQ0UsUUFGdEI7QUFBQSxNQUdJQyxpQkFBaUIsR0FBR0gsTUFBTSxDQUFDRyxpQkFIL0I7QUFBQSxNQUlJbjdDLElBSko7QUFBQSxNQUtJbU0sSUFMSjtBQUFBLE1BTUkxRSxNQUFNLEdBQUdtMUIsVUFBVSxDQUFDMXhCLElBQUksQ0FBQ3pELE1BQU4sQ0FBVixJQUEyQjZ5QixtQkFOeEM7QUFBQSxNQU9JOGdCLFFBQVEsR0FBR3g2QyxrQkFBSSxDQUFDd1YsSUFBTCxDQUFVNG5CLE9BQVYsR0FBb0JxZCxjQVBuQztBQUFBLE1BUUkvckMsT0FBTyxHQUFHaTFCLFVBQVUsS0FBS3I1QixJQUFJLENBQUNvRSxPQUFMLElBQWdCc3RCLFVBQVUsQ0FBQzF4QixJQUFJLENBQUNvRSxPQUFOLENBQTFCLElBQTRDOHJDLFFBQVEsSUFBSUEsUUFBUSxDQUFDN25DLEdBQVQsRUFBWixJQUE4QjZuQyxRQUFRLENBQUM3bkMsR0FBVCxHQUFlakUsT0FBZixFQUEvRSxDQVJ4QjtBQUFBLE1BU0l1eEIsV0FBVyxHQUFHOUQsY0FBYyxDQUFDdDFCLE1BQUQsRUFBU2kxQixTQUFULENBVGhDO0FBQUEsTUFVSWtFLFdBQVcsR0FBRzdELGNBQWMsQ0FBQ3QxQixNQUFELEVBQVM2MEIsV0FBVCxDQVZoQztBQUFBLE1BV0lpTCxLQUFLLEdBQUcsQ0FYWjtBQUFBLE1BWUkrVCxZQUFZLEdBQUcsQ0FBQ3BkLGdCQUFBLElBQW9CcjlCLGlCQUFJLENBQUMwNkMsY0FBekIsR0FBMEMxNkMsaUJBQUksQ0FBQzA2QyxjQUFMLENBQW9CaFUsS0FBcEIsR0FBNEIxbUMsaUJBQUksQ0FBQzA2QyxjQUFMLENBQW9CcHhDLEtBQTFGLEdBQWtHdEosaUJBQUksQ0FBQzI2QyxVQUF4RyxJQUFzSDM2QyxpQkFBSSxDQUFDeUosVUFaOUk7QUFBQSxNQWFJbXhDLFlBQVksR0FBRyxDQWJuQjtBQUFBLE1BY0lDLHVCQUF1QixHQUFHdjVDLFdBQVcsQ0FBQys0QyxRQUFELENBQVgsR0FBd0IsWUFBWTtBQUNoRSxXQUFPQSxRQUFRLENBQUNsN0MsSUFBRCxDQUFmO0FBQ0QsR0FGNkIsR0FFMUIsWUFBWTtBQUNkLFdBQU9rN0MsUUFBUSxJQUFJLEdBQW5CO0FBQ0QsR0FsQkQ7QUFBQSxNQW1CSVMsYUFuQko7QUFBQSxNQW9CSUMsYUFwQko7QUFBQSxNQXFCSUMsYUFBYSxHQUFHckIsY0FBYyxDQUFDL3lDLE1BQUQsRUFBU3lELElBQUksQ0FBQ2pJLElBQWQsRUFBb0IsSUFBcEIsRUFBMEJrNEMsaUJBQTFCLENBckJsQztBQUFBLE1Bc0JJVyxlQUFlLEdBQUcsU0FBU0EsZUFBVCxHQUEyQjtBQUMvQyxXQUFPSCxhQUFhLEdBQUcsS0FBdkI7QUFDRCxHQXhCRDtBQUFBLE1BeUJJSSxZQUFZLEdBQUdsaEIseUJBekJuQjtBQUFBLE1BMEJJbWhCLFlBQVksR0FBR25oQix5QkExQm5CO0FBQUEsTUEyQklvaEIsWUFBWSxHQUFHLFNBQVNBLFlBQVQsR0FBd0I7QUFDekM5dkMsSUFBQUEsSUFBSSxHQUFHZzVCLFVBQVUsQ0FBQzE5QixNQUFELEVBQVNpMUIsU0FBVCxDQUFqQjtBQUNBc2YsSUFBQUEsWUFBWSxHQUFHM2hCLG1CQUFNLENBQUNrSyxVQUFVLEdBQUcsQ0FBSCxHQUFPLENBQWxCLEVBQXFCcDRCLElBQXJCLENBQXJCO0FBQ0E4dUMsSUFBQUEsZ0JBQWdCLEtBQUtjLFlBQVksR0FBRzFoQixtQkFBTSxDQUFDLENBQUQsRUFBSThLLFVBQVUsQ0FBQzE5QixNQUFELEVBQVM2MEIsV0FBVCxDQUFkLENBQTFCLENBQWhCO0FBQ0FzZixJQUFBQSxhQUFhLEdBQUd0UCxVQUFoQjtBQUNELEdBaENEO0FBQUEsTUFpQ0k0UCxVQUFVLEdBQUcsU0FBU0EsVUFBVCxHQUFzQjtBQUNyQyxRQUFJUCxhQUFKLEVBQW1CO0FBQ2pCN1osTUFBQUEscUJBQXFCLENBQUNnYSxlQUFELENBQXJCLENBRGlCLENBQ3VCOztBQUV4QyxVQUFJbHdDLE1BQU0sR0FBR2xKLE1BQU0sQ0FBQzFDLElBQUksQ0FBQ3NaLE1BQUwsR0FBYyxDQUFmLENBQW5CO0FBQUEsVUFDSXpRLE1BQU0sR0FBR216QyxZQUFZLENBQUNuYixXQUFXLENBQUN2TCxDQUFaLEdBQWdCMXBCLE1BQWpCLENBRHpCOztBQUdBLFVBQUkwRCxPQUFPLElBQUl6RyxNQUFNLEtBQUtnNEIsV0FBVyxDQUFDdkwsQ0FBWixHQUFnQnVMLFdBQVcsQ0FBQ2oxQixNQUF0RCxFQUE4RDtBQUM1RGkxQixRQUFBQSxXQUFXLENBQUNqMUIsTUFBWixHQUFxQi9DLE1BQU0sR0FBR2c0QixXQUFXLENBQUN2TCxDQUExQztBQUNBaG1CLFFBQUFBLE9BQU8sQ0FBQy9MLEtBQVIsQ0FBYzQ0QyxTQUFkLEdBQTBCLGdCQUFnQixDQUFDdGIsV0FBVyxDQUFDajFCLE1BQTdCLEdBQXNDLEtBQWhFO0FBQ0EwRCxRQUFBQSxPQUFPLENBQUM2RyxLQUFSLEtBQWtCN0csT0FBTyxDQUFDNkcsS0FBUixDQUFjaE4sQ0FBZCxHQUFrQixDQUFDMDNCLFdBQVcsQ0FBQ2oxQixNQUFiLEdBQXNCLElBQTFEO0FBQ0FpMUIsUUFBQUEsV0FBVyxDQUFDeEUsT0FBWixHQUFzQnJCLGdCQUF0Qjs7QUFFQStQLFFBQUFBLFVBQVU7QUFDWDs7QUFFRCxhQUFPLElBQVA7QUFDRDs7QUFFRCxRQUFJejdCLE9BQUosRUFBYTtBQUNYQSxNQUFBQSxPQUFPLENBQUMvTCxLQUFSLENBQWM0NEMsU0FBZCxHQUEwQixpQkFBMUI7QUFDQXRiLE1BQUFBLFdBQVcsQ0FBQ2oxQixNQUFaLEdBQXFCaTFCLFdBQVcsQ0FBQ3hFLE9BQVosR0FBc0IsQ0FBM0M7QUFDQS9zQixNQUFBQSxPQUFPLENBQUM2RyxLQUFSLEtBQWtCN0csT0FBTyxDQUFDNkcsS0FBUixDQUFjaE4sQ0FBZCxHQUFrQixLQUFwQztBQUNEOztBQUVEd3lDLElBQUFBLGFBQWEsR0FBRyxJQUFoQjtBQUNELEdBM0REO0FBQUEsTUE0REl6Z0MsS0E1REo7QUFBQSxNQTZESWtoQyxZQTdESjtBQUFBLE1BOERJQyxZQTlESjtBQUFBLE1BK0RJaGMsaUJBL0RKO0FBQUEsTUFnRUlpYyxRQUFRLEdBQUcsU0FBU0EsUUFBVCxHQUFvQjtBQUNqQztBQUNBTCxJQUFBQSxZQUFZOztBQUVaLFFBQUkvZ0MsS0FBSyxDQUFDZ0MsUUFBTixNQUFvQmhDLEtBQUssQ0FBQ2hRLElBQU4sQ0FBVzYxQixPQUFYLEdBQXFCNTBCLElBQTdDLEVBQW1EO0FBQ2pEMDBCLE1BQUFBLFdBQVcsS0FBSzEwQixJQUFoQixHQUF1QitPLEtBQUssQ0FBQ2tLLFFBQU4sQ0FBZSxDQUFmLEtBQXFCeWIsV0FBVyxDQUFDMTBCLElBQUQsQ0FBdkQsR0FBZ0UrTyxLQUFLLENBQUN1OEIsT0FBTixDQUFjLFNBQWQsRUFBeUJ0ckMsSUFBekIsQ0FBaEU7QUFDRDtBQUNGLEdBdkVEOztBQXlFQWpCLEVBQUFBLElBQUksQ0FBQzAwQixXQUFMLEdBQW1CLFVBQVV6OEIsQ0FBVixFQUFhO0FBQzlCLFdBQU9vaEMsVUFBVSxJQUFJcGhDLENBQUMsQ0FBQ0YsSUFBRixLQUFXLFdBQXpCLElBQXdDaTVDLFVBQVUsQ0FBQy80QyxDQUFELENBQWxELElBQXlEb2tDLEtBQUssR0FBRyxJQUFSLElBQWdCcGtDLENBQUMsQ0FBQ0YsSUFBRixLQUFXLFlBQXBGLElBQW9HakQsSUFBSSxDQUFDc2lDLFdBQXpHLElBQXdIbi9CLENBQUMsQ0FBQ3FFLE9BQUYsSUFBYXJFLENBQUMsQ0FBQ3FFLE9BQUYsQ0FBVXZDLE1BQVYsR0FBbUIsQ0FBL0o7QUFDRCxHQUZEOztBQUlBaUcsRUFBQUEsSUFBSSxDQUFDa1MsT0FBTCxHQUFlLFlBQVk7QUFDekIsUUFBSW0vQixTQUFTLEdBQUdoVixLQUFoQjtBQUNBQSxJQUFBQSxLQUFLLEdBQUc3a0MsTUFBTSxDQUFDLENBQUM3QixpQkFBSSxDQUFDMDZDLGNBQUwsSUFBdUIxNkMsaUJBQUksQ0FBQzA2QyxjQUFMLENBQW9CaFUsS0FBM0MsSUFBb0QsQ0FBckQsSUFBMEQrVCxZQUEzRCxDQUFkO0FBQ0FwZ0MsSUFBQUEsS0FBSyxDQUFDd21CLEtBQU47QUFDQTZhLElBQUFBLFNBQVMsS0FBS2hWLEtBQWQsSUFBdUIwUyxtQkFBbUIsQ0FBQ3h5QyxNQUFELEVBQVM4L0IsS0FBSyxHQUFHLElBQVIsR0FBZSxJQUFmLEdBQXNCMFQsZ0JBQWdCLEdBQUcsS0FBSCxHQUFXLEdBQTFELENBQTFDO0FBQ0FVLElBQUFBLGFBQWEsR0FBRyxLQUFoQjtBQUNBUyxJQUFBQSxZQUFZLEdBQUd4YixXQUFXLEVBQTFCO0FBQ0F5YixJQUFBQSxZQUFZLEdBQUd4YixXQUFXLEVBQTFCO0FBQ0FvYixJQUFBQSxZQUFZO0FBQ1pMLElBQUFBLGFBQWEsR0FBR3RQLFVBQWhCO0FBQ0QsR0FWRDs7QUFZQXBoQyxFQUFBQSxJQUFJLENBQUNvUyxTQUFMLEdBQWlCcFMsSUFBSSxDQUFDNDBCLGNBQUwsR0FBc0IsVUFBVTkvQixJQUFWLEVBQWdCNGYsV0FBaEIsRUFBNkI7QUFDbEUsUUFBSXRRLE9BQUosRUFBYTtBQUNYQSxNQUFBQSxPQUFPLENBQUMvTCxLQUFSLENBQWM0NEMsU0FBZCxHQUEwQixpQkFBMUI7QUFDQXRiLE1BQUFBLFdBQVcsQ0FBQ2oxQixNQUFaLEdBQXFCaTFCLFdBQVcsQ0FBQ3hFLE9BQVosR0FBc0IsQ0FBM0M7QUFDQS9zQixNQUFBQSxPQUFPLENBQUM2RyxLQUFSLEtBQWtCN0csT0FBTyxDQUFDNkcsS0FBUixDQUFjaE4sQ0FBZCxHQUFrQixLQUFwQztBQUNEOztBQUVELFFBQUksQ0FBQ3lXLFdBQUwsRUFBa0I7QUFDaEJ5Z0IsTUFBQUEsaUJBQWlCLENBQUNrQyxPQUFsQixDQUEwQixJQUExQjtBQUNELEtBRkQsTUFFTztBQUNMdkgsTUFBQUEsZ0JBQUEsR0FESyxDQUNlO0FBQ3BCOztBQUVBLFVBQUl3aEIsR0FBRyxHQUFHZCx1QkFBdUIsRUFBakM7QUFBQSxVQUNJZSxhQURKO0FBQUEsVUFFSW5JLFNBRko7O0FBSUEsVUFBSTJHLGdCQUFKLEVBQXNCO0FBQ3BCd0IsUUFBQUEsYUFBYSxHQUFHN2IsV0FBVyxFQUEzQjtBQUNBMFQsUUFBQUEsU0FBUyxHQUFHbUksYUFBYSxHQUFHRCxHQUFHLEdBQUcsSUFBTixHQUFhLENBQUN4OEMsSUFBSSxDQUFDMDhDLFNBQW5CLEdBQStCLEtBQTNELENBRm9CLENBRThDOztBQUVsRUYsUUFBQUEsR0FBRyxJQUFJeEMsb0NBQW9DLENBQUNwWixXQUFELEVBQWM2YixhQUFkLEVBQTZCbkksU0FBN0IsRUFBd0NuUCxVQUFVLENBQUMxOUIsTUFBRCxFQUFTNjBCLFdBQVQsQ0FBbEQsQ0FBM0M7QUFDQXBoQixRQUFBQSxLQUFLLENBQUNoUSxJQUFOLENBQVc0MUIsT0FBWCxHQUFxQmliLFlBQVksQ0FBQ3pILFNBQUQsQ0FBakM7QUFDRDs7QUFFRG1JLE1BQUFBLGFBQWEsR0FBRzViLFdBQVcsRUFBM0I7QUFDQXlULE1BQUFBLFNBQVMsR0FBR21JLGFBQWEsR0FBR0QsR0FBRyxHQUFHLElBQU4sR0FBYSxDQUFDeDhDLElBQUksQ0FBQzI4QyxTQUFuQixHQUErQixLQUEzRCxDQWpCSyxDQWlCNkQ7O0FBRWxFSCxNQUFBQSxHQUFHLElBQUl4QyxvQ0FBb0MsQ0FBQ25aLFdBQUQsRUFBYzRiLGFBQWQsRUFBNkJuSSxTQUE3QixFQUF3Q25QLFVBQVUsQ0FBQzE5QixNQUFELEVBQVNpMUIsU0FBVCxDQUFsRCxDQUEzQztBQUNBeGhCLE1BQUFBLEtBQUssQ0FBQ2hRLElBQU4sQ0FBVzYxQixPQUFYLEdBQXFCaWIsWUFBWSxDQUFDMUgsU0FBRCxDQUFqQztBQUNBcDVCLE1BQUFBLEtBQUssQ0FBQ3U2QixVQUFOLEdBQW1CdHZDLFFBQW5CLENBQTRCcTJDLEdBQTVCLEVBQWlDdmdDLElBQWpDLENBQXNDLElBQXRDOztBQUVBLFVBQUlzb0IsVUFBVSxJQUFJcnBCLEtBQUssQ0FBQ2hRLElBQU4sQ0FBVzYxQixPQUFYLElBQXNCNTBCLElBQXBDLElBQTRDc3dDLGFBQWEsSUFBSXR3QyxJQUFJLEdBQUcsQ0FBeEUsRUFBMkU7QUFDekU7QUFDQXZMLFFBQUFBLGtCQUFJLENBQUNvRixFQUFMLENBQVEsRUFBUixFQUFZO0FBQ1YyVixVQUFBQSxRQUFRLEVBQUUyZ0MsUUFEQTtBQUVWbjJDLFVBQUFBLFFBQVEsRUFBRXEyQztBQUZBLFNBQVo7QUFJRDtBQUNGO0FBQ0YsR0F4Q0Q7O0FBMENBdHhDLEVBQUFBLElBQUksQ0FBQzgwQixPQUFMLEdBQWUsWUFBWTtBQUN6QjlrQixJQUFBQSxLQUFLLENBQUMwaEMsR0FBTixJQUFhMWhDLEtBQUssQ0FBQ3dtQixLQUFOLEVBQWI7O0FBRUEsUUFBSTk5QixxQkFBUSxLQUFLNjNDLFlBQWIsR0FBNEIsSUFBaEMsRUFBc0M7QUFDcEM7QUFDQUcsTUFBQUEsYUFBYSxHQUFHLENBQWhCO0FBQ0FILE1BQUFBLFlBQVksR0FBRzczQyxxQkFBUSxFQUF2QjtBQUNEO0FBQ0YsR0FSRDs7QUFVQXNILEVBQUFBLElBQUksQ0FBQ3EwQixRQUFMLEdBQWdCLFVBQVV2L0IsSUFBVixFQUFnQnFhLEVBQWhCLEVBQW9CQyxFQUFwQixFQUF3QnVpQyxNQUF4QixFQUFnQ0MsTUFBaEMsRUFBd0M7QUFDdER4USxJQUFBQSxVQUFVLEtBQUtzUCxhQUFmLElBQWdDSyxZQUFZLEVBQTVDO0FBQ0E1aEMsSUFBQUEsRUFBRSxJQUFJNGdDLGdCQUFOLElBQTBCcmEsV0FBVyxDQUFDbWIsWUFBWSxDQUFDYyxNQUFNLENBQUMsQ0FBRCxDQUFOLEtBQWN4aUMsRUFBZCxHQUFtQitoQyxZQUFZLElBQUlwOEMsSUFBSSxDQUFDZ2QsTUFBTCxHQUFjaGQsSUFBSSxDQUFDa0osQ0FBdkIsQ0FBL0IsR0FBMkQwM0IsV0FBVyxLQUFLdm1CLEVBQWhCLEdBQXFCd2lDLE1BQU0sQ0FBQyxDQUFELENBQXZGLENBQWIsQ0FBckMsQ0FGc0QsQ0FFMEY7O0FBRWhKdmlDLElBQUFBLEVBQUUsSUFBSXVtQixXQUFXLENBQUNtYixZQUFZLENBQUNjLE1BQU0sQ0FBQyxDQUFELENBQU4sS0FBY3hpQyxFQUFkLEdBQW1CK2hDLFlBQVksSUFBSXI4QyxJQUFJLENBQUNpZCxNQUFMLEdBQWNqZCxJQUFJLENBQUNtSixDQUF2QixDQUEvQixHQUEyRDAzQixXQUFXLEtBQUt2bUIsRUFBaEIsR0FBcUJ3aUMsTUFBTSxDQUFDLENBQUQsQ0FBdkYsQ0FBYixDQUFqQjs7QUFFQS9SLElBQUFBLFVBQVU7QUFDWCxHQVBEOztBQVNBNy9CLEVBQUFBLElBQUksQ0FBQyswQixRQUFMLEdBQWdCLFlBQVk7QUFDMUJnYSxJQUFBQSxtQkFBbUIsQ0FBQ3h5QyxNQUFELEVBQVN3ekMsZ0JBQWdCLEdBQUcsS0FBSCxHQUFXLEdBQXBDLENBQW5COztBQUVBMTBDLElBQUFBLHlCQUFZLENBQUMxRixpQkFBRCxFQUFPLFFBQVAsRUFBaUJ5N0MsUUFBakIsQ0FBWjs7QUFFQVQsSUFBQUEsYUFBYSxDQUFDcnFDLE1BQWQ7QUFDRCxHQU5EOztBQVFBdEcsRUFBQUEsSUFBSSxDQUFDZzFCLFNBQUwsR0FBaUIsWUFBWTtBQUMzQitaLElBQUFBLG1CQUFtQixDQUFDeHlDLE1BQUQsRUFBUyxJQUFULENBQW5COztBQUVBWixJQUFBQSw0QkFBZSxDQUFDaEcsaUJBQUQsRUFBTyxRQUFQLEVBQWlCeTdDLFFBQWpCLENBQWY7O0FBRUFULElBQUFBLGFBQWEsQ0FBQy85QixJQUFkO0FBQ0QsR0FORDs7QUFRQTlkLEVBQUFBLElBQUksR0FBRyxJQUFJaytCLFFBQUosQ0FBYWh6QixJQUFiLENBQVA7QUFDQWxMLEVBQUFBLElBQUksQ0FBQ284QixHQUFMLEdBQVdtSSxVQUFYLENBOUs2RCxDQThLdEM7O0FBRXZCQSxFQUFBQSxVQUFVLElBQUksQ0FBQzFELFdBQVcsRUFBMUIsSUFBZ0NBLFdBQVcsQ0FBQyxDQUFELENBQTNDLENBaEw2RCxDQWdMYjs7QUFFaERSLEVBQUFBLGlCQUFpQixHQUFHcmdDLElBQUksQ0FBQ2tqQyxHQUF6QjtBQUNBaG9CLEVBQUFBLEtBQUssR0FBR3RhLGtCQUFJLENBQUNvRixFQUFMLENBQVFoRyxJQUFSLEVBQWM7QUFDcEIwekMsSUFBQUEsSUFBSSxFQUFFLFFBRGM7QUFFcEJFLElBQUFBLE1BQU0sRUFBRSxJQUZZO0FBR3BCOVMsSUFBQUEsT0FBTyxFQUFFbWEsZ0JBQWdCLEdBQUcsT0FBSCxHQUFhLEtBSGxCO0FBSXBCbGEsSUFBQUEsT0FBTyxFQUFFLE9BSlc7QUFLcEIzNkIsSUFBQUEsVUFBVSxFQUFFaTZCLGlCQUFpQixDQUFDbjFCLElBQWxCLENBQXVCOUU7QUFMZixHQUFkLENBQVI7QUFPQSxTQUFPcEcsSUFBUDtBQUNELENBaFFEOztBQWtRQXk2QiwyQkFBYSxDQUFDeU4sSUFBZCxHQUFxQixVQUFVM2lDLElBQVYsRUFBZ0I7QUFDbkMsU0FBT29sQyxTQUFTLENBQUN6QyxJQUFWLENBQWUzaUMsSUFBSSxJQUFJLFVBQVV1SSxDQUFWLEVBQWEyUixDQUFiLEVBQWdCO0FBQzVDLFdBQU8sQ0FBQzNSLENBQUMsQ0FBQzVDLElBQUYsQ0FBT3FvQyxlQUFQLElBQTBCLENBQTNCLElBQWdDLENBQUMsR0FBakMsR0FBdUN6bEMsQ0FBQyxDQUFDdU8sS0FBekMsSUFBa0RvRCxDQUFDLENBQUNwRCxLQUFGLEdBQVUsQ0FBQ29ELENBQUMsQ0FBQ3ZVLElBQUYsQ0FBT3FvQyxlQUFQLElBQTBCLENBQTNCLElBQWdDLENBQUMsR0FBN0YsQ0FBUDtBQUNELEdBRk0sQ0FBUDtBQUdELENBSkQ7O0FBTUE5WSwyQkFBYSxDQUFDc2lCLE9BQWQsR0FBd0IsVUFBVTd4QyxJQUFWLEVBQWdCO0FBQ3RDLFNBQU8sSUFBSWd6QixRQUFKLENBQWFoekIsSUFBYixDQUFQO0FBQ0QsQ0FGRDs7QUFJQXV2QiwyQkFBYSxDQUFDdWlCLGVBQWQsR0FBZ0MsVUFBVTl4QyxJQUFWLEVBQWdCO0FBQzlDLE1BQUksT0FBT0EsSUFBUCxLQUFnQixXQUFwQixFQUFpQztBQUMvQixXQUFPeXZCLHdCQUFQO0FBQ0Q7O0FBRUQsTUFBSXp2QixJQUFJLEtBQUssSUFBVCxJQUFpQnl2Qix3QkFBckIsRUFBa0M7QUFDaEMsV0FBT0Esd0JBQVcsQ0FBQ25wQixNQUFaLEVBQVA7QUFDRDs7QUFFRCxNQUFJdEcsSUFBSSxLQUFLLEtBQWIsRUFBb0I7QUFDbEIsV0FBT3l2Qix3QkFBVyxJQUFJQSx3QkFBVyxDQUFDN2MsSUFBWixFQUF0QjtBQUNEOztBQUVELE1BQUltL0IsVUFBVSxHQUFHL3hDLElBQUksWUFBWWd6QixRQUFoQixHQUEyQmh6QixJQUEzQixHQUFrQzZ2QyxvQkFBb0IsQ0FBQzd2QyxJQUFELENBQXZFO0FBQ0F5dkIsRUFBQUEsd0JBQVcsSUFBSUEsd0JBQVcsQ0FBQ2x6QixNQUFaLEtBQXVCdzFDLFVBQVUsQ0FBQ3gxQyxNQUFqRCxJQUEyRGt6Qix3QkFBVyxDQUFDN2MsSUFBWixFQUEzRDtBQUNBMGQsRUFBQUEsd0JBQVcsQ0FBQ3loQixVQUFVLENBQUN4MUMsTUFBWixDQUFYLEtBQW1Da3pCLHdCQUFXLEdBQUdzaUIsVUFBakQ7QUFDQSxTQUFPQSxVQUFQO0FBQ0QsQ0FqQkQ7O0FBbUJBeGlCLDJCQUFhLENBQUNya0IsSUFBZCxHQUFxQjtBQUNuQjtBQUNBNG1CLEVBQUFBLGdCQUFnQixFQUFFQSxnQkFGQztBQUduQndkLEVBQUFBLGNBQWMsRUFBRUEsY0FIRztBQUluQnhmLEVBQUFBLFVBQVUsRUFBRUEsVUFKTztBQUtuQkMsRUFBQUEsUUFBUSxFQUFFQSxRQUxTO0FBTW5CRyxFQUFBQSxNQUFNLEVBQUU7QUFDTjtBQUNBOGhCLElBQUFBLEVBQUUsRUFBRSxTQUFTQSxFQUFULEdBQWM7QUFDaEJ4WSxNQUFBQSxlQUFlLElBQUlzRyxTQUFTLENBQUMsYUFBRCxDQUE1QjtBQUNBdEcsTUFBQUEsZUFBZSxHQUFHOWdDLHFCQUFRLEVBQTFCO0FBQ0QsS0FMSztBQU1OO0FBQ0F1NUMsSUFBQUEsR0FBRyxFQUFFLFNBQVNBLEdBQVQsR0FBZTtBQUNsQixhQUFPeFosV0FBUDtBQUNEO0FBVEs7QUFOVyxDQUFyQjtBQWtCQTFoQyxxQkFBUSxNQUFNckIsa0JBQUksQ0FBQ3NCLGNBQUwsQ0FBb0J1NEIsMkJBQXBCLENBQWQ7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDenhFQSxTQUFTMTZCLHNCQUFULENBQWdDQyxJQUFoQyxFQUFzQztBQUFFLE1BQUlBLElBQUksS0FBSyxLQUFLLENBQWxCLEVBQXFCO0FBQUUsVUFBTSxJQUFJQyxjQUFKLENBQW1CLDJEQUFuQixDQUFOO0FBQXdGOztBQUFDLFNBQU9ELElBQVA7QUFBYzs7QUFFdEssU0FBU0UsY0FBVCxDQUF3QkMsUUFBeEIsRUFBa0NDLFVBQWxDLEVBQThDO0FBQUVELEVBQUFBLFFBQVEsQ0FBQ0UsU0FBVCxHQUFxQkMsTUFBTSxDQUFDQyxNQUFQLENBQWNILFVBQVUsQ0FBQ0MsU0FBekIsQ0FBckI7QUFBMERGLEVBQUFBLFFBQVEsQ0FBQ0UsU0FBVCxDQUFtQkcsV0FBbkIsR0FBaUNMLFFBQWpDO0FBQTJDQSxFQUFBQSxRQUFRLENBQUNNLFNBQVQsR0FBcUJMLFVBQXJCO0FBQWtDO0FBRXZMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7O0FBQ0EsSUFBSWc5QyxPQUFPLEdBQUc7QUFDWkMsRUFBQUEsU0FBUyxFQUFFLEdBREM7QUFFWjVzQyxFQUFBQSxPQUFPLEVBQUUsTUFGRztBQUdacXNCLEVBQUFBLGNBQWMsRUFBRSxDQUhKO0FBSVp3Z0IsRUFBQUEsS0FBSyxFQUFFO0FBQ0w1ZSxJQUFBQSxVQUFVLEVBQUU7QUFEUDtBQUpLLENBQWQ7QUFBQSxJQVFJc0ssU0FBUyxHQUFHO0FBQ2Q3aUMsRUFBQUEsUUFBUSxFQUFFLEVBREk7QUFFZEYsRUFBQUEsU0FBUyxFQUFFLEtBRkc7QUFHZEMsRUFBQUEsS0FBSyxFQUFFO0FBSE8sQ0FSaEI7QUFBQSxJQWFJZytCLG1CQWJKO0FBQUEsSUFjSXhnQyxPQUFPLEdBQUcsR0FkZDtBQUFBLElBZUk2NUMsUUFBUSxHQUFHLElBQUk3NUMsT0FmbkI7QUFBQSxJQWdCSTg1QyxJQUFJLEdBQUc3NkMsSUFBSSxDQUFDYyxFQUFMLEdBQVUsQ0FoQnJCO0FBQUEsSUFpQklnNkMsUUFBUSxHQUFHRCxJQUFJLEdBQUcsQ0FqQnRCO0FBQUEsSUFrQklFLEtBQUssR0FBRyxDQWxCWjtBQUFBLElBbUJJaDVCLEtBQUssR0FBRy9oQixJQUFJLENBQUNnaUIsSUFuQmpCO0FBQUEsSUFvQklKLElBQUksR0FBRzVoQixJQUFJLENBQUM2aEIsR0FwQmhCO0FBQUEsSUFxQklILElBQUksR0FBRzFoQixJQUFJLENBQUMyaEIsR0FyQmhCO0FBQUEsSUFzQklRLFNBQVMsR0FBRyxTQUFTQSxTQUFULENBQW1CMWlCLEtBQW5CLEVBQTBCO0FBQ3hDLFNBQU8sT0FBT0EsS0FBUCxLQUFpQixRQUF4QjtBQUNELENBeEJEO0FBQUEsSUF5QklELFdBQVcsR0FBRyxTQUFTQSxXQUFULENBQXFCQyxLQUFyQixFQUE0QjtBQUM1QyxTQUFPLE9BQU9BLEtBQVAsS0FBaUIsVUFBeEI7QUFDRCxDQTNCRDtBQUFBLElBNEJJMmlCLFNBQVMsR0FBRyxTQUFTQSxTQUFULENBQW1CM2lCLEtBQW5CLEVBQTBCO0FBQ3hDLFNBQU8sT0FBT0EsS0FBUCxLQUFpQixRQUF4QjtBQUNELENBOUJEO0FBQUEsSUErQklFLFlBQVksR0FBRyxTQUFTQSxZQUFULENBQXNCRixLQUF0QixFQUE2QjtBQUM5QyxTQUFPLE9BQU9BLEtBQVAsS0FBaUIsV0FBeEI7QUFDRCxDQWpDRDtBQUFBLElBa0NJQyxTQUFTLEdBQUcsU0FBU0EsU0FBVCxDQUFtQkQsS0FBbkIsRUFBMEI7QUFDeEMsU0FBTyxRQUFPQSxLQUFQLE1BQWlCLFFBQXhCO0FBQ0QsQ0FwQ0Q7QUFBQSxJQXFDSXU3QyxXQUFXLEdBQUcsU0FBU0EsV0FBVCxDQUFxQnY3QyxLQUFyQixFQUE0QjtBQUM1QyxTQUFPQSxLQUFLLEtBQUssS0FBakI7QUFDRCxDQXZDRDtBQUFBLElBd0NJTCxhQUFhLEdBQUcsU0FBU0EsYUFBVCxHQUF5QjtBQUMzQyxTQUFPLE9BQU9DLE1BQVAsS0FBa0IsV0FBekI7QUFDRCxDQTFDRDtBQUFBLElBMkNJNDdDLGVBQWUsR0FBRyxTQUFTQSxlQUFULENBQXlCeDdDLEtBQXpCLEVBQWdDO0FBQ3BELFNBQU9ELFdBQVcsQ0FBQ0MsS0FBRCxDQUFYLElBQXNCMGlCLFNBQVMsQ0FBQzFpQixLQUFELENBQXRDO0FBQ0QsQ0E3Q0Q7QUFBQSxJQThDSXk3QyxhQUFhLEdBQUcsT0FBT0MsV0FBUCxLQUF1QixVQUF2QixJQUFxQ0EsV0FBVyxDQUFDQyxNQUFqRCxJQUEyRCxZQUFZLENBQUUsQ0E5QzdGO0FBQUEsSUErQ0k7QUFDSmw3QyxRQUFRLEdBQUdDLEtBQUssQ0FBQ0MsT0FoRGpCO0FBQUEsSUFpRElpN0MsYUFBYSxHQUFHLG1CQWpEcEI7QUFBQSxJQWtESTtBQUNKNW5CLE9BQU8sR0FBRyxrQ0FuRFY7QUFBQSxJQW9ESTtBQUNKNm5CLGVBQWUsR0FBRyw2QkFyRGxCO0FBQUEsSUFzRElDLG9CQUFvQixHQUFHLGtDQXREM0I7QUFBQSxJQXVESTtBQUNKQyxPQUFPLEdBQUcsZUF4RFY7QUFBQSxJQXlESUMsa0JBQWtCLEdBQUcsaUJBekR6QjtBQUFBLElBMERJO0FBQ0pDLFFBQVEsR0FBRyx1Q0EzRFg7QUFBQSxJQTRESUMsZUE1REo7QUFBQSxJQTZESXo5QyxJQTdESjtBQUFBLElBOERJTSxZQTlESjtBQUFBLElBK0RJTCxJQS9ESjtBQUFBLElBZ0VJeTlDLFFBQVEsR0FBRyxFQWhFZjtBQUFBLElBaUVJQyxhQUFhLEdBQUcsRUFqRXBCO0FBQUEsSUFrRUlDLFVBbEVKO0FBQUEsSUFtRUlDLFFBQVEsR0FBRyxTQUFTQSxRQUFULENBQWtCQyxLQUFsQixFQUF5QjtBQUN0QyxTQUFPLENBQUNILGFBQWEsR0FBR0ksTUFBTSxDQUFDRCxLQUFELEVBQVFKLFFBQVIsQ0FBdkIsS0FBNkMzOUMsSUFBcEQ7QUFDRCxDQXJFRDtBQUFBLElBc0VJaStDLGNBQWMsR0FBRyxTQUFTQSxjQUFULENBQXdCcDFDLFFBQXhCLEVBQWtDckgsS0FBbEMsRUFBeUM7QUFDNUQsU0FBT3lSLE9BQU8sQ0FBQ0MsSUFBUixDQUFhLGtCQUFiLEVBQWlDckssUUFBakMsRUFBMkMsUUFBM0MsRUFBcURySCxLQUFyRCxFQUE0RCx1Q0FBNUQsQ0FBUDtBQUNELENBeEVEO0FBQUEsSUF5RUkwOEMsS0FBSyxHQUFHLFNBQVNBLEtBQVQsQ0FBZUMsT0FBZixFQUF3QkMsUUFBeEIsRUFBa0M7QUFDNUMsU0FBTyxDQUFDQSxRQUFELElBQWFuckMsT0FBTyxDQUFDQyxJQUFSLENBQWFpckMsT0FBYixDQUFwQjtBQUNELENBM0VEO0FBQUEsSUE0RUlFLFVBQVUsR0FBRyxTQUFTQSxVQUFULENBQW9CcjNCLElBQXBCLEVBQTBCcGpCLEdBQTFCLEVBQStCO0FBQzlDLFNBQU9vakIsSUFBSSxLQUFLMjJCLFFBQVEsQ0FBQzMyQixJQUFELENBQVIsR0FBaUJwakIsR0FBdEIsQ0FBSixJQUFrQ2c2QyxhQUFsQyxLQUFvREEsYUFBYSxDQUFDNTJCLElBQUQsQ0FBYixHQUFzQnBqQixHQUExRSxLQUFrRis1QyxRQUF6RjtBQUNELENBOUVEO0FBQUEsSUErRUloOEMsVUFBVSxHQUFHLFNBQVNBLFVBQVQsR0FBc0I7QUFDckMsU0FBTyxDQUFQO0FBQ0QsQ0FqRkQ7QUFBQSxJQWtGSTI4QyxjQUFjLEdBQUcsRUFsRnJCO0FBQUEsSUFtRklDLFdBQVcsR0FBRyxFQW5GbEI7QUFBQSxJQW9GSUMsV0FBVyxHQUFHLEVBcEZsQjtBQUFBLElBcUZJQyxrQkFyRko7QUFBQSxJQXNGSUMsUUFBUSxHQUFHLEVBdEZmO0FBQUEsSUF1RklDLFFBQVEsR0FBRyxFQXZGZjtBQUFBLElBd0ZJQyxZQUFZLEdBQUcsRUF4Rm5CO0FBQUEsSUF5RklDLGVBQWUsR0FBRyxFQXpGdEI7QUFBQSxJQTBGSUMsY0FBYyxHQUFHLEVBMUZyQjtBQUFBLElBMkZJQyxRQUFRLEdBQUcsU0FBU0EsUUFBVCxDQUFrQnI4QixPQUFsQixFQUEyQjtBQUN4QyxNQUFJN2IsTUFBTSxHQUFHNmIsT0FBTyxDQUFDLENBQUQsQ0FBcEI7QUFBQSxNQUNJczhCLGFBREo7QUFBQSxNQUVJNTZDLENBRko7QUFHQTNDLEVBQUFBLFNBQVMsQ0FBQ29GLE1BQUQsQ0FBVCxJQUFxQnRGLFdBQVcsQ0FBQ3NGLE1BQUQsQ0FBaEMsS0FBNkM2YixPQUFPLEdBQUcsQ0FBQ0EsT0FBRCxDQUF2RDs7QUFFQSxNQUFJLEVBQUVzOEIsYUFBYSxHQUFHLENBQUNuNEMsTUFBTSxDQUFDME8sS0FBUCxJQUFnQixFQUFqQixFQUFxQnloQixPQUF2QyxDQUFKLEVBQXFEO0FBQ25EO0FBQ0E1eUIsSUFBQUEsQ0FBQyxHQUFHeTZDLGVBQWUsQ0FBQ3g2QyxNQUFwQjs7QUFFQSxXQUFPRCxDQUFDLE1BQU0sQ0FBQ3k2QyxlQUFlLENBQUN6NkMsQ0FBRCxDQUFmLENBQW1CNjZDLFVBQW5CLENBQThCcDRDLE1BQTlCLENBQWYsRUFBc0QsQ0FBRTs7QUFFeERtNEMsSUFBQUEsYUFBYSxHQUFHSCxlQUFlLENBQUN6NkMsQ0FBRCxDQUEvQjtBQUNEOztBQUVEQSxFQUFBQSxDQUFDLEdBQUdzZSxPQUFPLENBQUNyZSxNQUFaOztBQUVBLFNBQU9ELENBQUMsRUFBUixFQUFZO0FBQ1ZzZSxJQUFBQSxPQUFPLENBQUN0ZSxDQUFELENBQVAsS0FBZXNlLE9BQU8sQ0FBQ3RlLENBQUQsQ0FBUCxDQUFXbVIsS0FBWCxLQUFxQm1OLE9BQU8sQ0FBQ3RlLENBQUQsQ0FBUCxDQUFXbVIsS0FBWCxHQUFtQixJQUFJMnBDLE9BQUosQ0FBWXg4QixPQUFPLENBQUN0ZSxDQUFELENBQW5CLEVBQXdCNDZDLGFBQXhCLENBQXhDLENBQWYsS0FBbUd0OEIsT0FBTyxDQUFDdmQsTUFBUixDQUFlZixDQUFmLEVBQWtCLENBQWxCLENBQW5HO0FBQ0Q7O0FBRUQsU0FBT3NlLE9BQVA7QUFDRCxDQWpIRDtBQUFBLElBa0hJeThCLFNBQVMsR0FBRyxTQUFTQSxTQUFULENBQW1CdDRDLE1BQW5CLEVBQTJCO0FBQ3pDLFNBQU9BLE1BQU0sQ0FBQzBPLEtBQVAsSUFBZ0J3cEMsUUFBUSxDQUFDdHdDLE9BQU8sQ0FBQzVILE1BQUQsQ0FBUixDQUFSLENBQTBCLENBQTFCLEVBQTZCME8sS0FBcEQ7QUFDRCxDQXBIRDtBQUFBLElBcUhJNnBDLFlBQVksR0FBRyxTQUFTQSxZQUFULENBQXNCdjRDLE1BQXRCLEVBQThCZ0MsUUFBOUIsRUFBd0M2ckIsQ0FBeEMsRUFBMkM7QUFDNUQsU0FBTyxDQUFDQSxDQUFDLEdBQUc3dEIsTUFBTSxDQUFDZ0MsUUFBRCxDQUFYLEtBQTBCdEgsV0FBVyxDQUFDbXpCLENBQUQsQ0FBckMsR0FBMkM3dEIsTUFBTSxDQUFDZ0MsUUFBRCxDQUFOLEVBQTNDLEdBQWdFbkgsWUFBWSxDQUFDZ3pCLENBQUQsQ0FBWixJQUFtQjd0QixNQUFNLENBQUMyRyxZQUExQixJQUEwQzNHLE1BQU0sQ0FBQzJHLFlBQVAsQ0FBb0IzRSxRQUFwQixDQUExQyxJQUEyRTZyQixDQUFsSjtBQUNELENBdkhEO0FBQUEsSUF3SEkycUIsWUFBWSxHQUFHLFNBQVNBLFlBQVQsQ0FBc0JDLEtBQXRCLEVBQTZCMzZDLElBQTdCLEVBQW1DO0FBQ3BELFNBQU8sQ0FBQzI2QyxLQUFLLEdBQUdBLEtBQUssQ0FBQzlzQyxLQUFOLENBQVksR0FBWixDQUFULEVBQTJCOU4sT0FBM0IsQ0FBbUNDLElBQW5DLEtBQTRDMjZDLEtBQW5EO0FBQ0QsQ0ExSEQ7QUFBQSxJQTJISTtBQUNKeDlDLE1BQU0sR0FBRyxTQUFTQSxNQUFULENBQWdCTixLQUFoQixFQUF1QjtBQUM5QixTQUFPTyxJQUFJLENBQUNDLEtBQUwsQ0FBV1IsS0FBSyxHQUFHLE1BQW5CLElBQTZCLE1BQTdCLElBQXVDLENBQTlDO0FBQ0QsQ0E5SEQ7QUFBQSxJQStISWlqQixhQUFhLEdBQUcsU0FBU0EsYUFBVCxDQUF1QmpqQixLQUF2QixFQUE4QjtBQUNoRCxTQUFPTyxJQUFJLENBQUNDLEtBQUwsQ0FBV1IsS0FBSyxHQUFHLFFBQW5CLElBQStCLFFBQS9CLElBQTJDLENBQWxEO0FBQ0QsQ0FqSUQ7QUFBQSxJQWtJSTtBQUNKKzlDLGNBQWMsR0FBRyxTQUFTQSxjQUFULENBQXdCOWpDLEtBQXhCLEVBQStCamEsS0FBL0IsRUFBc0M7QUFDckQsTUFBSWcrQyxRQUFRLEdBQUdoK0MsS0FBSyxDQUFDaXZCLE1BQU4sQ0FBYSxDQUFiLENBQWY7QUFBQSxNQUNJcmpCLEdBQUcsR0FBR1osVUFBVSxDQUFDaEwsS0FBSyxDQUFDZ3ZCLE1BQU4sQ0FBYSxDQUFiLENBQUQsQ0FEcEI7QUFFQS9VLEVBQUFBLEtBQUssR0FBR2pQLFVBQVUsQ0FBQ2lQLEtBQUQsQ0FBbEI7QUFDQSxTQUFPK2pDLFFBQVEsS0FBSyxHQUFiLEdBQW1CL2pDLEtBQUssR0FBR3JPLEdBQTNCLEdBQWlDb3lDLFFBQVEsS0FBSyxHQUFiLEdBQW1CL2pDLEtBQUssR0FBR3JPLEdBQTNCLEdBQWlDb3lDLFFBQVEsS0FBSyxHQUFiLEdBQW1CL2pDLEtBQUssR0FBR3JPLEdBQTNCLEdBQWlDcU8sS0FBSyxHQUFHck8sR0FBbEg7QUFDRCxDQXhJRDtBQUFBLElBeUlJcXlDLGlCQUFpQixHQUFHLFNBQVNBLGlCQUFULENBQTJCQyxRQUEzQixFQUFxQ0MsTUFBckMsRUFBNkM7QUFDbkU7QUFDQSxNQUFJeHlDLENBQUMsR0FBR3d5QyxNQUFNLENBQUN0N0MsTUFBZjtBQUFBLE1BQ0lELENBQUMsR0FBRyxDQURSOztBQUdBLFNBQU9zN0MsUUFBUSxDQUFDN3RDLE9BQVQsQ0FBaUI4dEMsTUFBTSxDQUFDdjdDLENBQUQsQ0FBdkIsSUFBOEIsQ0FBOUIsSUFBbUMsRUFBRUEsQ0FBRixHQUFNK0ksQ0FBaEQsR0FBb0QsQ0FBRTs7QUFFdEQsU0FBTy9JLENBQUMsR0FBRytJLENBQVg7QUFDRCxDQWpKRDtBQUFBLElBa0pJeXlDLFdBQVcsR0FBRyxTQUFTQSxXQUFULEdBQXVCO0FBQ3ZDLE1BQUl6eUMsQ0FBQyxHQUFHb3hDLFdBQVcsQ0FBQ2w2QyxNQUFwQjtBQUFBLE1BQ0k2SSxDQUFDLEdBQUdxeEMsV0FBVyxDQUFDdDVCLEtBQVosQ0FBa0IsQ0FBbEIsQ0FEUjtBQUFBLE1BRUk3Z0IsQ0FGSjtBQUFBLE1BR0lrVyxLQUhKOztBQUtBa2tDLEVBQUFBLFdBQVcsR0FBRyxFQUFkO0FBQ0FELEVBQUFBLFdBQVcsQ0FBQ2w2QyxNQUFaLEdBQXFCLENBQXJCOztBQUVBLE9BQUtELENBQUMsR0FBRyxDQUFULEVBQVlBLENBQUMsR0FBRytJLENBQWhCLEVBQW1CL0ksQ0FBQyxFQUFwQixFQUF3QjtBQUN0QmtXLElBQUFBLEtBQUssR0FBR3BOLENBQUMsQ0FBQzlJLENBQUQsQ0FBVDtBQUNBa1csSUFBQUEsS0FBSyxJQUFJQSxLQUFLLENBQUN1bEMsS0FBZixLQUF5QnZsQyxLQUFLLENBQUMzQyxNQUFOLENBQWEyQyxLQUFLLENBQUN1bEMsS0FBTixDQUFZLENBQVosQ0FBYixFQUE2QnZsQyxLQUFLLENBQUN1bEMsS0FBTixDQUFZLENBQVosQ0FBN0IsRUFBNkMsSUFBN0MsRUFBbURBLEtBQW5ELEdBQTJELENBQXBGO0FBQ0Q7QUFDRixDQS9KRDtBQUFBLElBZ0tJQyxlQUFlLEdBQUcsU0FBU0EsZUFBVCxDQUF5QjVhLFNBQXpCLEVBQW9DbGxCLElBQXBDLEVBQTBDcEksY0FBMUMsRUFBMEQ5SCxLQUExRCxFQUFpRTtBQUNyRnl1QyxFQUFBQSxXQUFXLENBQUNsNkMsTUFBWixJQUFzQnU3QyxXQUFXLEVBQWpDO0FBQ0ExYSxFQUFBQSxTQUFTLENBQUN2dEIsTUFBVixDQUFpQnFJLElBQWpCLEVBQXVCcEksY0FBdkIsRUFBdUM5SCxLQUF2QztBQUNBeXVDLEVBQUFBLFdBQVcsQ0FBQ2w2QyxNQUFaLElBQXNCdTdDLFdBQVcsRUFBakMsQ0FIcUYsQ0FHaEQ7QUFDdEMsQ0FwS0Q7QUFBQSxJQXFLSUcsa0JBQWtCLEdBQUcsU0FBU0Esa0JBQVQsQ0FBNEJ2K0MsS0FBNUIsRUFBbUM7QUFDMUQsTUFBSTBYLENBQUMsR0FBRzFNLFVBQVUsQ0FBQ2hMLEtBQUQsQ0FBbEI7QUFDQSxTQUFPLENBQUMwWCxDQUFDLElBQUlBLENBQUMsS0FBSyxDQUFaLEtBQWtCLENBQUMxWCxLQUFLLEdBQUcsRUFBVCxFQUFhMm5CLEtBQWIsQ0FBbUJxMEIsa0JBQW5CLEVBQXVDbjVDLE1BQXZDLEdBQWdELENBQWxFLEdBQXNFNlUsQ0FBdEUsR0FBMEVnTCxTQUFTLENBQUMxaUIsS0FBRCxDQUFULEdBQW1CQSxLQUFLLENBQUN3K0MsSUFBTixFQUFuQixHQUFrQ3grQyxLQUFuSDtBQUNELENBeEtEO0FBQUEsSUF5S0l5NEIsWUFBWSxHQUFHLFNBQVNBLFlBQVQsQ0FBc0JsMkIsQ0FBdEIsRUFBeUI7QUFDMUMsU0FBT0EsQ0FBUDtBQUNELENBM0tEO0FBQUEsSUE0S0kyQixZQUFZLEdBQUcsU0FBU0EsWUFBVCxDQUFzQjlCLEdBQXRCLEVBQTJCSyxRQUEzQixFQUFxQztBQUN0RCxPQUFLLElBQUlGLENBQVQsSUFBY0UsUUFBZCxFQUF3QjtBQUN0QkYsSUFBQUEsQ0FBQyxJQUFJSCxHQUFMLEtBQWFBLEdBQUcsQ0FBQ0csQ0FBRCxDQUFILEdBQVNFLFFBQVEsQ0FBQ0YsQ0FBRCxDQUE5QjtBQUNEOztBQUVELFNBQU9ILEdBQVA7QUFDRCxDQWxMRDtBQUFBLElBbUxJcThDLG9CQUFvQixHQUFHLFNBQVNBLG9CQUFULENBQThCQyxlQUE5QixFQUErQztBQUN4RSxTQUFPLFVBQVV0OEMsR0FBVixFQUFlSyxRQUFmLEVBQXlCO0FBQzlCLFNBQUssSUFBSUYsQ0FBVCxJQUFjRSxRQUFkLEVBQXdCO0FBQ3RCRixNQUFBQSxDQUFDLElBQUlILEdBQUwsSUFBWUcsQ0FBQyxLQUFLLFVBQU4sSUFBb0JtOEMsZUFBaEMsSUFBbURuOEMsQ0FBQyxLQUFLLE1BQXpELEtBQW9FSCxHQUFHLENBQUNHLENBQUQsQ0FBSCxHQUFTRSxRQUFRLENBQUNGLENBQUQsQ0FBckY7QUFDRDtBQUNGLEdBSkQ7QUFLRCxDQXpMRDtBQUFBLElBMExJaTZDLE1BQU0sR0FBRyxTQUFTQSxNQUFULENBQWdCbUMsSUFBaEIsRUFBc0JDLE9BQXRCLEVBQStCO0FBQzFDLE9BQUssSUFBSXI4QyxDQUFULElBQWNxOEMsT0FBZCxFQUF1QjtBQUNyQkQsSUFBQUEsSUFBSSxDQUFDcDhDLENBQUQsQ0FBSixHQUFVcThDLE9BQU8sQ0FBQ3I4QyxDQUFELENBQWpCO0FBQ0Q7O0FBRUQsU0FBT284QyxJQUFQO0FBQ0QsQ0FoTUQ7QUFBQSxJQWlNSUUsVUFBVSxHQUFHLFNBQVNBLFVBQVQsQ0FBb0JGLElBQXBCLEVBQTBCQyxPQUExQixFQUFtQztBQUNsRCxPQUFLLElBQUlyOEMsQ0FBVCxJQUFjcThDLE9BQWQsRUFBdUI7QUFDckJyOEMsSUFBQUEsQ0FBQyxLQUFLLFdBQU4sSUFBcUJBLENBQUMsS0FBSyxhQUEzQixJQUE0Q0EsQ0FBQyxLQUFLLFdBQWxELEtBQWtFbzhDLElBQUksQ0FBQ3A4QyxDQUFELENBQUosR0FBVXRDLFNBQVMsQ0FBQzIrQyxPQUFPLENBQUNyOEMsQ0FBRCxDQUFSLENBQVQsR0FBd0JzOEMsVUFBVSxDQUFDRixJQUFJLENBQUNwOEMsQ0FBRCxDQUFKLEtBQVlvOEMsSUFBSSxDQUFDcDhDLENBQUQsQ0FBSixHQUFVLEVBQXRCLENBQUQsRUFBNEJxOEMsT0FBTyxDQUFDcjhDLENBQUQsQ0FBbkMsQ0FBbEMsR0FBNEVxOEMsT0FBTyxDQUFDcjhDLENBQUQsQ0FBL0o7QUFDRDs7QUFFRCxTQUFPbzhDLElBQVA7QUFDRCxDQXZNRDtBQUFBLElBd01JRyxjQUFjLEdBQUcsU0FBU0EsY0FBVCxDQUF3QjE4QyxHQUF4QixFQUE2QjI4QyxTQUE3QixFQUF3QztBQUMzRCxNQUFJejhDLElBQUksR0FBRyxFQUFYO0FBQUEsTUFDSUMsQ0FESjs7QUFHQSxPQUFLQSxDQUFMLElBQVVILEdBQVYsRUFBZTtBQUNiRyxJQUFBQSxDQUFDLElBQUl3OEMsU0FBTCxLQUFtQno4QyxJQUFJLENBQUNDLENBQUQsQ0FBSixHQUFVSCxHQUFHLENBQUNHLENBQUQsQ0FBaEM7QUFDRDs7QUFFRCxTQUFPRCxJQUFQO0FBQ0QsQ0FqTkQ7QUFBQSxJQWtOSTA4QyxnQkFBZ0IsR0FBRyxTQUFTQSxnQkFBVCxDQUEwQmwyQyxJQUExQixFQUFnQztBQUNyRCxNQUFJNkgsTUFBTSxHQUFHN0gsSUFBSSxDQUFDNkgsTUFBTCxJQUFldXJDLGVBQTVCO0FBQUEsTUFDSS80QyxJQUFJLEdBQUcyRixJQUFJLENBQUNtMkMsU0FBTCxHQUFpQlIsb0JBQW9CLENBQUNoK0MsUUFBUSxDQUFDcUksSUFBSSxDQUFDbTJDLFNBQU4sQ0FBVCxDQUFyQyxHQUFrRS82QyxZQUQ3RTs7QUFHQSxNQUFJcTNDLFdBQVcsQ0FBQ3p5QyxJQUFJLENBQUNvMkMsT0FBTixDQUFmLEVBQStCO0FBQzdCLFdBQU92dUMsTUFBUCxFQUFlO0FBQ2J4TixNQUFBQSxJQUFJLENBQUMyRixJQUFELEVBQU82SCxNQUFNLENBQUM3SCxJQUFQLENBQVlyRyxRQUFuQixDQUFKO0FBQ0FrTyxNQUFBQSxNQUFNLEdBQUdBLE1BQU0sQ0FBQ0EsTUFBUCxJQUFpQkEsTUFBTSxDQUFDdWtDLEdBQWpDO0FBQ0Q7QUFDRjs7QUFFRCxTQUFPcHNDLElBQVA7QUFDRCxDQTlORDtBQUFBLElBK05JcTJDLFlBQVksR0FBRyxTQUFTQSxZQUFULENBQXNCQyxFQUF0QixFQUEwQkMsRUFBMUIsRUFBOEI7QUFDL0MsTUFBSXo4QyxDQUFDLEdBQUd3OEMsRUFBRSxDQUFDdjhDLE1BQVg7QUFBQSxNQUNJOGtCLEtBQUssR0FBRy9rQixDQUFDLEtBQUt5OEMsRUFBRSxDQUFDeDhDLE1BRHJCOztBQUdBLFNBQU84a0IsS0FBSyxJQUFJL2tCLENBQUMsRUFBVixJQUFnQnc4QyxFQUFFLENBQUN4OEMsQ0FBRCxDQUFGLEtBQVV5OEMsRUFBRSxDQUFDejhDLENBQUQsQ0FBbkMsRUFBd0MsQ0FBRTs7QUFFMUMsU0FBT0EsQ0FBQyxHQUFHLENBQVg7QUFDRCxDQXRPRDtBQUFBLElBdU9JMDhDLGtCQUFrQixHQUFHLFNBQVNBLGtCQUFULENBQTRCM3VDLE1BQTVCLEVBQW9DRixLQUFwQyxFQUEyQzh1QyxTQUEzQyxFQUFzREMsUUFBdEQsRUFBZ0VDLE1BQWhFLEVBQXdFO0FBQy9GLE1BQUlGLFNBQVMsS0FBSyxLQUFLLENBQXZCLEVBQTBCO0FBQ3hCQSxJQUFBQSxTQUFTLEdBQUcsUUFBWjtBQUNEOztBQUVELE1BQUlDLFFBQVEsS0FBSyxLQUFLLENBQXRCLEVBQXlCO0FBQ3ZCQSxJQUFBQSxRQUFRLEdBQUcsT0FBWDtBQUNEOztBQUVELE1BQUlFLElBQUksR0FBRy91QyxNQUFNLENBQUM2dUMsUUFBRCxDQUFqQjtBQUFBLE1BQ0luOEIsQ0FESjs7QUFHQSxNQUFJbzhCLE1BQUosRUFBWTtBQUNWcDhCLElBQUFBLENBQUMsR0FBRzVTLEtBQUssQ0FBQ2d2QyxNQUFELENBQVQ7O0FBRUEsV0FBT0MsSUFBSSxJQUFJQSxJQUFJLENBQUNELE1BQUQsQ0FBSixHQUFlcDhCLENBQTlCLEVBQWlDO0FBQy9CcThCLE1BQUFBLElBQUksR0FBR0EsSUFBSSxDQUFDQyxLQUFaO0FBQ0Q7QUFDRjs7QUFFRCxNQUFJRCxJQUFKLEVBQVU7QUFDUmp2QyxJQUFBQSxLQUFLLENBQUN3bUIsS0FBTixHQUFjeW9CLElBQUksQ0FBQ3pvQixLQUFuQjtBQUNBeW9CLElBQUFBLElBQUksQ0FBQ3pvQixLQUFMLEdBQWF4bUIsS0FBYjtBQUNELEdBSEQsTUFHTztBQUNMQSxJQUFBQSxLQUFLLENBQUN3bUIsS0FBTixHQUFjdG1CLE1BQU0sQ0FBQzR1QyxTQUFELENBQXBCO0FBQ0E1dUMsSUFBQUEsTUFBTSxDQUFDNHVDLFNBQUQsQ0FBTixHQUFvQjl1QyxLQUFwQjtBQUNEOztBQUVELE1BQUlBLEtBQUssQ0FBQ3dtQixLQUFWLEVBQWlCO0FBQ2Z4bUIsSUFBQUEsS0FBSyxDQUFDd21CLEtBQU4sQ0FBWTBvQixLQUFaLEdBQW9CbHZDLEtBQXBCO0FBQ0QsR0FGRCxNQUVPO0FBQ0xFLElBQUFBLE1BQU0sQ0FBQzZ1QyxRQUFELENBQU4sR0FBbUIvdUMsS0FBbkI7QUFDRDs7QUFFREEsRUFBQUEsS0FBSyxDQUFDa3ZDLEtBQU4sR0FBY0QsSUFBZDtBQUNBanZDLEVBQUFBLEtBQUssQ0FBQ0UsTUFBTixHQUFlRixLQUFLLENBQUN5a0MsR0FBTixHQUFZdmtDLE1BQTNCO0FBQ0EsU0FBT0YsS0FBUDtBQUNELENBNVFEO0FBQUEsSUE2UUltdkMscUJBQXFCLEdBQUcsU0FBU0EscUJBQVQsQ0FBK0JqdkMsTUFBL0IsRUFBdUNGLEtBQXZDLEVBQThDOHVDLFNBQTlDLEVBQXlEQyxRQUF6RCxFQUFtRTtBQUM3RixNQUFJRCxTQUFTLEtBQUssS0FBSyxDQUF2QixFQUEwQjtBQUN4QkEsSUFBQUEsU0FBUyxHQUFHLFFBQVo7QUFDRDs7QUFFRCxNQUFJQyxRQUFRLEtBQUssS0FBSyxDQUF0QixFQUF5QjtBQUN2QkEsSUFBQUEsUUFBUSxHQUFHLE9BQVg7QUFDRDs7QUFFRCxNQUFJRSxJQUFJLEdBQUdqdkMsS0FBSyxDQUFDa3ZDLEtBQWpCO0FBQUEsTUFDSTFNLElBQUksR0FBR3hpQyxLQUFLLENBQUN3bUIsS0FEakI7O0FBR0EsTUFBSXlvQixJQUFKLEVBQVU7QUFDUkEsSUFBQUEsSUFBSSxDQUFDem9CLEtBQUwsR0FBYWdjLElBQWI7QUFDRCxHQUZELE1BRU8sSUFBSXRpQyxNQUFNLENBQUM0dUMsU0FBRCxDQUFOLEtBQXNCOXVDLEtBQTFCLEVBQWlDO0FBQ3RDRSxJQUFBQSxNQUFNLENBQUM0dUMsU0FBRCxDQUFOLEdBQW9CdE0sSUFBcEI7QUFDRDs7QUFFRCxNQUFJQSxJQUFKLEVBQVU7QUFDUkEsSUFBQUEsSUFBSSxDQUFDME0sS0FBTCxHQUFhRCxJQUFiO0FBQ0QsR0FGRCxNQUVPLElBQUkvdUMsTUFBTSxDQUFDNnVDLFFBQUQsQ0FBTixLQUFxQi91QyxLQUF6QixFQUFnQztBQUNyQ0UsSUFBQUEsTUFBTSxDQUFDNnVDLFFBQUQsQ0FBTixHQUFtQkUsSUFBbkI7QUFDRDs7QUFFRGp2QyxFQUFBQSxLQUFLLENBQUN3bUIsS0FBTixHQUFjeG1CLEtBQUssQ0FBQ2t2QyxLQUFOLEdBQWNsdkMsS0FBSyxDQUFDRSxNQUFOLEdBQWUsSUFBM0MsQ0F4QjZGLENBd0I1QztBQUNsRCxDQXRTRDtBQUFBLElBdVNJa3ZDLGlCQUFpQixHQUFHLFNBQVNBLGlCQUFULENBQTJCcHZDLEtBQTNCLEVBQWtDcXZDLHlCQUFsQyxFQUE2RDtBQUNuRnJ2QyxFQUFBQSxLQUFLLENBQUNFLE1BQU4sS0FBaUIsQ0FBQ212Qyx5QkFBRCxJQUE4QnJ2QyxLQUFLLENBQUNFLE1BQU4sQ0FBYW92QyxrQkFBNUQsS0FBbUZ0dkMsS0FBSyxDQUFDRSxNQUFOLENBQWFsTixNQUFiLENBQW9CZ04sS0FBcEIsQ0FBbkY7QUFDQUEsRUFBQUEsS0FBSyxDQUFDdXZDLElBQU4sR0FBYSxDQUFiO0FBQ0QsQ0ExU0Q7QUFBQSxJQTJTSUMsUUFBUSxHQUFHLFNBQVNBLFFBQVQsQ0FBa0J2YyxTQUFsQixFQUE2Qmp6QixLQUE3QixFQUFvQztBQUNqRCxNQUFJaXpCLFNBQVMsS0FBSyxDQUFDanpCLEtBQUQsSUFBVUEsS0FBSyxDQUFDeXZDLElBQU4sR0FBYXhjLFNBQVMsQ0FBQ3ljLElBQWpDLElBQXlDMXZDLEtBQUssQ0FBQzJrQyxNQUFOLEdBQWUsQ0FBN0QsQ0FBYixFQUE4RTtBQUM1RTtBQUNBLFFBQUkxcEMsQ0FBQyxHQUFHZzRCLFNBQVI7O0FBRUEsV0FBT2g0QixDQUFQLEVBQVU7QUFDUkEsTUFBQUEsQ0FBQyxDQUFDc1osTUFBRixHQUFXLENBQVg7QUFDQXRaLE1BQUFBLENBQUMsR0FBR0EsQ0FBQyxDQUFDaUYsTUFBTjtBQUNEO0FBQ0Y7O0FBRUQsU0FBTyt5QixTQUFQO0FBQ0QsQ0F2VEQ7QUFBQSxJQXdUSTBjLGlCQUFpQixHQUFHLFNBQVNBLGlCQUFULENBQTJCMWMsU0FBM0IsRUFBc0M7QUFDNUQsTUFBSS95QixNQUFNLEdBQUcreUIsU0FBUyxDQUFDL3lCLE1BQXZCOztBQUVBLFNBQU9BLE1BQU0sSUFBSUEsTUFBTSxDQUFDQSxNQUF4QixFQUFnQztBQUM5QjtBQUNBQSxJQUFBQSxNQUFNLENBQUNxVSxNQUFQLEdBQWdCLENBQWhCO0FBQ0FyVSxJQUFBQSxNQUFNLENBQUMwdkMsYUFBUDtBQUNBMXZDLElBQUFBLE1BQU0sR0FBR0EsTUFBTSxDQUFDQSxNQUFoQjtBQUNEOztBQUVELFNBQU8reUIsU0FBUDtBQUNELENBblVEO0FBQUEsSUFvVUk0YyxxQkFBcUIsR0FBRyxTQUFTQSxxQkFBVCxDQUErQjVjLFNBQS9CLEVBQTBDO0FBQ3BFLFNBQU8sQ0FBQ0EsU0FBRCxJQUFjQSxTQUFTLENBQUM4VyxHQUFWLElBQWlCOEYscUJBQXFCLENBQUM1YyxTQUFTLENBQUMveUIsTUFBWCxDQUEzRDtBQUNELENBdFVEO0FBQUEsSUF1VUk0dkMscUJBQXFCLEdBQUcsU0FBU0EscUJBQVQsQ0FBK0I3YyxTQUEvQixFQUEwQztBQUNwRSxTQUFPQSxTQUFTLENBQUM4YyxPQUFWLEdBQW9CQyxlQUFlLENBQUMvYyxTQUFTLENBQUM0UixNQUFYLEVBQW1CNVIsU0FBUyxHQUFHQSxTQUFTLENBQUMzL0IsUUFBVixLQUF1QjIvQixTQUFTLENBQUNnZCxPQUFoRSxDQUFmLEdBQTBGaGQsU0FBOUcsR0FBMEgsQ0FBakk7QUFDRCxDQXpVRDtBQUFBLElBMFVJO0FBQ0orYyxlQUFlLEdBQUcsU0FBU0EsZUFBVCxDQUF5QkUsS0FBekIsRUFBZ0NDLGFBQWhDLEVBQStDO0FBQy9ELE1BQUlDLEtBQUssR0FBR3RnRCxJQUFJLENBQUN1Z0QsS0FBTCxDQUFXSCxLQUFLLElBQUlDLGFBQXBCLENBQVo7QUFDQSxTQUFPRCxLQUFLLElBQUlFLEtBQUssS0FBS0YsS0FBbkIsR0FBMkJFLEtBQUssR0FBRyxDQUFuQyxHQUF1Q0EsS0FBOUM7QUFDRCxDQTlVRDtBQUFBLElBK1VJRSx1QkFBdUIsR0FBRyxTQUFTQSx1QkFBVCxDQUFpQ0MsVUFBakMsRUFBNkN2d0MsS0FBN0MsRUFBb0Q7QUFDaEYsU0FBTyxDQUFDdXdDLFVBQVUsR0FBR3Z3QyxLQUFLLENBQUMya0MsTUFBcEIsSUFBOEIza0MsS0FBSyxDQUFDK3BDLEdBQXBDLElBQTJDL3BDLEtBQUssQ0FBQytwQyxHQUFOLElBQWEsQ0FBYixHQUFpQixDQUFqQixHQUFxQi9wQyxLQUFLLENBQUN1VSxNQUFOLEdBQWV2VSxLQUFLLENBQUM0dkMsYUFBTixFQUFmLEdBQXVDNXZDLEtBQUssQ0FBQzhrQyxLQUE3RyxDQUFQO0FBQ0QsQ0FqVkQ7QUFBQSxJQWtWSTBMLE9BQU8sR0FBRyxTQUFTQSxPQUFULENBQWlCdmQsU0FBakIsRUFBNEI7QUFDeEMsU0FBT0EsU0FBUyxDQUFDd2MsSUFBVixHQUFpQmo5QixhQUFhLENBQUN5Z0IsU0FBUyxDQUFDMFIsTUFBVixJQUFvQjFSLFNBQVMsQ0FBQzZSLEtBQVYsR0FBa0JoMUMsSUFBSSxDQUFDMmIsR0FBTCxDQUFTd25CLFNBQVMsQ0FBQzhXLEdBQVYsSUFBaUI5VyxTQUFTLENBQUN3ZCxJQUEzQixJQUFtQy9GLFFBQTVDLENBQWxCLElBQTJFLENBQS9GLENBQUQsQ0FBckM7QUFDRCxDQXBWRDtBQUFBLElBcVZJZ0csY0FBYyxHQUFHLFNBQVNBLGNBQVQsQ0FBd0J6ZCxTQUF4QixFQUFtQ0UsU0FBbkMsRUFBOEM7QUFDakU7QUFDQSxNQUFJanpCLE1BQU0sR0FBRyt5QixTQUFTLENBQUN3UixHQUF2Qjs7QUFFQSxNQUFJdmtDLE1BQU0sSUFBSUEsTUFBTSxDQUFDeXdDLGlCQUFqQixJQUFzQzFkLFNBQVMsQ0FBQzhXLEdBQXBELEVBQXlEO0FBQ3ZEOVcsSUFBQUEsU0FBUyxDQUFDMFIsTUFBVixHQUFtQm55QixhQUFhLENBQUN0UyxNQUFNLENBQUN3a0MsS0FBUCxJQUFnQnpSLFNBQVMsQ0FBQzhXLEdBQVYsR0FBZ0IsQ0FBaEIsR0FBb0I1VyxTQUFTLEdBQUdGLFNBQVMsQ0FBQzhXLEdBQTFDLEdBQWdELENBQUMsQ0FBQzlXLFNBQVMsQ0FBQzFlLE1BQVYsR0FBbUIwZSxTQUFTLENBQUMyYyxhQUFWLEVBQW5CLEdBQStDM2MsU0FBUyxDQUFDNlIsS0FBMUQsSUFBbUUzUixTQUFwRSxJQUFpRixDQUFDRixTQUFTLENBQUM4VyxHQUE1SixDQUFELENBQWhDOztBQUVBeUcsSUFBQUEsT0FBTyxDQUFDdmQsU0FBRCxDQUFQOztBQUVBL3lCLElBQUFBLE1BQU0sQ0FBQ3FVLE1BQVAsSUFBaUJpN0IsUUFBUSxDQUFDdHZDLE1BQUQsRUFBUyt5QixTQUFULENBQXpCLENBTHVELENBS1Q7QUFDL0M7O0FBRUQsU0FBT0EsU0FBUDtBQUNELENBbFdEOztBQW9XQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBMmQsY0FBYyxHQUFHLFNBQVNBLGNBQVQsQ0FBd0I1YixRQUF4QixFQUFrQ2gxQixLQUFsQyxFQUF5QztBQUN4RCxNQUFJNFMsQ0FBSjs7QUFFQSxNQUFJNVMsS0FBSyxDQUFDMGtDLEtBQU4sSUFBZTFrQyxLQUFLLENBQUNnaEMsUUFBTixJQUFrQixDQUFDaGhDLEtBQUssQ0FBQzB2QyxJQUE1QyxFQUFrRDtBQUNoRDtBQUNBOThCLElBQUFBLENBQUMsR0FBRzA5Qix1QkFBdUIsQ0FBQ3RiLFFBQVEsQ0FBQzZiLE9BQVQsRUFBRCxFQUFxQjd3QyxLQUFyQixDQUEzQjs7QUFFQSxRQUFJLENBQUNBLEtBQUssQ0FBQzB2QyxJQUFQLElBQWVsb0IsTUFBTSxDQUFDLENBQUQsRUFBSXhuQixLQUFLLENBQUM0dkMsYUFBTixFQUFKLEVBQTJCaDlCLENBQTNCLENBQU4sR0FBc0M1UyxLQUFLLENBQUM2a0MsTUFBNUMsR0FBcUQ2RixRQUF4RSxFQUFrRjtBQUNoRjFxQyxNQUFBQSxLQUFLLENBQUMwRixNQUFOLENBQWFrTixDQUFiLEVBQWdCLElBQWhCO0FBQ0Q7QUFDRixHQVZ1RCxDQVV0RDs7O0FBR0YsTUFBSTQ4QixRQUFRLENBQUN4YSxRQUFELEVBQVdoMUIsS0FBWCxDQUFSLENBQTBCeWtDLEdBQTFCLElBQWlDelAsUUFBUSxDQUFDZ00sUUFBMUMsSUFBc0RoTSxRQUFRLENBQUMwUCxLQUFULElBQWtCMVAsUUFBUSxDQUFDMGEsSUFBakYsSUFBeUYxYSxRQUFRLENBQUMrVSxHQUF0RyxFQUEyRztBQUN6RztBQUNBLFFBQUkvVSxRQUFRLENBQUMwYSxJQUFULEdBQWdCMWEsUUFBUSxDQUFDMWhDLFFBQVQsRUFBcEIsRUFBeUM7QUFDdkNzZixNQUFBQSxDQUFDLEdBQUdvaUIsUUFBSjs7QUFFQSxhQUFPcGlCLENBQUMsQ0FBQzZ4QixHQUFULEVBQWM7QUFDWjd4QixRQUFBQSxDQUFDLENBQUNpK0IsT0FBRixNQUFlLENBQWYsSUFBb0JqK0IsQ0FBQyxDQUFDdWdCLFNBQUYsQ0FBWXZnQixDQUFDLENBQUNpeUIsTUFBZCxDQUFwQixDQURZLENBQytCOztBQUUzQ2p5QixRQUFBQSxDQUFDLEdBQUdBLENBQUMsQ0FBQzZ4QixHQUFOO0FBQ0Q7QUFDRjs7QUFFRHpQLElBQUFBLFFBQVEsQ0FBQzhiLE1BQVQsR0FBa0IsQ0FBQ3BHLFFBQW5CLENBWnlHLENBWTVFO0FBQzlCO0FBQ0YsQ0F6WUQ7QUFBQSxJQTBZSXFHLGNBQWMsR0FBRyxTQUFTQSxjQUFULENBQXdCL2IsUUFBeEIsRUFBa0NoMUIsS0FBbEMsRUFBeUM3RCxRQUF6QyxFQUFtRDYwQyxVQUFuRCxFQUErRDtBQUNsRmh4QyxFQUFBQSxLQUFLLENBQUNFLE1BQU4sSUFBZ0JrdkMsaUJBQWlCLENBQUNwdkMsS0FBRCxDQUFqQztBQUNBQSxFQUFBQSxLQUFLLENBQUMya0MsTUFBTixHQUFlbnlCLGFBQWEsQ0FBQyxDQUFDTixTQUFTLENBQUMvVixRQUFELENBQVQsR0FBc0JBLFFBQXRCLEdBQWlDQSxRQUFRLElBQUk2NEIsUUFBUSxLQUFLeVcsZUFBekIsR0FBMkNuUSxjQUFjLENBQUN0RyxRQUFELEVBQVc3NEIsUUFBWCxFQUFxQjZELEtBQXJCLENBQXpELEdBQXVGZzFCLFFBQVEsQ0FBQzBQLEtBQWxJLElBQTJJMWtDLEtBQUssQ0FBQ2l4QyxNQUFsSixDQUE1QjtBQUNBanhDLEVBQUFBLEtBQUssQ0FBQ3l2QyxJQUFOLEdBQWFqOUIsYUFBYSxDQUFDeFMsS0FBSyxDQUFDMmtDLE1BQU4sSUFBZ0Iza0MsS0FBSyxDQUFDNHZDLGFBQU4sS0FBd0I5L0MsSUFBSSxDQUFDMmIsR0FBTCxDQUFTekwsS0FBSyxDQUFDa3hDLFNBQU4sRUFBVCxDQUF4QixJQUF1RCxDQUF2RSxDQUFELENBQTFCOztBQUVBckMsRUFBQUEsa0JBQWtCLENBQUM3WixRQUFELEVBQVdoMUIsS0FBWCxFQUFrQixRQUFsQixFQUE0QixPQUE1QixFQUFxQ2cxQixRQUFRLENBQUM1RCxLQUFULEdBQWlCLFFBQWpCLEdBQTRCLENBQWpFLENBQWxCOztBQUVBK2YsRUFBQUEsa0JBQWtCLENBQUNueEMsS0FBRCxDQUFsQixLQUE4QmcxQixRQUFRLENBQUNvYyxPQUFULEdBQW1CcHhDLEtBQWpEO0FBQ0FneEMsRUFBQUEsVUFBVSxJQUFJSixjQUFjLENBQUM1YixRQUFELEVBQVdoMUIsS0FBWCxDQUE1QjtBQUNBLFNBQU9nMUIsUUFBUDtBQUNELENBcFpEO0FBQUEsSUFxWklxYyxjQUFjLEdBQUcsU0FBU0EsY0FBVCxDQUF3QnBlLFNBQXhCLEVBQW1DeHdCLE9BQW5DLEVBQTRDO0FBQy9ELFNBQU8sQ0FBQ2lwQyxRQUFRLENBQUM5akIsYUFBVCxJQUEwQm9rQixjQUFjLENBQUMsZUFBRCxFQUFrQnZwQyxPQUFsQixDQUF6QyxLQUF3RWlwQyxRQUFRLENBQUM5akIsYUFBVCxDQUF1Qmw2QixNQUF2QixDQUE4QitVLE9BQTlCLEVBQXVDd3dCLFNBQXZDLENBQS9FO0FBQ0QsQ0F2WkQ7QUFBQSxJQXdaSXFlLGlCQUFpQixHQUFHLFNBQVNBLGlCQUFULENBQTJCanBDLEtBQTNCLEVBQWtDOHFCLFNBQWxDLEVBQTZDdDFCLEtBQTdDLEVBQW9EOEgsY0FBcEQsRUFBb0U7QUFDMUY0ckMsRUFBQUEsVUFBVSxDQUFDbHBDLEtBQUQsRUFBUThxQixTQUFSLENBQVY7O0FBRUEsTUFBSSxDQUFDOXFCLEtBQUssQ0FBQzI0QixRQUFYLEVBQXFCO0FBQ25CLFdBQU8sQ0FBUDtBQUNEOztBQUVELE1BQUksQ0FBQ25qQyxLQUFELElBQVV3SyxLQUFLLENBQUM4YyxHQUFoQixLQUF3QjljLEtBQUssQ0FBQ3FuQyxJQUFOLElBQWNybkMsS0FBSyxDQUFDaFEsSUFBTixDQUFXMkQsSUFBWCxLQUFvQixLQUFsQyxJQUEyQyxDQUFDcU0sS0FBSyxDQUFDcW5DLElBQVAsSUFBZXJuQyxLQUFLLENBQUNoUSxJQUFOLENBQVcyRCxJQUE3RixLQUFzR3d3QyxrQkFBa0IsS0FBS2dGLE9BQU8sQ0FBQzFZLEtBQXpJLEVBQWdKO0FBQzlJd1QsSUFBQUEsV0FBVyxDQUFDMTVDLElBQVosQ0FBaUJ5VixLQUFqQjs7QUFFQUEsSUFBQUEsS0FBSyxDQUFDdWxDLEtBQU4sR0FBYyxDQUFDemEsU0FBRCxFQUFZeHRCLGNBQVosQ0FBZDtBQUNBLFdBQU8sQ0FBUDtBQUNEO0FBQ0YsQ0FyYUQ7QUFBQSxJQXNhSThyQyw0QkFBNEIsR0FBRyxTQUFTQSw0QkFBVCxDQUFzQ250QixJQUF0QyxFQUE0QztBQUM3RSxNQUFJcGtCLE1BQU0sR0FBR29rQixJQUFJLENBQUNwa0IsTUFBbEI7QUFDQSxTQUFPQSxNQUFNLElBQUlBLE1BQU0sQ0FBQzZwQyxHQUFqQixJQUF3QjdwQyxNQUFNLENBQUM4Z0MsUUFBL0IsSUFBMkMsQ0FBQzlnQyxNQUFNLENBQUN3eEMsS0FBbkQsS0FBNkR4eEMsTUFBTSxDQUFDMndDLE9BQVAsS0FBbUIsQ0FBbkIsSUFBd0JZLDRCQUE0QixDQUFDdnhDLE1BQUQsQ0FBakgsQ0FBUDtBQUNELENBemFEO0FBQUEsSUEwYUk7QUFDSml4QyxrQkFBa0IsR0FBRyxTQUFTQSxrQkFBVCxDQUE0QjVlLEtBQTVCLEVBQW1DO0FBQ3RELE1BQUkvK0IsSUFBSSxHQUFHKytCLEtBQUssQ0FBQy8rQixJQUFqQjtBQUNBLFNBQU9BLElBQUksS0FBSyxhQUFULElBQTBCQSxJQUFJLEtBQUssU0FBMUM7QUFDRCxDQTlhRDtBQUFBLElBK2FJbStDLHdCQUF3QixHQUFHLFNBQVNBLHdCQUFULENBQWtDdHBDLEtBQWxDLEVBQXlDOHFCLFNBQXpDLEVBQW9EeHRCLGNBQXBELEVBQW9FOUgsS0FBcEUsRUFBMkU7QUFDeEcsTUFBSSt6QyxTQUFTLEdBQUd2cEMsS0FBSyxDQUFDZ0gsS0FBdEI7QUFBQSxNQUNJQSxLQUFLLEdBQUc4akIsU0FBUyxHQUFHLENBQVosSUFBaUIsQ0FBQ0EsU0FBRCxLQUFlLENBQUM5cUIsS0FBSyxDQUFDczhCLE1BQVAsSUFBaUI4TSw0QkFBNEIsQ0FBQ3BwQyxLQUFELENBQTdDLElBQXdELEVBQUUsQ0FBQ0EsS0FBSyxDQUFDMjRCLFFBQVAsSUFBbUJtUSxrQkFBa0IsQ0FBQzlvQyxLQUFELENBQXZDLENBQXhELElBQTJHLENBQUNBLEtBQUssQ0FBQzBoQyxHQUFOLEdBQVksQ0FBWixJQUFpQjFoQyxLQUFLLENBQUNvOEIsR0FBTixDQUFVc0YsR0FBVixHQUFnQixDQUFsQyxLQUF3QyxDQUFDb0gsa0JBQWtCLENBQUM5b0MsS0FBRCxDQUFyTCxDQUFqQixHQUFpTixDQUFqTixHQUFxTixDQURqTztBQUFBLE1BRUk7QUFDSndwQyxFQUFBQSxXQUFXLEdBQUd4cEMsS0FBSyxDQUFDNG5DLE9BSHBCO0FBQUEsTUFJSUMsS0FBSyxHQUFHLENBSlo7QUFBQSxNQUtJaHJCLEVBTEo7QUFBQSxNQU1JNHNCLFNBTko7QUFBQSxNQU9JQyxhQVBKOztBQVNBLE1BQUlGLFdBQVcsSUFBSXhwQyxLQUFLLENBQUMwbkMsT0FBekIsRUFBa0M7QUFDaEM7QUFDQUcsSUFBQUEsS0FBSyxHQUFHMW9CLE1BQU0sQ0FBQyxDQUFELEVBQUluZixLQUFLLENBQUN5OEIsS0FBVixFQUFpQjNSLFNBQWpCLENBQWQ7QUFDQTJlLElBQUFBLFNBQVMsR0FBRzlCLGVBQWUsQ0FBQ0UsS0FBRCxFQUFRMkIsV0FBUixDQUEzQjtBQUNBeHBDLElBQUFBLEtBQUssQ0FBQzJwQyxLQUFOLElBQWVGLFNBQVMsR0FBRyxDQUEzQixLQUFpQ3ppQyxLQUFLLEdBQUcsSUFBSUEsS0FBN0M7O0FBRUEsUUFBSXlpQyxTQUFTLEtBQUs5QixlQUFlLENBQUMzbkMsS0FBSyxDQUFDdzhCLE1BQVAsRUFBZWdOLFdBQWYsQ0FBakMsRUFBOEQ7QUFDNUQ7QUFDQUQsTUFBQUEsU0FBUyxHQUFHLElBQUl2aUMsS0FBaEI7QUFDQWhILE1BQUFBLEtBQUssQ0FBQ2hRLElBQU4sQ0FBVzQ1QyxhQUFYLElBQTRCNXBDLEtBQUssQ0FBQzI0QixRQUFsQyxJQUE4QzM0QixLQUFLLENBQUN1NkIsVUFBTixFQUE5QztBQUNEO0FBQ0Y7O0FBRUQsTUFBSXZ6QixLQUFLLEtBQUt1aUMsU0FBVixJQUF1Qi96QyxLQUF2QixJQUFnQ3dLLEtBQUssQ0FBQ3lvQyxNQUFOLEtBQWlCcEcsUUFBakQsSUFBNkQsQ0FBQ3ZYLFNBQUQsSUFBYzlxQixLQUFLLENBQUN5b0MsTUFBckYsRUFBNkY7QUFDM0YsUUFBSSxDQUFDem9DLEtBQUssQ0FBQzI0QixRQUFQLElBQW1Cc1EsaUJBQWlCLENBQUNqcEMsS0FBRCxFQUFROHFCLFNBQVIsRUFBbUJ0MUIsS0FBbkIsRUFBMEI4SCxjQUExQixDQUF4QyxFQUFtRjtBQUNqRjtBQUNBO0FBQ0Q7O0FBRURvc0MsSUFBQUEsYUFBYSxHQUFHMXBDLEtBQUssQ0FBQ3lvQyxNQUF0QjtBQUNBem9DLElBQUFBLEtBQUssQ0FBQ3lvQyxNQUFOLEdBQWUzZCxTQUFTLEtBQUt4dEIsY0FBYyxHQUFHK2tDLFFBQUgsR0FBYyxDQUFqQyxDQUF4QixDQVAyRixDQU85Qjs7QUFFN0Qva0MsSUFBQUEsY0FBYyxLQUFLQSxjQUFjLEdBQUd3dEIsU0FBUyxJQUFJLENBQUM0ZSxhQUFwQyxDQUFkLENBVDJGLENBU3pCOztBQUVsRTFwQyxJQUFBQSxLQUFLLENBQUNnSCxLQUFOLEdBQWNBLEtBQWQ7QUFDQWhILElBQUFBLEtBQUssQ0FBQzZwQyxLQUFOLEtBQWdCN2lDLEtBQUssR0FBRyxJQUFJQSxLQUE1QjtBQUNBaEgsSUFBQUEsS0FBSyxDQUFDcThCLEtBQU4sR0FBYyxDQUFkO0FBQ0FyOEIsSUFBQUEsS0FBSyxDQUFDdzhCLE1BQU4sR0FBZXFMLEtBQWY7QUFDQWhyQixJQUFBQSxFQUFFLEdBQUc3YyxLQUFLLENBQUM4YyxHQUFYOztBQUVBLFdBQU9ELEVBQVAsRUFBVztBQUNUQSxNQUFBQSxFQUFFLENBQUNudEIsQ0FBSCxDQUFLc1gsS0FBTCxFQUFZNlYsRUFBRSxDQUFDclksQ0FBZjtBQUNBcVksTUFBQUEsRUFBRSxHQUFHQSxFQUFFLENBQUNzQixLQUFSO0FBQ0Q7O0FBRURuZSxJQUFBQSxLQUFLLENBQUM4cEMsUUFBTixJQUFrQmhmLFNBQVMsR0FBRyxDQUE5QixJQUFtQzlxQixLQUFLLENBQUM4cEMsUUFBTixDQUFlenNDLE1BQWYsQ0FBc0J5dEIsU0FBdEIsRUFBaUMsSUFBakMsRUFBdUMsSUFBdkMsQ0FBbkM7QUFDQTlxQixJQUFBQSxLQUFLLENBQUMrcEMsU0FBTixJQUFtQixDQUFDenNDLGNBQXBCLElBQXNDdXRCLFNBQVMsQ0FBQzdxQixLQUFELEVBQVEsVUFBUixDQUEvQztBQUNBNm5DLElBQUFBLEtBQUssSUFBSTduQyxLQUFLLENBQUMwbkMsT0FBZixJQUEwQixDQUFDcHFDLGNBQTNCLElBQTZDMEMsS0FBSyxDQUFDbkksTUFBbkQsSUFBNkRnekIsU0FBUyxDQUFDN3FCLEtBQUQsRUFBUSxVQUFSLENBQXRFOztBQUVBLFFBQUksQ0FBQzhxQixTQUFTLElBQUk5cUIsS0FBSyxDQUFDeThCLEtBQW5CLElBQTRCM1IsU0FBUyxHQUFHLENBQXpDLEtBQStDOXFCLEtBQUssQ0FBQ2dILEtBQU4sS0FBZ0JBLEtBQW5FLEVBQTBFO0FBQ3hFQSxNQUFBQSxLQUFLLElBQUkrL0IsaUJBQWlCLENBQUMvbUMsS0FBRCxFQUFRLENBQVIsQ0FBMUI7O0FBRUEsVUFBSSxDQUFDMUMsY0FBTCxFQUFxQjtBQUNuQnV0QixRQUFBQSxTQUFTLENBQUM3cUIsS0FBRCxFQUFRZ0gsS0FBSyxHQUFHLFlBQUgsR0FBa0IsbUJBQS9CLEVBQW9ELElBQXBELENBQVQ7O0FBRUFoSCxRQUFBQSxLQUFLLENBQUNncUMsS0FBTixJQUFlaHFDLEtBQUssQ0FBQ2dxQyxLQUFOLEVBQWY7QUFDRDtBQUNGO0FBQ0YsR0FuQ0QsTUFtQ08sSUFBSSxDQUFDaHFDLEtBQUssQ0FBQ3lvQyxNQUFYLEVBQW1CO0FBQ3hCem9DLElBQUFBLEtBQUssQ0FBQ3lvQyxNQUFOLEdBQWUzZCxTQUFmO0FBQ0Q7QUFDRixDQTVlRDtBQUFBLElBNmVJbWYsbUJBQW1CLEdBQUcsU0FBU0EsbUJBQVQsQ0FBNkJyZixTQUE3QixFQUF3Q3NmLFFBQXhDLEVBQWtEeGtDLElBQWxELEVBQXdEO0FBQ2hGLE1BQUkvTixLQUFKOztBQUVBLE1BQUkrTixJQUFJLEdBQUd3a0MsUUFBWCxFQUFxQjtBQUNuQnZ5QyxJQUFBQSxLQUFLLEdBQUdpekIsU0FBUyxDQUFDdWYsTUFBbEI7O0FBRUEsV0FBT3h5QyxLQUFLLElBQUlBLEtBQUssQ0FBQzJrQyxNQUFOLElBQWdCNTJCLElBQWhDLEVBQXNDO0FBQ3BDLFVBQUkvTixLQUFLLENBQUN4TSxJQUFOLEtBQWUsU0FBZixJQUE0QndNLEtBQUssQ0FBQzJrQyxNQUFOLEdBQWU0TixRQUEvQyxFQUF5RDtBQUN2RCxlQUFPdnlDLEtBQVA7QUFDRDs7QUFFREEsTUFBQUEsS0FBSyxHQUFHQSxLQUFLLENBQUN3bUIsS0FBZDtBQUNEO0FBQ0YsR0FWRCxNQVVPO0FBQ0x4bUIsSUFBQUEsS0FBSyxHQUFHaXpCLFNBQVMsQ0FBQ3dmLEtBQWxCOztBQUVBLFdBQU96eUMsS0FBSyxJQUFJQSxLQUFLLENBQUMya0MsTUFBTixJQUFnQjUyQixJQUFoQyxFQUFzQztBQUNwQyxVQUFJL04sS0FBSyxDQUFDeE0sSUFBTixLQUFlLFNBQWYsSUFBNEJ3TSxLQUFLLENBQUMya0MsTUFBTixHQUFlNE4sUUFBL0MsRUFBeUQ7QUFDdkQsZUFBT3Z5QyxLQUFQO0FBQ0Q7O0FBRURBLE1BQUFBLEtBQUssR0FBR0EsS0FBSyxDQUFDa3ZDLEtBQWQ7QUFDRDtBQUNGO0FBQ0YsQ0FyZ0JEO0FBQUEsSUFzZ0JJd0QsWUFBWSxHQUFHLFNBQVNBLFlBQVQsQ0FBc0J6ZixTQUF0QixFQUFpQzMvQixRQUFqQyxFQUEyQ3EvQyxXQUEzQyxFQUF3REMsYUFBeEQsRUFBdUU7QUFDeEYsTUFBSUMsTUFBTSxHQUFHNWYsU0FBUyxDQUFDOGMsT0FBdkI7QUFBQSxNQUNJcEcsR0FBRyxHQUFHbjNCLGFBQWEsQ0FBQ2xmLFFBQUQsQ0FBYixJQUEyQixDQURyQztBQUFBLE1BRUl3dEMsYUFBYSxHQUFHN04sU0FBUyxDQUFDNFIsTUFBVixHQUFtQjVSLFNBQVMsQ0FBQzZSLEtBRmpEO0FBR0FoRSxFQUFBQSxhQUFhLElBQUksQ0FBQzhSLGFBQWxCLEtBQW9DM2YsU0FBUyxDQUFDeVIsS0FBVixJQUFtQmlGLEdBQUcsR0FBRzFXLFNBQVMsQ0FBQ3ljLElBQXZFO0FBQ0F6YyxFQUFBQSxTQUFTLENBQUN5YyxJQUFWLEdBQWlCL0YsR0FBakI7QUFDQTFXLEVBQUFBLFNBQVMsQ0FBQzZSLEtBQVYsR0FBa0IsQ0FBQytOLE1BQUQsR0FBVWxKLEdBQVYsR0FBZ0JrSixNQUFNLEdBQUcsQ0FBVCxHQUFhLElBQWIsR0FBb0JyZ0MsYUFBYSxDQUFDbTNCLEdBQUcsSUFBSWtKLE1BQU0sR0FBRyxDQUFiLENBQUgsR0FBcUI1ZixTQUFTLENBQUNnZCxPQUFWLEdBQW9CNEMsTUFBMUMsQ0FBbkU7QUFDQS9SLEVBQUFBLGFBQWEsR0FBRyxDQUFoQixJQUFxQixDQUFDOFIsYUFBdEIsR0FBc0NsQyxjQUFjLENBQUN6ZCxTQUFELEVBQVlBLFNBQVMsQ0FBQzRSLE1BQVYsR0FBbUI1UixTQUFTLENBQUM2UixLQUFWLEdBQWtCaEUsYUFBakQsQ0FBcEQsR0FBc0g3TixTQUFTLENBQUMveUIsTUFBVixJQUFvQnN3QyxPQUFPLENBQUN2ZCxTQUFELENBQWpKO0FBQ0EwZixFQUFBQSxXQUFXLElBQUluRCxRQUFRLENBQUN2YyxTQUFTLENBQUMveUIsTUFBWCxFQUFtQit5QixTQUFuQixDQUF2QjtBQUNBLFNBQU9BLFNBQVA7QUFDRCxDQWhoQkQ7QUFBQSxJQWloQkk2ZixzQkFBc0IsR0FBRyxTQUFTQSxzQkFBVCxDQUFnQzdmLFNBQWhDLEVBQTJDO0FBQ3RFLFNBQU9BLFNBQVMsWUFBWThmLFFBQXJCLEdBQWdDdkQsUUFBUSxDQUFDdmMsU0FBRCxDQUF4QyxHQUFzRHlmLFlBQVksQ0FBQ3pmLFNBQUQsRUFBWUEsU0FBUyxDQUFDeWMsSUFBdEIsQ0FBekU7QUFDRCxDQW5oQkQ7QUFBQSxJQW9oQklzRCxhQUFhLEdBQUc7QUFDbEJyTyxFQUFBQSxNQUFNLEVBQUUsQ0FEVTtBQUVsQnNPLEVBQUFBLE9BQU8sRUFBRXZqRCxVQUZTO0FBR2xCa2dELEVBQUFBLGFBQWEsRUFBRWxnRDtBQUhHLENBcGhCcEI7QUFBQSxJQXloQkk0ckMsY0FBYyxHQUFHLFNBQVNBLGNBQVQsQ0FBd0JySSxTQUF4QixFQUFtQzkyQixRQUFuQyxFQUE2QysyQyxnQkFBN0MsRUFBK0Q7QUFDbEYsTUFBSWplLE1BQU0sR0FBR2hDLFNBQVMsQ0FBQ2dDLE1BQXZCO0FBQUEsTUFDSWtlLE1BQU0sR0FBR2xnQixTQUFTLENBQUNtZSxPQUFWLElBQXFCNEIsYUFEbEM7QUFBQSxNQUVJSSxlQUFlLEdBQUduZ0IsU0FBUyxDQUFDMy9CLFFBQVYsTUFBd0J6QyxPQUF4QixHQUFrQ3NpRCxNQUFNLENBQUNGLE9BQVAsQ0FBZSxLQUFmLENBQWxDLEdBQTBEaGdCLFNBQVMsQ0FBQ3ljLElBRjFGO0FBQUEsTUFHSTtBQUNKdjlDLEVBQUFBLENBSkE7QUFBQSxNQUtJNEcsTUFMSjtBQUFBLE1BTUlzNkMsU0FOSjs7QUFRQSxNQUFJcGhDLFNBQVMsQ0FBQzlWLFFBQUQsQ0FBVCxLQUF3QndGLEtBQUssQ0FBQ3hGLFFBQUQsQ0FBTCxJQUFtQkEsUUFBUSxJQUFJODRCLE1BQXZELENBQUosRUFBb0U7QUFDbEU7QUFDQWw4QixJQUFBQSxNQUFNLEdBQUdvRCxRQUFRLENBQUNxaUIsTUFBVCxDQUFnQixDQUFoQixDQUFUO0FBQ0E2MEIsSUFBQUEsU0FBUyxHQUFHbDNDLFFBQVEsQ0FBQ29pQixNQUFULENBQWdCLENBQUMsQ0FBakIsTUFBd0IsR0FBcEM7QUFDQXBzQixJQUFBQSxDQUFDLEdBQUdnSyxRQUFRLENBQUN5RCxPQUFULENBQWlCLEdBQWpCLENBQUo7O0FBRUEsUUFBSTdHLE1BQU0sS0FBSyxHQUFYLElBQWtCQSxNQUFNLEtBQUssR0FBakMsRUFBc0M7QUFDcEM1RyxNQUFBQSxDQUFDLElBQUksQ0FBTCxLQUFXZ0ssUUFBUSxHQUFHQSxRQUFRLENBQUMzTCxPQUFULENBQWlCLEdBQWpCLEVBQXNCLEVBQXRCLENBQXRCO0FBQ0EsYUFBTyxDQUFDdUksTUFBTSxLQUFLLEdBQVgsR0FBaUJvNkMsTUFBTSxDQUFDeE8sTUFBeEIsR0FBaUN3TyxNQUFNLENBQUNGLE9BQVAsQ0FBZUUsTUFBTSxDQUFDcEQsT0FBUCxJQUFrQixDQUFqQyxDQUFsQyxJQUF5RSxDQUFDeDFDLFVBQVUsQ0FBQzRCLFFBQVEsQ0FBQ29pQixNQUFULENBQWdCLENBQWhCLENBQUQsQ0FBVixJQUFrQyxDQUFuQyxLQUF5QzgwQixTQUFTLEdBQUcsQ0FBQ2xoRCxDQUFDLEdBQUcsQ0FBSixHQUFRZ2hELE1BQVIsR0FBaUJELGdCQUFsQixFQUFvQ3RELGFBQXBDLEtBQXNELEdBQXpELEdBQStELENBQWpILENBQWhGO0FBQ0Q7O0FBRUQsUUFBSXo5QyxDQUFDLEdBQUcsQ0FBUixFQUFXO0FBQ1RnSyxNQUFBQSxRQUFRLElBQUk4NEIsTUFBWixLQUF1QkEsTUFBTSxDQUFDOTRCLFFBQUQsQ0FBTixHQUFtQmkzQyxlQUExQztBQUNBLGFBQU9uZSxNQUFNLENBQUM5NEIsUUFBRCxDQUFiO0FBQ0Q7O0FBRURwRCxJQUFBQSxNQUFNLEdBQUd3QixVQUFVLENBQUM0QixRQUFRLENBQUNxaUIsTUFBVCxDQUFnQnJzQixDQUFDLEdBQUcsQ0FBcEIsSUFBeUJnSyxRQUFRLENBQUNvaUIsTUFBVCxDQUFnQnBzQixDQUFDLEdBQUcsQ0FBcEIsQ0FBMUIsQ0FBbkI7O0FBRUEsUUFBSWtoRCxTQUFTLElBQUlILGdCQUFqQixFQUFtQztBQUNqQ242QyxNQUFBQSxNQUFNLEdBQUdBLE1BQU0sR0FBRyxHQUFULEdBQWUsQ0FBQy9JLFFBQVEsQ0FBQ2tqRCxnQkFBRCxDQUFSLEdBQTZCQSxnQkFBZ0IsQ0FBQyxDQUFELENBQTdDLEdBQW1EQSxnQkFBcEQsRUFBc0V0RCxhQUF0RSxFQUF4QjtBQUNEOztBQUVELFdBQU96OUMsQ0FBQyxHQUFHLENBQUosR0FBUW1wQyxjQUFjLENBQUNySSxTQUFELEVBQVk5MkIsUUFBUSxDQUFDb2lCLE1BQVQsQ0FBZ0IsQ0FBaEIsRUFBbUJwc0IsQ0FBQyxHQUFHLENBQXZCLENBQVosRUFBdUMrZ0QsZ0JBQXZDLENBQWQsR0FBeUVuNkMsTUFBakYsR0FBMEZxNkMsZUFBZSxHQUFHcjZDLE1BQW5IO0FBQ0Q7O0FBRUQsU0FBT29ELFFBQVEsSUFBSSxJQUFaLEdBQW1CaTNDLGVBQW5CLEdBQXFDLENBQUNqM0MsUUFBN0M7QUFDRCxDQTVqQkQ7QUFBQSxJQTZqQkltM0MsZ0JBQWdCLEdBQUcsU0FBU0EsZ0JBQVQsQ0FBMEJsakQsSUFBMUIsRUFBZ0NtakQsTUFBaEMsRUFBd0N2ZSxRQUF4QyxFQUFrRDtBQUN2RSxNQUFJd2UsUUFBUSxHQUFHdGhDLFNBQVMsQ0FBQ3FoQyxNQUFNLENBQUMsQ0FBRCxDQUFQLENBQXhCO0FBQUEsTUFDSUUsU0FBUyxHQUFHLENBQUNELFFBQVEsR0FBRyxDQUFILEdBQU8sQ0FBaEIsS0FBc0JwakQsSUFBSSxHQUFHLENBQVAsR0FBVyxDQUFYLEdBQWUsQ0FBckMsQ0FEaEI7QUFBQSxNQUVJaUksSUFBSSxHQUFHazdDLE1BQU0sQ0FBQ0UsU0FBRCxDQUZqQjtBQUFBLE1BR0lDLE1BSEo7QUFBQSxNQUlJeHpDLE1BSko7O0FBTUFzekMsRUFBQUEsUUFBUSxLQUFLbjdDLElBQUksQ0FBQy9FLFFBQUwsR0FBZ0JpZ0QsTUFBTSxDQUFDLENBQUQsQ0FBM0IsQ0FBUjtBQUNBbDdDLEVBQUFBLElBQUksQ0FBQzZILE1BQUwsR0FBYzgwQixRQUFkOztBQUVBLE1BQUk1a0MsSUFBSixFQUFVO0FBQ1JzakQsSUFBQUEsTUFBTSxHQUFHcjdDLElBQVQ7QUFDQTZILElBQUFBLE1BQU0sR0FBRzgwQixRQUFUOztBQUVBLFdBQU85MEIsTUFBTSxJQUFJLEVBQUUscUJBQXFCd3pDLE1BQXZCLENBQWpCLEVBQWlEO0FBQy9DO0FBQ0FBLE1BQUFBLE1BQU0sR0FBR3h6QyxNQUFNLENBQUM3SCxJQUFQLENBQVlyRyxRQUFaLElBQXdCLEVBQWpDO0FBQ0FrTyxNQUFBQSxNQUFNLEdBQUc0cUMsV0FBVyxDQUFDNXFDLE1BQU0sQ0FBQzdILElBQVAsQ0FBWW8yQyxPQUFiLENBQVgsSUFBb0N2dUMsTUFBTSxDQUFDQSxNQUFwRDtBQUNEOztBQUVEN0gsSUFBQUEsSUFBSSxDQUFDNG9DLGVBQUwsR0FBdUI2SixXQUFXLENBQUM0SSxNQUFNLENBQUN6UyxlQUFSLENBQWxDO0FBQ0E3d0MsSUFBQUEsSUFBSSxHQUFHLENBQVAsR0FBV2lJLElBQUksQ0FBQ3M3QyxZQUFMLEdBQW9CLENBQS9CLEdBQW1DdDdDLElBQUksQ0FBQ3U3QyxPQUFMLEdBQWVMLE1BQU0sQ0FBQ0UsU0FBUyxHQUFHLENBQWIsQ0FBeEQsQ0FYUSxDQVdpRTtBQUMxRTs7QUFFRCxTQUFPLElBQUlJLEtBQUosQ0FBVU4sTUFBTSxDQUFDLENBQUQsQ0FBaEIsRUFBcUJsN0MsSUFBckIsRUFBMkJrN0MsTUFBTSxDQUFDRSxTQUFTLEdBQUcsQ0FBYixDQUFqQyxDQUFQO0FBQ0QsQ0F0bEJEO0FBQUEsSUF1bEJJSyxrQkFBa0IsR0FBRyxTQUFTQSxrQkFBVCxDQUE0QnZrRCxLQUE1QixFQUFtQ21ELElBQW5DLEVBQXlDO0FBQ2hFLFNBQU9uRCxLQUFLLElBQUlBLEtBQUssS0FBSyxDQUFuQixHQUF1Qm1ELElBQUksQ0FBQ25ELEtBQUQsQ0FBM0IsR0FBcUNtRCxJQUE1QztBQUNELENBemxCRDtBQUFBLElBMGxCSTgwQixNQUFNLEdBQUcsU0FBU0EsTUFBVCxDQUFnQnh1QixHQUFoQixFQUFxQjlDLEdBQXJCLEVBQTBCM0csS0FBMUIsRUFBaUM7QUFDNUMsU0FBT0EsS0FBSyxHQUFHeUosR0FBUixHQUFjQSxHQUFkLEdBQW9CekosS0FBSyxHQUFHMkcsR0FBUixHQUFjQSxHQUFkLEdBQW9CM0csS0FBL0M7QUFDRCxDQTVsQkQ7QUFBQSxJQTZsQklvMkIsT0FBTyxHQUFHLFNBQVNBLE9BQVQsQ0FBaUJwMkIsS0FBakIsRUFBd0JrekIsQ0FBeEIsRUFBMkI7QUFDdkMsU0FBTyxDQUFDeFEsU0FBUyxDQUFDMWlCLEtBQUQsQ0FBVixJQUFxQixFQUFFa3pCLENBQUMsR0FBRytvQixRQUFRLENBQUN1SSxJQUFULENBQWN4a0QsS0FBZCxDQUFOLENBQXJCLEdBQW1ELEVBQW5ELEdBQXdEa3pCLENBQUMsQ0FBQyxDQUFELENBQWhFO0FBQ0QsQ0EvbEJEO0FBQUEsSUFnbUJJO0FBQ0oySSxLQUFLLEdBQUcsU0FBU0EsS0FBVCxDQUFlcHlCLEdBQWYsRUFBb0I5QyxHQUFwQixFQUF5QjNHLEtBQXpCLEVBQWdDO0FBQ3RDLFNBQU91a0Qsa0JBQWtCLENBQUN2a0QsS0FBRCxFQUFRLFVBQVVrekIsQ0FBVixFQUFhO0FBQzVDLFdBQU8rRSxNQUFNLENBQUN4dUIsR0FBRCxFQUFNOUMsR0FBTixFQUFXdXNCLENBQVgsQ0FBYjtBQUNELEdBRndCLENBQXpCO0FBR0QsQ0FybUJEO0FBQUEsSUFzbUJJdXhCLE1BQU0sR0FBRyxHQUFHaGhDLEtBdG1CaEI7QUFBQSxJQXVtQklpaEMsWUFBWSxHQUFHLFNBQVNBLFlBQVQsQ0FBc0Ixa0QsS0FBdEIsRUFBNkIya0QsUUFBN0IsRUFBdUM7QUFDeEQsU0FBTzNrRCxLQUFLLElBQUlDLFNBQVMsQ0FBQ0QsS0FBRCxDQUFsQixJQUE2QixZQUFZQSxLQUF6QyxLQUFtRCxDQUFDMmtELFFBQUQsSUFBYSxDQUFDM2tELEtBQUssQ0FBQzZDLE1BQXBCLElBQThCN0MsS0FBSyxDQUFDNkMsTUFBTixHQUFlLENBQWYsSUFBb0I3QyxLQUFwQixJQUE2QkMsU0FBUyxDQUFDRCxLQUFLLENBQUMsQ0FBRCxDQUFOLENBQXZILEtBQXNJLENBQUNBLEtBQUssQ0FBQ3FHLFFBQTdJLElBQXlKckcsS0FBSyxLQUFLdkIsSUFBMUs7QUFDRCxDQXptQkQ7QUFBQSxJQTBtQkltbUQsUUFBUSxHQUFHLFNBQVNBLFFBQVQsQ0FBa0JDLEVBQWxCLEVBQXNCQyxZQUF0QixFQUFvQ0MsV0FBcEMsRUFBaUQ7QUFDOUQsTUFBSUEsV0FBVyxLQUFLLEtBQUssQ0FBekIsRUFBNEI7QUFDMUJBLElBQUFBLFdBQVcsR0FBRyxFQUFkO0FBQ0Q7O0FBRUQsU0FBT0YsRUFBRSxDQUFDM2hELE9BQUgsQ0FBVyxVQUFVbEQsS0FBVixFQUFpQjtBQUNqQyxRQUFJZ2xELFlBQUo7O0FBRUEsV0FBT3RpQyxTQUFTLENBQUMxaUIsS0FBRCxDQUFULElBQW9CLENBQUM4a0QsWUFBckIsSUFBcUNKLFlBQVksQ0FBQzFrRCxLQUFELEVBQVEsQ0FBUixDQUFqRCxHQUE4RCxDQUFDZ2xELFlBQVksR0FBR0QsV0FBaEIsRUFBNkIxaEQsSUFBN0IsQ0FBa0M2RixLQUFsQyxDQUF3Qzg3QyxZQUF4QyxFQUFzRC8zQyxPQUFPLENBQUNqTixLQUFELENBQTdELENBQTlELEdBQXNJK2tELFdBQVcsQ0FBQzFoRCxJQUFaLENBQWlCckQsS0FBakIsQ0FBN0k7QUFDRCxHQUpNLEtBSUQra0QsV0FKTjtBQUtELENBcG5CRDtBQUFBLElBcW5CSTtBQUNKOTNDLE9BQU8sR0FBRyxTQUFTQSxPQUFULENBQWlCak4sS0FBakIsRUFBd0J1OEMsS0FBeEIsRUFBK0J1SSxZQUEvQixFQUE2QztBQUNyRCxTQUFPcGlDLFNBQVMsQ0FBQzFpQixLQUFELENBQVQsSUFBb0IsQ0FBQzhrRCxZQUFyQixLQUFzQy9sRCxZQUFZLElBQUksQ0FBQ2ttRCxLQUFLLEVBQTVELElBQWtFUixNQUFNLENBQUM1NEMsSUFBUCxDQUFZLENBQUMwd0MsS0FBSyxJQUFJNzlDLElBQVYsRUFBZ0J3bUQsZ0JBQWhCLENBQWlDbGxELEtBQWpDLENBQVosRUFBcUQsQ0FBckQsQ0FBbEUsR0FBNEhTLFFBQVEsQ0FBQ1QsS0FBRCxDQUFSLEdBQWtCNGtELFFBQVEsQ0FBQzVrRCxLQUFELEVBQVE4a0QsWUFBUixDQUExQixHQUFrREosWUFBWSxDQUFDMWtELEtBQUQsQ0FBWixHQUFzQnlrRCxNQUFNLENBQUM1NEMsSUFBUCxDQUFZN0wsS0FBWixFQUFtQixDQUFuQixDQUF0QixHQUE4Q0EsS0FBSyxHQUFHLENBQUNBLEtBQUQsQ0FBSCxHQUFhLEVBQXJQO0FBQ0QsQ0F4bkJEO0FBQUEsSUF5bkJJbWxELFFBQVEsR0FBRyxTQUFTQSxRQUFULENBQWtCbmxELEtBQWxCLEVBQXlCO0FBQ3RDQSxFQUFBQSxLQUFLLEdBQUdpTixPQUFPLENBQUNqTixLQUFELENBQVAsQ0FBZSxDQUFmLEtBQXFCMDhDLEtBQUssQ0FBQyxlQUFELENBQTFCLElBQStDLEVBQXZEO0FBQ0EsU0FBTyxVQUFVeHBCLENBQVYsRUFBYTtBQUNsQixRQUFJbUcsRUFBRSxHQUFHcjVCLEtBQUssQ0FBQ3l5QyxPQUFOLElBQWlCenlDLEtBQUssQ0FBQzB5QyxhQUF2QixJQUF3QzF5QyxLQUFqRDtBQUNBLFdBQU9pTixPQUFPLENBQUNpbUIsQ0FBRCxFQUFJbUcsRUFBRSxDQUFDNnJCLGdCQUFILEdBQXNCN3JCLEVBQXRCLEdBQTJCQSxFQUFFLEtBQUtyNUIsS0FBUCxHQUFlMDhDLEtBQUssQ0FBQyxlQUFELENBQUwsSUFBMEJoK0MsSUFBSSxDQUFDd0MsYUFBTCxDQUFtQixLQUFuQixDQUF6QyxHQUFxRWxCLEtBQXBHLENBQWQ7QUFDRCxHQUhEO0FBSUQsQ0EvbkJEO0FBQUEsSUFnb0JJb2xELE9BQU8sR0FBRyxTQUFTQSxPQUFULENBQWlCMTVDLENBQWpCLEVBQW9CO0FBQ2hDLFNBQU9BLENBQUMsQ0FBQ282QixJQUFGLENBQU8sWUFBWTtBQUN4QixXQUFPLEtBQUt2bEMsSUFBSSxDQUFDOGtELE1BQUwsRUFBWjtBQUNELEdBRk0sQ0FBUDtBQUdELENBcG9CRDtBQUFBLElBcW9CSTtBQUNKO0FBQ0FDLFVBQVUsR0FBRyxTQUFTQSxVQUFULENBQW9CcHlCLENBQXBCLEVBQXVCO0FBQ2xDLE1BQUluekIsV0FBVyxDQUFDbXpCLENBQUQsQ0FBZixFQUFvQjtBQUNsQixXQUFPQSxDQUFQO0FBQ0Q7O0FBRUQsTUFBSXBxQixJQUFJLEdBQUc3SSxTQUFTLENBQUNpekIsQ0FBRCxDQUFULEdBQWVBLENBQWYsR0FBbUI7QUFDNUJxeUIsSUFBQUEsSUFBSSxFQUFFcnlCO0FBRHNCLEdBQTlCO0FBQUEsTUFHSTtBQUNKb2UsRUFBQUEsSUFBSSxHQUFHa1UsVUFBVSxDQUFDMThDLElBQUksQ0FBQ3dvQyxJQUFOLENBSmpCO0FBQUEsTUFLSTN4QixJQUFJLEdBQUc3VyxJQUFJLENBQUM2VyxJQUFMLElBQWEsQ0FMeEI7QUFBQSxNQU1JZy9CLElBQUksR0FBRzN6QyxVQUFVLENBQUNsQyxJQUFJLENBQUM2MUMsSUFBTixDQUFWLElBQXlCLENBTnBDO0FBQUEsTUFPSXBwQixLQUFLLEdBQUcsRUFQWjtBQUFBLE1BUUlrd0IsU0FBUyxHQUFHOWxDLElBQUksR0FBRyxDQUFQLElBQVlBLElBQUksR0FBRyxDQVJuQztBQUFBLE1BU0krbEMsTUFBTSxHQUFHdHpDLEtBQUssQ0FBQ3VOLElBQUQsQ0FBTCxJQUFlOGxDLFNBVDVCO0FBQUEsTUFVSWwvQyxJQUFJLEdBQUd1QyxJQUFJLENBQUN2QyxJQVZoQjtBQUFBLE1BV0lvL0MsTUFBTSxHQUFHaG1DLElBWGI7QUFBQSxNQVlJaW1DLE1BQU0sR0FBR2ptQyxJQVpiOztBQWNBLE1BQUkrQyxTQUFTLENBQUMvQyxJQUFELENBQWIsRUFBcUI7QUFDbkJnbUMsSUFBQUEsTUFBTSxHQUFHQyxNQUFNLEdBQUc7QUFDaEI1ZSxNQUFBQSxNQUFNLEVBQUUsRUFEUTtBQUVoQjZlLE1BQUFBLEtBQUssRUFBRSxFQUZTO0FBR2hCajZDLE1BQUFBLEdBQUcsRUFBRTtBQUhXLE1BSWhCK1QsSUFKZ0IsS0FJUCxDQUpYO0FBS0QsR0FORCxNQU1PLElBQUksQ0FBQzhsQyxTQUFELElBQWNDLE1BQWxCLEVBQTBCO0FBQy9CQyxJQUFBQSxNQUFNLEdBQUdobUMsSUFBSSxDQUFDLENBQUQsQ0FBYjtBQUNBaW1DLElBQUFBLE1BQU0sR0FBR2ptQyxJQUFJLENBQUMsQ0FBRCxDQUFiO0FBQ0Q7O0FBRUQsU0FBTyxVQUFVL2MsQ0FBVixFQUFheUMsTUFBYixFQUFxQnFHLENBQXJCLEVBQXdCO0FBQzdCLFFBQUlDLENBQUMsR0FBRyxDQUFDRCxDQUFDLElBQUk1QyxJQUFOLEVBQVlqRyxNQUFwQjtBQUFBLFFBQ0lpakQsU0FBUyxHQUFHdndCLEtBQUssQ0FBQzVwQixDQUFELENBRHJCO0FBQUEsUUFFSW82QyxPQUZKO0FBQUEsUUFHSUMsT0FISjtBQUFBLFFBSUlsL0MsQ0FKSjtBQUFBLFFBS0lDLENBTEo7QUFBQSxRQU1JdVcsQ0FOSjtBQUFBLFFBT0k4TCxDQVBKO0FBQUEsUUFRSXppQixHQVJKO0FBQUEsUUFTSThDLEdBVEo7QUFBQSxRQVVJdzhDLE1BVko7O0FBWUEsUUFBSSxDQUFDSCxTQUFMLEVBQWdCO0FBQ2RHLE1BQUFBLE1BQU0sR0FBR245QyxJQUFJLENBQUNvOUMsSUFBTCxLQUFjLE1BQWQsR0FBdUIsQ0FBdkIsR0FBMkIsQ0FBQ3A5QyxJQUFJLENBQUNvOUMsSUFBTCxJQUFhLENBQUMsQ0FBRCxFQUFJNWtELE9BQUosQ0FBZCxFQUE0QixDQUE1QixDQUFwQzs7QUFFQSxVQUFJLENBQUMya0QsTUFBTCxFQUFhO0FBQ1h0L0MsUUFBQUEsR0FBRyxHQUFHLENBQUNyRixPQUFQOztBQUVBLGVBQU9xRixHQUFHLElBQUlBLEdBQUcsR0FBRytFLENBQUMsQ0FBQ3U2QyxNQUFNLEVBQVAsQ0FBRCxDQUFZdDlDLHFCQUFaLEdBQW9DZCxJQUE5QyxDQUFILElBQTBEbytDLE1BQU0sR0FBR3Q2QyxDQUExRSxFQUE2RSxDQUFFOztBQUUvRXM2QyxRQUFBQSxNQUFNO0FBQ1A7O0FBRURILE1BQUFBLFNBQVMsR0FBR3Z3QixLQUFLLENBQUM1cEIsQ0FBRCxDQUFMLEdBQVcsRUFBdkI7QUFDQW82QyxNQUFBQSxPQUFPLEdBQUdMLE1BQU0sR0FBR25sRCxJQUFJLENBQUNrSixHQUFMLENBQVN3OEMsTUFBVCxFQUFpQnQ2QyxDQUFqQixJQUFzQmc2QyxNQUF0QixHQUErQixFQUFsQyxHQUF1Q2htQyxJQUFJLEdBQUdzbUMsTUFBOUQ7QUFDQUQsTUFBQUEsT0FBTyxHQUFHQyxNQUFNLEtBQUsza0QsT0FBWCxHQUFxQixDQUFyQixHQUF5Qm9rRCxNQUFNLEdBQUcvNUMsQ0FBQyxHQUFHaTZDLE1BQUosR0FBYUssTUFBYixHQUFzQixFQUF6QixHQUE4QnRtQyxJQUFJLEdBQUdzbUMsTUFBUCxHQUFnQixDQUF2RjtBQUNBdC9DLE1BQUFBLEdBQUcsR0FBRyxDQUFOO0FBQ0E4QyxNQUFBQSxHQUFHLEdBQUduSSxPQUFOOztBQUVBLFdBQUs4bkIsQ0FBQyxHQUFHLENBQVQsRUFBWUEsQ0FBQyxHQUFHemQsQ0FBaEIsRUFBbUJ5ZCxDQUFDLEVBQXBCLEVBQXdCO0FBQ3RCdGlCLFFBQUFBLENBQUMsR0FBR3NpQixDQUFDLEdBQUc2OEIsTUFBSixHQUFhRixPQUFqQjtBQUNBaC9DLFFBQUFBLENBQUMsR0FBR2kvQyxPQUFPLElBQUk1OEIsQ0FBQyxHQUFHNjhCLE1BQUosR0FBYSxDQUFqQixDQUFYO0FBQ0FILFFBQUFBLFNBQVMsQ0FBQzE4QixDQUFELENBQVQsR0FBZTlMLENBQUMsR0FBRyxDQUFDL1csSUFBRCxHQUFRK2IsS0FBSyxDQUFDeGIsQ0FBQyxHQUFHQSxDQUFKLEdBQVFDLENBQUMsR0FBR0EsQ0FBYixDQUFiLEdBQStCeEcsSUFBSSxDQUFDMmIsR0FBTCxDQUFTM1YsSUFBSSxLQUFLLEdBQVQsR0FBZVEsQ0FBZixHQUFtQkQsQ0FBNUIsQ0FBbEQ7QUFDQXdXLFFBQUFBLENBQUMsR0FBRzNXLEdBQUosS0FBWUEsR0FBRyxHQUFHMlcsQ0FBbEI7QUFDQUEsUUFBQUEsQ0FBQyxHQUFHN1QsR0FBSixLQUFZQSxHQUFHLEdBQUc2VCxDQUFsQjtBQUNEOztBQUVEcUMsTUFBQUEsSUFBSSxLQUFLLFFBQVQsSUFBcUJ5bEMsT0FBTyxDQUFDVSxTQUFELENBQTVCO0FBQ0FBLE1BQUFBLFNBQVMsQ0FBQ24vQyxHQUFWLEdBQWdCQSxHQUFHLEdBQUc4QyxHQUF0QjtBQUNBcThDLE1BQUFBLFNBQVMsQ0FBQ3I4QyxHQUFWLEdBQWdCQSxHQUFoQjtBQUNBcThDLE1BQUFBLFNBQVMsQ0FBQzV5QixDQUFWLEdBQWN2bkIsQ0FBQyxHQUFHLENBQUNYLFVBQVUsQ0FBQ2xDLElBQUksQ0FBQ3E5QyxNQUFOLENBQVYsSUFBMkJuN0MsVUFBVSxDQUFDbEMsSUFBSSxDQUFDeThDLElBQU4sQ0FBVixJQUF5QlUsTUFBTSxHQUFHdDZDLENBQVQsR0FBYUEsQ0FBQyxHQUFHLENBQWpCLEdBQXFCLENBQUNwRixJQUFELEdBQVFoRyxJQUFJLENBQUNvRyxHQUFMLENBQVNzL0MsTUFBVCxFQUFpQnQ2QyxDQUFDLEdBQUdzNkMsTUFBckIsQ0FBUixHQUF1QzEvQyxJQUFJLEtBQUssR0FBVCxHQUFlb0YsQ0FBQyxHQUFHczZDLE1BQW5CLEdBQTRCQSxNQUFqSCxDQUEzQixJQUF1SixDQUF4SixLQUE4SnRtQyxJQUFJLEtBQUssT0FBVCxHQUFtQixDQUFDLENBQXBCLEdBQXdCLENBQXRMLENBQWxCO0FBQ0FtbUMsTUFBQUEsU0FBUyxDQUFDem9DLENBQVYsR0FBYzFSLENBQUMsR0FBRyxDQUFKLEdBQVFnekMsSUFBSSxHQUFHaHpDLENBQWYsR0FBbUJnekMsSUFBakM7QUFDQW1ILE1BQUFBLFNBQVMsQ0FBQ2p3QixDQUFWLEdBQWNPLE9BQU8sQ0FBQ3R0QixJQUFJLENBQUNxOUMsTUFBTCxJQUFlcjlDLElBQUksQ0FBQ3k4QyxJQUFyQixDQUFQLElBQXFDLENBQW5ELENBOUJjLENBOEJ3Qzs7QUFFdERqVSxNQUFBQSxJQUFJLEdBQUdBLElBQUksSUFBSTNsQyxDQUFDLEdBQUcsQ0FBWixHQUFnQnk2QyxXQUFXLENBQUM5VSxJQUFELENBQTNCLEdBQW9DQSxJQUEzQztBQUNEOztBQUVEM2xDLElBQUFBLENBQUMsR0FBRyxDQUFDbTZDLFNBQVMsQ0FBQ2xqRCxDQUFELENBQVQsR0FBZWtqRCxTQUFTLENBQUNyOEMsR0FBMUIsSUFBaUNxOEMsU0FBUyxDQUFDbi9DLEdBQTNDLElBQWtELENBQXREO0FBQ0EsV0FBT3NjLGFBQWEsQ0FBQzZpQyxTQUFTLENBQUN6b0MsQ0FBVixHQUFjLENBQUNpMEIsSUFBSSxHQUFHQSxJQUFJLENBQUMzbEMsQ0FBRCxDQUFQLEdBQWFBLENBQWxCLElBQXVCbTZDLFNBQVMsQ0FBQzV5QixDQUFoRCxDQUFiLEdBQWtFNHlCLFNBQVMsQ0FBQ2p3QixDQUFuRixDQWpENkIsQ0FpRHlEO0FBQ3ZGLEdBbEREO0FBbURELENBeHRCRDtBQUFBLElBeXRCSXd3QixjQUFjLEdBQUcsU0FBU0EsY0FBVCxDQUF3Qm56QixDQUF4QixFQUEyQjtBQUM5QztBQUNBLE1BQUkzd0IsQ0FBQyxHQUFHaEMsSUFBSSxDQUFDMndCLEdBQUwsQ0FBUyxFQUFULEVBQWEsQ0FBQyxDQUFDZ0MsQ0FBQyxHQUFHLEVBQUwsRUFBU2xpQixLQUFULENBQWUsR0FBZixFQUFvQixDQUFwQixLQUEwQixFQUEzQixFQUErQm5PLE1BQTVDLENBQVIsQ0FGOEMsQ0FFZTs7QUFFN0QsU0FBTyxVQUFVeWpELEdBQVYsRUFBZTtBQUNwQixRQUFJNXVDLENBQUMsR0FBR25YLElBQUksQ0FBQ0MsS0FBTCxDQUFXd0ssVUFBVSxDQUFDczdDLEdBQUQsQ0FBVixHQUFrQnB6QixDQUE3QixJQUFrQ0EsQ0FBbEMsR0FBc0Mzd0IsQ0FBOUM7QUFDQSxXQUFPLENBQUNtVixDQUFDLEdBQUdBLENBQUMsR0FBRyxDQUFULElBQWNuVixDQUFkLElBQW1Cb2dCLFNBQVMsQ0FBQzJqQyxHQUFELENBQVQsR0FBaUIsQ0FBakIsR0FBcUJsd0IsT0FBTyxDQUFDa3dCLEdBQUQsQ0FBL0MsQ0FBUCxDQUZvQixDQUUwQztBQUMvRCxHQUhEO0FBSUQsQ0FqdUJEO0FBQUEsSUFrdUJJOTZDLElBQUksR0FBRyxTQUFTQSxJQUFULENBQWNvbUMsTUFBZCxFQUFzQjV4QyxLQUF0QixFQUE2QjtBQUN0QyxNQUFJVyxPQUFPLEdBQUdGLFFBQVEsQ0FBQ214QyxNQUFELENBQXRCO0FBQUEsTUFDSTc1QixNQURKO0FBQUEsTUFFSXd1QyxJQUZKOztBQUlBLE1BQUksQ0FBQzVsRCxPQUFELElBQVlWLFNBQVMsQ0FBQzJ4QyxNQUFELENBQXpCLEVBQW1DO0FBQ2pDNzVCLElBQUFBLE1BQU0sR0FBR3BYLE9BQU8sR0FBR2l4QyxNQUFNLENBQUM3NUIsTUFBUCxJQUFpQnpXLE9BQXBDOztBQUVBLFFBQUlzd0MsTUFBTSxDQUFDM2UsTUFBWCxFQUFtQjtBQUNqQjJlLE1BQUFBLE1BQU0sR0FBRzNrQyxPQUFPLENBQUMya0MsTUFBTSxDQUFDM2UsTUFBUixDQUFoQjs7QUFFQSxVQUFJc3pCLElBQUksR0FBRyxDQUFDNWpDLFNBQVMsQ0FBQ2l2QixNQUFNLENBQUMsQ0FBRCxDQUFQLENBQXJCLEVBQWtDO0FBQ2hDNzVCLFFBQUFBLE1BQU0sSUFBSUEsTUFBVixDQURnQyxDQUNkO0FBQ25CO0FBQ0YsS0FORCxNQU1PO0FBQ0w2NUIsTUFBQUEsTUFBTSxHQUFHeVUsY0FBYyxDQUFDelUsTUFBTSxDQUFDNFUsU0FBUixDQUF2QjtBQUNEO0FBQ0Y7O0FBRUQsU0FBT2pDLGtCQUFrQixDQUFDdmtELEtBQUQsRUFBUSxDQUFDVyxPQUFELEdBQVcwbEQsY0FBYyxDQUFDelUsTUFBRCxDQUF6QixHQUFvQzd4QyxXQUFXLENBQUM2eEMsTUFBRCxDQUFYLEdBQXNCLFVBQVUwVSxHQUFWLEVBQWU7QUFDeEdDLElBQUFBLElBQUksR0FBRzNVLE1BQU0sQ0FBQzBVLEdBQUQsQ0FBYjtBQUNBLFdBQU8vbEQsSUFBSSxDQUFDMmIsR0FBTCxDQUFTcXFDLElBQUksR0FBR0QsR0FBaEIsS0FBd0J2dUMsTUFBeEIsR0FBaUN3dUMsSUFBakMsR0FBd0NELEdBQS9DO0FBQ0QsR0FIb0UsR0FHakUsVUFBVUEsR0FBVixFQUFlO0FBQ2pCLFFBQUl4L0MsQ0FBQyxHQUFHa0UsVUFBVSxDQUFDdTdDLElBQUksR0FBR0QsR0FBRyxDQUFDeC9DLENBQVAsR0FBV3cvQyxHQUFoQixDQUFsQjtBQUFBLFFBQ0l2L0MsQ0FBQyxHQUFHaUUsVUFBVSxDQUFDdTdDLElBQUksR0FBR0QsR0FBRyxDQUFDdi9DLENBQVAsR0FBVyxDQUFoQixDQURsQjtBQUFBLFFBRUkwQyxHQUFHLEdBQUduSSxPQUZWO0FBQUEsUUFHSXNXLE9BQU8sR0FBRyxDQUhkO0FBQUEsUUFJSWhWLENBQUMsR0FBR2d2QyxNQUFNLENBQUMvdUMsTUFKZjtBQUFBLFFBS0lvVixFQUxKO0FBQUEsUUFNSUMsRUFOSjs7QUFRQSxXQUFPdFYsQ0FBQyxFQUFSLEVBQVk7QUFDVixVQUFJMmpELElBQUosRUFBVTtBQUNSdHVDLFFBQUFBLEVBQUUsR0FBRzI1QixNQUFNLENBQUNodkMsQ0FBRCxDQUFOLENBQVVrRSxDQUFWLEdBQWNBLENBQW5CO0FBQ0FvUixRQUFBQSxFQUFFLEdBQUcwNUIsTUFBTSxDQUFDaHZDLENBQUQsQ0FBTixDQUFVbUUsQ0FBVixHQUFjQSxDQUFuQjtBQUNBa1IsUUFBQUEsRUFBRSxHQUFHQSxFQUFFLEdBQUdBLEVBQUwsR0FBVUMsRUFBRSxHQUFHQSxFQUFwQjtBQUNELE9BSkQsTUFJTztBQUNMRCxRQUFBQSxFQUFFLEdBQUcxWCxJQUFJLENBQUMyYixHQUFMLENBQVMwMUIsTUFBTSxDQUFDaHZDLENBQUQsQ0FBTixHQUFZa0UsQ0FBckIsQ0FBTDtBQUNEOztBQUVELFVBQUltUixFQUFFLEdBQUd4TyxHQUFULEVBQWM7QUFDWkEsUUFBQUEsR0FBRyxHQUFHd08sRUFBTjtBQUNBTCxRQUFBQSxPQUFPLEdBQUdoVixDQUFWO0FBQ0Q7QUFDRjs7QUFFRGdWLElBQUFBLE9BQU8sR0FBRyxDQUFDRyxNQUFELElBQVd0TyxHQUFHLElBQUlzTyxNQUFsQixHQUEyQjY1QixNQUFNLENBQUNoNkIsT0FBRCxDQUFqQyxHQUE2QzB1QyxHQUF2RDtBQUNBLFdBQU9DLElBQUksSUFBSTN1QyxPQUFPLEtBQUswdUMsR0FBcEIsSUFBMkIzakMsU0FBUyxDQUFDMmpDLEdBQUQsQ0FBcEMsR0FBNEMxdUMsT0FBNUMsR0FBc0RBLE9BQU8sR0FBR3dlLE9BQU8sQ0FBQ2t3QixHQUFELENBQTlFO0FBQ0QsR0E3QndCLENBQXpCO0FBOEJELENBbnhCRDtBQUFBLElBb3hCSWpCLE1BQU0sR0FBRyxTQUFTQSxNQUFULENBQWdCNTdDLEdBQWhCLEVBQXFCOUMsR0FBckIsRUFBMEI4L0MsaUJBQTFCLEVBQTZDQyxjQUE3QyxFQUE2RDtBQUN4RSxTQUFPbkMsa0JBQWtCLENBQUM5akQsUUFBUSxDQUFDZ0osR0FBRCxDQUFSLEdBQWdCLENBQUM5QyxHQUFqQixHQUF1QjgvQyxpQkFBaUIsS0FBSyxJQUF0QixHQUE2QixDQUFDLEVBQUVBLGlCQUFpQixHQUFHLENBQXRCLENBQTlCLEdBQXlELENBQUNDLGNBQWxGLEVBQWtHLFlBQVk7QUFDckksV0FBT2ptRCxRQUFRLENBQUNnSixHQUFELENBQVIsR0FBZ0JBLEdBQUcsQ0FBQyxDQUFDLEVBQUVsSixJQUFJLENBQUM4a0QsTUFBTCxLQUFnQjU3QyxHQUFHLENBQUM1RyxNQUF0QixDQUFGLENBQW5CLEdBQXNELENBQUM0akQsaUJBQWlCLEdBQUdBLGlCQUFpQixJQUFJLElBQTFDLE1BQW9EQyxjQUFjLEdBQUdELGlCQUFpQixHQUFHLENBQXBCLEdBQXdCbG1ELElBQUksQ0FBQzJ3QixHQUFMLENBQVMsRUFBVCxFQUFhLENBQUN1MUIsaUJBQWlCLEdBQUcsRUFBckIsRUFBeUI1akQsTUFBekIsR0FBa0MsQ0FBL0MsQ0FBeEIsR0FBNEUsQ0FBakosS0FBdUp0QyxJQUFJLENBQUN1Z0QsS0FBTCxDQUFXdmdELElBQUksQ0FBQ0MsS0FBTCxDQUFXLENBQUNpSixHQUFHLEdBQUdnOUMsaUJBQWlCLEdBQUcsQ0FBMUIsR0FBOEJsbUQsSUFBSSxDQUFDOGtELE1BQUwsTUFBaUIxK0MsR0FBRyxHQUFHOEMsR0FBTixHQUFZZzlDLGlCQUFpQixHQUFHLEdBQWpELENBQS9CLElBQXdGQSxpQkFBbkcsSUFBd0hBLGlCQUF4SCxHQUE0SUMsY0FBdkosSUFBeUtBLGNBQTdYO0FBQ0QsR0FGd0IsQ0FBekI7QUFHRCxDQXh4QkQ7QUFBQSxJQXl4QklDLElBQUksR0FBRyxTQUFTQSxJQUFULEdBQWdCO0FBQ3pCLE9BQUssSUFBSUMsSUFBSSxHQUFHcjRDLFNBQVMsQ0FBQzFMLE1BQXJCLEVBQTZCZ2tELFNBQVMsR0FBRyxJQUFJbm1ELEtBQUosQ0FBVWttRCxJQUFWLENBQXpDLEVBQTBERSxJQUFJLEdBQUcsQ0FBdEUsRUFBeUVBLElBQUksR0FBR0YsSUFBaEYsRUFBc0ZFLElBQUksRUFBMUYsRUFBOEY7QUFDNUZELElBQUFBLFNBQVMsQ0FBQ0MsSUFBRCxDQUFULEdBQWtCdjRDLFNBQVMsQ0FBQ3U0QyxJQUFELENBQTNCO0FBQ0Q7O0FBRUQsU0FBTyxVQUFVOW1ELEtBQVYsRUFBaUI7QUFDdEIsV0FBTzZtRCxTQUFTLENBQUNFLE1BQVYsQ0FBaUIsVUFBVTd6QixDQUFWLEVBQWEzVixDQUFiLEVBQWdCO0FBQ3RDLGFBQU9BLENBQUMsQ0FBQzJWLENBQUQsQ0FBUjtBQUNELEtBRk0sRUFFSmx6QixLQUZJLENBQVA7QUFHRCxHQUpEO0FBS0QsQ0FueUJEO0FBQUEsSUFveUJJZ25ELE9BQU8sR0FBRyxTQUFTQSxPQUFULENBQWlCN2pELElBQWpCLEVBQXVCaVIsSUFBdkIsRUFBNkI7QUFDekMsU0FBTyxVQUFVcFUsS0FBVixFQUFpQjtBQUN0QixXQUFPbUQsSUFBSSxDQUFDNkgsVUFBVSxDQUFDaEwsS0FBRCxDQUFYLENBQUosSUFBMkJvVSxJQUFJLElBQUlnaUIsT0FBTyxDQUFDcDJCLEtBQUQsQ0FBMUMsQ0FBUDtBQUNELEdBRkQ7QUFHRCxDQXh5QkQ7QUFBQSxJQXl5QklpbkQsU0FBUyxHQUFHLFNBQVNBLFNBQVQsQ0FBbUJ4OUMsR0FBbkIsRUFBd0I5QyxHQUF4QixFQUE2QjNHLEtBQTdCLEVBQW9DO0FBQ2xELFNBQU9rbkQsUUFBUSxDQUFDejlDLEdBQUQsRUFBTTlDLEdBQU4sRUFBVyxDQUFYLEVBQWMsQ0FBZCxFQUFpQjNHLEtBQWpCLENBQWY7QUFDRCxDQTN5QkQ7QUFBQSxJQTR5QkltbkQsVUFBVSxHQUFHLFNBQVNBLFVBQVQsQ0FBb0J6N0MsQ0FBcEIsRUFBdUIwN0MsT0FBdkIsRUFBZ0NwbkQsS0FBaEMsRUFBdUM7QUFDdEQsU0FBT3VrRCxrQkFBa0IsQ0FBQ3ZrRCxLQUFELEVBQVEsVUFBVXlrQixLQUFWLEVBQWlCO0FBQ2hELFdBQU8vWSxDQUFDLENBQUMsQ0FBQyxDQUFDMDdDLE9BQU8sQ0FBQzNpQyxLQUFELENBQVYsQ0FBUjtBQUNELEdBRndCLENBQXpCO0FBR0QsQ0FoekJEO0FBQUEsSUFpekJJNkQsSUFBSSxHQUFHLFNBQVNBLElBQVQsQ0FBYzdlLEdBQWQsRUFBbUI5QyxHQUFuQixFQUF3QjNHLEtBQXhCLEVBQStCO0FBQ3hDO0FBQ0EsTUFBSXFuRCxLQUFLLEdBQUcxZ0QsR0FBRyxHQUFHOEMsR0FBbEI7QUFDQSxTQUFPaEosUUFBUSxDQUFDZ0osR0FBRCxDQUFSLEdBQWdCMDlDLFVBQVUsQ0FBQzE5QyxHQUFELEVBQU02ZSxJQUFJLENBQUMsQ0FBRCxFQUFJN2UsR0FBRyxDQUFDNUcsTUFBUixDQUFWLEVBQTJCOEQsR0FBM0IsQ0FBMUIsR0FBNEQ0OUMsa0JBQWtCLENBQUN2a0QsS0FBRCxFQUFRLFVBQVVBLEtBQVYsRUFBaUI7QUFDNUcsV0FBTyxDQUFDcW5ELEtBQUssR0FBRyxDQUFDcm5ELEtBQUssR0FBR3lKLEdBQVQsSUFBZ0I0OUMsS0FBekIsSUFBa0NBLEtBQWxDLEdBQTBDNTlDLEdBQWpEO0FBQ0QsR0FGb0YsQ0FBckY7QUFHRCxDQXZ6QkQ7QUFBQSxJQXd6Qkk2OUMsUUFBUSxHQUFHLFNBQVNBLFFBQVQsQ0FBa0I3OUMsR0FBbEIsRUFBdUI5QyxHQUF2QixFQUE0QjNHLEtBQTVCLEVBQW1DO0FBQ2hELE1BQUlxbkQsS0FBSyxHQUFHMWdELEdBQUcsR0FBRzhDLEdBQWxCO0FBQUEsTUFDSTg5QyxLQUFLLEdBQUdGLEtBQUssR0FBRyxDQURwQjtBQUVBLFNBQU81bUQsUUFBUSxDQUFDZ0osR0FBRCxDQUFSLEdBQWdCMDlDLFVBQVUsQ0FBQzE5QyxHQUFELEVBQU02OUMsUUFBUSxDQUFDLENBQUQsRUFBSTc5QyxHQUFHLENBQUM1RyxNQUFKLEdBQWEsQ0FBakIsQ0FBZCxFQUFtQzhELEdBQW5DLENBQTFCLEdBQW9FNDlDLGtCQUFrQixDQUFDdmtELEtBQUQsRUFBUSxVQUFVQSxLQUFWLEVBQWlCO0FBQ3BIQSxJQUFBQSxLQUFLLEdBQUcsQ0FBQ3VuRCxLQUFLLEdBQUcsQ0FBQ3ZuRCxLQUFLLEdBQUd5SixHQUFULElBQWdCODlDLEtBQXpCLElBQWtDQSxLQUFsQyxJQUEyQyxDQUFuRDtBQUNBLFdBQU85OUMsR0FBRyxJQUFJekosS0FBSyxHQUFHcW5ELEtBQVIsR0FBZ0JFLEtBQUssR0FBR3ZuRCxLQUF4QixHQUFnQ0EsS0FBcEMsQ0FBVjtBQUNELEdBSDRGLENBQTdGO0FBSUQsQ0EvekJEO0FBQUEsSUFnMEJJd25ELGNBQWMsR0FBRyxTQUFTQSxjQUFULENBQXdCeG5ELEtBQXhCLEVBQStCO0FBQ2xEO0FBQ0EsTUFBSTAvQyxJQUFJLEdBQUcsQ0FBWDtBQUFBLE1BQ0luM0IsQ0FBQyxHQUFHLEVBRFI7QUFBQSxNQUVJM2xCLENBRko7QUFBQSxNQUdJNmtELElBSEo7QUFBQSxNQUlJNzdDLEdBSko7QUFBQSxNQUtJakwsT0FMSjs7QUFPQSxTQUFPLEVBQUVpQyxDQUFDLEdBQUc1QyxLQUFLLENBQUNxUSxPQUFOLENBQWMsU0FBZCxFQUF5QnF2QyxJQUF6QixDQUFOLENBQVAsRUFBOEM7QUFDNUM5ekMsSUFBQUEsR0FBRyxHQUFHNUwsS0FBSyxDQUFDcVEsT0FBTixDQUFjLEdBQWQsRUFBbUJ6TixDQUFuQixDQUFOO0FBQ0FqQyxJQUFBQSxPQUFPLEdBQUdYLEtBQUssQ0FBQ2l2QixNQUFOLENBQWFyc0IsQ0FBQyxHQUFHLENBQWpCLE1BQXdCLEdBQWxDO0FBQ0E2a0QsSUFBQUEsSUFBSSxHQUFHem5ELEtBQUssQ0FBQ2d2QixNQUFOLENBQWFwc0IsQ0FBQyxHQUFHLENBQWpCLEVBQW9CZ0osR0FBRyxHQUFHaEosQ0FBTixHQUFVLENBQTlCLEVBQWlDK2tCLEtBQWpDLENBQXVDaG5CLE9BQU8sR0FBR3E3QyxrQkFBSCxHQUF3QkosYUFBdEUsQ0FBUDtBQUNBcnpCLElBQUFBLENBQUMsSUFBSXZvQixLQUFLLENBQUNndkIsTUFBTixDQUFhMHdCLElBQWIsRUFBbUI5OEMsQ0FBQyxHQUFHODhDLElBQXZCLElBQStCMkYsTUFBTSxDQUFDMWtELE9BQU8sR0FBRzhtRCxJQUFILEdBQVUsQ0FBQ0EsSUFBSSxDQUFDLENBQUQsQ0FBdkIsRUFBNEI5bUQsT0FBTyxHQUFHLENBQUgsR0FBTyxDQUFDOG1ELElBQUksQ0FBQyxDQUFELENBQS9DLEVBQW9ELENBQUNBLElBQUksQ0FBQyxDQUFELENBQUwsSUFBWSxJQUFoRSxDQUExQztBQUNBL0gsSUFBQUEsSUFBSSxHQUFHOXpDLEdBQUcsR0FBRyxDQUFiO0FBQ0Q7O0FBRUQsU0FBTzJjLENBQUMsR0FBR3ZvQixLQUFLLENBQUNndkIsTUFBTixDQUFhMHdCLElBQWIsRUFBbUIxL0MsS0FBSyxDQUFDNkMsTUFBTixHQUFlNjhDLElBQWxDLENBQVg7QUFDRCxDQWwxQkQ7QUFBQSxJQW0xQkl3SCxRQUFRLEdBQUcsU0FBU0EsUUFBVCxDQUFrQlEsS0FBbEIsRUFBeUJDLEtBQXpCLEVBQWdDQyxNQUFoQyxFQUF3Q0MsTUFBeEMsRUFBZ0Q3bkQsS0FBaEQsRUFBdUQ7QUFDcEUsTUFBSThuRCxPQUFPLEdBQUdILEtBQUssR0FBR0QsS0FBdEI7QUFBQSxNQUNJSyxRQUFRLEdBQUdGLE1BQU0sR0FBR0QsTUFEeEI7QUFFQSxTQUFPckQsa0JBQWtCLENBQUN2a0QsS0FBRCxFQUFRLFVBQVVBLEtBQVYsRUFBaUI7QUFDaEQsV0FBTzRuRCxNQUFNLElBQUksQ0FBQzVuRCxLQUFLLEdBQUcwbkQsS0FBVCxJQUFrQkksT0FBbEIsR0FBNEJDLFFBQTVCLElBQXdDLENBQTVDLENBQWI7QUFDRCxHQUZ3QixDQUF6QjtBQUdELENBejFCRDtBQUFBLElBMDFCSUMsV0FBVyxHQUFHLFNBQVNBLFdBQVQsQ0FBcUIvdEMsS0FBckIsRUFBNEJyTyxHQUE1QixFQUFpQ29YLFFBQWpDLEVBQTJDaWxDLE1BQTNDLEVBQW1EO0FBQ25FLE1BQUk5a0QsSUFBSSxHQUFHaVAsS0FBSyxDQUFDNkgsS0FBSyxHQUFHck8sR0FBVCxDQUFMLEdBQXFCLENBQXJCLEdBQXlCLFVBQVVySixDQUFWLEVBQWE7QUFDL0MsV0FBTyxDQUFDLElBQUlBLENBQUwsSUFBVTBYLEtBQVYsR0FBa0IxWCxDQUFDLEdBQUdxSixHQUE3QjtBQUNELEdBRkQ7O0FBSUEsTUFBSSxDQUFDekksSUFBTCxFQUFXO0FBQ1QsUUFBSStrRCxRQUFRLEdBQUd4bEMsU0FBUyxDQUFDekksS0FBRCxDQUF4QjtBQUFBLFFBQ0lrdUMsTUFBTSxHQUFHLEVBRGI7QUFBQSxRQUVJNWxELENBRko7QUFBQSxRQUdJSyxDQUhKO0FBQUEsUUFJSXdsRCxhQUpKO0FBQUEsUUFLSXo4QyxDQUxKO0FBQUEsUUFNSTA4QyxFQU5KOztBQVFBcmxDLElBQUFBLFFBQVEsS0FBSyxJQUFiLEtBQXNCaWxDLE1BQU0sR0FBRyxDQUEvQixNQUFzQ2psQyxRQUFRLEdBQUcsSUFBakQ7O0FBRUEsUUFBSWtsQyxRQUFKLEVBQWM7QUFDWmp1QyxNQUFBQSxLQUFLLEdBQUc7QUFDTjFYLFFBQUFBLENBQUMsRUFBRTBYO0FBREcsT0FBUjtBQUdBck8sTUFBQUEsR0FBRyxHQUFHO0FBQ0pySixRQUFBQSxDQUFDLEVBQUVxSjtBQURDLE9BQU47QUFHRCxLQVBELE1BT08sSUFBSW5MLFFBQVEsQ0FBQ3daLEtBQUQsQ0FBUixJQUFtQixDQUFDeFosUUFBUSxDQUFDbUwsR0FBRCxDQUFoQyxFQUF1QztBQUM1Q3c4QyxNQUFBQSxhQUFhLEdBQUcsRUFBaEI7QUFDQXo4QyxNQUFBQSxDQUFDLEdBQUdzTyxLQUFLLENBQUNwWCxNQUFWO0FBQ0F3bEQsTUFBQUEsRUFBRSxHQUFHMThDLENBQUMsR0FBRyxDQUFUOztBQUVBLFdBQUsvSSxDQUFDLEdBQUcsQ0FBVCxFQUFZQSxDQUFDLEdBQUcrSSxDQUFoQixFQUFtQi9JLENBQUMsRUFBcEIsRUFBd0I7QUFDdEJ3bEQsUUFBQUEsYUFBYSxDQUFDL2tELElBQWQsQ0FBbUIya0QsV0FBVyxDQUFDL3RDLEtBQUssQ0FBQ3JYLENBQUMsR0FBRyxDQUFMLENBQU4sRUFBZXFYLEtBQUssQ0FBQ3JYLENBQUQsQ0FBcEIsQ0FBOUIsRUFEc0IsQ0FDbUM7QUFDMUQ7O0FBRUQrSSxNQUFBQSxDQUFDOztBQUVEeEksTUFBQUEsSUFBSSxHQUFHLFNBQVNBLElBQVQsQ0FBY1osQ0FBZCxFQUFpQjtBQUN0QkEsUUFBQUEsQ0FBQyxJQUFJb0osQ0FBTDtBQUNBLFlBQUkvSSxDQUFDLEdBQUdyQyxJQUFJLENBQUNrSixHQUFMLENBQVM0K0MsRUFBVCxFQUFhLENBQUMsQ0FBQzlsRCxDQUFmLENBQVI7QUFDQSxlQUFPNmxELGFBQWEsQ0FBQ3hsRCxDQUFELENBQWIsQ0FBaUJMLENBQUMsR0FBR0ssQ0FBckIsQ0FBUDtBQUNELE9BSkQ7O0FBTUFvZ0IsTUFBQUEsUUFBUSxHQUFHcFgsR0FBWDtBQUNELEtBbEJNLE1Ba0JBLElBQUksQ0FBQ3E4QyxNQUFMLEVBQWE7QUFDbEJodUMsTUFBQUEsS0FBSyxHQUFHdWlDLE1BQU0sQ0FBQy83QyxRQUFRLENBQUN3WixLQUFELENBQVIsR0FBa0IsRUFBbEIsR0FBdUIsRUFBeEIsRUFBNEJBLEtBQTVCLENBQWQ7QUFDRDs7QUFFRCxRQUFJLENBQUNtdUMsYUFBTCxFQUFvQjtBQUNsQixXQUFLN2xELENBQUwsSUFBVXFKLEdBQVYsRUFBZTtBQUNiMDhDLFFBQUFBLGFBQWEsQ0FBQ3o4QyxJQUFkLENBQW1CczhDLE1BQW5CLEVBQTJCbHVDLEtBQTNCLEVBQWtDMVgsQ0FBbEMsRUFBcUMsS0FBckMsRUFBNENxSixHQUFHLENBQUNySixDQUFELENBQS9DO0FBQ0Q7O0FBRURZLE1BQUFBLElBQUksR0FBRyxTQUFTQSxJQUFULENBQWNaLENBQWQsRUFBaUI7QUFDdEIsZUFBT2dtRCxpQkFBaUIsQ0FBQ2htRCxDQUFELEVBQUk0bEQsTUFBSixDQUFqQixLQUFpQ0QsUUFBUSxHQUFHanVDLEtBQUssQ0FBQzFYLENBQVQsR0FBYTBYLEtBQXRELENBQVA7QUFDRCxPQUZEO0FBR0Q7QUFDRjs7QUFFRCxTQUFPc3FDLGtCQUFrQixDQUFDdmhDLFFBQUQsRUFBVzdmLElBQVgsQ0FBekI7QUFDRCxDQW41QkQ7QUFBQSxJQW81QklxbEQsb0JBQW9CLEdBQUcsU0FBU0Esb0JBQVQsQ0FBOEIvaUIsUUFBOUIsRUFBd0NnakIsUUFBeEMsRUFBa0RDLFFBQWxELEVBQTREO0FBQ3JGO0FBQ0EsTUFBSWhqQixNQUFNLEdBQUdELFFBQVEsQ0FBQ0MsTUFBdEI7QUFBQSxNQUNJajhCLEdBQUcsR0FBR25JLE9BRFY7QUFBQSxNQUVJaUIsQ0FGSjtBQUFBLE1BR0lvbUQsUUFISjtBQUFBLE1BSUlwVSxLQUpKOztBQU1BLE9BQUtoeUMsQ0FBTCxJQUFVbWpDLE1BQVYsRUFBa0I7QUFDaEJpakIsSUFBQUEsUUFBUSxHQUFHampCLE1BQU0sQ0FBQ25qQyxDQUFELENBQU4sR0FBWWttRCxRQUF2Qjs7QUFFQSxRQUFJRSxRQUFRLEdBQUcsQ0FBWCxLQUFpQixDQUFDLENBQUNELFFBQW5CLElBQStCQyxRQUEvQixJQUEyQ2wvQyxHQUFHLElBQUlrL0MsUUFBUSxHQUFHcG9ELElBQUksQ0FBQzJiLEdBQUwsQ0FBU3lzQyxRQUFULENBQWYsQ0FBbEQsRUFBc0Y7QUFDcEZwVSxNQUFBQSxLQUFLLEdBQUdoeUMsQ0FBUjtBQUNBa0gsTUFBQUEsR0FBRyxHQUFHay9DLFFBQU47QUFDRDtBQUNGOztBQUVELFNBQU9wVSxLQUFQO0FBQ0QsQ0F0NkJEO0FBQUEsSUF1NkJJNVEsU0FBUyxHQUFHLFNBQVNBLFNBQVQsQ0FBbUJELFNBQW5CLEVBQThCN2lDLElBQTlCLEVBQW9DK25ELGdCQUFwQyxFQUFzRDtBQUNwRSxNQUFJMTFCLENBQUMsR0FBR3dRLFNBQVMsQ0FBQzU2QixJQUFsQjtBQUFBLE1BQ0k3QyxRQUFRLEdBQUdpdEIsQ0FBQyxDQUFDcnlCLElBQUQsQ0FEaEI7QUFBQSxNQUVJbWpELE1BRko7QUFBQSxNQUdJekgsS0FISjs7QUFLQSxNQUFJLENBQUN0MkMsUUFBTCxFQUFlO0FBQ2I7QUFDRDs7QUFFRCs5QyxFQUFBQSxNQUFNLEdBQUc5d0IsQ0FBQyxDQUFDcnlCLElBQUksR0FBRyxRQUFSLENBQVY7QUFDQTA3QyxFQUFBQSxLQUFLLEdBQUdycEIsQ0FBQyxDQUFDL3BCLGFBQUYsSUFBbUJ1NkIsU0FBM0I7QUFDQWtsQixFQUFBQSxnQkFBZ0IsSUFBSTdMLFdBQVcsQ0FBQ2w2QyxNQUFoQyxJQUEwQ3U3QyxXQUFXLEVBQXJELENBWm9FLENBWVg7O0FBRXpELFNBQU80RixNQUFNLEdBQUcvOUMsUUFBUSxDQUFDaUQsS0FBVCxDQUFlcXpDLEtBQWYsRUFBc0J5SCxNQUF0QixDQUFILEdBQW1DLzlDLFFBQVEsQ0FBQzRGLElBQVQsQ0FBYzB3QyxLQUFkLENBQWhEO0FBQ0QsQ0F0N0JEO0FBQUEsSUF1N0JJc00sVUFBVSxHQUFHLFNBQVNBLFVBQVQsQ0FBb0JubEIsU0FBcEIsRUFBK0I7QUFDOUNtYyxFQUFBQSxpQkFBaUIsQ0FBQ25jLFNBQUQsQ0FBakI7O0FBRUFBLEVBQUFBLFNBQVMsQ0FBQ2lPLGFBQVYsSUFBMkJqTyxTQUFTLENBQUNpTyxhQUFWLENBQXdCajJCLElBQXhCLENBQTZCLEtBQTdCLENBQTNCO0FBQ0Fnb0IsRUFBQUEsU0FBUyxDQUFDMWdCLFFBQVYsS0FBdUIsQ0FBdkIsSUFBNEIyZ0IsU0FBUyxDQUFDRCxTQUFELEVBQVksYUFBWixDQUFyQztBQUNBLFNBQU9BLFNBQVA7QUFDRCxDQTc3QkQ7QUFBQSxJQTg3QklvbEIsV0E5N0JKO0FBQUEsSUErN0JJQyxhQUFhLEdBQUcsU0FBU0EsYUFBVCxDQUF1QnR1QixNQUF2QixFQUErQjtBQUNqREEsRUFBQUEsTUFBTSxHQUFHLENBQUNBLE1BQU0sQ0FBQ2pWLElBQVIsSUFBZ0JpVixNQUFNLENBQUMsU0FBRCxDQUF0QixJQUFxQ0EsTUFBOUMsQ0FEaUQsQ0FDSzs7QUFFdEQsTUFBSWpWLElBQUksR0FBR2lWLE1BQU0sQ0FBQ2pWLElBQWxCO0FBQUEsTUFDSXdqQyxNQUFNLEdBQUdqcEQsV0FBVyxDQUFDMDZCLE1BQUQsQ0FEeEI7QUFBQSxNQUVJdkUsTUFBTSxHQUFHMVEsSUFBSSxJQUFJLENBQUN3akMsTUFBVCxJQUFtQnZ1QixNQUFNLENBQUNwRSxJQUExQixHQUFpQyxZQUFZO0FBQ3hELFNBQUtOLE1BQUwsR0FBYyxFQUFkO0FBQ0QsR0FGWSxHQUVUMEUsTUFKSjtBQUFBLE1BS0k7QUFDSnd1QixFQUFBQSxnQkFBZ0IsR0FBRztBQUNqQjV5QixJQUFBQSxJQUFJLEVBQUVsMkIsVUFEVztBQUVqQmdXLElBQUFBLE1BQU0sRUFBRW95QyxpQkFGUztBQUdqQmhsRCxJQUFBQSxHQUFHLEVBQUUra0QsYUFIWTtBQUlqQjVzQyxJQUFBQSxJQUFJLEVBQUV3dEMsaUJBSlc7QUFLakJDLElBQUFBLFFBQVEsRUFBRUMsa0JBTE87QUFNakJDLElBQUFBLE9BQU8sRUFBRTtBQU5RLEdBTm5CO0FBQUEsTUFjSUMsT0FBTyxHQUFHO0FBQ1o3TCxJQUFBQSxVQUFVLEVBQUUsQ0FEQTtBQUVadHNDLElBQUFBLEdBQUcsRUFBRSxDQUZPO0FBR1pvNEMsSUFBQUEsU0FBUyxFQUFFQyxVQUhDO0FBSVo5ekIsSUFBQUEsT0FBTyxFQUFFLEVBSkc7QUFLWnpVLElBQUFBLFFBQVEsRUFBRTtBQUxFLEdBZGQ7O0FBc0JBZ2tDLEVBQUFBLEtBQUs7O0FBRUwsTUFBSXhxQixNQUFNLEtBQUt2RSxNQUFmLEVBQXVCO0FBQ3JCLFFBQUlnbkIsUUFBUSxDQUFDMTNCLElBQUQsQ0FBWixFQUFvQjtBQUNsQjtBQUNEOztBQUVEdGhCLElBQUFBLFlBQVksQ0FBQ2d5QixNQUFELEVBQVNoeUIsWUFBWSxDQUFDNDZDLGNBQWMsQ0FBQ3JrQixNQUFELEVBQVN3dUIsZ0JBQVQsQ0FBZixFQUEyQ0ssT0FBM0MsQ0FBckIsQ0FBWixDQUxxQixDQUtrRTs7O0FBR3ZGOU0sSUFBQUEsTUFBTSxDQUFDdG1CLE1BQU0sQ0FBQ2o0QixTQUFSLEVBQW1CdStDLE1BQU0sQ0FBQ3lNLGdCQUFELEVBQW1CbkssY0FBYyxDQUFDcmtCLE1BQUQsRUFBUzZ1QixPQUFULENBQWpDLENBQXpCLENBQU4sQ0FScUIsQ0FRZ0U7OztBQUdyRnBNLElBQUFBLFFBQVEsQ0FBQ2huQixNQUFNLENBQUM5QyxJQUFQLEdBQWM1TixJQUFmLENBQVIsR0FBK0IwUSxNQUEvQjs7QUFFQSxRQUFJdUUsTUFBTSxDQUFDZ2pCLFVBQVgsRUFBdUI7QUFDckJKLE1BQUFBLGVBQWUsQ0FBQ2g2QyxJQUFoQixDQUFxQjZ5QixNQUFyQjs7QUFFQTRtQixNQUFBQSxjQUFjLENBQUN0M0IsSUFBRCxDQUFkLEdBQXVCLENBQXZCO0FBQ0Q7O0FBRURBLElBQUFBLElBQUksR0FBRyxDQUFDQSxJQUFJLEtBQUssS0FBVCxHQUFpQixLQUFqQixHQUF5QkEsSUFBSSxDQUFDeUosTUFBTCxDQUFZLENBQVosRUFBZUgsV0FBZixLQUErQnRKLElBQUksQ0FBQ3dKLE1BQUwsQ0FBWSxDQUFaLENBQXpELElBQTJFLFFBQWxGLENBbkJxQixDQW1CdUU7QUFDN0Y7O0FBRUQ2dEIsRUFBQUEsVUFBVSxDQUFDcjNCLElBQUQsRUFBTzBRLE1BQVAsQ0FBVjs7QUFFQXVFLEVBQUFBLE1BQU0sQ0FBQ3haLFFBQVAsSUFBbUJ3WixNQUFNLENBQUN4WixRQUFQLENBQWdCemlCLElBQWhCLEVBQXNCMDNCLE1BQXRCLEVBQThCcEQsU0FBOUIsQ0FBbkI7QUFDRCxDQW4vQkQ7O0FBcS9CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EyMkIsSUFBSSxHQUFHLEdBMS9CUDtBQUFBLElBMi9CSUMsWUFBWSxHQUFHO0FBQ2pCQyxFQUFBQSxJQUFJLEVBQUUsQ0FBQyxDQUFELEVBQUlGLElBQUosRUFBVUEsSUFBVixDQURXO0FBRWpCRyxFQUFBQSxJQUFJLEVBQUUsQ0FBQyxDQUFELEVBQUlILElBQUosRUFBVSxDQUFWLENBRlc7QUFHakJJLEVBQUFBLE1BQU0sRUFBRSxDQUFDLEdBQUQsRUFBTSxHQUFOLEVBQVcsR0FBWCxDQUhTO0FBSWpCQyxFQUFBQSxLQUFLLEVBQUUsQ0FBQyxDQUFELEVBQUksQ0FBSixFQUFPLENBQVAsQ0FKVTtBQUtqQkMsRUFBQUEsTUFBTSxFQUFFLENBQUMsR0FBRCxFQUFNLENBQU4sRUFBUyxDQUFULENBTFM7QUFNakJDLEVBQUFBLElBQUksRUFBRSxDQUFDLENBQUQsRUFBSSxHQUFKLEVBQVMsR0FBVCxDQU5XO0FBT2pCQyxFQUFBQSxJQUFJLEVBQUUsQ0FBQyxDQUFELEVBQUksQ0FBSixFQUFPUixJQUFQLENBUFc7QUFRakJTLEVBQUFBLElBQUksRUFBRSxDQUFDLENBQUQsRUFBSSxDQUFKLEVBQU8sR0FBUCxDQVJXO0FBU2pCQyxFQUFBQSxLQUFLLEVBQUUsQ0FBQ1YsSUFBRCxFQUFPQSxJQUFQLEVBQWFBLElBQWIsQ0FUVTtBQVVqQlcsRUFBQUEsS0FBSyxFQUFFLENBQUMsR0FBRCxFQUFNLEdBQU4sRUFBVyxDQUFYLENBVlU7QUFXakJDLEVBQUFBLE1BQU0sRUFBRSxDQUFDWixJQUFELEVBQU9BLElBQVAsRUFBYSxDQUFiLENBWFM7QUFZakJhLEVBQUFBLE1BQU0sRUFBRSxDQUFDYixJQUFELEVBQU8sR0FBUCxFQUFZLENBQVosQ0FaUztBQWFqQmMsRUFBQUEsSUFBSSxFQUFFLENBQUMsR0FBRCxFQUFNLEdBQU4sRUFBVyxHQUFYLENBYlc7QUFjakJDLEVBQUFBLE1BQU0sRUFBRSxDQUFDLEdBQUQsRUFBTSxDQUFOLEVBQVMsR0FBVCxDQWRTO0FBZWpCQyxFQUFBQSxLQUFLLEVBQUUsQ0FBQyxDQUFELEVBQUksR0FBSixFQUFTLENBQVQsQ0FmVTtBQWdCakJDLEVBQUFBLEdBQUcsRUFBRSxDQUFDakIsSUFBRCxFQUFPLENBQVAsRUFBVSxDQUFWLENBaEJZO0FBaUJqQmtCLEVBQUFBLElBQUksRUFBRSxDQUFDbEIsSUFBRCxFQUFPLEdBQVAsRUFBWSxHQUFaLENBakJXO0FBa0JqQm1CLEVBQUFBLElBQUksRUFBRSxDQUFDLENBQUQsRUFBSW5CLElBQUosRUFBVUEsSUFBVixDQWxCVztBQW1CakJvQixFQUFBQSxXQUFXLEVBQUUsQ0FBQ3BCLElBQUQsRUFBT0EsSUFBUCxFQUFhQSxJQUFiLEVBQW1CLENBQW5CO0FBbkJJLENBMy9CbkI7QUFBQSxJQWdoQ0k7QUFDSjtBQUNBO0FBQ0FxQixJQUFJLEdBQUcsU0FBU0EsSUFBVCxDQUFjcGtDLENBQWQsRUFBaUJxa0MsRUFBakIsRUFBcUJ6cUMsRUFBckIsRUFBeUI7QUFDOUJvRyxFQUFBQSxDQUFDLElBQUlBLENBQUMsR0FBRyxDQUFKLEdBQVEsQ0FBUixHQUFZQSxDQUFDLEdBQUcsQ0FBSixHQUFRLENBQUMsQ0FBVCxHQUFhLENBQTlCO0FBQ0EsU0FBTyxDQUFDQSxDQUFDLEdBQUcsQ0FBSixHQUFRLENBQVIsR0FBWXFrQyxFQUFFLEdBQUcsQ0FBQ3pxQyxFQUFFLEdBQUd5cUMsRUFBTixJQUFZcmtDLENBQVosR0FBZ0IsQ0FBakMsR0FBcUNBLENBQUMsR0FBRyxFQUFKLEdBQVNwRyxFQUFULEdBQWNvRyxDQUFDLEdBQUcsQ0FBSixHQUFRLENBQVIsR0FBWXFrQyxFQUFFLEdBQUcsQ0FBQ3pxQyxFQUFFLEdBQUd5cUMsRUFBTixLQUFhLElBQUksQ0FBSixHQUFRcmtDLENBQXJCLElBQTBCLENBQTNDLEdBQStDcWtDLEVBQW5HLElBQXlHdEIsSUFBekcsR0FBZ0gsRUFBaEgsR0FBcUgsQ0FBNUg7QUFDRCxDQXRoQ0Q7QUFBQSxJQXVoQ0l1QixVQUFVLEdBQUcsU0FBU0EsVUFBVCxDQUFvQjkzQixDQUFwQixFQUF1QiszQixLQUF2QixFQUE4QkMsVUFBOUIsRUFBMEM7QUFDekQsTUFBSXgvQyxDQUFDLEdBQUcsQ0FBQ3duQixDQUFELEdBQUt3MkIsWUFBWSxDQUFDSSxLQUFsQixHQUEwQm5uQyxTQUFTLENBQUN1USxDQUFELENBQVQsR0FBZSxDQUFDQSxDQUFDLElBQUksRUFBTixFQUFVQSxDQUFDLElBQUksQ0FBTCxHQUFTdTJCLElBQW5CLEVBQXlCdjJCLENBQUMsR0FBR3UyQixJQUE3QixDQUFmLEdBQW9ELENBQXRGO0FBQUEsTUFDSWpoRCxDQURKO0FBQUEsTUFFSTJpRCxDQUZKO0FBQUEsTUFHSTl0QyxDQUhKO0FBQUEsTUFJSXFKLENBSko7QUFBQSxNQUtJNkIsQ0FMSjtBQUFBLE1BTUk1YyxDQU5KO0FBQUEsTUFPSWhGLEdBUEo7QUFBQSxNQVFJOEMsR0FSSjtBQUFBLE1BU0k2VCxDQVRKO0FBQUEsTUFVSTh0QyxNQVZKOztBQVlBLE1BQUksQ0FBQzEvQyxDQUFMLEVBQVE7QUFDTixRQUFJd25CLENBQUMsQ0FBQ2xFLE1BQUYsQ0FBUyxDQUFDLENBQVYsTUFBaUIsR0FBckIsRUFBMEI7QUFDeEI7QUFDQWtFLE1BQUFBLENBQUMsR0FBR0EsQ0FBQyxDQUFDbEUsTUFBRixDQUFTLENBQVQsRUFBWWtFLENBQUMsQ0FBQ3J3QixNQUFGLEdBQVcsQ0FBdkIsQ0FBSjtBQUNEOztBQUVELFFBQUk2bUQsWUFBWSxDQUFDeDJCLENBQUQsQ0FBaEIsRUFBcUI7QUFDbkJ4bkIsTUFBQUEsQ0FBQyxHQUFHZytDLFlBQVksQ0FBQ3gyQixDQUFELENBQWhCO0FBQ0QsS0FGRCxNQUVPLElBQUlBLENBQUMsQ0FBQ2pFLE1BQUYsQ0FBUyxDQUFULE1BQWdCLEdBQXBCLEVBQXlCO0FBQzlCLFVBQUlpRSxDQUFDLENBQUNyd0IsTUFBRixHQUFXLENBQWYsRUFBa0I7QUFDaEI7QUFDQTJGLFFBQUFBLENBQUMsR0FBRzBxQixDQUFDLENBQUNqRSxNQUFGLENBQVMsQ0FBVCxDQUFKO0FBQ0FrOEIsUUFBQUEsQ0FBQyxHQUFHajRCLENBQUMsQ0FBQ2pFLE1BQUYsQ0FBUyxDQUFULENBQUo7QUFDQTVSLFFBQUFBLENBQUMsR0FBRzZWLENBQUMsQ0FBQ2pFLE1BQUYsQ0FBUyxDQUFULENBQUo7QUFDQWlFLFFBQUFBLENBQUMsR0FBRyxNQUFNMXFCLENBQU4sR0FBVUEsQ0FBVixHQUFjMmlELENBQWQsR0FBa0JBLENBQWxCLEdBQXNCOXRDLENBQXRCLEdBQTBCQSxDQUExQixJQUErQjZWLENBQUMsQ0FBQ3J3QixNQUFGLEtBQWEsQ0FBYixHQUFpQnF3QixDQUFDLENBQUNqRSxNQUFGLENBQVMsQ0FBVCxJQUFjaUUsQ0FBQyxDQUFDakUsTUFBRixDQUFTLENBQVQsQ0FBL0IsR0FBNkMsRUFBNUUsQ0FBSjtBQUNEOztBQUVELFVBQUlpRSxDQUFDLENBQUNyd0IsTUFBRixLQUFhLENBQWpCLEVBQW9CO0FBQ2xCO0FBQ0E2SSxRQUFBQSxDQUFDLEdBQUcyL0MsUUFBUSxDQUFDbjRCLENBQUMsQ0FBQ2xFLE1BQUYsQ0FBUyxDQUFULEVBQVksQ0FBWixDQUFELEVBQWlCLEVBQWpCLENBQVo7QUFDQSxlQUFPLENBQUN0akIsQ0FBQyxJQUFJLEVBQU4sRUFBVUEsQ0FBQyxJQUFJLENBQUwsR0FBUys5QyxJQUFuQixFQUF5Qi85QyxDQUFDLEdBQUcrOUMsSUFBN0IsRUFBbUM0QixRQUFRLENBQUNuNEIsQ0FBQyxDQUFDbEUsTUFBRixDQUFTLENBQVQsQ0FBRCxFQUFjLEVBQWQsQ0FBUixHQUE0QixHQUEvRCxDQUFQO0FBQ0Q7O0FBRURrRSxNQUFBQSxDQUFDLEdBQUdtNEIsUUFBUSxDQUFDbjRCLENBQUMsQ0FBQ2xFLE1BQUYsQ0FBUyxDQUFULENBQUQsRUFBYyxFQUFkLENBQVo7QUFDQXRqQixNQUFBQSxDQUFDLEdBQUcsQ0FBQ3duQixDQUFDLElBQUksRUFBTixFQUFVQSxDQUFDLElBQUksQ0FBTCxHQUFTdTJCLElBQW5CLEVBQXlCdjJCLENBQUMsR0FBR3UyQixJQUE3QixDQUFKO0FBQ0QsS0FqQk0sTUFpQkEsSUFBSXYyQixDQUFDLENBQUNsRSxNQUFGLENBQVMsQ0FBVCxFQUFZLENBQVosTUFBbUIsS0FBdkIsRUFBOEI7QUFDbkN0akIsTUFBQUEsQ0FBQyxHQUFHMC9DLE1BQU0sR0FBR2w0QixDQUFDLENBQUN2TCxLQUFGLENBQVFpMEIsYUFBUixDQUFiOztBQUVBLFVBQUksQ0FBQ3FQLEtBQUwsRUFBWTtBQUNWdmtDLFFBQUFBLENBQUMsR0FBRyxDQUFDaGIsQ0FBQyxDQUFDLENBQUQsQ0FBRixHQUFRLEdBQVIsR0FBYyxHQUFsQjtBQUNBNmMsUUFBQUEsQ0FBQyxHQUFHLENBQUM3YyxDQUFDLENBQUMsQ0FBRCxDQUFGLEdBQVEsR0FBWjtBQUNBQyxRQUFBQSxDQUFDLEdBQUcsQ0FBQ0QsQ0FBQyxDQUFDLENBQUQsQ0FBRixHQUFRLEdBQVo7QUFDQXkvQyxRQUFBQSxDQUFDLEdBQUd4L0MsQ0FBQyxJQUFJLEVBQUwsR0FBVUEsQ0FBQyxJQUFJNGMsQ0FBQyxHQUFHLENBQVIsQ0FBWCxHQUF3QjVjLENBQUMsR0FBRzRjLENBQUosR0FBUTVjLENBQUMsR0FBRzRjLENBQXhDO0FBQ0EvZixRQUFBQSxDQUFDLEdBQUdtRCxDQUFDLEdBQUcsQ0FBSixHQUFRdy9DLENBQVo7QUFDQXovQyxRQUFBQSxDQUFDLENBQUM3SSxNQUFGLEdBQVcsQ0FBWCxLQUFpQjZJLENBQUMsQ0FBQyxDQUFELENBQUQsSUFBUSxDQUF6QixFQU5VLENBTW1COztBQUU3QkEsUUFBQUEsQ0FBQyxDQUFDLENBQUQsQ0FBRCxHQUFPby9DLElBQUksQ0FBQ3BrQyxDQUFDLEdBQUcsSUFBSSxDQUFULEVBQVlsZSxDQUFaLEVBQWUyaUQsQ0FBZixDQUFYO0FBQ0F6L0MsUUFBQUEsQ0FBQyxDQUFDLENBQUQsQ0FBRCxHQUFPby9DLElBQUksQ0FBQ3BrQyxDQUFELEVBQUlsZSxDQUFKLEVBQU8yaUQsQ0FBUCxDQUFYO0FBQ0F6L0MsUUFBQUEsQ0FBQyxDQUFDLENBQUQsQ0FBRCxHQUFPby9DLElBQUksQ0FBQ3BrQyxDQUFDLEdBQUcsSUFBSSxDQUFULEVBQVlsZSxDQUFaLEVBQWUyaUQsQ0FBZixDQUFYO0FBQ0QsT0FYRCxNQVdPLElBQUksQ0FBQ2o0QixDQUFDLENBQUM3aUIsT0FBRixDQUFVLEdBQVYsQ0FBTCxFQUFxQjtBQUMxQjtBQUNBM0UsUUFBQUEsQ0FBQyxHQUFHd25CLENBQUMsQ0FBQ3ZMLEtBQUYsQ0FBUXFNLE9BQVIsQ0FBSjtBQUNBazNCLFFBQUFBLFVBQVUsSUFBSXgvQyxDQUFDLENBQUM3SSxNQUFGLEdBQVcsQ0FBekIsS0FBK0I2SSxDQUFDLENBQUMsQ0FBRCxDQUFELEdBQU8sQ0FBdEM7QUFDQSxlQUFPQSxDQUFQO0FBQ0Q7QUFDRixLQXBCTSxNQW9CQTtBQUNMQSxNQUFBQSxDQUFDLEdBQUd3bkIsQ0FBQyxDQUFDdkwsS0FBRixDQUFRaTBCLGFBQVIsS0FBMEI4TixZQUFZLENBQUNtQixXQUEzQztBQUNEOztBQUVEbi9DLElBQUFBLENBQUMsR0FBR0EsQ0FBQyxDQUFDeVYsR0FBRixDQUFNbXFDLE1BQU4sQ0FBSjtBQUNEOztBQUVELE1BQUlMLEtBQUssSUFBSSxDQUFDRyxNQUFkLEVBQXNCO0FBQ3BCNWlELElBQUFBLENBQUMsR0FBR2tELENBQUMsQ0FBQyxDQUFELENBQUQsR0FBTys5QyxJQUFYO0FBQ0EwQixJQUFBQSxDQUFDLEdBQUd6L0MsQ0FBQyxDQUFDLENBQUQsQ0FBRCxHQUFPKzlDLElBQVg7QUFDQXBzQyxJQUFBQSxDQUFDLEdBQUczUixDQUFDLENBQUMsQ0FBRCxDQUFELEdBQU8rOUMsSUFBWDtBQUNBOWlELElBQUFBLEdBQUcsR0FBR3BHLElBQUksQ0FBQ29HLEdBQUwsQ0FBUzZCLENBQVQsRUFBWTJpRCxDQUFaLEVBQWU5dEMsQ0FBZixDQUFOO0FBQ0E1VCxJQUFBQSxHQUFHLEdBQUdsSixJQUFJLENBQUNrSixHQUFMLENBQVNqQixDQUFULEVBQVkyaUQsQ0FBWixFQUFlOXRDLENBQWYsQ0FBTjtBQUNBMVIsSUFBQUEsQ0FBQyxHQUFHLENBQUNoRixHQUFHLEdBQUc4QyxHQUFQLElBQWMsQ0FBbEI7O0FBRUEsUUFBSTlDLEdBQUcsS0FBSzhDLEdBQVosRUFBaUI7QUFDZmlkLE1BQUFBLENBQUMsR0FBRzZCLENBQUMsR0FBRyxDQUFSO0FBQ0QsS0FGRCxNQUVPO0FBQ0xqTCxNQUFBQSxDQUFDLEdBQUczVyxHQUFHLEdBQUc4QyxHQUFWO0FBQ0E4ZSxNQUFBQSxDQUFDLEdBQUc1YyxDQUFDLEdBQUcsR0FBSixHQUFVMlIsQ0FBQyxJQUFJLElBQUkzVyxHQUFKLEdBQVU4QyxHQUFkLENBQVgsR0FBZ0M2VCxDQUFDLElBQUkzVyxHQUFHLEdBQUc4QyxHQUFWLENBQXJDO0FBQ0FpZCxNQUFBQSxDQUFDLEdBQUcvZixHQUFHLEtBQUs2QixDQUFSLEdBQVksQ0FBQzJpRCxDQUFDLEdBQUc5dEMsQ0FBTCxJQUFVQyxDQUFWLElBQWU2dEMsQ0FBQyxHQUFHOXRDLENBQUosR0FBUSxDQUFSLEdBQVksQ0FBM0IsQ0FBWixHQUE0QzFXLEdBQUcsS0FBS3drRCxDQUFSLEdBQVksQ0FBQzl0QyxDQUFDLEdBQUc3VSxDQUFMLElBQVU4VSxDQUFWLEdBQWMsQ0FBMUIsR0FBOEIsQ0FBQzlVLENBQUMsR0FBRzJpRCxDQUFMLElBQVU3dEMsQ0FBVixHQUFjLENBQTVGO0FBQ0FvSixNQUFBQSxDQUFDLElBQUksRUFBTDtBQUNEOztBQUVEaGIsSUFBQUEsQ0FBQyxDQUFDLENBQUQsQ0FBRCxHQUFPLENBQUMsRUFBRWdiLENBQUMsR0FBRyxFQUFOLENBQVI7QUFDQWhiLElBQUFBLENBQUMsQ0FBQyxDQUFELENBQUQsR0FBTyxDQUFDLEVBQUU2YyxDQUFDLEdBQUcsR0FBSixHQUFVLEVBQVosQ0FBUjtBQUNBN2MsSUFBQUEsQ0FBQyxDQUFDLENBQUQsQ0FBRCxHQUFPLENBQUMsRUFBRUMsQ0FBQyxHQUFHLEdBQUosR0FBVSxFQUFaLENBQVI7QUFDRDs7QUFFRHUvQyxFQUFBQSxVQUFVLElBQUl4L0MsQ0FBQyxDQUFDN0ksTUFBRixHQUFXLENBQXpCLEtBQStCNkksQ0FBQyxDQUFDLENBQUQsQ0FBRCxHQUFPLENBQXRDO0FBQ0EsU0FBT0EsQ0FBUDtBQUNELENBaG5DRDtBQUFBLElBaW5DSTYvQyxlQUFlLEdBQUcsU0FBU0EsZUFBVCxDQUF5QnI0QixDQUF6QixFQUE0QjtBQUNoRDtBQUNBLE1BQUlELE1BQU0sR0FBRyxFQUFiO0FBQUEsTUFDSTdWLENBQUMsR0FBRyxFQURSO0FBQUEsTUFFSXhhLENBQUMsR0FBRyxDQUFDLENBRlQ7QUFHQXN3QixFQUFBQSxDQUFDLENBQUNsaUIsS0FBRixDQUFRdzZDLFNBQVIsRUFBbUJ0b0QsT0FBbkIsQ0FBMkIsVUFBVWd3QixDQUFWLEVBQWE7QUFDdEMsUUFBSXhuQixDQUFDLEdBQUd3bkIsQ0FBQyxDQUFDdkwsS0FBRixDQUFRazBCLGVBQVIsS0FBNEIsRUFBcEM7QUFDQTVvQixJQUFBQSxNQUFNLENBQUM1dkIsSUFBUCxDQUFZNkYsS0FBWixDQUFrQitwQixNQUFsQixFQUEwQnZuQixDQUExQjtBQUNBMFIsSUFBQUEsQ0FBQyxDQUFDL1osSUFBRixDQUFPVCxDQUFDLElBQUk4SSxDQUFDLENBQUM3SSxNQUFGLEdBQVcsQ0FBdkI7QUFDRCxHQUpEO0FBS0Fvd0IsRUFBQUEsTUFBTSxDQUFDN1YsQ0FBUCxHQUFXQSxDQUFYO0FBQ0EsU0FBTzZWLE1BQVA7QUFDRCxDQTduQ0Q7QUFBQSxJQThuQ0l3NEIsYUFBYSxHQUFHLFNBQVNBLGFBQVQsQ0FBdUJsakMsQ0FBdkIsRUFBMEIwaUMsS0FBMUIsRUFBaUNTLGNBQWpDLEVBQWlEO0FBQ25FLE1BQUl6aUQsTUFBTSxHQUFHLEVBQWI7QUFBQSxNQUNJMGlELE1BQU0sR0FBRyxDQUFDcGpDLENBQUMsR0FBR3RmLE1BQUwsRUFBYTBlLEtBQWIsQ0FBbUI2akMsU0FBbkIsQ0FEYjtBQUFBLE1BRUkzcUQsSUFBSSxHQUFHb3FELEtBQUssR0FBRyxPQUFILEdBQWEsT0FGN0I7QUFBQSxNQUdJcm9ELENBQUMsR0FBRyxDQUhSO0FBQUEsTUFJSXdhLENBSko7QUFBQSxNQUtJd3VDLEtBTEo7QUFBQSxNQU1JdHVDLENBTko7QUFBQSxNQU9JM1IsQ0FQSjs7QUFTQSxNQUFJLENBQUNnZ0QsTUFBTCxFQUFhO0FBQ1gsV0FBT3BqQyxDQUFQO0FBQ0Q7O0FBRURvakMsRUFBQUEsTUFBTSxHQUFHQSxNQUFNLENBQUN4cUMsR0FBUCxDQUFXLFVBQVV5bUIsS0FBVixFQUFpQjtBQUNuQyxXQUFPLENBQUNBLEtBQUssR0FBR29qQixVQUFVLENBQUNwakIsS0FBRCxFQUFRcWpCLEtBQVIsRUFBZSxDQUFmLENBQW5CLEtBQXlDcHFELElBQUksSUFBSW9xRCxLQUFLLEdBQUdyakIsS0FBSyxDQUFDLENBQUQsQ0FBTCxHQUFXLEdBQVgsR0FBaUJBLEtBQUssQ0FBQyxDQUFELENBQXRCLEdBQTRCLElBQTVCLEdBQW1DQSxLQUFLLENBQUMsQ0FBRCxDQUF4QyxHQUE4QyxJQUE5QyxHQUFxREEsS0FBSyxDQUFDLENBQUQsQ0FBN0QsR0FBbUVBLEtBQUssQ0FBQ3RnQixJQUFOLENBQVcsR0FBWCxDQUE1RSxDQUFKLEdBQW1HLEdBQW5KO0FBQ0QsR0FGUSxDQUFUOztBQUlBLE1BQUlva0MsY0FBSixFQUFvQjtBQUNsQnB1QyxJQUFBQSxDQUFDLEdBQUdpdUMsZUFBZSxDQUFDaGpDLENBQUQsQ0FBbkI7QUFDQW5MLElBQUFBLENBQUMsR0FBR3N1QyxjQUFjLENBQUN0dUMsQ0FBbkI7O0FBRUEsUUFBSUEsQ0FBQyxDQUFDa0ssSUFBRixDQUFPcmUsTUFBUCxNQUFtQnFVLENBQUMsQ0FBQ0YsQ0FBRixDQUFJa0ssSUFBSixDQUFTcmUsTUFBVCxDQUF2QixFQUF5QztBQUN2QzJpRCxNQUFBQSxLQUFLLEdBQUdyakMsQ0FBQyxDQUFDdG5CLE9BQUYsQ0FBVXVxRCxTQUFWLEVBQXFCLEdBQXJCLEVBQTBCeDZDLEtBQTFCLENBQWdDNnFDLGVBQWhDLENBQVI7QUFDQWx3QyxNQUFBQSxDQUFDLEdBQUdpZ0QsS0FBSyxDQUFDL29ELE1BQU4sR0FBZSxDQUFuQjs7QUFFQSxhQUFPRCxDQUFDLEdBQUcrSSxDQUFYLEVBQWMvSSxDQUFDLEVBQWYsRUFBbUI7QUFDakJxRyxRQUFBQSxNQUFNLElBQUkyaUQsS0FBSyxDQUFDaHBELENBQUQsQ0FBTCxJQUFZLENBQUN3YSxDQUFDLENBQUMvTSxPQUFGLENBQVV6TixDQUFWLENBQUQsR0FBZ0Irb0QsTUFBTSxDQUFDcG9DLEtBQVAsTUFBa0IxaUIsSUFBSSxHQUFHLFVBQXpDLEdBQXNELENBQUN5YyxDQUFDLENBQUN6YSxNQUFGLEdBQVd5YSxDQUFYLEdBQWVxdUMsTUFBTSxDQUFDOW9ELE1BQVAsR0FBZ0I4b0QsTUFBaEIsR0FBeUJELGNBQXpDLEVBQXlEbm9DLEtBQXpELEVBQWxFLENBQVY7QUFDRDtBQUNGO0FBQ0Y7O0FBRUQsTUFBSSxDQUFDcW9DLEtBQUwsRUFBWTtBQUNWQSxJQUFBQSxLQUFLLEdBQUdyakMsQ0FBQyxDQUFDdlgsS0FBRixDQUFRdzZDLFNBQVIsQ0FBUjtBQUNBNy9DLElBQUFBLENBQUMsR0FBR2lnRCxLQUFLLENBQUMvb0QsTUFBTixHQUFlLENBQW5COztBQUVBLFdBQU9ELENBQUMsR0FBRytJLENBQVgsRUFBYy9JLENBQUMsRUFBZixFQUFtQjtBQUNqQnFHLE1BQUFBLE1BQU0sSUFBSTJpRCxLQUFLLENBQUNocEQsQ0FBRCxDQUFMLEdBQVcrb0QsTUFBTSxDQUFDL29ELENBQUQsQ0FBM0I7QUFDRDtBQUNGOztBQUVELFNBQU9xRyxNQUFNLEdBQUcyaUQsS0FBSyxDQUFDamdELENBQUQsQ0FBckI7QUFDRCxDQXhxQ0Q7QUFBQSxJQXlxQ0k2L0MsU0FBUyxHQUFHLFlBQVk7QUFDMUIsTUFBSWpqQyxDQUFDLEdBQUcsd0VBQVI7QUFBQSxNQUNJO0FBQ0pobUIsRUFBQUEsQ0FGQTs7QUFJQSxPQUFLQSxDQUFMLElBQVVtbkQsWUFBVixFQUF3QjtBQUN0Qm5oQyxJQUFBQSxDQUFDLElBQUksTUFBTWhtQixDQUFOLEdBQVUsS0FBZjtBQUNEOztBQUVELFNBQU8sSUFBSXNwRCxNQUFKLENBQVd0akMsQ0FBQyxHQUFHLEdBQWYsRUFBb0IsSUFBcEIsQ0FBUDtBQUNELENBVmUsRUF6cUNoQjtBQUFBLElBb3JDSXVqQyxPQUFPLEdBQUcsV0FwckNkO0FBQUEsSUFxckNJQyxrQkFBa0IsR0FBRyxTQUFTQSxrQkFBVCxDQUE0QnJnRCxDQUE1QixFQUErQjtBQUN0RCxNQUFJc2dELFFBQVEsR0FBR3RnRCxDQUFDLENBQUM0YixJQUFGLENBQU8sR0FBUCxDQUFmO0FBQUEsTUFDSTJqQyxLQURKO0FBRUFPLEVBQUFBLFNBQVMsQ0FBQ1MsU0FBVixHQUFzQixDQUF0Qjs7QUFFQSxNQUFJVCxTQUFTLENBQUN0L0MsSUFBVixDQUFlOC9DLFFBQWYsQ0FBSixFQUE4QjtBQUM1QmYsSUFBQUEsS0FBSyxHQUFHYSxPQUFPLENBQUM1L0MsSUFBUixDQUFhOC9DLFFBQWIsQ0FBUjtBQUNBdGdELElBQUFBLENBQUMsQ0FBQyxDQUFELENBQUQsR0FBTysvQyxhQUFhLENBQUMvL0MsQ0FBQyxDQUFDLENBQUQsQ0FBRixFQUFPdS9DLEtBQVAsQ0FBcEI7QUFDQXYvQyxJQUFBQSxDQUFDLENBQUMsQ0FBRCxDQUFELEdBQU8rL0MsYUFBYSxDQUFDLy9DLENBQUMsQ0FBQyxDQUFELENBQUYsRUFBT3UvQyxLQUFQLEVBQWNNLGVBQWUsQ0FBQzcvQyxDQUFDLENBQUMsQ0FBRCxDQUFGLENBQTdCLENBQXBCLENBSDRCLENBRzhCOztBQUUxRCxXQUFPLElBQVA7QUFDRDtBQUNGLENBanNDRDs7QUFtc0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQXdnRCxhQXhzQ0E7QUFBQSxJQXlzQ0lqSyxPQUFPLEdBQUcsWUFBWTtBQUN4QixNQUFJemdELFFBQVEsR0FBR0MsSUFBSSxDQUFDQyxHQUFwQjtBQUFBLE1BQ0l5cUQsYUFBYSxHQUFHLEdBRHBCO0FBQUEsTUFFSUMsWUFBWSxHQUFHLEVBRm5CO0FBQUEsTUFHSUMsVUFBVSxHQUFHN3FELFFBQVEsRUFIekI7QUFBQSxNQUlJOHFELFdBQVcsR0FBR0QsVUFKbEI7QUFBQSxNQUtJRSxJQUFJLEdBQUcsT0FBTyxHQUxsQjtBQUFBLE1BTUlDLFNBQVMsR0FBR0QsSUFOaEI7QUFBQSxNQU9JdmpELFVBQVUsR0FBRyxFQVBqQjtBQUFBLE1BUUl5akQsR0FSSjtBQUFBLE1BU0lDLElBVEo7QUFBQSxNQVVJQyxJQVZKO0FBQUEsTUFXSUMsS0FYSjtBQUFBLE1BWUlDLE1BWko7QUFBQSxNQWFJcHJCLEVBYko7QUFBQSxNQWNJcXJCLEtBQUssR0FBRyxTQUFTQSxLQUFULENBQWU1NUIsQ0FBZixFQUFrQjtBQUM1QixRQUFJNjVCLE9BQU8sR0FBR3ZyRCxRQUFRLEtBQUs4cUQsV0FBM0I7QUFBQSxRQUNJVSxNQUFNLEdBQUc5NUIsQ0FBQyxLQUFLLElBRG5CO0FBQUEsUUFFSTNSLE9BRko7QUFBQSxRQUdJMHJDLFFBSEo7QUFBQSxRQUlJenVDLElBSko7QUFBQSxRQUtJK3FCLEtBTEo7O0FBT0F3akIsSUFBQUEsT0FBTyxHQUFHWixhQUFWLEtBQTRCRSxVQUFVLElBQUlVLE9BQU8sR0FBR1gsWUFBcEQ7QUFDQUUsSUFBQUEsV0FBVyxJQUFJUyxPQUFmO0FBQ0F2dUMsSUFBQUEsSUFBSSxHQUFHOHRDLFdBQVcsR0FBR0QsVUFBckI7QUFDQTlxQyxJQUFBQSxPQUFPLEdBQUcvQyxJQUFJLEdBQUdndUMsU0FBakI7O0FBRUEsUUFBSWpyQyxPQUFPLEdBQUcsQ0FBVixJQUFleXJDLE1BQW5CLEVBQTJCO0FBQ3pCempCLE1BQUFBLEtBQUssR0FBRyxFQUFFcWpCLEtBQUssQ0FBQ3JqQixLQUFoQjtBQUNBc2pCLE1BQUFBLE1BQU0sR0FBR3J1QyxJQUFJLEdBQUdvdUMsS0FBSyxDQUFDcHVDLElBQU4sR0FBYSxJQUE3QjtBQUNBb3VDLE1BQUFBLEtBQUssQ0FBQ3B1QyxJQUFOLEdBQWFBLElBQUksR0FBR0EsSUFBSSxHQUFHLElBQTNCO0FBQ0FndUMsTUFBQUEsU0FBUyxJQUFJanJDLE9BQU8sSUFBSUEsT0FBTyxJQUFJZ3JDLElBQVgsR0FBa0IsQ0FBbEIsR0FBc0JBLElBQUksR0FBR2hyQyxPQUFqQyxDQUFwQjtBQUNBMHJDLE1BQUFBLFFBQVEsR0FBRyxDQUFYO0FBQ0Q7O0FBRURELElBQUFBLE1BQU0sS0FBS1AsR0FBRyxHQUFHQyxJQUFJLENBQUNJLEtBQUQsQ0FBZixDQUFOLENBckI0QixDQXFCRzs7QUFFL0IsUUFBSUcsUUFBSixFQUFjO0FBQ1osV0FBS3hyQixFQUFFLEdBQUcsQ0FBVixFQUFhQSxFQUFFLEdBQUd6NEIsVUFBVSxDQUFDbkcsTUFBN0IsRUFBcUM0K0IsRUFBRSxFQUF2QyxFQUEyQztBQUN6QztBQUNBejRCLFFBQUFBLFVBQVUsQ0FBQ3k0QixFQUFELENBQVYsQ0FBZWpqQixJQUFmLEVBQXFCcXVDLE1BQXJCLEVBQTZCdGpCLEtBQTdCLEVBQW9DclcsQ0FBcEM7QUFDRDtBQUNGO0FBQ0YsR0EzQ0Q7O0FBNkNBMDVCLEVBQUFBLEtBQUssR0FBRztBQUNOcHVDLElBQUFBLElBQUksRUFBRSxDQURBO0FBRU4rcUIsSUFBQUEsS0FBSyxFQUFFLENBRkQ7QUFHTkQsSUFBQUEsSUFBSSxFQUFFLFNBQVNBLElBQVQsR0FBZ0I7QUFDcEJ3akIsTUFBQUEsS0FBSyxDQUFDLElBQUQsQ0FBTDtBQUNELEtBTEs7QUFNTkksSUFBQUEsVUFBVSxFQUFFLFNBQVNBLFVBQVQsQ0FBb0JDLEdBQXBCLEVBQXlCO0FBQ25DLGFBQU9OLE1BQU0sSUFBSSxRQUFRTSxHQUFHLElBQUksRUFBZixDQUFKLENBQWI7QUFDRCxLQVJLO0FBU05DLElBQUFBLElBQUksRUFBRSxTQUFTQSxJQUFULEdBQWdCO0FBQ3BCLFVBQUkvUSxVQUFKLEVBQWdCO0FBQ2QsWUFBSSxDQUFDdDlDLFlBQUQsSUFBaUJZLGFBQWEsRUFBbEMsRUFBc0M7QUFDcENsQixVQUFBQSxJQUFJLEdBQUdNLFlBQVksR0FBR2EsTUFBdEI7QUFDQWxCLFVBQUFBLElBQUksR0FBR0QsSUFBSSxDQUFDME8sUUFBTCxJQUFpQixFQUF4QjtBQUNBZ3ZDLFVBQUFBLFFBQVEsQ0FBQzM5QyxJQUFULEdBQWdCQSxJQUFoQjtBQUNBLFdBQUNDLElBQUksQ0FBQzR1RCxZQUFMLEtBQXNCNXVELElBQUksQ0FBQzR1RCxZQUFMLEdBQW9CLEVBQTFDLENBQUQsRUFBZ0RocUQsSUFBaEQsQ0FBcUQ3RSxJQUFJLENBQUNrakIsT0FBMUQ7O0FBRUE0NkIsVUFBQUEsUUFBUSxDQUFDRixhQUFhLElBQUkzOUMsSUFBSSxDQUFDNnVELGdCQUF0QixJQUEwQyxDQUFDN3VELElBQUksQ0FBQ0QsSUFBTixJQUFjQyxJQUF4RCxJQUFnRSxFQUFqRSxDQUFSOztBQUVBa3VELFVBQUFBLElBQUksR0FBR2x1RCxJQUFJLENBQUNpaEMscUJBQVo7QUFDRDs7QUFFRCtzQixRQUFBQSxHQUFHLElBQUlHLEtBQUssQ0FBQ1csS0FBTixFQUFQOztBQUVBYixRQUFBQSxJQUFJLEdBQUdDLElBQUksSUFBSSxVQUFVcHZDLENBQVYsRUFBYTtBQUMxQixpQkFBTzZlLFVBQVUsQ0FBQzdlLENBQUQsRUFBSWl2QyxTQUFTLEdBQUdJLEtBQUssQ0FBQ3B1QyxJQUFOLEdBQWEsSUFBekIsR0FBZ0MsQ0FBaEMsR0FBb0MsQ0FBeEMsQ0FBakI7QUFDRCxTQUZEOztBQUlBMHRDLFFBQUFBLGFBQWEsR0FBRyxDQUFoQjs7QUFFQVksUUFBQUEsS0FBSyxDQUFDLENBQUQsQ0FBTDtBQUNEO0FBQ0YsS0FoQ0s7QUFpQ05TLElBQUFBLEtBQUssRUFBRSxTQUFTQSxLQUFULEdBQWlCO0FBQ3RCLE9BQUNaLElBQUksR0FBR2x1RCxJQUFJLENBQUMrdUQsb0JBQVIsR0FBK0JDLFlBQXBDLEVBQWtEaEIsR0FBbEQ7QUFDQVAsTUFBQUEsYUFBYSxHQUFHLENBQWhCO0FBQ0FRLE1BQUFBLElBQUksR0FBR3ZzRCxVQUFQO0FBQ0QsS0FyQ0s7QUFzQ051dEQsSUFBQUEsWUFBWSxFQUFFLFNBQVNBLFlBQVQsQ0FBc0JqdUMsU0FBdEIsRUFBaUNrdUMsV0FBakMsRUFBOEM7QUFDMUR4QixNQUFBQSxhQUFhLEdBQUcxc0MsU0FBUyxJQUFJLElBQUkwN0IsUUFBakMsQ0FEMEQsQ0FDZjs7QUFFM0NpUixNQUFBQSxZQUFZLEdBQUc3ckQsSUFBSSxDQUFDa0osR0FBTCxDQUFTa2tELFdBQVQsRUFBc0J4QixhQUF0QixFQUFxQyxDQUFyQyxDQUFmO0FBQ0QsS0ExQ0s7QUEyQ05nQixJQUFBQSxHQUFHLEVBQUUsU0FBU0EsR0FBVCxDQUFhUyxJQUFiLEVBQW1CO0FBQ3RCckIsTUFBQUEsSUFBSSxHQUFHLFFBQVFxQixJQUFJLElBQUksR0FBaEIsQ0FBUDtBQUNBcEIsTUFBQUEsU0FBUyxHQUFHSSxLQUFLLENBQUNwdUMsSUFBTixHQUFhLElBQWIsR0FBb0IrdEMsSUFBaEM7QUFDRCxLQTlDSztBQStDTmhwRCxJQUFBQSxHQUFHLEVBQUUsU0FBU0EsR0FBVCxDQUFhMEMsUUFBYixFQUF1QjZuQyxJQUF2QixFQUE2QitmLFVBQTdCLEVBQXlDO0FBQzVDLFVBQUkxcUQsSUFBSSxHQUFHMnFDLElBQUksR0FBRyxVQUFVenFCLENBQVYsRUFBYS9GLENBQWIsRUFBZ0JDLENBQWhCLEVBQW1CMlYsQ0FBbkIsRUFBc0I7QUFDdENqdEIsUUFBQUEsUUFBUSxDQUFDb2QsQ0FBRCxFQUFJL0YsQ0FBSixFQUFPQyxDQUFQLEVBQVUyVixDQUFWLENBQVI7O0FBRUEwNUIsUUFBQUEsS0FBSyxDQUFDbnBELE1BQU4sQ0FBYU4sSUFBYjtBQUNELE9BSmMsR0FJWDhDLFFBSko7O0FBTUEybUQsTUFBQUEsS0FBSyxDQUFDbnBELE1BQU4sQ0FBYXdDLFFBQWI7O0FBRUErQyxNQUFBQSxVQUFVLENBQUM2a0QsVUFBVSxHQUFHLFNBQUgsR0FBZSxNQUExQixDQUFWLENBQTRDMXFELElBQTVDOztBQUVBOGhELE1BQUFBLEtBQUs7O0FBRUwsYUFBTzloRCxJQUFQO0FBQ0QsS0E3REs7QUE4RE5NLElBQUFBLE1BQU0sRUFBRSxTQUFTQSxNQUFULENBQWdCd0MsUUFBaEIsRUFBMEJyRCxDQUExQixFQUE2QjtBQUNuQyxRQUFFQSxDQUFDLEdBQUdvRyxVQUFVLENBQUNxSCxPQUFYLENBQW1CcEssUUFBbkIsQ0FBTixLQUF1QytDLFVBQVUsQ0FBQ3JGLE1BQVgsQ0FBa0JmLENBQWxCLEVBQXFCLENBQXJCLENBQXZDLElBQWtFNitCLEVBQUUsSUFBSTcrQixDQUF4RSxJQUE2RTYrQixFQUFFLEVBQS9FO0FBQ0QsS0FoRUs7QUFpRU56NEIsSUFBQUEsVUFBVSxFQUFFQTtBQWpFTixHQUFSO0FBbUVBLFNBQU80akQsS0FBUDtBQUNELENBbEhhLEVBenNDZDtBQUFBLElBNHpDSTNILEtBQUssR0FBRyxTQUFTQSxLQUFULEdBQWlCO0FBQzNCLFNBQU8sQ0FBQ2lILGFBQUQsSUFBa0JqSyxPQUFPLENBQUNtTCxJQUFSLEVBQXpCO0FBQ0QsQ0E5ekNEO0FBQUEsSUErekNJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQVUsUUFBUSxHQUFHLEVBdDBDWDtBQUFBLElBdTBDSUMsY0FBYyxHQUFHLHFCQXYwQ3JCO0FBQUEsSUF3MENJQyxVQUFVLEdBQUcsT0F4MENqQjtBQUFBLElBeTBDSUMsb0JBQW9CLEdBQUcsU0FBU0Esb0JBQVQsQ0FBOEJqdUQsS0FBOUIsRUFBcUM7QUFDOUQ7QUFDQSxNQUFJb0MsR0FBRyxHQUFHLEVBQVY7QUFBQSxNQUNJNE8sS0FBSyxHQUFHaFIsS0FBSyxDQUFDZ3ZCLE1BQU4sQ0FBYSxDQUFiLEVBQWdCaHZCLEtBQUssQ0FBQzZDLE1BQU4sR0FBZSxDQUEvQixFQUFrQ21PLEtBQWxDLENBQXdDLEdBQXhDLENBRFo7QUFBQSxNQUVJNG1CLEdBQUcsR0FBRzVtQixLQUFLLENBQUMsQ0FBRCxDQUZmO0FBQUEsTUFHSXBPLENBQUMsR0FBRyxDQUhSO0FBQUEsTUFJSStJLENBQUMsR0FBR3FGLEtBQUssQ0FBQ25PLE1BSmQ7QUFBQSxNQUtJNGhCLEtBTEo7QUFBQSxNQU1JN1QsR0FOSjtBQUFBLE1BT0lzOUMsU0FQSjs7QUFTQSxTQUFPdHJELENBQUMsR0FBRytJLENBQVgsRUFBYy9JLENBQUMsRUFBZixFQUFtQjtBQUNqQmdPLElBQUFBLEdBQUcsR0FBR0ksS0FBSyxDQUFDcE8sQ0FBRCxDQUFYO0FBQ0E2aEIsSUFBQUEsS0FBSyxHQUFHN2hCLENBQUMsS0FBSytJLENBQUMsR0FBRyxDQUFWLEdBQWNpRixHQUFHLENBQUN1OUMsV0FBSixDQUFnQixHQUFoQixDQUFkLEdBQXFDdjlDLEdBQUcsQ0FBQy9OLE1BQWpEO0FBQ0FxckQsSUFBQUEsU0FBUyxHQUFHdDlDLEdBQUcsQ0FBQ29lLE1BQUosQ0FBVyxDQUFYLEVBQWN2SyxLQUFkLENBQVo7QUFDQXJpQixJQUFBQSxHQUFHLENBQUN3MUIsR0FBRCxDQUFILEdBQVd4bEIsS0FBSyxDQUFDODdDLFNBQUQsQ0FBTCxHQUFtQkEsU0FBUyxDQUFDanRELE9BQVYsQ0FBa0Irc0QsVUFBbEIsRUFBOEIsRUFBOUIsRUFBa0N4UCxJQUFsQyxFQUFuQixHQUE4RCxDQUFDMFAsU0FBMUU7QUFDQXQyQixJQUFBQSxHQUFHLEdBQUdobkIsR0FBRyxDQUFDb2UsTUFBSixDQUFXdkssS0FBSyxHQUFHLENBQW5CLEVBQXNCKzVCLElBQXRCLEVBQU47QUFDRDs7QUFFRCxTQUFPcDhDLEdBQVA7QUFDRCxDQTcxQ0Q7QUFBQSxJQTgxQ0lnc0QsbUJBQW1CLEdBQUcsU0FBU0EsbUJBQVQsQ0FBNkJwdUQsS0FBN0IsRUFBb0M7QUFDNUQsTUFBSXF1RCxJQUFJLEdBQUdydUQsS0FBSyxDQUFDcVEsT0FBTixDQUFjLEdBQWQsSUFBcUIsQ0FBaEM7QUFBQSxNQUNJaStDLEtBQUssR0FBR3R1RCxLQUFLLENBQUNxUSxPQUFOLENBQWMsR0FBZCxDQURaO0FBQUEsTUFFSWlvQyxNQUFNLEdBQUd0NEMsS0FBSyxDQUFDcVEsT0FBTixDQUFjLEdBQWQsRUFBbUJnK0MsSUFBbkIsQ0FGYjtBQUdBLFNBQU9ydUQsS0FBSyxDQUFDdXVELFNBQU4sQ0FBZ0JGLElBQWhCLEVBQXNCLENBQUMvVixNQUFELElBQVdBLE1BQU0sR0FBR2dXLEtBQXBCLEdBQTRCdHVELEtBQUssQ0FBQ3FRLE9BQU4sQ0FBYyxHQUFkLEVBQW1CaStDLEtBQUssR0FBRyxDQUEzQixDQUE1QixHQUE0REEsS0FBbEYsQ0FBUDtBQUNELENBbjJDRDtBQUFBLElBbzJDSUUscUJBQXFCLEdBQUcsU0FBU0EscUJBQVQsQ0FBK0JocEMsSUFBL0IsRUFBcUM7QUFDL0Q7QUFDQSxNQUFJeFUsS0FBSyxHQUFHLENBQUN3VSxJQUFJLEdBQUcsRUFBUixFQUFZeFUsS0FBWixDQUFrQixHQUFsQixDQUFaO0FBQUEsTUFDSXNnQyxJQUFJLEdBQUd3YyxRQUFRLENBQUM5OEMsS0FBSyxDQUFDLENBQUQsQ0FBTixDQURuQjtBQUVBLFNBQU9zZ0MsSUFBSSxJQUFJdGdDLEtBQUssQ0FBQ25PLE1BQU4sR0FBZSxDQUF2QixJQUE0Qnl1QyxJQUFJLENBQUM3VyxNQUFqQyxHQUEwQzZXLElBQUksQ0FBQzdXLE1BQUwsQ0FBWXZ4QixLQUFaLENBQWtCLElBQWxCLEVBQXdCLENBQUNzYyxJQUFJLENBQUNuVixPQUFMLENBQWEsR0FBYixDQUFELEdBQXFCLENBQUM0OUMsb0JBQW9CLENBQUNqOUMsS0FBSyxDQUFDLENBQUQsQ0FBTixDQUFyQixDQUFyQixHQUF3RG85QyxtQkFBbUIsQ0FBQzVvQyxJQUFELENBQW5CLENBQTBCeFUsS0FBMUIsQ0FBZ0MsR0FBaEMsRUFBcUNtUSxHQUFyQyxDQUF5Q285QixrQkFBekMsQ0FBaEYsQ0FBMUMsR0FBMEx1UCxRQUFRLENBQUNXLEdBQVQsSUFBZ0JWLGNBQWMsQ0FBQzdoRCxJQUFmLENBQW9Cc1osSUFBcEIsQ0FBaEIsR0FBNENzb0MsUUFBUSxDQUFDVyxHQUFULENBQWEsRUFBYixFQUFpQmpwQyxJQUFqQixDQUE1QyxHQUFxRThyQixJQUF0UTtBQUNELENBejJDRDtBQUFBLElBMDJDSThVLFdBQVcsR0FBRyxTQUFTQSxXQUFULENBQXFCOVUsSUFBckIsRUFBMkI7QUFDM0MsU0FBTyxVQUFVL3VDLENBQVYsRUFBYTtBQUNsQixXQUFPLElBQUkrdUMsSUFBSSxDQUFDLElBQUkvdUMsQ0FBTCxDQUFmO0FBQ0QsR0FGRDtBQUdELENBOTJDRDtBQUFBLElBKzJDSTtBQUNKbXNELGtCQUFrQixHQUFHLFNBQVNBLGtCQUFULENBQTRCanBCLFFBQTVCLEVBQXNDa3BCLE1BQXRDLEVBQThDO0FBQ2pFLE1BQUlsK0MsS0FBSyxHQUFHZzFCLFFBQVEsQ0FBQ3dkLE1BQXJCO0FBQUEsTUFDSTNSLElBREo7O0FBR0EsU0FBTzdnQyxLQUFQLEVBQWM7QUFDWixRQUFJQSxLQUFLLFlBQVkreUMsUUFBckIsRUFBK0I7QUFDN0JrTCxNQUFBQSxrQkFBa0IsQ0FBQ2orQyxLQUFELEVBQVFrK0MsTUFBUixDQUFsQjtBQUNELEtBRkQsTUFFTyxJQUFJbCtDLEtBQUssQ0FBQzNILElBQU4sQ0FBVzhsRCxRQUFYLEtBQXdCLENBQUNuK0MsS0FBSyxDQUFDZ3lDLEtBQVAsSUFBZ0IsQ0FBQ2h5QyxLQUFLLENBQUMrdkMsT0FBL0MsS0FBMkQvdkMsS0FBSyxDQUFDZ3lDLEtBQU4sS0FBZ0JrTSxNQUEvRSxFQUF1RjtBQUM1RixVQUFJbCtDLEtBQUssQ0FBQ2cxQixRQUFWLEVBQW9CO0FBQ2xCaXBCLFFBQUFBLGtCQUFrQixDQUFDaitDLEtBQUssQ0FBQ2cxQixRQUFQLEVBQWlCa3BCLE1BQWpCLENBQWxCO0FBQ0QsT0FGRCxNQUVPO0FBQ0xyZCxRQUFBQSxJQUFJLEdBQUc3Z0MsS0FBSyxDQUFDbytDLEtBQWI7QUFDQXArQyxRQUFBQSxLQUFLLENBQUNvK0MsS0FBTixHQUFjcCtDLEtBQUssQ0FBQ3ErQyxNQUFwQjtBQUNBcitDLFFBQUFBLEtBQUssQ0FBQ3ErQyxNQUFOLEdBQWV4ZCxJQUFmO0FBQ0E3Z0MsUUFBQUEsS0FBSyxDQUFDZ3lDLEtBQU4sR0FBY2tNLE1BQWQ7QUFDRDtBQUNGOztBQUVEbCtDLElBQUFBLEtBQUssR0FBR0EsS0FBSyxDQUFDd21CLEtBQWQ7QUFDRDtBQUNGLENBcDRDRDtBQUFBLElBcTRDSXV1QixVQUFVLEdBQUcsU0FBU0EsVUFBVCxDQUFvQmxVLElBQXBCLEVBQTBCeWQsV0FBMUIsRUFBdUM7QUFDdEQsU0FBTyxDQUFDemQsSUFBRCxHQUFReWQsV0FBUixHQUFzQixDQUFDaHZELFdBQVcsQ0FBQ3V4QyxJQUFELENBQVgsR0FBb0JBLElBQXBCLEdBQTJCd2MsUUFBUSxDQUFDeGMsSUFBRCxDQUFSLElBQWtCa2QscUJBQXFCLENBQUNsZCxJQUFELENBQW5FLEtBQThFeWQsV0FBM0c7QUFDRCxDQXY0Q0Q7QUFBQSxJQXc0Q0lDLFdBQVcsR0FBRyxTQUFTQSxXQUFULENBQXFCbFIsS0FBckIsRUFBNEJtUixNQUE1QixFQUFvQ0MsT0FBcEMsRUFBNkNDLFNBQTdDLEVBQXdEO0FBQ3hFLE1BQUlELE9BQU8sS0FBSyxLQUFLLENBQXJCLEVBQXdCO0FBQ3RCQSxJQUFBQSxPQUFPLEdBQUcsU0FBU0EsT0FBVCxDQUFpQjNzRCxDQUFqQixFQUFvQjtBQUM1QixhQUFPLElBQUkwc0QsTUFBTSxDQUFDLElBQUkxc0QsQ0FBTCxDQUFqQjtBQUNELEtBRkQ7QUFHRDs7QUFFRCxNQUFJNHNELFNBQVMsS0FBSyxLQUFLLENBQXZCLEVBQTBCO0FBQ3hCQSxJQUFBQSxTQUFTLEdBQUcsU0FBU0EsU0FBVCxDQUFtQjVzRCxDQUFuQixFQUFzQjtBQUNoQyxhQUFPQSxDQUFDLEdBQUcsRUFBSixHQUFTMHNELE1BQU0sQ0FBQzFzRCxDQUFDLEdBQUcsQ0FBTCxDQUFOLEdBQWdCLENBQXpCLEdBQTZCLElBQUkwc0QsTUFBTSxDQUFDLENBQUMsSUFBSTFzRCxDQUFMLElBQVUsQ0FBWCxDQUFOLEdBQXNCLENBQTlEO0FBQ0QsS0FGRDtBQUdEOztBQUVELE1BQUkrdUMsSUFBSSxHQUFHO0FBQ1QyZCxJQUFBQSxNQUFNLEVBQUVBLE1BREM7QUFFVEMsSUFBQUEsT0FBTyxFQUFFQSxPQUZBO0FBR1RDLElBQUFBLFNBQVMsRUFBRUE7QUFIRixHQUFYO0FBQUEsTUFLSUMsYUFMSjs7QUFPQXZSLEVBQUFBLFlBQVksQ0FBQ0MsS0FBRCxFQUFRLFVBQVV0NEIsSUFBVixFQUFnQjtBQUNsQ3NvQyxJQUFBQSxRQUFRLENBQUN0b0MsSUFBRCxDQUFSLEdBQWlCMjJCLFFBQVEsQ0FBQzMyQixJQUFELENBQVIsR0FBaUI4ckIsSUFBbEM7QUFDQXdjLElBQUFBLFFBQVEsQ0FBQ3NCLGFBQWEsR0FBRzVwQyxJQUFJLENBQUNsZSxXQUFMLEVBQWpCLENBQVIsR0FBK0M0bkQsT0FBL0M7O0FBRUEsU0FBSyxJQUFJM3NELENBQVQsSUFBYyt1QyxJQUFkLEVBQW9CO0FBQ2xCd2MsTUFBQUEsUUFBUSxDQUFDc0IsYUFBYSxJQUFJN3NELENBQUMsS0FBSyxRQUFOLEdBQWlCLEtBQWpCLEdBQXlCQSxDQUFDLEtBQUssU0FBTixHQUFrQixNQUFsQixHQUEyQixRQUF4RCxDQUFkLENBQVIsR0FBMkZ1ckQsUUFBUSxDQUFDdG9DLElBQUksR0FBRyxHQUFQLEdBQWFqakIsQ0FBZCxDQUFSLEdBQTJCK3VDLElBQUksQ0FBQy91QyxDQUFELENBQTFIO0FBQ0Q7QUFDRixHQVBXLENBQVo7O0FBU0EsU0FBTyt1QyxJQUFQO0FBQ0QsQ0F0NkNEO0FBQUEsSUF1NkNJK2QsaUJBQWlCLEdBQUcsU0FBU0EsaUJBQVQsQ0FBMkJILE9BQTNCLEVBQW9DO0FBQzFELFNBQU8sVUFBVTNzRCxDQUFWLEVBQWE7QUFDbEIsV0FBT0EsQ0FBQyxHQUFHLEVBQUosR0FBUyxDQUFDLElBQUkyc0QsT0FBTyxDQUFDLElBQUkzc0QsQ0FBQyxHQUFHLENBQVQsQ0FBWixJQUEyQixDQUFwQyxHQUF3QyxLQUFLMnNELE9BQU8sQ0FBQyxDQUFDM3NELENBQUMsR0FBRyxFQUFMLElBQVcsQ0FBWixDQUFQLEdBQXdCLENBQTVFO0FBQ0QsR0FGRDtBQUdELENBMzZDRDtBQUFBLElBNDZDSStzRCxjQUFjLEdBQUcsU0FBU0EsY0FBVCxDQUF3Qnp1RCxJQUF4QixFQUE4QjB1RCxTQUE5QixFQUF5Q0MsTUFBekMsRUFBaUQ7QUFDcEUsTUFBSWxsRCxFQUFFLEdBQUdpbEQsU0FBUyxJQUFJLENBQWIsR0FBaUJBLFNBQWpCLEdBQTZCLENBQXRDO0FBQUEsTUFDSTtBQUNKaGxELEVBQUFBLEVBQUUsR0FBRyxDQUFDaWxELE1BQU0sS0FBSzN1RCxJQUFJLEdBQUcsRUFBSCxHQUFRLEdBQWpCLENBQVAsS0FBaUMwdUQsU0FBUyxHQUFHLENBQVosR0FBZ0JBLFNBQWhCLEdBQTRCLENBQTdELENBRkw7QUFBQSxNQUdJL2tELEVBQUUsR0FBR0QsRUFBRSxHQUFHNndDLElBQUwsSUFBYTc2QyxJQUFJLENBQUNrdkQsSUFBTCxDQUFVLElBQUlubEQsRUFBZCxLQUFxQixDQUFsQyxDQUhUO0FBQUEsTUFJSTRrRCxPQUFPLEdBQUcsU0FBU0EsT0FBVCxDQUFpQjNzRCxDQUFqQixFQUFvQjtBQUNoQyxXQUFPQSxDQUFDLEtBQUssQ0FBTixHQUFVLENBQVYsR0FBYytILEVBQUUsR0FBRy9KLElBQUksQ0FBQzJ3QixHQUFMLENBQVMsQ0FBVCxFQUFZLENBQUMsRUFBRCxHQUFNM3VCLENBQWxCLENBQUwsR0FBNEIwZixJQUFJLENBQUMsQ0FBQzFmLENBQUMsR0FBR2lJLEVBQUwsSUFBV0QsRUFBWixDQUFoQyxHQUFrRCxDQUF2RTtBQUNELEdBTkQ7QUFBQSxNQU9JK21DLElBQUksR0FBR3p3QyxJQUFJLEtBQUssS0FBVCxHQUFpQnF1RCxPQUFqQixHQUEyQnJ1RCxJQUFJLEtBQUssSUFBVCxHQUFnQixVQUFVMEIsQ0FBVixFQUFhO0FBQ2pFLFdBQU8sSUFBSTJzRCxPQUFPLENBQUMsSUFBSTNzRCxDQUFMLENBQWxCO0FBQ0QsR0FGcUMsR0FFbEM4c0QsaUJBQWlCLENBQUNILE9BQUQsQ0FUckI7O0FBV0Eza0QsRUFBQUEsRUFBRSxHQUFHNndDLElBQUksR0FBRzd3QyxFQUFaLENBWm9FLENBWXBEOztBQUVoQittQyxFQUFBQSxJQUFJLENBQUM3VyxNQUFMLEdBQWMsVUFBVTgwQixTQUFWLEVBQXFCQyxNQUFyQixFQUE2QjtBQUN6QyxXQUFPRixjQUFjLENBQUN6dUQsSUFBRCxFQUFPMHVELFNBQVAsRUFBa0JDLE1BQWxCLENBQXJCO0FBQ0QsR0FGRDs7QUFJQSxTQUFPbGUsSUFBUDtBQUNELENBLzdDRDtBQUFBLElBZzhDSW9lLFdBQVcsR0FBRyxTQUFTQSxXQUFULENBQXFCN3VELElBQXJCLEVBQTJCd1ksU0FBM0IsRUFBc0M7QUFDdEQsTUFBSUEsU0FBUyxLQUFLLEtBQUssQ0FBdkIsRUFBMEI7QUFDeEJBLElBQUFBLFNBQVMsR0FBRyxPQUFaO0FBQ0Q7O0FBRUQsTUFBSTYxQyxPQUFPLEdBQUcsU0FBU0EsT0FBVCxDQUFpQjNzRCxDQUFqQixFQUFvQjtBQUNoQyxXQUFPQSxDQUFDLEdBQUcsRUFBRUEsQ0FBRixHQUFNQSxDQUFOLElBQVcsQ0FBQzhXLFNBQVMsR0FBRyxDQUFiLElBQWtCOVcsQ0FBbEIsR0FBc0I4VyxTQUFqQyxJQUE4QyxDQUFqRCxHQUFxRCxDQUE3RDtBQUNELEdBRkQ7QUFBQSxNQUdJaTRCLElBQUksR0FBR3p3QyxJQUFJLEtBQUssS0FBVCxHQUFpQnF1RCxPQUFqQixHQUEyQnJ1RCxJQUFJLEtBQUssSUFBVCxHQUFnQixVQUFVMEIsQ0FBVixFQUFhO0FBQ2pFLFdBQU8sSUFBSTJzRCxPQUFPLENBQUMsSUFBSTNzRCxDQUFMLENBQWxCO0FBQ0QsR0FGcUMsR0FFbEM4c0QsaUJBQWlCLENBQUNILE9BQUQsQ0FMckI7O0FBT0E1ZCxFQUFBQSxJQUFJLENBQUM3VyxNQUFMLEdBQWMsVUFBVXBoQixTQUFWLEVBQXFCO0FBQ2pDLFdBQU9xMkMsV0FBVyxDQUFDN3VELElBQUQsRUFBT3dZLFNBQVAsQ0FBbEI7QUFDRCxHQUZEOztBQUlBLFNBQU9pNEIsSUFBUDtBQUNELENBajlDRCxFQWk5Q0c7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBdU0sWUFBWSxDQUFDLHNDQUFELEVBQXlDLFVBQVVyNEIsSUFBVixFQUFnQjVpQixDQUFoQixFQUFtQjtBQUN0RSxNQUFJK3NELEtBQUssR0FBRy9zRCxDQUFDLEdBQUcsQ0FBSixHQUFRQSxDQUFDLEdBQUcsQ0FBWixHQUFnQkEsQ0FBNUI7O0FBRUFvc0QsRUFBQUEsV0FBVyxDQUFDeHBDLElBQUksR0FBRyxRQUFQLElBQW1CbXFDLEtBQUssR0FBRyxDQUEzQixDQUFELEVBQWdDL3NELENBQUMsR0FBRyxVQUFVTCxDQUFWLEVBQWE7QUFDMUQsV0FBT2hDLElBQUksQ0FBQzJ3QixHQUFMLENBQVMzdUIsQ0FBVCxFQUFZb3RELEtBQVosQ0FBUDtBQUNELEdBRjJDLEdBRXhDLFVBQVVwdEQsQ0FBVixFQUFhO0FBQ2YsV0FBT0EsQ0FBUDtBQUNELEdBSlUsRUFJUixVQUFVQSxDQUFWLEVBQWE7QUFDZCxXQUFPLElBQUloQyxJQUFJLENBQUMyd0IsR0FBTCxDQUFTLElBQUkzdUIsQ0FBYixFQUFnQm90RCxLQUFoQixDQUFYO0FBQ0QsR0FOVSxFQU1SLFVBQVVwdEQsQ0FBVixFQUFhO0FBQ2QsV0FBT0EsQ0FBQyxHQUFHLEVBQUosR0FBU2hDLElBQUksQ0FBQzJ3QixHQUFMLENBQVMzdUIsQ0FBQyxHQUFHLENBQWIsRUFBZ0JvdEQsS0FBaEIsSUFBeUIsQ0FBbEMsR0FBc0MsSUFBSXB2RCxJQUFJLENBQUMyd0IsR0FBTCxDQUFTLENBQUMsSUFBSTN1QixDQUFMLElBQVUsQ0FBbkIsRUFBc0JvdEQsS0FBdEIsSUFBK0IsQ0FBaEY7QUFDRCxHQVJVLENBQVg7QUFTRCxDQVpXLENBQVo7O0FBY0E3QixRQUFRLENBQUM4QixNQUFULENBQWdCQyxRQUFoQixHQUEyQi9CLFFBQVEsQ0FBQ2dDLElBQVQsR0FBZ0JoQyxRQUFRLENBQUM4QixNQUFULENBQWdCWCxNQUEzRDs7QUFFQUQsV0FBVyxDQUFDLFNBQUQsRUFBWU0sY0FBYyxDQUFDLElBQUQsQ0FBMUIsRUFBa0NBLGNBQWMsQ0FBQyxLQUFELENBQWhELEVBQXlEQSxjQUFjLEVBQXZFLENBQVg7O0FBRUEsQ0FBQyxVQUFVNTNDLENBQVYsRUFBYTBGLENBQWIsRUFBZ0I7QUFDZixNQUFJMnlDLEVBQUUsR0FBRyxJQUFJM3lDLENBQWI7QUFBQSxNQUNJNHlDLEVBQUUsR0FBRyxJQUFJRCxFQURiO0FBQUEsTUFFSUUsRUFBRSxHQUFHLE1BQU1GLEVBRmY7QUFBQSxNQUdJYixPQUFPLEdBQUcsU0FBU0EsT0FBVCxDQUFpQjNzRCxDQUFqQixFQUFvQjtBQUNoQyxXQUFPQSxDQUFDLEdBQUd3dEQsRUFBSixHQUFTcjRDLENBQUMsR0FBR25WLENBQUosR0FBUUEsQ0FBakIsR0FBcUJBLENBQUMsR0FBR3l0RCxFQUFKLEdBQVN0NEMsQ0FBQyxHQUFHblgsSUFBSSxDQUFDMndCLEdBQUwsQ0FBUzN1QixDQUFDLEdBQUcsTUFBTTZhLENBQW5CLEVBQXNCLENBQXRCLENBQUosR0FBK0IsR0FBeEMsR0FBOEM3YSxDQUFDLEdBQUcwdEQsRUFBSixHQUFTdjRDLENBQUMsSUFBSW5WLENBQUMsSUFBSSxPQUFPNmEsQ0FBaEIsQ0FBRCxHQUFzQjdhLENBQXRCLEdBQTBCLEtBQW5DLEdBQTJDbVYsQ0FBQyxHQUFHblgsSUFBSSxDQUFDMndCLEdBQUwsQ0FBUzN1QixDQUFDLEdBQUcsUUFBUTZhLENBQXJCLEVBQXdCLENBQXhCLENBQUosR0FBaUMsT0FBdEo7QUFDRCxHQUxEOztBQU9BNHhDLEVBQUFBLFdBQVcsQ0FBQyxRQUFELEVBQVcsVUFBVXpzRCxDQUFWLEVBQWE7QUFDakMsV0FBTyxJQUFJMnNELE9BQU8sQ0FBQyxJQUFJM3NELENBQUwsQ0FBbEI7QUFDRCxHQUZVLEVBRVIyc0QsT0FGUSxDQUFYO0FBR0QsQ0FYRCxFQVdHLE1BWEgsRUFXVyxJQVhYOztBQWFBRixXQUFXLENBQUMsTUFBRCxFQUFTLFVBQVV6c0QsQ0FBVixFQUFhO0FBQy9CLFNBQU9BLENBQUMsR0FBR2hDLElBQUksQ0FBQzJ3QixHQUFMLENBQVMsQ0FBVCxFQUFZLE1BQU0zdUIsQ0FBQyxHQUFHLENBQVYsQ0FBWixDQUFILEdBQStCLENBQXZDO0FBQ0QsQ0FGVSxDQUFYOztBQUlBeXNELFdBQVcsQ0FBQyxNQUFELEVBQVMsVUFBVXpzRCxDQUFWLEVBQWE7QUFDL0IsU0FBTyxFQUFFK2YsS0FBSyxDQUFDLElBQUkvZixDQUFDLEdBQUdBLENBQVQsQ0FBTCxHQUFtQixDQUFyQixDQUFQO0FBQ0QsQ0FGVSxDQUFYOztBQUlBeXNELFdBQVcsQ0FBQyxNQUFELEVBQVMsVUFBVXpzRCxDQUFWLEVBQWE7QUFDL0IsU0FBT0EsQ0FBQyxLQUFLLENBQU4sR0FBVSxDQUFWLEdBQWMsQ0FBQzRmLElBQUksQ0FBQzVmLENBQUMsR0FBRzg0QyxRQUFMLENBQUwsR0FBc0IsQ0FBM0M7QUFDRCxDQUZVLENBQVg7O0FBSUEyVCxXQUFXLENBQUMsTUFBRCxFQUFTVSxXQUFXLENBQUMsSUFBRCxDQUFwQixFQUE0QkEsV0FBVyxDQUFDLEtBQUQsQ0FBdkMsRUFBZ0RBLFdBQVcsRUFBM0QsQ0FBWDs7QUFFQTVCLFFBQVEsQ0FBQ29DLFdBQVQsR0FBdUJwQyxRQUFRLENBQUNxQyxLQUFULEdBQWlCaFUsUUFBUSxDQUFDK1QsV0FBVCxHQUF1QjtBQUM3RHoxQixFQUFBQSxNQUFNLEVBQUUsU0FBU0EsTUFBVCxDQUFnQjAxQixLQUFoQixFQUF1QkMsY0FBdkIsRUFBdUM7QUFDN0MsUUFBSUQsS0FBSyxLQUFLLEtBQUssQ0FBbkIsRUFBc0I7QUFDcEJBLE1BQUFBLEtBQUssR0FBRyxDQUFSO0FBQ0Q7O0FBRUQsUUFBSTdsRCxFQUFFLEdBQUcsSUFBSTZsRCxLQUFiO0FBQUEsUUFDSTVsRCxFQUFFLEdBQUc0bEQsS0FBSyxJQUFJQyxjQUFjLEdBQUcsQ0FBSCxHQUFPLENBQXpCLENBRGQ7QUFBQSxRQUVJNWxELEVBQUUsR0FBRzRsRCxjQUFjLEdBQUcsQ0FBSCxHQUFPLENBRjlCO0FBQUEsUUFHSXpwRCxHQUFHLEdBQUcsSUFBSXcwQyxRQUhkO0FBSUEsV0FBTyxVQUFVNTRDLENBQVYsRUFBYTtBQUNsQixhQUFPLENBQUMsQ0FBQ2dJLEVBQUUsR0FBRzB0QixNQUFNLENBQUMsQ0FBRCxFQUFJdHhCLEdBQUosRUFBU3BFLENBQVQsQ0FBWCxHQUF5QixDQUExQixJQUErQmlJLEVBQWhDLElBQXNDRixFQUE3QztBQUNELEtBRkQ7QUFHRDtBQWI0RCxDQUEvRDtBQWVBczhCLFNBQVMsQ0FBQzBLLElBQVYsR0FBaUJ3YyxRQUFRLENBQUMsVUFBRCxDQUF6Qjs7QUFFQWpRLFlBQVksQ0FBQyxvRUFBRCxFQUF1RSxVQUFVcjRCLElBQVYsRUFBZ0I7QUFDakcsU0FBTzgzQixjQUFjLElBQUk5M0IsSUFBSSxHQUFHLEdBQVAsR0FBYUEsSUFBYixHQUFvQixTQUE3QztBQUNELENBRlcsQ0FBWjtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdPLElBQUlrNEIsT0FBTyxHQUFHLFNBQVNBLE9BQVQsQ0FBaUJyNEMsTUFBakIsRUFBeUJtd0IsT0FBekIsRUFBa0M7QUFDckQsT0FBS2hWLEVBQUwsR0FBVTg2QixLQUFLLEVBQWY7QUFDQWoyQyxFQUFBQSxNQUFNLENBQUMwTyxLQUFQLEdBQWUsSUFBZjtBQUNBLE9BQUsxTyxNQUFMLEdBQWNBLE1BQWQ7QUFDQSxPQUFLbXdCLE9BQUwsR0FBZUEsT0FBZjtBQUNBLE9BQUtya0IsR0FBTCxHQUFXcWtCLE9BQU8sR0FBR0EsT0FBTyxDQUFDcmtCLEdBQVgsR0FBaUJ5c0MsWUFBbkM7QUFDQSxPQUFLcHhDLEdBQUwsR0FBV2dwQixPQUFPLEdBQUdBLE9BQU8sQ0FBQyt6QixTQUFYLEdBQXVCQyxVQUF6QztBQUNELENBUE07QUFRUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVPLElBQUk2RyxTQUFTLEdBQUcsYUFBYSxZQUFZO0FBQzlDLFdBQVNBLFNBQVQsQ0FBbUJ2bkQsSUFBbkIsRUFBeUI7QUFDdkIsU0FBS0EsSUFBTCxHQUFZQSxJQUFaO0FBQ0EsU0FBSzQ0QyxNQUFMLEdBQWMsQ0FBQzU0QyxJQUFJLENBQUNoRixLQUFOLElBQWUsQ0FBN0I7O0FBRUEsUUFBSSxLQUFLMDhDLE9BQUwsR0FBZTEzQyxJQUFJLENBQUN3NkMsTUFBTCxLQUFnQmdOLFFBQWhCLEdBQTJCLENBQUMsQ0FBNUIsR0FBZ0N4bkQsSUFBSSxDQUFDdzZDLE1BQUwsSUFBZSxDQUFsRSxFQUFxRTtBQUNuRTtBQUNBLFdBQUs1QyxPQUFMLEdBQWU1M0MsSUFBSSxDQUFDdzVDLFdBQUwsSUFBb0IsQ0FBbkM7QUFDQSxXQUFLRyxLQUFMLEdBQWEsQ0FBQyxDQUFDMzVDLElBQUksQ0FBQ3luRCxJQUFQLElBQWUsQ0FBQyxDQUFDem5ELElBQUksQ0FBQzhsRCxRQUFuQztBQUNEOztBQUVELFNBQUtwVSxHQUFMLEdBQVcsQ0FBWDs7QUFFQTJJLElBQUFBLFlBQVksQ0FBQyxJQUFELEVBQU8sQ0FBQ3I2QyxJQUFJLENBQUMvRSxRQUFiLEVBQXVCLENBQXZCLEVBQTBCLENBQTFCLENBQVo7O0FBRUEsU0FBS0UsSUFBTCxHQUFZNkUsSUFBSSxDQUFDN0UsSUFBakI7QUFDQWlvRCxJQUFBQSxhQUFhLElBQUlqSyxPQUFPLENBQUNtTCxJQUFSLEVBQWpCO0FBQ0Q7O0FBRUQsTUFBSXg3QyxNQUFNLEdBQUd5K0MsU0FBUyxDQUFDcHlELFNBQXZCOztBQUVBMlQsRUFBQUEsTUFBTSxDQUFDOU4sS0FBUCxHQUFlLFNBQVNBLEtBQVQsQ0FBZTlELEtBQWYsRUFBc0I7QUFDbkMsUUFBSUEsS0FBSyxJQUFJQSxLQUFLLEtBQUssQ0FBdkIsRUFBMEI7QUFDeEIsV0FBSzJRLE1BQUwsSUFBZSxLQUFLQSxNQUFMLENBQVl5d0MsaUJBQTNCLElBQWdELEtBQUtvUCxTQUFMLENBQWUsS0FBS3BiLE1BQUwsR0FBY3AxQyxLQUFkLEdBQXNCLEtBQUswaEQsTUFBMUMsQ0FBaEQ7QUFDQSxXQUFLQSxNQUFMLEdBQWMxaEQsS0FBZDtBQUNBLGFBQU8sSUFBUDtBQUNEOztBQUVELFdBQU8sS0FBSzBoRCxNQUFaO0FBQ0QsR0FSRDs7QUFVQTl2QyxFQUFBQSxNQUFNLENBQUM3TixRQUFQLEdBQWtCLFNBQVNBLFFBQVQsQ0FBa0IvRCxLQUFsQixFQUF5QjtBQUN6QyxXQUFPdU8sU0FBUyxDQUFDMUwsTUFBVixHQUFtQixLQUFLdzlDLGFBQUwsQ0FBbUIsS0FBS0csT0FBTCxHQUFlLENBQWYsR0FBbUJ4Z0QsS0FBSyxHQUFHLENBQUNBLEtBQUssR0FBRyxLQUFLMGdELE9BQWQsSUFBeUIsS0FBS0YsT0FBekQsR0FBbUV4Z0QsS0FBdEYsQ0FBbkIsR0FBa0gsS0FBS3FnRCxhQUFMLE1BQXdCLEtBQUtGLElBQXRKO0FBQ0QsR0FGRDs7QUFJQXZ1QyxFQUFBQSxNQUFNLENBQUN5dUMsYUFBUCxHQUF1QixTQUFTQSxhQUFULENBQXVCcmdELEtBQXZCLEVBQThCO0FBQ25ELFFBQUksQ0FBQ3VPLFNBQVMsQ0FBQzFMLE1BQWYsRUFBdUI7QUFDckIsYUFBTyxLQUFLMHlDLEtBQVo7QUFDRDs7QUFFRCxTQUFLdndCLE1BQUwsR0FBYyxDQUFkO0FBQ0EsV0FBT20rQixZQUFZLENBQUMsSUFBRCxFQUFPLEtBQUszQyxPQUFMLEdBQWUsQ0FBZixHQUFtQnhnRCxLQUFuQixHQUEyQixDQUFDQSxLQUFLLEdBQUcsS0FBS3dnRCxPQUFMLEdBQWUsS0FBS0UsT0FBN0IsS0FBeUMsS0FBS0YsT0FBTCxHQUFlLENBQXhELENBQWxDLENBQW5CO0FBQ0QsR0FQRDs7QUFTQTV1QyxFQUFBQSxNQUFNLENBQUNneUIsU0FBUCxHQUFtQixTQUFTQSxTQUFULENBQW1CNnNCLFVBQW5CLEVBQStCcjZDLGNBQS9CLEVBQStDO0FBQ2hFNnVDLElBQUFBLEtBQUs7O0FBRUwsUUFBSSxDQUFDMTJDLFNBQVMsQ0FBQzFMLE1BQWYsRUFBdUI7QUFDckIsYUFBTyxLQUFLeXlDLE1BQVo7QUFDRDs7QUFFRCxRQUFJM2tDLE1BQU0sR0FBRyxLQUFLdWtDLEdBQWxCOztBQUVBLFFBQUl2a0MsTUFBTSxJQUFJQSxNQUFNLENBQUN5d0MsaUJBQWpCLElBQXNDLEtBQUs1RyxHQUEvQyxFQUFvRDtBQUNsRDJHLE1BQUFBLGNBQWMsQ0FBQyxJQUFELEVBQU9zUCxVQUFQLENBQWQ7O0FBRUEsT0FBQzkvQyxNQUFNLENBQUN1a0MsR0FBUixJQUFldmtDLE1BQU0sQ0FBQ0EsTUFBdEIsSUFBZ0Mwd0MsY0FBYyxDQUFDMXdDLE1BQUQsRUFBUyxJQUFULENBQTlDLENBSGtELENBR1k7QUFDOUQ7O0FBRUEsYUFBT0EsTUFBTSxJQUFJQSxNQUFNLENBQUNBLE1BQXhCLEVBQWdDO0FBQzlCLFlBQUlBLE1BQU0sQ0FBQ0EsTUFBUCxDQUFjd2tDLEtBQWQsS0FBd0J4a0MsTUFBTSxDQUFDeWtDLE1BQVAsSUFBaUJ6a0MsTUFBTSxDQUFDNnBDLEdBQVAsSUFBYyxDQUFkLEdBQWtCN3BDLE1BQU0sQ0FBQzJrQyxNQUFQLEdBQWdCM2tDLE1BQU0sQ0FBQzZwQyxHQUF6QyxHQUErQyxDQUFDN3BDLE1BQU0sQ0FBQzB2QyxhQUFQLEtBQXlCMXZDLE1BQU0sQ0FBQzJrQyxNQUFqQyxJQUEyQyxDQUFDM2tDLE1BQU0sQ0FBQzZwQyxHQUFuSCxDQUE1QixFQUFxSjtBQUNuSjdwQyxVQUFBQSxNQUFNLENBQUNpekIsU0FBUCxDQUFpQmp6QixNQUFNLENBQUMya0MsTUFBeEIsRUFBZ0MsSUFBaEM7QUFDRDs7QUFFRDNrQyxRQUFBQSxNQUFNLEdBQUdBLE1BQU0sQ0FBQ0EsTUFBaEI7QUFDRDs7QUFFRCxVQUFJLENBQUMsS0FBS0EsTUFBTixJQUFnQixLQUFLdWtDLEdBQUwsQ0FBUzZLLGtCQUF6QixLQUFnRCxLQUFLdkYsR0FBTCxHQUFXLENBQVgsSUFBZ0JpVyxVQUFVLEdBQUcsS0FBS2xiLEtBQWxDLElBQTJDLEtBQUtpRixHQUFMLEdBQVcsQ0FBWCxJQUFnQmlXLFVBQVUsR0FBRyxDQUF4RSxJQUE2RSxDQUFDLEtBQUtsYixLQUFOLElBQWUsQ0FBQ2tiLFVBQTdJLENBQUosRUFBOEo7QUFDNUo7QUFDQWpQLFFBQUFBLGNBQWMsQ0FBQyxLQUFLdE0sR0FBTixFQUFXLElBQVgsRUFBaUIsS0FBS0UsTUFBTCxHQUFjLEtBQUtzTSxNQUFwQyxDQUFkO0FBQ0Q7QUFDRjs7QUFFRCxRQUFJLEtBQUtwTSxNQUFMLEtBQWdCbWIsVUFBaEIsSUFBOEIsQ0FBQyxLQUFLdFEsSUFBTixJQUFjLENBQUMvcEMsY0FBN0MsSUFBK0QsS0FBS3E3QixRQUFMLElBQWlCbHhDLElBQUksQ0FBQzJiLEdBQUwsQ0FBUyxLQUFLcWxDLE1BQWQsTUFBMEJwRyxRQUExRyxJQUFzSCxDQUFDc1YsVUFBRCxJQUFlLENBQUMsS0FBS2hmLFFBQXJCLEtBQWtDLEtBQUtsdUMsR0FBTCxJQUFZLEtBQUttdEQsU0FBbkQsQ0FBMUgsRUFBeUw7QUFDdkw7QUFDQSxXQUFLbFcsR0FBTCxLQUFhLEtBQUttVyxNQUFMLEdBQWNGLFVBQTNCLEVBRnVMLENBRS9JO0FBQ3hDO0FBQ0E7O0FBRUFuUyxNQUFBQSxlQUFlLENBQUMsSUFBRCxFQUFPbVMsVUFBUCxFQUFtQnI2QyxjQUFuQixDQUFmLENBTnVMLENBTXBJO0FBQ25EOztBQUVEOztBQUVELFdBQU8sSUFBUDtBQUNELEdBekNEOztBQTJDQXhFLEVBQUFBLE1BQU0sQ0FBQzRNLElBQVAsR0FBYyxTQUFTQSxJQUFULENBQWN4ZSxLQUFkLEVBQXFCb1csY0FBckIsRUFBcUM7QUFDakQsV0FBTzdILFNBQVMsQ0FBQzFMLE1BQVYsR0FBbUIsS0FBSytnQyxTQUFMLENBQWVyakMsSUFBSSxDQUFDa0osR0FBTCxDQUFTLEtBQUs0MkMsYUFBTCxFQUFULEVBQStCcmdELEtBQUssR0FBR3VnRCxxQkFBcUIsQ0FBQyxJQUFELENBQTVELEtBQXVFLEtBQUtKLElBQUwsR0FBWSxLQUFLTyxPQUF4RixNQUFxRzFnRCxLQUFLLEdBQUcsS0FBS21nRCxJQUFSLEdBQWUsQ0FBekgsQ0FBZixFQUE0SS9wQyxjQUE1SSxDQUFuQixHQUFpTCxLQUFLKytCLEtBQTdMLENBRGlELENBQ21KO0FBQ3JNLEdBRkQ7O0FBSUF2akMsRUFBQUEsTUFBTSxDQUFDMi9CLGFBQVAsR0FBdUIsU0FBU0EsYUFBVCxDQUF1QnZ4QyxLQUF2QixFQUE4Qm9XLGNBQTlCLEVBQThDO0FBQ25FLFdBQU83SCxTQUFTLENBQUMxTCxNQUFWLEdBQW1CLEtBQUsrZ0MsU0FBTCxDQUFlLEtBQUt5YyxhQUFMLEtBQXVCcmdELEtBQXRDLEVBQTZDb1csY0FBN0MsQ0FBbkIsR0FBa0YsS0FBS2lxQyxhQUFMLEtBQXVCOS9DLElBQUksQ0FBQ2tKLEdBQUwsQ0FBUyxDQUFULEVBQVksS0FBSzZyQyxNQUFMLEdBQWMsS0FBS0MsS0FBL0IsQ0FBdkIsR0FBK0QsS0FBS3oxQixLQUE3SjtBQUNELEdBRkQ7O0FBSUFsTyxFQUFBQSxNQUFNLENBQUNvUixRQUFQLEdBQWtCLFNBQVNBLFFBQVQsQ0FBa0JoakIsS0FBbEIsRUFBeUJvVyxjQUF6QixFQUF5QztBQUN6RCxXQUFPN0gsU0FBUyxDQUFDMUwsTUFBVixHQUFtQixLQUFLK2dDLFNBQUwsQ0FBZSxLQUFLNy9CLFFBQUwsTUFBbUIsS0FBSzArQyxLQUFMLElBQWMsRUFBRSxLQUFLRixTQUFMLEtBQW1CLENBQXJCLENBQWQsR0FBd0MsSUFBSXZpRCxLQUE1QyxHQUFvREEsS0FBdkUsSUFBZ0Z1Z0QscUJBQXFCLENBQUMsSUFBRCxDQUFwSCxFQUE0SG5xQyxjQUE1SCxDQUFuQixHQUFpSyxLQUFLclMsUUFBTCxLQUFrQnhELElBQUksQ0FBQ2tKLEdBQUwsQ0FBUyxDQUFULEVBQVksS0FBSzByQyxLQUFMLEdBQWEsS0FBS2dMLElBQTlCLENBQWxCLEdBQXdELEtBQUtyZ0MsS0FBck87QUFDRCxHQUZEOztBQUlBbE8sRUFBQUEsTUFBTSxDQUFDMndDLFNBQVAsR0FBbUIsU0FBU0EsU0FBVCxDQUFtQnZpRCxLQUFuQixFQUEwQm9XLGNBQTFCLEVBQTBDO0FBQzNELFFBQUl3cUMsYUFBYSxHQUFHLEtBQUs3OEMsUUFBTCxLQUFrQixLQUFLMjhDLE9BQTNDOztBQUVBLFdBQU9ueUMsU0FBUyxDQUFDMUwsTUFBVixHQUFtQixLQUFLK2dDLFNBQUwsQ0FBZSxLQUFLdVIsS0FBTCxHQUFhLENBQUNuMUMsS0FBSyxHQUFHLENBQVQsSUFBYzRnRCxhQUExQyxFQUF5RHhxQyxjQUF6RCxDQUFuQixHQUE4RixLQUFLb3FDLE9BQUwsR0FBZUMsZUFBZSxDQUFDLEtBQUtuTCxNQUFOLEVBQWNzTCxhQUFkLENBQWYsR0FBOEMsQ0FBN0QsR0FBaUUsQ0FBdEs7QUFDRCxHQUpELENBSUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFiQTs7QUFnQkFodkMsRUFBQUEsTUFBTSxDQUFDK3ZDLFNBQVAsR0FBbUIsU0FBU0EsU0FBVCxDQUFtQjNoRCxLQUFuQixFQUEwQjtBQUMzQyxRQUFJLENBQUN1TyxTQUFTLENBQUMxTCxNQUFmLEVBQXVCO0FBQ3JCLGFBQU8sS0FBS3ErQyxJQUFMLEtBQWMsQ0FBQy9GLFFBQWYsR0FBMEIsQ0FBMUIsR0FBOEIsS0FBSytGLElBQTFDLENBRHFCLENBQzJCO0FBQ2pEOztBQUVELFFBQUksS0FBS0EsSUFBTCxLQUFjbGhELEtBQWxCLEVBQXlCO0FBQ3ZCLGFBQU8sSUFBUDtBQUNEOztBQUVELFFBQUkyZ0QsS0FBSyxHQUFHLEtBQUtod0MsTUFBTCxJQUFlLEtBQUs2cEMsR0FBcEIsR0FBMEJ1Ryx1QkFBdUIsQ0FBQyxLQUFLcHdDLE1BQUwsQ0FBWXdrQyxLQUFiLEVBQW9CLElBQXBCLENBQWpELEdBQTZFLEtBQUtHLE1BQTlGLENBVDJDLENBUzJEO0FBQ3RHO0FBQ0E7QUFDQTs7QUFFQSxTQUFLNEwsSUFBTCxHQUFZLENBQUNsaEQsS0FBRCxJQUFVLENBQXRCO0FBQ0EsU0FBS3c2QyxHQUFMLEdBQVcsS0FBS29XLEdBQUwsSUFBWTV3RCxLQUFLLEtBQUssQ0FBQ203QyxRQUF2QixHQUFrQyxDQUFsQyxHQUFzQyxLQUFLK0YsSUFBdEQsQ0FmMkMsQ0FlaUI7O0FBRTVELFNBQUt0ZCxTQUFMLENBQWUzTCxNQUFNLENBQUMsQ0FBQyxLQUFLeXBCLE1BQVAsRUFBZSxLQUFLbk0sS0FBcEIsRUFBMkJvTCxLQUEzQixDQUFyQixFQUF3RCxJQUF4RDs7QUFFQU0sSUFBQUEsT0FBTyxDQUFDLElBQUQsQ0FBUCxDQW5CMkMsQ0FtQjVCOzs7QUFHZixXQUFPYixpQkFBaUIsQ0FBQyxJQUFELENBQXhCO0FBQ0QsR0F2QkQ7O0FBeUJBeHVDLEVBQUFBLE1BQU0sQ0FBQzQvQixNQUFQLEdBQWdCLFNBQVNBLE1BQVQsQ0FBZ0J4eEMsS0FBaEIsRUFBdUI7QUFDckMsUUFBSSxDQUFDdU8sU0FBUyxDQUFDMUwsTUFBZixFQUF1QjtBQUNyQixhQUFPLEtBQUsrdEQsR0FBWjtBQUNEOztBQUVELFFBQUksS0FBS0EsR0FBTCxLQUFhNXdELEtBQWpCLEVBQXdCO0FBQ3RCLFdBQUs0d0QsR0FBTCxHQUFXNXdELEtBQVg7O0FBRUEsVUFBSUEsS0FBSixFQUFXO0FBQ1QsYUFBSzJ3RCxNQUFMLEdBQWMsS0FBS3JiLE1BQUwsSUFBZS8wQyxJQUFJLENBQUNvRyxHQUFMLENBQVMsQ0FBQyxLQUFLKzZDLE1BQWYsRUFBdUIsS0FBS0osT0FBTCxFQUF2QixDQUE3QixDQURTLENBQzREOztBQUVyRSxhQUFLOUcsR0FBTCxHQUFXLEtBQUt3RixJQUFMLEdBQVksQ0FBdkIsQ0FIUyxDQUdpQjtBQUMzQixPQUpELE1BSU87QUFDTGlGLFFBQUFBLEtBQUs7O0FBRUwsYUFBS3pLLEdBQUwsR0FBVyxLQUFLMEcsSUFBaEIsQ0FISyxDQUdpQjs7QUFFdEIsYUFBS3RkLFNBQUwsQ0FBZSxLQUFLanpCLE1BQUwsSUFBZSxDQUFDLEtBQUtBLE1BQUwsQ0FBWXl3QyxpQkFBNUIsR0FBZ0QsS0FBS0UsT0FBTCxFQUFoRCxHQUFpRSxLQUFLaE0sTUFBTCxJQUFlLEtBQUtxYixNQUFwRyxFQUE0RyxLQUFLM3RDLFFBQUwsT0FBb0IsQ0FBcEIsSUFBeUJ6aUIsSUFBSSxDQUFDMmIsR0FBTCxDQUFTLEtBQUtxbEMsTUFBZCxNQUEwQnBHLFFBQW5ELEtBQWdFLEtBQUs3RixNQUFMLElBQWU2RixRQUEvRSxDQUE1RyxFQUxLLENBS2tNO0FBQ3hNO0FBQ0Y7O0FBRUQsV0FBTyxJQUFQO0FBQ0QsR0F0QkQ7O0FBd0JBdnBDLEVBQUFBLE1BQU0sQ0FBQzQrQyxTQUFQLEdBQW1CLFNBQVNBLFNBQVQsQ0FBbUJ4d0QsS0FBbkIsRUFBMEI7QUFDM0MsUUFBSXVPLFNBQVMsQ0FBQzFMLE1BQWQsRUFBc0I7QUFDcEIsV0FBS3V5QyxNQUFMLEdBQWNwMUMsS0FBZDtBQUNBLFVBQUkyUSxNQUFNLEdBQUcsS0FBS0EsTUFBTCxJQUFlLEtBQUt1a0MsR0FBakM7QUFDQXZrQyxNQUFBQSxNQUFNLEtBQUtBLE1BQU0sQ0FBQ2t4QixLQUFQLElBQWdCLENBQUMsS0FBS2x4QixNQUEzQixDQUFOLElBQTRDNndDLGNBQWMsQ0FBQzd3QyxNQUFELEVBQVMsSUFBVCxFQUFlM1EsS0FBSyxHQUFHLEtBQUswaEQsTUFBNUIsQ0FBMUQ7QUFDQSxhQUFPLElBQVA7QUFDRDs7QUFFRCxXQUFPLEtBQUt0TSxNQUFaO0FBQ0QsR0FURDs7QUFXQXhqQyxFQUFBQSxNQUFNLENBQUM4eEMsT0FBUCxHQUFpQixTQUFTQSxPQUFULENBQWlCbU4sY0FBakIsRUFBaUM7QUFDaEQsV0FBTyxLQUFLemIsTUFBTCxHQUFjLENBQUNtRyxXQUFXLENBQUNzVixjQUFELENBQVgsR0FBOEIsS0FBS3hRLGFBQUwsRUFBOUIsR0FBcUQsS0FBS3Q4QyxRQUFMLEVBQXRELElBQXlFeEQsSUFBSSxDQUFDMmIsR0FBTCxDQUFTLEtBQUtzK0IsR0FBTCxJQUFZLENBQXJCLENBQTlGO0FBQ0QsR0FGRDs7QUFJQTVvQyxFQUFBQSxNQUFNLENBQUMwdkMsT0FBUCxHQUFpQixTQUFTQSxPQUFULENBQWlCd1AsV0FBakIsRUFBOEI7QUFDN0MsUUFBSW5nRCxNQUFNLEdBQUcsS0FBS0EsTUFBTCxJQUFlLEtBQUt1a0MsR0FBakMsQ0FENkMsQ0FDUDs7QUFFdEMsV0FBTyxDQUFDdmtDLE1BQUQsR0FBVSxLQUFLMmtDLE1BQWYsR0FBd0J3YixXQUFXLEtBQUssQ0FBQyxLQUFLdFcsR0FBTixJQUFhLEtBQUtnRyxPQUFMLElBQWdCLEtBQUtyTCxLQUFyQixJQUE4QixLQUFLNUQsYUFBTCxLQUF1QixDQUF2RSxDQUFYLEdBQXVGLEtBQUsrRCxNQUFMLElBQWUsS0FBSzZLLElBQUwsR0FBWSxLQUFLTyxPQUFoQyxDQUF2RixHQUFrSSxDQUFDLEtBQUtsRyxHQUFOLEdBQVksS0FBS2xGLE1BQWpCLEdBQTBCeUwsdUJBQXVCLENBQUNwd0MsTUFBTSxDQUFDMndDLE9BQVAsQ0FBZXdQLFdBQWYsQ0FBRCxFQUE4QixJQUE5QixDQUFsTjtBQUNELEdBSkQ7O0FBTUFsL0MsRUFBQUEsTUFBTSxDQUFDbS9DLFVBQVAsR0FBb0IsU0FBU0EsVUFBVCxDQUFvQnpQLE9BQXBCLEVBQTZCO0FBQy9DLFFBQUk1ZCxTQUFTLEdBQUcsSUFBaEI7QUFBQSxRQUNJbGxCLElBQUksR0FBR2pRLFNBQVMsQ0FBQzFMLE1BQVYsR0FBbUJ5K0MsT0FBbkIsR0FBNkI1ZCxTQUFTLENBQUM0ZCxPQUFWLEVBRHhDOztBQUdBLFdBQU81ZCxTQUFQLEVBQWtCO0FBQ2hCbGxCLE1BQUFBLElBQUksR0FBR2tsQixTQUFTLENBQUMwUixNQUFWLEdBQW1CNTJCLElBQUksSUFBSWtsQixTQUFTLENBQUM4VyxHQUFWLElBQWlCLENBQXJCLENBQTlCO0FBQ0E5VyxNQUFBQSxTQUFTLEdBQUdBLFNBQVMsQ0FBQ3dSLEdBQXRCO0FBQ0Q7O0FBRUQsV0FBTzEyQixJQUFQO0FBQ0QsR0FWRDs7QUFZQTVNLEVBQUFBLE1BQU0sQ0FBQzB4QyxNQUFQLEdBQWdCLFNBQVNBLE1BQVQsQ0FBZ0J0akQsS0FBaEIsRUFBdUI7QUFDckMsUUFBSXVPLFNBQVMsQ0FBQzFMLE1BQWQsRUFBc0I7QUFDcEIsV0FBSzI5QyxPQUFMLEdBQWV4Z0QsS0FBSyxLQUFLc3dELFFBQVYsR0FBcUIsQ0FBQyxDQUF0QixHQUEwQnR3RCxLQUF6QztBQUNBLGFBQU91akQsc0JBQXNCLENBQUMsSUFBRCxDQUE3QjtBQUNEOztBQUVELFdBQU8sS0FBSy9DLE9BQUwsS0FBaUIsQ0FBQyxDQUFsQixHQUFzQjhQLFFBQXRCLEdBQWlDLEtBQUs5UCxPQUE3QztBQUNELEdBUEQ7O0FBU0E1dUMsRUFBQUEsTUFBTSxDQUFDMHdDLFdBQVAsR0FBcUIsU0FBU0EsV0FBVCxDQUFxQnRpRCxLQUFyQixFQUE0QjtBQUMvQyxRQUFJdU8sU0FBUyxDQUFDMUwsTUFBZCxFQUFzQjtBQUNwQixVQUFJMmIsSUFBSSxHQUFHLEtBQUsyMkIsS0FBaEI7QUFDQSxXQUFLdUwsT0FBTCxHQUFlMWdELEtBQWY7O0FBRUF1akQsTUFBQUEsc0JBQXNCLENBQUMsSUFBRCxDQUF0Qjs7QUFFQSxhQUFPL2tDLElBQUksR0FBRyxLQUFLQSxJQUFMLENBQVVBLElBQVYsQ0FBSCxHQUFxQixJQUFoQztBQUNEOztBQUVELFdBQU8sS0FBS2tpQyxPQUFaO0FBQ0QsR0FYRDs7QUFhQTl1QyxFQUFBQSxNQUFNLENBQUMyK0MsSUFBUCxHQUFjLFNBQVNBLElBQVQsQ0FBY3Z3RCxLQUFkLEVBQXFCO0FBQ2pDLFFBQUl1TyxTQUFTLENBQUMxTCxNQUFkLEVBQXNCO0FBQ3BCLFdBQUs0L0MsS0FBTCxHQUFhemlELEtBQWI7QUFDQSxhQUFPLElBQVA7QUFDRDs7QUFFRCxXQUFPLEtBQUt5aUQsS0FBWjtBQUNELEdBUEQ7O0FBU0E3d0MsRUFBQUEsTUFBTSxDQUFDeTZCLElBQVAsR0FBYyxTQUFTQSxJQUFULENBQWN6L0IsUUFBZCxFQUF3QndKLGNBQXhCLEVBQXdDO0FBQ3BELFdBQU8sS0FBS3d0QixTQUFMLENBQWVtSSxjQUFjLENBQUMsSUFBRCxFQUFPbi9CLFFBQVAsQ0FBN0IsRUFBK0MydUMsV0FBVyxDQUFDbmxDLGNBQUQsQ0FBMUQsQ0FBUDtBQUNELEdBRkQ7O0FBSUF4RSxFQUFBQSxNQUFNLENBQUN1dUIsT0FBUCxHQUFpQixTQUFTQSxPQUFULENBQWlCNndCLFlBQWpCLEVBQStCNTZDLGNBQS9CLEVBQStDO0FBQzlELFdBQU8sS0FBS3lELElBQUwsR0FBWStwQixTQUFaLENBQXNCb3RCLFlBQVksR0FBRyxDQUFDLEtBQUt0UCxNQUFULEdBQWtCLENBQXBELEVBQXVEbkcsV0FBVyxDQUFDbmxDLGNBQUQsQ0FBbEUsQ0FBUDtBQUNELEdBRkQ7O0FBSUF4RSxFQUFBQSxNQUFNLENBQUNpSSxJQUFQLEdBQWMsU0FBU0EsSUFBVCxDQUFjOEYsSUFBZCxFQUFvQnZKLGNBQXBCLEVBQW9DO0FBQ2hEdUosSUFBQUEsSUFBSSxJQUFJLElBQVIsSUFBZ0IsS0FBSzBzQixJQUFMLENBQVUxc0IsSUFBVixFQUFnQnZKLGNBQWhCLENBQWhCO0FBQ0EsV0FBTyxLQUFLMk4sUUFBTCxDQUFjLEtBQWQsRUFBcUJ5dEIsTUFBckIsQ0FBNEIsS0FBNUIsQ0FBUDtBQUNELEdBSEQ7O0FBS0E1L0IsRUFBQUEsTUFBTSxDQUFDa1MsT0FBUCxHQUFpQixTQUFTQSxPQUFULENBQWlCbkUsSUFBakIsRUFBdUJ2SixjQUF2QixFQUF1QztBQUN0RHVKLElBQUFBLElBQUksSUFBSSxJQUFSLElBQWdCLEtBQUswc0IsSUFBTCxDQUFVMXNCLElBQUksSUFBSSxLQUFLMGdDLGFBQUwsRUFBbEIsRUFBd0NqcUMsY0FBeEMsQ0FBaEI7QUFDQSxXQUFPLEtBQUsyTixRQUFMLENBQWMsSUFBZCxFQUFvQnl0QixNQUFwQixDQUEyQixLQUEzQixDQUFQO0FBQ0QsR0FIRDs7QUFLQTUvQixFQUFBQSxNQUFNLENBQUMwdEIsS0FBUCxHQUFlLFNBQVNBLEtBQVQsQ0FBZTJ4QixNQUFmLEVBQXVCNzZDLGNBQXZCLEVBQXVDO0FBQ3BENjZDLElBQUFBLE1BQU0sSUFBSSxJQUFWLElBQWtCLEtBQUs1a0IsSUFBTCxDQUFVNGtCLE1BQVYsRUFBa0I3NkMsY0FBbEIsQ0FBbEI7QUFDQSxXQUFPLEtBQUtvN0IsTUFBTCxDQUFZLElBQVosQ0FBUDtBQUNELEdBSEQ7O0FBS0E1L0IsRUFBQUEsTUFBTSxDQUFDcy9DLE1BQVAsR0FBZ0IsU0FBU0EsTUFBVCxHQUFrQjtBQUNoQyxXQUFPLEtBQUsxZixNQUFMLENBQVksS0FBWixDQUFQO0FBQ0QsR0FGRDs7QUFJQTUvQixFQUFBQSxNQUFNLENBQUNtUyxRQUFQLEdBQWtCLFNBQVNBLFFBQVQsQ0FBa0IvakIsS0FBbEIsRUFBeUI7QUFDekMsUUFBSXVPLFNBQVMsQ0FBQzFMLE1BQWQsRUFBc0I7QUFDcEIsT0FBQyxDQUFDN0MsS0FBRixLQUFZLEtBQUsrakIsUUFBTCxFQUFaLElBQStCLEtBQUs0OUIsU0FBTCxDQUFlLENBQUMsS0FBS1QsSUFBTixLQUFlbGhELEtBQUssR0FBRyxDQUFDbTdDLFFBQUosR0FBZSxDQUFuQyxDQUFmLENBQS9CLENBRG9CLENBQ2tFOztBQUV0RixhQUFPLElBQVA7QUFDRDs7QUFFRCxXQUFPLEtBQUsrRixJQUFMLEdBQVksQ0FBbkI7QUFDRCxHQVJEOztBQVVBdHZDLEVBQUFBLE1BQU0sQ0FBQ3loQyxVQUFQLEdBQW9CLFNBQVNBLFVBQVQsR0FBc0I7QUFDeEMsU0FBSzVCLFFBQUwsR0FBZ0IsS0FBS3VPLElBQUwsR0FBWSxDQUE1QjtBQUNBLFNBQUt1QixNQUFMLEdBQWMsQ0FBQ3BHLFFBQWY7QUFDQSxXQUFPLElBQVA7QUFDRCxHQUpEOztBQU1BdnBDLEVBQUFBLE1BQU0sQ0FBQ2tKLFFBQVAsR0FBa0IsU0FBU0EsUUFBVCxHQUFvQjtBQUNwQyxRQUFJbkssTUFBTSxHQUFHLEtBQUtBLE1BQUwsSUFBZSxLQUFLdWtDLEdBQWpDO0FBQUEsUUFDSWo3QixLQUFLLEdBQUcsS0FBS203QixNQURqQjtBQUFBLFFBRUlrTSxPQUZKO0FBR0EsV0FBTyxDQUFDLEVBQUUsQ0FBQzN3QyxNQUFELElBQVcsS0FBSzZwQyxHQUFMLElBQVksS0FBSy9JLFFBQWpCLElBQTZCOWdDLE1BQU0sQ0FBQ21LLFFBQVAsRUFBN0IsSUFBa0QsQ0FBQ3dtQyxPQUFPLEdBQUczd0MsTUFBTSxDQUFDMndDLE9BQVAsQ0FBZSxJQUFmLENBQVgsS0FBb0NybkMsS0FBdEYsSUFBK0ZxbkMsT0FBTyxHQUFHLEtBQUtvQyxPQUFMLENBQWEsSUFBYixJQUFxQnZJLFFBQTNJLENBQVI7QUFDRCxHQUxEOztBQU9BdnBDLEVBQUFBLE1BQU0sQ0FBQ21oQyxhQUFQLEdBQXVCLFNBQVNBLGFBQVQsQ0FBdUJseUMsSUFBdkIsRUFBNkJvRixRQUE3QixFQUF1Qys5QyxNQUF2QyxFQUErQztBQUNwRSxRQUFJbDdDLElBQUksR0FBRyxLQUFLQSxJQUFoQjs7QUFFQSxRQUFJeUYsU0FBUyxDQUFDMUwsTUFBVixHQUFtQixDQUF2QixFQUEwQjtBQUN4QixVQUFJLENBQUNvRCxRQUFMLEVBQWU7QUFDYixlQUFPNkMsSUFBSSxDQUFDakksSUFBRCxDQUFYO0FBQ0QsT0FGRCxNQUVPO0FBQ0xpSSxRQUFBQSxJQUFJLENBQUNqSSxJQUFELENBQUosR0FBYW9GLFFBQWI7QUFDQSs5QyxRQUFBQSxNQUFNLEtBQUtsN0MsSUFBSSxDQUFDakksSUFBSSxHQUFHLFFBQVIsQ0FBSixHQUF3Qm1qRCxNQUE3QixDQUFOO0FBQ0FuakQsUUFBQUEsSUFBSSxLQUFLLFVBQVQsS0FBd0IsS0FBS2dpRCxTQUFMLEdBQWlCNThDLFFBQXpDO0FBQ0Q7O0FBRUQsYUFBTyxJQUFQO0FBQ0Q7O0FBRUQsV0FBTzZDLElBQUksQ0FBQ2pJLElBQUQsQ0FBWDtBQUNELEdBaEJEOztBQWtCQStRLEVBQUFBLE1BQU0sQ0FBQ3UvQyxJQUFQLEdBQWMsU0FBU0EsSUFBVCxDQUFjQyxXQUFkLEVBQTJCO0FBQ3ZDLFFBQUl4ekQsSUFBSSxHQUFHLElBQVg7QUFDQSxXQUFPLElBQUl5ekQsT0FBSixDQUFZLFVBQVVDLE9BQVYsRUFBbUI7QUFDcEMsVUFBSS96QyxDQUFDLEdBQUd4ZCxXQUFXLENBQUNxeEQsV0FBRCxDQUFYLEdBQTJCQSxXQUEzQixHQUF5QzM0QixZQUFqRDtBQUFBLFVBQ0k4NEIsUUFBUSxHQUFHLFNBQVNBLFFBQVQsR0FBb0I7QUFDakMsWUFBSUMsS0FBSyxHQUFHNXpELElBQUksQ0FBQ3V6RCxJQUFqQjtBQUNBdnpELFFBQUFBLElBQUksQ0FBQ3V6RCxJQUFMLEdBQVksSUFBWixDQUZpQyxDQUVmOztBQUVsQnB4RCxRQUFBQSxXQUFXLENBQUN3ZCxDQUFELENBQVgsS0FBbUJBLENBQUMsR0FBR0EsQ0FBQyxDQUFDM2YsSUFBRCxDQUF4QixNQUFvQzJmLENBQUMsQ0FBQzR6QyxJQUFGLElBQVU1ekMsQ0FBQyxLQUFLM2YsSUFBcEQsTUFBOERBLElBQUksQ0FBQ3V6RCxJQUFMLEdBQVlLLEtBQTFFO0FBQ0FGLFFBQUFBLE9BQU8sQ0FBQy96QyxDQUFELENBQVA7QUFDQTNmLFFBQUFBLElBQUksQ0FBQ3V6RCxJQUFMLEdBQVlLLEtBQVo7QUFDRCxPQVJEOztBQVVBLFVBQUk1ekQsSUFBSSxDQUFDNnpDLFFBQUwsSUFBaUI3ekMsSUFBSSxDQUFDMnpDLGFBQUwsT0FBeUIsQ0FBMUMsSUFBK0MzekMsSUFBSSxDQUFDNDhDLEdBQUwsSUFBWSxDQUEzRCxJQUFnRSxDQUFDNThDLElBQUksQ0FBQzAzQyxNQUFOLElBQWdCMTNDLElBQUksQ0FBQzQ4QyxHQUFMLEdBQVcsQ0FBL0YsRUFBa0c7QUFDaEcrVyxRQUFBQSxRQUFRO0FBQ1QsT0FGRCxNQUVPO0FBQ0wzekQsUUFBQUEsSUFBSSxDQUFDa2xELEtBQUwsR0FBYXlPLFFBQWI7QUFDRDtBQUNGLEtBaEJNLENBQVA7QUFpQkQsR0FuQkQ7O0FBcUJBMy9DLEVBQUFBLE1BQU0sQ0FBQzhKLElBQVAsR0FBYyxTQUFTQSxJQUFULEdBQWdCO0FBQzVCbXRDLElBQUFBLFVBQVUsQ0FBQyxJQUFELENBQVY7QUFDRCxHQUZEOztBQUlBLFNBQU93SCxTQUFQO0FBQ0QsQ0FsVW1DLEVBQTdCOztBQW9VUG5zRCxZQUFZLENBQUNtc0QsU0FBUyxDQUFDcHlELFNBQVgsRUFBc0I7QUFDaENrM0MsRUFBQUEsS0FBSyxFQUFFLENBRHlCO0FBRWhDQyxFQUFBQSxNQUFNLEVBQUUsQ0FGd0I7QUFHaEM4SyxFQUFBQSxJQUFJLEVBQUUsQ0FIMEI7QUFJaEM1SyxFQUFBQSxNQUFNLEVBQUUsQ0FKd0I7QUFLaENDLEVBQUFBLEtBQUssRUFBRSxDQUx5QjtBQU1oQ3Z3QixFQUFBQSxNQUFNLEVBQUUsQ0FOd0I7QUFPaEN3N0IsRUFBQUEsT0FBTyxFQUFFLENBUHVCO0FBUWhDaUMsRUFBQUEsS0FBSyxFQUFFLEtBUnlCO0FBU2hDOXhDLEVBQUFBLE1BQU0sRUFBRSxJQVR3QjtBQVVoQzhnQyxFQUFBQSxRQUFRLEVBQUUsS0FWc0I7QUFXaENpUCxFQUFBQSxPQUFPLEVBQUUsQ0FYdUI7QUFZaENsRyxFQUFBQSxHQUFHLEVBQUUsQ0FaMkI7QUFhaEN0RixFQUFBQSxHQUFHLEVBQUUsQ0FiMkI7QUFjaENwMUIsRUFBQUEsS0FBSyxFQUFFLENBZHlCO0FBZWhDeWhDLEVBQUFBLE1BQU0sRUFBRSxDQUFDcEcsUUFmdUI7QUFnQmhDMkgsRUFBQUEsS0FBSyxFQUFFLENBaEJ5QjtBQWlCaEM4TixFQUFBQSxHQUFHLEVBQUUsS0FqQjJCO0FBa0JoQzFQLEVBQUFBLElBQUksRUFBRTtBQWxCMEIsQ0FBdEIsQ0FBWjtBQW9CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHTyxJQUFJc0MsUUFBUSxHQUFHLGFBQWEsVUFBVWlPLFVBQVYsRUFBc0I7QUFDdkQzekQsRUFBQUEsY0FBYyxDQUFDMGxELFFBQUQsRUFBV2lPLFVBQVgsQ0FBZDs7QUFFQSxXQUFTak8sUUFBVCxDQUFrQjE2QyxJQUFsQixFQUF3QjhELFFBQXhCLEVBQWtDO0FBQ2hDLFFBQUlpRixLQUFKOztBQUVBLFFBQUkvSSxJQUFJLEtBQUssS0FBSyxDQUFsQixFQUFxQjtBQUNuQkEsTUFBQUEsSUFBSSxHQUFHLEVBQVA7QUFDRDs7QUFFRCtJLElBQUFBLEtBQUssR0FBRzQvQyxVQUFVLENBQUM1bEQsSUFBWCxDQUFnQixJQUFoQixFQUFzQi9DLElBQXRCLEtBQStCLElBQXZDO0FBQ0ErSSxJQUFBQSxLQUFLLENBQUM2ekIsTUFBTixHQUFlLEVBQWY7QUFDQTd6QixJQUFBQSxLQUFLLENBQUN1dkMsaUJBQU4sR0FBMEIsQ0FBQyxDQUFDdDRDLElBQUksQ0FBQ3M0QyxpQkFBakM7QUFDQXZ2QyxJQUFBQSxLQUFLLENBQUNrdUMsa0JBQU4sR0FBMkIsQ0FBQyxDQUFDajNDLElBQUksQ0FBQ2kzQyxrQkFBbEM7QUFDQWx1QyxJQUFBQSxLQUFLLENBQUNnd0IsS0FBTixHQUFjMFosV0FBVyxDQUFDenlDLElBQUksQ0FBQzRvRCxZQUFOLENBQXpCO0FBQ0F4VixJQUFBQSxlQUFlLElBQUlzRixjQUFjLENBQUMxNEMsSUFBSSxDQUFDNkgsTUFBTCxJQUFldXJDLGVBQWhCLEVBQWlDditDLHNCQUFzQixDQUFDa1UsS0FBRCxDQUF2RCxFQUFnRWpGLFFBQWhFLENBQWpDO0FBQ0E5RCxJQUFBQSxJQUFJLENBQUNpYixRQUFMLElBQWlCbFMsS0FBSyxDQUFDaVMsT0FBTixFQUFqQjtBQUNBaGIsSUFBQUEsSUFBSSxDQUFDMG9DLE1BQUwsSUFBZTMvQixLQUFLLENBQUMyL0IsTUFBTixDQUFhLElBQWIsQ0FBZjtBQUNBMW9DLElBQUFBLElBQUksQ0FBQzZvQyxhQUFMLElBQXNCbVEsY0FBYyxDQUFDbmtELHNCQUFzQixDQUFDa1UsS0FBRCxDQUF2QixFQUFnQy9JLElBQUksQ0FBQzZvQyxhQUFyQyxDQUFwQztBQUNBLFdBQU85L0IsS0FBUDtBQUNEOztBQUVELE1BQUk4L0MsT0FBTyxHQUFHbk8sUUFBUSxDQUFDdmxELFNBQXZCOztBQUVBMHpELEVBQUFBLE9BQU8sQ0FBQy90RCxFQUFSLEdBQWEsU0FBU0EsRUFBVCxDQUFZc2QsT0FBWixFQUFxQnBZLElBQXJCLEVBQTJCOEQsUUFBM0IsRUFBcUM7QUFDaERtM0MsSUFBQUEsZ0JBQWdCLENBQUMsQ0FBRCxFQUFJeDFDLFNBQUosRUFBZSxJQUFmLENBQWhCOztBQUVBLFdBQU8sSUFBUDtBQUNELEdBSkQ7O0FBTUFvakQsRUFBQUEsT0FBTyxDQUFDaHlDLElBQVIsR0FBZSxTQUFTQSxJQUFULENBQWN1QixPQUFkLEVBQXVCcFksSUFBdkIsRUFBNkI4RCxRQUE3QixFQUF1QztBQUNwRG0zQyxJQUFBQSxnQkFBZ0IsQ0FBQyxDQUFELEVBQUl4MUMsU0FBSixFQUFlLElBQWYsQ0FBaEI7O0FBRUEsV0FBTyxJQUFQO0FBQ0QsR0FKRDs7QUFNQW9qRCxFQUFBQSxPQUFPLENBQUNDLE1BQVIsR0FBaUIsU0FBU0EsTUFBVCxDQUFnQjF3QyxPQUFoQixFQUF5QjJ3QyxRQUF6QixFQUFtQ0MsTUFBbkMsRUFBMkNsbEQsUUFBM0MsRUFBcUQ7QUFDcEVtM0MsSUFBQUEsZ0JBQWdCLENBQUMsQ0FBRCxFQUFJeDFDLFNBQUosRUFBZSxJQUFmLENBQWhCOztBQUVBLFdBQU8sSUFBUDtBQUNELEdBSkQ7O0FBTUFvakQsRUFBQUEsT0FBTyxDQUFDbmxELEdBQVIsR0FBYyxTQUFTQSxHQUFULENBQWEwVSxPQUFiLEVBQXNCcFksSUFBdEIsRUFBNEI4RCxRQUE1QixFQUFzQztBQUNsRDlELElBQUFBLElBQUksQ0FBQy9FLFFBQUwsR0FBZ0IsQ0FBaEI7QUFDQStFLElBQUFBLElBQUksQ0FBQzZILE1BQUwsR0FBYyxJQUFkO0FBQ0FxdUMsSUFBQUEsZ0JBQWdCLENBQUNsMkMsSUFBRCxDQUFoQixDQUF1Qnc1QyxXQUF2QixLQUF1Q3g1QyxJQUFJLENBQUN3NkMsTUFBTCxHQUFjLENBQXJEO0FBQ0F4NkMsSUFBQUEsSUFBSSxDQUFDNG9DLGVBQUwsR0FBdUIsQ0FBQyxDQUFDNW9DLElBQUksQ0FBQzRvQyxlQUE5QjtBQUNBLFFBQUk0UyxLQUFKLENBQVVwakMsT0FBVixFQUFtQnBZLElBQW5CLEVBQXlCaWpDLGNBQWMsQ0FBQyxJQUFELEVBQU9uL0IsUUFBUCxDQUF2QyxFQUF5RCxDQUF6RDtBQUNBLFdBQU8sSUFBUDtBQUNELEdBUEQ7O0FBU0Era0QsRUFBQUEsT0FBTyxDQUFDOWxELElBQVIsR0FBZSxTQUFTQSxJQUFULENBQWM1RixRQUFkLEVBQXdCKzlDLE1BQXhCLEVBQWdDcDNDLFFBQWhDLEVBQTBDO0FBQ3ZELFdBQU80MEMsY0FBYyxDQUFDLElBQUQsRUFBTzhDLEtBQUssQ0FBQzNtQyxXQUFOLENBQWtCLENBQWxCLEVBQXFCMVgsUUFBckIsRUFBK0IrOUMsTUFBL0IsQ0FBUCxFQUErQ3AzQyxRQUEvQyxDQUFyQjtBQUNELEdBRkQsQ0FFRTtBQUZGOztBQUtBK2tELEVBQUFBLE9BQU8sQ0FBQ0ksU0FBUixHQUFvQixTQUFTQSxTQUFULENBQW1CN3dDLE9BQW5CLEVBQTRCbmQsUUFBNUIsRUFBc0MrRSxJQUF0QyxFQUE0Q2twRCxPQUE1QyxFQUFxRHBsRCxRQUFyRCxFQUErRHFsRCxhQUEvRCxFQUE4RUMsbUJBQTlFLEVBQW1HO0FBQ3JIcHBELElBQUFBLElBQUksQ0FBQy9FLFFBQUwsR0FBZ0JBLFFBQWhCO0FBQ0ErRSxJQUFBQSxJQUFJLENBQUNrcEQsT0FBTCxHQUFlbHBELElBQUksQ0FBQ2twRCxPQUFMLElBQWdCQSxPQUEvQjtBQUNBbHBELElBQUFBLElBQUksQ0FBQzlFLFVBQUwsR0FBa0JpdUQsYUFBbEI7QUFDQW5wRCxJQUFBQSxJQUFJLENBQUNxcEQsZ0JBQUwsR0FBd0JELG1CQUF4QjtBQUNBcHBELElBQUFBLElBQUksQ0FBQzZILE1BQUwsR0FBYyxJQUFkO0FBQ0EsUUFBSTJ6QyxLQUFKLENBQVVwakMsT0FBVixFQUFtQnBZLElBQW5CLEVBQXlCaWpDLGNBQWMsQ0FBQyxJQUFELEVBQU9uL0IsUUFBUCxDQUF2QztBQUNBLFdBQU8sSUFBUDtBQUNELEdBUkQ7O0FBVUEra0QsRUFBQUEsT0FBTyxDQUFDUyxXQUFSLEdBQXNCLFNBQVNBLFdBQVQsQ0FBcUJseEMsT0FBckIsRUFBOEJuZCxRQUE5QixFQUF3QytFLElBQXhDLEVBQThDa3BELE9BQTlDLEVBQXVEcGxELFFBQXZELEVBQWlFcWxELGFBQWpFLEVBQWdGQyxtQkFBaEYsRUFBcUc7QUFDekhwcEQsSUFBQUEsSUFBSSxDQUFDczdDLFlBQUwsR0FBb0IsQ0FBcEI7QUFDQXBGLElBQUFBLGdCQUFnQixDQUFDbDJDLElBQUQsQ0FBaEIsQ0FBdUI0b0MsZUFBdkIsR0FBeUM2SixXQUFXLENBQUN6eUMsSUFBSSxDQUFDNG9DLGVBQU4sQ0FBcEQ7QUFDQSxXQUFPLEtBQUtxZ0IsU0FBTCxDQUFlN3dDLE9BQWYsRUFBd0JuZCxRQUF4QixFQUFrQytFLElBQWxDLEVBQXdDa3BELE9BQXhDLEVBQWlEcGxELFFBQWpELEVBQTJEcWxELGFBQTNELEVBQTBFQyxtQkFBMUUsQ0FBUDtBQUNELEdBSkQ7O0FBTUFQLEVBQUFBLE9BQU8sQ0FBQ1UsYUFBUixHQUF3QixTQUFTQSxhQUFULENBQXVCbnhDLE9BQXZCLEVBQWdDbmQsUUFBaEMsRUFBMEM4dEQsUUFBMUMsRUFBb0RDLE1BQXBELEVBQTRERSxPQUE1RCxFQUFxRXBsRCxRQUFyRSxFQUErRXFsRCxhQUEvRSxFQUE4RkMsbUJBQTlGLEVBQW1IO0FBQ3pJSixJQUFBQSxNQUFNLENBQUN6TixPQUFQLEdBQWlCd04sUUFBakI7QUFDQTdTLElBQUFBLGdCQUFnQixDQUFDOFMsTUFBRCxDQUFoQixDQUF5QnBnQixlQUF6QixHQUEyQzZKLFdBQVcsQ0FBQ3VXLE1BQU0sQ0FBQ3BnQixlQUFSLENBQXREO0FBQ0EsV0FBTyxLQUFLcWdCLFNBQUwsQ0FBZTd3QyxPQUFmLEVBQXdCbmQsUUFBeEIsRUFBa0MrdEQsTUFBbEMsRUFBMENFLE9BQTFDLEVBQW1EcGxELFFBQW5ELEVBQTZEcWxELGFBQTdELEVBQTRFQyxtQkFBNUUsQ0FBUDtBQUNELEdBSkQ7O0FBTUFQLEVBQUFBLE9BQU8sQ0FBQ3g3QyxNQUFSLEdBQWlCLFNBQVNBLE1BQVQsQ0FBZ0J5dEIsU0FBaEIsRUFBMkJ4dEIsY0FBM0IsRUFBMkM5SCxLQUEzQyxFQUFrRDtBQUNqRSxRQUFJMDBDLFFBQVEsR0FBRyxLQUFLN04sS0FBcEI7QUFBQSxRQUNJbWQsSUFBSSxHQUFHLEtBQUt0dEMsTUFBTCxHQUFjLEtBQUtxN0IsYUFBTCxFQUFkLEdBQXFDLEtBQUs5SyxLQURyRDtBQUFBLFFBRUk2RSxHQUFHLEdBQUcsS0FBSytGLElBRmY7QUFBQSxRQUdJUSxLQUFLLEdBQUcvYyxTQUFTLElBQUksQ0FBYixHQUFpQixDQUFqQixHQUFxQjNnQixhQUFhLENBQUMyZ0IsU0FBRCxDQUg5QztBQUFBLFFBSUk7QUFDSjJ1QixJQUFBQSxhQUFhLEdBQUcsS0FBS2hSLE1BQUwsR0FBYyxDQUFkLEtBQW9CM2QsU0FBUyxHQUFHLENBQWhDLEtBQXNDLEtBQUs2TixRQUFMLElBQWlCLENBQUMySSxHQUF4RCxDQUxoQjtBQUFBLFFBTUk1N0IsSUFOSjtBQUFBLFFBT0kvTixLQVBKO0FBQUEsUUFRSXdpQyxJQVJKO0FBQUEsUUFTSXNQLFNBVEo7QUFBQSxRQVVJM0IsYUFWSjtBQUFBLFFBV0k0UixVQVhKO0FBQUEsUUFZSUMsVUFaSjtBQUFBLFFBYUk5USxTQWJKO0FBQUEsUUFjSStRLFNBZEo7QUFBQSxRQWVJbFEsYUFmSjtBQUFBLFFBZ0JJK04sSUFoQko7QUFBQSxRQWlCSTVCLE1BakJKO0FBa0JBLGFBQVN6UyxlQUFULElBQTRCeUUsS0FBSyxHQUFHMlIsSUFBcEMsSUFBNEMxdUIsU0FBUyxJQUFJLENBQXpELEtBQStEK2MsS0FBSyxHQUFHMlIsSUFBdkU7O0FBRUEsUUFBSTNSLEtBQUssS0FBSyxLQUFLckwsTUFBZixJQUF5QmhuQyxLQUF6QixJQUFrQ2lrRCxhQUF0QyxFQUFxRDtBQUNuRCxVQUFJdlAsUUFBUSxLQUFLLEtBQUs3TixLQUFsQixJQUEyQmlGLEdBQS9CLEVBQW9DO0FBQ2xDO0FBQ0F1RyxRQUFBQSxLQUFLLElBQUksS0FBS3hMLEtBQUwsR0FBYTZOLFFBQXRCO0FBQ0FwZixRQUFBQSxTQUFTLElBQUksS0FBS3VSLEtBQUwsR0FBYTZOLFFBQTFCO0FBQ0Q7O0FBRUR4a0MsTUFBQUEsSUFBSSxHQUFHbWlDLEtBQVA7QUFDQStSLE1BQUFBLFNBQVMsR0FBRyxLQUFLdGQsTUFBakI7QUFDQXVNLE1BQUFBLFNBQVMsR0FBRyxLQUFLbkgsR0FBakI7QUFDQWdZLE1BQUFBLFVBQVUsR0FBRyxDQUFDN1EsU0FBZDs7QUFFQSxVQUFJNFEsYUFBSixFQUFtQjtBQUNqQm5ZLFFBQUFBLEdBQUcsS0FBSzRJLFFBQVEsR0FBRyxLQUFLekIsTUFBckIsQ0FBSCxDQURpQixDQUNnQjs7QUFFakMsU0FBQzNkLFNBQVMsSUFBSSxDQUFDeHRCLGNBQWYsTUFBbUMsS0FBS21yQyxNQUFMLEdBQWMzZCxTQUFqRDtBQUNEOztBQUVELFVBQUksS0FBSzRjLE9BQVQsRUFBa0I7QUFDaEI7QUFDQStQLFFBQUFBLElBQUksR0FBRyxLQUFLOU4sS0FBWjtBQUNBN0IsUUFBQUEsYUFBYSxHQUFHeEcsR0FBRyxHQUFHLEtBQUtzRyxPQUEzQjs7QUFFQSxZQUFJLEtBQUtGLE9BQUwsR0FBZSxDQUFDLENBQWhCLElBQXFCNWMsU0FBUyxHQUFHLENBQXJDLEVBQXdDO0FBQ3RDLGlCQUFPLEtBQUtBLFNBQUwsQ0FBZWdkLGFBQWEsR0FBRyxHQUFoQixHQUFzQmhkLFNBQXJDLEVBQWdEeHRCLGNBQWhELEVBQWdFOUgsS0FBaEUsQ0FBUDtBQUNEOztBQUVEa1EsUUFBQUEsSUFBSSxHQUFHeUUsYUFBYSxDQUFDMDlCLEtBQUssR0FBR0MsYUFBVCxDQUFwQixDQVRnQixDQVM2Qjs7QUFFN0MsWUFBSUQsS0FBSyxLQUFLMlIsSUFBZCxFQUFvQjtBQUNsQjtBQUNBL1AsVUFBQUEsU0FBUyxHQUFHLEtBQUsvQixPQUFqQjtBQUNBaGlDLFVBQUFBLElBQUksR0FBRzQ3QixHQUFQO0FBQ0QsU0FKRCxNQUlPO0FBQ0xtSSxVQUFBQSxTQUFTLEdBQUcsQ0FBQyxFQUFFNUIsS0FBSyxHQUFHQyxhQUFWLENBQWI7O0FBRUEsY0FBSTJCLFNBQVMsSUFBSUEsU0FBUyxLQUFLNUIsS0FBSyxHQUFHQyxhQUF2QyxFQUFzRDtBQUNwRHBpQyxZQUFBQSxJQUFJLEdBQUc0N0IsR0FBUDtBQUNBbUksWUFBQUEsU0FBUztBQUNWOztBQUVEL2pDLFVBQUFBLElBQUksR0FBRzQ3QixHQUFQLEtBQWU1N0IsSUFBSSxHQUFHNDdCLEdBQXRCO0FBQ0Q7O0FBRURvSSxRQUFBQSxhQUFhLEdBQUcvQixlQUFlLENBQUMsS0FBS25MLE1BQU4sRUFBY3NMLGFBQWQsQ0FBL0I7QUFDQSxTQUFDb0MsUUFBRCxJQUFhLEtBQUsxTixNQUFsQixJQUE0QmtOLGFBQWEsS0FBS0QsU0FBOUMsS0FBNERDLGFBQWEsR0FBR0QsU0FBNUUsRUEzQmdCLENBMkJ3RTs7QUFFeEYsWUFBSWdPLElBQUksSUFBSWhPLFNBQVMsR0FBRyxDQUF4QixFQUEyQjtBQUN6Qi9qQyxVQUFBQSxJQUFJLEdBQUc0N0IsR0FBRyxHQUFHNTdCLElBQWI7QUFDQW13QyxVQUFBQSxNQUFNLEdBQUcsQ0FBVDtBQUNEO0FBQ0Q7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR1EsWUFBSXBNLFNBQVMsS0FBS0MsYUFBZCxJQUErQixDQUFDLEtBQUtMLEtBQXpDLEVBQWdEO0FBQzlDLGNBQUl3USxTQUFTLEdBQUdwQyxJQUFJLElBQUkvTixhQUFhLEdBQUcsQ0FBeEM7QUFBQSxjQUNJb1EsUUFBUSxHQUFHRCxTQUFTLE1BQU1wQyxJQUFJLElBQUloTyxTQUFTLEdBQUcsQ0FBMUIsQ0FEeEI7QUFFQUEsVUFBQUEsU0FBUyxHQUFHQyxhQUFaLEtBQThCbVEsU0FBUyxHQUFHLENBQUNBLFNBQTNDO0FBQ0EzUCxVQUFBQSxRQUFRLEdBQUcyUCxTQUFTLEdBQUcsQ0FBSCxHQUFPdlksR0FBM0I7QUFDQSxlQUFLK0gsS0FBTCxHQUFhLENBQWI7QUFDQSxlQUFLaHNDLE1BQUwsQ0FBWTZzQyxRQUFRLEtBQUsyTCxNQUFNLEdBQUcsQ0FBSCxHQUFPMXJDLGFBQWEsQ0FBQ3MvQixTQUFTLEdBQUczQixhQUFiLENBQS9CLENBQXBCLEVBQWlGeHFDLGNBQWpGLEVBQWlHLENBQUNna0MsR0FBbEcsRUFBdUcrSCxLQUF2RyxHQUErRyxDQUEvRztBQUNBLGVBQUs3TSxNQUFMLEdBQWNxTCxLQUFkLENBUDhDLENBT3pCOztBQUVyQixXQUFDdnFDLGNBQUQsSUFBbUIsS0FBS3pGLE1BQXhCLElBQWtDZ3pCLFNBQVMsQ0FBQyxJQUFELEVBQU8sVUFBUCxDQUEzQztBQUNBLGVBQUs3NkIsSUFBTCxDQUFVNDVDLGFBQVYsSUFBMkIsQ0FBQ2lNLE1BQTVCLEtBQXVDLEtBQUt0YixVQUFMLEdBQWtCOE8sS0FBbEIsR0FBMEIsQ0FBakU7O0FBRUEsY0FBSWEsUUFBUSxJQUFJQSxRQUFRLEtBQUssS0FBSzdOLEtBQTlCLElBQXVDcWQsVUFBVSxLQUFLLENBQUMsS0FBS2hZLEdBQTVELElBQW1FLEtBQUsxeEMsSUFBTCxDQUFVK3BELFFBQVYsSUFBc0IsQ0FBQyxLQUFLbGlELE1BQTVCLElBQXNDLENBQUMsS0FBS3F2QyxJQUFuSCxFQUF5SDtBQUN2SDtBQUNBLG1CQUFPLElBQVA7QUFDRDs7QUFFRDVGLFVBQUFBLEdBQUcsR0FBRyxLQUFLK0YsSUFBWCxDQWpCOEMsQ0FpQjdCOztBQUVqQm1TLFVBQUFBLElBQUksR0FBRyxLQUFLL2MsS0FBWjs7QUFFQSxjQUFJcWQsUUFBSixFQUFjO0FBQ1osaUJBQUt6USxLQUFMLEdBQWEsQ0FBYjtBQUNBYSxZQUFBQSxRQUFRLEdBQUcyUCxTQUFTLEdBQUd2WSxHQUFILEdBQVMsQ0FBQyxNQUE5QjtBQUNBLGlCQUFLamtDLE1BQUwsQ0FBWTZzQyxRQUFaLEVBQXNCLElBQXRCO0FBQ0EsaUJBQUtsNkMsSUFBTCxDQUFVNDVDLGFBQVYsSUFBMkIsQ0FBQ2lNLE1BQTVCLElBQXNDLEtBQUt0YixVQUFMLEVBQXRDO0FBQ0Q7O0FBRUQsZUFBSzhPLEtBQUwsR0FBYSxDQUFiOztBQUVBLGNBQUksQ0FBQyxLQUFLM0gsR0FBTixJQUFhLENBQUNnWSxVQUFsQixFQUE4QjtBQUM1QixtQkFBTyxJQUFQO0FBQ0QsV0FoQzZDLENBZ0M1Qzs7O0FBR0Y5RCxVQUFBQSxrQkFBa0IsQ0FBQyxJQUFELEVBQU9DLE1BQVAsQ0FBbEI7QUFDRDtBQUNGOztBQUVELFVBQUksS0FBS21FLFNBQUwsSUFBa0IsQ0FBQyxLQUFLQyxRQUF4QixJQUFvQyxLQUFLNVEsS0FBTCxHQUFhLENBQXJELEVBQXdEO0FBQ3REc1EsUUFBQUEsVUFBVSxHQUFHMVAsbUJBQW1CLENBQUMsSUFBRCxFQUFPOS9CLGFBQWEsQ0FBQysvQixRQUFELENBQXBCLEVBQWdDLy9CLGFBQWEsQ0FBQ3pFLElBQUQsQ0FBN0MsQ0FBaEM7O0FBRUEsWUFBSWkwQyxVQUFKLEVBQWdCO0FBQ2Q5UixVQUFBQSxLQUFLLElBQUluaUMsSUFBSSxJQUFJQSxJQUFJLEdBQUdpMEMsVUFBVSxDQUFDcmQsTUFBdEIsQ0FBYjtBQUNEO0FBQ0Y7O0FBRUQsV0FBS0UsTUFBTCxHQUFjcUwsS0FBZDtBQUNBLFdBQUt4TCxLQUFMLEdBQWEzMkIsSUFBYjtBQUNBLFdBQUt3aEMsSUFBTCxHQUFZLENBQUMyQixTQUFiLENBOUdtRCxDQThHM0I7O0FBRXhCLFVBQUksQ0FBQyxLQUFLbFEsUUFBVixFQUFvQjtBQUNsQixhQUFLb1IsU0FBTCxHQUFpQixLQUFLLzVDLElBQUwsQ0FBVXlRLFFBQTNCO0FBQ0EsYUFBS2s0QixRQUFMLEdBQWdCLENBQWhCO0FBQ0EsYUFBSzhQLE1BQUwsR0FBYzNkLFNBQWQ7QUFDQW9mLFFBQUFBLFFBQVEsR0FBRyxDQUFYLENBSmtCLENBSUo7QUFDZjs7QUFFRCxVQUFJLENBQUNBLFFBQUQsSUFBYXhrQyxJQUFiLElBQXFCLENBQUNwSSxjQUExQixFQUEwQztBQUN4Q3V0QixRQUFBQSxTQUFTLENBQUMsSUFBRCxFQUFPLFNBQVAsQ0FBVDs7QUFFQSxZQUFJLEtBQUsyUixNQUFMLEtBQWdCcUwsS0FBcEIsRUFBMkI7QUFDekI7QUFDQSxpQkFBTyxJQUFQO0FBQ0Q7QUFDRjs7QUFFRCxVQUFJbmlDLElBQUksSUFBSXdrQyxRQUFSLElBQW9CcGYsU0FBUyxJQUFJLENBQXJDLEVBQXdDO0FBQ3RDbnpCLFFBQUFBLEtBQUssR0FBRyxLQUFLd3lDLE1BQWI7O0FBRUEsZUFBT3h5QyxLQUFQLEVBQWM7QUFDWndpQyxVQUFBQSxJQUFJLEdBQUd4aUMsS0FBSyxDQUFDd21CLEtBQWI7O0FBRUEsY0FBSSxDQUFDeG1CLEtBQUssQ0FBQ3V2QyxJQUFOLElBQWN4aEMsSUFBSSxJQUFJL04sS0FBSyxDQUFDMmtDLE1BQTdCLEtBQXdDM2tDLEtBQUssQ0FBQytwQyxHQUE5QyxJQUFxRGlZLFVBQVUsS0FBS2hpRCxLQUF4RSxFQUErRTtBQUM3RSxnQkFBSUEsS0FBSyxDQUFDRSxNQUFOLEtBQWlCLElBQXJCLEVBQTJCO0FBQ3pCO0FBQ0EscUJBQU8sS0FBS3dGLE1BQUwsQ0FBWXl0QixTQUFaLEVBQXVCeHRCLGNBQXZCLEVBQXVDOUgsS0FBdkMsQ0FBUDtBQUNEOztBQUVEbUMsWUFBQUEsS0FBSyxDQUFDMEYsTUFBTixDQUFhMUYsS0FBSyxDQUFDK3BDLEdBQU4sR0FBWSxDQUFaLEdBQWdCLENBQUNoOEIsSUFBSSxHQUFHL04sS0FBSyxDQUFDMmtDLE1BQWQsSUFBd0Iza0MsS0FBSyxDQUFDK3BDLEdBQTlDLEdBQW9ELENBQUMvcEMsS0FBSyxDQUFDdVUsTUFBTixHQUFldlUsS0FBSyxDQUFDNHZDLGFBQU4sRUFBZixHQUF1QzV2QyxLQUFLLENBQUM4a0MsS0FBOUMsSUFBdUQsQ0FBQy8yQixJQUFJLEdBQUcvTixLQUFLLENBQUMya0MsTUFBZCxJQUF3QjNrQyxLQUFLLENBQUMrcEMsR0FBdEosRUFBMkpwa0MsY0FBM0osRUFBMks5SCxLQUEzSzs7QUFFQSxnQkFBSWtRLElBQUksS0FBSyxLQUFLMjJCLEtBQWQsSUFBdUIsQ0FBQyxLQUFLcUYsR0FBTixJQUFhLENBQUNnWSxVQUF6QyxFQUFxRDtBQUNuRDtBQUNBQyxjQUFBQSxVQUFVLEdBQUcsQ0FBYjtBQUNBeGYsY0FBQUEsSUFBSSxLQUFLME4sS0FBSyxJQUFJLEtBQUtZLE1BQUwsR0FBYyxDQUFDcEcsUUFBN0IsQ0FBSixDQUhtRCxDQUdQOztBQUU1QztBQUNEO0FBQ0Y7O0FBRUQxcUMsVUFBQUEsS0FBSyxHQUFHd2lDLElBQVI7QUFDRDtBQUNGLE9BekJELE1BeUJPO0FBQ0x4aUMsUUFBQUEsS0FBSyxHQUFHLEtBQUt5eUMsS0FBYjtBQUNBLFlBQUk4UCxZQUFZLEdBQUdwdkIsU0FBUyxHQUFHLENBQVosR0FBZ0JBLFNBQWhCLEdBQTRCcGxCLElBQS9DLENBRkssQ0FFZ0Q7O0FBRXJELGVBQU8vTixLQUFQLEVBQWM7QUFDWndpQyxVQUFBQSxJQUFJLEdBQUd4aUMsS0FBSyxDQUFDa3ZDLEtBQWI7O0FBRUEsY0FBSSxDQUFDbHZDLEtBQUssQ0FBQ3V2QyxJQUFOLElBQWNnVCxZQUFZLElBQUl2aUQsS0FBSyxDQUFDeXZDLElBQXJDLEtBQThDenZDLEtBQUssQ0FBQytwQyxHQUFwRCxJQUEyRGlZLFVBQVUsS0FBS2hpRCxLQUE5RSxFQUFxRjtBQUNuRixnQkFBSUEsS0FBSyxDQUFDRSxNQUFOLEtBQWlCLElBQXJCLEVBQTJCO0FBQ3pCO0FBQ0EscUJBQU8sS0FBS3dGLE1BQUwsQ0FBWXl0QixTQUFaLEVBQXVCeHRCLGNBQXZCLEVBQXVDOUgsS0FBdkMsQ0FBUDtBQUNEOztBQUVEbUMsWUFBQUEsS0FBSyxDQUFDMEYsTUFBTixDQUFhMUYsS0FBSyxDQUFDK3BDLEdBQU4sR0FBWSxDQUFaLEdBQWdCLENBQUN3WSxZQUFZLEdBQUd2aUQsS0FBSyxDQUFDMmtDLE1BQXRCLElBQWdDM2tDLEtBQUssQ0FBQytwQyxHQUF0RCxHQUE0RCxDQUFDL3BDLEtBQUssQ0FBQ3VVLE1BQU4sR0FBZXZVLEtBQUssQ0FBQzR2QyxhQUFOLEVBQWYsR0FBdUM1dkMsS0FBSyxDQUFDOGtDLEtBQTlDLElBQXVELENBQUN5ZCxZQUFZLEdBQUd2aUQsS0FBSyxDQUFDMmtDLE1BQXRCLElBQWdDM2tDLEtBQUssQ0FBQytwQyxHQUF0SyxFQUEyS3BrQyxjQUEzSyxFQUEyTDlILEtBQTNMOztBQUVBLGdCQUFJa1EsSUFBSSxLQUFLLEtBQUsyMkIsS0FBZCxJQUF1QixDQUFDLEtBQUtxRixHQUFOLElBQWEsQ0FBQ2dZLFVBQXpDLEVBQXFEO0FBQ25EO0FBQ0FDLGNBQUFBLFVBQVUsR0FBRyxDQUFiO0FBQ0F4ZixjQUFBQSxJQUFJLEtBQUswTixLQUFLLElBQUksS0FBS1ksTUFBTCxHQUFjeVIsWUFBWSxHQUFHLENBQUM3WCxRQUFKLEdBQWVBLFFBQXZELENBQUosQ0FIbUQsQ0FHbUI7O0FBRXRFO0FBQ0Q7QUFDRjs7QUFFRDFxQyxVQUFBQSxLQUFLLEdBQUd3aUMsSUFBUjtBQUNEO0FBQ0Y7O0FBRUQsVUFBSXdmLFVBQVUsSUFBSSxDQUFDcjhDLGNBQW5CLEVBQW1DO0FBQ2pDLGFBQUtrcEIsS0FBTDtBQUNBbXpCLFFBQUFBLFVBQVUsQ0FBQ3Q4QyxNQUFYLENBQWtCcUksSUFBSSxJQUFJd2tDLFFBQVIsR0FBbUIsQ0FBbkIsR0FBdUIsQ0FBQzdILFFBQTFDLEVBQW9Eb0csTUFBcEQsR0FBNkQvaUMsSUFBSSxJQUFJd2tDLFFBQVIsR0FBbUIsQ0FBbkIsR0FBdUIsQ0FBQyxDQUFyRjs7QUFFQSxZQUFJLEtBQUt4SSxHQUFULEVBQWM7QUFDWjtBQUNBLGVBQUtwRixNQUFMLEdBQWNzZCxTQUFkLENBRlksQ0FFYTs7QUFFekJ6UixVQUFBQSxPQUFPLENBQUMsSUFBRCxDQUFQOztBQUVBLGlCQUFPLEtBQUs5cUMsTUFBTCxDQUFZeXRCLFNBQVosRUFBdUJ4dEIsY0FBdkIsRUFBdUM5SCxLQUF2QyxDQUFQO0FBQ0Q7QUFDRjs7QUFFRCxXQUFLdTBDLFNBQUwsSUFBa0IsQ0FBQ3pzQyxjQUFuQixJQUFxQ3V0QixTQUFTLENBQUMsSUFBRCxFQUFPLFVBQVAsRUFBbUIsSUFBbkIsQ0FBOUM7QUFDQSxVQUFJZ2QsS0FBSyxLQUFLMlIsSUFBVixJQUFrQixLQUFLaGQsTUFBTCxJQUFlLEtBQUsrSyxhQUFMLEVBQWpDLElBQXlELENBQUNNLEtBQUQsSUFBVXFDLFFBQXZFLEVBQWlGLElBQUkwUCxTQUFTLEtBQUssS0FBS3RkLE1BQW5CLElBQTZCNzBDLElBQUksQ0FBQzJiLEdBQUwsQ0FBU3lsQyxTQUFULE1BQXdCcGhELElBQUksQ0FBQzJiLEdBQUwsQ0FBUyxLQUFLcytCLEdBQWQsQ0FBekQsRUFBNkUsSUFBSSxDQUFDLEtBQUsySCxLQUFWLEVBQWlCO0FBQzdLO0FBQ0EsU0FBQ3ZlLFNBQVMsSUFBSSxDQUFDd1csR0FBZixNQUF3QnVHLEtBQUssS0FBSzJSLElBQVYsSUFBa0IsS0FBSzlYLEdBQUwsR0FBVyxDQUE3QixJQUFrQyxDQUFDbUcsS0FBRCxJQUFVLEtBQUtuRyxHQUFMLEdBQVcsQ0FBL0UsS0FBcUZxRixpQkFBaUIsQ0FBQyxJQUFELEVBQU8sQ0FBUCxDQUF0RyxDQUY2SyxDQUU1RDs7QUFFakgsWUFBSSxDQUFDenBDLGNBQUQsSUFBbUIsRUFBRXd0QixTQUFTLEdBQUcsQ0FBWixJQUFpQixDQUFDb2YsUUFBcEIsQ0FBbkIsS0FBcURyQyxLQUFLLElBQUlxQyxRQUFULElBQXFCLENBQUNzUCxJQUEzRSxDQUFKLEVBQXNGO0FBQ3BGM3VCLFVBQUFBLFNBQVMsQ0FBQyxJQUFELEVBQU9nZCxLQUFLLEtBQUsyUixJQUFWLElBQWtCMXVCLFNBQVMsSUFBSSxDQUEvQixHQUFtQyxZQUFuQyxHQUFrRCxtQkFBekQsRUFBOEUsSUFBOUUsQ0FBVDs7QUFFQSxlQUFLa2YsS0FBTCxJQUFjLEVBQUVuQyxLQUFLLEdBQUcyUixJQUFSLElBQWdCLEtBQUszUSxTQUFMLEtBQW1CLENBQXJDLENBQWQsSUFBeUQsS0FBS21CLEtBQUwsRUFBekQ7QUFDRDtBQUNGO0FBQ0Y7O0FBRUQsV0FBTyxJQUFQO0FBQ0QsR0F0T0Q7O0FBd09BNk8sRUFBQUEsT0FBTyxDQUFDcHVELEdBQVIsR0FBYyxTQUFTQSxHQUFULENBQWFrTixLQUFiLEVBQW9CN0QsUUFBcEIsRUFBOEI7QUFDMUMsUUFBSW9GLE1BQU0sR0FBRyxJQUFiOztBQUVBMlEsSUFBQUEsU0FBUyxDQUFDL1YsUUFBRCxDQUFULEtBQXdCQSxRQUFRLEdBQUdtL0IsY0FBYyxDQUFDLElBQUQsRUFBT24vQixRQUFQLEVBQWlCNkQsS0FBakIsQ0FBakQ7O0FBRUEsUUFBSSxFQUFFQSxLQUFLLFlBQVk0L0MsU0FBbkIsQ0FBSixFQUFtQztBQUNqQyxVQUFJNXZELFFBQVEsQ0FBQ2dRLEtBQUQsQ0FBWixFQUFxQjtBQUNuQkEsUUFBQUEsS0FBSyxDQUFDdk4sT0FBTixDQUFjLFVBQVVkLEdBQVYsRUFBZTtBQUMzQixpQkFBTzRQLE1BQU0sQ0FBQ3pPLEdBQVAsQ0FBV25CLEdBQVgsRUFBZ0J3SyxRQUFoQixDQUFQO0FBQ0QsU0FGRDtBQUdBLGVBQU8sSUFBUDtBQUNEOztBQUVELFVBQUk4VixTQUFTLENBQUNqUyxLQUFELENBQWIsRUFBc0I7QUFDcEIsZUFBTyxLQUFLd2lELFFBQUwsQ0FBY3hpRCxLQUFkLEVBQXFCN0QsUUFBckIsQ0FBUDtBQUNEOztBQUVELFVBQUk3TSxXQUFXLENBQUMwUSxLQUFELENBQWYsRUFBd0I7QUFDdEJBLFFBQUFBLEtBQUssR0FBRzZ6QyxLQUFLLENBQUMzbUMsV0FBTixDQUFrQixDQUFsQixFQUFxQmxOLEtBQXJCLENBQVI7QUFDRCxPQUZELE1BRU87QUFDTCxlQUFPLElBQVA7QUFDRDtBQUNGOztBQUVELFdBQU8sU0FBU0EsS0FBVCxHQUFpQit3QyxjQUFjLENBQUMsSUFBRCxFQUFPL3dDLEtBQVAsRUFBYzdELFFBQWQsQ0FBL0IsR0FBeUQsSUFBaEUsQ0F4QjBDLENBd0I0QjtBQUN2RSxHQXpCRDs7QUEyQkEra0QsRUFBQUEsT0FBTyxDQUFDdUIsV0FBUixHQUFzQixTQUFTQSxXQUFULENBQXFCNWEsTUFBckIsRUFBNkI2YSxNQUE3QixFQUFxQ0MsU0FBckMsRUFBZ0RDLGdCQUFoRCxFQUFrRTtBQUN0RixRQUFJL2EsTUFBTSxLQUFLLEtBQUssQ0FBcEIsRUFBdUI7QUFDckJBLE1BQUFBLE1BQU0sR0FBRyxJQUFUO0FBQ0Q7O0FBRUQsUUFBSTZhLE1BQU0sS0FBSyxLQUFLLENBQXBCLEVBQXVCO0FBQ3JCQSxNQUFBQSxNQUFNLEdBQUcsSUFBVDtBQUNEOztBQUVELFFBQUlDLFNBQVMsS0FBSyxLQUFLLENBQXZCLEVBQTBCO0FBQ3hCQSxNQUFBQSxTQUFTLEdBQUcsSUFBWjtBQUNEOztBQUVELFFBQUlDLGdCQUFnQixLQUFLLEtBQUssQ0FBOUIsRUFBaUM7QUFDL0JBLE1BQUFBLGdCQUFnQixHQUFHLENBQUMveEQsT0FBcEI7QUFDRDs7QUFFRCxRQUFJb0ssQ0FBQyxHQUFHLEVBQVI7QUFBQSxRQUNJK0UsS0FBSyxHQUFHLEtBQUt3eUMsTUFEakI7O0FBR0EsV0FBT3h5QyxLQUFQLEVBQWM7QUFDWixVQUFJQSxLQUFLLENBQUMya0MsTUFBTixJQUFnQmllLGdCQUFwQixFQUFzQztBQUNwQyxZQUFJNWlELEtBQUssWUFBWTZ6QyxLQUFyQixFQUE0QjtBQUMxQjZPLFVBQUFBLE1BQU0sSUFBSXpuRCxDQUFDLENBQUNySSxJQUFGLENBQU9vTixLQUFQLENBQVY7QUFDRCxTQUZELE1BRU87QUFDTDJpRCxVQUFBQSxTQUFTLElBQUkxbkQsQ0FBQyxDQUFDckksSUFBRixDQUFPb04sS0FBUCxDQUFiO0FBQ0E2bkMsVUFBQUEsTUFBTSxJQUFJNXNDLENBQUMsQ0FBQ3JJLElBQUYsQ0FBTzZGLEtBQVAsQ0FBYXdDLENBQWIsRUFBZ0IrRSxLQUFLLENBQUN5aUQsV0FBTixDQUFrQixJQUFsQixFQUF3QkMsTUFBeEIsRUFBZ0NDLFNBQWhDLENBQWhCLENBQVY7QUFDRDtBQUNGOztBQUVEM2lELE1BQUFBLEtBQUssR0FBR0EsS0FBSyxDQUFDd21CLEtBQWQ7QUFDRDs7QUFFRCxXQUFPdnJCLENBQVA7QUFDRCxHQWxDRDs7QUFvQ0FpbUQsRUFBQUEsT0FBTyxDQUFDeHdCLE9BQVIsR0FBa0IsU0FBU0EsT0FBVCxDQUFpQjNnQixFQUFqQixFQUFxQjtBQUNyQyxRQUFJOHlDLFVBQVUsR0FBRyxLQUFLSixXQUFMLENBQWlCLENBQWpCLEVBQW9CLENBQXBCLEVBQXVCLENBQXZCLENBQWpCO0FBQUEsUUFDSXR3RCxDQUFDLEdBQUcwd0QsVUFBVSxDQUFDendELE1BRG5COztBQUdBLFdBQU9ELENBQUMsRUFBUixFQUFZO0FBQ1YsVUFBSTB3RCxVQUFVLENBQUMxd0QsQ0FBRCxDQUFWLENBQWNrRyxJQUFkLENBQW1CMFgsRUFBbkIsS0FBMEJBLEVBQTlCLEVBQWtDO0FBQ2hDLGVBQU84eUMsVUFBVSxDQUFDMXdELENBQUQsQ0FBakI7QUFDRDtBQUNGO0FBQ0YsR0FURDs7QUFXQSt1RCxFQUFBQSxPQUFPLENBQUNsdUQsTUFBUixHQUFpQixTQUFTQSxNQUFULENBQWdCZ04sS0FBaEIsRUFBdUI7QUFDdEMsUUFBSWlTLFNBQVMsQ0FBQ2pTLEtBQUQsQ0FBYixFQUFzQjtBQUNwQixhQUFPLEtBQUs4aUQsV0FBTCxDQUFpQjlpRCxLQUFqQixDQUFQO0FBQ0Q7O0FBRUQsUUFBSTFRLFdBQVcsQ0FBQzBRLEtBQUQsQ0FBZixFQUF3QjtBQUN0QixhQUFPLEtBQUsvQixZQUFMLENBQWtCK0IsS0FBbEIsQ0FBUDtBQUNEOztBQUVEbXZDLElBQUFBLHFCQUFxQixDQUFDLElBQUQsRUFBT252QyxLQUFQLENBQXJCOztBQUVBLFFBQUlBLEtBQUssS0FBSyxLQUFLb3hDLE9BQW5CLEVBQTRCO0FBQzFCLFdBQUtBLE9BQUwsR0FBZSxLQUFLcUIsS0FBcEI7QUFDRDs7QUFFRCxXQUFPakQsUUFBUSxDQUFDLElBQUQsQ0FBZjtBQUNELEdBaEJEOztBQWtCQTBSLEVBQUFBLE9BQU8sQ0FBQy90QixTQUFSLEdBQW9CLFNBQVNBLFNBQVQsQ0FBbUI0dkIsV0FBbkIsRUFBZ0NwOUMsY0FBaEMsRUFBZ0Q7QUFDbEUsUUFBSSxDQUFDN0gsU0FBUyxDQUFDMUwsTUFBZixFQUF1QjtBQUNyQixhQUFPLEtBQUt5eUMsTUFBWjtBQUNEOztBQUVELFNBQUt5ZCxRQUFMLEdBQWdCLENBQWhCOztBQUVBLFFBQUksQ0FBQyxLQUFLN2QsR0FBTixJQUFhLEtBQUtzRixHQUF0QixFQUEyQjtBQUN6QjtBQUNBLFdBQUtwRixNQUFMLEdBQWNueUIsYUFBYSxDQUFDZy9CLE9BQU8sQ0FBQ3pqQyxJQUFSLElBQWdCLEtBQUtnOEIsR0FBTCxHQUFXLENBQVgsR0FBZWdaLFdBQVcsR0FBRyxLQUFLaFosR0FBbEMsR0FBd0MsQ0FBQyxLQUFLNkYsYUFBTCxLQUF1Qm1ULFdBQXhCLElBQXVDLENBQUMsS0FBS2haLEdBQXJHLENBQUQsQ0FBM0I7QUFDRDs7QUFFRGlYLElBQUFBLFVBQVUsQ0FBQ3h6RCxTQUFYLENBQXFCMmxDLFNBQXJCLENBQStCLzNCLElBQS9CLENBQW9DLElBQXBDLEVBQTBDMm5ELFdBQTFDLEVBQXVEcDlDLGNBQXZEOztBQUVBLFNBQUsyOEMsUUFBTCxHQUFnQixDQUFoQjtBQUNBLFdBQU8sSUFBUDtBQUNELEdBaEJEOztBQWtCQXBCLEVBQUFBLE9BQU8sQ0FBQ3NCLFFBQVIsR0FBbUIsU0FBU0EsUUFBVCxDQUFrQjFlLEtBQWxCLEVBQXlCM25DLFFBQXpCLEVBQW1DO0FBQ3BELFNBQUs4NEIsTUFBTCxDQUFZNk8sS0FBWixJQUFxQnhJLGNBQWMsQ0FBQyxJQUFELEVBQU9uL0IsUUFBUCxDQUFuQztBQUNBLFdBQU8sSUFBUDtBQUNELEdBSEQ7O0FBS0Era0QsRUFBQUEsT0FBTyxDQUFDNEIsV0FBUixHQUFzQixTQUFTQSxXQUFULENBQXFCaGYsS0FBckIsRUFBNEI7QUFDaEQsV0FBTyxLQUFLN08sTUFBTCxDQUFZNk8sS0FBWixDQUFQO0FBQ0EsV0FBTyxJQUFQO0FBQ0QsR0FIRDs7QUFLQW9kLEVBQUFBLE9BQU8sQ0FBQzhCLFFBQVIsR0FBbUIsU0FBU0EsUUFBVCxDQUFrQjdtRCxRQUFsQixFQUE0QjNHLFFBQTVCLEVBQXNDKzlDLE1BQXRDLEVBQThDO0FBQy9ELFFBQUkzZ0MsQ0FBQyxHQUFHaWhDLEtBQUssQ0FBQzNtQyxXQUFOLENBQWtCLENBQWxCLEVBQXFCMVgsUUFBUSxJQUFJOUYsVUFBakMsRUFBNkM2akQsTUFBN0MsQ0FBUjtBQUNBM2dDLElBQUFBLENBQUMsQ0FBQ3BmLElBQUYsR0FBUyxTQUFUO0FBQ0EsU0FBSzZ1RCxTQUFMLEdBQWlCLENBQWpCO0FBQ0EsV0FBT3RSLGNBQWMsQ0FBQyxJQUFELEVBQU9uK0IsQ0FBUCxFQUFVMG9CLGNBQWMsQ0FBQyxJQUFELEVBQU9uL0IsUUFBUCxDQUF4QixDQUFyQjtBQUNELEdBTEQ7O0FBT0Era0QsRUFBQUEsT0FBTyxDQUFDK0IsV0FBUixHQUFzQixTQUFTQSxXQUFULENBQXFCOW1ELFFBQXJCLEVBQStCO0FBQ25ELFFBQUk2RCxLQUFLLEdBQUcsS0FBS3d5QyxNQUFqQjtBQUNBcjJDLElBQUFBLFFBQVEsR0FBR20vQixjQUFjLENBQUMsSUFBRCxFQUFPbi9CLFFBQVAsQ0FBekI7O0FBRUEsV0FBTzZELEtBQVAsRUFBYztBQUNaLFVBQUlBLEtBQUssQ0FBQzJrQyxNQUFOLEtBQWlCeG9DLFFBQWpCLElBQTZCNkQsS0FBSyxDQUFDeE0sSUFBTixLQUFlLFNBQWhELEVBQTJEO0FBQ3pENDdDLFFBQUFBLGlCQUFpQixDQUFDcHZDLEtBQUQsQ0FBakI7QUFDRDs7QUFFREEsTUFBQUEsS0FBSyxHQUFHQSxLQUFLLENBQUN3bUIsS0FBZDtBQUNEO0FBQ0YsR0FYRDs7QUFhQTA2QixFQUFBQSxPQUFPLENBQUNqakQsWUFBUixHQUF1QixTQUFTQSxZQUFULENBQXNCd1MsT0FBdEIsRUFBK0IrRSxLQUEvQixFQUFzQzB0QyxVQUF0QyxFQUFrRDtBQUN2RSxRQUFJUixNQUFNLEdBQUcsS0FBS1MsV0FBTCxDQUFpQjF5QyxPQUFqQixFQUEwQnl5QyxVQUExQixDQUFiO0FBQUEsUUFDSS93RCxDQUFDLEdBQUd1d0QsTUFBTSxDQUFDdHdELE1BRGY7O0FBR0EsV0FBT0QsQ0FBQyxFQUFSLEVBQVk7QUFDVml4RCxNQUFBQSxpQkFBaUIsS0FBS1YsTUFBTSxDQUFDdndELENBQUQsQ0FBNUIsSUFBbUN1d0QsTUFBTSxDQUFDdndELENBQUQsQ0FBTixDQUFVOFksSUFBVixDQUFld0YsT0FBZixFQUF3QitFLEtBQXhCLENBQW5DO0FBQ0Q7O0FBRUQsV0FBTyxJQUFQO0FBQ0QsR0FURDs7QUFXQTByQyxFQUFBQSxPQUFPLENBQUNpQyxXQUFSLEdBQXNCLFNBQVNBLFdBQVQsQ0FBcUIxeUMsT0FBckIsRUFBOEJ5eUMsVUFBOUIsRUFBMEM7QUFDOUQsUUFBSWpvRCxDQUFDLEdBQUcsRUFBUjtBQUFBLFFBQ0lvb0QsYUFBYSxHQUFHN21ELE9BQU8sQ0FBQ2lVLE9BQUQsQ0FEM0I7QUFBQSxRQUVJelEsS0FBSyxHQUFHLEtBQUt3eUMsTUFGakI7QUFBQSxRQUdJOFEsWUFBWSxHQUFHcHhDLFNBQVMsQ0FBQ2d4QyxVQUFELENBSDVCO0FBQUEsUUFJSTtBQUNKN3dELElBQUFBLFFBTEE7O0FBT0EsV0FBTzJOLEtBQVAsRUFBYztBQUNaLFVBQUlBLEtBQUssWUFBWTZ6QyxLQUFyQixFQUE0QjtBQUMxQixZQUFJckcsaUJBQWlCLENBQUN4dEMsS0FBSyxDQUFDdWpELFFBQVAsRUFBaUJGLGFBQWpCLENBQWpCLEtBQXFEQyxZQUFZLEdBQUcsQ0FBQyxDQUFDRixpQkFBRCxJQUFzQnBqRCxLQUFLLENBQUNnaEMsUUFBTixJQUFrQmhoQyxLQUFLLENBQUMrcEMsR0FBL0MsS0FBdUQvcEMsS0FBSyxDQUFDc2dELFVBQU4sQ0FBaUIsQ0FBakIsS0FBdUI0QyxVQUE5RSxJQUE0RmxqRCxLQUFLLENBQUNzZ0QsVUFBTixDQUFpQnRnRCxLQUFLLENBQUM0dkMsYUFBTixFQUFqQixJQUEwQ3NULFVBQXpJLEdBQXNKLENBQUNBLFVBQUQsSUFBZWxqRCxLQUFLLENBQUNxSyxRQUFOLEVBQXRPLENBQUosRUFBNlA7QUFDM1A7QUFDQXBQLFVBQUFBLENBQUMsQ0FBQ3JJLElBQUYsQ0FBT29OLEtBQVA7QUFDRDtBQUNGLE9BTEQsTUFLTyxJQUFJLENBQUMzTixRQUFRLEdBQUcyTixLQUFLLENBQUNtakQsV0FBTixDQUFrQkUsYUFBbEIsRUFBaUNILFVBQWpDLENBQVosRUFBMEQ5d0QsTUFBOUQsRUFBc0U7QUFDM0U2SSxRQUFBQSxDQUFDLENBQUNySSxJQUFGLENBQU82RixLQUFQLENBQWF3QyxDQUFiLEVBQWdCNUksUUFBaEI7QUFDRDs7QUFFRDJOLE1BQUFBLEtBQUssR0FBR0EsS0FBSyxDQUFDd21CLEtBQWQ7QUFDRDs7QUFFRCxXQUFPdnJCLENBQVA7QUFDRCxHQXRCRCxDQXNCRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUEzQkE7O0FBOEJBaW1ELEVBQUFBLE9BQU8sQ0FBQ3ppQixPQUFSLEdBQWtCLFNBQVNBLE9BQVQsQ0FBaUJ0aUMsUUFBakIsRUFBMkI5RCxJQUEzQixFQUFpQztBQUNqREEsSUFBQUEsSUFBSSxHQUFHQSxJQUFJLElBQUksRUFBZjs7QUFFQSxRQUFJNG5CLEVBQUUsR0FBRyxJQUFUO0FBQUEsUUFDSWd6QixPQUFPLEdBQUczWCxjQUFjLENBQUNyYixFQUFELEVBQUs5akIsUUFBTCxDQUQ1QjtBQUFBLFFBRUkycEIsS0FBSyxHQUFHenRCLElBRlo7QUFBQSxRQUdJdTdDLE9BQU8sR0FBRzl0QixLQUFLLENBQUM4dEIsT0FIcEI7QUFBQSxRQUlJNFAsUUFBUSxHQUFHMTlCLEtBQUssQ0FBQzZiLE9BSnJCO0FBQUEsUUFLSThoQixhQUFhLEdBQUczOUIsS0FBSyxDQUFDMjlCLGFBTDFCO0FBQUEsUUFNSXhpQixlQUFlLEdBQUduYixLQUFLLENBQUNtYixlQU41QjtBQUFBLFFBT0l1QyxPQVBKO0FBQUEsUUFRSW43QixLQUFLLEdBQUd3ckMsS0FBSyxDQUFDMWdELEVBQU4sQ0FBUzhzQixFQUFULEVBQWF4c0IsWUFBWSxDQUFDO0FBQ3BDb3RDLE1BQUFBLElBQUksRUFBRXhvQyxJQUFJLENBQUN3b0MsSUFBTCxJQUFhLE1BRGlCO0FBRXBDN2tDLE1BQUFBLElBQUksRUFBRSxLQUY4QjtBQUdwQ2lsQyxNQUFBQSxlQUFlLEVBQUUsS0FIbUI7QUFJcENsekIsTUFBQUEsSUFBSSxFQUFFa2xDLE9BSjhCO0FBS3BDNy9DLE1BQUFBLFNBQVMsRUFBRSxNQUx5QjtBQU1wQ0UsTUFBQUEsUUFBUSxFQUFFK0UsSUFBSSxDQUFDL0UsUUFBTCxJQUFpQnhELElBQUksQ0FBQzJiLEdBQUwsQ0FBUyxDQUFDd25DLE9BQU8sSUFBSVcsT0FBTyxJQUFJLFVBQVVBLE9BQXJCLEdBQStCQSxPQUFPLENBQUM3bEMsSUFBdkMsR0FBOENrUyxFQUFFLENBQUN5a0IsS0FBckQsQ0FBUixJQUF1RXprQixFQUFFLENBQUNpeEIsU0FBSCxFQUFoRixDQUFqQixJQUFvSHhHLFFBTjFGO0FBT3BDL0ksTUFBQUEsT0FBTyxFQUFFLFNBQVNBLE9BQVQsR0FBbUI7QUFDMUIxaEIsUUFBQUEsRUFBRSxDQUFDNE8sS0FBSDs7QUFFQSxZQUFJLENBQUMyVSxPQUFMLEVBQWM7QUFDWixjQUFJbHdDLFFBQVEsR0FBRytFLElBQUksQ0FBQy9FLFFBQUwsSUFBaUJ4RCxJQUFJLENBQUMyYixHQUFMLENBQVMsQ0FBQ3duQyxPQUFPLElBQUlXLE9BQU8sSUFBSSxVQUFVQSxPQUFyQixHQUErQkEsT0FBTyxDQUFDN2xDLElBQXZDLEdBQThDa1MsRUFBRSxDQUFDeWtCLEtBQXJELENBQVIsSUFBdUV6a0IsRUFBRSxDQUFDaXhCLFNBQUgsRUFBaEYsQ0FBaEM7QUFDQTdvQyxVQUFBQSxLQUFLLENBQUNxbkMsSUFBTixLQUFlcDhDLFFBQWYsSUFBMkJvL0MsWUFBWSxDQUFDcnFDLEtBQUQsRUFBUS9VLFFBQVIsRUFBa0IsQ0FBbEIsRUFBcUIsQ0FBckIsQ0FBWixDQUFvQ29TLE1BQXBDLENBQTJDMkMsS0FBSyxDQUFDcThCLEtBQWpELEVBQXdELElBQXhELEVBQThELElBQTlELENBQTNCO0FBQ0FsQixVQUFBQSxPQUFPLEdBQUcsQ0FBVjtBQUNEOztBQUVEZ2dCLFFBQUFBLFFBQVEsSUFBSUEsUUFBUSxDQUFDL3FELEtBQVQsQ0FBZTRQLEtBQWYsRUFBc0JvN0MsYUFBYSxJQUFJLEVBQXZDLENBQVosQ0FUMEIsQ0FTOEI7QUFDekQ7QUFqQm1DLEtBQUQsRUFrQmxDcHJELElBbEJrQyxDQUF6QixDQVJaOztBQTRCQSxXQUFPNG9DLGVBQWUsR0FBRzU0QixLQUFLLENBQUMzQyxNQUFOLENBQWEsQ0FBYixDQUFILEdBQXFCMkMsS0FBM0M7QUFDRCxHQWhDRDs7QUFrQ0E2NEMsRUFBQUEsT0FBTyxDQUFDd0MsV0FBUixHQUFzQixTQUFTQSxXQUFULENBQXFCQyxZQUFyQixFQUFtQ0MsVUFBbkMsRUFBK0N2ckQsSUFBL0MsRUFBcUQ7QUFDekUsV0FBTyxLQUFLb21DLE9BQUwsQ0FBYW1sQixVQUFiLEVBQXlCbndELFlBQVksQ0FBQztBQUMzQ21nRCxNQUFBQSxPQUFPLEVBQUU7QUFDUDdsQyxRQUFBQSxJQUFJLEVBQUV1dEIsY0FBYyxDQUFDLElBQUQsRUFBT3FvQixZQUFQO0FBRGI7QUFEa0MsS0FBRCxFQUl6Q3RyRCxJQUp5QyxDQUFyQyxDQUFQO0FBS0QsR0FORDs7QUFRQTZvRCxFQUFBQSxPQUFPLENBQUMvTixNQUFSLEdBQWlCLFNBQVNBLE1BQVQsR0FBa0I7QUFDakMsV0FBTyxLQUFLL0IsT0FBWjtBQUNELEdBRkQ7O0FBSUE4UCxFQUFBQSxPQUFPLENBQUMyQyxTQUFSLEdBQW9CLFNBQVNBLFNBQVQsQ0FBbUJDLFNBQW5CLEVBQThCO0FBQ2hELFFBQUlBLFNBQVMsS0FBSyxLQUFLLENBQXZCLEVBQTBCO0FBQ3hCQSxNQUFBQSxTQUFTLEdBQUcsS0FBS3BmLEtBQWpCO0FBQ0Q7O0FBRUQsV0FBT3FULG9CQUFvQixDQUFDLElBQUQsRUFBT3pjLGNBQWMsQ0FBQyxJQUFELEVBQU93b0IsU0FBUCxDQUFyQixDQUEzQjtBQUNELEdBTkQ7O0FBUUE1QyxFQUFBQSxPQUFPLENBQUM2QyxhQUFSLEdBQXdCLFNBQVNBLGFBQVQsQ0FBdUJDLFVBQXZCLEVBQW1DO0FBQ3pELFFBQUlBLFVBQVUsS0FBSyxLQUFLLENBQXhCLEVBQTJCO0FBQ3pCQSxNQUFBQSxVQUFVLEdBQUcsS0FBS3RmLEtBQWxCO0FBQ0Q7O0FBRUQsV0FBT3FULG9CQUFvQixDQUFDLElBQUQsRUFBT3pjLGNBQWMsQ0FBQyxJQUFELEVBQU8wb0IsVUFBUCxDQUFyQixFQUF5QyxDQUF6QyxDQUEzQjtBQUNELEdBTkQ7O0FBUUE5QyxFQUFBQSxPQUFPLENBQUMrQyxZQUFSLEdBQXVCLFNBQVNBLFlBQVQsQ0FBc0IxMEQsS0FBdEIsRUFBNkI7QUFDbEQsV0FBT3VPLFNBQVMsQ0FBQzFMLE1BQVYsR0FBbUIsS0FBS3dwQyxJQUFMLENBQVVyc0MsS0FBVixFQUFpQixJQUFqQixDQUFuQixHQUE0QyxLQUFLdzBELGFBQUwsQ0FBbUIsS0FBS3JmLEtBQUwsR0FBYWdHLFFBQWhDLENBQW5EO0FBQ0QsR0FGRDs7QUFJQXdXLEVBQUFBLE9BQU8sQ0FBQ2dELGFBQVIsR0FBd0IsU0FBU0EsYUFBVCxDQUF1QnhPLE1BQXZCLEVBQStCeU8sWUFBL0IsRUFBNkN2QixnQkFBN0MsRUFBK0Q7QUFDckYsUUFBSUEsZ0JBQWdCLEtBQUssS0FBSyxDQUE5QixFQUFpQztBQUMvQkEsTUFBQUEsZ0JBQWdCLEdBQUcsQ0FBbkI7QUFDRDs7QUFFRCxRQUFJNWlELEtBQUssR0FBRyxLQUFLd3lDLE1BQWpCO0FBQUEsUUFDSXZkLE1BQU0sR0FBRyxLQUFLQSxNQURsQjtBQUFBLFFBRUluakMsQ0FGSjs7QUFJQSxXQUFPa08sS0FBUCxFQUFjO0FBQ1osVUFBSUEsS0FBSyxDQUFDMmtDLE1BQU4sSUFBZ0JpZSxnQkFBcEIsRUFBc0M7QUFDcEM1aUQsUUFBQUEsS0FBSyxDQUFDMmtDLE1BQU4sSUFBZ0IrUSxNQUFoQjtBQUNBMTFDLFFBQUFBLEtBQUssQ0FBQ3l2QyxJQUFOLElBQWNpRyxNQUFkO0FBQ0Q7O0FBRUQxMUMsTUFBQUEsS0FBSyxHQUFHQSxLQUFLLENBQUN3bUIsS0FBZDtBQUNEOztBQUVELFFBQUkyOUIsWUFBSixFQUFrQjtBQUNoQixXQUFLcnlELENBQUwsSUFBVW1qQyxNQUFWLEVBQWtCO0FBQ2hCLFlBQUlBLE1BQU0sQ0FBQ25qQyxDQUFELENBQU4sSUFBYTh3RCxnQkFBakIsRUFBbUM7QUFDakMzdEIsVUFBQUEsTUFBTSxDQUFDbmpDLENBQUQsQ0FBTixJQUFhNGpELE1BQWI7QUFDRDtBQUNGO0FBQ0Y7O0FBRUQsV0FBT2xHLFFBQVEsQ0FBQyxJQUFELENBQWY7QUFDRCxHQTNCRDs7QUE2QkEwUixFQUFBQSxPQUFPLENBQUN0ZSxVQUFSLEdBQXFCLFNBQVNBLFVBQVQsR0FBc0I7QUFDekMsUUFBSTVpQyxLQUFLLEdBQUcsS0FBS3d5QyxNQUFqQjtBQUNBLFNBQUtkLEtBQUwsR0FBYSxDQUFiOztBQUVBLFdBQU8xeEMsS0FBUCxFQUFjO0FBQ1pBLE1BQUFBLEtBQUssQ0FBQzRpQyxVQUFOO0FBQ0E1aUMsTUFBQUEsS0FBSyxHQUFHQSxLQUFLLENBQUN3bUIsS0FBZDtBQUNEOztBQUVELFdBQU93NkIsVUFBVSxDQUFDeHpELFNBQVgsQ0FBcUJvMUMsVUFBckIsQ0FBZ0N4bkMsSUFBaEMsQ0FBcUMsSUFBckMsQ0FBUDtBQUNELEdBVkQ7O0FBWUE4bEQsRUFBQUEsT0FBTyxDQUFDa0QsS0FBUixHQUFnQixTQUFTQSxLQUFULENBQWVDLGFBQWYsRUFBOEI7QUFDNUMsUUFBSUEsYUFBYSxLQUFLLEtBQUssQ0FBM0IsRUFBOEI7QUFDNUJBLE1BQUFBLGFBQWEsR0FBRyxJQUFoQjtBQUNEOztBQUVELFFBQUlya0QsS0FBSyxHQUFHLEtBQUt3eUMsTUFBakI7QUFBQSxRQUNJaFEsSUFESjs7QUFHQSxXQUFPeGlDLEtBQVAsRUFBYztBQUNad2lDLE1BQUFBLElBQUksR0FBR3hpQyxLQUFLLENBQUN3bUIsS0FBYjtBQUNBLFdBQUt4ekIsTUFBTCxDQUFZZ04sS0FBWjtBQUNBQSxNQUFBQSxLQUFLLEdBQUd3aUMsSUFBUjtBQUNEOztBQUVELFNBQUtpQyxHQUFMLEtBQWEsS0FBS0MsS0FBTCxHQUFhLEtBQUtHLE1BQUwsR0FBYyxLQUFLcWIsTUFBTCxHQUFjLENBQXREO0FBQ0FtRSxJQUFBQSxhQUFhLEtBQUssS0FBS3B2QixNQUFMLEdBQWMsRUFBbkIsQ0FBYjtBQUNBLFdBQU91YSxRQUFRLENBQUMsSUFBRCxDQUFmO0FBQ0QsR0FqQkQ7O0FBbUJBMFIsRUFBQUEsT0FBTyxDQUFDdFIsYUFBUixHQUF3QixTQUFTQSxhQUFULENBQXVCcmdELEtBQXZCLEVBQThCO0FBQ3BELFFBQUkyRyxHQUFHLEdBQUcsQ0FBVjtBQUFBLFFBQ0kvSSxJQUFJLEdBQUcsSUFEWDtBQUFBLFFBRUk2UyxLQUFLLEdBQUc3UyxJQUFJLENBQUNzbEQsS0FGakI7QUFBQSxRQUdJd1AsU0FBUyxHQUFHcHhELE9BSGhCO0FBQUEsUUFJSW8rQyxJQUpKO0FBQUEsUUFLSXpsQyxLQUxKO0FBQUEsUUFNSXRKLE1BTko7O0FBUUEsUUFBSXBDLFNBQVMsQ0FBQzFMLE1BQWQsRUFBc0I7QUFDcEIsYUFBT2pGLElBQUksQ0FBQytqRCxTQUFMLENBQWUsQ0FBQy9qRCxJQUFJLENBQUM0aUQsT0FBTCxHQUFlLENBQWYsR0FBbUI1aUQsSUFBSSxDQUFDbUcsUUFBTCxFQUFuQixHQUFxQ25HLElBQUksQ0FBQ3lpRCxhQUFMLEVBQXRDLEtBQStEemlELElBQUksQ0FBQ21tQixRQUFMLEtBQWtCLENBQUMvakIsS0FBbkIsR0FBMkJBLEtBQTFGLENBQWYsQ0FBUDtBQUNEOztBQUVELFFBQUlwQyxJQUFJLENBQUNvbkIsTUFBVCxFQUFpQjtBQUNmclUsTUFBQUEsTUFBTSxHQUFHL1MsSUFBSSxDQUFDK1MsTUFBZDs7QUFFQSxhQUFPRixLQUFQLEVBQWM7QUFDWml2QyxRQUFBQSxJQUFJLEdBQUdqdkMsS0FBSyxDQUFDa3ZDLEtBQWIsQ0FEWSxDQUNROztBQUVwQmx2QyxRQUFBQSxLQUFLLENBQUN1VSxNQUFOLElBQWdCdlUsS0FBSyxDQUFDNHZDLGFBQU4sRUFBaEIsQ0FIWSxDQUcyQjs7QUFFdkNwbUMsUUFBQUEsS0FBSyxHQUFHeEosS0FBSyxDQUFDMmtDLE1BQWQ7O0FBRUEsWUFBSW43QixLQUFLLEdBQUd5NEMsU0FBUixJQUFxQjkwRCxJQUFJLENBQUNpa0MsS0FBMUIsSUFBbUNweEIsS0FBSyxDQUFDK3BDLEdBQXpDLElBQWdELENBQUM1OEMsSUFBSSxDQUFDdWtELEtBQTFELEVBQWlFO0FBQy9EO0FBQ0F2a0QsVUFBQUEsSUFBSSxDQUFDdWtELEtBQUwsR0FBYSxDQUFiLENBRitELENBRS9DOztBQUVoQlgsVUFBQUEsY0FBYyxDQUFDNWpELElBQUQsRUFBTzZTLEtBQVAsRUFBY3dKLEtBQUssR0FBR3hKLEtBQUssQ0FBQ2l4QyxNQUE1QixFQUFvQyxDQUFwQyxDQUFkLENBQXFEUyxLQUFyRCxHQUE2RCxDQUE3RDtBQUNELFNBTEQsTUFLTztBQUNMdVEsVUFBQUEsU0FBUyxHQUFHejRDLEtBQVo7QUFDRDs7QUFFRCxZQUFJQSxLQUFLLEdBQUcsQ0FBUixJQUFheEosS0FBSyxDQUFDK3BDLEdBQXZCLEVBQTRCO0FBQzFCO0FBQ0E3ekMsVUFBQUEsR0FBRyxJQUFJc1QsS0FBUDs7QUFFQSxjQUFJLENBQUN0SixNQUFELElBQVcsQ0FBQy9TLElBQUksQ0FBQ3MzQyxHQUFqQixJQUF3QnZrQyxNQUFNLElBQUlBLE1BQU0sQ0FBQ3l3QyxpQkFBN0MsRUFBZ0U7QUFDOUR4akQsWUFBQUEsSUFBSSxDQUFDdzNDLE1BQUwsSUFBZW43QixLQUFLLEdBQUdyYyxJQUFJLENBQUM0OEMsR0FBNUI7QUFDQTU4QyxZQUFBQSxJQUFJLENBQUN1M0MsS0FBTCxJQUFjbDdCLEtBQWQ7QUFDQXJjLFlBQUFBLElBQUksQ0FBQzAzQyxNQUFMLElBQWVyN0IsS0FBZjtBQUNEOztBQUVEcmMsVUFBQUEsSUFBSSxDQUFDKzJELGFBQUwsQ0FBbUIsQ0FBQzE2QyxLQUFwQixFQUEyQixLQUEzQixFQUFrQyxDQUFDLEtBQW5DO0FBQ0F5NEMsVUFBQUEsU0FBUyxHQUFHLENBQVo7QUFDRDs7QUFFRGppRCxRQUFBQSxLQUFLLENBQUN5dkMsSUFBTixHQUFhdjVDLEdBQWIsSUFBb0I4SixLQUFLLENBQUMrcEMsR0FBMUIsS0FBa0M3ekMsR0FBRyxHQUFHOEosS0FBSyxDQUFDeXZDLElBQTlDO0FBQ0F6dkMsUUFBQUEsS0FBSyxHQUFHaXZDLElBQVI7QUFDRDs7QUFFRHlELE1BQUFBLFlBQVksQ0FBQ3ZsRCxJQUFELEVBQU9BLElBQUksS0FBS3MrQyxlQUFULElBQTRCdCtDLElBQUksQ0FBQ3UzQyxLQUFMLEdBQWF4dUMsR0FBekMsR0FBK0MvSSxJQUFJLENBQUN1M0MsS0FBcEQsR0FBNER4dUMsR0FBbkUsRUFBd0UsQ0FBeEUsRUFBMkUsQ0FBM0UsQ0FBWjs7QUFFQS9JLE1BQUFBLElBQUksQ0FBQ29uQixNQUFMLEdBQWMsQ0FBZDtBQUNEOztBQUVELFdBQU9wbkIsSUFBSSxDQUFDMjNDLEtBQVo7QUFDRCxHQXhERDs7QUEwREFpTyxFQUFBQSxRQUFRLENBQUN1UixVQUFULEdBQXNCLFNBQVNBLFVBQVQsQ0FBb0J2MkMsSUFBcEIsRUFBMEI7QUFDOUMsUUFBSTA5QixlQUFlLENBQUMxQixHQUFwQixFQUF5QjtBQUN2QjhELE1BQUFBLGVBQWUsQ0FBQ3BDLGVBQUQsRUFBa0I2RSx1QkFBdUIsQ0FBQ3ZpQyxJQUFELEVBQU8wOUIsZUFBUCxDQUF6QyxDQUFmOztBQUVBZSxNQUFBQSxrQkFBa0IsR0FBR2dGLE9BQU8sQ0FBQzFZLEtBQTdCO0FBQ0Q7O0FBRUQsUUFBSTBZLE9BQU8sQ0FBQzFZLEtBQVIsSUFBaUI2VCxZQUFyQixFQUFtQztBQUNqQ0EsTUFBQUEsWUFBWSxJQUFJcEMsT0FBTyxDQUFDQyxTQUFSLElBQXFCLEdBQXJDO0FBQ0EsVUFBSXhxQyxLQUFLLEdBQUd5ckMsZUFBZSxDQUFDK0csTUFBNUI7QUFDQSxVQUFJLENBQUN4eUMsS0FBRCxJQUFVLENBQUNBLEtBQUssQ0FBQytwQyxHQUFyQixFQUEwQixJQUFJUSxPQUFPLENBQUNDLFNBQVIsSUFBcUJnSCxPQUFPLENBQUNqNUMsVUFBUixDQUFtQm5HLE1BQW5CLEdBQTRCLENBQXJELEVBQXdEO0FBQ2hGLGVBQU80TixLQUFLLElBQUksQ0FBQ0EsS0FBSyxDQUFDK3BDLEdBQXZCLEVBQTRCO0FBQzFCL3BDLFVBQUFBLEtBQUssR0FBR0EsS0FBSyxDQUFDd21CLEtBQWQ7QUFDRDs7QUFFRHhtQixRQUFBQSxLQUFLLElBQUl3eEMsT0FBTyxDQUFDc0wsS0FBUixFQUFUO0FBQ0Q7QUFDRjtBQUNGLEdBbEJEOztBQW9CQSxTQUFPL0osUUFBUDtBQUNELENBeHJCa0MsQ0F3ckJqQzZNLFNBeHJCaUMsQ0FBNUI7O0FBMHJCUG5zRCxZQUFZLENBQUNzL0MsUUFBUSxDQUFDdmxELFNBQVYsRUFBcUI7QUFDL0Jra0QsRUFBQUEsS0FBSyxFQUFFLENBRHdCO0FBRS9CMlEsRUFBQUEsU0FBUyxFQUFFLENBRm9CO0FBRy9CQyxFQUFBQSxRQUFRLEVBQUU7QUFIcUIsQ0FBckIsQ0FBWjs7QUFNQSxJQUFJaUMsMEJBQTBCLEdBQUcsU0FBU0EsMEJBQVQsQ0FBb0MzdkQsTUFBcEMsRUFBNEMrdEIsSUFBNUMsRUFBa0RuWixLQUFsRCxFQUF5RHJPLEdBQXpELEVBQThEcXBELE1BQTlELEVBQXNFQyxZQUF0RSxFQUFvRkMsU0FBcEYsRUFBK0Y7QUFDOUg7QUFDQSxNQUFJeC9CLEVBQUUsR0FBRyxJQUFJN0MsU0FBSixDQUFjLEtBQUs4QyxHQUFuQixFQUF3QnZ3QixNQUF4QixFQUFnQyt0QixJQUFoQyxFQUFzQyxDQUF0QyxFQUF5QyxDQUF6QyxFQUE0Q2dpQyxvQkFBNUMsRUFBa0UsSUFBbEUsRUFBd0VILE1BQXhFLENBQVQ7QUFBQSxNQUNJeHdDLEtBQUssR0FBRyxDQURaO0FBQUEsTUFFSTR3QyxVQUFVLEdBQUcsQ0FGakI7QUFBQSxNQUdJcHNELE1BSEo7QUFBQSxNQUlJcXNELFNBSko7QUFBQSxNQUtJMXRCLEtBTEo7QUFBQSxNQU1JMnRCLE1BTko7QUFBQSxNQU9JQyxLQVBKO0FBQUEsTUFRSUMsUUFSSjtBQUFBLE1BU0lDLFNBVEo7QUFBQSxNQVVJaHFELENBVko7QUFXQWlxQixFQUFBQSxFQUFFLENBQUN0WSxDQUFILEdBQU9wRCxLQUFQO0FBQ0EwYixFQUFBQSxFQUFFLENBQUM1MEIsQ0FBSCxHQUFPNkssR0FBUDtBQUNBcU8sRUFBQUEsS0FBSyxJQUFJLEVBQVQsQ0FmOEgsQ0Flakg7O0FBRWJyTyxFQUFBQSxHQUFHLElBQUksRUFBUDs7QUFFQSxNQUFJOHBELFNBQVMsR0FBRyxDQUFDOXBELEdBQUcsQ0FBQ3lFLE9BQUosQ0FBWSxTQUFaLENBQWpCLEVBQXlDO0FBQ3ZDekUsSUFBQUEsR0FBRyxHQUFHNDdDLGNBQWMsQ0FBQzU3QyxHQUFELENBQXBCO0FBQ0Q7O0FBRUQsTUFBSXNwRCxZQUFKLEVBQWtCO0FBQ2hCeHBELElBQUFBLENBQUMsR0FBRyxDQUFDdU8sS0FBRCxFQUFRck8sR0FBUixDQUFKO0FBQ0FzcEQsSUFBQUEsWUFBWSxDQUFDeHBELENBQUQsRUFBSXJHLE1BQUosRUFBWSt0QixJQUFaLENBQVosQ0FGZ0IsQ0FFZTs7QUFFL0JuWixJQUFBQSxLQUFLLEdBQUd2TyxDQUFDLENBQUMsQ0FBRCxDQUFUO0FBQ0FFLElBQUFBLEdBQUcsR0FBR0YsQ0FBQyxDQUFDLENBQUQsQ0FBUDtBQUNEOztBQUVENHBELEVBQUFBLFNBQVMsR0FBR3I3QyxLQUFLLENBQUMwTixLQUFOLENBQVltMEIsb0JBQVosS0FBcUMsRUFBakQ7O0FBRUEsU0FBTzd5QyxNQUFNLEdBQUc2eUMsb0JBQW9CLENBQUMwSSxJQUFyQixDQUEwQjU0QyxHQUExQixDQUFoQixFQUFnRDtBQUM5QzJwRCxJQUFBQSxNQUFNLEdBQUd0c0QsTUFBTSxDQUFDLENBQUQsQ0FBZjtBQUNBdXNELElBQUFBLEtBQUssR0FBRzVwRCxHQUFHLENBQUMyaUQsU0FBSixDQUFjOXBDLEtBQWQsRUFBcUJ4YixNQUFNLENBQUN3YixLQUE1QixDQUFSOztBQUVBLFFBQUltakIsS0FBSixFQUFXO0FBQ1RBLE1BQUFBLEtBQUssR0FBRyxDQUFDQSxLQUFLLEdBQUcsQ0FBVCxJQUFjLENBQXRCO0FBQ0QsS0FGRCxNQUVPLElBQUk0dEIsS0FBSyxDQUFDeG1DLE1BQU4sQ0FBYSxDQUFDLENBQWQsTUFBcUIsT0FBekIsRUFBa0M7QUFDdkM0WSxNQUFBQSxLQUFLLEdBQUcsQ0FBUjtBQUNEOztBQUVELFFBQUkydEIsTUFBTSxLQUFLRCxTQUFTLENBQUNELFVBQVUsRUFBWCxDQUF4QixFQUF3QztBQUN0Q0ksTUFBQUEsUUFBUSxHQUFHenFELFVBQVUsQ0FBQ3NxRCxTQUFTLENBQUNELFVBQVUsR0FBRyxDQUFkLENBQVYsQ0FBVixJQUF5QyxDQUFwRCxDQURzQyxDQUNpQjs7QUFFdkQxL0IsTUFBQUEsRUFBRSxDQUFDQyxHQUFILEdBQVM7QUFDUHFCLFFBQUFBLEtBQUssRUFBRXRCLEVBQUUsQ0FBQ0MsR0FESDtBQUVQcnpCLFFBQUFBLENBQUMsRUFBRWl6RCxLQUFLLElBQUlILFVBQVUsS0FBSyxDQUF4QixHQUE0QkcsS0FBNUIsR0FBb0MsR0FGaEM7QUFHUDtBQUNBanRDLFFBQUFBLENBQUMsRUFBRWt0QyxRQUpJO0FBS1ByNEMsUUFBQUEsQ0FBQyxFQUFFbTRDLE1BQU0sQ0FBQ3RtQyxNQUFQLENBQWMsQ0FBZCxNQUFxQixHQUFyQixHQUEyQjh1QixjQUFjLENBQUMwWCxRQUFELEVBQVdGLE1BQVgsQ0FBZCxHQUFtQ0UsUUFBOUQsR0FBeUV6cUQsVUFBVSxDQUFDdXFELE1BQUQsQ0FBVixHQUFxQkUsUUFMMUY7QUFNUHAxQyxRQUFBQSxDQUFDLEVBQUV1bkIsS0FBSyxJQUFJQSxLQUFLLEdBQUcsQ0FBakIsR0FBcUJybkMsSUFBSSxDQUFDQyxLQUExQixHQUFrQztBQU45QixPQUFUO0FBUUFpa0IsTUFBQUEsS0FBSyxHQUFHcTNCLG9CQUFvQixDQUFDbVEsU0FBN0I7QUFDRDtBQUNGOztBQUVEdDJCLEVBQUFBLEVBQUUsQ0FBQ3ZZLENBQUgsR0FBT3FILEtBQUssR0FBRzdZLEdBQUcsQ0FBQy9JLE1BQVosR0FBcUIrSSxHQUFHLENBQUMyaUQsU0FBSixDQUFjOXBDLEtBQWQsRUFBcUI3WSxHQUFHLENBQUMvSSxNQUF6QixDQUFyQixHQUF3RCxFQUEvRCxDQTFEOEgsQ0EwRDNEOztBQUVuRTh5QixFQUFBQSxFQUFFLENBQUNnZ0MsRUFBSCxHQUFRUixTQUFSOztBQUVBLE1BQUlwWixPQUFPLENBQUM3dkMsSUFBUixDQUFhTixHQUFiLEtBQXFCOHBELFNBQXpCLEVBQW9DO0FBQ2xDLy9CLElBQUFBLEVBQUUsQ0FBQzUwQixDQUFILEdBQU8sQ0FBUCxDQURrQyxDQUN4QjtBQUNYOztBQUVELE9BQUs2MEIsR0FBTCxHQUFXRCxFQUFYLENBbEU4SCxDQWtFL0c7O0FBRWYsU0FBT0EsRUFBUDtBQUNELENBckVEO0FBQUEsSUFzRUkyeUIsYUFBYSxHQUFHLFNBQVNBLGFBQVQsQ0FBdUJqakQsTUFBdkIsRUFBK0IrdEIsSUFBL0IsRUFBcUNuWixLQUFyQyxFQUE0Q3JPLEdBQTVDLEVBQWlENlksS0FBakQsRUFBd0R2RCxPQUF4RCxFQUFpRWlvQyxRQUFqRSxFQUEyRStMLFlBQTNFLEVBQXlGQyxTQUF6RixFQUFvRztBQUN0SHAxRCxFQUFBQSxXQUFXLENBQUM2TCxHQUFELENBQVgsS0FBcUJBLEdBQUcsR0FBR0EsR0FBRyxDQUFDNlksS0FBSyxJQUFJLENBQVYsRUFBYXBmLE1BQWIsRUFBcUI2YixPQUFyQixDQUE5QjtBQUNBLE1BQUkwMEMsWUFBWSxHQUFHdndELE1BQU0sQ0FBQyt0QixJQUFELENBQXpCO0FBQUEsTUFDSXNnQixXQUFXLEdBQUd6NUIsS0FBSyxLQUFLLEtBQVYsR0FBa0JBLEtBQWxCLEdBQTBCLENBQUNsYSxXQUFXLENBQUM2MUQsWUFBRCxDQUFaLEdBQTZCQSxZQUE3QixHQUE0Q1QsU0FBUyxHQUFHOXZELE1BQU0sQ0FBQyt0QixJQUFJLENBQUMvaUIsT0FBTCxDQUFhLEtBQWIsS0FBdUIsQ0FBQ3RRLFdBQVcsQ0FBQ3NGLE1BQU0sQ0FBQyxRQUFRK3RCLElBQUksQ0FBQ3BFLE1BQUwsQ0FBWSxDQUFaLENBQVQsQ0FBUCxDQUFuQyxHQUFzRW9FLElBQXRFLEdBQTZFLFFBQVFBLElBQUksQ0FBQ3BFLE1BQUwsQ0FBWSxDQUFaLENBQXRGLENBQU4sQ0FBNEdtbUMsU0FBNUcsQ0FBSCxHQUE0SDl2RCxNQUFNLENBQUMrdEIsSUFBRCxDQUFOLEVBRDdOO0FBQUEsTUFFSTZoQyxNQUFNLEdBQUcsQ0FBQ2wxRCxXQUFXLENBQUM2MUQsWUFBRCxDQUFaLEdBQTZCQyxZQUE3QixHQUE0Q1YsU0FBUyxHQUFHVyxvQkFBSCxHQUEwQkMsV0FGNUY7QUFBQSxNQUdJcGdDLEVBSEo7O0FBS0EsTUFBSWpULFNBQVMsQ0FBQzlXLEdBQUQsQ0FBYixFQUFvQjtBQUNsQixRQUFJLENBQUNBLEdBQUcsQ0FBQ3lFLE9BQUosQ0FBWSxTQUFaLENBQUwsRUFBNkI7QUFDM0J6RSxNQUFBQSxHQUFHLEdBQUc0N0MsY0FBYyxDQUFDNTdDLEdBQUQsQ0FBcEI7QUFDRDs7QUFFRCxRQUFJQSxHQUFHLENBQUNxakIsTUFBSixDQUFXLENBQVgsTUFBa0IsR0FBdEIsRUFBMkI7QUFDekIwRyxNQUFBQSxFQUFFLEdBQUdvb0IsY0FBYyxDQUFDckssV0FBRCxFQUFjOW5DLEdBQWQsQ0FBZCxJQUFvQ3dxQixPQUFPLENBQUNzZCxXQUFELENBQVAsSUFBd0IsQ0FBNUQsQ0FBTDs7QUFFQSxVQUFJL2QsRUFBRSxJQUFJQSxFQUFFLEtBQUssQ0FBakIsRUFBb0I7QUFDbEI7QUFDQS9wQixRQUFBQSxHQUFHLEdBQUcrcEIsRUFBTjtBQUNEO0FBQ0Y7QUFDRjs7QUFFRCxNQUFJK2QsV0FBVyxLQUFLOW5DLEdBQWhCLElBQXVCb3FELG1CQUEzQixFQUFnRDtBQUM5QyxRQUFJLENBQUM1akQsS0FBSyxDQUFDc2hDLFdBQVcsR0FBRzluQyxHQUFmLENBQU4sSUFBNkJBLEdBQUcsS0FBSyxFQUF6QyxFQUE2QztBQUMzQztBQUNBK3BCLE1BQUFBLEVBQUUsR0FBRyxJQUFJN0MsU0FBSixDQUFjLEtBQUs4QyxHQUFuQixFQUF3QnZ3QixNQUF4QixFQUFnQyt0QixJQUFoQyxFQUFzQyxDQUFDc2dCLFdBQUQsSUFBZ0IsQ0FBdEQsRUFBeUQ5bkMsR0FBRyxJQUFJOG5DLFdBQVcsSUFBSSxDQUFuQixDQUE1RCxFQUFtRixPQUFPa2lCLFlBQVAsS0FBd0IsU0FBeEIsR0FBb0NLLGNBQXBDLEdBQXFEQyxZQUF4SSxFQUFzSixDQUF0SixFQUF5SmpCLE1BQXpKLENBQUw7QUFDQUUsTUFBQUEsU0FBUyxLQUFLeC9CLEVBQUUsQ0FBQ2dnQyxFQUFILEdBQVFSLFNBQWIsQ0FBVDtBQUNBaE0sTUFBQUEsUUFBUSxJQUFJeHpCLEVBQUUsQ0FBQ3d6QixRQUFILENBQVlBLFFBQVosRUFBc0IsSUFBdEIsRUFBNEI5akQsTUFBNUIsQ0FBWjtBQUNBLGFBQU8sS0FBS3V3QixHQUFMLEdBQVdELEVBQWxCO0FBQ0Q7O0FBRUQsS0FBQ2lnQyxZQUFELElBQWlCLEVBQUV4aUMsSUFBSSxJQUFJL3RCLE1BQVYsQ0FBakIsSUFBc0NvM0MsY0FBYyxDQUFDcnBCLElBQUQsRUFBT3huQixHQUFQLENBQXBEO0FBQ0EsV0FBT29wRCwwQkFBMEIsQ0FBQ25wRCxJQUEzQixDQUFnQyxJQUFoQyxFQUFzQ3hHLE1BQXRDLEVBQThDK3RCLElBQTlDLEVBQW9Ec2dCLFdBQXBELEVBQWlFOW5DLEdBQWpFLEVBQXNFcXBELE1BQXRFLEVBQThFQyxZQUFZLElBQUlsYSxPQUFPLENBQUNrYSxZQUF0RyxFQUFvSEMsU0FBcEgsQ0FBUDtBQUNEO0FBQ0YsQ0F4R0Q7QUFBQSxJQXlHSTtBQUNKZ0IsWUFBWSxHQUFHLFNBQVNBLFlBQVQsQ0FBc0JydEQsSUFBdEIsRUFBNEIyYixLQUE1QixFQUFtQ3BmLE1BQW5DLEVBQTJDNmIsT0FBM0MsRUFBb0RwSSxLQUFwRCxFQUEyRDtBQUN4RS9ZLEVBQUFBLFdBQVcsQ0FBQytJLElBQUQsQ0FBWCxLQUFzQkEsSUFBSSxHQUFHc3RELGtCQUFrQixDQUFDdHRELElBQUQsRUFBT2dRLEtBQVAsRUFBYzJMLEtBQWQsRUFBcUJwZixNQUFyQixFQUE2QjZiLE9BQTdCLENBQS9DOztBQUVBLE1BQUksQ0FBQ2poQixTQUFTLENBQUM2SSxJQUFELENBQVYsSUFBb0JBLElBQUksQ0FBQzNILEtBQUwsSUFBYzJILElBQUksQ0FBQ3pDLFFBQXZDLElBQW1ENUYsUUFBUSxDQUFDcUksSUFBRCxDQUEzRCxJQUFxRTJ5QyxhQUFhLENBQUMzeUMsSUFBRCxDQUF0RixFQUE4RjtBQUM1RixXQUFPNFosU0FBUyxDQUFDNVosSUFBRCxDQUFULEdBQWtCc3RELGtCQUFrQixDQUFDdHRELElBQUQsRUFBT2dRLEtBQVAsRUFBYzJMLEtBQWQsRUFBcUJwZixNQUFyQixFQUE2QjZiLE9BQTdCLENBQXBDLEdBQTRFcFksSUFBbkY7QUFDRDs7QUFFRCxNQUFJeEcsSUFBSSxHQUFHLEVBQVg7QUFBQSxNQUNJQyxDQURKOztBQUdBLE9BQUtBLENBQUwsSUFBVXVHLElBQVYsRUFBZ0I7QUFDZHhHLElBQUFBLElBQUksQ0FBQ0MsQ0FBRCxDQUFKLEdBQVU2ekQsa0JBQWtCLENBQUN0dEQsSUFBSSxDQUFDdkcsQ0FBRCxDQUFMLEVBQVV1VyxLQUFWLEVBQWlCMkwsS0FBakIsRUFBd0JwZixNQUF4QixFQUFnQzZiLE9BQWhDLENBQTVCO0FBQ0Q7O0FBRUQsU0FBTzVlLElBQVA7QUFDRCxDQXpIRDtBQUFBLElBMEhJK3pELFlBQVksR0FBRyxTQUFTQSxZQUFULENBQXNCaHZELFFBQXRCLEVBQWdDeUIsSUFBaEMsRUFBc0NnUSxLQUF0QyxFQUE2QzJMLEtBQTdDLEVBQW9EcGYsTUFBcEQsRUFBNEQ2YixPQUE1RCxFQUFxRTtBQUN0RixNQUFJcVMsTUFBSixFQUFZb0MsRUFBWixFQUFnQjJnQyxRQUFoQixFQUEwQjF6RCxDQUExQjs7QUFFQSxNQUFJczZDLFFBQVEsQ0FBQzcxQyxRQUFELENBQVIsSUFBc0IsQ0FBQ2tzQixNQUFNLEdBQUcsSUFBSTJwQixRQUFRLENBQUM3MUMsUUFBRCxDQUFaLEVBQVYsRUFBb0NndkIsSUFBcEMsQ0FBeUNoeEIsTUFBekMsRUFBaURrdUIsTUFBTSxDQUFDODFCLE9BQVAsR0FBaUJ2Z0QsSUFBSSxDQUFDekIsUUFBRCxDQUFyQixHQUFrQzh1RCxZQUFZLENBQUNydEQsSUFBSSxDQUFDekIsUUFBRCxDQUFMLEVBQWlCb2QsS0FBakIsRUFBd0JwZixNQUF4QixFQUFnQzZiLE9BQWhDLEVBQXlDcEksS0FBekMsQ0FBL0YsRUFBZ0pBLEtBQWhKLEVBQXVKMkwsS0FBdkosRUFBOEp2RCxPQUE5SixNQUEySyxLQUFyTSxFQUE0TTtBQUMxTXBJLElBQUFBLEtBQUssQ0FBQzhjLEdBQU4sR0FBWUQsRUFBRSxHQUFHLElBQUk3QyxTQUFKLENBQWNoYSxLQUFLLENBQUM4YyxHQUFwQixFQUF5QnZ3QixNQUF6QixFQUFpQ2dDLFFBQWpDLEVBQTJDLENBQTNDLEVBQThDLENBQTlDLEVBQWlEa3NCLE1BQU0sQ0FBQ3BkLE1BQXhELEVBQWdFb2QsTUFBaEUsRUFBd0UsQ0FBeEUsRUFBMkVBLE1BQU0sQ0FBQ2dqQyxRQUFsRixDQUFqQjs7QUFFQSxRQUFJejlDLEtBQUssS0FBS2d3QyxXQUFkLEVBQTJCO0FBQ3pCd04sTUFBQUEsUUFBUSxHQUFHeDlDLEtBQUssQ0FBQzQzQyxTQUFOLENBQWdCNTNDLEtBQUssQ0FBQ2s3QyxRQUFOLENBQWUzakQsT0FBZixDQUF1QmhMLE1BQXZCLENBQWhCLENBQVgsQ0FEeUIsQ0FDbUM7O0FBRTVEekMsTUFBQUEsQ0FBQyxHQUFHMndCLE1BQU0sQ0FBQ3dDLE1BQVAsQ0FBY2x6QixNQUFsQjs7QUFFQSxhQUFPRCxDQUFDLEVBQVIsRUFBWTtBQUNWMHpELFFBQUFBLFFBQVEsQ0FBQy9pQyxNQUFNLENBQUN3QyxNQUFQLENBQWNuekIsQ0FBZCxDQUFELENBQVIsR0FBNkIreUIsRUFBN0I7QUFDRDtBQUNGO0FBQ0Y7O0FBRUQsU0FBT3BDLE1BQVA7QUFDRCxDQTVJRDtBQUFBLElBNklJc2dDLGlCQTdJSjtBQUFBLElBOElJO0FBQ0ptQyxtQkEvSUE7QUFBQSxJQWdKSWhVLFVBQVUsR0FBRyxTQUFTQSxVQUFULENBQW9CbHBDLEtBQXBCLEVBQTJCMEYsSUFBM0IsRUFBaUM7QUFDaEQsTUFBSTFWLElBQUksR0FBR2dRLEtBQUssQ0FBQ2hRLElBQWpCO0FBQUEsTUFDSXdvQyxJQUFJLEdBQUd4b0MsSUFBSSxDQUFDd29DLElBRGhCO0FBQUEsTUFFSStTLE9BQU8sR0FBR3Y3QyxJQUFJLENBQUN1N0MsT0FGbkI7QUFBQSxNQUdJM1MsZUFBZSxHQUFHNW9DLElBQUksQ0FBQzRvQyxlQUgzQjtBQUFBLE1BSUlqbEMsSUFBSSxHQUFHM0QsSUFBSSxDQUFDMkQsSUFKaEI7QUFBQSxNQUtJOE0sUUFBUSxHQUFHelEsSUFBSSxDQUFDeVEsUUFMcEI7QUFBQSxNQU1JRSxjQUFjLEdBQUczUSxJQUFJLENBQUMyUSxjQU4xQjtBQUFBLE1BT0l0USxhQUFhLEdBQUdMLElBQUksQ0FBQ0ssYUFQekI7QUFBQSxNQVFJaTdDLFlBQVksR0FBR3Q3QyxJQUFJLENBQUNzN0MsWUFSeEI7QUFBQSxNQVNJd0ssUUFBUSxHQUFHOWxELElBQUksQ0FBQzhsRCxRQVRwQjtBQUFBLE1BVUkzUCxTQUFTLEdBQUduMkMsSUFBSSxDQUFDbTJDLFNBVnJCO0FBQUEsTUFXSXVYLFVBQVUsR0FBRzF0RCxJQUFJLENBQUMwdEQsVUFYdEI7QUFBQSxNQVlJcGMsR0FBRyxHQUFHdGhDLEtBQUssQ0FBQ3FuQyxJQVpoQjtBQUFBLE1BYUlzVyxXQUFXLEdBQUczOUMsS0FBSyxDQUFDOHBDLFFBYnhCO0FBQUEsTUFjSTFoQyxPQUFPLEdBQUdwSSxLQUFLLENBQUNrN0MsUUFkcEI7QUFBQSxNQWVJcmpELE1BQU0sR0FBR21JLEtBQUssQ0FBQ25JLE1BZm5CO0FBQUEsTUFnQkkrbEQsV0FBVyxHQUFHL2xELE1BQU0sSUFBSUEsTUFBTSxDQUFDMU0sSUFBUCxLQUFnQixRQUExQixHQUFxQzBNLE1BQU0sQ0FBQ0EsTUFBUCxDQUFjcWpELFFBQW5ELEdBQThEOXlDLE9BaEJoRjtBQUFBLE1BaUJJeTFDLGFBQWEsR0FBRzc5QyxLQUFLLENBQUM4OUMsVUFBTixLQUFxQixNQUFyQixJQUErQixDQUFDOTBCLG1CQWpCcEQ7QUFBQSxNQWtCSXBSLEVBQUUsR0FBRzVYLEtBQUssQ0FBQzJzQixRQWxCZjtBQUFBLE1BbUJJb3hCLFNBbkJKO0FBQUEsTUFvQklqMEQsQ0FwQko7QUFBQSxNQXFCSUwsQ0FyQko7QUFBQSxNQXNCSW96QixFQXRCSjtBQUFBLE1BdUJJdHdCLE1BdkJKO0FBQUEsTUF3Qkl5eEQsV0F4Qko7QUFBQSxNQXlCSUMsTUF6Qko7QUFBQSxNQTBCSXZoQyxPQTFCSjtBQUFBLE1BMkJJakMsTUEzQko7QUFBQSxNQTRCSStpQyxRQTVCSjtBQUFBLE1BNkJJN3hDLEtBN0JKO0FBQUEsTUE4Qkl1eUMsV0E5Qko7QUFBQSxNQStCSUMsV0EvQko7QUFnQ0F2bUMsRUFBQUEsRUFBRSxLQUFLLENBQUN1dUIsU0FBRCxJQUFjLENBQUMzTixJQUFwQixDQUFGLEtBQWdDQSxJQUFJLEdBQUcsTUFBdkM7QUFDQXg0QixFQUFBQSxLQUFLLENBQUMrMUMsS0FBTixHQUFjckosVUFBVSxDQUFDbFUsSUFBRCxFQUFPMUssU0FBUyxDQUFDMEssSUFBakIsQ0FBeEI7QUFDQXg0QixFQUFBQSxLQUFLLENBQUNnMkMsTUFBTixHQUFlRixRQUFRLEdBQUd4SSxXQUFXLENBQUNaLFVBQVUsQ0FBQ29KLFFBQVEsS0FBSyxJQUFiLEdBQW9CdGQsSUFBcEIsR0FBMkJzZCxRQUE1QixFQUFzQ2hvQixTQUFTLENBQUMwSyxJQUFoRCxDQUFYLENBQWQsR0FBa0YsQ0FBekc7O0FBRUEsTUFBSXNkLFFBQVEsSUFBSTkxQyxLQUFLLENBQUMycEMsS0FBbEIsSUFBMkIsQ0FBQzNwQyxLQUFLLENBQUMwbkMsT0FBdEMsRUFBK0M7QUFDN0M7QUFDQW9PLElBQUFBLFFBQVEsR0FBRzkxQyxLQUFLLENBQUNnMkMsTUFBakI7QUFDQWgyQyxJQUFBQSxLQUFLLENBQUNnMkMsTUFBTixHQUFlaDJDLEtBQUssQ0FBQysxQyxLQUFyQjtBQUNBLzFDLElBQUFBLEtBQUssQ0FBQysxQyxLQUFOLEdBQWNELFFBQWQ7QUFDRDs7QUFFRDkxQyxFQUFBQSxLQUFLLENBQUM2cEMsS0FBTixHQUFjLENBQUNqeUIsRUFBRCxJQUFPLENBQUMsQ0FBQzVuQixJQUFJLENBQUNzN0MsWUFBNUIsQ0E1Q2dELENBNENOOztBQUUxQyxNQUFJLENBQUMxekIsRUFBRCxJQUFPdXVCLFNBQVMsSUFBSSxDQUFDbjJDLElBQUksQ0FBQ2twRCxPQUE5QixFQUF1QztBQUNyQztBQUNBeDhCLElBQUFBLE9BQU8sR0FBR3RVLE9BQU8sQ0FBQyxDQUFELENBQVAsR0FBYXk4QixTQUFTLENBQUN6OEIsT0FBTyxDQUFDLENBQUQsQ0FBUixDQUFULENBQXNCc1UsT0FBbkMsR0FBNkMsQ0FBdkQ7QUFDQXdoQyxJQUFBQSxXQUFXLEdBQUd4aEMsT0FBTyxJQUFJMXNCLElBQUksQ0FBQzBzQixPQUFPLENBQUNwQyxJQUFULENBQTdCLENBSHFDLENBR1E7O0FBRTdDeWpDLElBQUFBLFNBQVMsR0FBRy9YLGNBQWMsQ0FBQ2gyQyxJQUFELEVBQU9nMEMsY0FBUCxDQUExQjs7QUFFQSxRQUFJMlosV0FBSixFQUFpQjtBQUNmNVcsTUFBQUEsaUJBQWlCLENBQUM0VyxXQUFXLENBQUN0Z0QsTUFBWixDQUFtQixDQUFDLENBQXBCLEVBQXVCLElBQXZCLENBQUQsQ0FBakI7O0FBRUFzZ0QsTUFBQUEsV0FBVyxDQUFDcFksS0FBWixHQUFvQixDQUFwQjtBQUNEOztBQUVELFFBQUlnRyxPQUFKLEVBQWE7QUFDWHhFLE1BQUFBLGlCQUFpQixDQUFDL21DLEtBQUssQ0FBQzhwQyxRQUFOLEdBQWlCMEIsS0FBSyxDQUFDOTNDLEdBQU4sQ0FBVTBVLE9BQVYsRUFBbUJoZCxZQUFZLENBQUM7QUFDakVELFFBQUFBLElBQUksRUFBRSxTQUQyRDtBQUVqRUosUUFBQUEsU0FBUyxFQUFFLEtBRnNEO0FBR2pFOE0sUUFBQUEsTUFBTSxFQUFFQSxNQUh5RDtBQUlqRStnQyxRQUFBQSxlQUFlLEVBQUUsSUFKZ0Q7QUFLakVqbEMsUUFBQUEsSUFBSSxFQUFFOHVDLFdBQVcsQ0FBQzl1QyxJQUFELENBTGdEO0FBTWpFNDNDLFFBQUFBLE9BQU8sRUFBRSxJQU53RDtBQU9qRXZnRCxRQUFBQSxLQUFLLEVBQUUsQ0FQMEQ7QUFRakV5VixRQUFBQSxRQUFRLEVBQUVBLFFBUnVEO0FBU2pFRSxRQUFBQSxjQUFjLEVBQUVBLGNBVGlEO0FBVWpFdFEsUUFBQUEsYUFBYSxFQUFFQSxhQVZrRDtBQVdqRTZvRCxRQUFBQSxPQUFPLEVBQUU7QUFYd0QsT0FBRCxFQVkvRDNOLE9BWitELENBQS9CLENBQWxCLENBQWpCLENBRFcsQ0FhSTs7O0FBR2Y3bEMsTUFBQUEsSUFBSSxHQUFHLENBQVAsSUFBWSxDQUFDa3pCLGVBQWIsSUFBZ0MsQ0FBQzhrQixVQUFqQyxJQUErQzE5QyxLQUFLLENBQUM4cEMsUUFBTixDQUFlenNDLE1BQWYsQ0FBc0IsQ0FBQyxDQUF2QixFQUEwQixJQUExQixDQUEvQyxDQWhCVyxDQWdCcUU7O0FBRWhGLFVBQUl1N0IsZUFBSixFQUFxQjtBQUNuQmx6QixRQUFBQSxJQUFJLEdBQUcsQ0FBUCxJQUFZLENBQUNnNEMsVUFBYixLQUE0QjE5QyxLQUFLLENBQUM4cEMsUUFBTixHQUFpQixDQUE3QyxFQURtQixDQUM4Qjs7QUFFakQsWUFBSXhJLEdBQUcsSUFBSTU3QixJQUFJLElBQUksQ0FBbkIsRUFBc0I7QUFDcEJBLFVBQUFBLElBQUksS0FBSzFGLEtBQUssQ0FBQ3lvQyxNQUFOLEdBQWUvaUMsSUFBcEIsQ0FBSjtBQUNBLGlCQUZvQixDQUVaO0FBQ1QsU0FOa0IsQ0FNakI7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVELE9BYkQsTUFhTyxJQUFJZzRDLFVBQVUsS0FBSyxLQUFuQixFQUEwQjtBQUMvQjE5QyxRQUFBQSxLQUFLLENBQUM4cEMsUUFBTixHQUFpQixDQUFqQjtBQUNEO0FBQ0YsS0FsQ0QsTUFrQ08sSUFBSXdCLFlBQVksSUFBSWhLLEdBQXBCLEVBQXlCO0FBQzlCO0FBQ0EsVUFBSXFjLFdBQUosRUFBaUI7QUFDZixTQUFDRCxVQUFELEtBQWdCMTlDLEtBQUssQ0FBQzhwQyxRQUFOLEdBQWlCLENBQWpDO0FBQ0QsT0FGRCxNQUVPO0FBQ0xwa0MsUUFBQUEsSUFBSSxLQUFLa3pCLGVBQWUsR0FBRyxLQUF2QixDQUFKLENBREssQ0FDOEI7O0FBRW5DbnZDLFFBQUFBLENBQUMsR0FBRzJCLFlBQVksQ0FBQztBQUNmTCxVQUFBQSxTQUFTLEVBQUUsS0FESTtBQUVmSSxVQUFBQSxJQUFJLEVBQUUsYUFGUztBQUdmO0FBQ0F3SSxVQUFBQSxJQUFJLEVBQUVpbEMsZUFBZSxJQUFJNkosV0FBVyxDQUFDOXVDLElBQUQsQ0FKckI7QUFLZmlsQyxVQUFBQSxlQUFlLEVBQUVBLGVBTEY7QUFNZjtBQUNBc2dCLFVBQUFBLE9BQU8sRUFBRSxDQVBNO0FBUWZyaEQsVUFBQUEsTUFBTSxFQUFFQSxNQVJPLENBUUE7O0FBUkEsU0FBRCxFQVVia21ELFNBVmEsQ0FBaEI7QUFXQUcsUUFBQUEsV0FBVyxLQUFLejBELENBQUMsQ0FBQ2l6QixPQUFPLENBQUNwQyxJQUFULENBQUQsR0FBa0I0akMsV0FBdkIsQ0FBWCxDQWRLLENBYzJDOztBQUVoRG5YLFFBQUFBLGlCQUFpQixDQUFDL21DLEtBQUssQ0FBQzhwQyxRQUFOLEdBQWlCMEIsS0FBSyxDQUFDOTNDLEdBQU4sQ0FBVTBVLE9BQVYsRUFBbUIzZSxDQUFuQixDQUFsQixDQUFqQjs7QUFFQWljLFFBQUFBLElBQUksR0FBRyxDQUFQLElBQVkxRixLQUFLLENBQUM4cEMsUUFBTixDQUFlenNDLE1BQWYsQ0FBc0IsQ0FBQyxDQUF2QixFQUEwQixJQUExQixDQUFaLENBbEJLLENBa0J3Qzs7QUFFN0MyQyxRQUFBQSxLQUFLLENBQUN5b0MsTUFBTixHQUFlL2lDLElBQWY7O0FBRUEsWUFBSSxDQUFDa3pCLGVBQUwsRUFBc0I7QUFDcEJzUSxVQUFBQSxVQUFVLENBQUNscEMsS0FBSyxDQUFDOHBDLFFBQVAsRUFBaUJ6SCxRQUFqQixDQUFWLENBRG9CLENBQ2tCOztBQUV2QyxTQUhELE1BR08sSUFBSSxDQUFDMzhCLElBQUwsRUFBVztBQUNoQjtBQUNEO0FBQ0Y7QUFDRjs7QUFFRDFGLElBQUFBLEtBQUssQ0FBQzhjLEdBQU4sR0FBWTljLEtBQUssQ0FBQ28rQyxRQUFOLEdBQWlCLENBQTdCO0FBQ0F6cUQsSUFBQUEsSUFBSSxHQUFHMnRDLEdBQUcsSUFBSW1CLFdBQVcsQ0FBQzl1QyxJQUFELENBQWxCLElBQTRCQSxJQUFJLElBQUksQ0FBQzJ0QyxHQUE1Qzs7QUFFQSxTQUFLeDNDLENBQUMsR0FBRyxDQUFULEVBQVlBLENBQUMsR0FBR3NlLE9BQU8sQ0FBQ3JlLE1BQXhCLEVBQWdDRCxDQUFDLEVBQWpDLEVBQXFDO0FBQ25DeUMsTUFBQUEsTUFBTSxHQUFHNmIsT0FBTyxDQUFDdGUsQ0FBRCxDQUFoQjtBQUNBbTBELE1BQUFBLE1BQU0sR0FBRzF4RCxNQUFNLENBQUMwTyxLQUFQLElBQWdCd3BDLFFBQVEsQ0FBQ3I4QixPQUFELENBQVIsQ0FBa0J0ZSxDQUFsQixFQUFxQm1SLEtBQTlDO0FBQ0ErRSxNQUFBQSxLQUFLLENBQUM0M0MsU0FBTixDQUFnQjl0RCxDQUFoQixJQUFxQjB6RCxRQUFRLEdBQUcsRUFBaEM7QUFDQXRaLE1BQUFBLFdBQVcsQ0FBQytaLE1BQU0sQ0FBQ3YyQyxFQUFSLENBQVgsSUFBMEJ1OEIsV0FBVyxDQUFDbDZDLE1BQXRDLElBQWdEdTdDLFdBQVcsRUFBM0QsQ0FKbUMsQ0FJNEI7O0FBRS9EMzVCLE1BQUFBLEtBQUssR0FBR2l5QyxXQUFXLEtBQUt4MUMsT0FBaEIsR0FBMEJ0ZSxDQUExQixHQUE4Qjh6RCxXQUFXLENBQUNybUQsT0FBWixDQUFvQmhMLE1BQXBCLENBQXRDOztBQUVBLFVBQUltd0IsT0FBTyxJQUFJLENBQUNqQyxNQUFNLEdBQUcsSUFBSWlDLE9BQUosRUFBVixFQUF5QmEsSUFBekIsQ0FBOEJoeEIsTUFBOUIsRUFBc0MyeEQsV0FBVyxJQUFJSCxTQUFyRCxFQUFnRS85QyxLQUFoRSxFQUF1RTJMLEtBQXZFLEVBQThFaXlDLFdBQTlFLE1BQStGLEtBQTlHLEVBQXFIO0FBQ25INTlDLFFBQUFBLEtBQUssQ0FBQzhjLEdBQU4sR0FBWUQsRUFBRSxHQUFHLElBQUk3QyxTQUFKLENBQWNoYSxLQUFLLENBQUM4YyxHQUFwQixFQUF5QnZ3QixNQUF6QixFQUFpQ2t1QixNQUFNLENBQUMvTixJQUF4QyxFQUE4QyxDQUE5QyxFQUFpRCxDQUFqRCxFQUFvRCtOLE1BQU0sQ0FBQ3BkLE1BQTNELEVBQW1Fb2QsTUFBbkUsRUFBMkUsQ0FBM0UsRUFBOEVBLE1BQU0sQ0FBQ2dqQyxRQUFyRixDQUFqQjs7QUFFQWhqQyxRQUFBQSxNQUFNLENBQUN3QyxNQUFQLENBQWM3eUIsT0FBZCxDQUFzQixVQUFVc2lCLElBQVYsRUFBZ0I7QUFDcEM4d0MsVUFBQUEsUUFBUSxDQUFDOXdDLElBQUQsQ0FBUixHQUFpQm1RLEVBQWpCO0FBQ0QsU0FGRDs7QUFJQXBDLFFBQUFBLE1BQU0sQ0FBQ2dqQyxRQUFQLEtBQW9CTyxXQUFXLEdBQUcsQ0FBbEM7QUFDRDs7QUFFRCxVQUFJLENBQUN0aEMsT0FBRCxJQUFZd2hDLFdBQWhCLEVBQTZCO0FBQzNCLGFBQUt6MEQsQ0FBTCxJQUFVczBELFNBQVYsRUFBcUI7QUFDbkIsY0FBSTNaLFFBQVEsQ0FBQzM2QyxDQUFELENBQVIsS0FBZ0JneEIsTUFBTSxHQUFHOGlDLFlBQVksQ0FBQzl6RCxDQUFELEVBQUlzMEQsU0FBSixFQUFlLzlDLEtBQWYsRUFBc0IyTCxLQUF0QixFQUE2QnBmLE1BQTdCLEVBQXFDcXhELFdBQXJDLENBQXJDLENBQUosRUFBNkY7QUFDM0ZuakMsWUFBQUEsTUFBTSxDQUFDZ2pDLFFBQVAsS0FBb0JPLFdBQVcsR0FBRyxDQUFsQztBQUNELFdBRkQsTUFFTztBQUNMUixZQUFBQSxRQUFRLENBQUMvekQsQ0FBRCxDQUFSLEdBQWNvekIsRUFBRSxHQUFHMnlCLGFBQWEsQ0FBQ3o4QyxJQUFkLENBQW1CaU4sS0FBbkIsRUFBMEJ6VCxNQUExQixFQUFrQzlDLENBQWxDLEVBQXFDLEtBQXJDLEVBQTRDczBELFNBQVMsQ0FBQ3QwRCxDQUFELENBQXJELEVBQTBEa2lCLEtBQTFELEVBQWlFaXlDLFdBQWpFLEVBQThFLENBQTlFLEVBQWlGNXRELElBQUksQ0FBQ29zRCxZQUF0RixDQUFuQjtBQUNEO0FBQ0Y7QUFDRjs7QUFFRHA4QyxNQUFBQSxLQUFLLENBQUNxK0MsR0FBTixJQUFhcitDLEtBQUssQ0FBQ3ErQyxHQUFOLENBQVV2MEQsQ0FBVixDQUFiLElBQTZCa1csS0FBSyxDQUFDNEMsSUFBTixDQUFXclcsTUFBWCxFQUFtQnlULEtBQUssQ0FBQ3ErQyxHQUFOLENBQVV2MEQsQ0FBVixDQUFuQixDQUE3Qjs7QUFFQSxVQUFJK3pELGFBQWEsSUFBSTc5QyxLQUFLLENBQUM4YyxHQUEzQixFQUFnQztBQUM5QmkrQixRQUFBQSxpQkFBaUIsR0FBRy82QyxLQUFwQjs7QUFFQW9qQyxRQUFBQSxlQUFlLENBQUN4dEMsWUFBaEIsQ0FBNkJySixNQUE3QixFQUFxQ2l4RCxRQUFyQyxFQUErQ3g5QyxLQUFLLENBQUNpNEMsVUFBTixDQUFpQnZ5QyxJQUFqQixDQUEvQyxFQUg4QixDQUcwQzs7O0FBR3hFeTRDLFFBQUFBLFdBQVcsR0FBRyxDQUFDbitDLEtBQUssQ0FBQ25JLE1BQXJCO0FBQ0FrakQsUUFBQUEsaUJBQWlCLEdBQUcsQ0FBcEI7QUFDRDs7QUFFRC82QyxNQUFBQSxLQUFLLENBQUM4YyxHQUFOLElBQWFucEIsSUFBYixLQUFzQnV3QyxXQUFXLENBQUMrWixNQUFNLENBQUN2MkMsRUFBUixDQUFYLEdBQXlCLENBQS9DO0FBQ0Q7O0FBRURzMkMsSUFBQUEsV0FBVyxJQUFJTSx5QkFBeUIsQ0FBQ3QrQyxLQUFELENBQXhDO0FBQ0FBLElBQUFBLEtBQUssQ0FBQ3UrQyxPQUFOLElBQWlCditDLEtBQUssQ0FBQ3UrQyxPQUFOLENBQWN2K0MsS0FBZCxDQUFqQixDQWpJcUMsQ0FpSUU7QUFDeEM7O0FBRURBLEVBQUFBLEtBQUssQ0FBQytwQyxTQUFOLEdBQWtCdHBDLFFBQWxCO0FBQ0FULEVBQUFBLEtBQUssQ0FBQzI0QixRQUFOLEdBQWlCLENBQUMsQ0FBQzM0QixLQUFLLENBQUNxK0MsR0FBUCxJQUFjcitDLEtBQUssQ0FBQzhjLEdBQXJCLEtBQTZCLENBQUNxaEMsV0FBL0MsQ0FuTGdELENBbUxZOztBQUU1RGhZLEVBQUFBLFNBQVMsSUFBSXpnQyxJQUFJLElBQUksQ0FBckIsSUFBMEJrUyxFQUFFLENBQUN2YSxNQUFILENBQVU3VSxPQUFWLEVBQW1CLElBQW5CLEVBQXlCLElBQXpCLENBQTFCLENBckxnRCxDQXFMVTtBQUMzRCxDQXRVRDtBQUFBLElBdVVJZzJELGlCQUFpQixHQUFHLFNBQVNBLGlCQUFULENBQTJCeCtDLEtBQTNCLEVBQWtDelIsUUFBbEMsRUFBNENySCxLQUE1QyxFQUFtRGlhLEtBQW5ELEVBQTBEczlDLGVBQTFELEVBQTJFejNDLEtBQTNFLEVBQWtGdEIsSUFBbEYsRUFBd0Y7QUFDOUcsTUFBSWc1QyxPQUFPLEdBQUcsQ0FBQzErQyxLQUFLLENBQUM4YyxHQUFOLElBQWE5YyxLQUFLLENBQUNvK0MsUUFBbkIsS0FBZ0NwK0MsS0FBSyxDQUFDbytDLFFBQU4sR0FBaUIsRUFBakQsQ0FBRCxFQUF1RDd2RCxRQUF2RCxDQUFkO0FBQUEsTUFDSXN1QixFQURKO0FBQUEsTUFFSXZSLE1BRko7QUFBQSxNQUdJeGhCLENBSEo7O0FBS0EsTUFBSSxDQUFDNDBELE9BQUwsRUFBYztBQUNaQSxJQUFBQSxPQUFPLEdBQUcxK0MsS0FBSyxDQUFDbytDLFFBQU4sQ0FBZTd2RCxRQUFmLElBQTJCLEVBQXJDO0FBQ0ErYyxJQUFBQSxNQUFNLEdBQUd0TCxLQUFLLENBQUM0M0MsU0FBZjtBQUNBOXRELElBQUFBLENBQUMsR0FBR2tXLEtBQUssQ0FBQ2s3QyxRQUFOLENBQWVueEQsTUFBbkI7O0FBRUEsV0FBT0QsQ0FBQyxFQUFSLEVBQVk7QUFDVit5QixNQUFBQSxFQUFFLEdBQUd2UixNQUFNLENBQUN4aEIsQ0FBRCxDQUFOLENBQVV5RSxRQUFWLENBQUw7O0FBRUEsVUFBSXN1QixFQUFFLElBQUlBLEVBQUUsQ0FBQ3JZLENBQVQsSUFBY3FZLEVBQUUsQ0FBQ3JZLENBQUgsQ0FBS3NZLEdBQXZCLEVBQTRCO0FBQzFCO0FBQ0FELFFBQUFBLEVBQUUsR0FBR0EsRUFBRSxDQUFDclksQ0FBSCxDQUFLc1ksR0FBVjs7QUFFQSxlQUFPRCxFQUFFLElBQUlBLEVBQUUsQ0FBQ3B6QixDQUFILEtBQVM4RSxRQUF0QixFQUFnQztBQUM5QnN1QixVQUFBQSxFQUFFLEdBQUdBLEVBQUUsQ0FBQ3NCLEtBQVI7QUFDRDtBQUNGOztBQUVELFVBQUksQ0FBQ3RCLEVBQUwsRUFBUztBQUNQO0FBQ0E7QUFDQXFnQyxRQUFBQSxtQkFBbUIsR0FBRyxDQUF0QixDQUhPLENBR2tCOztBQUV6Qmw5QyxRQUFBQSxLQUFLLENBQUNoUSxJQUFOLENBQVd6QixRQUFYLElBQXVCLEtBQXZCOztBQUVBMjZDLFFBQUFBLFVBQVUsQ0FBQ2xwQyxLQUFELEVBQVEwRixJQUFSLENBQVY7O0FBRUF3M0MsUUFBQUEsbUJBQW1CLEdBQUcsQ0FBdEI7QUFDQSxlQUFPLENBQVA7QUFDRDs7QUFFRHdCLE1BQUFBLE9BQU8sQ0FBQ24wRCxJQUFSLENBQWFzeUIsRUFBYjtBQUNEO0FBQ0Y7O0FBRUQveUIsRUFBQUEsQ0FBQyxHQUFHNDBELE9BQU8sQ0FBQzMwRCxNQUFaOztBQUVBLFNBQU9ELENBQUMsRUFBUixFQUFZO0FBQ1YreUIsSUFBQUEsRUFBRSxHQUFHNmhDLE9BQU8sQ0FBQzUwRCxDQUFELENBQVo7QUFDQSt5QixJQUFBQSxFQUFFLENBQUNwTixDQUFILEdBQU8sQ0FBQ3RPLEtBQUssSUFBSUEsS0FBSyxLQUFLLENBQXBCLEtBQTBCLENBQUNzOUMsZUFBM0IsR0FBNkN0OUMsS0FBN0MsR0FBcUQwYixFQUFFLENBQUNwTixDQUFILElBQVF0TyxLQUFLLElBQUksQ0FBakIsSUFBc0I2RixLQUFLLEdBQUc2VixFQUFFLENBQUN2WSxDQUE3RjtBQUNBdVksSUFBQUEsRUFBRSxDQUFDdlksQ0FBSCxHQUFPcGQsS0FBSyxHQUFHMjFCLEVBQUUsQ0FBQ3BOLENBQWxCO0FBQ0FvTixJQUFBQSxFQUFFLENBQUM1MEIsQ0FBSCxLQUFTNDBCLEVBQUUsQ0FBQzUwQixDQUFILEdBQU9ULE1BQU0sQ0FBQ04sS0FBRCxDQUFOLEdBQWdCbzJCLE9BQU8sQ0FBQ1QsRUFBRSxDQUFDNTBCLENBQUosQ0FBdkMsRUFKVSxDQUlzQzs7QUFFaEQ0MEIsSUFBQUEsRUFBRSxDQUFDdFksQ0FBSCxLQUFTc1ksRUFBRSxDQUFDdFksQ0FBSCxHQUFPc1ksRUFBRSxDQUFDcE4sQ0FBSCxHQUFPNk4sT0FBTyxDQUFDVCxFQUFFLENBQUN0WSxDQUFKLENBQTlCLEVBTlUsQ0FNNkI7QUFDeEM7QUFDRixDQXpYRDtBQUFBLElBMFhJbzZDLGlCQUFpQixHQUFHLFNBQVNBLGlCQUFULENBQTJCdjJDLE9BQTNCLEVBQW9DcFksSUFBcEMsRUFBMEM7QUFDaEUsTUFBSTBzQixPQUFPLEdBQUd0VSxPQUFPLENBQUMsQ0FBRCxDQUFQLEdBQWF5OEIsU0FBUyxDQUFDejhCLE9BQU8sQ0FBQyxDQUFELENBQVIsQ0FBVCxDQUFzQnNVLE9BQW5DLEdBQTZDLENBQTNEO0FBQUEsTUFDSWtpQyxlQUFlLEdBQUdsaUMsT0FBTyxJQUFJQSxPQUFPLENBQUNFLE9BRHpDO0FBQUEsTUFFSXB6QixJQUZKO0FBQUEsTUFHSUMsQ0FISjtBQUFBLE1BSUlLLENBSko7QUFBQSxNQUtJOHlCLE9BTEo7O0FBT0EsTUFBSSxDQUFDZ2lDLGVBQUwsRUFBc0I7QUFDcEIsV0FBTzV1RCxJQUFQO0FBQ0Q7O0FBRUR4RyxFQUFBQSxJQUFJLEdBQUdrNkMsTUFBTSxDQUFDLEVBQUQsRUFBSzF6QyxJQUFMLENBQWI7O0FBRUEsT0FBS3ZHLENBQUwsSUFBVW0xRCxlQUFWLEVBQTJCO0FBQ3pCLFFBQUluMUQsQ0FBQyxJQUFJRCxJQUFULEVBQWU7QUFDYm96QixNQUFBQSxPQUFPLEdBQUdnaUMsZUFBZSxDQUFDbjFELENBQUQsQ0FBZixDQUFtQnlPLEtBQW5CLENBQXlCLEdBQXpCLENBQVY7QUFDQXBPLE1BQUFBLENBQUMsR0FBRzh5QixPQUFPLENBQUM3eUIsTUFBWjs7QUFFQSxhQUFPRCxDQUFDLEVBQVIsRUFBWTtBQUNWTixRQUFBQSxJQUFJLENBQUNvekIsT0FBTyxDQUFDOXlCLENBQUQsQ0FBUixDQUFKLEdBQW1CTixJQUFJLENBQUNDLENBQUQsQ0FBdkI7QUFDRDtBQUNGO0FBQ0Y7O0FBRUQsU0FBT0QsSUFBUDtBQUNELENBcFpEO0FBQUEsSUFxWkk7QUFDSnExRCxjQUFjLEdBQUcsU0FBU0EsY0FBVCxDQUF3QnZrQyxJQUF4QixFQUE4Qmh4QixHQUE5QixFQUFtQ3cxRCxRQUFuQyxFQUE2Q0MsUUFBN0MsRUFBdUQ7QUFDdEUsTUFBSXZtQixJQUFJLEdBQUdsdkMsR0FBRyxDQUFDa3ZDLElBQUosSUFBWXVtQixRQUFaLElBQXdCLGNBQW5DO0FBQUEsTUFDSXQxRCxDQURKO0FBQUEsTUFFSW1KLENBRko7O0FBSUEsTUFBSWpMLFFBQVEsQ0FBQzJCLEdBQUQsQ0FBWixFQUFtQjtBQUNqQnNKLElBQUFBLENBQUMsR0FBR2tzRCxRQUFRLENBQUN4a0MsSUFBRCxDQUFSLEtBQW1Cd2tDLFFBQVEsQ0FBQ3hrQyxJQUFELENBQVIsR0FBaUIsRUFBcEMsQ0FBSixDQURpQixDQUM0Qjs7QUFFN0NoeEIsSUFBQUEsR0FBRyxDQUFDYyxPQUFKLENBQVksVUFBVWxELEtBQVYsRUFBaUI0QyxDQUFqQixFQUFvQjtBQUM5QixhQUFPOEksQ0FBQyxDQUFDckksSUFBRixDQUFPO0FBQ1pnZ0IsUUFBQUEsQ0FBQyxFQUFFemdCLENBQUMsSUFBSVIsR0FBRyxDQUFDUyxNQUFKLEdBQWEsQ0FBakIsQ0FBRCxHQUF1QixHQURkO0FBRVpxd0IsUUFBQUEsQ0FBQyxFQUFFbHpCLEtBRlM7QUFHWmUsUUFBQUEsQ0FBQyxFQUFFdXdDO0FBSFMsT0FBUCxDQUFQO0FBS0QsS0FORDtBQU9ELEdBVkQsTUFVTztBQUNMLFNBQUsvdUMsQ0FBTCxJQUFVSCxHQUFWLEVBQWU7QUFDYnNKLE1BQUFBLENBQUMsR0FBR2tzRCxRQUFRLENBQUNyMUQsQ0FBRCxDQUFSLEtBQWdCcTFELFFBQVEsQ0FBQ3IxRCxDQUFELENBQVIsR0FBYyxFQUE5QixDQUFKO0FBQ0FBLE1BQUFBLENBQUMsS0FBSyxNQUFOLElBQWdCbUosQ0FBQyxDQUFDckksSUFBRixDQUFPO0FBQ3JCZ2dCLFFBQUFBLENBQUMsRUFBRXJZLFVBQVUsQ0FBQ29vQixJQUFELENBRFE7QUFFckJGLFFBQUFBLENBQUMsRUFBRTl3QixHQUFHLENBQUNHLENBQUQsQ0FGZTtBQUdyQnhCLFFBQUFBLENBQUMsRUFBRXV3QztBQUhrQixPQUFQLENBQWhCO0FBS0Q7QUFDRjtBQUNGLENBL2FEO0FBQUEsSUFnYkk4a0Isa0JBQWtCLEdBQUcsU0FBU0Esa0JBQVQsQ0FBNEJwMkQsS0FBNUIsRUFBbUM4WSxLQUFuQyxFQUEwQ2xXLENBQTFDLEVBQTZDeUMsTUFBN0MsRUFBcUQ2YixPQUFyRCxFQUE4RDtBQUNyRixTQUFPbmhCLFdBQVcsQ0FBQ0MsS0FBRCxDQUFYLEdBQXFCQSxLQUFLLENBQUM2TCxJQUFOLENBQVdpTixLQUFYLEVBQWtCbFcsQ0FBbEIsRUFBcUJ5QyxNQUFyQixFQUE2QjZiLE9BQTdCLENBQXJCLEdBQTZEd0IsU0FBUyxDQUFDMWlCLEtBQUQsQ0FBVCxJQUFvQixDQUFDQSxLQUFLLENBQUNxUSxPQUFOLENBQWMsU0FBZCxDQUFyQixHQUFnRG0zQyxjQUFjLENBQUN4bkQsS0FBRCxDQUE5RCxHQUF3RUEsS0FBNUk7QUFDRCxDQWxiRDtBQUFBLElBbWJJODNELGtCQUFrQixHQUFHeGEsY0FBYyxHQUFHLDJEQW5iMUM7QUFBQSxJQW9iSXlhLG1CQUFtQixHQUFHLEVBcGIxQjs7QUFzYkFsYSxZQUFZLENBQUNpYSxrQkFBa0IsR0FBRyxpREFBdEIsRUFBeUUsVUFBVXR5QyxJQUFWLEVBQWdCO0FBQ25HLFNBQU91eUMsbUJBQW1CLENBQUN2eUMsSUFBRCxDQUFuQixHQUE0QixDQUFuQztBQUNELENBRlcsQ0FBWjtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdPLElBQUk4K0IsS0FBSyxHQUFHLGFBQWEsVUFBVTBULFdBQVYsRUFBdUI7QUFDckRsNkQsRUFBQUEsY0FBYyxDQUFDd21ELEtBQUQsRUFBUTBULFdBQVIsQ0FBZDs7QUFFQSxXQUFTMVQsS0FBVCxDQUFlcGpDLE9BQWYsRUFBd0JwWSxJQUF4QixFQUE4QjhELFFBQTlCLEVBQXdDcXJELFdBQXhDLEVBQXFEO0FBQ25ELFFBQUlDLE1BQUo7O0FBRUEsUUFBSSxPQUFPcHZELElBQVAsS0FBZ0IsUUFBcEIsRUFBOEI7QUFDNUI4RCxNQUFBQSxRQUFRLENBQUM3SSxRQUFULEdBQW9CK0UsSUFBcEI7QUFDQUEsTUFBQUEsSUFBSSxHQUFHOEQsUUFBUDtBQUNBQSxNQUFBQSxRQUFRLEdBQUcsSUFBWDtBQUNEOztBQUVEc3JELElBQUFBLE1BQU0sR0FBR0YsV0FBVyxDQUFDbnNELElBQVosQ0FBaUIsSUFBakIsRUFBdUJvc0QsV0FBVyxHQUFHbnZELElBQUgsR0FBVWsyQyxnQkFBZ0IsQ0FBQ2wyQyxJQUFELENBQTVELEtBQXVFLElBQWhGO0FBQ0EsUUFBSXF2RCxXQUFXLEdBQUdELE1BQU0sQ0FBQ3B2RCxJQUF6QjtBQUFBLFFBQ0kvRSxRQUFRLEdBQUdvMEQsV0FBVyxDQUFDcDBELFFBRDNCO0FBQUEsUUFFSUQsS0FBSyxHQUFHcTBELFdBQVcsQ0FBQ3IwRCxLQUZ4QjtBQUFBLFFBR0k0dEMsZUFBZSxHQUFHeW1CLFdBQVcsQ0FBQ3ptQixlQUhsQztBQUFBLFFBSUlzZ0IsT0FBTyxHQUFHbUcsV0FBVyxDQUFDbkcsT0FKMUI7QUFBQSxRQUtJbnVELFNBQVMsR0FBR3MwRCxXQUFXLENBQUN0MEQsU0FMNUI7QUFBQSxRQU1JbzdDLFNBQVMsR0FBR2taLFdBQVcsQ0FBQ2xaLFNBTjVCO0FBQUEsUUFPSXg4QyxRQUFRLEdBQUcwMUQsV0FBVyxDQUFDMTFELFFBUDNCO0FBQUEsUUFRSWt2QyxhQUFhLEdBQUd3bUIsV0FBVyxDQUFDeG1CLGFBUmhDO0FBQUEsUUFTSWlkLFFBQVEsR0FBR3VKLFdBQVcsQ0FBQ3ZKLFFBVDNCO0FBQUEsUUFVSWorQyxNQUFNLEdBQUc3SCxJQUFJLENBQUM2SCxNQUFMLElBQWV1ckMsZUFWNUI7QUFBQSxRQVdJNFgsYUFBYSxHQUFHLENBQUNyekQsUUFBUSxDQUFDeWdCLE9BQUQsQ0FBUixJQUFxQnU2QixhQUFhLENBQUN2NkIsT0FBRCxDQUFsQyxHQUE4Q3lCLFNBQVMsQ0FBQ3pCLE9BQU8sQ0FBQyxDQUFELENBQVIsQ0FBdkQsR0FBc0UsWUFBWXBZLElBQW5GLElBQTJGLENBQUNvWSxPQUFELENBQTNGLEdBQXVHalUsT0FBTyxDQUFDaVUsT0FBRCxDQVhsSTtBQUFBLFFBWUl3UCxFQVpKO0FBQUEsUUFhSTl0QixDQWJKO0FBQUEsUUFjSU4sSUFkSjtBQUFBLFFBZUlxSixDQWZKO0FBQUEsUUFnQklwSixDQWhCSjtBQUFBLFFBaUJJNjFELFNBakJKO0FBQUEsUUFrQklDLFdBbEJKO0FBQUEsUUFtQklDLGtCQW5CSjtBQW9CQUosSUFBQUEsTUFBTSxDQUFDbEUsUUFBUCxHQUFrQkYsYUFBYSxDQUFDanhELE1BQWQsR0FBdUIwNkMsUUFBUSxDQUFDdVcsYUFBRCxDQUEvQixHQUFpRHBYLEtBQUssQ0FBQyxpQkFBaUJ4N0IsT0FBakIsR0FBMkIsbUNBQTVCLEVBQWlFLENBQUM4NUIsT0FBTyxDQUFDdGdCLGNBQTFFLENBQUwsSUFBa0csRUFBcks7QUFDQXc5QixJQUFBQSxNQUFNLENBQUN4SCxTQUFQLEdBQW1CLEVBQW5CLENBL0JtRCxDQStCNUI7O0FBRXZCd0gsSUFBQUEsTUFBTSxDQUFDdEIsVUFBUCxHQUFvQi95RCxTQUFwQjs7QUFFQSxRQUFJbzdDLFNBQVMsSUFBSStTLE9BQWIsSUFBd0J4VyxlQUFlLENBQUN6M0MsUUFBRCxDQUF2QyxJQUFxRHkzQyxlQUFlLENBQUMxM0MsS0FBRCxDQUF4RSxFQUFpRjtBQUMvRWdGLE1BQUFBLElBQUksR0FBR292RCxNQUFNLENBQUNwdkQsSUFBZDtBQUNBNG5CLE1BQUFBLEVBQUUsR0FBR3duQyxNQUFNLENBQUN6eUIsUUFBUCxHQUFrQixJQUFJK2QsUUFBSixDQUFhO0FBQ2xDdi9DLFFBQUFBLElBQUksRUFBRSxRQUQ0QjtBQUVsQ3hCLFFBQUFBLFFBQVEsRUFBRUEsUUFBUSxJQUFJO0FBRlksT0FBYixDQUF2QjtBQUlBaXVCLE1BQUFBLEVBQUUsQ0FBQ2hWLElBQUg7QUFDQWdWLE1BQUFBLEVBQUUsQ0FBQy9mLE1BQUgsR0FBWStmLEVBQUUsQ0FBQ3drQixHQUFILEdBQVN2M0Msc0JBQXNCLENBQUN1NkQsTUFBRCxDQUEzQztBQUNBeG5DLE1BQUFBLEVBQUUsQ0FBQzBrQixNQUFILEdBQVksQ0FBWjs7QUFFQSxVQUFJNGMsT0FBTyxJQUFJeFcsZUFBZSxDQUFDejNDLFFBQUQsQ0FBMUIsSUFBd0N5M0MsZUFBZSxDQUFDMTNDLEtBQUQsQ0FBM0QsRUFBb0U7QUFDbEU2SCxRQUFBQSxDQUFDLEdBQUdtb0QsYUFBYSxDQUFDanhELE1BQWxCO0FBQ0F3MUQsUUFBQUEsV0FBVyxHQUFHckcsT0FBTyxJQUFJMU0sVUFBVSxDQUFDME0sT0FBRCxDQUFuQzs7QUFFQSxZQUFJL3hELFNBQVMsQ0FBQyt4RCxPQUFELENBQWIsRUFBd0I7QUFDdEI7QUFDQSxlQUFLenZELENBQUwsSUFBVXl2RCxPQUFWLEVBQW1CO0FBQ2pCLGdCQUFJLENBQUM4RixrQkFBa0IsQ0FBQ3puRCxPQUFuQixDQUEyQjlOLENBQTNCLENBQUwsRUFBb0M7QUFDbEMrMUQsY0FBQUEsa0JBQWtCLEtBQUtBLGtCQUFrQixHQUFHLEVBQTFCLENBQWxCO0FBQ0FBLGNBQUFBLGtCQUFrQixDQUFDLzFELENBQUQsQ0FBbEIsR0FBd0J5dkQsT0FBTyxDQUFDenZELENBQUQsQ0FBL0I7QUFDRDtBQUNGO0FBQ0Y7O0FBRUQsYUFBS0ssQ0FBQyxHQUFHLENBQVQsRUFBWUEsQ0FBQyxHQUFHK0ksQ0FBaEIsRUFBbUIvSSxDQUFDLEVBQXBCLEVBQXdCO0FBQ3RCTixVQUFBQSxJQUFJLEdBQUd3OEMsY0FBYyxDQUFDaDJDLElBQUQsRUFBT2l2RCxtQkFBUCxDQUFyQjtBQUNBejFELFVBQUFBLElBQUksQ0FBQzB2RCxPQUFMLEdBQWUsQ0FBZjtBQUNBcEQsVUFBQUEsUUFBUSxLQUFLdHNELElBQUksQ0FBQ3NzRCxRQUFMLEdBQWdCQSxRQUFyQixDQUFSO0FBQ0EwSixVQUFBQSxrQkFBa0IsSUFBSTliLE1BQU0sQ0FBQ2w2QyxJQUFELEVBQU9nMkQsa0JBQVAsQ0FBNUI7QUFDQUYsVUFBQUEsU0FBUyxHQUFHdEUsYUFBYSxDQUFDbHhELENBQUQsQ0FBekIsQ0FMc0IsQ0FLUTs7QUFFOUJOLFVBQUFBLElBQUksQ0FBQ3lCLFFBQUwsR0FBZ0IsQ0FBQ3F5RCxrQkFBa0IsQ0FBQ3J5RCxRQUFELEVBQVdwRyxzQkFBc0IsQ0FBQ3U2RCxNQUFELENBQWpDLEVBQTJDdDFELENBQTNDLEVBQThDdzFELFNBQTlDLEVBQXlEdEUsYUFBekQsQ0FBbkM7QUFDQXh4RCxVQUFBQSxJQUFJLENBQUN3QixLQUFMLEdBQWEsQ0FBQyxDQUFDc3lELGtCQUFrQixDQUFDdHlELEtBQUQsRUFBUW5HLHNCQUFzQixDQUFDdTZELE1BQUQsQ0FBOUIsRUFBd0N0MUQsQ0FBeEMsRUFBMkN3MUQsU0FBM0MsRUFBc0R0RSxhQUF0RCxDQUFuQixJQUEyRixDQUE1RixJQUFpR29FLE1BQU0sQ0FBQ3hXLE1BQXJIOztBQUVBLGNBQUksQ0FBQ3NRLE9BQUQsSUFBWXJtRCxDQUFDLEtBQUssQ0FBbEIsSUFBdUJySixJQUFJLENBQUN3QixLQUFoQyxFQUF1QztBQUNyQztBQUNBbzBELFlBQUFBLE1BQU0sQ0FBQ3hXLE1BQVAsR0FBZ0I1OUMsS0FBSyxHQUFHeEIsSUFBSSxDQUFDd0IsS0FBN0I7QUFDQW8wRCxZQUFBQSxNQUFNLENBQUM5aUIsTUFBUCxJQUFpQnR4QyxLQUFqQjtBQUNBeEIsWUFBQUEsSUFBSSxDQUFDd0IsS0FBTCxHQUFhLENBQWI7QUFDRDs7QUFFRDRzQixVQUFBQSxFQUFFLENBQUM5c0IsRUFBSCxDQUFNdzBELFNBQU4sRUFBaUI5MUQsSUFBakIsRUFBdUIrMUQsV0FBVyxHQUFHQSxXQUFXLENBQUN6MUQsQ0FBRCxFQUFJdzFELFNBQUosRUFBZXRFLGFBQWYsQ0FBZCxHQUE4QyxDQUFoRjtBQUNBcGpDLFVBQUFBLEVBQUUsQ0FBQ20rQixLQUFILEdBQVdmLFFBQVEsQ0FBQ2dDLElBQXBCO0FBQ0Q7O0FBRURwL0IsUUFBQUEsRUFBRSxDQUFDM3NCLFFBQUgsS0FBZ0JBLFFBQVEsR0FBR0QsS0FBSyxHQUFHLENBQW5DLEdBQXVDbzBELE1BQU0sQ0FBQ3p5QixRQUFQLEdBQWtCLENBQXpELENBbkNrRSxDQW1DTjtBQUM3RCxPQXBDRCxNQW9DTyxJQUFJd1osU0FBSixFQUFlO0FBQ3BCRCxRQUFBQSxnQkFBZ0IsQ0FBQzk2QyxZQUFZLENBQUN3c0IsRUFBRSxDQUFDNW5CLElBQUgsQ0FBUXJHLFFBQVQsRUFBbUI7QUFDOUM2dUMsVUFBQUEsSUFBSSxFQUFFO0FBRHdDLFNBQW5CLENBQWIsQ0FBaEI7O0FBSUE1Z0IsUUFBQUEsRUFBRSxDQUFDbStCLEtBQUgsR0FBV3JKLFVBQVUsQ0FBQ3ZHLFNBQVMsQ0FBQzNOLElBQVYsSUFBa0J4b0MsSUFBSSxDQUFDd29DLElBQXZCLElBQStCLE1BQWhDLENBQXJCO0FBQ0EsWUFBSTl5QixJQUFJLEdBQUcsQ0FBWDtBQUFBLFlBQ0k5UyxDQURKO0FBQUEsWUFFSTZzRCxFQUZKO0FBQUEsWUFHSXJsQyxDQUhKOztBQUtBLFlBQUl6eUIsUUFBUSxDQUFDdytDLFNBQUQsQ0FBWixFQUF5QjtBQUN2QkEsVUFBQUEsU0FBUyxDQUFDLzdDLE9BQVYsQ0FBa0IsVUFBVXFtQyxLQUFWLEVBQWlCO0FBQ2pDLG1CQUFPN1ksRUFBRSxDQUFDOXNCLEVBQUgsQ0FBTWt3RCxhQUFOLEVBQXFCdnFCLEtBQXJCLEVBQTRCLEdBQTVCLENBQVA7QUFDRCxXQUZEO0FBR0QsU0FKRCxNQUlPO0FBQ0xqbkMsVUFBQUEsSUFBSSxHQUFHLEVBQVA7O0FBRUEsZUFBS0MsQ0FBTCxJQUFVMDhDLFNBQVYsRUFBcUI7QUFDbkIxOEMsWUFBQUEsQ0FBQyxLQUFLLE1BQU4sSUFBZ0JBLENBQUMsS0FBSyxVQUF0QixJQUFvQ28xRCxjQUFjLENBQUNwMUQsQ0FBRCxFQUFJMDhDLFNBQVMsQ0FBQzE4QyxDQUFELENBQWIsRUFBa0JELElBQWxCLEVBQXdCMjhDLFNBQVMsQ0FBQzRZLFFBQWxDLENBQWxEO0FBQ0Q7O0FBRUQsZUFBS3QxRCxDQUFMLElBQVVELElBQVYsRUFBZ0I7QUFDZG9KLFlBQUFBLENBQUMsR0FBR3BKLElBQUksQ0FBQ0MsQ0FBRCxDQUFKLENBQVF1akMsSUFBUixDQUFhLFVBQVVwNkIsQ0FBVixFQUFhMlIsQ0FBYixFQUFnQjtBQUMvQixxQkFBTzNSLENBQUMsQ0FBQzJYLENBQUYsR0FBTWhHLENBQUMsQ0FBQ2dHLENBQWY7QUFDRCxhQUZHLENBQUo7QUFHQTdFLFlBQUFBLElBQUksR0FBRyxDQUFQOztBQUVBLGlCQUFLNWIsQ0FBQyxHQUFHLENBQVQsRUFBWUEsQ0FBQyxHQUFHOEksQ0FBQyxDQUFDN0ksTUFBbEIsRUFBMEJELENBQUMsRUFBM0IsRUFBK0I7QUFDN0IyMUQsY0FBQUEsRUFBRSxHQUFHN3NELENBQUMsQ0FBQzlJLENBQUQsQ0FBTjtBQUNBc3dCLGNBQUFBLENBQUMsR0FBRztBQUNGb2UsZ0JBQUFBLElBQUksRUFBRWluQixFQUFFLENBQUN4M0QsQ0FEUDtBQUVGZ0QsZ0JBQUFBLFFBQVEsRUFBRSxDQUFDdzBELEVBQUUsQ0FBQ2wxQyxDQUFILElBQVF6Z0IsQ0FBQyxHQUFHOEksQ0FBQyxDQUFDOUksQ0FBQyxHQUFHLENBQUwsQ0FBRCxDQUFTeWdCLENBQVosR0FBZ0IsQ0FBekIsQ0FBRCxJQUFnQyxHQUFoQyxHQUFzQ3RmO0FBRjlDLGVBQUo7QUFJQW12QixjQUFBQSxDQUFDLENBQUMzd0IsQ0FBRCxDQUFELEdBQU9nMkQsRUFBRSxDQUFDcmxDLENBQVY7QUFDQXhDLGNBQUFBLEVBQUUsQ0FBQzlzQixFQUFILENBQU1rd0QsYUFBTixFQUFxQjVnQyxDQUFyQixFQUF3QjFVLElBQXhCO0FBQ0FBLGNBQUFBLElBQUksSUFBSTBVLENBQUMsQ0FBQ252QixRQUFWO0FBQ0Q7QUFDRjs7QUFFRDJzQixVQUFBQSxFQUFFLENBQUMzc0IsUUFBSCxLQUFnQkEsUUFBaEIsSUFBNEIyc0IsRUFBRSxDQUFDOXNCLEVBQUgsQ0FBTSxFQUFOLEVBQVU7QUFDcENHLFlBQUFBLFFBQVEsRUFBRUEsUUFBUSxHQUFHMnNCLEVBQUUsQ0FBQzNzQixRQUFIO0FBRGUsV0FBVixDQUE1QixDQXpCSyxDQTJCRDtBQUNMO0FBQ0Y7O0FBRURBLE1BQUFBLFFBQVEsSUFBSW0wRCxNQUFNLENBQUNuMEQsUUFBUCxDQUFnQkEsUUFBUSxHQUFHMnNCLEVBQUUsQ0FBQzNzQixRQUFILEVBQTNCLENBQVo7QUFDRCxLQTdGRCxNQTZGTztBQUNMbTBELE1BQUFBLE1BQU0sQ0FBQ3p5QixRQUFQLEdBQWtCLENBQWxCLENBREssQ0FDZ0I7QUFDdEI7O0FBRUQsUUFBSTVoQyxTQUFTLEtBQUssSUFBZCxJQUFzQixDQUFDaStCLG1CQUEzQixFQUFnRDtBQUM5Qyt4QixNQUFBQSxpQkFBaUIsR0FBR2wyRCxzQkFBc0IsQ0FBQ3U2RCxNQUFELENBQTFDOztBQUVBaGMsTUFBQUEsZUFBZSxDQUFDeHRDLFlBQWhCLENBQTZCb2xELGFBQTdCOztBQUVBRCxNQUFBQSxpQkFBaUIsR0FBRyxDQUFwQjtBQUNEOztBQUVEclMsSUFBQUEsY0FBYyxDQUFDN3dDLE1BQUQsRUFBU2hULHNCQUFzQixDQUFDdTZELE1BQUQsQ0FBL0IsRUFBeUN0ckQsUUFBekMsQ0FBZDs7QUFFQTlELElBQUFBLElBQUksQ0FBQ2liLFFBQUwsSUFBaUJtMEMsTUFBTSxDQUFDcDBDLE9BQVAsRUFBakI7QUFDQWhiLElBQUFBLElBQUksQ0FBQzBvQyxNQUFMLElBQWUwbUIsTUFBTSxDQUFDMW1CLE1BQVAsQ0FBYyxJQUFkLENBQWY7O0FBRUEsUUFBSUUsZUFBZSxJQUFJLENBQUMzdEMsUUFBRCxJQUFhLENBQUNrN0MsU0FBZCxJQUEyQmlaLE1BQU0sQ0FBQzlpQixNQUFQLEtBQWtCbnlCLGFBQWEsQ0FBQ3RTLE1BQU0sQ0FBQ3drQyxLQUFSLENBQTFELElBQTRFb0csV0FBVyxDQUFDN0osZUFBRCxDQUF2RixJQUE0RzRPLHFCQUFxQixDQUFDM2lELHNCQUFzQixDQUFDdTZELE1BQUQsQ0FBdkIsQ0FBakksSUFBcUt2bkQsTUFBTSxDQUFDMU0sSUFBUCxLQUFnQixRQUE1TSxFQUFzTjtBQUNwTmkwRCxNQUFBQSxNQUFNLENBQUM1aUIsTUFBUCxHQUFnQixDQUFDNkYsUUFBakIsQ0FEb04sQ0FDekw7O0FBRTNCK2MsTUFBQUEsTUFBTSxDQUFDL2hELE1BQVAsQ0FBYzVWLElBQUksQ0FBQ29HLEdBQUwsQ0FBUyxDQUFULEVBQVksQ0FBQzdDLEtBQWIsQ0FBZCxFQUhvTixDQUdoTDs7QUFFckM7O0FBRUQ2dEMsSUFBQUEsYUFBYSxJQUFJbVEsY0FBYyxDQUFDbmtELHNCQUFzQixDQUFDdTZELE1BQUQsQ0FBdkIsRUFBaUN2bUIsYUFBakMsQ0FBL0I7QUFDQSxXQUFPdW1CLE1BQVA7QUFDRDs7QUFFRCxNQUFJTSxPQUFPLEdBQUdsVSxLQUFLLENBQUNybUQsU0FBcEI7O0FBRUF1NkQsRUFBQUEsT0FBTyxDQUFDcmlELE1BQVIsR0FBaUIsU0FBU0EsTUFBVCxDQUFnQnl0QixTQUFoQixFQUEyQnh0QixjQUEzQixFQUEyQzlILEtBQTNDLEVBQWtEO0FBQ2pFLFFBQUkwMEMsUUFBUSxHQUFHLEtBQUs3TixLQUFwQjtBQUFBLFFBQ0ltZCxJQUFJLEdBQUcsS0FBSy9jLEtBRGhCO0FBQUEsUUFFSTZFLEdBQUcsR0FBRyxLQUFLK0YsSUFGZjtBQUFBLFFBR0lRLEtBQUssR0FBRy9jLFNBQVMsR0FBRzB1QixJQUFJLEdBQUduWCxRQUFuQixJQUErQnZYLFNBQVMsSUFBSSxDQUE1QyxHQUFnRDB1QixJQUFoRCxHQUF1RDF1QixTQUFTLEdBQUd1WCxRQUFaLEdBQXVCLENBQXZCLEdBQTJCdlgsU0FIOUY7QUFBQSxRQUlJcGxCLElBSko7QUFBQSxRQUtJbVgsRUFMSjtBQUFBLFFBTUk0c0IsU0FOSjtBQUFBLFFBT0kzQixhQVBKO0FBQUEsUUFRSTRCLGFBUko7QUFBQSxRQVNJbU0sTUFUSjtBQUFBLFFBVUk3dUMsS0FWSjtBQUFBLFFBV0kybEIsUUFYSjtBQUFBLFFBWUltcEIsUUFaSjs7QUFjQSxRQUFJLENBQUN4VSxHQUFMLEVBQVU7QUFDUmdJLE1BQUFBLHdCQUF3QixDQUFDLElBQUQsRUFBT3hlLFNBQVAsRUFBa0J4dEIsY0FBbEIsRUFBa0M5SCxLQUFsQyxDQUF4QjtBQUNELEtBRkQsTUFFTyxJQUFJcXlDLEtBQUssS0FBSyxLQUFLckwsTUFBZixJQUF5QixDQUFDMVIsU0FBMUIsSUFBdUN0MUIsS0FBdkMsSUFBZ0QsQ0FBQyxLQUFLbWpDLFFBQU4sSUFBa0IsS0FBSzZELE1BQXZFLElBQWlGLEtBQUtzTixRQUFMLElBQWlCLEtBQUtyQixNQUFMLEdBQWMsQ0FBZCxLQUFvQjNkLFNBQVMsR0FBRyxDQUF0SSxFQUF5STtBQUM5STtBQUNBcGxCLE1BQUFBLElBQUksR0FBR21pQyxLQUFQO0FBQ0FsYixNQUFBQSxRQUFRLEdBQUcsS0FBS0EsUUFBaEI7O0FBRUEsVUFBSSxLQUFLK2EsT0FBVCxFQUFrQjtBQUNoQjtBQUNBSSxRQUFBQSxhQUFhLEdBQUd4RyxHQUFHLEdBQUcsS0FBS3NHLE9BQTNCOztBQUVBLFlBQUksS0FBS0YsT0FBTCxHQUFlLENBQUMsQ0FBaEIsSUFBcUI1YyxTQUFTLEdBQUcsQ0FBckMsRUFBd0M7QUFDdEMsaUJBQU8sS0FBS0EsU0FBTCxDQUFlZ2QsYUFBYSxHQUFHLEdBQWhCLEdBQXNCaGQsU0FBckMsRUFBZ0R4dEIsY0FBaEQsRUFBZ0U5SCxLQUFoRSxDQUFQO0FBQ0Q7O0FBRURrUSxRQUFBQSxJQUFJLEdBQUd5RSxhQUFhLENBQUMwOUIsS0FBSyxHQUFHQyxhQUFULENBQXBCLENBUmdCLENBUTZCOztBQUU3QyxZQUFJRCxLQUFLLEtBQUsyUixJQUFkLEVBQW9CO0FBQ2xCO0FBQ0EvUCxVQUFBQSxTQUFTLEdBQUcsS0FBSy9CLE9BQWpCO0FBQ0FoaUMsVUFBQUEsSUFBSSxHQUFHNDdCLEdBQVA7QUFDRCxTQUpELE1BSU87QUFDTG1JLFVBQUFBLFNBQVMsR0FBRyxDQUFDLEVBQUU1QixLQUFLLEdBQUdDLGFBQVYsQ0FBYjs7QUFFQSxjQUFJMkIsU0FBUyxJQUFJQSxTQUFTLEtBQUs1QixLQUFLLEdBQUdDLGFBQXZDLEVBQXNEO0FBQ3BEcGlDLFlBQUFBLElBQUksR0FBRzQ3QixHQUFQO0FBQ0FtSSxZQUFBQSxTQUFTO0FBQ1Y7O0FBRUQvakMsVUFBQUEsSUFBSSxHQUFHNDdCLEdBQVAsS0FBZTU3QixJQUFJLEdBQUc0N0IsR0FBdEI7QUFDRDs7QUFFRHVVLFFBQUFBLE1BQU0sR0FBRyxLQUFLbE0sS0FBTCxJQUFjRixTQUFTLEdBQUcsQ0FBbkM7O0FBRUEsWUFBSW9NLE1BQUosRUFBWTtBQUNWQyxVQUFBQSxRQUFRLEdBQUcsS0FBS0UsTUFBaEI7QUFDQXR3QyxVQUFBQSxJQUFJLEdBQUc0N0IsR0FBRyxHQUFHNTdCLElBQWI7QUFDRDs7QUFFRGdrQyxRQUFBQSxhQUFhLEdBQUcvQixlQUFlLENBQUMsS0FBS25MLE1BQU4sRUFBY3NMLGFBQWQsQ0FBL0I7O0FBRUEsWUFBSXBpQyxJQUFJLEtBQUt3a0MsUUFBVCxJQUFxQixDQUFDMTBDLEtBQXRCLElBQStCLEtBQUttakMsUUFBeEMsRUFBa0Q7QUFDaEQ7QUFDQSxlQUFLNkQsTUFBTCxHQUFjcUwsS0FBZDtBQUNBLGlCQUFPLElBQVA7QUFDRDs7QUFFRCxZQUFJNEIsU0FBUyxLQUFLQyxhQUFsQixFQUFpQztBQUMvQi9jLFVBQUFBLFFBQVEsSUFBSSxLQUFLcXBCLE1BQWpCLElBQTJCSixrQkFBa0IsQ0FBQ2pwQixRQUFELEVBQVdrcEIsTUFBWCxDQUE3QyxDQUQrQixDQUNrQzs7QUFFakUsY0FBSSxLQUFLN2xELElBQUwsQ0FBVTQ1QyxhQUFWLElBQTJCLENBQUNpTSxNQUE1QixJQUFzQyxDQUFDLEtBQUt4TSxLQUFoRCxFQUF1RDtBQUNyRCxpQkFBS0EsS0FBTCxHQUFhN3pDLEtBQUssR0FBRyxDQUFyQixDQURxRCxDQUM3Qjs7QUFFeEIsaUJBQUs2SCxNQUFMLENBQVk4TSxhQUFhLENBQUMyOUIsYUFBYSxHQUFHMkIsU0FBakIsQ0FBekIsRUFBc0QsSUFBdEQsRUFBNERsUCxVQUE1RCxHQUF5RThPLEtBQXpFLEdBQWlGLENBQWpGO0FBQ0Q7QUFDRjtBQUNGOztBQUVELFVBQUksQ0FBQyxLQUFLMVEsUUFBVixFQUFvQjtBQUNsQixZQUFJc1EsaUJBQWlCLENBQUMsSUFBRCxFQUFPbmUsU0FBUyxHQUFHLENBQVosR0FBZ0JBLFNBQWhCLEdBQTRCcGxCLElBQW5DLEVBQXlDbFEsS0FBekMsRUFBZ0Q4SCxjQUFoRCxDQUFyQixFQUFzRjtBQUNwRixlQUFLay9CLE1BQUwsR0FBYyxDQUFkLENBRG9GLENBQ25FOztBQUVqQixpQkFBTyxJQUFQO0FBQ0Q7O0FBRUQsWUFBSTBOLFFBQVEsS0FBSyxLQUFLN04sS0FBdEIsRUFBNkI7QUFDM0I7QUFDQSxpQkFBTyxJQUFQO0FBQ0Q7O0FBRUQsWUFBSWlGLEdBQUcsS0FBSyxLQUFLK0YsSUFBakIsRUFBdUI7QUFDckI7QUFDQSxpQkFBTyxLQUFLaHFDLE1BQUwsQ0FBWXl0QixTQUFaLEVBQXVCeHRCLGNBQXZCLEVBQXVDOUgsS0FBdkMsQ0FBUDtBQUNEO0FBQ0Y7O0FBRUQsV0FBS2duQyxNQUFMLEdBQWNxTCxLQUFkO0FBQ0EsV0FBS3hMLEtBQUwsR0FBYTMyQixJQUFiOztBQUVBLFVBQUksQ0FBQyxLQUFLd2hDLElBQU4sSUFBYyxLQUFLeEYsR0FBdkIsRUFBNEI7QUFDMUIsYUFBS3dGLElBQUwsR0FBWSxDQUFaLENBRDBCLENBQ1g7O0FBRWYsYUFBSzNCLEtBQUwsR0FBYSxDQUFiO0FBQ0Q7O0FBRUQsV0FBS3YrQixLQUFMLEdBQWFBLEtBQUssR0FBRyxDQUFDOHVDLFFBQVEsSUFBSSxLQUFLQyxLQUFsQixFQUF5QnJ3QyxJQUFJLEdBQUc0N0IsR0FBaEMsQ0FBckI7O0FBRUEsVUFBSSxLQUFLdUksS0FBVCxFQUFnQjtBQUNkLGFBQUs3aUMsS0FBTCxHQUFhQSxLQUFLLEdBQUcsSUFBSUEsS0FBekI7QUFDRDs7QUFFRCxVQUFJdEIsSUFBSSxJQUFJLENBQUN3a0MsUUFBVCxJQUFxQixDQUFDNXNDLGNBQTFCLEVBQTBDO0FBQ3hDdXRCLFFBQUFBLFNBQVMsQ0FBQyxJQUFELEVBQU8sU0FBUCxDQUFUOztBQUVBLFlBQUksS0FBSzJSLE1BQUwsS0FBZ0JxTCxLQUFwQixFQUEyQjtBQUN6QjtBQUNBLGlCQUFPLElBQVA7QUFDRDtBQUNGOztBQUVEaHJCLE1BQUFBLEVBQUUsR0FBRyxLQUFLQyxHQUFWOztBQUVBLGFBQU9ELEVBQVAsRUFBVztBQUNUQSxRQUFBQSxFQUFFLENBQUNudEIsQ0FBSCxDQUFLc1gsS0FBTCxFQUFZNlYsRUFBRSxDQUFDclksQ0FBZjtBQUNBcVksUUFBQUEsRUFBRSxHQUFHQSxFQUFFLENBQUNzQixLQUFSO0FBQ0Q7O0FBRUR3TyxNQUFBQSxRQUFRLElBQUlBLFFBQVEsQ0FBQ3R2QixNQUFULENBQWdCeXRCLFNBQVMsR0FBRyxDQUFaLEdBQWdCQSxTQUFoQixHQUE0QixDQUFDcGxCLElBQUQsSUFBU213QyxNQUFULEdBQWtCLENBQUN4VCxRQUFuQixHQUE4QjFWLFFBQVEsQ0FBQzBhLElBQVQsR0FBZ0IxYSxRQUFRLENBQUNvcEIsS0FBVCxDQUFlcndDLElBQUksR0FBRyxLQUFLMmhDLElBQTNCLENBQTFGLEVBQTRIL3BDLGNBQTVILEVBQTRJOUgsS0FBNUksQ0FBWixJQUFrSyxLQUFLczBDLFFBQUwsS0FBa0IsS0FBS3JCLE1BQUwsR0FBYzNkLFNBQWhDLENBQWxLOztBQUVBLFVBQUksS0FBS2lmLFNBQUwsSUFBa0IsQ0FBQ3pzQyxjQUF2QixFQUF1QztBQUNyQ3d0QixRQUFBQSxTQUFTLEdBQUcsQ0FBWixJQUFpQixLQUFLZ2YsUUFBdEIsSUFBa0MsS0FBS0EsUUFBTCxDQUFjenNDLE1BQWQsQ0FBcUJ5dEIsU0FBckIsRUFBZ0MsSUFBaEMsRUFBc0N0MUIsS0FBdEMsQ0FBbEMsQ0FEcUMsQ0FDMkM7O0FBRWhGcTFCLFFBQUFBLFNBQVMsQ0FBQyxJQUFELEVBQU8sVUFBUCxDQUFUO0FBQ0Q7O0FBRUQsV0FBSzZjLE9BQUwsSUFBZ0IrQixTQUFTLEtBQUtDLGFBQTlCLElBQStDLEtBQUsxNUMsSUFBTCxDQUFVK3BELFFBQXpELElBQXFFLENBQUN6OEMsY0FBdEUsSUFBd0YsS0FBS3pGLE1BQTdGLElBQXVHZ3pCLFNBQVMsQ0FBQyxJQUFELEVBQU8sVUFBUCxDQUFoSDs7QUFFQSxVQUFJLENBQUNnZCxLQUFLLEtBQUssS0FBS3BMLEtBQWYsSUFBd0IsQ0FBQ29MLEtBQTFCLEtBQW9DLEtBQUtyTCxNQUFMLEtBQWdCcUwsS0FBeEQsRUFBK0Q7QUFDN0QvYyxRQUFBQSxTQUFTLEdBQUcsQ0FBWixJQUFpQixLQUFLZ2YsUUFBdEIsSUFBa0MsQ0FBQyxLQUFLQyxTQUF4QyxJQUFxRCxLQUFLRCxRQUFMLENBQWN6c0MsTUFBZCxDQUFxQnl0QixTQUFyQixFQUFnQyxJQUFoQyxFQUFzQyxJQUF0QyxDQUFyRDtBQUNBLFNBQUNBLFNBQVMsSUFBSSxDQUFDd1csR0FBZixNQUF3QnVHLEtBQUssS0FBSyxLQUFLcEwsS0FBZixJQUF3QixLQUFLaUYsR0FBTCxHQUFXLENBQW5DLElBQXdDLENBQUNtRyxLQUFELElBQVUsS0FBS25HLEdBQUwsR0FBVyxDQUFyRixLQUEyRnFGLGlCQUFpQixDQUFDLElBQUQsRUFBTyxDQUFQLENBQTVHLENBRjZELENBRTBEOztBQUV2SCxZQUFJLENBQUN6cEMsY0FBRCxJQUFtQixFQUFFd3RCLFNBQVMsR0FBRyxDQUFaLElBQWlCLENBQUNvZixRQUFwQixDQUFuQixLQUFxRHJDLEtBQUssSUFBSXFDLFFBQTlELENBQUosRUFBNkU7QUFDM0U7QUFDQXJmLFVBQUFBLFNBQVMsQ0FBQyxJQUFELEVBQU9nZCxLQUFLLEtBQUsyUixJQUFWLEdBQWlCLFlBQWpCLEdBQWdDLG1CQUF2QyxFQUE0RCxJQUE1RCxDQUFUOztBQUVBLGVBQUt4UCxLQUFMLElBQWMsRUFBRW5DLEtBQUssR0FBRzJSLElBQVIsSUFBZ0IsS0FBSzNRLFNBQUwsS0FBbUIsQ0FBckMsQ0FBZCxJQUF5RCxLQUFLbUIsS0FBTCxFQUF6RDtBQUNEO0FBQ0Y7QUFDRjs7QUFFRCxXQUFPLElBQVA7QUFDRCxHQWxKRDs7QUFvSkEwVixFQUFBQSxPQUFPLENBQUN0M0MsT0FBUixHQUFrQixTQUFTQSxPQUFULEdBQW1CO0FBQ25DLFdBQU8sS0FBSzh5QyxRQUFaO0FBQ0QsR0FGRDs7QUFJQXdFLEVBQUFBLE9BQU8sQ0FBQ25sQixVQUFSLEdBQXFCLFNBQVNBLFVBQVQsR0FBc0I7QUFDekMsU0FBS3pkLEdBQUwsR0FBVyxLQUFLdWhDLEdBQUwsR0FBVyxLQUFLdlUsUUFBTCxHQUFnQixLQUFLQyxTQUFMLEdBQWlCLEtBQUt4RSxLQUFMLEdBQWEsS0FBS3YrQixLQUFMLEdBQWEsQ0FBakY7QUFDQSxTQUFLNHdDLFNBQUwsR0FBaUIsRUFBakI7QUFDQSxTQUFLanJCLFFBQUwsSUFBaUIsS0FBS0EsUUFBTCxDQUFjNE4sVUFBZCxFQUFqQjtBQUNBLFdBQU8ya0IsV0FBVyxDQUFDLzVELFNBQVosQ0FBc0JvMUMsVUFBdEIsQ0FBaUN4bkMsSUFBakMsQ0FBc0MsSUFBdEMsQ0FBUDtBQUNELEdBTEQ7O0FBT0Eyc0QsRUFBQUEsT0FBTyxDQUFDbmpCLE9BQVIsR0FBa0IsU0FBU0EsT0FBVCxDQUFpQmh1QyxRQUFqQixFQUEyQnJILEtBQTNCLEVBQWtDaWEsS0FBbEMsRUFBeUNzOUMsZUFBekMsRUFBMEQ7QUFDMUVyTCxJQUFBQSxhQUFhLElBQUlqSyxPQUFPLENBQUNtTCxJQUFSLEVBQWpCO0FBQ0EsU0FBSzVTLEdBQUwsSUFBWSxLQUFLM2dDLElBQUwsRUFBWjtBQUNBLFFBQUkyRSxJQUFJLEdBQUdqZSxJQUFJLENBQUNrSixHQUFMLENBQVMsS0FBSzAyQyxJQUFkLEVBQW9CLENBQUMsS0FBS2pMLEdBQUwsQ0FBU0MsS0FBVCxHQUFpQixLQUFLQyxNQUF2QixJQUFpQyxLQUFLb0YsR0FBMUQsQ0FBWDtBQUFBLFFBQ0kxNkIsS0FESjtBQUVBLFNBQUsyeEIsUUFBTCxJQUFpQnVRLFVBQVUsQ0FBQyxJQUFELEVBQU94akMsSUFBUCxDQUEzQjtBQUNBc0IsSUFBQUEsS0FBSyxHQUFHLEtBQUsrdUMsS0FBTCxDQUFXcndDLElBQUksR0FBRyxLQUFLMmhDLElBQXZCLENBQVIsQ0FOMEUsQ0FNcEM7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxRQUFJbVgsaUJBQWlCLENBQUMsSUFBRCxFQUFPandELFFBQVAsRUFBaUJySCxLQUFqQixFQUF3QmlhLEtBQXhCLEVBQStCczlDLGVBQS9CLEVBQWdEejNDLEtBQWhELEVBQXVEdEIsSUFBdkQsQ0FBckIsRUFBbUY7QUFDakYsYUFBTyxLQUFLNjJCLE9BQUwsQ0FBYWh1QyxRQUFiLEVBQXVCckgsS0FBdkIsRUFBOEJpYSxLQUE5QixFQUFxQ3M5QyxlQUFyQyxDQUFQLENBRGlGLENBQ25CO0FBQy9ELEtBbEJ5RSxDQWtCeEU7OztBQUdGcFcsSUFBQUEsY0FBYyxDQUFDLElBQUQsRUFBTyxDQUFQLENBQWQ7O0FBRUEsU0FBS3h3QyxNQUFMLElBQWUydUMsa0JBQWtCLENBQUMsS0FBS3BLLEdBQU4sRUFBVyxJQUFYLEVBQWlCLFFBQWpCLEVBQTJCLE9BQTNCLEVBQW9DLEtBQUtBLEdBQUwsQ0FBU3JULEtBQVQsR0FBaUIsUUFBakIsR0FBNEIsQ0FBaEUsQ0FBakM7QUFDQSxXQUFPLEtBQUsxckIsTUFBTCxDQUFZLENBQVosQ0FBUDtBQUNELEdBekJEOztBQTJCQXFpRCxFQUFBQSxPQUFPLENBQUM5OEMsSUFBUixHQUFlLFNBQVNBLElBQVQsQ0FBY3dGLE9BQWQsRUFBdUJwWSxJQUF2QixFQUE2QjtBQUMxQyxRQUFJQSxJQUFJLEtBQUssS0FBSyxDQUFsQixFQUFxQjtBQUNuQkEsTUFBQUEsSUFBSSxHQUFHLEtBQVA7QUFDRDs7QUFFRCxRQUFJLENBQUNvWSxPQUFELEtBQWEsQ0FBQ3BZLElBQUQsSUFBU0EsSUFBSSxLQUFLLEtBQS9CLENBQUosRUFBMkM7QUFDekMsV0FBS3UxQyxLQUFMLEdBQWEsS0FBS3pvQixHQUFMLEdBQVcsQ0FBeEI7QUFDQSxhQUFPLEtBQUtqbEIsTUFBTCxHQUFjazRDLFVBQVUsQ0FBQyxJQUFELENBQXhCLEdBQWlDLElBQXhDO0FBQ0Q7O0FBRUQsUUFBSSxLQUFLcGpCLFFBQVQsRUFBbUI7QUFDakIsVUFBSTZzQixJQUFJLEdBQUcsS0FBSzdzQixRQUFMLENBQWM0YSxhQUFkLEVBQVg7QUFDQSxXQUFLNWEsUUFBTCxDQUFjLzJCLFlBQWQsQ0FBMkJ3UyxPQUEzQixFQUFvQ3BZLElBQXBDLEVBQTBDK3FELGlCQUFpQixJQUFJQSxpQkFBaUIsQ0FBQy9xRCxJQUFsQixDQUF1QmpGLFNBQXZCLEtBQXFDLElBQXBHLEVBQTBHby9DLE1BQTFHLElBQW9INEYsVUFBVSxDQUFDLElBQUQsQ0FBOUgsQ0FGaUIsQ0FFcUg7O0FBRXRJLFdBQUtsNEMsTUFBTCxJQUFlMmhELElBQUksS0FBSyxLQUFLN3NCLFFBQUwsQ0FBYzRhLGFBQWQsRUFBeEIsSUFBeUQ4QyxZQUFZLENBQUMsSUFBRCxFQUFPLEtBQUtoRCxJQUFMLEdBQVksS0FBSzFhLFFBQUwsQ0FBYzhQLEtBQTFCLEdBQWtDK2MsSUFBekMsRUFBK0MsQ0FBL0MsRUFBa0QsQ0FBbEQsQ0FBckUsQ0FKaUIsQ0FJMEc7O0FBRTNILGFBQU8sSUFBUDtBQUNEOztBQUVELFFBQUl3QixhQUFhLEdBQUcsS0FBS0UsUUFBekI7QUFBQSxRQUNJeUUsY0FBYyxHQUFHdjNDLE9BQU8sR0FBR2pVLE9BQU8sQ0FBQ2lVLE9BQUQsQ0FBVixHQUFzQjR5QyxhQURsRDtBQUFBLFFBRUk0RSxlQUFlLEdBQUcsS0FBS2hJLFNBRjNCO0FBQUEsUUFHSWlJLE9BQU8sR0FBRyxLQUFLL2lDLEdBSG5CO0FBQUEsUUFJSWdqQyxnQkFKSjtBQUFBLFFBS0lDLFNBTEo7QUFBQSxRQU1JQyxpQkFOSjtBQUFBLFFBT0k3eUMsS0FQSjtBQUFBLFFBUUkxakIsQ0FSSjtBQUFBLFFBU0lvekIsRUFUSjtBQUFBLFFBVUkveUIsQ0FWSjs7QUFZQSxRQUFJLENBQUMsQ0FBQ2tHLElBQUQsSUFBU0EsSUFBSSxLQUFLLEtBQW5CLEtBQTZCcTJDLFlBQVksQ0FBQzJVLGFBQUQsRUFBZ0IyRSxjQUFoQixDQUE3QyxFQUE4RTtBQUM1RTN2RCxNQUFBQSxJQUFJLEtBQUssS0FBVCxLQUFtQixLQUFLOHNCLEdBQUwsR0FBVyxDQUE5QjtBQUNBLGFBQU9pekIsVUFBVSxDQUFDLElBQUQsQ0FBakI7QUFDRDs7QUFFRCtQLElBQUFBLGdCQUFnQixHQUFHLEtBQUt6QixHQUFMLEdBQVcsS0FBS0EsR0FBTCxJQUFZLEVBQTFDOztBQUVBLFFBQUlydUQsSUFBSSxLQUFLLEtBQWIsRUFBb0I7QUFDbEI7QUFDQSxVQUFJNFosU0FBUyxDQUFDNVosSUFBRCxDQUFiLEVBQXFCO0FBQ25CdkcsUUFBQUEsQ0FBQyxHQUFHLEVBQUo7O0FBRUFzN0MsUUFBQUEsWUFBWSxDQUFDLzBDLElBQUQsRUFBTyxVQUFVMGMsSUFBVixFQUFnQjtBQUNqQyxpQkFBT2pqQixDQUFDLENBQUNpakIsSUFBRCxDQUFELEdBQVUsQ0FBakI7QUFDRCxTQUZXLENBQVo7O0FBSUExYyxRQUFBQSxJQUFJLEdBQUd2RyxDQUFQO0FBQ0Q7O0FBRUR1RyxNQUFBQSxJQUFJLEdBQUcydUQsaUJBQWlCLENBQUMzRCxhQUFELEVBQWdCaHJELElBQWhCLENBQXhCO0FBQ0Q7O0FBRURsRyxJQUFBQSxDQUFDLEdBQUdreEQsYUFBYSxDQUFDanhELE1BQWxCOztBQUVBLFdBQU9ELENBQUMsRUFBUixFQUFZO0FBQ1YsVUFBSSxDQUFDNjFELGNBQWMsQ0FBQ3BvRCxPQUFmLENBQXVCeWpELGFBQWEsQ0FBQ2x4RCxDQUFELENBQXBDLENBQUwsRUFBK0M7QUFDN0NpMkQsUUFBQUEsU0FBUyxHQUFHSCxlQUFlLENBQUM5MUQsQ0FBRCxDQUEzQjs7QUFFQSxZQUFJa0csSUFBSSxLQUFLLEtBQWIsRUFBb0I7QUFDbEI4dkQsVUFBQUEsZ0JBQWdCLENBQUNoMkQsQ0FBRCxDQUFoQixHQUFzQmtHLElBQXRCO0FBQ0FtZCxVQUFBQSxLQUFLLEdBQUc0eUMsU0FBUjtBQUNBQyxVQUFBQSxpQkFBaUIsR0FBRyxFQUFwQjtBQUNELFNBSkQsTUFJTztBQUNMQSxVQUFBQSxpQkFBaUIsR0FBR0YsZ0JBQWdCLENBQUNoMkQsQ0FBRCxDQUFoQixHQUFzQmcyRCxnQkFBZ0IsQ0FBQ2gyRCxDQUFELENBQWhCLElBQXVCLEVBQWpFO0FBQ0FxakIsVUFBQUEsS0FBSyxHQUFHbmQsSUFBUjtBQUNEOztBQUVELGFBQUt2RyxDQUFMLElBQVUwakIsS0FBVixFQUFpQjtBQUNmMFAsVUFBQUEsRUFBRSxHQUFHa2pDLFNBQVMsSUFBSUEsU0FBUyxDQUFDdDJELENBQUQsQ0FBM0I7O0FBRUEsY0FBSW96QixFQUFKLEVBQVE7QUFDTixnQkFBSSxFQUFFLFVBQVVBLEVBQUUsQ0FBQ3JZLENBQWYsS0FBcUJxWSxFQUFFLENBQUNyWSxDQUFILENBQUs1QixJQUFMLENBQVVuWixDQUFWLE1BQWlCLElBQTFDLEVBQWdEO0FBQzlDcTlDLGNBQUFBLHFCQUFxQixDQUFDLElBQUQsRUFBT2pxQixFQUFQLEVBQVcsS0FBWCxDQUFyQjtBQUNEOztBQUVELG1CQUFPa2pDLFNBQVMsQ0FBQ3QyRCxDQUFELENBQWhCO0FBQ0Q7O0FBRUQsY0FBSXUyRCxpQkFBaUIsS0FBSyxLQUExQixFQUFpQztBQUMvQkEsWUFBQUEsaUJBQWlCLENBQUN2MkQsQ0FBRCxDQUFqQixHQUF1QixDQUF2QjtBQUNEO0FBQ0Y7QUFDRjtBQUNGOztBQUVELFNBQUtrdkMsUUFBTCxJQUFpQixDQUFDLEtBQUs3YixHQUF2QixJQUE4QitpQyxPQUE5QixJQUF5QzlQLFVBQVUsQ0FBQyxJQUFELENBQW5ELENBdEYwQyxDQXNGaUI7O0FBRTNELFdBQU8sSUFBUDtBQUNELEdBekZEOztBQTJGQXZFLEVBQUFBLEtBQUssQ0FBQzFnRCxFQUFOLEdBQVcsU0FBU0EsRUFBVCxDQUFZc2QsT0FBWixFQUFxQnBZLElBQXJCLEVBQTJCO0FBQ3BDLFdBQU8sSUFBSXc3QyxLQUFKLENBQVVwakMsT0FBVixFQUFtQnBZLElBQW5CLEVBQXlCeUYsU0FBUyxDQUFDLENBQUQsQ0FBbEMsQ0FBUDtBQUNELEdBRkQ7O0FBSUErMUMsRUFBQUEsS0FBSyxDQUFDM2tDLElBQU4sR0FBYSxTQUFTQSxJQUFULENBQWN1QixPQUFkLEVBQXVCcFksSUFBdkIsRUFBNkI7QUFDeEMsV0FBT2k3QyxnQkFBZ0IsQ0FBQyxDQUFELEVBQUl4MUMsU0FBSixDQUF2QjtBQUNELEdBRkQ7O0FBSUErMUMsRUFBQUEsS0FBSyxDQUFDM21DLFdBQU4sR0FBb0IsU0FBU0EsV0FBVCxDQUFxQjdaLEtBQXJCLEVBQTRCbUMsUUFBNUIsRUFBc0MrOUMsTUFBdEMsRUFBOEN6SCxLQUE5QyxFQUFxRDtBQUN2RSxXQUFPLElBQUkrSCxLQUFKLENBQVVyK0MsUUFBVixFQUFvQixDQUFwQixFQUF1QjtBQUM1QnlyQyxNQUFBQSxlQUFlLEVBQUUsS0FEVztBQUU1QmpsQyxNQUFBQSxJQUFJLEVBQUUsS0FGc0I7QUFHNUI1SSxNQUFBQSxTQUFTLEVBQUUsS0FIaUI7QUFJNUJDLE1BQUFBLEtBQUssRUFBRUEsS0FKcUI7QUFLNUJFLE1BQUFBLFVBQVUsRUFBRWlDLFFBTGdCO0FBTTVCOHlELE1BQUFBLGlCQUFpQixFQUFFOXlELFFBTlM7QUFPNUJrc0QsTUFBQUEsZ0JBQWdCLEVBQUVuTyxNQVBVO0FBUTVCZ1YsTUFBQUEsdUJBQXVCLEVBQUVoVixNQVJHO0FBUzVCNzZDLE1BQUFBLGFBQWEsRUFBRW96QztBQVRhLEtBQXZCLENBQVA7QUFXRCxHQVpEOztBQWNBK0gsRUFBQUEsS0FBSyxDQUFDc04sTUFBTixHQUFlLFNBQVNBLE1BQVQsQ0FBZ0Ixd0MsT0FBaEIsRUFBeUIyd0MsUUFBekIsRUFBbUNDLE1BQW5DLEVBQTJDO0FBQ3hELFdBQU8vTixnQkFBZ0IsQ0FBQyxDQUFELEVBQUl4MUMsU0FBSixDQUF2QjtBQUNELEdBRkQ7O0FBSUErMUMsRUFBQUEsS0FBSyxDQUFDOTNDLEdBQU4sR0FBWSxTQUFTQSxHQUFULENBQWEwVSxPQUFiLEVBQXNCcFksSUFBdEIsRUFBNEI7QUFDdENBLElBQUFBLElBQUksQ0FBQy9FLFFBQUwsR0FBZ0IsQ0FBaEI7QUFDQStFLElBQUFBLElBQUksQ0FBQ3c1QyxXQUFMLEtBQXFCeDVDLElBQUksQ0FBQ3c2QyxNQUFMLEdBQWMsQ0FBbkM7QUFDQSxXQUFPLElBQUlnQixLQUFKLENBQVVwakMsT0FBVixFQUFtQnBZLElBQW5CLENBQVA7QUFDRCxHQUpEOztBQU1BdzdDLEVBQUFBLEtBQUssQ0FBQzUxQyxZQUFOLEdBQXFCLFNBQVNBLFlBQVQsQ0FBc0J3UyxPQUF0QixFQUErQitFLEtBQS9CLEVBQXNDMHRDLFVBQXRDLEVBQWtEO0FBQ3JFLFdBQU96WCxlQUFlLENBQUN4dEMsWUFBaEIsQ0FBNkJ3UyxPQUE3QixFQUFzQytFLEtBQXRDLEVBQTZDMHRDLFVBQTdDLENBQVA7QUFDRCxHQUZEOztBQUlBLFNBQU9yUCxLQUFQO0FBQ0QsQ0EzZCtCLENBMmQ5QitMLFNBM2Q4QixDQUF6Qjs7QUE2ZFBuc0QsWUFBWSxDQUFDb2dELEtBQUssQ0FBQ3JtRCxTQUFQLEVBQWtCO0FBQzVCKzFELEVBQUFBLFFBQVEsRUFBRSxFQURrQjtBQUU1QjNWLEVBQUFBLEtBQUssRUFBRSxDQUZxQjtBQUc1QnVFLEVBQUFBLFFBQVEsRUFBRSxDQUhrQjtBQUk1QnVVLEVBQUFBLEdBQUcsRUFBRSxDQUp1QjtBQUs1QkUsRUFBQUEsT0FBTyxFQUFFO0FBTG1CLENBQWxCLENBQVosRUFNSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQXhaLFlBQVksQ0FBQyxxQ0FBRCxFQUF3QyxVQUFVcjRCLElBQVYsRUFBZ0I7QUFDbEU4K0IsRUFBQUEsS0FBSyxDQUFDOStCLElBQUQsQ0FBTCxHQUFjLFlBQVk7QUFDeEIsUUFBSWtMLEVBQUUsR0FBRyxJQUFJOHlCLFFBQUosRUFBVDtBQUFBLFFBQ0lRLE1BQU0sR0FBR1MsTUFBTSxDQUFDNTRDLElBQVAsQ0FBWTBDLFNBQVosRUFBdUIsQ0FBdkIsQ0FEYjs7QUFHQXkxQyxJQUFBQSxNQUFNLENBQUNyZ0QsTUFBUCxDQUFjNmhCLElBQUksS0FBSyxlQUFULEdBQTJCLENBQTNCLEdBQStCLENBQTdDLEVBQWdELENBQWhELEVBQW1ELENBQW5EO0FBQ0EsV0FBT2tMLEVBQUUsQ0FBQ2xMLElBQUQsQ0FBRixDQUFTdGMsS0FBVCxDQUFld25CLEVBQWYsRUFBbUJzekIsTUFBbkIsQ0FBUDtBQUNELEdBTkQ7QUFPRCxDQVJXLENBQVo7QUFTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQSxJQUFJNlIsWUFBWSxHQUFHLFNBQVNBLFlBQVQsQ0FBc0J4d0QsTUFBdEIsRUFBOEJnQyxRQUE5QixFQUF3Q3JILEtBQXhDLEVBQStDO0FBQ2hFLFNBQU9xRixNQUFNLENBQUNnQyxRQUFELENBQU4sR0FBbUJySCxLQUExQjtBQUNELENBRkQ7QUFBQSxJQUdJKzFELFdBQVcsR0FBRyxTQUFTQSxXQUFULENBQXFCMXdELE1BQXJCLEVBQTZCZ0MsUUFBN0IsRUFBdUNySCxLQUF2QyxFQUE4QztBQUM5RCxTQUFPcUYsTUFBTSxDQUFDZ0MsUUFBRCxDQUFOLENBQWlCckgsS0FBakIsQ0FBUDtBQUNELENBTEQ7QUFBQSxJQU1JODFELG9CQUFvQixHQUFHLFNBQVNBLG9CQUFULENBQThCendELE1BQTlCLEVBQXNDZ0MsUUFBdEMsRUFBZ0RySCxLQUFoRCxFQUF1RGlFLElBQXZELEVBQTZEO0FBQ3RGLFNBQU9vQixNQUFNLENBQUNnQyxRQUFELENBQU4sQ0FBaUJwRCxJQUFJLENBQUMweEQsRUFBdEIsRUFBMEIzMUQsS0FBMUIsQ0FBUDtBQUNELENBUkQ7QUFBQSxJQVNJaTVELGdCQUFnQixHQUFHLFNBQVNBLGdCQUFULENBQTBCNXpELE1BQTFCLEVBQWtDZ0MsUUFBbEMsRUFBNENySCxLQUE1QyxFQUFtRDtBQUN4RSxTQUFPcUYsTUFBTSxDQUFDdWlCLFlBQVAsQ0FBb0J2Z0IsUUFBcEIsRUFBOEJySCxLQUE5QixDQUFQO0FBQ0QsQ0FYRDtBQUFBLElBWUl3cEQsVUFBVSxHQUFHLFNBQVNBLFVBQVQsQ0FBb0Jua0QsTUFBcEIsRUFBNEJnQyxRQUE1QixFQUFzQztBQUNyRCxTQUFPdEgsV0FBVyxDQUFDc0YsTUFBTSxDQUFDZ0MsUUFBRCxDQUFQLENBQVgsR0FBZ0MwdUQsV0FBaEMsR0FBOEM3MUQsWUFBWSxDQUFDbUYsTUFBTSxDQUFDZ0MsUUFBRCxDQUFQLENBQVosSUFBa0NoQyxNQUFNLENBQUN1aUIsWUFBekMsR0FBd0RxeEMsZ0JBQXhELEdBQTJFcEQsWUFBaEk7QUFDRCxDQWREO0FBQUEsSUFlSUssWUFBWSxHQUFHLFNBQVNBLFlBQVQsQ0FBc0JwMkMsS0FBdEIsRUFBNkI3YixJQUE3QixFQUFtQztBQUNwRCxTQUFPQSxJQUFJLENBQUN1SSxHQUFMLENBQVN2SSxJQUFJLENBQUNvZixDQUFkLEVBQWlCcGYsSUFBSSxDQUFDMUIsQ0FBdEIsRUFBeUJoQyxJQUFJLENBQUNDLEtBQUwsQ0FBVyxDQUFDeUQsSUFBSSxDQUFDc2tCLENBQUwsR0FBU3RrQixJQUFJLENBQUNtWixDQUFMLEdBQVMwQyxLQUFuQixJQUE0QixPQUF2QyxJQUFrRCxPQUEzRSxFQUFvRjdiLElBQXBGLENBQVA7QUFDRCxDQWpCRDtBQUFBLElBa0JJZ3lELGNBQWMsR0FBRyxTQUFTQSxjQUFULENBQXdCbjJDLEtBQXhCLEVBQStCN2IsSUFBL0IsRUFBcUM7QUFDeEQsU0FBT0EsSUFBSSxDQUFDdUksR0FBTCxDQUFTdkksSUFBSSxDQUFDb2YsQ0FBZCxFQUFpQnBmLElBQUksQ0FBQzFCLENBQXRCLEVBQXlCLENBQUMsRUFBRTBCLElBQUksQ0FBQ3NrQixDQUFMLEdBQVN0a0IsSUFBSSxDQUFDbVosQ0FBTCxHQUFTMEMsS0FBcEIsQ0FBMUIsRUFBc0Q3YixJQUF0RCxDQUFQO0FBQ0QsQ0FwQkQ7QUFBQSxJQXFCSW14RCxvQkFBb0IsR0FBRyxTQUFTQSxvQkFBVCxDQUE4QnQxQyxLQUE5QixFQUFxQzdiLElBQXJDLEVBQTJDO0FBQ3BFLE1BQUkweEIsRUFBRSxHQUFHMXhCLElBQUksQ0FBQzJ4QixHQUFkO0FBQUEsTUFDSXJOLENBQUMsR0FBRyxFQURSOztBQUdBLE1BQUksQ0FBQ3pJLEtBQUQsSUFBVTdiLElBQUksQ0FBQ29aLENBQW5CLEVBQXNCO0FBQ3BCO0FBQ0FrTCxJQUFBQSxDQUFDLEdBQUd0a0IsSUFBSSxDQUFDb1osQ0FBVDtBQUNELEdBSEQsTUFHTyxJQUFJeUMsS0FBSyxLQUFLLENBQVYsSUFBZTdiLElBQUksQ0FBQ2xELENBQXhCLEVBQTJCO0FBQ2hDO0FBQ0F3bkIsSUFBQUEsQ0FBQyxHQUFHdGtCLElBQUksQ0FBQ2xELENBQVQ7QUFDRCxHQUhNLE1BR0E7QUFDTCxXQUFPNDBCLEVBQVAsRUFBVztBQUNUcE4sTUFBQUEsQ0FBQyxHQUFHb04sRUFBRSxDQUFDcHpCLENBQUgsSUFBUW96QixFQUFFLENBQUN0VixDQUFILEdBQU9zVixFQUFFLENBQUN0VixDQUFILENBQUtzVixFQUFFLENBQUNwTixDQUFILEdBQU9vTixFQUFFLENBQUN2WSxDQUFILEdBQU8wQyxLQUFuQixDQUFQLEdBQW1DdmYsSUFBSSxDQUFDQyxLQUFMLENBQVcsQ0FBQ20xQixFQUFFLENBQUNwTixDQUFILEdBQU9vTixFQUFFLENBQUN2WSxDQUFILEdBQU8wQyxLQUFmLElBQXdCLEtBQW5DLElBQTRDLEtBQXZGLElBQWdHeUksQ0FBcEcsQ0FEUyxDQUM4Rjs7QUFFdkdvTixNQUFBQSxFQUFFLEdBQUdBLEVBQUUsQ0FBQ3NCLEtBQVI7QUFDRDs7QUFFRDFPLElBQUFBLENBQUMsSUFBSXRrQixJQUFJLENBQUNtWixDQUFWLENBUEssQ0FPUTtBQUNkOztBQUVEblosRUFBQUEsSUFBSSxDQUFDdUksR0FBTCxDQUFTdkksSUFBSSxDQUFDb2YsQ0FBZCxFQUFpQnBmLElBQUksQ0FBQzFCLENBQXRCLEVBQXlCZ21CLENBQXpCLEVBQTRCdGtCLElBQTVCO0FBQ0QsQ0ExQ0Q7QUFBQSxJQTJDSXNrRCxpQkFBaUIsR0FBRyxTQUFTQSxpQkFBVCxDQUEyQnpvQyxLQUEzQixFQUFrQzdiLElBQWxDLEVBQXdDO0FBQzlELE1BQUkweEIsRUFBRSxHQUFHMXhCLElBQUksQ0FBQzJ4QixHQUFkOztBQUVBLFNBQU9ELEVBQVAsRUFBVztBQUNUQSxJQUFBQSxFQUFFLENBQUNudEIsQ0FBSCxDQUFLc1gsS0FBTCxFQUFZNlYsRUFBRSxDQUFDclksQ0FBZjtBQUNBcVksSUFBQUEsRUFBRSxHQUFHQSxFQUFFLENBQUNzQixLQUFSO0FBQ0Q7QUFDRixDQWxERDtBQUFBLElBbURJbXlCLGtCQUFrQixHQUFHLFNBQVNBLGtCQUFULENBQTRCRCxRQUE1QixFQUFzQ3J3QyxLQUF0QyxFQUE2Q3pULE1BQTdDLEVBQXFEZ0MsUUFBckQsRUFBK0Q7QUFDdEYsTUFBSXN1QixFQUFFLEdBQUcsS0FBS0MsR0FBZDtBQUFBLE1BQ0lxZCxJQURKOztBQUdBLFNBQU90ZCxFQUFQLEVBQVc7QUFDVHNkLElBQUFBLElBQUksR0FBR3RkLEVBQUUsQ0FBQ3NCLEtBQVY7QUFDQXRCLElBQUFBLEVBQUUsQ0FBQ3B6QixDQUFILEtBQVM4RSxRQUFULElBQXFCc3VCLEVBQUUsQ0FBQ3d6QixRQUFILENBQVlBLFFBQVosRUFBc0Jyd0MsS0FBdEIsRUFBNkJ6VCxNQUE3QixDQUFyQjtBQUNBc3dCLElBQUFBLEVBQUUsR0FBR3NkLElBQUw7QUFDRDtBQUNGLENBNUREO0FBQUEsSUE2RElpVyxpQkFBaUIsR0FBRyxTQUFTQSxpQkFBVCxDQUEyQjdoRCxRQUEzQixFQUFxQztBQUMzRCxNQUFJc3VCLEVBQUUsR0FBRyxLQUFLQyxHQUFkO0FBQUEsTUFDSXNqQyx3QkFESjtBQUFBLE1BRUlqbUIsSUFGSjs7QUFJQSxTQUFPdGQsRUFBUCxFQUFXO0FBQ1RzZCxJQUFBQSxJQUFJLEdBQUd0ZCxFQUFFLENBQUNzQixLQUFWOztBQUVBLFFBQUl0QixFQUFFLENBQUNwekIsQ0FBSCxLQUFTOEUsUUFBVCxJQUFxQixDQUFDc3VCLEVBQUUsQ0FBQzRFLEVBQXpCLElBQStCNUUsRUFBRSxDQUFDNEUsRUFBSCxLQUFVbHpCLFFBQTdDLEVBQXVEO0FBQ3JEdTRDLE1BQUFBLHFCQUFxQixDQUFDLElBQUQsRUFBT2pxQixFQUFQLEVBQVcsS0FBWCxDQUFyQjtBQUNELEtBRkQsTUFFTyxJQUFJLENBQUNBLEVBQUUsQ0FBQ3dqQyxHQUFSLEVBQWE7QUFDbEJELE1BQUFBLHdCQUF3QixHQUFHLENBQTNCO0FBQ0Q7O0FBRUR2akMsSUFBQUEsRUFBRSxHQUFHc2QsSUFBTDtBQUNEOztBQUVELFNBQU8sQ0FBQ2ltQix3QkFBUjtBQUNELENBL0VEO0FBQUEsSUFnRklFLG1CQUFtQixHQUFHLFNBQVNBLG1CQUFULENBQTZCL3pELE1BQTdCLEVBQXFDZ0MsUUFBckMsRUFBK0NySCxLQUEvQyxFQUFzRGlFLElBQXRELEVBQTREO0FBQ3BGQSxFQUFBQSxJQUFJLENBQUNvMUQsSUFBTCxDQUFVaDBELE1BQVYsRUFBa0JnQyxRQUFsQixFQUE0QnBELElBQUksQ0FBQ29jLENBQUwsQ0FBT3hVLElBQVAsQ0FBWTVILElBQUksQ0FBQzZVLEtBQWpCLEVBQXdCOVksS0FBeEIsRUFBK0JpRSxJQUFJLENBQUNxMUQsRUFBcEMsQ0FBNUIsRUFBcUVyMUQsSUFBckU7QUFDRCxDQWxGRDtBQUFBLElBbUZJbXpELHlCQUF5QixHQUFHLFNBQVNBLHlCQUFULENBQW1Dem1ELE1BQW5DLEVBQTJDO0FBQ3pFLE1BQUlnbEIsRUFBRSxHQUFHaGxCLE1BQU0sQ0FBQ2lsQixHQUFoQjtBQUFBLE1BQ0lxZCxJQURKO0FBQUEsTUFFSXNtQixHQUZKO0FBQUEsTUFHSWxvQyxLQUhKO0FBQUEsTUFJSUMsSUFKSixDQUR5RSxDQUsvRDs7QUFFVixTQUFPcUUsRUFBUCxFQUFXO0FBQ1RzZCxJQUFBQSxJQUFJLEdBQUd0ZCxFQUFFLENBQUNzQixLQUFWO0FBQ0FzaUMsSUFBQUEsR0FBRyxHQUFHbG9DLEtBQU47O0FBRUEsV0FBT2tvQyxHQUFHLElBQUlBLEdBQUcsQ0FBQ0MsRUFBSixHQUFTN2pDLEVBQUUsQ0FBQzZqQyxFQUExQixFQUE4QjtBQUM1QkQsTUFBQUEsR0FBRyxHQUFHQSxHQUFHLENBQUN0aUMsS0FBVjtBQUNEOztBQUVELFFBQUl0QixFQUFFLENBQUNncUIsS0FBSCxHQUFXNFosR0FBRyxHQUFHQSxHQUFHLENBQUM1WixLQUFQLEdBQWVydUIsSUFBakMsRUFBdUM7QUFDckNxRSxNQUFBQSxFQUFFLENBQUNncUIsS0FBSCxDQUFTMW9CLEtBQVQsR0FBaUJ0QixFQUFqQjtBQUNELEtBRkQsTUFFTztBQUNMdEUsTUFBQUEsS0FBSyxHQUFHc0UsRUFBUjtBQUNEOztBQUVELFFBQUlBLEVBQUUsQ0FBQ3NCLEtBQUgsR0FBV3NpQyxHQUFmLEVBQW9CO0FBQ2xCQSxNQUFBQSxHQUFHLENBQUM1WixLQUFKLEdBQVlocUIsRUFBWjtBQUNELEtBRkQsTUFFTztBQUNMckUsTUFBQUEsSUFBSSxHQUFHcUUsRUFBUDtBQUNEOztBQUVEQSxJQUFBQSxFQUFFLEdBQUdzZCxJQUFMO0FBQ0Q7O0FBRUR0aUMsRUFBQUEsTUFBTSxDQUFDaWxCLEdBQVAsR0FBYXZFLEtBQWI7QUFDRCxDQWxIRCxFQWtIRzs7O0FBR0ksSUFBSXlCLFNBQVMsR0FBRyxhQUFhLFlBQVk7QUFDOUMsV0FBU0EsU0FBVCxDQUFtQm1nQixJQUFuQixFQUF5QjV0QyxNQUF6QixFQUFpQyt0QixJQUFqQyxFQUF1Q25aLEtBQXZDLEVBQThDMjFCLE1BQTlDLEVBQXNENnBCLFFBQXRELEVBQWdFeDFELElBQWhFLEVBQXNFZ3hELE1BQXRFLEVBQThFc0IsUUFBOUUsRUFBd0Y7QUFDdEYsU0FBS2x6QyxDQUFMLEdBQVNoZSxNQUFUO0FBQ0EsU0FBS2tqQixDQUFMLEdBQVN0TyxLQUFUO0FBQ0EsU0FBS21ELENBQUwsR0FBU3d5QixNQUFUO0FBQ0EsU0FBS3J0QyxDQUFMLEdBQVM2d0IsSUFBVDtBQUNBLFNBQUs1cUIsQ0FBTCxHQUFTaXhELFFBQVEsSUFBSXZELFlBQXJCO0FBQ0EsU0FBSzU0QyxDQUFMLEdBQVNyWixJQUFJLElBQUksSUFBakI7QUFDQSxTQUFLdUksR0FBTCxHQUFXeW9ELE1BQU0sSUFBSVksWUFBckI7QUFDQSxTQUFLMkQsRUFBTCxHQUFVakQsUUFBUSxJQUFJLENBQXRCO0FBQ0EsU0FBS3QvQixLQUFMLEdBQWFnYyxJQUFiOztBQUVBLFFBQUlBLElBQUosRUFBVTtBQUNSQSxNQUFBQSxJQUFJLENBQUMwTSxLQUFMLEdBQWEsSUFBYjtBQUNEO0FBQ0Y7O0FBRUQsTUFBSStaLE9BQU8sR0FBRzVtQyxTQUFTLENBQUM3MEIsU0FBeEI7O0FBRUF5N0QsRUFBQUEsT0FBTyxDQUFDdlEsUUFBUixHQUFtQixTQUFTQSxRQUFULENBQWtCaG1ELElBQWxCLEVBQXdCMlYsS0FBeEIsRUFBK0J6VCxNQUEvQixFQUF1QztBQUN4RCxTQUFLZzBELElBQUwsR0FBWSxLQUFLQSxJQUFMLElBQWEsS0FBSzdzRCxHQUE5QixDQUR3RCxDQUNyQjs7QUFFbkMsU0FBS0EsR0FBTCxHQUFXNHNELG1CQUFYO0FBQ0EsU0FBSy80QyxDQUFMLEdBQVNsZCxJQUFUO0FBQ0EsU0FBS20yRCxFQUFMLEdBQVVqMEQsTUFBVixDQUx3RCxDQUt0Qzs7QUFFbEIsU0FBS3lULEtBQUwsR0FBYUEsS0FBYjtBQUNELEdBUkQ7O0FBVUEsU0FBT2dhLFNBQVA7QUFDRCxDQTlCbUMsRUFBN0IsRUE4QkY7O0FBRUwrcUIsWUFBWSxDQUFDUCxjQUFjLEdBQUcscU9BQWxCLEVBQXlQLFVBQVU5M0IsSUFBVixFQUFnQjtBQUNuUixTQUFPczNCLGNBQWMsQ0FBQ3QzQixJQUFELENBQWQsR0FBdUIsQ0FBOUI7QUFDRCxDQUZXLENBQVo7O0FBSUEyMkIsUUFBUSxDQUFDd2QsUUFBVCxHQUFvQnhkLFFBQVEsQ0FBQ3lkLFNBQVQsR0FBcUJ0VixLQUF6QztBQUNBbkksUUFBUSxDQUFDMGQsWUFBVCxHQUF3QjFkLFFBQVEsQ0FBQzJkLFdBQVQsR0FBdUJ0VyxRQUEvQztBQUNBdEgsZUFBZSxHQUFHLElBQUlzSCxRQUFKLENBQWE7QUFDN0JrTyxFQUFBQSxZQUFZLEVBQUUsS0FEZTtBQUU3Qmp2RCxFQUFBQSxRQUFRLEVBQUVta0MsU0FGbUI7QUFHN0JtWixFQUFBQSxrQkFBa0IsRUFBRSxJQUhTO0FBSTdCdi9CLEVBQUFBLEVBQUUsRUFBRSxNQUp5QjtBQUs3QjRnQyxFQUFBQSxpQkFBaUIsRUFBRTtBQUxVLENBQWIsQ0FBbEI7QUFPQXBHLE9BQU8sQ0FBQ2thLFlBQVIsR0FBdUJuSixrQkFBdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLElBQUloNEMsS0FBSyxHQUFHO0FBQ1ZqVSxFQUFBQSxjQUFjLEVBQUUsU0FBU0EsY0FBVCxHQUEwQjtBQUN4QyxTQUFLLElBQUlpNkQsS0FBSyxHQUFHeHJELFNBQVMsQ0FBQzFMLE1BQXRCLEVBQThCbTNELElBQUksR0FBRyxJQUFJdDVELEtBQUosQ0FBVXE1RCxLQUFWLENBQXJDLEVBQXVERSxLQUFLLEdBQUcsQ0FBcEUsRUFBdUVBLEtBQUssR0FBR0YsS0FBL0UsRUFBc0ZFLEtBQUssRUFBM0YsRUFBK0Y7QUFDN0ZELE1BQUFBLElBQUksQ0FBQ0MsS0FBRCxDQUFKLEdBQWMxckQsU0FBUyxDQUFDMHJELEtBQUQsQ0FBdkI7QUFDRDs7QUFFREQsSUFBQUEsSUFBSSxDQUFDOTJELE9BQUwsQ0FBYSxVQUFVdTNCLE1BQVYsRUFBa0I7QUFDN0IsYUFBT3N1QixhQUFhLENBQUN0dUIsTUFBRCxDQUFwQjtBQUNELEtBRkQ7QUFHRCxHQVRTO0FBVVZnTCxFQUFBQSxRQUFRLEVBQUUsU0FBU0EsUUFBVCxDQUFrQjM4QixJQUFsQixFQUF3QjtBQUNoQyxXQUFPLElBQUkwNkMsUUFBSixDQUFhMTZDLElBQWIsQ0FBUDtBQUNELEdBWlM7QUFhVjhxRCxFQUFBQSxXQUFXLEVBQUUsU0FBU0EsV0FBVCxDQUFxQjF5QyxPQUFyQixFQUE4Qnl5QyxVQUE5QixFQUEwQztBQUNyRCxXQUFPelgsZUFBZSxDQUFDMFgsV0FBaEIsQ0FBNEIxeUMsT0FBNUIsRUFBcUN5eUMsVUFBckMsQ0FBUDtBQUNELEdBZlM7QUFnQlZsaEQsRUFBQUEsV0FBVyxFQUFFLFNBQVNBLFdBQVQsQ0FBcUJwTixNQUFyQixFQUE2QmdDLFFBQTdCLEVBQXVDK00sSUFBdkMsRUFBNkNtRCxPQUE3QyxFQUFzRDtBQUNqRW1MLElBQUFBLFNBQVMsQ0FBQ3JkLE1BQUQsQ0FBVCxLQUFzQkEsTUFBTSxHQUFHNEgsT0FBTyxDQUFDNUgsTUFBRCxDQUFQLENBQWdCLENBQWhCLENBQS9CLEVBRGlFLENBQ2I7O0FBRXBELFFBQUk2MEQsTUFBTSxHQUFHdmMsU0FBUyxDQUFDdDRDLE1BQU0sSUFBSSxFQUFYLENBQVQsQ0FBd0I4TCxHQUFyQztBQUFBLFFBQ0lncEQsTUFBTSxHQUFHL2xELElBQUksR0FBR3FrQixZQUFILEdBQWtCOGxCLGtCQURuQzs7QUFHQW5xQyxJQUFBQSxJQUFJLEtBQUssUUFBVCxLQUFzQkEsSUFBSSxHQUFHLEVBQTdCO0FBQ0EsV0FBTyxDQUFDL08sTUFBRCxHQUFVQSxNQUFWLEdBQW1CLENBQUNnQyxRQUFELEdBQVksVUFBVUEsUUFBVixFQUFvQitNLElBQXBCLEVBQTBCbUQsT0FBMUIsRUFBbUM7QUFDdkUsYUFBTzRpRCxNQUFNLENBQUMsQ0FBQ2pkLFFBQVEsQ0FBQzcxQyxRQUFELENBQVIsSUFBc0I2MUMsUUFBUSxDQUFDNzFDLFFBQUQsQ0FBUixDQUFtQjhKLEdBQXpDLElBQWdEK29ELE1BQWpELEVBQXlENzBELE1BQXpELEVBQWlFZ0MsUUFBakUsRUFBMkUrTSxJQUEzRSxFQUFpRm1ELE9BQWpGLENBQUQsQ0FBYjtBQUNELEtBRnlCLEdBRXRCNGlELE1BQU0sQ0FBQyxDQUFDamQsUUFBUSxDQUFDNzFDLFFBQUQsQ0FBUixJQUFzQjYxQyxRQUFRLENBQUM3MUMsUUFBRCxDQUFSLENBQW1COEosR0FBekMsSUFBZ0Qrb0QsTUFBakQsRUFBeUQ3MEQsTUFBekQsRUFBaUVnQyxRQUFqRSxFQUEyRStNLElBQTNFLEVBQWlGbUQsT0FBakYsQ0FBRCxDQUZWO0FBR0QsR0ExQlM7QUEyQlZxN0IsRUFBQUEsV0FBVyxFQUFFLFNBQVNBLFdBQVQsQ0FBcUJ2dEMsTUFBckIsRUFBNkJnQyxRQUE3QixFQUF1QytNLElBQXZDLEVBQTZDO0FBQ3hEL08sSUFBQUEsTUFBTSxHQUFHNEgsT0FBTyxDQUFDNUgsTUFBRCxDQUFoQjs7QUFFQSxRQUFJQSxNQUFNLENBQUN4QyxNQUFQLEdBQWdCLENBQXBCLEVBQXVCO0FBQ3JCLFVBQUl1M0QsT0FBTyxHQUFHLzBELE1BQU0sQ0FBQzhiLEdBQVAsQ0FBVyxVQUFVa0MsQ0FBVixFQUFhO0FBQ3BDLGVBQU83a0IsSUFBSSxDQUFDbzBDLFdBQUwsQ0FBaUJ2dkIsQ0FBakIsRUFBb0JoYyxRQUFwQixFQUE4QitNLElBQTlCLENBQVA7QUFDRCxPQUZhLENBQWQ7QUFBQSxVQUdJekksQ0FBQyxHQUFHeXVELE9BQU8sQ0FBQ3YzRCxNQUhoQjtBQUlBLGFBQU8sVUFBVTdDLEtBQVYsRUFBaUI7QUFDdEIsWUFBSTRDLENBQUMsR0FBRytJLENBQVI7O0FBRUEsZUFBTy9JLENBQUMsRUFBUixFQUFZO0FBQ1Z3M0QsVUFBQUEsT0FBTyxDQUFDeDNELENBQUQsQ0FBUCxDQUFXNUMsS0FBWDtBQUNEO0FBQ0YsT0FORDtBQU9EOztBQUVEcUYsSUFBQUEsTUFBTSxHQUFHQSxNQUFNLENBQUMsQ0FBRCxDQUFOLElBQWEsRUFBdEI7O0FBRUEsUUFBSTZ3QixNQUFNLEdBQUdnbkIsUUFBUSxDQUFDNzFDLFFBQUQsQ0FBckI7QUFBQSxRQUNJa3VCLEtBQUssR0FBR29vQixTQUFTLENBQUN0NEMsTUFBRCxDQURyQjtBQUFBLFFBRUk5QyxDQUFDLEdBQUdnekIsS0FBSyxDQUFDQyxPQUFOLElBQWlCLENBQUNELEtBQUssQ0FBQ0MsT0FBTixDQUFjRSxPQUFkLElBQXlCLEVBQTFCLEVBQThCcnVCLFFBQTlCLENBQWpCLElBQTREQSxRQUZwRTtBQUFBLFFBR0k7QUFDSjR0RCxJQUFBQSxNQUFNLEdBQUcvK0IsTUFBTSxHQUFHLFVBQVVsMkIsS0FBVixFQUFpQjtBQUNqQyxVQUFJdUMsQ0FBQyxHQUFHLElBQUkyekIsTUFBSixFQUFSO0FBQ0E0eUIsTUFBQUEsV0FBVyxDQUFDbHpCLEdBQVosR0FBa0IsQ0FBbEI7QUFDQXJ6QixNQUFBQSxDQUFDLENBQUM4ekIsSUFBRixDQUFPaHhCLE1BQVAsRUFBZStPLElBQUksR0FBR3BVLEtBQUssR0FBR29VLElBQVgsR0FBa0JwVSxLQUFyQyxFQUE0QzhvRCxXQUE1QyxFQUF5RCxDQUF6RCxFQUE0RCxDQUFDempELE1BQUQsQ0FBNUQ7QUFDQTlDLE1BQUFBLENBQUMsQ0FBQzRULE1BQUYsQ0FBUyxDQUFULEVBQVk1VCxDQUFaO0FBQ0F1bUQsTUFBQUEsV0FBVyxDQUFDbHpCLEdBQVosSUFBbUIyeUIsaUJBQWlCLENBQUMsQ0FBRCxFQUFJTyxXQUFKLENBQXBDO0FBQ0QsS0FOYyxHQU1YdnpCLEtBQUssQ0FBQy9vQixHQUFOLENBQVVuSCxNQUFWLEVBQWtCOUMsQ0FBbEIsQ0FWSjs7QUFZQSxXQUFPMnpCLE1BQU0sR0FBRysrQixNQUFILEdBQVksVUFBVWoxRCxLQUFWLEVBQWlCO0FBQ3hDLGFBQU9pMUQsTUFBTSxDQUFDNXZELE1BQUQsRUFBUzlDLENBQVQsRUFBWTZSLElBQUksR0FBR3BVLEtBQUssR0FBR29VLElBQVgsR0FBa0JwVSxLQUFsQyxFQUF5Q3UxQixLQUF6QyxFQUFnRCxDQUFoRCxDQUFiO0FBQ0QsS0FGRDtBQUdELEdBN0RTO0FBOERWOGtDLEVBQUFBLE9BQU8sRUFBRSxTQUFTQSxPQUFULENBQWlCaDFELE1BQWpCLEVBQXlCZ0MsUUFBekIsRUFBbUN5QixJQUFuQyxFQUF5QztBQUNoRCxRQUFJd3hELE9BQUo7O0FBRUEsUUFBSXhoRCxLQUFLLEdBQUd0YSxJQUFJLENBQUNvRixFQUFMLENBQVF5QixNQUFSLEVBQWdCbTNDLE1BQU0sRUFBRThkLE9BQU8sR0FBRyxFQUFWLEVBQWNBLE9BQU8sQ0FBQ2p6RCxRQUFELENBQVAsR0FBb0IsT0FBbEMsRUFBMkNpekQsT0FBTyxDQUFDOW9CLE1BQVIsR0FBaUIsSUFBNUQsRUFBa0U4b0IsT0FBcEUsR0FBOEV4eEQsSUFBSSxJQUFJLEVBQXRGLENBQXRCLENBQVo7QUFBQSxRQUNJM0YsSUFBSSxHQUFHLFNBQVNBLElBQVQsQ0FBY25ELEtBQWQsRUFBcUJpYSxLQUFyQixFQUE0QnM5QyxlQUE1QixFQUE2QztBQUN0RCxhQUFPeitDLEtBQUssQ0FBQ3U4QixPQUFOLENBQWNodUMsUUFBZCxFQUF3QnJILEtBQXhCLEVBQStCaWEsS0FBL0IsRUFBc0NzOUMsZUFBdEMsQ0FBUDtBQUNELEtBSEQ7O0FBS0FwMEQsSUFBQUEsSUFBSSxDQUFDMlYsS0FBTCxHQUFhQSxLQUFiO0FBQ0EsV0FBTzNWLElBQVA7QUFDRCxHQXhFUztBQXlFVnFYLEVBQUFBLFVBQVUsRUFBRSxTQUFTQSxVQUFULENBQW9CMEcsT0FBcEIsRUFBNkI7QUFDdkMsV0FBT2c3QixlQUFlLENBQUMwWCxXQUFoQixDQUE0QjF5QyxPQUE1QixFQUFxQyxJQUFyQyxFQUEyQ3JlLE1BQTNDLEdBQW9ELENBQTNEO0FBQ0QsR0EzRVM7QUE0RVZKLEVBQUFBLFFBQVEsRUFBRSxTQUFTQSxRQUFULENBQWtCekMsS0FBbEIsRUFBeUI7QUFDakNBLElBQUFBLEtBQUssSUFBSUEsS0FBSyxDQUFDc3hDLElBQWYsS0FBd0J0eEMsS0FBSyxDQUFDc3hDLElBQU4sR0FBYWtVLFVBQVUsQ0FBQ3hsRCxLQUFLLENBQUNzeEMsSUFBUCxFQUFhMUssU0FBUyxDQUFDMEssSUFBdkIsQ0FBL0M7QUFDQSxXQUFPdU4sVUFBVSxDQUFDalksU0FBRCxFQUFZNW1DLEtBQUssSUFBSSxFQUFyQixDQUFqQjtBQUNELEdBL0VTO0FBZ0ZWeTZCLEVBQUFBLE1BQU0sRUFBRSxTQUFTQSxNQUFULENBQWdCejZCLEtBQWhCLEVBQXVCO0FBQzdCLFdBQU82K0MsVUFBVSxDQUFDN0QsT0FBRCxFQUFVaDdDLEtBQUssSUFBSSxFQUFuQixDQUFqQjtBQUNELEdBbEZTO0FBbUZWdTZELEVBQUFBLGNBQWMsRUFBRSxTQUFTQSxjQUFULENBQXdCaDFCLEtBQXhCLEVBQStCO0FBQzdDLFFBQUkvZixJQUFJLEdBQUcrZixLQUFLLENBQUMvZixJQUFqQjtBQUFBLFFBQ0lnMUMsTUFBTSxHQUFHajFCLEtBQUssQ0FBQ2kxQixNQURuQjtBQUFBLFFBRUlscEQsT0FBTyxHQUFHaTBCLEtBQUssQ0FBQ2owQixPQUZwQjtBQUFBLFFBR0k3TyxRQUFRLEdBQUc4aUMsS0FBSyxDQUFDOWlDLFFBSHJCO0FBQUEsUUFJSWc0RCxjQUFjLEdBQUdsMUIsS0FBSyxDQUFDazFCLGNBSjNCO0FBS0EsS0FBQ25wRCxPQUFPLElBQUksRUFBWixFQUFnQk4sS0FBaEIsQ0FBc0IsR0FBdEIsRUFBMkI5TixPQUEzQixDQUFtQyxVQUFVdzNELFVBQVYsRUFBc0I7QUFDdkQsYUFBT0EsVUFBVSxJQUFJLENBQUN4ZCxRQUFRLENBQUN3ZCxVQUFELENBQXZCLElBQXVDLENBQUN2ZSxRQUFRLENBQUN1ZSxVQUFELENBQWhELElBQWdFaGUsS0FBSyxDQUFDbDNCLElBQUksR0FBRyxtQkFBUCxHQUE2QmsxQyxVQUE3QixHQUEwQyxVQUEzQyxDQUE1RTtBQUNELEtBRkQ7O0FBSUF2ZCxJQUFBQSxRQUFRLENBQUMzM0IsSUFBRCxDQUFSLEdBQWlCLFVBQVV0RSxPQUFWLEVBQW1CcFksSUFBbkIsRUFBeUI0bkIsRUFBekIsRUFBNkI7QUFDNUMsYUFBTzhwQyxNQUFNLENBQUN2dEQsT0FBTyxDQUFDaVUsT0FBRCxDQUFSLEVBQW1CaGQsWUFBWSxDQUFDNEUsSUFBSSxJQUFJLEVBQVQsRUFBYXJHLFFBQWIsQ0FBL0IsRUFBdURpdUIsRUFBdkQsQ0FBYjtBQUNELEtBRkQ7O0FBSUEsUUFBSStwQyxjQUFKLEVBQW9CO0FBQ2xCalgsTUFBQUEsUUFBUSxDQUFDdmxELFNBQVQsQ0FBbUJ1bkIsSUFBbkIsSUFBMkIsVUFBVXRFLE9BQVYsRUFBbUJwWSxJQUFuQixFQUF5QjhELFFBQXpCLEVBQW1DO0FBQzVELGVBQU8sS0FBS3JKLEdBQUwsQ0FBUzQ1QyxRQUFRLENBQUMzM0IsSUFBRCxDQUFSLENBQWV0RSxPQUFmLEVBQXdCamhCLFNBQVMsQ0FBQzZJLElBQUQsQ0FBVCxHQUFrQkEsSUFBbEIsR0FBeUIsQ0FBQzhELFFBQVEsR0FBRzlELElBQVosS0FBcUIsRUFBdEUsRUFBMEUsSUFBMUUsQ0FBVCxFQUEwRjhELFFBQTFGLENBQVA7QUFDRCxPQUZEO0FBR0Q7QUFDRixHQXRHUztBQXVHVit0RCxFQUFBQSxZQUFZLEVBQUUsU0FBU0EsWUFBVCxDQUFzQm4xQyxJQUF0QixFQUE0QjhyQixJQUE1QixFQUFrQztBQUM5Q3djLElBQUFBLFFBQVEsQ0FBQ3RvQyxJQUFELENBQVIsR0FBaUJnZ0MsVUFBVSxDQUFDbFUsSUFBRCxDQUEzQjtBQUNELEdBekdTO0FBMEdWc3BCLEVBQUFBLFNBQVMsRUFBRSxTQUFTQSxTQUFULENBQW1CdHBCLElBQW5CLEVBQXlCeWQsV0FBekIsRUFBc0M7QUFDL0MsV0FBT3hnRCxTQUFTLENBQUMxTCxNQUFWLEdBQW1CMmlELFVBQVUsQ0FBQ2xVLElBQUQsRUFBT3lkLFdBQVAsQ0FBN0IsR0FBbURqQixRQUExRDtBQUNELEdBNUdTO0FBNkdWM3NCLEVBQUFBLE9BQU8sRUFBRSxTQUFTQSxPQUFULENBQWlCM2dCLEVBQWpCLEVBQXFCO0FBQzVCLFdBQU8wN0IsZUFBZSxDQUFDL2EsT0FBaEIsQ0FBd0IzZ0IsRUFBeEIsQ0FBUDtBQUNELEdBL0dTO0FBZ0hWcTZDLEVBQUFBLFVBQVUsRUFBRSxTQUFTQSxVQUFULENBQW9CL3hELElBQXBCLEVBQTBCZ3lELG1CQUExQixFQUErQztBQUN6RCxRQUFJaHlELElBQUksS0FBSyxLQUFLLENBQWxCLEVBQXFCO0FBQ25CQSxNQUFBQSxJQUFJLEdBQUcsRUFBUDtBQUNEOztBQUVELFFBQUk0bkIsRUFBRSxHQUFHLElBQUk4eUIsUUFBSixDQUFhMTZDLElBQWIsQ0FBVDtBQUFBLFFBQ0kySCxLQURKO0FBQUEsUUFFSXdpQyxJQUZKO0FBR0F2aUIsSUFBQUEsRUFBRSxDQUFDMHdCLGlCQUFILEdBQXVCN0YsV0FBVyxDQUFDenlDLElBQUksQ0FBQ3M0QyxpQkFBTixDQUFsQzs7QUFFQWxGLElBQUFBLGVBQWUsQ0FBQ3o0QyxNQUFoQixDQUF1Qml0QixFQUF2Qjs7QUFFQUEsSUFBQUEsRUFBRSxDQUFDd2tCLEdBQUgsR0FBUyxDQUFULENBWnlELENBWTdDOztBQUVaeGtCLElBQUFBLEVBQUUsQ0FBQ3lrQixLQUFILEdBQVd6a0IsRUFBRSxDQUFDNGtCLE1BQUgsR0FBWTRHLGVBQWUsQ0FBQy9HLEtBQXZDO0FBQ0Exa0MsSUFBQUEsS0FBSyxHQUFHeXJDLGVBQWUsQ0FBQytHLE1BQXhCOztBQUVBLFdBQU94eUMsS0FBUCxFQUFjO0FBQ1p3aUMsTUFBQUEsSUFBSSxHQUFHeGlDLEtBQUssQ0FBQ3dtQixLQUFiOztBQUVBLFVBQUk2akMsbUJBQW1CLElBQUksRUFBRSxDQUFDcnFELEtBQUssQ0FBQzB2QyxJQUFQLElBQWUxdkMsS0FBSyxZQUFZNnpDLEtBQWhDLElBQXlDN3pDLEtBQUssQ0FBQzNILElBQU4sQ0FBVzlFLFVBQVgsS0FBMEJ5TSxLQUFLLENBQUN1akQsUUFBTixDQUFlLENBQWYsQ0FBckUsQ0FBM0IsRUFBb0g7QUFDbEh4UyxRQUFBQSxjQUFjLENBQUM5d0IsRUFBRCxFQUFLamdCLEtBQUwsRUFBWUEsS0FBSyxDQUFDMmtDLE1BQU4sR0FBZTNrQyxLQUFLLENBQUNpeEMsTUFBakMsQ0FBZDtBQUNEOztBQUVEanhDLE1BQUFBLEtBQUssR0FBR3dpQyxJQUFSO0FBQ0Q7O0FBRUR1TyxJQUFBQSxjQUFjLENBQUN0RixlQUFELEVBQWtCeHJCLEVBQWxCLEVBQXNCLENBQXRCLENBQWQ7O0FBRUEsV0FBT0EsRUFBUDtBQUNELEdBOUlTO0FBK0lWMWpCLEVBQUFBLEtBQUssRUFBRTtBQUNMc2IsSUFBQUEsSUFBSSxFQUFFQSxJQUREO0FBRUxnL0IsSUFBQUEsUUFBUSxFQUFFQSxRQUZMO0FBR0xoQyxJQUFBQSxVQUFVLEVBQUVBLFVBSFA7QUFJTEQsSUFBQUEsTUFBTSxFQUFFQSxNQUpIO0FBS0w3NUMsSUFBQUEsSUFBSSxFQUFFQSxJQUxEO0FBTUx5N0MsSUFBQUEsU0FBUyxFQUFFQSxTQU5OO0FBT0w3d0IsSUFBQUEsT0FBTyxFQUFFQSxPQVBKO0FBUUx5RixJQUFBQSxLQUFLLEVBQUVBLEtBUkY7QUFTTG12QixJQUFBQSxVQUFVLEVBQUVBLFVBVFA7QUFVTC85QyxJQUFBQSxPQUFPLEVBQUVBLE9BVko7QUFXTGs0QyxJQUFBQSxRQUFRLEVBQUVBLFFBWEw7QUFZTCtCLElBQUFBLFFBQVEsRUFBRUEsUUFaTDtBQWFMUCxJQUFBQSxJQUFJLEVBQUVBLElBYkQ7QUFjTEssSUFBQUEsT0FBTyxFQUFFQSxPQWRKO0FBZUxnQixJQUFBQSxXQUFXLEVBQUVBLFdBZlI7QUFnQkw1QyxJQUFBQSxPQUFPLEVBQUVBO0FBaEJKLEdBL0lHO0FBaUtWMlYsRUFBQUEsT0FBTyxFQUFFemUsUUFqS0M7QUFrS1YwZSxFQUFBQSxPQUFPLEVBQUU3ZCxRQWxLQztBQW1LVjc1QyxFQUFBQSxNQUFNLEVBQUUyK0MsT0FuS0U7QUFvS1Y4UyxFQUFBQSxVQUFVLEVBQUV2UixRQUFRLENBQUN1UixVQXBLWDtBQXFLVnpqRCxFQUFBQSxPQUFPLEVBQUU0ckMsUUFyS0M7QUFzS1YrZCxFQUFBQSxjQUFjLEVBQUUvZSxlQXRLTjtBQXVLVmxvQyxFQUFBQSxJQUFJLEVBQUU7QUFDSjhlLElBQUFBLFNBQVMsRUFBRUEsU0FEUDtBQUVKOEksSUFBQUEsT0FBTyxFQUFFaWhCLFVBRkw7QUFHSnlILElBQUFBLEtBQUssRUFBRUEsS0FISDtBQUlKZCxJQUFBQSxRQUFRLEVBQUVBLFFBSk47QUFLSjZNLElBQUFBLFNBQVMsRUFBRUEsU0FMUDtBQU1KcDhDLElBQUFBLFFBQVEsRUFBRTBwQyxTQU5OO0FBT0ppQyxJQUFBQSxxQkFBcUIsRUFBRUEscUJBUG5CO0FBUUpoSyxJQUFBQSxrQkFBa0IsRUFBRSxTQUFTQSxrQkFBVCxDQUE0QjUxQyxLQUE1QixFQUFtQztBQUNyRCxhQUFPOGhDLG1CQUFtQixHQUFHOWhDLEtBQTdCO0FBQ0Q7QUFWRztBQXZLSSxDQUFaOztBQXFMQTY5QyxZQUFZLENBQUMsNkNBQUQsRUFBZ0QsVUFBVXI0QixJQUFWLEVBQWdCO0FBQzFFLFNBQU96UixLQUFLLENBQUN5UixJQUFELENBQUwsR0FBYzgrQixLQUFLLENBQUM5K0IsSUFBRCxDQUExQjtBQUNELENBRlcsQ0FBWjs7QUFJQXk4QixPQUFPLENBQUMxK0MsR0FBUixDQUFZaWdELFFBQVEsQ0FBQ3VSLFVBQXJCOztBQUVBak0sV0FBVyxHQUFHLzBDLEtBQUssQ0FBQ25RLEVBQU4sQ0FBUyxFQUFULEVBQWE7QUFDekJHLEVBQUFBLFFBQVEsRUFBRTtBQURlLENBQWIsQ0FBZCxFQUVJOztBQUVKLElBQUltM0QsbUJBQW1CLEdBQUcsU0FBU0EsbUJBQVQsQ0FBNkIzbkMsTUFBN0IsRUFBcUNILElBQXJDLEVBQTJDO0FBQ25FLE1BQUl1QyxFQUFFLEdBQUdwQyxNQUFNLENBQUNxQyxHQUFoQjs7QUFFQSxTQUFPRCxFQUFFLElBQUlBLEVBQUUsQ0FBQ3B6QixDQUFILEtBQVM2d0IsSUFBZixJQUF1QnVDLEVBQUUsQ0FBQzRFLEVBQUgsS0FBVW5ILElBQWpDLElBQXlDdUMsRUFBRSxDQUFDZ2dDLEVBQUgsS0FBVXZpQyxJQUExRCxFQUFnRTtBQUM5RHVDLElBQUFBLEVBQUUsR0FBR0EsRUFBRSxDQUFDc0IsS0FBUjtBQUNEOztBQUVELFNBQU90QixFQUFQO0FBQ0QsQ0FSRDtBQUFBLElBU0l3bEMsYUFBYSxHQUFHLFNBQVNBLGFBQVQsQ0FBdUJyaUQsS0FBdkIsRUFBOEJ1MEIsU0FBOUIsRUFBeUM7QUFDM0QsTUFBSW5zQixPQUFPLEdBQUdwSSxLQUFLLENBQUNrN0MsUUFBcEI7QUFBQSxNQUNJenhELENBREo7QUFBQSxNQUVJSyxDQUZKO0FBQUEsTUFHSSt5QixFQUhKOztBQUtBLE9BQUtwekIsQ0FBTCxJQUFVOHFDLFNBQVYsRUFBcUI7QUFDbkJ6cUMsSUFBQUEsQ0FBQyxHQUFHc2UsT0FBTyxDQUFDcmUsTUFBWjs7QUFFQSxXQUFPRCxDQUFDLEVBQVIsRUFBWTtBQUNWK3lCLE1BQUFBLEVBQUUsR0FBRzdjLEtBQUssQ0FBQzQzQyxTQUFOLENBQWdCOXRELENBQWhCLEVBQW1CTCxDQUFuQixDQUFMOztBQUVBLFVBQUlvekIsRUFBRSxLQUFLQSxFQUFFLEdBQUdBLEVBQUUsQ0FBQ3JZLENBQWIsQ0FBTixFQUF1QjtBQUNyQixZQUFJcVksRUFBRSxDQUFDQyxHQUFQLEVBQVk7QUFDVjtBQUNBRCxVQUFBQSxFQUFFLEdBQUd1bEMsbUJBQW1CLENBQUN2bEMsRUFBRCxFQUFLcHpCLENBQUwsQ0FBeEI7QUFDRDs7QUFFRG96QixRQUFBQSxFQUFFLElBQUlBLEVBQUUsQ0FBQ3d6QixRQUFULElBQXFCeHpCLEVBQUUsQ0FBQ3d6QixRQUFILENBQVk5YixTQUFTLENBQUM5cUMsQ0FBRCxDQUFyQixFQUEwQnVXLEtBQTFCLEVBQWlDb0ksT0FBTyxDQUFDdGUsQ0FBRCxDQUF4QyxFQUE2Q0wsQ0FBN0MsQ0FBckI7QUFDRDtBQUNGO0FBQ0Y7QUFDRixDQS9CRDtBQUFBLElBZ0NJNjRELG9CQUFvQixHQUFHLFNBQVNBLG9CQUFULENBQThCNTFDLElBQTlCLEVBQW9DMmpDLFFBQXBDLEVBQThDO0FBQ3ZFLFNBQU87QUFDTDNqQyxJQUFBQSxJQUFJLEVBQUVBLElBREQ7QUFFTDZqQyxJQUFBQSxPQUFPLEVBQUUsQ0FGSjtBQUdMO0FBQ0FoekIsSUFBQUEsSUFBSSxFQUFFLFNBQVNBLElBQVQsQ0FBY2h4QixNQUFkLEVBQXNCeUQsSUFBdEIsRUFBNEJnUSxLQUE1QixFQUFtQztBQUN2Q0EsTUFBQUEsS0FBSyxDQUFDdStDLE9BQU4sR0FBZ0IsVUFBVXYrQyxLQUFWLEVBQWlCO0FBQy9CLFlBQUlxRSxJQUFKLEVBQVU1YSxDQUFWOztBQUVBLFlBQUltZ0IsU0FBUyxDQUFDNVosSUFBRCxDQUFiLEVBQXFCO0FBQ25CcVUsVUFBQUEsSUFBSSxHQUFHLEVBQVA7O0FBRUEwZ0MsVUFBQUEsWUFBWSxDQUFDLzBDLElBQUQsRUFBTyxVQUFVMGMsSUFBVixFQUFnQjtBQUNqQyxtQkFBT3JJLElBQUksQ0FBQ3FJLElBQUQsQ0FBSixHQUFhLENBQXBCO0FBQ0QsV0FGVyxDQUFaLENBSG1CLENBS2Y7OztBQUdKMWMsVUFBQUEsSUFBSSxHQUFHcVUsSUFBUDtBQUNEOztBQUVELFlBQUlnc0MsUUFBSixFQUFjO0FBQ1poc0MsVUFBQUEsSUFBSSxHQUFHLEVBQVA7O0FBRUEsZUFBSzVhLENBQUwsSUFBVXVHLElBQVYsRUFBZ0I7QUFDZHFVLFlBQUFBLElBQUksQ0FBQzVhLENBQUQsQ0FBSixHQUFVNG1ELFFBQVEsQ0FBQ3JnRCxJQUFJLENBQUN2RyxDQUFELENBQUwsQ0FBbEI7QUFDRDs7QUFFRHVHLFVBQUFBLElBQUksR0FBR3FVLElBQVA7QUFDRDs7QUFFRGcrQyxRQUFBQSxhQUFhLENBQUNyaUQsS0FBRCxFQUFRaFEsSUFBUixDQUFiO0FBQ0QsT0F6QkQ7QUEwQkQ7QUEvQkksR0FBUDtBQWlDRCxDQWxFRCxFQWtFRzs7O0FBR0ksSUFBSXRLLElBQUksR0FBR3VWLEtBQUssQ0FBQ2pVLGNBQU4sQ0FBcUI7QUFDckMwbEIsRUFBQUEsSUFBSSxFQUFFLE1BRCtCO0FBRXJDNlEsRUFBQUEsSUFBSSxFQUFFLFNBQVNBLElBQVQsQ0FBY2h4QixNQUFkLEVBQXNCeUQsSUFBdEIsRUFBNEJnUSxLQUE1QixFQUFtQzJMLEtBQW5DLEVBQTBDdkQsT0FBMUMsRUFBbUQ7QUFDdkQsUUFBSTNlLENBQUosRUFBT296QixFQUFQOztBQUVBLFNBQUtwekIsQ0FBTCxJQUFVdUcsSUFBVixFQUFnQjtBQUNkNnNCLE1BQUFBLEVBQUUsR0FBRyxLQUFLcHlCLEdBQUwsQ0FBUzhCLE1BQVQsRUFBaUIsY0FBakIsRUFBaUMsQ0FBQ0EsTUFBTSxDQUFDMkcsWUFBUCxDQUFvQnpKLENBQXBCLEtBQTBCLENBQTNCLElBQWdDLEVBQWpFLEVBQXFFdUcsSUFBSSxDQUFDdkcsQ0FBRCxDQUF6RSxFQUE4RWtpQixLQUE5RSxFQUFxRnZELE9BQXJGLEVBQThGLENBQTlGLEVBQWlHLENBQWpHLEVBQW9HM2UsQ0FBcEcsQ0FBTDtBQUNBb3pCLE1BQUFBLEVBQUUsS0FBS0EsRUFBRSxDQUFDNEUsRUFBSCxHQUFRaDRCLENBQWIsQ0FBRjs7QUFFQSxXQUFLd3pCLE1BQUwsQ0FBWTF5QixJQUFaLENBQWlCZCxDQUFqQjtBQUNEO0FBQ0Y7QUFYb0MsQ0FBckIsRUFZZjtBQUNEaWpCLEVBQUFBLElBQUksRUFBRSxVQURMO0FBRUQ2USxFQUFBQSxJQUFJLEVBQUUsU0FBU0EsSUFBVCxDQUFjaHhCLE1BQWQsRUFBc0JyRixLQUF0QixFQUE2QjtBQUNqQyxRQUFJNEMsQ0FBQyxHQUFHNUMsS0FBSyxDQUFDNkMsTUFBZDs7QUFFQSxXQUFPRCxDQUFDLEVBQVIsRUFBWTtBQUNWLFdBQUtXLEdBQUwsQ0FBUzhCLE1BQVQsRUFBaUJ6QyxDQUFqQixFQUFvQnlDLE1BQU0sQ0FBQ3pDLENBQUQsQ0FBTixJQUFhLENBQWpDLEVBQW9DNUMsS0FBSyxDQUFDNEMsQ0FBRCxDQUF6QztBQUNEO0FBQ0Y7QUFSQSxDQVplLEVBcUJmdzRELG9CQUFvQixDQUFDLFlBQUQsRUFBZS9VLGNBQWYsQ0FyQkwsRUFxQnFDK1Usb0JBQW9CLENBQUMsV0FBRCxDQXJCekQsRUFxQndFQSxvQkFBb0IsQ0FBQyxNQUFELEVBQVM1dkQsSUFBVCxDQXJCNUYsS0FxQitHdUksS0FyQjFILEVBcUJpSTs7QUFFeEl1d0MsS0FBSyxDQUFDNWlDLE9BQU4sR0FBZ0I4aEMsUUFBUSxDQUFDOWhDLE9BQVQsR0FBbUJsakIsSUFBSSxDQUFDa2pCLE9BQUwsR0FBZSxRQUFsRDtBQUNBMjZCLFVBQVUsR0FBRyxDQUFiO0FBQ0ExOEMsYUFBYSxNQUFNc2xELEtBQUssRUFBeEI7QUFDQSxJQUFJb1csTUFBTSxHQUFHdk4sUUFBUSxDQUFDdU4sTUFBdEI7QUFBQSxJQUNJQyxNQUFNLEdBQUd4TixRQUFRLENBQUN3TixNQUR0QjtBQUFBLElBRUlDLE1BQU0sR0FBR3pOLFFBQVEsQ0FBQ3lOLE1BRnRCO0FBQUEsSUFHSUMsTUFBTSxHQUFHMU4sUUFBUSxDQUFDME4sTUFIdEI7QUFBQSxJQUlJQyxNQUFNLEdBQUczTixRQUFRLENBQUMyTixNQUp0QjtBQUFBLElBS0k3TCxNQUFNLEdBQUc5QixRQUFRLENBQUM4QixNQUx0QjtBQUFBLElBTUk4TCxJQUFJLEdBQUc1TixRQUFRLENBQUM0TixJQU5wQjtBQUFBLElBT0lDLEtBQUssR0FBRzdOLFFBQVEsQ0FBQzZOLEtBUHJCO0FBQUEsSUFRSUMsS0FBSyxHQUFHOU4sUUFBUSxDQUFDOE4sS0FSckI7QUFBQSxJQVNJQyxLQUFLLEdBQUcvTixRQUFRLENBQUMrTixLQVRyQjtBQUFBLElBVUlDLE1BQU0sR0FBR2hPLFFBQVEsQ0FBQ2dPLE1BVnRCO0FBQUEsSUFXSUMsT0FBTyxHQUFHak8sUUFBUSxDQUFDaU8sT0FYdkI7QUFBQSxJQVlJQyxJQUFJLEdBQUdsTyxRQUFRLENBQUNrTyxJQVpwQjtBQUFBLElBYUk5TCxXQUFXLEdBQUdwQyxRQUFRLENBQUNvQyxXQWIzQjtBQUFBLElBY0krTCxNQUFNLEdBQUduTyxRQUFRLENBQUNtTyxNQWR0QjtBQUFBLElBZUlDLElBQUksR0FBR3BPLFFBQVEsQ0FBQ29PLElBZnBCO0FBQUEsSUFnQklDLElBQUksR0FBR3JPLFFBQVEsQ0FBQ3FPLElBaEJwQjtBQUFBLElBaUJJQyxJQUFJLEdBQUd0TyxRQUFRLENBQUNzTyxJQWpCcEI7QUFrQkE7Q0FDeVE7Ozs7OztBQzMvSHpRO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUdBLElBQUkzOUQsYUFBSjtBQUFBLElBQ0lDLGFBREo7QUFBQSxJQUVJQyxXQUZKO0FBQUEsSUFHSTA5RCxjQUhKO0FBQUEsSUFJSXg5RCxRQUpKO0FBQUEsSUFLSXk5RCxjQUxKO0FBQUEsSUFNSUMsbUJBTko7QUFBQSxJQU9JNThELHNCQUFhLEdBQUcsU0FBU0EsYUFBVCxHQUF5QjtBQUMzQyxTQUFPLE9BQU9DLE1BQVAsS0FBa0IsV0FBekI7QUFDRCxDQVREO0FBQUEsSUFVSTQ4RCxlQUFlLEdBQUcsRUFWdEI7QUFBQSxJQVdJcDdELFFBQVEsR0FBRyxNQUFNYixJQUFJLENBQUNjLEVBWDFCO0FBQUEsSUFZSTJnQixRQUFRLEdBQUd6aEIsSUFBSSxDQUFDYyxFQUFMLEdBQVUsR0FaekI7QUFBQSxJQWFJbWhCLE1BQU0sR0FBR2ppQixJQUFJLENBQUNvYSxLQWJsQjtBQUFBLElBY0lyWixnQkFBTyxHQUFHLEdBZGQ7QUFBQSxJQWVJb3FDLFFBQVEsR0FBRyxVQWZmO0FBQUEsSUFnQkkrd0IsY0FBYyxHQUFHLHNDQWhCckI7QUFBQSxJQWlCSUMsV0FBVyxHQUFHLFdBakJsQjtBQUFBLElBa0JJQyxnQkFBZ0IsR0FBRztBQUNyQkMsRUFBQUEsU0FBUyxFQUFFLG9CQURVO0FBRXJCejNCLEVBQUFBLEtBQUssRUFBRSxlQUZjO0FBR3JCMDNCLEVBQUFBLEtBQUssRUFBRTtBQUhjLENBbEJ2QjtBQUFBLElBdUJJQyxjQUFjLEdBQUcsU0FBU0EsY0FBVCxDQUF3Qmg5QyxLQUF4QixFQUErQjdiLElBQS9CLEVBQXFDO0FBQ3hELFNBQU9BLElBQUksQ0FBQ3VJLEdBQUwsQ0FBU3ZJLElBQUksQ0FBQ29mLENBQWQsRUFBaUJwZixJQUFJLENBQUMxQixDQUF0QixFQUF5QmhDLElBQUksQ0FBQ0MsS0FBTCxDQUFXLENBQUN5RCxJQUFJLENBQUNza0IsQ0FBTCxHQUFTdGtCLElBQUksQ0FBQ21aLENBQUwsR0FBUzBDLEtBQW5CLElBQTRCLEtBQXZDLElBQWdELEtBQWhELEdBQXdEN2IsSUFBSSxDQUFDNHhCLENBQXRGLEVBQXlGNXhCLElBQXpGLENBQVA7QUFDRCxDQXpCRDtBQUFBLElBMEJJODRELGtCQUFrQixHQUFHLFNBQVNBLGtCQUFULENBQTRCajlDLEtBQTVCLEVBQW1DN2IsSUFBbkMsRUFBeUM7QUFDaEUsU0FBT0EsSUFBSSxDQUFDdUksR0FBTCxDQUFTdkksSUFBSSxDQUFDb2YsQ0FBZCxFQUFpQnBmLElBQUksQ0FBQzFCLENBQXRCLEVBQXlCdWQsS0FBSyxLQUFLLENBQVYsR0FBYzdiLElBQUksQ0FBQ2xELENBQW5CLEdBQXVCUixJQUFJLENBQUNDLEtBQUwsQ0FBVyxDQUFDeUQsSUFBSSxDQUFDc2tCLENBQUwsR0FBU3RrQixJQUFJLENBQUNtWixDQUFMLEdBQVMwQyxLQUFuQixJQUE0QixLQUF2QyxJQUFnRCxLQUFoRCxHQUF3RDdiLElBQUksQ0FBQzR4QixDQUE3RyxFQUFnSDV4QixJQUFoSCxDQUFQO0FBQ0QsQ0E1QkQ7QUFBQSxJQTZCSSs0RCwyQkFBMkIsR0FBRyxTQUFTQSwyQkFBVCxDQUFxQ2w5QyxLQUFyQyxFQUE0QzdiLElBQTVDLEVBQWtEO0FBQ2xGLFNBQU9BLElBQUksQ0FBQ3VJLEdBQUwsQ0FBU3ZJLElBQUksQ0FBQ29mLENBQWQsRUFBaUJwZixJQUFJLENBQUMxQixDQUF0QixFQUF5QnVkLEtBQUssR0FBR3ZmLElBQUksQ0FBQ0MsS0FBTCxDQUFXLENBQUN5RCxJQUFJLENBQUNza0IsQ0FBTCxHQUFTdGtCLElBQUksQ0FBQ21aLENBQUwsR0FBUzBDLEtBQW5CLElBQTRCLEtBQXZDLElBQWdELEtBQWhELEdBQXdEN2IsSUFBSSxDQUFDNHhCLENBQWhFLEdBQW9FNXhCLElBQUksQ0FBQ29aLENBQXZHLEVBQTBHcFosSUFBMUcsQ0FBUDtBQUNELENBL0JEO0FBQUEsSUFnQ0k7QUFDSmc1RCxxQkFBcUIsR0FBRyxTQUFTQSxxQkFBVCxDQUErQm45QyxLQUEvQixFQUFzQzdiLElBQXRDLEVBQTRDO0FBQ2xFLE1BQUlqRSxLQUFLLEdBQUdpRSxJQUFJLENBQUNza0IsQ0FBTCxHQUFTdGtCLElBQUksQ0FBQ21aLENBQUwsR0FBUzBDLEtBQTlCO0FBQ0E3YixFQUFBQSxJQUFJLENBQUN1SSxHQUFMLENBQVN2SSxJQUFJLENBQUNvZixDQUFkLEVBQWlCcGYsSUFBSSxDQUFDMUIsQ0FBdEIsRUFBeUIsQ0FBQyxFQUFFdkMsS0FBSyxJQUFJQSxLQUFLLEdBQUcsQ0FBUixHQUFZLENBQUMsRUFBYixHQUFrQixFQUF0QixDQUFQLENBQUQsR0FBcUNpRSxJQUFJLENBQUM0eEIsQ0FBbkUsRUFBc0U1eEIsSUFBdEU7QUFDRCxDQXBDRDtBQUFBLElBcUNJaTVELHVCQUF1QixHQUFHLFNBQVNBLHVCQUFULENBQWlDcDlDLEtBQWpDLEVBQXdDN2IsSUFBeEMsRUFBOEM7QUFDMUUsU0FBT0EsSUFBSSxDQUFDdUksR0FBTCxDQUFTdkksSUFBSSxDQUFDb2YsQ0FBZCxFQUFpQnBmLElBQUksQ0FBQzFCLENBQXRCLEVBQXlCdWQsS0FBSyxHQUFHN2IsSUFBSSxDQUFDbEQsQ0FBUixHQUFZa0QsSUFBSSxDQUFDb1osQ0FBL0MsRUFBa0RwWixJQUFsRCxDQUFQO0FBQ0QsQ0F2Q0Q7QUFBQSxJQXdDSWs1RCxnQ0FBZ0MsR0FBRyxTQUFTQSxnQ0FBVCxDQUEwQ3I5QyxLQUExQyxFQUFpRDdiLElBQWpELEVBQXVEO0FBQzVGLFNBQU9BLElBQUksQ0FBQ3VJLEdBQUwsQ0FBU3ZJLElBQUksQ0FBQ29mLENBQWQsRUFBaUJwZixJQUFJLENBQUMxQixDQUF0QixFQUF5QnVkLEtBQUssS0FBSyxDQUFWLEdBQWM3YixJQUFJLENBQUNvWixDQUFuQixHQUF1QnBaLElBQUksQ0FBQ2xELENBQXJELEVBQXdEa0QsSUFBeEQsQ0FBUDtBQUNELENBMUNEO0FBQUEsSUEyQ0ltNUQsZUFBZSxHQUFHLFNBQVNBLGVBQVQsQ0FBeUIvM0QsTUFBekIsRUFBaUNnQyxRQUFqQyxFQUEyQ3JILEtBQTNDLEVBQWtEO0FBQ3RFLFNBQU9xRixNQUFNLENBQUNsRSxLQUFQLENBQWFrRyxRQUFiLElBQXlCckgsS0FBaEM7QUFDRCxDQTdDRDtBQUFBLElBOENJcTlELGNBQWMsR0FBRyxTQUFTQSxjQUFULENBQXdCaDRELE1BQXhCLEVBQWdDZ0MsUUFBaEMsRUFBMENySCxLQUExQyxFQUFpRDtBQUNwRSxTQUFPcUYsTUFBTSxDQUFDbEUsS0FBUCxDQUFhbThELFdBQWIsQ0FBeUJqMkQsUUFBekIsRUFBbUNySCxLQUFuQyxDQUFQO0FBQ0QsQ0FoREQ7QUFBQSxJQWlESXU5RCxnQkFBZ0IsR0FBRyxTQUFTQSxnQkFBVCxDQUEwQmw0RCxNQUExQixFQUFrQ2dDLFFBQWxDLEVBQTRDckgsS0FBNUMsRUFBbUQ7QUFDeEUsU0FBT3FGLE1BQU0sQ0FBQzBPLEtBQVAsQ0FBYTFNLFFBQWIsSUFBeUJySCxLQUFoQztBQUNELENBbkREO0FBQUEsSUFvREl3OUQsWUFBWSxHQUFHLFNBQVNBLFlBQVQsQ0FBc0JuNEQsTUFBdEIsRUFBOEJnQyxRQUE5QixFQUF3Q3JILEtBQXhDLEVBQStDO0FBQ2hFLFNBQU9xRixNQUFNLENBQUMwTyxLQUFQLENBQWEwcEQsTUFBYixHQUFzQnA0RCxNQUFNLENBQUMwTyxLQUFQLENBQWEycEQsTUFBYixHQUFzQjE5RCxLQUFuRDtBQUNELENBdEREO0FBQUEsSUF1REkyOUQsc0JBQXNCLEdBQUcsU0FBU0Esc0JBQVQsQ0FBZ0N0NEQsTUFBaEMsRUFBd0NnQyxRQUF4QyxFQUFrRHJILEtBQWxELEVBQXlEaUUsSUFBekQsRUFBK0Q2YixLQUEvRCxFQUFzRTtBQUNqRyxNQUFJeVYsS0FBSyxHQUFHbHdCLE1BQU0sQ0FBQzBPLEtBQW5CO0FBQ0F3aEIsRUFBQUEsS0FBSyxDQUFDa29DLE1BQU4sR0FBZWxvQyxLQUFLLENBQUNtb0MsTUFBTixHQUFlMTlELEtBQTlCO0FBQ0F1MUIsRUFBQUEsS0FBSyxDQUFDdGUsZUFBTixDQUFzQjZJLEtBQXRCLEVBQTZCeVYsS0FBN0I7QUFDRCxDQTNERDtBQUFBLElBNERJcW9DLDBCQUEwQixHQUFHLFNBQVNBLDBCQUFULENBQW9DdjRELE1BQXBDLEVBQTRDZ0MsUUFBNUMsRUFBc0RySCxLQUF0RCxFQUE2RGlFLElBQTdELEVBQW1FNmIsS0FBbkUsRUFBMEU7QUFDekcsTUFBSXlWLEtBQUssR0FBR2x3QixNQUFNLENBQUMwTyxLQUFuQjtBQUNBd2hCLEVBQUFBLEtBQUssQ0FBQ2x1QixRQUFELENBQUwsR0FBa0JySCxLQUFsQjtBQUNBdTFCLEVBQUFBLEtBQUssQ0FBQ3RlLGVBQU4sQ0FBc0I2SSxLQUF0QixFQUE2QnlWLEtBQTdCO0FBQ0QsQ0FoRUQ7QUFBQSxJQWlFSW4xQixjQUFjLEdBQUcsV0FqRXJCO0FBQUEsSUFrRUlDLG9CQUFvQixHQUFHRCxjQUFjLEdBQUcsUUFsRTVDO0FBQUEsSUFtRUl5TSxXQW5FSjtBQUFBLElBb0VJak0sY0FBYyxHQUFHLFNBQVNBLGNBQVQsQ0FBd0JDLElBQXhCLEVBQThCQyxFQUE5QixFQUFrQztBQUNyRCxNQUFJQyxDQUFDLEdBQUdyQyxhQUFJLENBQUNzQyxlQUFMLEdBQXVCdEMsYUFBSSxDQUFDc0MsZUFBTCxDQUFxQixDQUFDRixFQUFFLElBQUksOEJBQVAsRUFBdUNHLE9BQXZDLENBQStDLFFBQS9DLEVBQXlELE1BQXpELENBQXJCLEVBQXVGSixJQUF2RixDQUF2QixHQUFzSG5DLGFBQUksQ0FBQ3dDLGFBQUwsQ0FBbUJMLElBQW5CLENBQTlILENBRHFELENBQ21HOztBQUV4SixTQUFPRSxDQUFDLENBQUNJLEtBQUYsR0FBVUosQ0FBVixHQUFjckMsYUFBSSxDQUFDd0MsYUFBTCxDQUFtQkwsSUFBbkIsQ0FBckIsQ0FIcUQsQ0FHTjtBQUNoRCxDQXhFRDtBQUFBLElBeUVJZzlELG9CQUFvQixHQUFHLFNBQVNBLG9CQUFULENBQThCeDRELE1BQTlCLEVBQXNDZ0MsUUFBdEMsRUFBZ0R5MkQsa0JBQWhELEVBQW9FO0FBQzdGLE1BQUluekQsRUFBRSxHQUFHbkQsZ0JBQWdCLENBQUNuQyxNQUFELENBQXpCO0FBQ0EsU0FBT3NGLEVBQUUsQ0FBQ3RELFFBQUQsQ0FBRixJQUFnQnNELEVBQUUsQ0FBQ296RCxnQkFBSCxDQUFvQjEyRCxRQUFRLENBQUNwRyxPQUFULENBQWlCeXFDLFFBQWpCLEVBQTJCLEtBQTNCLEVBQWtDcGtDLFdBQWxDLEVBQXBCLENBQWhCLElBQXdGcUQsRUFBRSxDQUFDb3pELGdCQUFILENBQW9CMTJELFFBQXBCLENBQXhGLElBQXlILENBQUN5MkQsa0JBQUQsSUFBdUJELG9CQUFvQixDQUFDeDRELE1BQUQsRUFBUzI0RCxnQkFBZ0IsQ0FBQzMyRCxRQUFELENBQWhCLElBQThCQSxRQUF2QyxFQUFpRCxDQUFqRCxDQUFwSyxJQUEyTixFQUFsTyxDQUY2RixDQUV5STtBQUN2TyxDQTVFRDtBQUFBLElBNkVJNDJELFNBQVMsR0FBRyxxQkFBcUJqdEQsS0FBckIsQ0FBMkIsR0FBM0IsQ0E3RWhCO0FBQUEsSUE4RUlndEQsZ0JBQWdCLEdBQUcsU0FBU0EsZ0JBQVQsQ0FBMEIzMkQsUUFBMUIsRUFBb0NqRCxPQUFwQyxFQUE2Qzg1RCxZQUE3QyxFQUEyRDtBQUNoRixNQUFJbjlELENBQUMsR0FBR3FELE9BQU8sSUFBSXZGLFFBQW5CO0FBQUEsTUFDSTBwQixDQUFDLEdBQUd4bkIsQ0FBQyxDQUFDSSxLQURWO0FBQUEsTUFFSXlCLENBQUMsR0FBRyxDQUZSOztBQUlBLE1BQUl5RSxRQUFRLElBQUlraEIsQ0FBWixJQUFpQixDQUFDMjFDLFlBQXRCLEVBQW9DO0FBQ2xDLFdBQU83MkQsUUFBUDtBQUNEOztBQUVEQSxFQUFBQSxRQUFRLEdBQUdBLFFBQVEsQ0FBQzRuQixNQUFULENBQWdCLENBQWhCLEVBQW1CSCxXQUFuQixLQUFtQ3puQixRQUFRLENBQUMybkIsTUFBVCxDQUFnQixDQUFoQixDQUE5Qzs7QUFFQSxTQUFPcHNCLENBQUMsTUFBTSxFQUFFcTdELFNBQVMsQ0FBQ3I3RCxDQUFELENBQVQsR0FBZXlFLFFBQWYsSUFBMkJraEIsQ0FBN0IsQ0FBZCxFQUErQyxDQUFFOztBQUVqRCxTQUFPM2xCLENBQUMsR0FBRyxDQUFKLEdBQVEsSUFBUixHQUFlLENBQUNBLENBQUMsS0FBSyxDQUFOLEdBQVUsSUFBVixHQUFpQkEsQ0FBQyxJQUFJLENBQUwsR0FBU3E3RCxTQUFTLENBQUNyN0QsQ0FBRCxDQUFsQixHQUF3QixFQUExQyxJQUFnRHlFLFFBQXRFO0FBQ0QsQ0E1RkQ7QUFBQSxJQTZGSXdJLFNBQVMsR0FBRyxTQUFTQSxTQUFULEdBQXFCO0FBQ25DLE1BQUlsUSxzQkFBYSxNQUFNQyxNQUFNLENBQUN1TixRQUE5QixFQUF3QztBQUN0QzFPLElBQUFBLGFBQUksR0FBR21CLE1BQVA7QUFDQWxCLElBQUFBLGFBQUksR0FBR0QsYUFBSSxDQUFDME8sUUFBWjtBQUNBeE8sSUFBQUEsV0FBVyxHQUFHRCxhQUFJLENBQUNpSCxlQUFuQjtBQUNBOUcsSUFBQUEsUUFBUSxHQUFHK0IsY0FBYyxDQUFDLEtBQUQsQ0FBZCxJQUF5QjtBQUNsQ08sTUFBQUEsS0FBSyxFQUFFO0FBRDJCLEtBQXBDO0FBR0FtN0QsSUFBQUEsY0FBYyxHQUFHMTdELGNBQWMsQ0FBQyxLQUFELENBQS9CO0FBQ0FSLElBQUFBLGNBQWMsR0FBRzQ5RCxnQkFBZ0IsQ0FBQzU5RCxjQUFELENBQWpDO0FBQ0FDLElBQUFBLG9CQUFvQixHQUFHRCxjQUFjLEdBQUcsUUFBeEM7QUFDQXZCLElBQUFBLFFBQVEsQ0FBQ3NDLEtBQVQsQ0FBZStPLE9BQWYsR0FBeUIsMERBQXpCLENBVnNDLENBVStDOztBQUVyRnJELElBQUFBLFdBQVcsR0FBRyxDQUFDLENBQUNteEQsZ0JBQWdCLENBQUMsYUFBRCxDQUFoQztBQUNBM0IsSUFBQUEsY0FBYyxHQUFHLENBQWpCO0FBQ0Q7QUFDRixDQTdHRDtBQUFBLElBOEdJOEIsWUFBWSxHQUFHLFNBQVNBLFlBQVQsQ0FBc0JDLGNBQXRCLEVBQXNDO0FBQ3ZEO0FBQ0EsTUFBSWhxQyxHQUFHLEdBQUd4ekIsY0FBYyxDQUFDLEtBQUQsRUFBUSxLQUFLd0osZUFBTCxJQUF3QixLQUFLQSxlQUFMLENBQXFCNEIsWUFBckIsQ0FBa0MsT0FBbEMsQ0FBeEIsSUFBc0UsNEJBQTlFLENBQXhCO0FBQUEsTUFDSXF5RCxTQUFTLEdBQUcsS0FBS2w0RCxVQURyQjtBQUFBLE1BRUltNEQsVUFBVSxHQUFHLEtBQUtydkQsV0FGdEI7QUFBQSxNQUdJc3ZELE1BQU0sR0FBRyxLQUFLcDlELEtBQUwsQ0FBVytPLE9BSHhCO0FBQUEsTUFJSXhGLElBSko7O0FBTUEvTCxFQUFBQSxXQUFXLENBQUN1USxXQUFaLENBQXdCa2xCLEdBQXhCOztBQUVBQSxFQUFBQSxHQUFHLENBQUNsbEIsV0FBSixDQUFnQixJQUFoQjtBQUNBLE9BQUsvTixLQUFMLENBQVdxTyxPQUFYLEdBQXFCLE9BQXJCOztBQUVBLE1BQUk0dUQsY0FBSixFQUFvQjtBQUNsQixRQUFJO0FBQ0YxekQsTUFBQUEsSUFBSSxHQUFHLEtBQUtQLE9BQUwsRUFBUDtBQUNBLFdBQUtxMEQsU0FBTCxHQUFpQixLQUFLcjBELE9BQXRCLENBRkUsQ0FFNkI7O0FBRS9CLFdBQUtBLE9BQUwsR0FBZWcwRCxZQUFmO0FBQ0QsS0FMRCxDQUtFLE9BQU9wOUQsQ0FBUCxFQUFVLENBQUU7QUFDZixHQVBELE1BT08sSUFBSSxLQUFLeTlELFNBQVQsRUFBb0I7QUFDekI5ekQsSUFBQUEsSUFBSSxHQUFHLEtBQUs4ekQsU0FBTCxFQUFQO0FBQ0Q7O0FBRUQsTUFBSUgsU0FBSixFQUFlO0FBQ2IsUUFBSUMsVUFBSixFQUFnQjtBQUNkRCxNQUFBQSxTQUFTLENBQUN0MkMsWUFBVixDQUF1QixJQUF2QixFQUE2QnUyQyxVQUE3QjtBQUNELEtBRkQsTUFFTztBQUNMRCxNQUFBQSxTQUFTLENBQUNudkQsV0FBVixDQUFzQixJQUF0QjtBQUNEO0FBQ0Y7O0FBRUR2USxFQUFBQSxXQUFXLENBQUN3USxXQUFaLENBQXdCaWxCLEdBQXhCOztBQUVBLE9BQUtqekIsS0FBTCxDQUFXK08sT0FBWCxHQUFxQnF1RCxNQUFyQjtBQUNBLFNBQU83ekQsSUFBUDtBQUNELENBbEpEO0FBQUEsSUFtSkkrekQsc0JBQXNCLEdBQUcsU0FBU0Esc0JBQVQsQ0FBZ0NwNUQsTUFBaEMsRUFBd0NxNUQsZUFBeEMsRUFBeUQ7QUFDcEYsTUFBSTk3RCxDQUFDLEdBQUc4N0QsZUFBZSxDQUFDNzdELE1BQXhCOztBQUVBLFNBQU9ELENBQUMsRUFBUixFQUFZO0FBQ1YsUUFBSXlDLE1BQU0sQ0FBQ3M1RCxZQUFQLENBQW9CRCxlQUFlLENBQUM5N0QsQ0FBRCxDQUFuQyxDQUFKLEVBQTZDO0FBQzNDLGFBQU95QyxNQUFNLENBQUMyRyxZQUFQLENBQW9CMHlELGVBQWUsQ0FBQzk3RCxDQUFELENBQW5DLENBQVA7QUFDRDtBQUNGO0FBQ0YsQ0EzSkQ7QUFBQSxJQTRKSWc4RCxRQUFRLEdBQUcsU0FBU0EsUUFBVCxDQUFrQnY1RCxNQUFsQixFQUEwQjtBQUN2QyxNQUFJaVQsTUFBSjs7QUFFQSxNQUFJO0FBQ0ZBLElBQUFBLE1BQU0sR0FBR2pULE1BQU0sQ0FBQzhFLE9BQVAsRUFBVCxDQURFLENBQ3lCO0FBQzVCLEdBRkQsQ0FFRSxPQUFPMDBELEtBQVAsRUFBYztBQUNkdm1ELElBQUFBLE1BQU0sR0FBRzZsRCxZQUFZLENBQUN0eUQsSUFBYixDQUFrQnhHLE1BQWxCLEVBQTBCLElBQTFCLENBQVQ7QUFDRDs7QUFFRGlULEVBQUFBLE1BQU0sS0FBS0EsTUFBTSxDQUFDdlEsS0FBUCxJQUFnQnVRLE1BQU0sQ0FBQ25RLE1BQTVCLENBQU4sSUFBNkM5QyxNQUFNLENBQUM4RSxPQUFQLEtBQW1CZzBELFlBQWhFLEtBQWlGN2xELE1BQU0sR0FBRzZsRCxZQUFZLENBQUN0eUQsSUFBYixDQUFrQnhHLE1BQWxCLEVBQTBCLElBQTFCLENBQTFGLEVBVHVDLENBU3FGOztBQUU1SCxTQUFPaVQsTUFBTSxJQUFJLENBQUNBLE1BQU0sQ0FBQ3ZRLEtBQWxCLElBQTJCLENBQUN1USxNQUFNLENBQUN4UixDQUFuQyxJQUF3QyxDQUFDd1IsTUFBTSxDQUFDdlIsQ0FBaEQsR0FBb0Q7QUFDekRELElBQUFBLENBQUMsRUFBRSxDQUFDMjNELHNCQUFzQixDQUFDcDVELE1BQUQsRUFBUyxDQUFDLEdBQUQsRUFBTSxJQUFOLEVBQVksSUFBWixDQUFULENBQXZCLElBQXNELENBREE7QUFFekQwQixJQUFBQSxDQUFDLEVBQUUsQ0FBQzAzRCxzQkFBc0IsQ0FBQ3A1RCxNQUFELEVBQVMsQ0FBQyxHQUFELEVBQU0sSUFBTixFQUFZLElBQVosQ0FBVCxDQUF2QixJQUFzRCxDQUZBO0FBR3pEMEMsSUFBQUEsS0FBSyxFQUFFLENBSGtEO0FBSXpESSxJQUFBQSxNQUFNLEVBQUU7QUFKaUQsR0FBcEQsR0FLSG1RLE1BTEo7QUFNRCxDQTdLRDtBQUFBLElBOEtJd21ELE1BQU0sR0FBRyxTQUFTQSxNQUFULENBQWdCLzlELENBQWhCLEVBQW1CO0FBQzlCLFNBQU8sQ0FBQyxFQUFFQSxDQUFDLENBQUNnK0QsTUFBRixLQUFhLENBQUNoK0QsQ0FBQyxDQUFDb0YsVUFBSCxJQUFpQnBGLENBQUMsQ0FBQ3FKLGVBQWhDLEtBQW9EdzBELFFBQVEsQ0FBQzc5RCxDQUFELENBQTlELENBQVI7QUFDRCxDQWhMRDtBQUFBLElBaUxJO0FBQ0ppK0QsZUFBZSxHQUFHLFNBQVNBLGVBQVQsQ0FBeUIzNUQsTUFBekIsRUFBaUNnQyxRQUFqQyxFQUEyQztBQUMzRCxNQUFJQSxRQUFKLEVBQWM7QUFDWixRQUFJbEcsS0FBSyxHQUFHa0UsTUFBTSxDQUFDbEUsS0FBbkI7O0FBRUEsUUFBSWtHLFFBQVEsSUFBSW0xRCxlQUFaLElBQStCbjFELFFBQVEsS0FBS2hILG9CQUFoRCxFQUFzRTtBQUNwRWdILE1BQUFBLFFBQVEsR0FBR2pILGNBQVg7QUFDRDs7QUFFRCxRQUFJZSxLQUFLLENBQUM2QixjQUFWLEVBQTBCO0FBQ3hCLFVBQUlxRSxRQUFRLENBQUMybkIsTUFBVCxDQUFnQixDQUFoQixFQUFtQixDQUFuQixNQUEwQixJQUExQixJQUFrQzNuQixRQUFRLENBQUMybkIsTUFBVCxDQUFnQixDQUFoQixFQUFtQixDQUFuQixNQUEwQixRQUFoRSxFQUEwRTtBQUN4RTtBQUNBM25CLFFBQUFBLFFBQVEsR0FBRyxNQUFNQSxRQUFqQjtBQUNEOztBQUVEbEcsTUFBQUEsS0FBSyxDQUFDNkIsY0FBTixDQUFxQnFFLFFBQVEsQ0FBQ3BHLE9BQVQsQ0FBaUJ5cUMsUUFBakIsRUFBMkIsS0FBM0IsRUFBa0Nwa0MsV0FBbEMsRUFBckI7QUFDRCxLQVBELE1BT087QUFDTDtBQUNBbkcsTUFBQUEsS0FBSyxDQUFDODlELGVBQU4sQ0FBc0I1M0QsUUFBdEI7QUFDRDtBQUNGO0FBQ0YsQ0F0TUQ7QUFBQSxJQXVNSTYzRCxpQkFBaUIsR0FBRyxTQUFTQSxpQkFBVCxDQUEyQjNyQyxNQUEzQixFQUFtQ2x1QixNQUFuQyxFQUEyQ2dDLFFBQTNDLEVBQXFEODNELFNBQXJELEVBQWdFdnpELEdBQWhFLEVBQXFFd3pELFlBQXJFLEVBQW1GO0FBQ3pHLE1BQUl6cEMsRUFBRSxHQUFHLElBQUk3QyxTQUFKLENBQWNTLE1BQU0sQ0FBQ3FDLEdBQXJCLEVBQTBCdndCLE1BQTFCLEVBQWtDZ0MsUUFBbEMsRUFBNEMsQ0FBNUMsRUFBK0MsQ0FBL0MsRUFBa0QrM0QsWUFBWSxHQUFHakMsZ0NBQUgsR0FBc0NELHVCQUFwRyxDQUFUO0FBQ0EzcEMsRUFBQUEsTUFBTSxDQUFDcUMsR0FBUCxHQUFhRCxFQUFiO0FBQ0FBLEVBQUFBLEVBQUUsQ0FBQ3RZLENBQUgsR0FBTzhoRCxTQUFQO0FBQ0F4cEMsRUFBQUEsRUFBRSxDQUFDNTBCLENBQUgsR0FBTzZLLEdBQVA7O0FBRUEybkIsRUFBQUEsTUFBTSxDQUFDd0MsTUFBUCxDQUFjMXlCLElBQWQsQ0FBbUJnRSxRQUFuQjs7QUFFQSxTQUFPc3VCLEVBQVA7QUFDRCxDQWhORDtBQUFBLElBaU5JMHBDLG9CQUFvQixHQUFHO0FBQ3pCQyxFQUFBQSxHQUFHLEVBQUUsQ0FEb0I7QUFFekJDLEVBQUFBLEdBQUcsRUFBRSxDQUZvQjtBQUd6QkMsRUFBQUEsSUFBSSxFQUFFO0FBSG1CLENBak4zQjtBQUFBLElBc05JO0FBQ0pDLGNBQWMsR0FBRyxTQUFTQSxjQUFULENBQXdCcDZELE1BQXhCLEVBQWdDZ0MsUUFBaEMsRUFBMENySCxLQUExQyxFQUFpRG9VLElBQWpELEVBQXVEO0FBQ3RFLE1BQUlzckQsUUFBUSxHQUFHMTBELFVBQVUsQ0FBQ2hMLEtBQUQsQ0FBVixJQUFxQixDQUFwQztBQUFBLE1BQ0kyL0QsT0FBTyxHQUFHLENBQUMzL0QsS0FBSyxHQUFHLEVBQVQsRUFBYXcrQyxJQUFiLEdBQW9CeHZCLE1BQXBCLENBQTJCLENBQUMwd0MsUUFBUSxHQUFHLEVBQVosRUFBZ0I3OEQsTUFBM0MsS0FBc0QsSUFEcEU7QUFBQSxNQUVJO0FBQ0oxQixFQUFBQSxLQUFLLEdBQUd0QyxRQUFRLENBQUNzQyxLQUhqQjtBQUFBLE1BSUlndEMsVUFBVSxHQUFHc3VCLGNBQWMsQ0FBQ3Z3RCxJQUFmLENBQW9CN0UsUUFBcEIsQ0FKakI7QUFBQSxNQUtJdTRELFNBQVMsR0FBR3Y2RCxNQUFNLENBQUMrZ0IsT0FBUCxDQUFlOWUsV0FBZixPQUFpQyxLQUxqRDtBQUFBLE1BTUl1NEQsZUFBZSxHQUFHLENBQUNELFNBQVMsR0FBRyxRQUFILEdBQWMsUUFBeEIsS0FBcUN6eEIsVUFBVSxHQUFHLE9BQUgsR0FBYSxRQUE1RCxDQU50QjtBQUFBLE1BT0lnWSxNQUFNLEdBQUcsR0FQYjtBQUFBLE1BUUkyWixRQUFRLEdBQUcxckQsSUFBSSxLQUFLLElBUnhCO0FBQUEsTUFTSTJyRCxTQUFTLEdBQUczckQsSUFBSSxLQUFLLEdBVHpCO0FBQUEsTUFVSTJkLEVBVko7QUFBQSxNQVdJcGhCLE1BWEo7QUFBQSxNQVlJNGtCLEtBWko7QUFBQSxNQWFJcnJCLEtBYko7O0FBZUEsTUFBSWtLLElBQUksS0FBS3VyRCxPQUFULElBQW9CLENBQUNELFFBQXJCLElBQWlDTCxvQkFBb0IsQ0FBQ2pyRCxJQUFELENBQXJELElBQStEaXJELG9CQUFvQixDQUFDTSxPQUFELENBQXZGLEVBQWtHO0FBQ2hHLFdBQU9ELFFBQVA7QUFDRDs7QUFFREMsRUFBQUEsT0FBTyxLQUFLLElBQVosSUFBb0IsQ0FBQ0csUUFBckIsS0FBa0NKLFFBQVEsR0FBR0QsY0FBYyxDQUFDcDZELE1BQUQsRUFBU2dDLFFBQVQsRUFBbUJySCxLQUFuQixFQUEwQixJQUExQixDQUEzRDtBQUNBa0ssRUFBQUEsS0FBSyxHQUFHN0UsTUFBTSxDQUFDMDVELE1BQVAsSUFBaUJELE1BQU0sQ0FBQ3o1RCxNQUFELENBQS9COztBQUVBLE1BQUksQ0FBQzA2RCxTQUFTLElBQUlKLE9BQU8sS0FBSyxHQUExQixNQUFtQ25ELGVBQWUsQ0FBQ24xRCxRQUFELENBQWYsSUFBNkIsQ0FBQ0EsUUFBUSxDQUFDZ0osT0FBVCxDQUFpQixPQUFqQixDQUFqRSxDQUFKLEVBQWlHO0FBQy9GMGhCLElBQUFBLEVBQUUsR0FBRzduQixLQUFLLEdBQUc3RSxNQUFNLENBQUM4RSxPQUFQLEdBQWlCZ2tDLFVBQVUsR0FBRyxPQUFILEdBQWEsUUFBeEMsQ0FBSCxHQUF1RDlvQyxNQUFNLENBQUN3NkQsZUFBRCxDQUF2RTtBQUNBLFdBQU92L0QsTUFBTSxDQUFDeS9ELFNBQVMsR0FBR0wsUUFBUSxHQUFHM3RDLEVBQVgsR0FBZ0JvMEIsTUFBbkIsR0FBNEJ1WixRQUFRLEdBQUcsR0FBWCxHQUFpQjN0QyxFQUF2RCxDQUFiO0FBQ0Q7O0FBRUQ1d0IsRUFBQUEsS0FBSyxDQUFDZ3RDLFVBQVUsR0FBRyxPQUFILEdBQWEsUUFBeEIsQ0FBTCxHQUF5Q2dZLE1BQU0sSUFBSTJaLFFBQVEsR0FBR0gsT0FBSCxHQUFhdnJELElBQXpCLENBQS9DO0FBQ0F6RCxFQUFBQSxNQUFNLEdBQUcsQ0FBQ3RKLFFBQVEsQ0FBQ2dKLE9BQVQsQ0FBaUIsT0FBakIsQ0FBRCxJQUE4QitELElBQUksS0FBSyxJQUFULElBQWlCL08sTUFBTSxDQUFDNkosV0FBeEIsSUFBdUMsQ0FBQzB3RCxTQUF0RSxHQUFrRnY2RCxNQUFsRixHQUEyRkEsTUFBTSxDQUFDYyxVQUEzRzs7QUFFQSxNQUFJK0QsS0FBSixFQUFXO0FBQ1R5RyxJQUFBQSxNQUFNLEdBQUcsQ0FBQ3RMLE1BQU0sQ0FBQytFLGVBQVAsSUFBMEIsRUFBM0IsRUFBK0JqRSxVQUF4QztBQUNEOztBQUVELE1BQUksQ0FBQ3dLLE1BQUQsSUFBV0EsTUFBTSxLQUFLalMsYUFBdEIsSUFBOEIsQ0FBQ2lTLE1BQU0sQ0FBQ3pCLFdBQTFDLEVBQXVEO0FBQ3JEeUIsSUFBQUEsTUFBTSxHQUFHalMsYUFBSSxDQUFDa0gsSUFBZDtBQUNEOztBQUVEMnZCLEVBQUFBLEtBQUssR0FBRzVrQixNQUFNLENBQUNvRCxLQUFmOztBQUVBLE1BQUl3aEIsS0FBSyxJQUFJd3FDLFNBQVQsSUFBc0J4cUMsS0FBSyxDQUFDeHRCLEtBQTVCLElBQXFDb21DLFVBQXJDLElBQW1ENVksS0FBSyxDQUFDL1csSUFBTixLQUFleWpDLFlBQXRFLEVBQW9GO0FBQ2xGLFdBQU8zaEQsTUFBTSxDQUFDby9ELFFBQVEsR0FBR25xQyxLQUFLLENBQUN4dEIsS0FBakIsR0FBeUJvK0MsTUFBMUIsQ0FBYjtBQUNELEdBRkQsTUFFTztBQUNMLEtBQUM0WixTQUFTLElBQUlKLE9BQU8sS0FBSyxHQUExQixNQUFtQ3grRCxLQUFLLENBQUN5TCxRQUFOLEdBQWlCaXhELG9CQUFvQixDQUFDeDRELE1BQUQsRUFBUyxVQUFULENBQXhFO0FBQ0FzTCxJQUFBQSxNQUFNLEtBQUt0TCxNQUFYLEtBQXNCbEUsS0FBSyxDQUFDeUwsUUFBTixHQUFpQixRQUF2QyxFQUZLLENBRTZDOztBQUVsRCtELElBQUFBLE1BQU0sQ0FBQ3pCLFdBQVAsQ0FBbUJyUSxRQUFuQjtBQUNBa3pCLElBQUFBLEVBQUUsR0FBR2x6QixRQUFRLENBQUNnaEUsZUFBRCxDQUFiO0FBQ0FsdkQsSUFBQUEsTUFBTSxDQUFDeEIsV0FBUCxDQUFtQnRRLFFBQW5CO0FBQ0FzQyxJQUFBQSxLQUFLLENBQUN5TCxRQUFOLEdBQWlCLFVBQWpCOztBQUVBLFFBQUl1aEMsVUFBVSxJQUFJNHhCLFNBQWxCLEVBQTZCO0FBQzNCeHFDLE1BQUFBLEtBQUssR0FBR29vQixTQUFTLENBQUNodEMsTUFBRCxDQUFqQjtBQUNBNGtCLE1BQUFBLEtBQUssQ0FBQy9XLElBQU4sR0FBYXlqQyxZQUFiO0FBQ0Exc0IsTUFBQUEsS0FBSyxDQUFDeHRCLEtBQU4sR0FBYzRJLE1BQU0sQ0FBQ2t2RCxlQUFELENBQXBCO0FBQ0Q7QUFDRjs7QUFFRCxTQUFPdi9ELE1BQU0sQ0FBQ3cvRCxRQUFRLEdBQUcvdEMsRUFBRSxHQUFHMnRDLFFBQUwsR0FBZ0J2WixNQUFuQixHQUE0QnAwQixFQUFFLElBQUkydEMsUUFBTixHQUFpQnZaLE1BQU0sR0FBR3AwQixFQUFULEdBQWMydEMsUUFBL0IsR0FBMEMsQ0FBL0UsQ0FBYjtBQUNELENBblJEO0FBQUEsSUFvUklNLElBQUksR0FBRyxTQUFTQSxJQUFULENBQWMzNkQsTUFBZCxFQUFzQmdDLFFBQXRCLEVBQWdDK00sSUFBaEMsRUFBc0NtRCxPQUF0QyxFQUErQztBQUN4RCxNQUFJdlgsS0FBSjtBQUNBcThELEVBQUFBLGNBQWMsSUFBSXhzRCxTQUFTLEVBQTNCOztBQUVBLE1BQUl4SSxRQUFRLElBQUlzMUQsZ0JBQVosSUFBZ0N0MUQsUUFBUSxLQUFLLFdBQWpELEVBQThEO0FBQzVEQSxJQUFBQSxRQUFRLEdBQUdzMUQsZ0JBQWdCLENBQUN0MUQsUUFBRCxDQUEzQjs7QUFFQSxRQUFJLENBQUNBLFFBQVEsQ0FBQ2dKLE9BQVQsQ0FBaUIsR0FBakIsQ0FBTCxFQUE0QjtBQUMxQmhKLE1BQUFBLFFBQVEsR0FBR0EsUUFBUSxDQUFDMkosS0FBVCxDQUFlLEdBQWYsRUFBb0IsQ0FBcEIsQ0FBWDtBQUNEO0FBQ0Y7O0FBRUQsTUFBSXdyRCxlQUFlLENBQUNuMUQsUUFBRCxDQUFmLElBQTZCQSxRQUFRLEtBQUssV0FBOUMsRUFBMkQ7QUFDekRySCxJQUFBQSxLQUFLLEdBQUdpZ0UsZUFBZSxDQUFDNTZELE1BQUQsRUFBU2tTLE9BQVQsQ0FBdkI7QUFDQXZYLElBQUFBLEtBQUssR0FBR3FILFFBQVEsS0FBSyxpQkFBYixHQUFpQ3JILEtBQUssQ0FBQ3FILFFBQUQsQ0FBdEMsR0FBbURySCxLQUFLLENBQUNvMEIsR0FBTixHQUFZcDBCLEtBQUssQ0FBQ2swQixNQUFsQixHQUEyQmdzQyxhQUFhLENBQUNyQyxvQkFBb0IsQ0FBQ3g0RCxNQUFELEVBQVNoRixvQkFBVCxDQUFyQixDQUFiLEdBQW9FLEdBQXBFLEdBQTBFTCxLQUFLLENBQUNtZ0UsT0FBaEYsR0FBMEYsSUFBaEw7QUFDRCxHQUhELE1BR087QUFDTG5nRSxJQUFBQSxLQUFLLEdBQUdxRixNQUFNLENBQUNsRSxLQUFQLENBQWFrRyxRQUFiLENBQVI7O0FBRUEsUUFBSSxDQUFDckgsS0FBRCxJQUFVQSxLQUFLLEtBQUssTUFBcEIsSUFBOEJ1WCxPQUE5QixJQUF5QyxDQUFDLENBQUN2WCxLQUFLLEdBQUcsRUFBVCxFQUFhcVEsT0FBYixDQUFxQixPQUFyQixDQUE5QyxFQUE2RTtBQUMzRXJRLE1BQUFBLEtBQUssR0FBR29nRSxhQUFhLENBQUMvNEQsUUFBRCxDQUFiLElBQTJCKzRELGFBQWEsQ0FBQy80RCxRQUFELENBQWIsQ0FBd0JoQyxNQUF4QixFQUFnQ2dDLFFBQWhDLEVBQTBDK00sSUFBMUMsQ0FBM0IsSUFBOEV5cEQsb0JBQW9CLENBQUN4NEQsTUFBRCxFQUFTZ0MsUUFBVCxDQUFsRyxJQUF3SHUyQyxZQUFZLENBQUN2NEMsTUFBRCxFQUFTZ0MsUUFBVCxDQUFwSSxLQUEySkEsUUFBUSxLQUFLLFNBQWIsR0FBeUIsQ0FBekIsR0FBNkIsQ0FBeEwsQ0FBUixDQUQyRSxDQUN5SDtBQUNyTTtBQUNGOztBQUVELFNBQU8rTSxJQUFJLElBQUksQ0FBQyxDQUFDLENBQUNwVSxLQUFLLEdBQUcsRUFBVCxFQUFhdytDLElBQWIsR0FBb0JudUMsT0FBcEIsQ0FBNEIsR0FBNUIsQ0FBVixHQUE2Q292RCxjQUFjLENBQUNwNkQsTUFBRCxFQUFTZ0MsUUFBVCxFQUFtQnJILEtBQW5CLEVBQTBCb1UsSUFBMUIsQ0FBZCxHQUFnREEsSUFBN0YsR0FBb0dwVSxLQUEzRztBQUNELENBNVNEO0FBQUEsSUE2U0lxZ0Usc0JBQXNCLEdBQUcsU0FBU0Esc0JBQVQsQ0FBZ0NoN0QsTUFBaEMsRUFBd0MrdEIsSUFBeEMsRUFBOENuWixLQUE5QyxFQUFxRHJPLEdBQXJELEVBQTBEO0FBQ3JGO0FBQ0EsTUFBSSxDQUFDcU8sS0FBRCxJQUFVQSxLQUFLLEtBQUssTUFBeEIsRUFBZ0M7QUFDOUI7QUFDQSxRQUFJMVgsQ0FBQyxHQUFHeTdELGdCQUFnQixDQUFDNXFDLElBQUQsRUFBTy90QixNQUFQLEVBQWUsQ0FBZixDQUF4QjtBQUFBLFFBQ0lrakIsQ0FBQyxHQUFHaG1CLENBQUMsSUFBSXM3RCxvQkFBb0IsQ0FBQ3g0RCxNQUFELEVBQVM5QyxDQUFULEVBQVksQ0FBWixDQURqQzs7QUFHQSxRQUFJZ21CLENBQUMsSUFBSUEsQ0FBQyxLQUFLdE8sS0FBZixFQUFzQjtBQUNwQm1aLE1BQUFBLElBQUksR0FBRzd3QixDQUFQO0FBQ0EwWCxNQUFBQSxLQUFLLEdBQUdzTyxDQUFSO0FBQ0QsS0FIRCxNQUdPLElBQUk2SyxJQUFJLEtBQUssYUFBYixFQUE0QjtBQUNqQ25aLE1BQUFBLEtBQUssR0FBRzRqRCxvQkFBb0IsQ0FBQ3g0RCxNQUFELEVBQVMsZ0JBQVQsQ0FBNUIsQ0FEaUMsQ0FDdUI7QUFDekQ7QUFDRjs7QUFFRCxNQUFJc3dCLEVBQUUsR0FBRyxJQUFJN0MsU0FBSixDQUFjLEtBQUs4QyxHQUFuQixFQUF3QnZ3QixNQUFNLENBQUNsRSxLQUEvQixFQUFzQ2l5QixJQUF0QyxFQUE0QyxDQUE1QyxFQUErQyxDQUEvQyxFQUFrRGdpQyxvQkFBbEQsQ0FBVDtBQUFBLE1BQ0kzd0MsS0FBSyxHQUFHLENBRFo7QUFBQSxNQUVJNHdDLFVBQVUsR0FBRyxDQUZqQjtBQUFBLE1BR0kzcEQsQ0FISjtBQUFBLE1BSUl6QyxNQUpKO0FBQUEsTUFLSXEzRCxXQUxKO0FBQUEsTUFNSTdLLFFBTko7QUFBQSxNQU9JN3RCLEtBUEo7QUFBQSxNQVFJMjRCLFVBUko7QUFBQSxNQVNJdHVCLFFBVEo7QUFBQSxNQVVJc2pCLE1BVko7QUFBQSxNQVdJQyxLQVhKO0FBQUEsTUFZSWdMLE9BWko7QUFBQSxNQWFJQyxTQWJKO0FBQUEsTUFjSUMsU0FkSjtBQWVBL3FDLEVBQUFBLEVBQUUsQ0FBQ3RZLENBQUgsR0FBT3BELEtBQVA7QUFDQTBiLEVBQUFBLEVBQUUsQ0FBQzUwQixDQUFILEdBQU82SyxHQUFQO0FBQ0FxTyxFQUFBQSxLQUFLLElBQUksRUFBVCxDQWhDcUYsQ0FnQ3hFOztBQUVick8sRUFBQUEsR0FBRyxJQUFJLEVBQVA7O0FBRUEsTUFBSUEsR0FBRyxLQUFLLE1BQVosRUFBb0I7QUFDbEJ2RyxJQUFBQSxNQUFNLENBQUNsRSxLQUFQLENBQWFpeUIsSUFBYixJQUFxQnhuQixHQUFyQjtBQUNBQSxJQUFBQSxHQUFHLEdBQUdpeUQsb0JBQW9CLENBQUN4NEQsTUFBRCxFQUFTK3RCLElBQVQsQ0FBcEIsSUFBc0N4bkIsR0FBNUM7QUFDQXZHLElBQUFBLE1BQU0sQ0FBQ2xFLEtBQVAsQ0FBYWl5QixJQUFiLElBQXFCblosS0FBckI7QUFDRDs7QUFFRHZPLEVBQUFBLENBQUMsR0FBRyxDQUFDdU8sS0FBRCxFQUFRck8sR0FBUixDQUFKOztBQUVBbWdELEVBQUFBLGtCQUFrQixDQUFDcmdELENBQUQsQ0FBbEIsQ0E1Q3FGLENBNEM5RDs7O0FBR3ZCdU8sRUFBQUEsS0FBSyxHQUFHdk8sQ0FBQyxDQUFDLENBQUQsQ0FBVDtBQUNBRSxFQUFBQSxHQUFHLEdBQUdGLENBQUMsQ0FBQyxDQUFELENBQVA7QUFDQTQwRCxFQUFBQSxXQUFXLEdBQUdybUQsS0FBSyxDQUFDME4sS0FBTixDQUFZazBCLGVBQVosS0FBZ0MsRUFBOUM7QUFDQTZrQixFQUFBQSxTQUFTLEdBQUc5MEQsR0FBRyxDQUFDK2IsS0FBSixDQUFVazBCLGVBQVYsS0FBOEIsRUFBMUM7O0FBRUEsTUFBSTZrQixTQUFTLENBQUM3OUQsTUFBZCxFQUFzQjtBQUNwQixXQUFPb0csTUFBTSxHQUFHNHlDLG9CQUFBLENBQXFCandDLEdBQXJCLENBQWhCLEVBQTJDO0FBQ3pDcW1DLE1BQUFBLFFBQVEsR0FBR2hwQyxNQUFNLENBQUMsQ0FBRCxDQUFqQjtBQUNBdXNELE1BQUFBLEtBQUssR0FBRzVwRCxHQUFHLENBQUMyaUQsU0FBSixDQUFjOXBDLEtBQWQsRUFBcUJ4YixNQUFNLENBQUN3YixLQUE1QixDQUFSOztBQUVBLFVBQUltakIsS0FBSixFQUFXO0FBQ1RBLFFBQUFBLEtBQUssR0FBRyxDQUFDQSxLQUFLLEdBQUcsQ0FBVCxJQUFjLENBQXRCO0FBQ0QsT0FGRCxNQUVPLElBQUk0dEIsS0FBSyxDQUFDeG1DLE1BQU4sQ0FBYSxDQUFDLENBQWQsTUFBcUIsT0FBckIsSUFBZ0N3bUMsS0FBSyxDQUFDeG1DLE1BQU4sQ0FBYSxDQUFDLENBQWQsTUFBcUIsT0FBekQsRUFBa0U7QUFDdkU0WSxRQUFBQSxLQUFLLEdBQUcsQ0FBUjtBQUNEOztBQUVELFVBQUlxSyxRQUFRLE1BQU1zdUIsVUFBVSxHQUFHRCxXQUFXLENBQUNqTCxVQUFVLEVBQVgsQ0FBWCxJQUE2QixFQUFoRCxDQUFaLEVBQWlFO0FBQy9ESSxRQUFBQSxRQUFRLEdBQUd6cUQsVUFBVSxDQUFDdTFELFVBQUQsQ0FBVixJQUEwQixDQUFyQztBQUNBRSxRQUFBQSxTQUFTLEdBQUdGLFVBQVUsQ0FBQ3Z4QyxNQUFYLENBQWtCLENBQUN5bUMsUUFBUSxHQUFHLEVBQVosRUFBZ0I1eUQsTUFBbEMsQ0FBWjtBQUNBb3ZDLFFBQUFBLFFBQVEsQ0FBQ2hqQixNQUFULENBQWdCLENBQWhCLE1BQXVCLEdBQXZCLEtBQStCZ2pCLFFBQVEsR0FBRzhMLGNBQWMsQ0FBQzBYLFFBQUQsRUFBV3hqQixRQUFYLENBQWQsR0FBcUN3dUIsU0FBL0U7QUFDQWxMLFFBQUFBLE1BQU0sR0FBR3ZxRCxVQUFVLENBQUNpbkMsUUFBRCxDQUFuQjtBQUNBdXVCLFFBQUFBLE9BQU8sR0FBR3Z1QixRQUFRLENBQUNqakIsTUFBVCxDQUFnQixDQUFDdW1DLE1BQU0sR0FBRyxFQUFWLEVBQWMxeUQsTUFBOUIsQ0FBVjtBQUNBNGhCLFFBQUFBLEtBQUssR0FBR28zQix5QkFBQSxHQUE0QjJrQixPQUFPLENBQUMzOUQsTUFBNUM7O0FBRUEsWUFBSSxDQUFDMjlELE9BQUwsRUFBYztBQUNaO0FBQ0FBLFVBQUFBLE9BQU8sR0FBR0EsT0FBTyxJQUFJeGxCLGFBQUEsQ0FBYzVuQixJQUFkLENBQVgsSUFBa0NxdEMsU0FBNUM7O0FBRUEsY0FBSWg4QyxLQUFLLEtBQUs3WSxHQUFHLENBQUMvSSxNQUFsQixFQUEwQjtBQUN4QitJLFlBQUFBLEdBQUcsSUFBSTQwRCxPQUFQO0FBQ0E3cUMsWUFBQUEsRUFBRSxDQUFDNTBCLENBQUgsSUFBUXkvRCxPQUFSO0FBQ0Q7QUFDRjs7QUFFRCxZQUFJQyxTQUFTLEtBQUtELE9BQWxCLEVBQTJCO0FBQ3pCL0ssVUFBQUEsUUFBUSxHQUFHZ0ssY0FBYyxDQUFDcDZELE1BQUQsRUFBUyt0QixJQUFULEVBQWVtdEMsVUFBZixFQUEyQkMsT0FBM0IsQ0FBZCxJQUFxRCxDQUFoRTtBQUNELFNBcEI4RCxDQW9CN0Q7OztBQUdGN3FDLFFBQUFBLEVBQUUsQ0FBQ0MsR0FBSCxHQUFTO0FBQ1BxQixVQUFBQSxLQUFLLEVBQUV0QixFQUFFLENBQUNDLEdBREg7QUFFUHJ6QixVQUFBQSxDQUFDLEVBQUVpekQsS0FBSyxJQUFJSCxVQUFVLEtBQUssQ0FBeEIsR0FBNEJHLEtBQTVCLEdBQW9DLEdBRmhDO0FBR1A7QUFDQWp0QyxVQUFBQSxDQUFDLEVBQUVrdEMsUUFKSTtBQUtQcjRDLFVBQUFBLENBQUMsRUFBRW00QyxNQUFNLEdBQUdFLFFBTEw7QUFNUHAxQyxVQUFBQSxDQUFDLEVBQUV1bkIsS0FBSyxJQUFJQSxLQUFLLEdBQUcsQ0FBakIsSUFBc0J4VSxJQUFJLEtBQUssUUFBL0IsR0FBMEM3eUIsSUFBSSxDQUFDQyxLQUEvQyxHQUF1RDtBQU5uRCxTQUFUO0FBUUQ7QUFDRjs7QUFFRG0xQixJQUFBQSxFQUFFLENBQUN2WSxDQUFILEdBQU9xSCxLQUFLLEdBQUc3WSxHQUFHLENBQUMvSSxNQUFaLEdBQXFCK0ksR0FBRyxDQUFDMmlELFNBQUosQ0FBYzlwQyxLQUFkLEVBQXFCN1ksR0FBRyxDQUFDL0ksTUFBekIsQ0FBckIsR0FBd0QsRUFBL0QsQ0E3Q29CLENBNkMrQztBQUNwRSxHQTlDRCxNQThDTztBQUNMOHlCLElBQUFBLEVBQUUsQ0FBQ250QixDQUFILEdBQU80cUIsSUFBSSxLQUFLLFNBQVQsSUFBc0J4bkIsR0FBRyxLQUFLLE1BQTlCLEdBQXVDdXhELGdDQUF2QyxHQUEwRUQsdUJBQWpGO0FBQ0Q7O0FBRURuaEIsRUFBQUEsWUFBQSxDQUFhbndDLEdBQWIsTUFBc0IrcEIsRUFBRSxDQUFDNTBCLENBQUgsR0FBTyxDQUE3QixFQXRHcUYsQ0FzR3BEOztBQUVqQyxPQUFLNjBCLEdBQUwsR0FBV0QsRUFBWCxDQXhHcUYsQ0F3R3RFOztBQUVmLFNBQU9BLEVBQVA7QUFDRCxDQXhaRDtBQUFBLElBeVpJZ3JDLGlCQUFpQixHQUFHO0FBQ3RCNzRELEVBQUFBLEdBQUcsRUFBRSxJQURpQjtBQUV0Qk0sRUFBQUEsTUFBTSxFQUFFLE1BRmM7QUFHdEJQLEVBQUFBLElBQUksRUFBRSxJQUhnQjtBQUl0QkcsRUFBQUEsS0FBSyxFQUFFLE1BSmU7QUFLdEJnL0IsRUFBQUEsTUFBTSxFQUFFO0FBTGMsQ0F6WnhCO0FBQUEsSUFnYUk0NUIsNkJBQTZCLEdBQUcsU0FBU0EsNkJBQVQsQ0FBdUM1Z0UsS0FBdkMsRUFBOEM7QUFDaEYsTUFBSWdSLEtBQUssR0FBR2hSLEtBQUssQ0FBQ2dSLEtBQU4sQ0FBWSxHQUFaLENBQVo7QUFBQSxNQUNJbEssQ0FBQyxHQUFHa0ssS0FBSyxDQUFDLENBQUQsQ0FEYjtBQUFBLE1BRUlqSyxDQUFDLEdBQUdpSyxLQUFLLENBQUMsQ0FBRCxDQUFMLElBQVksS0FGcEI7O0FBSUEsTUFBSWxLLENBQUMsS0FBSyxLQUFOLElBQWVBLENBQUMsS0FBSyxRQUFyQixJQUFpQ0MsQ0FBQyxLQUFLLE1BQXZDLElBQWlEQSxDQUFDLEtBQUssT0FBM0QsRUFBb0U7QUFDbEU7QUFDQS9HLElBQUFBLEtBQUssR0FBRzhHLENBQVI7QUFDQUEsSUFBQUEsQ0FBQyxHQUFHQyxDQUFKO0FBQ0FBLElBQUFBLENBQUMsR0FBRy9HLEtBQUo7QUFDRDs7QUFFRGdSLEVBQUFBLEtBQUssQ0FBQyxDQUFELENBQUwsR0FBVzJ2RCxpQkFBaUIsQ0FBQzc1RCxDQUFELENBQWpCLElBQXdCQSxDQUFuQztBQUNBa0ssRUFBQUEsS0FBSyxDQUFDLENBQUQsQ0FBTCxHQUFXMnZELGlCQUFpQixDQUFDNTVELENBQUQsQ0FBakIsSUFBd0JBLENBQW5DO0FBQ0EsU0FBT2lLLEtBQUssQ0FBQ3NXLElBQU4sQ0FBVyxHQUFYLENBQVA7QUFDRCxDQS9hRDtBQUFBLElBZ2JJdTVDLGlCQUFpQixHQUFHLFNBQVNBLGlCQUFULENBQTJCL2dELEtBQTNCLEVBQWtDN2IsSUFBbEMsRUFBd0M7QUFDOUQsTUFBSUEsSUFBSSxDQUFDNlUsS0FBTCxJQUFjN1UsSUFBSSxDQUFDNlUsS0FBTCxDQUFXcThCLEtBQVgsS0FBcUJseEMsSUFBSSxDQUFDNlUsS0FBTCxDQUFXcW5DLElBQWxELEVBQXdEO0FBQ3RELFFBQUk5NkMsTUFBTSxHQUFHcEIsSUFBSSxDQUFDb2YsQ0FBbEI7QUFBQSxRQUNJbGlCLEtBQUssR0FBR2tFLE1BQU0sQ0FBQ2xFLEtBRG5CO0FBQUEsUUFFSThrQixLQUFLLEdBQUdoaUIsSUFBSSxDQUFDNHhCLENBRmpCO0FBQUEsUUFHSU4sS0FBSyxHQUFHbHdCLE1BQU0sQ0FBQzBPLEtBSG5CO0FBQUEsUUFJSXFmLElBSko7QUFBQSxRQUtJMHRDLGVBTEo7QUFBQSxRQU1JbCtELENBTko7O0FBUUEsUUFBSXFqQixLQUFLLEtBQUssS0FBVixJQUFtQkEsS0FBSyxLQUFLLElBQWpDLEVBQXVDO0FBQ3JDOWtCLE1BQUFBLEtBQUssQ0FBQytPLE9BQU4sR0FBZ0IsRUFBaEI7QUFDQTR3RCxNQUFBQSxlQUFlLEdBQUcsQ0FBbEI7QUFDRCxLQUhELE1BR087QUFDTDc2QyxNQUFBQSxLQUFLLEdBQUdBLEtBQUssQ0FBQ2pWLEtBQU4sQ0FBWSxHQUFaLENBQVI7QUFDQXBPLE1BQUFBLENBQUMsR0FBR3FqQixLQUFLLENBQUNwakIsTUFBVjs7QUFFQSxhQUFPLEVBQUVELENBQUYsR0FBTSxDQUFDLENBQWQsRUFBaUI7QUFDZnd3QixRQUFBQSxJQUFJLEdBQUduTixLQUFLLENBQUNyakIsQ0FBRCxDQUFaOztBQUVBLFlBQUk0NUQsZUFBZSxDQUFDcHBDLElBQUQsQ0FBbkIsRUFBMkI7QUFDekIwdEMsVUFBQUEsZUFBZSxHQUFHLENBQWxCO0FBQ0ExdEMsVUFBQUEsSUFBSSxHQUFHQSxJQUFJLEtBQUssaUJBQVQsR0FBNkIveUIsb0JBQTdCLEdBQW9ERCxjQUEzRDtBQUNEOztBQUVENCtELFFBQUFBLGVBQWUsQ0FBQzM1RCxNQUFELEVBQVMrdEIsSUFBVCxDQUFmO0FBQ0Q7QUFDRjs7QUFFRCxRQUFJMHRDLGVBQUosRUFBcUI7QUFDbkI5QixNQUFBQSxlQUFlLENBQUMzNUQsTUFBRCxFQUFTakYsY0FBVCxDQUFmOztBQUVBLFVBQUltMUIsS0FBSixFQUFXO0FBQ1RBLFFBQUFBLEtBQUssQ0FBQ25CLEdBQU4sSUFBYS91QixNQUFNLENBQUM0NUQsZUFBUCxDQUF1QixXQUF2QixDQUFiOztBQUVBZ0IsUUFBQUEsZUFBZSxDQUFDNTZELE1BQUQsRUFBUyxDQUFULENBQWYsQ0FIUyxDQUdtQjs7O0FBRzVCa3dCLFFBQUFBLEtBQUssQ0FBQ2hlLE9BQU4sR0FBZ0IsQ0FBaEI7QUFDRDtBQUNGO0FBQ0Y7QUFDRixDQTFkRDtBQUFBLElBMmRJO0FBQ0o2b0QsYUFBYSxHQUFHO0FBQ2R0L0MsRUFBQUEsVUFBVSxFQUFFLFNBQVNBLFVBQVQsQ0FBb0J5UyxNQUFwQixFQUE0Qmx1QixNQUE1QixFQUFvQ2dDLFFBQXBDLEVBQThDNHFDLFFBQTlDLEVBQXdEbjVCLEtBQXhELEVBQStEO0FBQ3pFLFFBQUlBLEtBQUssQ0FBQzdVLElBQU4sS0FBZSxhQUFuQixFQUFrQztBQUNoQyxVQUFJMHhCLEVBQUUsR0FBR3BDLE1BQU0sQ0FBQ3FDLEdBQVAsR0FBYSxJQUFJOUMsU0FBSixDQUFjUyxNQUFNLENBQUNxQyxHQUFyQixFQUEwQnZ3QixNQUExQixFQUFrQ2dDLFFBQWxDLEVBQTRDLENBQTVDLEVBQStDLENBQS9DLEVBQWtEdzVELGlCQUFsRCxDQUF0QjtBQUNBbHJDLE1BQUFBLEVBQUUsQ0FBQ0UsQ0FBSCxHQUFPb2MsUUFBUDtBQUNBdGMsTUFBQUEsRUFBRSxDQUFDNmpDLEVBQUgsR0FBUSxDQUFDLEVBQVQ7QUFDQTdqQyxNQUFBQSxFQUFFLENBQUM3YyxLQUFILEdBQVdBLEtBQVg7O0FBRUF5YSxNQUFBQSxNQUFNLENBQUN3QyxNQUFQLENBQWMxeUIsSUFBZCxDQUFtQmdFLFFBQW5COztBQUVBLGFBQU8sQ0FBUDtBQUNEO0FBQ0Y7QUFDRDtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBM0VnQixDQTVkaEI7O0FBMmlCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EwNUQsaUJBQWlCLEdBQUcsQ0FBQyxDQUFELEVBQUksQ0FBSixFQUFPLENBQVAsRUFBVSxDQUFWLEVBQWEsQ0FBYixFQUFnQixDQUFoQixDQWhqQnBCO0FBQUEsSUFpakJJQyxxQkFBcUIsR0FBRyxFQWpqQjVCO0FBQUEsSUFrakJJQyxnQkFBZ0IsR0FBRyxTQUFTQSxnQkFBVCxDQUEwQmpoRSxLQUExQixFQUFpQztBQUN0RCxTQUFPQSxLQUFLLEtBQUssMEJBQVYsSUFBd0NBLEtBQUssS0FBSyxNQUFsRCxJQUE0RCxDQUFDQSxLQUFwRTtBQUNELENBcGpCRDtBQUFBLElBcWpCSWtoRSxrQ0FBa0MsR0FBRyxTQUFTQSxrQ0FBVCxDQUE0Qzc3RCxNQUE1QyxFQUFvRDtBQUMzRixNQUFJODdELFlBQVksR0FBR3RELG9CQUFvQixDQUFDeDRELE1BQUQsRUFBU2pGLGNBQVQsQ0FBdkM7O0FBRUEsU0FBTzZnRSxnQkFBZ0IsQ0FBQ0UsWUFBRCxDQUFoQixHQUFpQ0osaUJBQWpDLEdBQXFESSxZQUFZLENBQUNueUMsTUFBYixDQUFvQixDQUFwQixFQUF1QnJILEtBQXZCLENBQTZCcU0sT0FBN0IsRUFBc0M3UyxHQUF0QyxDQUEwQzdnQixNQUExQyxDQUE1RDtBQUNELENBempCRDtBQUFBLElBMGpCSThnRSxVQUFVLEdBQUcsU0FBU0EsVUFBVCxDQUFvQi83RCxNQUFwQixFQUE0Qmc4RCxPQUE1QixFQUFxQztBQUNwRCxNQUFJOXJDLEtBQUssR0FBR2x3QixNQUFNLENBQUMwTyxLQUFQLElBQWdCNHBDLFNBQVMsQ0FBQ3Q0QyxNQUFELENBQXJDO0FBQUEsTUFDSWxFLEtBQUssR0FBR2tFLE1BQU0sQ0FBQ2xFLEtBRG5CO0FBQUEsTUFFSWtKLE1BQU0sR0FBRzYyRCxrQ0FBa0MsQ0FBQzc3RCxNQUFELENBRi9DO0FBQUEsTUFHSXNMLE1BSEo7QUFBQSxNQUlJMUIsV0FKSjtBQUFBLE1BS0lrTyxJQUxKO0FBQUEsTUFNSW1rRCxVQU5KOztBQVFBLE1BQUkvckMsS0FBSyxDQUFDbkIsR0FBTixJQUFhL3VCLE1BQU0sQ0FBQzJHLFlBQVAsQ0FBb0IsV0FBcEIsQ0FBakIsRUFBbUQ7QUFDakRtUixJQUFBQSxJQUFJLEdBQUc5WCxNQUFNLENBQUMwMEMsU0FBUCxDQUFpQmp2QyxPQUFqQixDQUF5QnkyRCxXQUF6QixHQUF1Q2wzRCxNQUE5QyxDQURpRCxDQUNLOztBQUV0REEsSUFBQUEsTUFBTSxHQUFHLENBQUM4UyxJQUFJLENBQUN6UixDQUFOLEVBQVN5UixJQUFJLENBQUNFLENBQWQsRUFBaUJGLElBQUksQ0FBQ0MsQ0FBdEIsRUFBeUJELElBQUksQ0FBQ0csQ0FBOUIsRUFBaUNILElBQUksQ0FBQ3BjLENBQXRDLEVBQXlDb2MsSUFBSSxDQUFDSSxDQUE5QyxDQUFUO0FBQ0EsV0FBT2xULE1BQU0sQ0FBQ2lkLElBQVAsQ0FBWSxHQUFaLE1BQXFCLGFBQXJCLEdBQXFDeTVDLGlCQUFyQyxHQUF5RDEyRCxNQUFoRTtBQUNELEdBTEQsTUFLTyxJQUFJQSxNQUFNLEtBQUswMkQsaUJBQVgsSUFBZ0MsQ0FBQzE3RCxNQUFNLENBQUNtOEQsWUFBeEMsSUFBd0RuOEQsTUFBTSxLQUFLMUcsV0FBbkUsSUFBa0YsQ0FBQzQyQixLQUFLLENBQUNuQixHQUE3RixFQUFrRztBQUN2RztBQUNBO0FBQ0FqWCxJQUFBQSxJQUFJLEdBQUdoYyxLQUFLLENBQUNxTyxPQUFiO0FBQ0FyTyxJQUFBQSxLQUFLLENBQUNxTyxPQUFOLEdBQWdCLE9BQWhCO0FBQ0FtQixJQUFBQSxNQUFNLEdBQUd0TCxNQUFNLENBQUNjLFVBQWhCOztBQUVBLFFBQUksQ0FBQ3dLLE1BQUQsSUFBVyxDQUFDdEwsTUFBTSxDQUFDbThELFlBQXZCLEVBQXFDO0FBQ25DO0FBQ0FGLE1BQUFBLFVBQVUsR0FBRyxDQUFiLENBRm1DLENBRW5COztBQUVoQnJ5RCxNQUFBQSxXQUFXLEdBQUc1SixNQUFNLENBQUM0SixXQUFyQjs7QUFFQXRRLE1BQUFBLFdBQVcsQ0FBQ3VRLFdBQVosQ0FBd0I3SixNQUF4QixFQU5tQyxDQU1GOztBQUVsQzs7QUFFRGdGLElBQUFBLE1BQU0sR0FBRzYyRCxrQ0FBa0MsQ0FBQzc3RCxNQUFELENBQTNDO0FBQ0E4WCxJQUFBQSxJQUFJLEdBQUdoYyxLQUFLLENBQUNxTyxPQUFOLEdBQWdCMk4sSUFBbkIsR0FBMEI2aEQsZUFBZSxDQUFDMzVELE1BQUQsRUFBUyxTQUFULENBQTdDOztBQUVBLFFBQUlpOEQsVUFBSixFQUFnQjtBQUNkcnlELE1BQUFBLFdBQVcsR0FBRzBCLE1BQU0sQ0FBQ29YLFlBQVAsQ0FBb0IxaUIsTUFBcEIsRUFBNEI0SixXQUE1QixDQUFILEdBQThDMEIsTUFBTSxHQUFHQSxNQUFNLENBQUN6QixXQUFQLENBQW1CN0osTUFBbkIsQ0FBSCxHQUFnQzFHLFdBQVcsQ0FBQ3dRLFdBQVosQ0FBd0I5SixNQUF4QixDQUEvRjtBQUNEO0FBQ0Y7O0FBRUQsU0FBT2c4RCxPQUFPLElBQUloM0QsTUFBTSxDQUFDeEgsTUFBUCxHQUFnQixDQUEzQixHQUErQixDQUFDd0gsTUFBTSxDQUFDLENBQUQsQ0FBUCxFQUFZQSxNQUFNLENBQUMsQ0FBRCxDQUFsQixFQUF1QkEsTUFBTSxDQUFDLENBQUQsQ0FBN0IsRUFBa0NBLE1BQU0sQ0FBQyxDQUFELENBQXhDLEVBQTZDQSxNQUFNLENBQUMsRUFBRCxDQUFuRCxFQUF5REEsTUFBTSxDQUFDLEVBQUQsQ0FBL0QsQ0FBL0IsR0FBc0dBLE1BQTdHO0FBQ0QsQ0FsbUJEO0FBQUEsSUFtbUJJbzNELGVBQWUsR0FBRyxTQUFTQSxlQUFULENBQXlCcDhELE1BQXpCLEVBQWlDNnVCLE1BQWpDLEVBQXlDd3RDLGdCQUF6QyxFQUEyREMsTUFBM0QsRUFBbUVDLFdBQW5FLEVBQWdGQyx1QkFBaEYsRUFBeUc7QUFDN0gsTUFBSXRzQyxLQUFLLEdBQUdsd0IsTUFBTSxDQUFDME8sS0FBbkI7QUFBQSxNQUNJMUosTUFBTSxHQUFHdTNELFdBQVcsSUFBSVIsVUFBVSxDQUFDLzdELE1BQUQsRUFBUyxJQUFULENBRHRDO0FBQUEsTUFFSXk4RCxVQUFVLEdBQUd2c0MsS0FBSyxDQUFDOWEsT0FBTixJQUFpQixDQUZsQztBQUFBLE1BR0lzbkQsVUFBVSxHQUFHeHNDLEtBQUssQ0FBQzdhLE9BQU4sSUFBaUIsQ0FIbEM7QUFBQSxNQUlJc25ELFVBQVUsR0FBR3pzQyxLQUFLLENBQUMwc0MsT0FBTixJQUFpQixDQUpsQztBQUFBLE1BS0lDLFVBQVUsR0FBRzNzQyxLQUFLLENBQUM0c0MsT0FBTixJQUFpQixDQUxsQztBQUFBLE1BTUl6MkQsQ0FBQyxHQUFHckIsTUFBTSxDQUFDLENBQUQsQ0FOZDtBQUFBLE1BT0lnVCxDQUFDLEdBQUdoVCxNQUFNLENBQUMsQ0FBRCxDQVBkO0FBQUEsTUFRSStTLENBQUMsR0FBRy9TLE1BQU0sQ0FBQyxDQUFELENBUmQ7QUFBQSxNQVNJaVQsQ0FBQyxHQUFHalQsTUFBTSxDQUFDLENBQUQsQ0FUZDtBQUFBLE1BVUlpaEIsRUFBRSxHQUFHamhCLE1BQU0sQ0FBQyxDQUFELENBVmY7QUFBQSxNQVdJa2hCLEVBQUUsR0FBR2xoQixNQUFNLENBQUMsQ0FBRCxDQVhmO0FBQUEsTUFZSSszRCxXQUFXLEdBQUdsdUMsTUFBTSxDQUFDbGpCLEtBQVAsQ0FBYSxHQUFiLENBWmxCO0FBQUEsTUFhSXlKLE9BQU8sR0FBR3pQLFVBQVUsQ0FBQ28zRCxXQUFXLENBQUMsQ0FBRCxDQUFaLENBQVYsSUFBOEIsQ0FiNUM7QUFBQSxNQWNJMW5ELE9BQU8sR0FBRzFQLFVBQVUsQ0FBQ28zRCxXQUFXLENBQUMsQ0FBRCxDQUFaLENBQVYsSUFBOEIsQ0FkNUM7QUFBQSxNQWVJOXBELE1BZko7QUFBQSxNQWdCSStwRCxXQWhCSjtBQUFBLE1BaUJJdjdELENBakJKO0FBQUEsTUFrQklDLENBbEJKOztBQW9CQSxNQUFJLENBQUMyNkQsZ0JBQUwsRUFBdUI7QUFDckJwcEQsSUFBQUEsTUFBTSxHQUFHc21ELFFBQVEsQ0FBQ3Y1RCxNQUFELENBQWpCO0FBQ0FvVixJQUFBQSxPQUFPLEdBQUduQyxNQUFNLENBQUN4UixDQUFQLElBQVksQ0FBQ3M3RCxXQUFXLENBQUMsQ0FBRCxDQUFYLENBQWUveEQsT0FBZixDQUF1QixHQUF2QixDQUFELEdBQStCb0ssT0FBTyxHQUFHLEdBQVYsR0FBZ0JuQyxNQUFNLENBQUN2USxLQUF0RCxHQUE4RDBTLE9BQTFFLENBQVY7QUFDQUMsSUFBQUEsT0FBTyxHQUFHcEMsTUFBTSxDQUFDdlIsQ0FBUCxJQUFZLENBQUMsQ0FBQ3E3RCxXQUFXLENBQUMsQ0FBRCxDQUFYLElBQWtCQSxXQUFXLENBQUMsQ0FBRCxDQUE5QixFQUFtQy94RCxPQUFuQyxDQUEyQyxHQUEzQyxDQUFELEdBQW1EcUssT0FBTyxHQUFHLEdBQVYsR0FBZ0JwQyxNQUFNLENBQUNuUSxNQUExRSxHQUFtRnVTLE9BQS9GLENBQVY7QUFDRCxHQUpELE1BSU8sSUFBSXJRLE1BQU0sS0FBSzAyRCxpQkFBWCxLQUFpQ3NCLFdBQVcsR0FBRzMyRCxDQUFDLEdBQUc0UixDQUFKLEdBQVFELENBQUMsR0FBR0QsQ0FBM0QsQ0FBSixFQUFtRTtBQUN4RTtBQUNBdFcsSUFBQUEsQ0FBQyxHQUFHMlQsT0FBTyxJQUFJNkMsQ0FBQyxHQUFHK2tELFdBQVIsQ0FBUCxHQUE4QjNuRCxPQUFPLElBQUksQ0FBQzBDLENBQUQsR0FBS2lsRCxXQUFULENBQXJDLEdBQTZELENBQUNqbEQsQ0FBQyxHQUFHbU8sRUFBSixHQUFTak8sQ0FBQyxHQUFHZ08sRUFBZCxJQUFvQisyQyxXQUFyRjtBQUNBdDdELElBQUFBLENBQUMsR0FBRzBULE9BQU8sSUFBSSxDQUFDNEMsQ0FBRCxHQUFLZ2xELFdBQVQsQ0FBUCxHQUErQjNuRCxPQUFPLElBQUloUCxDQUFDLEdBQUcyMkQsV0FBUixDQUF0QyxHQUE2RCxDQUFDMzJELENBQUMsR0FBRzZmLEVBQUosR0FBU2xPLENBQUMsR0FBR2lPLEVBQWQsSUFBb0IrMkMsV0FBckY7QUFDQTVuRCxJQUFBQSxPQUFPLEdBQUczVCxDQUFWO0FBQ0E0VCxJQUFBQSxPQUFPLEdBQUczVCxDQUFWO0FBQ0Q7O0FBRUQsTUFBSTQ2RCxNQUFNLElBQUlBLE1BQU0sS0FBSyxLQUFYLElBQW9CcHNDLEtBQUssQ0FBQ29zQyxNQUF4QyxFQUFnRDtBQUM5Q3IyQyxJQUFBQSxFQUFFLEdBQUc3USxPQUFPLEdBQUdxbkQsVUFBZjtBQUNBdjJDLElBQUFBLEVBQUUsR0FBRzdRLE9BQU8sR0FBR3FuRCxVQUFmO0FBQ0F4c0MsSUFBQUEsS0FBSyxDQUFDMHNDLE9BQU4sR0FBZ0JELFVBQVUsSUFBSTEyQyxFQUFFLEdBQUc1ZixDQUFMLEdBQVM2ZixFQUFFLEdBQUduTyxDQUFsQixDQUFWLEdBQWlDa08sRUFBakQ7QUFDQWlLLElBQUFBLEtBQUssQ0FBQzRzQyxPQUFOLEdBQWdCRCxVQUFVLElBQUk1MkMsRUFBRSxHQUFHak8sQ0FBTCxHQUFTa08sRUFBRSxHQUFHak8sQ0FBbEIsQ0FBVixHQUFpQ2lPLEVBQWpEO0FBQ0QsR0FMRCxNQUtPO0FBQ0xnSyxJQUFBQSxLQUFLLENBQUMwc0MsT0FBTixHQUFnQjFzQyxLQUFLLENBQUM0c0MsT0FBTixHQUFnQixDQUFoQztBQUNEOztBQUVENXNDLEVBQUFBLEtBQUssQ0FBQzlhLE9BQU4sR0FBZ0JBLE9BQWhCO0FBQ0E4YSxFQUFBQSxLQUFLLENBQUM3YSxPQUFOLEdBQWdCQSxPQUFoQjtBQUNBNmEsRUFBQUEsS0FBSyxDQUFDb3NDLE1BQU4sR0FBZSxDQUFDLENBQUNBLE1BQWpCO0FBQ0Fwc0MsRUFBQUEsS0FBSyxDQUFDckIsTUFBTixHQUFlQSxNQUFmO0FBQ0FxQixFQUFBQSxLQUFLLENBQUNtc0MsZ0JBQU4sR0FBeUIsQ0FBQyxDQUFDQSxnQkFBM0I7QUFDQXI4RCxFQUFBQSxNQUFNLENBQUNsRSxLQUFQLENBQWFkLG9CQUFiLElBQXFDLFNBQXJDLENBL0M2SCxDQStDN0U7O0FBRWhELE1BQUl3aEUsdUJBQUosRUFBNkI7QUFDM0IzQyxJQUFBQSxpQkFBaUIsQ0FBQzJDLHVCQUFELEVBQTBCdHNDLEtBQTFCLEVBQWlDLFNBQWpDLEVBQTRDdXNDLFVBQTVDLEVBQXdEcm5ELE9BQXhELENBQWpCOztBQUVBeWtELElBQUFBLGlCQUFpQixDQUFDMkMsdUJBQUQsRUFBMEJ0c0MsS0FBMUIsRUFBaUMsU0FBakMsRUFBNEN3c0MsVUFBNUMsRUFBd0RybkQsT0FBeEQsQ0FBakI7O0FBRUF3a0QsSUFBQUEsaUJBQWlCLENBQUMyQyx1QkFBRCxFQUEwQnRzQyxLQUExQixFQUFpQyxTQUFqQyxFQUE0Q3lzQyxVQUE1QyxFQUF3RHpzQyxLQUFLLENBQUMwc0MsT0FBOUQsQ0FBakI7O0FBRUEvQyxJQUFBQSxpQkFBaUIsQ0FBQzJDLHVCQUFELEVBQTBCdHNDLEtBQTFCLEVBQWlDLFNBQWpDLEVBQTRDMnNDLFVBQTVDLEVBQXdEM3NDLEtBQUssQ0FBQzRzQyxPQUE5RCxDQUFqQjtBQUNEOztBQUVEOThELEVBQUFBLE1BQU0sQ0FBQ3VpQixZQUFQLENBQW9CLGlCQUFwQixFQUF1Q25OLE9BQU8sR0FBRyxHQUFWLEdBQWdCQyxPQUF2RDtBQUNELENBL3BCRDtBQUFBLElBZ3FCSXVsRCxlQUFlLEdBQUcsU0FBU0EsZUFBVCxDQUF5QjU2RCxNQUF6QixFQUFpQ2tTLE9BQWpDLEVBQTBDO0FBQzlELE1BQUlnZSxLQUFLLEdBQUdsd0IsTUFBTSxDQUFDME8sS0FBUCxJQUFnQixJQUFJMnBDLE9BQUosQ0FBWXI0QyxNQUFaLENBQTVCOztBQUVBLE1BQUksT0FBT2t3QixLQUFQLElBQWdCLENBQUNoZSxPQUFqQixJQUE0QixDQUFDZ2UsS0FBSyxDQUFDaGUsT0FBdkMsRUFBZ0Q7QUFDOUMsV0FBT2dlLEtBQVA7QUFDRDs7QUFFRCxNQUFJcDBCLEtBQUssR0FBR2tFLE1BQU0sQ0FBQ2xFLEtBQW5CO0FBQUEsTUFDSW1oRSxjQUFjLEdBQUcvc0MsS0FBSyxDQUFDa29DLE1BQU4sR0FBZSxDQURwQztBQUFBLE1BRUkxckMsRUFBRSxHQUFHLElBRlQ7QUFBQSxNQUdJdXRDLEdBQUcsR0FBRyxLQUhWO0FBQUEsTUFJSXByQyxNQUFNLEdBQUcycEMsb0JBQW9CLENBQUN4NEQsTUFBRCxFQUFTaEYsb0JBQVQsQ0FBcEIsSUFBc0QsR0FKbkU7QUFBQSxNQUtJeUcsQ0FMSjtBQUFBLE1BTUlDLENBTko7QUFBQSxNQU9JdzdELENBUEo7QUFBQSxNQVFJOUUsTUFSSjtBQUFBLE1BU0lDLE1BVEo7QUFBQSxNQVVJenJELFFBVko7QUFBQSxNQVdJZ3pCLFNBWEo7QUFBQSxNQVlJQyxTQVpKO0FBQUEsTUFhSUUsS0FiSjtBQUFBLE1BY0lDLEtBZEo7QUFBQSxNQWVJbTlCLFdBZko7QUFBQSxNQWdCSS9uRCxPQWhCSjtBQUFBLE1BaUJJQyxPQWpCSjtBQUFBLE1Ba0JJclEsTUFsQko7QUFBQSxNQW1CSWdmLEtBbkJKO0FBQUEsTUFvQklqSCxHQXBCSjtBQUFBLE1BcUJJRixHQXJCSjtBQUFBLE1Bc0JJeFcsQ0F0Qko7QUFBQSxNQXVCSTJSLENBdkJKO0FBQUEsTUF3QklELENBeEJKO0FBQUEsTUF5QklFLENBekJKO0FBQUEsTUEwQkltbEQsR0ExQko7QUFBQSxNQTJCSUMsR0EzQko7QUFBQSxNQTRCSXpuQyxFQTVCSjtBQUFBLE1BNkJJQyxFQTdCSjtBQUFBLE1BOEJJeW5DLEVBOUJKO0FBQUEsTUErQklDLEdBL0JKO0FBQUEsTUFnQ0lDLEdBaENKO0FBQUEsTUFpQ0lDLEdBakNKO0FBQUEsTUFrQ0lDLEdBbENKO0FBQUEsTUFtQ0lDLEdBbkNKO0FBQUEsTUFvQ0lDLEdBcENKO0FBcUNBbjhELEVBQUFBLENBQUMsR0FBR0MsQ0FBQyxHQUFHdzdELENBQUMsR0FBR3R3RCxRQUFRLEdBQUdnekIsU0FBUyxHQUFHQyxTQUFTLEdBQUdFLEtBQUssR0FBR0MsS0FBSyxHQUFHbTlCLFdBQVcsR0FBRyxDQUE3RTtBQUNBL0UsRUFBQUEsTUFBTSxHQUFHQyxNQUFNLEdBQUcsQ0FBbEI7QUFDQW5vQyxFQUFBQSxLQUFLLENBQUNuQixHQUFOLEdBQVksQ0FBQyxFQUFFL3VCLE1BQU0sQ0FBQzA1RCxNQUFQLElBQWlCRCxNQUFNLENBQUN6NUQsTUFBRCxDQUF6QixDQUFiO0FBQ0FnRixFQUFBQSxNQUFNLEdBQUcrMkQsVUFBVSxDQUFDLzdELE1BQUQsRUFBU2t3QixLQUFLLENBQUNuQixHQUFmLENBQW5COztBQUVBLE1BQUltQixLQUFLLENBQUNuQixHQUFWLEVBQWU7QUFDYjZHLElBQUFBLEVBQUUsR0FBRyxDQUFDLENBQUMxRixLQUFLLENBQUNoZSxPQUFQLElBQWtCMmMsTUFBTSxLQUFLLFNBQTlCLEtBQTRDLENBQUMzYyxPQUE3QyxJQUF3RGxTLE1BQU0sQ0FBQzJHLFlBQVAsQ0FBb0IsaUJBQXBCLENBQTdELENBRGEsQ0FDd0Y7O0FBRXJHeTFELElBQUFBLGVBQWUsQ0FBQ3A4RCxNQUFELEVBQVM0MUIsRUFBRSxJQUFJL0csTUFBZixFQUF1QixDQUFDLENBQUMrRyxFQUFGLElBQVExRixLQUFLLENBQUNtc0MsZ0JBQXJDLEVBQXVEbnNDLEtBQUssQ0FBQ29zQyxNQUFOLEtBQWlCLEtBQXhFLEVBQStFdDNELE1BQS9FLENBQWY7QUFDRDs7QUFFRG9RLEVBQUFBLE9BQU8sR0FBRzhhLEtBQUssQ0FBQzlhLE9BQU4sSUFBaUIsQ0FBM0I7QUFDQUMsRUFBQUEsT0FBTyxHQUFHNmEsS0FBSyxDQUFDN2EsT0FBTixJQUFpQixDQUEzQjs7QUFFQSxNQUFJclEsTUFBTSxLQUFLMDJELGlCQUFmLEVBQWtDO0FBQ2hDcjFELElBQUFBLENBQUMsR0FBR3JCLE1BQU0sQ0FBQyxDQUFELENBQVYsQ0FEZ0MsQ0FDakI7O0FBRWZnVCxJQUFBQSxDQUFDLEdBQUdoVCxNQUFNLENBQUMsQ0FBRCxDQUFWLENBSGdDLENBR2pCOztBQUVmK1MsSUFBQUEsQ0FBQyxHQUFHL1MsTUFBTSxDQUFDLENBQUQsQ0FBVixDQUxnQyxDQUtqQjs7QUFFZmlULElBQUFBLENBQUMsR0FBR2pULE1BQU0sQ0FBQyxDQUFELENBQVYsQ0FQZ0MsQ0FPakI7O0FBRWZ2RCxJQUFBQSxDQUFDLEdBQUcyN0QsR0FBRyxHQUFHcDRELE1BQU0sQ0FBQyxDQUFELENBQWhCO0FBQ0F0RCxJQUFBQSxDQUFDLEdBQUcyN0QsR0FBRyxHQUFHcjRELE1BQU0sQ0FBQyxDQUFELENBQWhCLENBVmdDLENBVVg7O0FBRXJCLFFBQUlBLE1BQU0sQ0FBQ3hILE1BQVAsS0FBa0IsQ0FBdEIsRUFBeUI7QUFDdkI0NkQsTUFBQUEsTUFBTSxHQUFHbDlELElBQUksQ0FBQ2dpQixJQUFMLENBQVU3VyxDQUFDLEdBQUdBLENBQUosR0FBUTJSLENBQUMsR0FBR0EsQ0FBdEIsQ0FBVDtBQUNBcWdELE1BQUFBLE1BQU0sR0FBR245RCxJQUFJLENBQUNnaUIsSUFBTCxDQUFVakYsQ0FBQyxHQUFHQSxDQUFKLEdBQVFGLENBQUMsR0FBR0EsQ0FBdEIsQ0FBVDtBQUNBbkwsTUFBQUEsUUFBUSxHQUFHdkcsQ0FBQyxJQUFJMlIsQ0FBTCxHQUFTbUYsTUFBTSxDQUFDbkYsQ0FBRCxFQUFJM1IsQ0FBSixDQUFOLEdBQWV0SyxRQUF4QixHQUFtQyxDQUE5QyxDQUh1QixDQUcwQjs7QUFFakRna0MsTUFBQUEsS0FBSyxHQUFHaG9CLENBQUMsSUFBSUUsQ0FBTCxHQUFTa0YsTUFBTSxDQUFDcEYsQ0FBRCxFQUFJRSxDQUFKLENBQU4sR0FBZWxjLFFBQWYsR0FBMEI2USxRQUFuQyxHQUE4QyxDQUF0RDtBQUNBbXpCLE1BQUFBLEtBQUssS0FBS3M0QixNQUFNLElBQUluOUQsSUFBSSxDQUFDMmIsR0FBTCxDQUFTM2IsSUFBSSxDQUFDNmhCLEdBQUwsQ0FBU2dqQixLQUFLLEdBQUdwakIsUUFBakIsQ0FBVCxDQUFmLENBQUw7O0FBRUEsVUFBSXVULEtBQUssQ0FBQ25CLEdBQVYsRUFBZTtBQUNidHRCLFFBQUFBLENBQUMsSUFBSTJULE9BQU8sSUFBSUEsT0FBTyxHQUFHL08sQ0FBVixHQUFjZ1AsT0FBTyxHQUFHMEMsQ0FBNUIsQ0FBWjtBQUNBclcsUUFBQUEsQ0FBQyxJQUFJMlQsT0FBTyxJQUFJRCxPQUFPLEdBQUc0QyxDQUFWLEdBQWMzQyxPQUFPLEdBQUc0QyxDQUE1QixDQUFaO0FBQ0QsT0FYc0IsQ0FXckI7O0FBRUgsS0FiRCxNQWFPO0FBQ0wybEQsTUFBQUEsR0FBRyxHQUFHNTRELE1BQU0sQ0FBQyxDQUFELENBQVo7QUFDQTA0RCxNQUFBQSxHQUFHLEdBQUcxNEQsTUFBTSxDQUFDLENBQUQsQ0FBWjtBQUNBdTRELE1BQUFBLEdBQUcsR0FBR3Y0RCxNQUFNLENBQUMsQ0FBRCxDQUFaO0FBQ0F3NEQsTUFBQUEsR0FBRyxHQUFHeDRELE1BQU0sQ0FBQyxDQUFELENBQVo7QUFDQXk0RCxNQUFBQSxHQUFHLEdBQUd6NEQsTUFBTSxDQUFDLEVBQUQsQ0FBWjtBQUNBMjRELE1BQUFBLEdBQUcsR0FBRzM0RCxNQUFNLENBQUMsRUFBRCxDQUFaO0FBQ0F2RCxNQUFBQSxDQUFDLEdBQUd1RCxNQUFNLENBQUMsRUFBRCxDQUFWO0FBQ0F0RCxNQUFBQSxDQUFDLEdBQUdzRCxNQUFNLENBQUMsRUFBRCxDQUFWO0FBQ0FrNEQsTUFBQUEsQ0FBQyxHQUFHbDRELE1BQU0sQ0FBQyxFQUFELENBQVY7QUFDQWdmLE1BQUFBLEtBQUssR0FBRzdHLE1BQU0sQ0FBQ3lnRCxHQUFELEVBQU1ILEdBQU4sQ0FBZDtBQUNBNzlCLE1BQUFBLFNBQVMsR0FBRzViLEtBQUssR0FBR2pvQixRQUFwQixDQVhLLENBV3lCOztBQUU5QixVQUFJaW9CLEtBQUosRUFBVztBQUNUakgsUUFBQUEsR0FBRyxHQUFHN2hCLElBQUksQ0FBQzZoQixHQUFMLENBQVMsQ0FBQ2lILEtBQVYsQ0FBTjtBQUNBbkgsUUFBQUEsR0FBRyxHQUFHM2hCLElBQUksQ0FBQzJoQixHQUFMLENBQVMsQ0FBQ21ILEtBQVYsQ0FBTjtBQUNBNFIsUUFBQUEsRUFBRSxHQUFHd25DLEdBQUcsR0FBR3JnRCxHQUFOLEdBQVl3Z0QsR0FBRyxHQUFHMWdELEdBQXZCO0FBQ0FnWixRQUFBQSxFQUFFLEdBQUd3bkMsR0FBRyxHQUFHdGdELEdBQU4sR0FBWXlnRCxHQUFHLEdBQUczZ0QsR0FBdkI7QUFDQXlnRCxRQUFBQSxFQUFFLEdBQUdNLEdBQUcsR0FBRzdnRCxHQUFOLEdBQVkwZ0QsR0FBRyxHQUFHNWdELEdBQXZCO0FBQ0EwZ0QsUUFBQUEsR0FBRyxHQUFHSCxHQUFHLEdBQUcsQ0FBQ3ZnRCxHQUFQLEdBQWEwZ0QsR0FBRyxHQUFHeGdELEdBQXpCO0FBQ0F5Z0QsUUFBQUEsR0FBRyxHQUFHSCxHQUFHLEdBQUcsQ0FBQ3hnRCxHQUFQLEdBQWEyZ0QsR0FBRyxHQUFHemdELEdBQXpCO0FBQ0EwZ0QsUUFBQUEsR0FBRyxHQUFHRyxHQUFHLEdBQUcsQ0FBQy9nRCxHQUFQLEdBQWE0Z0QsR0FBRyxHQUFHMWdELEdBQXpCO0FBQ0E0Z0QsUUFBQUEsR0FBRyxHQUFHRCxHQUFHLEdBQUcsQ0FBQzdnRCxHQUFQLEdBQWE4Z0QsR0FBRyxHQUFHNWdELEdBQXpCO0FBQ0FxZ0QsUUFBQUEsR0FBRyxHQUFHeG5DLEVBQU47QUFDQXluQyxRQUFBQSxHQUFHLEdBQUd4bkMsRUFBTjtBQUNBK25DLFFBQUFBLEdBQUcsR0FBR04sRUFBTjtBQUNELE9BMUJJLENBMEJIOzs7QUFHRnQ1QyxNQUFBQSxLQUFLLEdBQUc3RyxNQUFNLENBQUMsQ0FBQ3BGLENBQUYsRUFBSzBsRCxHQUFMLENBQWQ7QUFDQTU5QixNQUFBQSxTQUFTLEdBQUc3YixLQUFLLEdBQUdqb0IsUUFBcEI7O0FBRUEsVUFBSWlvQixLQUFKLEVBQVc7QUFDVGpILFFBQUFBLEdBQUcsR0FBRzdoQixJQUFJLENBQUM2aEIsR0FBTCxDQUFTLENBQUNpSCxLQUFWLENBQU47QUFDQW5ILFFBQUFBLEdBQUcsR0FBRzNoQixJQUFJLENBQUMyaEIsR0FBTCxDQUFTLENBQUNtSCxLQUFWLENBQU47QUFDQTRSLFFBQUFBLEVBQUUsR0FBR3Z2QixDQUFDLEdBQUcwVyxHQUFKLEdBQVV3Z0QsR0FBRyxHQUFHMWdELEdBQXJCO0FBQ0FnWixRQUFBQSxFQUFFLEdBQUc3ZCxDQUFDLEdBQUcrRSxHQUFKLEdBQVV5Z0QsR0FBRyxHQUFHM2dELEdBQXJCO0FBQ0F5Z0QsUUFBQUEsRUFBRSxHQUFHdmxELENBQUMsR0FBR2dGLEdBQUosR0FBVTBnRCxHQUFHLEdBQUc1Z0QsR0FBckI7QUFDQThnRCxRQUFBQSxHQUFHLEdBQUcxbEQsQ0FBQyxHQUFHNEUsR0FBSixHQUFVOGdELEdBQUcsR0FBRzVnRCxHQUF0QjtBQUNBMVcsUUFBQUEsQ0FBQyxHQUFHdXZCLEVBQUo7QUFDQTVkLFFBQUFBLENBQUMsR0FBRzZkLEVBQUo7QUFDQTlkLFFBQUFBLENBQUMsR0FBR3VsRCxFQUFKO0FBQ0QsT0ExQ0ksQ0EwQ0g7OztBQUdGdDVDLE1BQUFBLEtBQUssR0FBRzdHLE1BQU0sQ0FBQ25GLENBQUQsRUFBSTNSLENBQUosQ0FBZDtBQUNBdUcsTUFBQUEsUUFBUSxHQUFHb1gsS0FBSyxHQUFHam9CLFFBQW5COztBQUVBLFVBQUlpb0IsS0FBSixFQUFXO0FBQ1RqSCxRQUFBQSxHQUFHLEdBQUc3aEIsSUFBSSxDQUFDNmhCLEdBQUwsQ0FBU2lILEtBQVQsQ0FBTjtBQUNBbkgsUUFBQUEsR0FBRyxHQUFHM2hCLElBQUksQ0FBQzJoQixHQUFMLENBQVNtSCxLQUFULENBQU47QUFDQTRSLFFBQUFBLEVBQUUsR0FBR3Z2QixDQUFDLEdBQUcwVyxHQUFKLEdBQVUvRSxDQUFDLEdBQUc2RSxHQUFuQjtBQUNBZ1osUUFBQUEsRUFBRSxHQUFHdW5DLEdBQUcsR0FBR3JnRCxHQUFOLEdBQVlzZ0QsR0FBRyxHQUFHeGdELEdBQXZCO0FBQ0E3RSxRQUFBQSxDQUFDLEdBQUdBLENBQUMsR0FBRytFLEdBQUosR0FBVTFXLENBQUMsR0FBR3dXLEdBQWxCO0FBQ0F3Z0QsUUFBQUEsR0FBRyxHQUFHQSxHQUFHLEdBQUd0Z0QsR0FBTixHQUFZcWdELEdBQUcsR0FBR3ZnRCxHQUF4QjtBQUNBeFcsUUFBQUEsQ0FBQyxHQUFHdXZCLEVBQUo7QUFDQXduQyxRQUFBQSxHQUFHLEdBQUd2bkMsRUFBTjtBQUNEOztBQUVELFVBQUkrSixTQUFTLElBQUkxa0MsSUFBSSxDQUFDMmIsR0FBTCxDQUFTK29CLFNBQVQsSUFBc0Ixa0MsSUFBSSxDQUFDMmIsR0FBTCxDQUFTakssUUFBVCxDQUF0QixHQUEyQyxLQUE1RCxFQUFtRTtBQUNqRTtBQUNBZ3pCLFFBQUFBLFNBQVMsR0FBR2h6QixRQUFRLEdBQUcsQ0FBdkI7QUFDQWl6QixRQUFBQSxTQUFTLEdBQUcsTUFBTUEsU0FBbEI7QUFDRDs7QUFFRHU0QixNQUFBQSxNQUFNLEdBQUduOUQsTUFBTSxDQUFDQyxJQUFJLENBQUNnaUIsSUFBTCxDQUFVN1csQ0FBQyxHQUFHQSxDQUFKLEdBQVEyUixDQUFDLEdBQUdBLENBQVosR0FBZ0JELENBQUMsR0FBR0EsQ0FBOUIsQ0FBRCxDQUFmO0FBQ0FzZ0QsTUFBQUEsTUFBTSxHQUFHcDlELE1BQU0sQ0FBQ0MsSUFBSSxDQUFDZ2lCLElBQUwsQ0FBVW1nRCxHQUFHLEdBQUdBLEdBQU4sR0FBWU8sR0FBRyxHQUFHQSxHQUE1QixDQUFELENBQWY7QUFDQTU1QyxNQUFBQSxLQUFLLEdBQUc3RyxNQUFNLENBQUNpZ0QsR0FBRCxFQUFNQyxHQUFOLENBQWQ7QUFDQXQ5QixNQUFBQSxLQUFLLEdBQUc3a0MsSUFBSSxDQUFDMmIsR0FBTCxDQUFTbU4sS0FBVCxJQUFrQixNQUFsQixHQUEyQkEsS0FBSyxHQUFHam9CLFFBQW5DLEdBQThDLENBQXREO0FBQ0FvaEUsTUFBQUEsV0FBVyxHQUFHUSxHQUFHLEdBQUcsS0FBS0EsR0FBRyxHQUFHLENBQU4sR0FBVSxDQUFDQSxHQUFYLEdBQWlCQSxHQUF0QixDQUFILEdBQWdDLENBQWpEO0FBQ0Q7O0FBRUQsUUFBSXp0QyxLQUFLLENBQUNuQixHQUFWLEVBQWU7QUFDYjtBQUNBNkcsTUFBQUEsRUFBRSxHQUFHNTFCLE1BQU0sQ0FBQzJHLFlBQVAsQ0FBb0IsV0FBcEIsQ0FBTDtBQUNBdXBCLE1BQUFBLEtBQUssQ0FBQzJ0QyxRQUFOLEdBQWlCNzlELE1BQU0sQ0FBQ3VpQixZQUFQLENBQW9CLFdBQXBCLEVBQWlDLEVBQWpDLEtBQXdDLENBQUNxNUMsZ0JBQWdCLENBQUNwRCxvQkFBb0IsQ0FBQ3g0RCxNQUFELEVBQVNqRixjQUFULENBQXJCLENBQTFFO0FBQ0E2NkIsTUFBQUEsRUFBRSxJQUFJNTFCLE1BQU0sQ0FBQ3VpQixZQUFQLENBQW9CLFdBQXBCLEVBQWlDcVQsRUFBakMsQ0FBTjtBQUNEO0FBQ0Y7O0FBRUQsTUFBSTE2QixJQUFJLENBQUMyYixHQUFMLENBQVNrcEIsS0FBVCxJQUFrQixFQUFsQixJQUF3QjdrQyxJQUFJLENBQUMyYixHQUFMLENBQVNrcEIsS0FBVCxJQUFrQixHQUE5QyxFQUFtRDtBQUNqRCxRQUFJazlCLGNBQUosRUFBb0I7QUFDbEI3RSxNQUFBQSxNQUFNLElBQUksQ0FBQyxDQUFYO0FBQ0FyNEIsTUFBQUEsS0FBSyxJQUFJbnpCLFFBQVEsSUFBSSxDQUFaLEdBQWdCLEdBQWhCLEdBQXNCLENBQUMsR0FBaEM7QUFDQUEsTUFBQUEsUUFBUSxJQUFJQSxRQUFRLElBQUksQ0FBWixHQUFnQixHQUFoQixHQUFzQixDQUFDLEdBQW5DO0FBQ0QsS0FKRCxNQUlPO0FBQ0x5ckQsTUFBQUEsTUFBTSxJQUFJLENBQUMsQ0FBWDtBQUNBdDRCLE1BQUFBLEtBQUssSUFBSUEsS0FBSyxJQUFJLENBQVQsR0FBYSxHQUFiLEdBQW1CLENBQUMsR0FBN0I7QUFDRDtBQUNGOztBQUVEN3RCLEVBQUFBLE9BQU8sR0FBR0EsT0FBTyxJQUFJZ2UsS0FBSyxDQUFDaGUsT0FBM0I7QUFDQWdlLEVBQUFBLEtBQUssQ0FBQ3p1QixDQUFOLEdBQVVBLENBQUMsSUFBSSxDQUFDeXVCLEtBQUssQ0FBQ3dQLFFBQU4sR0FBaUJqK0IsQ0FBQyxLQUFLLENBQUN5USxPQUFELElBQVlnZSxLQUFLLENBQUN3UCxRQUFsQixLQUErQnhrQyxJQUFJLENBQUNDLEtBQUwsQ0FBVzZFLE1BQU0sQ0FBQ2d2QixXQUFQLEdBQXFCLENBQWhDLE1BQXVDOXpCLElBQUksQ0FBQ0MsS0FBTCxDQUFXLENBQUNzRyxDQUFaLENBQXZDLEdBQXdELENBQUMsRUFBekQsR0FBOEQsQ0FBN0YsQ0FBTCxDQUFuQixJQUE0SHpCLE1BQU0sQ0FBQ2d2QixXQUFQLEdBQXFCa0IsS0FBSyxDQUFDd1AsUUFBM0IsR0FBc0MsR0FBbEssR0FBd0ssQ0FBNUssQ0FBRCxHQUFrTGhULEVBQTVMO0FBQ0F3RCxFQUFBQSxLQUFLLENBQUN4dUIsQ0FBTixHQUFVQSxDQUFDLElBQUksQ0FBQ3d1QixLQUFLLENBQUN5UCxRQUFOLEdBQWlCaitCLENBQUMsS0FBSyxDQUFDd1EsT0FBRCxJQUFZZ2UsS0FBSyxDQUFDeVAsUUFBbEIsS0FBK0J6a0MsSUFBSSxDQUFDQyxLQUFMLENBQVc2RSxNQUFNLENBQUNrSyxZQUFQLEdBQXNCLENBQWpDLE1BQXdDaFAsSUFBSSxDQUFDQyxLQUFMLENBQVcsQ0FBQ3VHLENBQVosQ0FBeEMsR0FBeUQsQ0FBQyxFQUExRCxHQUErRCxDQUE5RixDQUFMLENBQW5CLElBQTZIMUIsTUFBTSxDQUFDa0ssWUFBUCxHQUFzQmdtQixLQUFLLENBQUN5UCxRQUE1QixHQUF1QyxHQUFwSyxHQUEwSyxDQUE5SyxDQUFELEdBQW9MalQsRUFBOUw7QUFDQXdELEVBQUFBLEtBQUssQ0FBQ2d0QyxDQUFOLEdBQVVBLENBQUMsR0FBR3h3QyxFQUFkO0FBQ0F3RCxFQUFBQSxLQUFLLENBQUNrb0MsTUFBTixHQUFlbjlELE1BQU0sQ0FBQ205RCxNQUFELENBQXJCO0FBQ0Fsb0MsRUFBQUEsS0FBSyxDQUFDbW9DLE1BQU4sR0FBZXA5RCxNQUFNLENBQUNvOUQsTUFBRCxDQUFyQjtBQUNBbm9DLEVBQUFBLEtBQUssQ0FBQ3RqQixRQUFOLEdBQWlCM1IsTUFBTSxDQUFDMlIsUUFBRCxDQUFOLEdBQW1CcXRELEdBQXBDO0FBQ0EvcEMsRUFBQUEsS0FBSyxDQUFDMFAsU0FBTixHQUFrQjNrQyxNQUFNLENBQUMya0MsU0FBRCxDQUFOLEdBQW9CcTZCLEdBQXRDO0FBQ0EvcEMsRUFBQUEsS0FBSyxDQUFDMlAsU0FBTixHQUFrQjVrQyxNQUFNLENBQUM0a0MsU0FBRCxDQUFOLEdBQW9CbzZCLEdBQXRDO0FBQ0EvcEMsRUFBQUEsS0FBSyxDQUFDNlAsS0FBTixHQUFjQSxLQUFLLEdBQUdrNkIsR0FBdEI7QUFDQS9wQyxFQUFBQSxLQUFLLENBQUM4UCxLQUFOLEdBQWNBLEtBQUssR0FBR2k2QixHQUF0QjtBQUNBL3BDLEVBQUFBLEtBQUssQ0FBQzR0QyxvQkFBTixHQUE2QlgsV0FBVyxHQUFHendDLEVBQTNDOztBQUVBLE1BQUl3RCxLQUFLLENBQUM0cUMsT0FBTixHQUFnQm4xRCxVQUFVLENBQUNrcEIsTUFBTSxDQUFDbGpCLEtBQVAsQ0FBYSxHQUFiLEVBQWtCLENBQWxCLENBQUQsQ0FBVixJQUFvQyxDQUF4RCxFQUEyRDtBQUN6RDdQLElBQUFBLEtBQUssQ0FBQ2Qsb0JBQUQsQ0FBTCxHQUE4QjYvRCxhQUFhLENBQUNoc0MsTUFBRCxDQUEzQztBQUNEOztBQUVEcUIsRUFBQUEsS0FBSyxDQUFDMHNDLE9BQU4sR0FBZ0Ixc0MsS0FBSyxDQUFDNHNDLE9BQU4sR0FBZ0IsQ0FBaEM7QUFDQTVzQyxFQUFBQSxLQUFLLENBQUNsbkIsT0FBTixHQUFnQjJzQyxlQUFoQjtBQUNBemxCLEVBQUFBLEtBQUssQ0FBQ3RlLGVBQU4sR0FBd0JzZSxLQUFLLENBQUNuQixHQUFOLEdBQVlndkMsb0JBQVosR0FBbUN2MkQsV0FBVyxHQUFHdzJELG9CQUFILEdBQTBCQyxzQkFBaEc7QUFDQS90QyxFQUFBQSxLQUFLLENBQUNoZSxPQUFOLEdBQWdCLENBQWhCO0FBQ0EsU0FBT2dlLEtBQVA7QUFDRCxDQXAyQkQ7QUFBQSxJQXEyQkkycUMsYUFBYSxHQUFHLFNBQVNBLGFBQVQsQ0FBdUJsZ0UsS0FBdkIsRUFBOEI7QUFDaEQsU0FBTyxDQUFDQSxLQUFLLEdBQUdBLEtBQUssQ0FBQ2dSLEtBQU4sQ0FBWSxHQUFaLENBQVQsRUFBMkIsQ0FBM0IsSUFBZ0MsR0FBaEMsR0FBc0NoUixLQUFLLENBQUMsQ0FBRCxDQUFsRDtBQUNELENBdjJCRDtBQUFBLElBdzJCSTtBQUNKdWpFLGVBQWUsR0FBRyxTQUFTQSxlQUFULENBQXlCbCtELE1BQXpCLEVBQWlDNFUsS0FBakMsRUFBd0NqYSxLQUF4QyxFQUErQztBQUMvRCxNQUFJb1UsSUFBSSxHQUFHZ2lCLE9BQU8sQ0FBQ25jLEtBQUQsQ0FBbEI7QUFDQSxTQUFPM1osTUFBTSxDQUFDMEssVUFBVSxDQUFDaVAsS0FBRCxDQUFWLEdBQW9CalAsVUFBVSxDQUFDeTBELGNBQWMsQ0FBQ3A2RCxNQUFELEVBQVMsR0FBVCxFQUFjckYsS0FBSyxHQUFHLElBQXRCLEVBQTRCb1UsSUFBNUIsQ0FBZixDQUEvQixDQUFOLEdBQTBGQSxJQUFqRztBQUNELENBNTJCRDtBQUFBLElBNjJCSWt2RCxzQkFBc0IsR0FBRyxTQUFTQSxzQkFBVCxDQUFnQ3hqRCxLQUFoQyxFQUF1Q3lWLEtBQXZDLEVBQThDO0FBQ3pFQSxFQUFBQSxLQUFLLENBQUNndEMsQ0FBTixHQUFVLEtBQVY7QUFDQWh0QyxFQUFBQSxLQUFLLENBQUMyUCxTQUFOLEdBQWtCM1AsS0FBSyxDQUFDMFAsU0FBTixHQUFrQixNQUFwQztBQUNBMVAsRUFBQUEsS0FBSyxDQUFDbG5CLE9BQU4sR0FBZ0IsQ0FBaEI7O0FBRUFnMUQsRUFBQUEsb0JBQW9CLENBQUN2akQsS0FBRCxFQUFReVYsS0FBUixDQUFwQjtBQUNELENBbjNCRDtBQUFBLElBbzNCSWl1QyxRQUFRLEdBQUcsTUFwM0JmO0FBQUEsSUFxM0JJQyxPQUFPLEdBQUcsS0FyM0JkO0FBQUEsSUFzM0JJQyxlQUFlLEdBQUcsSUF0M0J0QjtBQUFBLElBdTNCSUwsb0JBQW9CLEdBQUcsU0FBU0Esb0JBQVQsQ0FBOEJ2akQsS0FBOUIsRUFBcUN5VixLQUFyQyxFQUE0QztBQUNyRSxNQUFJUixJQUFJLEdBQUdRLEtBQUssSUFBSSxJQUFwQjtBQUFBLE1BQ0l3UCxRQUFRLEdBQUdoUSxJQUFJLENBQUNnUSxRQURwQjtBQUFBLE1BRUlDLFFBQVEsR0FBR2pRLElBQUksQ0FBQ2lRLFFBRnBCO0FBQUEsTUFHSWwrQixDQUFDLEdBQUdpdUIsSUFBSSxDQUFDanVCLENBSGI7QUFBQSxNQUlJQyxDQUFDLEdBQUdndUIsSUFBSSxDQUFDaHVCLENBSmI7QUFBQSxNQUtJdzdELENBQUMsR0FBR3h0QyxJQUFJLENBQUN3dEMsQ0FMYjtBQUFBLE1BTUl0d0QsUUFBUSxHQUFHOGlCLElBQUksQ0FBQzlpQixRQU5wQjtBQUFBLE1BT0lpekIsU0FBUyxHQUFHblEsSUFBSSxDQUFDbVEsU0FQckI7QUFBQSxNQVFJRCxTQUFTLEdBQUdsUSxJQUFJLENBQUNrUSxTQVJyQjtBQUFBLE1BU0lHLEtBQUssR0FBR3JRLElBQUksQ0FBQ3FRLEtBVGpCO0FBQUEsTUFVSUMsS0FBSyxHQUFHdFEsSUFBSSxDQUFDc1EsS0FWakI7QUFBQSxNQVdJbzRCLE1BQU0sR0FBRzFvQyxJQUFJLENBQUMwb0MsTUFYbEI7QUFBQSxNQVlJQyxNQUFNLEdBQUczb0MsSUFBSSxDQUFDMm9DLE1BWmxCO0FBQUEsTUFhSXlGLG9CQUFvQixHQUFHcHVDLElBQUksQ0FBQ291QyxvQkFiaEM7QUFBQSxNQWNJOTBELE9BQU8sR0FBRzBtQixJQUFJLENBQUMxbUIsT0FkbkI7QUFBQSxNQWVJaEosTUFBTSxHQUFHMHZCLElBQUksQ0FBQzF2QixNQWZsQjtBQUFBLE1BZ0JJODZELE9BQU8sR0FBR3ByQyxJQUFJLENBQUNvckMsT0FoQm5CO0FBQUEsTUFpQkl3RCxVQUFVLEdBQUcsRUFqQmpCO0FBQUEsTUFrQklDLEtBQUssR0FBR3YxRCxPQUFPLEtBQUssTUFBWixJQUFzQnlSLEtBQXRCLElBQStCQSxLQUFLLEtBQUssQ0FBekMsSUFBOEN6UixPQUFPLEtBQUssSUFsQnRFLENBRHFFLENBbUJPOzs7QUFHNUUsTUFBSTh4RCxPQUFPLEtBQUtsN0IsU0FBUyxLQUFLdStCLFFBQWQsSUFBMEJ0K0IsU0FBUyxLQUFLcytCLFFBQTdDLENBQVgsRUFBbUU7QUFDakUsUUFBSW42QyxLQUFLLEdBQUdyZSxVQUFVLENBQUNrNkIsU0FBRCxDQUFWLEdBQXdCbGpCLFFBQXBDO0FBQUEsUUFDSTRnRCxHQUFHLEdBQUdyaUUsSUFBSSxDQUFDMmhCLEdBQUwsQ0FBU21ILEtBQVQsQ0FEVjtBQUFBLFFBRUl5NUMsR0FBRyxHQUFHdmlFLElBQUksQ0FBQzZoQixHQUFMLENBQVNpSCxLQUFULENBRlY7QUFBQSxRQUdJakgsR0FISjs7QUFLQWlILElBQUFBLEtBQUssR0FBR3JlLFVBQVUsQ0FBQ2k2QixTQUFELENBQVYsR0FBd0JqakIsUUFBaEM7QUFDQUksSUFBQUEsR0FBRyxHQUFHN2hCLElBQUksQ0FBQzZoQixHQUFMLENBQVNpSCxLQUFULENBQU47QUFDQXZpQixJQUFBQSxDQUFDLEdBQUd5OEQsZUFBZSxDQUFDbCtELE1BQUQsRUFBU3lCLENBQVQsRUFBWTg3RCxHQUFHLEdBQUd4Z0QsR0FBTixHQUFZLENBQUMrOUMsT0FBekIsQ0FBbkI7QUFDQXA1RCxJQUFBQSxDQUFDLEdBQUd3OEQsZUFBZSxDQUFDbCtELE1BQUQsRUFBUzBCLENBQVQsRUFBWSxDQUFDeEcsSUFBSSxDQUFDMmhCLEdBQUwsQ0FBU21ILEtBQVQsQ0FBRCxHQUFtQixDQUFDODJDLE9BQWhDLENBQW5CO0FBQ0FvQyxJQUFBQSxDQUFDLEdBQUdnQixlQUFlLENBQUNsK0QsTUFBRCxFQUFTazlELENBQVQsRUFBWU8sR0FBRyxHQUFHMWdELEdBQU4sR0FBWSxDQUFDKzlDLE9BQWIsR0FBdUJBLE9BQW5DLENBQW5CO0FBQ0Q7O0FBRUQsTUFBSWdELG9CQUFvQixLQUFLTSxPQUE3QixFQUFzQztBQUNwQ0UsSUFBQUEsVUFBVSxJQUFJLGlCQUFpQlIsb0JBQWpCLEdBQXdDTyxlQUF0RDtBQUNEOztBQUVELE1BQUkzK0IsUUFBUSxJQUFJQyxRQUFoQixFQUEwQjtBQUN4QjIrQixJQUFBQSxVQUFVLElBQUksZUFBZTUrQixRQUFmLEdBQTBCLEtBQTFCLEdBQWtDQyxRQUFsQyxHQUE2QyxLQUEzRDtBQUNEOztBQUVELE1BQUk0K0IsS0FBSyxJQUFJOThELENBQUMsS0FBSzI4RCxPQUFmLElBQTBCMThELENBQUMsS0FBSzA4RCxPQUFoQyxJQUEyQ2xCLENBQUMsS0FBS2tCLE9BQXJELEVBQThEO0FBQzVERSxJQUFBQSxVQUFVLElBQUlwQixDQUFDLEtBQUtrQixPQUFOLElBQWlCRyxLQUFqQixHQUF5QixpQkFBaUI5OEQsQ0FBakIsR0FBcUIsSUFBckIsR0FBNEJDLENBQTVCLEdBQWdDLElBQWhDLEdBQXVDdzdELENBQXZDLEdBQTJDLElBQXBFLEdBQTJFLGVBQWV6N0QsQ0FBZixHQUFtQixJQUFuQixHQUEwQkMsQ0FBMUIsR0FBOEIyOEQsZUFBdkg7QUFDRDs7QUFFRCxNQUFJenhELFFBQVEsS0FBS3V4RCxRQUFqQixFQUEyQjtBQUN6QkcsSUFBQUEsVUFBVSxJQUFJLFlBQVkxeEQsUUFBWixHQUF1Qnl4RCxlQUFyQztBQUNEOztBQUVELE1BQUl4K0IsU0FBUyxLQUFLcytCLFFBQWxCLEVBQTRCO0FBQzFCRyxJQUFBQSxVQUFVLElBQUksYUFBYXorQixTQUFiLEdBQXlCdytCLGVBQXZDO0FBQ0Q7O0FBRUQsTUFBSXorQixTQUFTLEtBQUt1K0IsUUFBbEIsRUFBNEI7QUFDMUJHLElBQUFBLFVBQVUsSUFBSSxhQUFhMStCLFNBQWIsR0FBeUJ5K0IsZUFBdkM7QUFDRDs7QUFFRCxNQUFJdCtCLEtBQUssS0FBS28rQixRQUFWLElBQXNCbitCLEtBQUssS0FBS20rQixRQUFwQyxFQUE4QztBQUM1Q0csSUFBQUEsVUFBVSxJQUFJLFVBQVV2K0IsS0FBVixHQUFrQixJQUFsQixHQUF5QkMsS0FBekIsR0FBaUNxK0IsZUFBL0M7QUFDRDs7QUFFRCxNQUFJakcsTUFBTSxLQUFLLENBQVgsSUFBZ0JDLE1BQU0sS0FBSyxDQUEvQixFQUFrQztBQUNoQ2lHLElBQUFBLFVBQVUsSUFBSSxXQUFXbEcsTUFBWCxHQUFvQixJQUFwQixHQUEyQkMsTUFBM0IsR0FBb0NnRyxlQUFsRDtBQUNEOztBQUVEcitELEVBQUFBLE1BQU0sQ0FBQ2xFLEtBQVAsQ0FBYWYsY0FBYixJQUErQnVqRSxVQUFVLElBQUksaUJBQTdDO0FBQ0QsQ0EzN0JEO0FBQUEsSUE0N0JJUCxvQkFBb0IsR0FBRyxTQUFTQSxvQkFBVCxDQUE4QnRqRCxLQUE5QixFQUFxQ3lWLEtBQXJDLEVBQTRDO0FBQ3JFLE1BQUl5TixLQUFLLEdBQUd6TixLQUFLLElBQUksSUFBckI7QUFBQSxNQUNJd1AsUUFBUSxHQUFHL0IsS0FBSyxDQUFDK0IsUUFEckI7QUFBQSxNQUVJQyxRQUFRLEdBQUdoQyxLQUFLLENBQUNnQyxRQUZyQjtBQUFBLE1BR0lsK0IsQ0FBQyxHQUFHazhCLEtBQUssQ0FBQ2w4QixDQUhkO0FBQUEsTUFJSUMsQ0FBQyxHQUFHaThCLEtBQUssQ0FBQ2o4QixDQUpkO0FBQUEsTUFLSWtMLFFBQVEsR0FBRyt3QixLQUFLLENBQUMvd0IsUUFMckI7QUFBQSxNQU1JbXpCLEtBQUssR0FBR3BDLEtBQUssQ0FBQ29DLEtBTmxCO0FBQUEsTUFPSUMsS0FBSyxHQUFHckMsS0FBSyxDQUFDcUMsS0FQbEI7QUFBQSxNQVFJbzRCLE1BQU0sR0FBR3o2QixLQUFLLENBQUN5NkIsTUFSbkI7QUFBQSxNQVNJQyxNQUFNLEdBQUcxNkIsS0FBSyxDQUFDMDZCLE1BVG5CO0FBQUEsTUFVSXI0RCxNQUFNLEdBQUcyOUIsS0FBSyxDQUFDMzlCLE1BVm5CO0FBQUEsTUFXSW9WLE9BQU8sR0FBR3VvQixLQUFLLENBQUN2b0IsT0FYcEI7QUFBQSxNQVlJQyxPQUFPLEdBQUdzb0IsS0FBSyxDQUFDdG9CLE9BWnBCO0FBQUEsTUFhSXVuRCxPQUFPLEdBQUdqL0IsS0FBSyxDQUFDaS9CLE9BYnBCO0FBQUEsTUFjSUUsT0FBTyxHQUFHbi9CLEtBQUssQ0FBQ20vQixPQWRwQjtBQUFBLE1BZUllLFFBQVEsR0FBR2xnQyxLQUFLLENBQUNrZ0MsUUFmckI7QUFBQSxNQWdCSTUzQyxFQUFFLEdBQUd0Z0IsVUFBVSxDQUFDbEUsQ0FBRCxDQWhCbkI7QUFBQSxNQWlCSXlrQixFQUFFLEdBQUd2Z0IsVUFBVSxDQUFDakUsQ0FBRCxDQWpCbkI7QUFBQSxNQWtCSTg4RCxHQWxCSjtBQUFBLE1BbUJJQyxHQW5CSjtBQUFBLE1Bb0JJckIsR0FwQko7QUFBQSxNQXFCSUMsR0FyQko7QUFBQSxNQXNCSXZsRCxJQXRCSjs7QUF3QkFsTCxFQUFBQSxRQUFRLEdBQUdqSCxVQUFVLENBQUNpSCxRQUFELENBQXJCO0FBQ0FtekIsRUFBQUEsS0FBSyxHQUFHcDZCLFVBQVUsQ0FBQ282QixLQUFELENBQWxCO0FBQ0FDLEVBQUFBLEtBQUssR0FBR3I2QixVQUFVLENBQUNxNkIsS0FBRCxDQUFsQjs7QUFFQSxNQUFJQSxLQUFKLEVBQVc7QUFDVDtBQUNBQSxJQUFBQSxLQUFLLEdBQUdyNkIsVUFBVSxDQUFDcTZCLEtBQUQsQ0FBbEI7QUFDQUQsSUFBQUEsS0FBSyxJQUFJQyxLQUFUO0FBQ0FwekIsSUFBQUEsUUFBUSxJQUFJb3pCLEtBQVo7QUFDRDs7QUFFRCxNQUFJcHpCLFFBQVEsSUFBSW16QixLQUFoQixFQUF1QjtBQUNyQm56QixJQUFBQSxRQUFRLElBQUkrUCxRQUFaO0FBQ0FvakIsSUFBQUEsS0FBSyxJQUFJcGpCLFFBQVQ7QUFDQTZoRCxJQUFBQSxHQUFHLEdBQUd0akUsSUFBSSxDQUFDNmhCLEdBQUwsQ0FBU25RLFFBQVQsSUFBcUJ3ckQsTUFBM0I7QUFDQXFHLElBQUFBLEdBQUcsR0FBR3ZqRSxJQUFJLENBQUMyaEIsR0FBTCxDQUFTalEsUUFBVCxJQUFxQndyRCxNQUEzQjtBQUNBZ0YsSUFBQUEsR0FBRyxHQUFHbGlFLElBQUksQ0FBQzJoQixHQUFMLENBQVNqUSxRQUFRLEdBQUdtekIsS0FBcEIsSUFBNkIsQ0FBQ3M0QixNQUFwQztBQUNBZ0YsSUFBQUEsR0FBRyxHQUFHbmlFLElBQUksQ0FBQzZoQixHQUFMLENBQVNuUSxRQUFRLEdBQUdtekIsS0FBcEIsSUFBNkJzNEIsTUFBbkM7O0FBRUEsUUFBSXQ0QixLQUFKLEVBQVc7QUFDVEMsTUFBQUEsS0FBSyxJQUFJcmpCLFFBQVQ7QUFDQTdFLE1BQUFBLElBQUksR0FBRzVjLElBQUksQ0FBQ3dqRSxHQUFMLENBQVMzK0IsS0FBSyxHQUFHQyxLQUFqQixDQUFQO0FBQ0Fsb0IsTUFBQUEsSUFBSSxHQUFHNWMsSUFBSSxDQUFDZ2lCLElBQUwsQ0FBVSxJQUFJcEYsSUFBSSxHQUFHQSxJQUFyQixDQUFQO0FBQ0FzbEQsTUFBQUEsR0FBRyxJQUFJdGxELElBQVA7QUFDQXVsRCxNQUFBQSxHQUFHLElBQUl2bEQsSUFBUDs7QUFFQSxVQUFJa29CLEtBQUosRUFBVztBQUNUbG9CLFFBQUFBLElBQUksR0FBRzVjLElBQUksQ0FBQ3dqRSxHQUFMLENBQVMxK0IsS0FBVCxDQUFQO0FBQ0Fsb0IsUUFBQUEsSUFBSSxHQUFHNWMsSUFBSSxDQUFDZ2lCLElBQUwsQ0FBVSxJQUFJcEYsSUFBSSxHQUFHQSxJQUFyQixDQUFQO0FBQ0EwbUQsUUFBQUEsR0FBRyxJQUFJMW1ELElBQVA7QUFDQTJtRCxRQUFBQSxHQUFHLElBQUkzbUQsSUFBUDtBQUNEO0FBQ0Y7O0FBRUQwbUQsSUFBQUEsR0FBRyxHQUFHdmpFLE1BQU0sQ0FBQ3VqRSxHQUFELENBQVo7QUFDQUMsSUFBQUEsR0FBRyxHQUFHeGpFLE1BQU0sQ0FBQ3dqRSxHQUFELENBQVo7QUFDQXJCLElBQUFBLEdBQUcsR0FBR25pRSxNQUFNLENBQUNtaUUsR0FBRCxDQUFaO0FBQ0FDLElBQUFBLEdBQUcsR0FBR3BpRSxNQUFNLENBQUNvaUUsR0FBRCxDQUFaO0FBQ0QsR0EzQkQsTUEyQk87QUFDTG1CLElBQUFBLEdBQUcsR0FBR3BHLE1BQU47QUFDQWlGLElBQUFBLEdBQUcsR0FBR2hGLE1BQU47QUFDQW9HLElBQUFBLEdBQUcsR0FBR3JCLEdBQUcsR0FBRyxDQUFaO0FBQ0Q7O0FBRUQsTUFBSW4zQyxFQUFFLElBQUksQ0FBQyxDQUFDLENBQUN4a0IsQ0FBQyxHQUFHLEVBQUwsRUFBU3VKLE9BQVQsQ0FBaUIsSUFBakIsQ0FBUixJQUFrQ2tiLEVBQUUsSUFBSSxDQUFDLENBQUMsQ0FBQ3hrQixDQUFDLEdBQUcsRUFBTCxFQUFTc0osT0FBVCxDQUFpQixJQUFqQixDQUE5QyxFQUFzRTtBQUNwRWliLElBQUFBLEVBQUUsR0FBR20wQyxjQUFjLENBQUNwNkQsTUFBRCxFQUFTLEdBQVQsRUFBY3lCLENBQWQsRUFBaUIsSUFBakIsQ0FBbkI7QUFDQXlrQixJQUFBQSxFQUFFLEdBQUdrMEMsY0FBYyxDQUFDcDZELE1BQUQsRUFBUyxHQUFULEVBQWMwQixDQUFkLEVBQWlCLElBQWpCLENBQW5CO0FBQ0Q7O0FBRUQsTUFBSTBULE9BQU8sSUFBSUMsT0FBWCxJQUFzQnVuRCxPQUF0QixJQUFpQ0UsT0FBckMsRUFBOEM7QUFDNUM3MkMsSUFBQUEsRUFBRSxHQUFHaHJCLE1BQU0sQ0FBQ2dyQixFQUFFLEdBQUc3USxPQUFMLElBQWdCQSxPQUFPLEdBQUdvcEQsR0FBVixHQUFnQm5wRCxPQUFPLEdBQUcrbkQsR0FBMUMsSUFBaURSLE9BQWxELENBQVg7QUFDQTEyQyxJQUFBQSxFQUFFLEdBQUdqckIsTUFBTSxDQUFDaXJCLEVBQUUsR0FBRzdRLE9BQUwsSUFBZ0JELE9BQU8sR0FBR3FwRCxHQUFWLEdBQWdCcHBELE9BQU8sR0FBR2dvRCxHQUExQyxJQUFpRFAsT0FBbEQsQ0FBWDtBQUNEOztBQUVELE1BQUlwOUIsUUFBUSxJQUFJQyxRQUFoQixFQUEwQjtBQUN4QjtBQUNBN25CLElBQUFBLElBQUksR0FBRzlYLE1BQU0sQ0FBQzhFLE9BQVAsRUFBUDtBQUNBbWhCLElBQUFBLEVBQUUsR0FBR2hyQixNQUFNLENBQUNnckIsRUFBRSxHQUFHeVosUUFBUSxHQUFHLEdBQVgsR0FBaUI1bkIsSUFBSSxDQUFDcFYsS0FBNUIsQ0FBWDtBQUNBd2pCLElBQUFBLEVBQUUsR0FBR2pyQixNQUFNLENBQUNpckIsRUFBRSxHQUFHeVosUUFBUSxHQUFHLEdBQVgsR0FBaUI3bkIsSUFBSSxDQUFDaFYsTUFBNUIsQ0FBWDtBQUNEOztBQUVEZ1YsRUFBQUEsSUFBSSxHQUFHLFlBQVkwbUQsR0FBWixHQUFrQixHQUFsQixHQUF3QkMsR0FBeEIsR0FBOEIsR0FBOUIsR0FBb0NyQixHQUFwQyxHQUEwQyxHQUExQyxHQUFnREMsR0FBaEQsR0FBc0QsR0FBdEQsR0FBNERwM0MsRUFBNUQsR0FBaUUsR0FBakUsR0FBdUVDLEVBQXZFLEdBQTRFLEdBQW5GO0FBQ0FsbUIsRUFBQUEsTUFBTSxDQUFDdWlCLFlBQVAsQ0FBb0IsV0FBcEIsRUFBaUN6SyxJQUFqQztBQUNBK2xELEVBQUFBLFFBQVEsS0FBSzc5RCxNQUFNLENBQUNsRSxLQUFQLENBQWFmLGNBQWIsSUFBK0IrYyxJQUFwQyxDQUFSLENBeEZxRSxDQXdGbEI7QUFDcEQsQ0FyaENEO0FBQUEsSUFzaENJNm1ELHVCQUF1QixHQUFHLFNBQVNBLHVCQUFULENBQWlDendDLE1BQWpDLEVBQXlDbHVCLE1BQXpDLEVBQWlEZ0MsUUFBakQsRUFBMkRvdUQsUUFBM0QsRUFBcUV4akIsUUFBckUsRUFBK0U7QUFDM0csTUFBSWd5QixHQUFHLEdBQUcsR0FBVjtBQUFBLE1BQ0kvYixRQUFRLEdBQUd4bEMsU0FBUyxDQUFDdXZCLFFBQUQsQ0FEeEI7QUFBQSxNQUVJc2pCLE1BQU0sR0FBR3ZxRCxVQUFVLENBQUNpbkMsUUFBRCxDQUFWLElBQXdCaVcsUUFBUSxJQUFJLENBQUNqVyxRQUFRLENBQUM1aEMsT0FBVCxDQUFpQixLQUFqQixDQUFiLEdBQXVDalAsUUFBdkMsR0FBa0QsQ0FBMUUsQ0FGYjtBQUFBLE1BR0l3dUMsTUFBTSxHQUFHMmxCLE1BQU0sR0FBR0UsUUFIdEI7QUFBQSxNQUlJeU8sVUFBVSxHQUFHek8sUUFBUSxHQUFHN2xCLE1BQVgsR0FBb0IsS0FKckM7QUFBQSxNQUtJN3ZCLFNBTEo7QUFBQSxNQU1JNFYsRUFOSjs7QUFRQSxNQUFJdXlCLFFBQUosRUFBYztBQUNabm9DLElBQUFBLFNBQVMsR0FBR2t5QixRQUFRLENBQUNqaEMsS0FBVCxDQUFlLEdBQWYsRUFBb0IsQ0FBcEIsQ0FBWjs7QUFFQSxRQUFJK08sU0FBUyxLQUFLLE9BQWxCLEVBQTJCO0FBQ3pCNnZCLE1BQUFBLE1BQU0sSUFBSXEwQixHQUFWOztBQUVBLFVBQUlyMEIsTUFBTSxLQUFLQSxNQUFNLElBQUlxMEIsR0FBRyxHQUFHLENBQVYsQ0FBckIsRUFBbUM7QUFDakNyMEIsUUFBQUEsTUFBTSxJQUFJQSxNQUFNLEdBQUcsQ0FBVCxHQUFhcTBCLEdBQWIsR0FBbUIsQ0FBQ0EsR0FBOUI7QUFDRDtBQUNGOztBQUVELFFBQUlsa0QsU0FBUyxLQUFLLElBQWQsSUFBc0I2dkIsTUFBTSxHQUFHLENBQW5DLEVBQXNDO0FBQ3BDQSxNQUFBQSxNQUFNLEdBQUcsQ0FBQ0EsTUFBTSxHQUFHcTBCLEdBQUcsR0FBRzNpRSxnQkFBaEIsSUFBMkIyaUUsR0FBM0IsR0FBaUMsQ0FBQyxFQUFFcjBCLE1BQU0sR0FBR3EwQixHQUFYLENBQUQsR0FBbUJBLEdBQTdEO0FBQ0QsS0FGRCxNQUVPLElBQUlsa0QsU0FBUyxLQUFLLEtBQWQsSUFBdUI2dkIsTUFBTSxHQUFHLENBQXBDLEVBQXVDO0FBQzVDQSxNQUFBQSxNQUFNLEdBQUcsQ0FBQ0EsTUFBTSxHQUFHcTBCLEdBQUcsR0FBRzNpRSxnQkFBaEIsSUFBMkIyaUUsR0FBM0IsR0FBaUMsQ0FBQyxFQUFFcjBCLE1BQU0sR0FBR3EwQixHQUFYLENBQUQsR0FBbUJBLEdBQTdEO0FBQ0Q7QUFDRjs7QUFFRDF3QyxFQUFBQSxNQUFNLENBQUNxQyxHQUFQLEdBQWFELEVBQUUsR0FBRyxJQUFJN0MsU0FBSixDQUFjUyxNQUFNLENBQUNxQyxHQUFyQixFQUEwQnZ3QixNQUExQixFQUFrQ2dDLFFBQWxDLEVBQTRDb3VELFFBQTVDLEVBQXNEN2xCLE1BQXRELEVBQThEbXRCLGtCQUE5RCxDQUFsQjtBQUNBcG5DLEVBQUFBLEVBQUUsQ0FBQzUwQixDQUFILEdBQU9takUsVUFBUDtBQUNBdnVDLEVBQUFBLEVBQUUsQ0FBQ0UsQ0FBSCxHQUFPLEtBQVA7O0FBRUF0QyxFQUFBQSxNQUFNLENBQUN3QyxNQUFQLENBQWMxeUIsSUFBZCxDQUFtQmdFLFFBQW5COztBQUVBLFNBQU9zdUIsRUFBUDtBQUNELENBeGpDRDtBQUFBLElBeWpDSXd1QyxPQUFPLEdBQUcsU0FBU0EsT0FBVCxDQUFpQjkrRCxNQUFqQixFQUF5QjZlLE1BQXpCLEVBQWlDO0FBQzdDO0FBQ0EsT0FBSyxJQUFJM2hCLENBQVQsSUFBYzJoQixNQUFkLEVBQXNCO0FBQ3BCN2UsSUFBQUEsTUFBTSxDQUFDOUMsQ0FBRCxDQUFOLEdBQVkyaEIsTUFBTSxDQUFDM2hCLENBQUQsQ0FBbEI7QUFDRDs7QUFFRCxTQUFPOEMsTUFBUDtBQUNELENBaGtDRDtBQUFBLElBaWtDSSsrRCxtQkFBbUIsR0FBRyxTQUFTQSxtQkFBVCxDQUE2Qjd3QyxNQUE3QixFQUFxQ293QyxVQUFyQyxFQUFpRHQrRCxNQUFqRCxFQUF5RDtBQUNqRjtBQUNBLE1BQUlnL0QsVUFBVSxHQUFHRixPQUFPLENBQUMsRUFBRCxFQUFLOStELE1BQU0sQ0FBQzBPLEtBQVosQ0FBeEI7QUFBQSxNQUNJdXdELE9BQU8sR0FBRywrQ0FEZDtBQUFBLE1BRUluakUsS0FBSyxHQUFHa0UsTUFBTSxDQUFDbEUsS0FGbkI7QUFBQSxNQUdJb2pFLFFBSEo7QUFBQSxNQUlJaGlFLENBSko7QUFBQSxNQUtJZytELFVBTEo7QUFBQSxNQU1JdHVCLFFBTko7QUFBQSxNQU9Jd2pCLFFBUEo7QUFBQSxNQVFJRixNQVJKO0FBQUEsTUFTSWtMLFNBVEo7QUFBQSxNQVVJRCxPQVZKOztBQVlBLE1BQUk2RCxVQUFVLENBQUNqd0MsR0FBZixFQUFvQjtBQUNsQm1zQyxJQUFBQSxVQUFVLEdBQUdsN0QsTUFBTSxDQUFDMkcsWUFBUCxDQUFvQixXQUFwQixDQUFiO0FBQ0EzRyxJQUFBQSxNQUFNLENBQUN1aUIsWUFBUCxDQUFvQixXQUFwQixFQUFpQyxFQUFqQztBQUNBem1CLElBQUFBLEtBQUssQ0FBQ2YsY0FBRCxDQUFMLEdBQXdCdWpFLFVBQXhCO0FBQ0FZLElBQUFBLFFBQVEsR0FBR3RFLGVBQWUsQ0FBQzU2RCxNQUFELEVBQVMsQ0FBVCxDQUExQjs7QUFFQTI1RCxJQUFBQSxlQUFlLENBQUMzNUQsTUFBRCxFQUFTakYsY0FBVCxDQUFmOztBQUVBaUYsSUFBQUEsTUFBTSxDQUFDdWlCLFlBQVAsQ0FBb0IsV0FBcEIsRUFBaUMyNEMsVUFBakM7QUFDRCxHQVRELE1BU087QUFDTEEsSUFBQUEsVUFBVSxHQUFHLzRELGdCQUFnQixDQUFDbkMsTUFBRCxDQUFoQixDQUF5QmpGLGNBQXpCLENBQWI7QUFDQWUsSUFBQUEsS0FBSyxDQUFDZixjQUFELENBQUwsR0FBd0J1akUsVUFBeEI7QUFDQVksSUFBQUEsUUFBUSxHQUFHdEUsZUFBZSxDQUFDNTZELE1BQUQsRUFBUyxDQUFULENBQTFCO0FBQ0FsRSxJQUFBQSxLQUFLLENBQUNmLGNBQUQsQ0FBTCxHQUF3Qm1nRSxVQUF4QjtBQUNEOztBQUVELE9BQUtoK0QsQ0FBTCxJQUFVaTZELGVBQVYsRUFBMkI7QUFDekIrRCxJQUFBQSxVQUFVLEdBQUc4RCxVQUFVLENBQUM5aEUsQ0FBRCxDQUF2QjtBQUNBMHZDLElBQUFBLFFBQVEsR0FBR3N5QixRQUFRLENBQUNoaUUsQ0FBRCxDQUFuQjs7QUFFQSxRQUFJZytELFVBQVUsS0FBS3R1QixRQUFmLElBQTJCcXlCLE9BQU8sQ0FBQ2owRCxPQUFSLENBQWdCOU4sQ0FBaEIsSUFBcUIsQ0FBcEQsRUFBdUQ7QUFDckQ7QUFDQWsrRCxNQUFBQSxTQUFTLEdBQUdycUMsT0FBTyxDQUFDbXFDLFVBQUQsQ0FBbkI7QUFDQUMsTUFBQUEsT0FBTyxHQUFHcHFDLE9BQU8sQ0FBQzZiLFFBQUQsQ0FBakI7QUFDQXdqQixNQUFBQSxRQUFRLEdBQUdnTCxTQUFTLEtBQUtELE9BQWQsR0FBd0JmLGNBQWMsQ0FBQ3A2RCxNQUFELEVBQVM5QyxDQUFULEVBQVlnK0QsVUFBWixFQUF3QkMsT0FBeEIsQ0FBdEMsR0FBeUV4MUQsVUFBVSxDQUFDdTFELFVBQUQsQ0FBOUY7QUFDQWhMLE1BQUFBLE1BQU0sR0FBR3ZxRCxVQUFVLENBQUNpbkMsUUFBRCxDQUFuQjtBQUNBMWUsTUFBQUEsTUFBTSxDQUFDcUMsR0FBUCxHQUFhLElBQUk5QyxTQUFKLENBQWNTLE1BQU0sQ0FBQ3FDLEdBQXJCLEVBQTBCMnVDLFFBQTFCLEVBQW9DaGlFLENBQXBDLEVBQXVDa3pELFFBQXZDLEVBQWlERixNQUFNLEdBQUdFLFFBQTFELEVBQW9FcUgsY0FBcEUsQ0FBYjtBQUNBdnBDLE1BQUFBLE1BQU0sQ0FBQ3FDLEdBQVAsQ0FBV0MsQ0FBWCxHQUFlMnFDLE9BQU8sSUFBSSxDQUExQjs7QUFFQWp0QyxNQUFBQSxNQUFNLENBQUN3QyxNQUFQLENBQWMxeUIsSUFBZCxDQUFtQmQsQ0FBbkI7QUFDRDtBQUNGOztBQUVENGhFLEVBQUFBLE9BQU8sQ0FBQ0ksUUFBRCxFQUFXRixVQUFYLENBQVA7QUFDRCxDQWpuQ0QsRUFpbkNHOzs7QUFHSHhtQixZQUFZLENBQUMsNkJBQUQsRUFBZ0MsVUFBVXI0QixJQUFWLEVBQWdCZixLQUFoQixFQUF1QjtBQUNqRSxNQUFJcEIsQ0FBQyxHQUFHLEtBQVI7QUFBQSxNQUNJN2EsQ0FBQyxHQUFHLE9BRFI7QUFBQSxNQUVJNlUsQ0FBQyxHQUFHLFFBRlI7QUFBQSxNQUdJMVIsQ0FBQyxHQUFHLE1BSFI7QUFBQSxNQUlJc2EsS0FBSyxHQUFHLENBQUN4QixLQUFLLEdBQUcsQ0FBUixHQUFZLENBQUNwQixDQUFELEVBQUk3YSxDQUFKLEVBQU82VSxDQUFQLEVBQVUxUixDQUFWLENBQVosR0FBMkIsQ0FBQzBYLENBQUMsR0FBRzFYLENBQUwsRUFBUTBYLENBQUMsR0FBRzdhLENBQVosRUFBZTZVLENBQUMsR0FBRzdVLENBQW5CLEVBQXNCNlUsQ0FBQyxHQUFHMVIsQ0FBMUIsQ0FBNUIsRUFBMER3VixHQUExRCxDQUE4RCxVQUFVaW5CLElBQVYsRUFBZ0I7QUFDeEYsV0FBTzNqQixLQUFLLEdBQUcsQ0FBUixHQUFZZSxJQUFJLEdBQUc0aUIsSUFBbkIsR0FBMEIsV0FBV0EsSUFBWCxHQUFrQjVpQixJQUFuRDtBQUNELEdBRlcsQ0FKWjs7QUFRQTQ2QyxFQUFBQSxhQUFhLENBQUMzN0MsS0FBSyxHQUFHLENBQVIsR0FBWSxXQUFXZSxJQUF2QixHQUE4QkEsSUFBL0IsQ0FBYixHQUFvRCxVQUFVK04sTUFBVixFQUFrQmx1QixNQUFsQixFQUEwQmdDLFFBQTFCLEVBQW9DNHFDLFFBQXBDLEVBQThDbjVCLEtBQTlDLEVBQXFEO0FBQ3ZHLFFBQUlwTixDQUFKLEVBQU81QyxJQUFQOztBQUVBLFFBQUl5RixTQUFTLENBQUMxTCxNQUFWLEdBQW1CLENBQXZCLEVBQTBCO0FBQ3hCO0FBQ0E2SSxNQUFBQSxDQUFDLEdBQUd1YSxLQUFLLENBQUM5RSxHQUFOLENBQVUsVUFBVWlTLElBQVYsRUFBZ0I7QUFDNUIsZUFBTzRzQyxJQUFJLENBQUN6c0MsTUFBRCxFQUFTSCxJQUFULEVBQWUvckIsUUFBZixDQUFYO0FBQ0QsT0FGRyxDQUFKO0FBR0F5QixNQUFBQSxJQUFJLEdBQUc0QyxDQUFDLENBQUM0YixJQUFGLENBQU8sR0FBUCxDQUFQO0FBQ0EsYUFBT3hlLElBQUksQ0FBQ2tJLEtBQUwsQ0FBV3RGLENBQUMsQ0FBQyxDQUFELENBQVosRUFBaUI3SSxNQUFqQixLQUE0QixDQUE1QixHQUFnQzZJLENBQUMsQ0FBQyxDQUFELENBQWpDLEdBQXVDNUMsSUFBOUM7QUFDRDs7QUFFRDRDLElBQUFBLENBQUMsR0FBRyxDQUFDdW1DLFFBQVEsR0FBRyxFQUFaLEVBQWdCamhDLEtBQWhCLENBQXNCLEdBQXRCLENBQUo7QUFDQWxJLElBQUFBLElBQUksR0FBRyxFQUFQO0FBQ0FtZCxJQUFBQSxLQUFLLENBQUMvaUIsT0FBTixDQUFjLFVBQVVrd0IsSUFBVixFQUFnQnh3QixDQUFoQixFQUFtQjtBQUMvQixhQUFPa0csSUFBSSxDQUFDc3FCLElBQUQsQ0FBSixHQUFhMW5CLENBQUMsQ0FBQzlJLENBQUQsQ0FBRCxHQUFPOEksQ0FBQyxDQUFDOUksQ0FBRCxDQUFELElBQVE4SSxDQUFDLENBQUMsQ0FBQzlJLENBQUMsR0FBRyxDQUFMLElBQVUsQ0FBVixHQUFjLENBQWYsQ0FBcEM7QUFDRCxLQUZEO0FBR0Eyd0IsSUFBQUEsTUFBTSxDQUFDOEMsSUFBUCxDQUFZaHhCLE1BQVosRUFBb0J5RCxJQUFwQixFQUEwQmdRLEtBQTFCO0FBQ0QsR0FsQkQ7QUFtQkQsQ0E1QlcsQ0FBWjs7QUE4Qk8sSUFBSTByRCxTQUFTLEdBQUc7QUFDckJoL0MsRUFBQUEsSUFBSSxFQUFFLEtBRGU7QUFFckJ2RSxFQUFBQSxRQUFRLEVBQUVwUixTQUZXO0FBR3JCNHRDLEVBQUFBLFVBQVUsRUFBRSxTQUFTQSxVQUFULENBQW9CcDRDLE1BQXBCLEVBQTRCO0FBQ3RDLFdBQU9BLE1BQU0sQ0FBQ2xFLEtBQVAsSUFBZ0JrRSxNQUFNLENBQUNnQixRQUE5QjtBQUNELEdBTG9CO0FBTXJCZ3dCLEVBQUFBLElBQUksRUFBRSxTQUFTQSxJQUFULENBQWNoeEIsTUFBZCxFQUFzQnlELElBQXRCLEVBQTRCZ1EsS0FBNUIsRUFBbUMyTCxLQUFuQyxFQUEwQ3ZELE9BQTFDLEVBQW1EO0FBQ3ZELFFBQUkrRSxLQUFLLEdBQUcsS0FBSzhQLE1BQWpCO0FBQUEsUUFDSTUwQixLQUFLLEdBQUdrRSxNQUFNLENBQUNsRSxLQURuQjtBQUFBLFFBRUlrakQsT0FBTyxHQUFHdnJDLEtBQUssQ0FBQ2hRLElBQU4sQ0FBV3U3QyxPQUZ6QjtBQUFBLFFBR0lrYyxVQUhKO0FBQUEsUUFJSXR1QixRQUpKO0FBQUEsUUFLSXNqQixNQUxKO0FBQUEsUUFNSUUsUUFOSjtBQUFBLFFBT0k1MEQsSUFQSjtBQUFBLFFBUUk0akUsV0FSSjtBQUFBLFFBU0lsaUUsQ0FUSjtBQUFBLFFBVUlrK0QsU0FWSjtBQUFBLFFBV0lELE9BWEo7QUFBQSxRQVlJNXNDLFFBWko7QUFBQSxRQWFJOHdDLGtCQWJKO0FBQUEsUUFjSUMsa0JBZEo7QUFBQSxRQWVJcHZDLEtBZko7QUFBQSxRQWdCSW9zQyxNQWhCSjtBQUFBLFFBaUJJN0ssV0FqQko7QUFrQkF1RixJQUFBQSxjQUFjLElBQUl4c0QsU0FBUyxFQUEzQjs7QUFFQSxTQUFLdE4sQ0FBTCxJQUFVdUcsSUFBVixFQUFnQjtBQUNkLFVBQUl2RyxDQUFDLEtBQUssV0FBVixFQUF1QjtBQUNyQjtBQUNEOztBQUVEMHZDLE1BQUFBLFFBQVEsR0FBR25wQyxJQUFJLENBQUN2RyxDQUFELENBQWY7O0FBRUEsVUFBSTI2QyxRQUFRLENBQUMzNkMsQ0FBRCxDQUFSLElBQWU4ekQsWUFBWSxDQUFDOXpELENBQUQsRUFBSXVHLElBQUosRUFBVWdRLEtBQVYsRUFBaUIyTCxLQUFqQixFQUF3QnBmLE1BQXhCLEVBQWdDNmIsT0FBaEMsQ0FBL0IsRUFBeUU7QUFDdkU7QUFDQTtBQUNEOztBQUVEcmdCLE1BQUFBLElBQUksR0FBRyxpQkFBT294QyxRQUFWLENBQUo7QUFDQXd5QixNQUFBQSxXQUFXLEdBQUdyRSxhQUFhLENBQUM3OUQsQ0FBRCxDQUEzQjs7QUFFQSxVQUFJMUIsSUFBSSxLQUFLLFVBQWIsRUFBeUI7QUFDdkJveEMsUUFBQUEsUUFBUSxHQUFHQSxRQUFRLENBQUNwbUMsSUFBVCxDQUFjaU4sS0FBZCxFQUFxQjJMLEtBQXJCLEVBQTRCcGYsTUFBNUIsRUFBb0M2YixPQUFwQyxDQUFYO0FBQ0FyZ0IsUUFBQUEsSUFBSSxHQUFHLGlCQUFPb3hDLFFBQVYsQ0FBSjtBQUNEOztBQUVELFVBQUlweEMsSUFBSSxLQUFLLFFBQVQsSUFBcUIsQ0FBQ294QyxRQUFRLENBQUM1aEMsT0FBVCxDQUFpQixTQUFqQixDQUExQixFQUF1RDtBQUNyRDRoQyxRQUFBQSxRQUFRLEdBQUd1VixjQUFjLENBQUN2VixRQUFELENBQXpCO0FBQ0Q7O0FBRUQsVUFBSXd5QixXQUFKLEVBQWlCO0FBQ2ZBLFFBQUFBLFdBQVcsQ0FBQyxJQUFELEVBQU9wL0QsTUFBUCxFQUFlOUMsQ0FBZixFQUFrQjB2QyxRQUFsQixFQUE0Qm41QixLQUE1QixDQUFYLEtBQWtEZytDLFdBQVcsR0FBRyxDQUFoRTtBQUNELE9BRkQsTUFFTyxJQUFJdjBELENBQUMsQ0FBQ3lzQixNQUFGLENBQVMsQ0FBVCxFQUFZLENBQVosTUFBbUIsSUFBdkIsRUFBNkI7QUFDbEM7QUFDQXV4QyxRQUFBQSxVQUFVLEdBQUcsQ0FBQy80RCxnQkFBZ0IsQ0FBQ25DLE1BQUQsQ0FBaEIsQ0FBeUIwNEQsZ0JBQXpCLENBQTBDeDdELENBQTFDLElBQStDLEVBQWhELEVBQW9EaThDLElBQXBELEVBQWI7QUFDQXZNLFFBQUFBLFFBQVEsSUFBSSxFQUFaO0FBQ0F1WixRQUFBQSxtQkFBQSxHQUFzQixDQUF0Qjs7QUFFQSxZQUFJLENBQUNBLGNBQUEsQ0FBZStVLFVBQWYsQ0FBTCxFQUFpQztBQUMvQjtBQUNBRSxVQUFBQSxTQUFTLEdBQUdycUMsT0FBTyxDQUFDbXFDLFVBQUQsQ0FBbkI7QUFDQUMsVUFBQUEsT0FBTyxHQUFHcHFDLE9BQU8sQ0FBQzZiLFFBQUQsQ0FBakI7QUFDRDs7QUFFRHV1QixRQUFBQSxPQUFPLEdBQUdDLFNBQVMsS0FBS0QsT0FBZCxLQUEwQkQsVUFBVSxHQUFHZCxjQUFjLENBQUNwNkQsTUFBRCxFQUFTOUMsQ0FBVCxFQUFZZytELFVBQVosRUFBd0JDLE9BQXhCLENBQWQsR0FBaURBLE9BQXhGLENBQUgsR0FBc0dDLFNBQVMsS0FBS3h1QixRQUFRLElBQUl3dUIsU0FBakIsQ0FBdEg7QUFDQSxhQUFLbDlELEdBQUwsQ0FBU3BDLEtBQVQsRUFBZ0IsYUFBaEIsRUFBK0JvL0QsVUFBL0IsRUFBMkN0dUIsUUFBM0MsRUFBcUR4dEIsS0FBckQsRUFBNER2RCxPQUE1RCxFQUFxRSxDQUFyRSxFQUF3RSxDQUF4RSxFQUEyRTNlLENBQTNFO0FBQ0EwakIsUUFBQUEsS0FBSyxDQUFDNWlCLElBQU4sQ0FBV2QsQ0FBWDtBQUNELE9BZk0sTUFlQSxJQUFJMUIsSUFBSSxLQUFLLFdBQWIsRUFBMEI7QUFDL0IsWUFBSXdqRCxPQUFPLElBQUk5aEQsQ0FBQyxJQUFJOGhELE9BQXBCLEVBQTZCO0FBQzNCO0FBQ0FrYyxVQUFBQSxVQUFVLEdBQUcsT0FBT2xjLE9BQU8sQ0FBQzloRCxDQUFELENBQWQsS0FBc0IsVUFBdEIsR0FBbUM4aEQsT0FBTyxDQUFDOWhELENBQUQsQ0FBUCxDQUFXc0osSUFBWCxDQUFnQmlOLEtBQWhCLEVBQXVCMkwsS0FBdkIsRUFBOEJwZixNQUE5QixFQUFzQzZiLE9BQXRDLENBQW5DLEdBQW9GbWpDLE9BQU8sQ0FBQzloRCxDQUFELENBQXhHO0FBQ0FtZ0IsVUFBQUEsU0FBUyxDQUFDNjlDLFVBQUQsQ0FBVCxJQUF5QixDQUFDQSxVQUFVLENBQUNsd0QsT0FBWCxDQUFtQixTQUFuQixDQUExQixLQUE0RGt3RCxVQUFVLEdBQUcvWSxjQUFjLENBQUMrWSxVQUFELENBQXZGO0FBQ0FucUMsVUFBQUEsT0FBTyxDQUFDbXFDLFVBQVUsR0FBRyxFQUFkLENBQVAsS0FBNkJBLFVBQVUsSUFBSXZsQixhQUFBLENBQWN6NEMsQ0FBZCxLQUFvQjZ6QixPQUFPLENBQUM0cEMsSUFBSSxDQUFDMzZELE1BQUQsRUFBUzlDLENBQVQsQ0FBTCxDQUEzQixJQUFnRCxFQUEzRixFQUoyQixDQUlxRTs7QUFFaEcsV0FBQ2crRCxVQUFVLEdBQUcsRUFBZCxFQUFrQnR4QyxNQUFsQixDQUF5QixDQUF6QixNQUFnQyxHQUFoQyxLQUF3Q3N4QyxVQUFVLEdBQUdQLElBQUksQ0FBQzM2RCxNQUFELEVBQVM5QyxDQUFULENBQXpELEVBTjJCLENBTTRDO0FBQ3hFLFNBUEQsTUFPTztBQUNMZytELFVBQUFBLFVBQVUsR0FBR1AsSUFBSSxDQUFDMzZELE1BQUQsRUFBUzlDLENBQVQsQ0FBakI7QUFDRDs7QUFFRGt6RCxRQUFBQSxRQUFRLEdBQUd6cUQsVUFBVSxDQUFDdTFELFVBQUQsQ0FBckI7QUFDQTNzQyxRQUFBQSxRQUFRLEdBQUcveUIsSUFBSSxLQUFLLFFBQVQsSUFBcUJveEMsUUFBUSxDQUFDaGpCLE1BQVQsQ0FBZ0IsQ0FBaEIsTUFBdUIsR0FBNUMsSUFBbURnakIsUUFBUSxDQUFDampCLE1BQVQsQ0FBZ0IsQ0FBaEIsRUFBbUIsQ0FBbkIsQ0FBOUQ7QUFDQTRFLFFBQUFBLFFBQVEsS0FBS3FlLFFBQVEsR0FBR0EsUUFBUSxDQUFDampCLE1BQVQsQ0FBZ0IsQ0FBaEIsQ0FBaEIsQ0FBUjtBQUNBdW1DLFFBQUFBLE1BQU0sR0FBR3ZxRCxVQUFVLENBQUNpbkMsUUFBRCxDQUFuQjs7QUFFQSxZQUFJMXZDLENBQUMsSUFBSW82RCxnQkFBVCxFQUEyQjtBQUN6QixjQUFJcDZELENBQUMsS0FBSyxXQUFWLEVBQXVCO0FBQ3JCO0FBQ0EsZ0JBQUlrekQsUUFBUSxLQUFLLENBQWIsSUFBa0J1SyxJQUFJLENBQUMzNkQsTUFBRCxFQUFTLFlBQVQsQ0FBSixLQUErQixRQUFqRCxJQUE2RGt3RCxNQUFqRSxFQUF5RTtBQUN2RTtBQUNBRSxjQUFBQSxRQUFRLEdBQUcsQ0FBWDtBQUNEOztBQUVEeUosWUFBQUEsaUJBQWlCLENBQUMsSUFBRCxFQUFPLzlELEtBQVAsRUFBYyxZQUFkLEVBQTRCczBELFFBQVEsR0FBRyxTQUFILEdBQWUsUUFBbkQsRUFBNkRGLE1BQU0sR0FBRyxTQUFILEdBQWUsUUFBbEYsRUFBNEYsQ0FBQ0EsTUFBN0YsQ0FBakI7QUFDRDs7QUFFRCxjQUFJaHpELENBQUMsS0FBSyxPQUFOLElBQWlCQSxDQUFDLEtBQUssV0FBM0IsRUFBd0M7QUFDdENBLFlBQUFBLENBQUMsR0FBR282RCxnQkFBZ0IsQ0FBQ3A2RCxDQUFELENBQXBCO0FBQ0EsYUFBQ0EsQ0FBQyxDQUFDOE4sT0FBRixDQUFVLEdBQVYsQ0FBRCxLQUFvQjlOLENBQUMsR0FBR0EsQ0FBQyxDQUFDeU8sS0FBRixDQUFRLEdBQVIsRUFBYSxDQUFiLENBQXhCO0FBQ0Q7QUFDRjs7QUFFRDB6RCxRQUFBQSxrQkFBa0IsR0FBR25pRSxDQUFDLElBQUlpNkQsZUFBMUIsQ0FsQytCLENBa0NZOztBQUUzQyxZQUFJa0ksa0JBQUosRUFBd0I7QUFDdEIsY0FBSSxDQUFDQyxrQkFBTCxFQUF5QjtBQUN2QnB2QyxZQUFBQSxLQUFLLEdBQUdsd0IsTUFBTSxDQUFDME8sS0FBZjtBQUNBd2hCLFlBQUFBLEtBQUssQ0FBQ3RlLGVBQU4sSUFBeUIsQ0FBQ25PLElBQUksQ0FBQzg3RCxjQUEvQixJQUFpRDNFLGVBQWUsQ0FBQzU2RCxNQUFELEVBQVN5RCxJQUFJLENBQUM4N0QsY0FBZCxDQUFoRSxDQUZ1QixDQUV3RTs7QUFFL0ZqRCxZQUFBQSxNQUFNLEdBQUc3NEQsSUFBSSxDQUFDKzdELFlBQUwsS0FBc0IsS0FBdEIsSUFBK0J0dkMsS0FBSyxDQUFDb3NDLE1BQTlDO0FBQ0FnRCxZQUFBQSxrQkFBa0IsR0FBRyxLQUFLL3VDLEdBQUwsR0FBVyxJQUFJOUMsU0FBSixDQUFjLEtBQUs4QyxHQUFuQixFQUF3QnowQixLQUF4QixFQUErQmYsY0FBL0IsRUFBK0MsQ0FBL0MsRUFBa0QsQ0FBbEQsRUFBcURtMUIsS0FBSyxDQUFDdGUsZUFBM0QsRUFBNEVzZSxLQUE1RSxFQUFtRixDQUFuRixFQUFzRixDQUFDLENBQXZGLENBQWhDLENBTHVCLENBS29HOztBQUUzSG92QyxZQUFBQSxrQkFBa0IsQ0FBQ3hMLEdBQW5CLEdBQXlCLENBQXpCLENBUHVCLENBT0s7QUFDN0I7O0FBRUQsY0FBSTUyRCxDQUFDLEtBQUssT0FBVixFQUFtQjtBQUNqQixpQkFBS3F6QixHQUFMLEdBQVcsSUFBSTlDLFNBQUosQ0FBYyxLQUFLOEMsR0FBbkIsRUFBd0JMLEtBQXhCLEVBQStCLFFBQS9CLEVBQXlDQSxLQUFLLENBQUNtb0MsTUFBL0MsRUFBdUQsQ0FBQzlwQyxRQUFRLEdBQUdtcUIsY0FBYyxDQUFDeG9CLEtBQUssQ0FBQ21vQyxNQUFQLEVBQWU5cEMsUUFBUSxHQUFHMmhDLE1BQTFCLENBQWpCLEdBQXFEQSxNQUE5RCxJQUF3RWhnQyxLQUFLLENBQUNtb0MsTUFBOUUsSUFBd0YsQ0FBL0ksQ0FBWDtBQUNBejNDLFlBQUFBLEtBQUssQ0FBQzVpQixJQUFOLENBQVcsUUFBWCxFQUFxQmQsQ0FBckI7QUFDQUEsWUFBQUEsQ0FBQyxJQUFJLEdBQUw7QUFDRCxXQUpELE1BSU8sSUFBSUEsQ0FBQyxLQUFLLGlCQUFWLEVBQTZCO0FBQ2xDMHZDLFlBQUFBLFFBQVEsR0FBRzJ1Qiw2QkFBNkIsQ0FBQzN1QixRQUFELENBQXhDLENBRGtDLENBQ2tCOztBQUVwRCxnQkFBSTFjLEtBQUssQ0FBQ25CLEdBQVYsRUFBZTtBQUNicXRDLGNBQUFBLGVBQWUsQ0FBQ3A4RCxNQUFELEVBQVM0c0MsUUFBVCxFQUFtQixDQUFuQixFQUFzQjB2QixNQUF0QixFQUE4QixDQUE5QixFQUFpQyxJQUFqQyxDQUFmO0FBQ0QsYUFGRCxNQUVPO0FBQ0xuQixjQUFBQSxPQUFPLEdBQUd4MUQsVUFBVSxDQUFDaW5DLFFBQVEsQ0FBQ2poQyxLQUFULENBQWUsR0FBZixFQUFvQixDQUFwQixDQUFELENBQVYsSUFBc0MsQ0FBaEQsQ0FESyxDQUM4Qzs7QUFFbkR3dkQsY0FBQUEsT0FBTyxLQUFLanJDLEtBQUssQ0FBQzRxQyxPQUFsQixJQUE2QmpCLGlCQUFpQixDQUFDLElBQUQsRUFBTzNwQyxLQUFQLEVBQWMsU0FBZCxFQUF5QkEsS0FBSyxDQUFDNHFDLE9BQS9CLEVBQXdDSyxPQUF4QyxDQUE5Qzs7QUFFQXRCLGNBQUFBLGlCQUFpQixDQUFDLElBQUQsRUFBTy85RCxLQUFQLEVBQWNvQixDQUFkLEVBQWlCMjlELGFBQWEsQ0FBQ0ssVUFBRCxDQUE5QixFQUE0Q0wsYUFBYSxDQUFDanVCLFFBQUQsQ0FBekQsQ0FBakI7QUFDRDs7QUFFRDtBQUNELFdBZE0sTUFjQSxJQUFJMXZDLENBQUMsS0FBSyxXQUFWLEVBQXVCO0FBQzVCay9ELFlBQUFBLGVBQWUsQ0FBQ3A4RCxNQUFELEVBQVM0c0MsUUFBVCxFQUFtQixDQUFuQixFQUFzQjB2QixNQUF0QixFQUE4QixDQUE5QixFQUFpQyxJQUFqQyxDQUFmOztBQUVBO0FBQ0QsV0FKTSxNQUlBLElBQUlwL0QsQ0FBQyxJQUFJeStELHFCQUFULEVBQWdDO0FBQ3JDZ0QsWUFBQUEsdUJBQXVCLENBQUMsSUFBRCxFQUFPenVDLEtBQVAsRUFBY2h6QixDQUFkLEVBQWlCa3pELFFBQWpCLEVBQTJCN2hDLFFBQVEsR0FBR21xQixjQUFjLENBQUMwWCxRQUFELEVBQVc3aEMsUUFBUSxHQUFHcWUsUUFBdEIsQ0FBakIsR0FBbURBLFFBQXRGLENBQXZCOztBQUVBO0FBQ0QsV0FKTSxNQUlBLElBQUkxdkMsQ0FBQyxLQUFLLGNBQVYsRUFBMEI7QUFDL0IyOEQsWUFBQUEsaUJBQWlCLENBQUMsSUFBRCxFQUFPM3BDLEtBQVAsRUFBYyxRQUFkLEVBQXdCQSxLQUFLLENBQUNvc0MsTUFBOUIsRUFBc0MxdkIsUUFBdEMsQ0FBakI7O0FBRUE7QUFDRCxXQUpNLE1BSUEsSUFBSTF2QyxDQUFDLEtBQUssU0FBVixFQUFxQjtBQUMxQmd6QixZQUFBQSxLQUFLLENBQUNoekIsQ0FBRCxDQUFMLEdBQVcwdkMsUUFBWDtBQUNBO0FBQ0QsV0FITSxNQUdBLElBQUkxdkMsQ0FBQyxLQUFLLFdBQVYsRUFBdUI7QUFDNUI2aEUsWUFBQUEsbUJBQW1CLENBQUMsSUFBRCxFQUFPbnlCLFFBQVAsRUFBaUI1c0MsTUFBakIsQ0FBbkI7O0FBRUE7QUFDRDtBQUNGLFNBakRELE1BaURPLElBQUksRUFBRTlDLENBQUMsSUFBSXBCLEtBQVAsQ0FBSixFQUFtQjtBQUN4Qm9CLFVBQUFBLENBQUMsR0FBR3k3RCxnQkFBZ0IsQ0FBQ3o3RCxDQUFELENBQWhCLElBQXVCQSxDQUEzQjtBQUNEOztBQUVELFlBQUltaUUsa0JBQWtCLElBQUksQ0FBQ25QLE1BQU0sSUFBSUEsTUFBTSxLQUFLLENBQXRCLE1BQTZCRSxRQUFRLElBQUlBLFFBQVEsS0FBSyxDQUF0RCxLQUE0RCxDQUFDaUgsV0FBVyxDQUFDeHdELElBQVosQ0FBaUIrbEMsUUFBakIsQ0FBN0QsSUFBMkYxdkMsQ0FBQyxJQUFJcEIsS0FBMUgsRUFBaUk7QUFDL0hzL0QsVUFBQUEsU0FBUyxHQUFHLENBQUNGLFVBQVUsR0FBRyxFQUFkLEVBQWtCdnhDLE1BQWxCLENBQXlCLENBQUN5bUMsUUFBUSxHQUFHLEVBQVosRUFBZ0I1eUQsTUFBekMsQ0FBWjtBQUNBMHlELFVBQUFBLE1BQU0sS0FBS0EsTUFBTSxHQUFHLENBQWQsQ0FBTixDQUYrSCxDQUV2Rzs7QUFFeEJpTCxVQUFBQSxPQUFPLEdBQUdwcUMsT0FBTyxDQUFDNmIsUUFBRCxDQUFQLEtBQXNCMXZDLENBQUMsSUFBSXk0QyxhQUFMLEdBQXFCQSxhQUFBLENBQWN6NEMsQ0FBZCxDQUFyQixHQUF3Q2srRCxTQUE5RCxDQUFWO0FBQ0FBLFVBQUFBLFNBQVMsS0FBS0QsT0FBZCxLQUEwQi9LLFFBQVEsR0FBR2dLLGNBQWMsQ0FBQ3A2RCxNQUFELEVBQVM5QyxDQUFULEVBQVlnK0QsVUFBWixFQUF3QkMsT0FBeEIsQ0FBbkQ7QUFDQSxlQUFLNXFDLEdBQUwsR0FBVyxJQUFJOUMsU0FBSixDQUFjLEtBQUs4QyxHQUFuQixFQUF3Qjh1QyxrQkFBa0IsR0FBR252QyxLQUFILEdBQVdwMEIsS0FBckQsRUFBNERvQixDQUE1RCxFQUErRGt6RCxRQUEvRCxFQUF5RSxDQUFDN2hDLFFBQVEsR0FBR21xQixjQUFjLENBQUMwWCxRQUFELEVBQVc3aEMsUUFBUSxHQUFHMmhDLE1BQXRCLENBQWpCLEdBQWlEQSxNQUExRCxJQUFvRUUsUUFBN0ksRUFBdUosQ0FBQ2lQLGtCQUFELEtBQXdCbEUsT0FBTyxLQUFLLElBQVosSUFBb0JqK0QsQ0FBQyxLQUFLLFFBQWxELEtBQStEdUcsSUFBSSxDQUFDZzhELFNBQUwsS0FBbUIsS0FBbEYsR0FBMEY3SCxxQkFBMUYsR0FBa0hILGNBQXpRLENBQVg7QUFDQSxlQUFLbG5DLEdBQUwsQ0FBU0MsQ0FBVCxHQUFhMnFDLE9BQU8sSUFBSSxDQUF4Qjs7QUFFQSxjQUFJQyxTQUFTLEtBQUtELE9BQWQsSUFBeUJBLE9BQU8sS0FBSyxHQUF6QyxFQUE4QztBQUM1QztBQUNBLGlCQUFLNXFDLEdBQUwsQ0FBU3ZZLENBQVQsR0FBYWtqRCxVQUFiO0FBQ0EsaUJBQUszcUMsR0FBTCxDQUFTcHRCLENBQVQsR0FBYXcwRCwyQkFBYjtBQUNEO0FBQ0YsU0FkRCxNQWNPLElBQUksRUFBRXo2RCxDQUFDLElBQUlwQixLQUFQLENBQUosRUFBbUI7QUFDeEIsY0FBSW9CLENBQUMsSUFBSThDLE1BQVQsRUFBaUI7QUFDZjtBQUNBLGlCQUFLOUIsR0FBTCxDQUFTOEIsTUFBVCxFQUFpQjlDLENBQWpCLEVBQW9CZytELFVBQVUsSUFBSWw3RCxNQUFNLENBQUM5QyxDQUFELENBQXhDLEVBQTZDcXhCLFFBQVEsR0FBR0EsUUFBUSxHQUFHcWUsUUFBZCxHQUF5QkEsUUFBOUUsRUFBd0Z4dEIsS0FBeEYsRUFBK0Z2RCxPQUEvRjtBQUNELFdBSEQsTUFHTztBQUNMdTdCLFlBQUFBLGNBQWMsQ0FBQ2w2QyxDQUFELEVBQUkwdkMsUUFBSixDQUFkOztBQUVBO0FBQ0Q7QUFDRixTQVRNLE1BU0E7QUFDTG91QixVQUFBQSxzQkFBc0IsQ0FBQ3gwRCxJQUF2QixDQUE0QixJQUE1QixFQUFrQ3hHLE1BQWxDLEVBQTBDOUMsQ0FBMUMsRUFBNkNnK0QsVUFBN0MsRUFBeUQzc0MsUUFBUSxHQUFHQSxRQUFRLEdBQUdxZSxRQUFkLEdBQXlCQSxRQUExRjtBQUNEOztBQUVEaHNCLFFBQUFBLEtBQUssQ0FBQzVpQixJQUFOLENBQVdkLENBQVg7QUFDRDtBQUNGOztBQUVEdTBELElBQUFBLFdBQVcsSUFBSU0seUJBQXlCLENBQUMsSUFBRCxDQUF4QztBQUNELEdBN0xvQjtBQThMckJqbUQsRUFBQUEsR0FBRyxFQUFFNnVELElBOUxnQjtBQStMckJ0cUMsRUFBQUEsT0FBTyxFQUFFaW5DLGdCQS9MWTtBQWdNckJwVCxFQUFBQSxTQUFTLEVBQUUsU0FBU0EsU0FBVCxDQUFtQmxrRCxNQUFuQixFQUEyQmdDLFFBQTNCLEVBQXFDa3NCLE1BQXJDLEVBQTZDO0FBQ3REO0FBQ0EsUUFBSWh4QixDQUFDLEdBQUdvNkQsZ0JBQWdCLENBQUN0MUQsUUFBRCxDQUF4QjtBQUNBOUUsSUFBQUEsQ0FBQyxJQUFJQSxDQUFDLENBQUM4TixPQUFGLENBQVUsR0FBVixJQUFpQixDQUF0QixLQUE0QmhKLFFBQVEsR0FBRzlFLENBQXZDO0FBQ0EsV0FBTzhFLFFBQVEsSUFBSW0xRCxlQUFaLElBQStCbjFELFFBQVEsS0FBS2hILG9CQUE1QyxLQUFxRWdGLE1BQU0sQ0FBQzBPLEtBQVAsQ0FBYWpOLENBQWIsSUFBa0JrNUQsSUFBSSxDQUFDMzZELE1BQUQsRUFBUyxHQUFULENBQTNGLElBQTRHa3VCLE1BQU0sSUFBSWdwQyxtQkFBbUIsS0FBS2hwQyxNQUFsQyxHQUEyQ2xzQixRQUFRLEtBQUssT0FBYixHQUF1Qm0yRCxZQUF2QixHQUFzQ0QsZ0JBQWpGLEdBQW9HLENBQUNoQixtQkFBbUIsR0FBR2hwQyxNQUFNLElBQUksRUFBakMsTUFBeUNsc0IsUUFBUSxLQUFLLE9BQWIsR0FBdUJzMkQsc0JBQXZCLEdBQWdEQywwQkFBekYsQ0FBaE4sR0FBdVV2NEQsTUFBTSxDQUFDbEUsS0FBUCxJQUFnQixDQUFDakIsWUFBWSxDQUFDbUYsTUFBTSxDQUFDbEUsS0FBUCxDQUFha0csUUFBYixDQUFELENBQTdCLEdBQXdEKzFELGVBQXhELEdBQTBFLENBQUMvMUQsUUFBUSxDQUFDZ0osT0FBVCxDQUFpQixHQUFqQixDQUFELEdBQXlCZ3RELGNBQXpCLEdBQTBDN1QsVUFBVSxDQUFDbmtELE1BQUQsRUFBU2dDLFFBQVQsQ0FBNWM7QUFDRCxHQXJNb0I7QUFzTXJCMk0sRUFBQUEsSUFBSSxFQUFFO0FBQ0pnckQsSUFBQUEsZUFBZSxFQUFFQSxlQURiO0FBRUpvQyxJQUFBQSxVQUFVLEVBQUVBO0FBRlI7QUF0TWUsQ0FBaEI7QUEyTVA1aUUsc0JBQUEsR0FBeUJ3L0QsZ0JBQXpCOztBQUVBLENBQUMsVUFBVStHLGdCQUFWLEVBQTRCOXlELFFBQTVCLEVBQXNDK3lELE1BQXRDLEVBQThDdHZDLE9BQTlDLEVBQXVEO0FBQ3RELE1BQUl1dkMsR0FBRyxHQUFHcG5CLFlBQVksQ0FBQ2tuQixnQkFBZ0IsR0FBRyxHQUFuQixHQUF5Qjl5RCxRQUF6QixHQUFvQyxHQUFwQyxHQUEwQyt5RCxNQUEzQyxFQUFtRCxVQUFVeC9DLElBQVYsRUFBZ0I7QUFDdkZnM0MsSUFBQUEsZUFBZSxDQUFDaDNDLElBQUQsQ0FBZixHQUF3QixDQUF4QjtBQUNELEdBRnFCLENBQXRCOztBQUlBcTRCLEVBQUFBLFlBQVksQ0FBQzVyQyxRQUFELEVBQVcsVUFBVXVULElBQVYsRUFBZ0I7QUFDckN3MUIsSUFBQUEsYUFBQSxDQUFjeDFCLElBQWQsSUFBc0IsS0FBdEI7QUFDQXc3QyxJQUFBQSxxQkFBcUIsQ0FBQ3g3QyxJQUFELENBQXJCLEdBQThCLENBQTlCO0FBQ0QsR0FIVyxDQUFaOztBQUtBbTNDLEVBQUFBLGdCQUFnQixDQUFDc0ksR0FBRyxDQUFDLEVBQUQsQ0FBSixDQUFoQixHQUE0QkYsZ0JBQWdCLEdBQUcsR0FBbkIsR0FBeUI5eUQsUUFBckQ7O0FBRUE0ckMsRUFBQUEsWUFBWSxDQUFDbm9CLE9BQUQsRUFBVSxVQUFVbFEsSUFBVixFQUFnQjtBQUNwQyxRQUFJeFUsS0FBSyxHQUFHd1UsSUFBSSxDQUFDeFUsS0FBTCxDQUFXLEdBQVgsQ0FBWjtBQUNBMnJELElBQUFBLGdCQUFnQixDQUFDM3JELEtBQUssQ0FBQyxDQUFELENBQU4sQ0FBaEIsR0FBNkJpMEQsR0FBRyxDQUFDajBELEtBQUssQ0FBQyxDQUFELENBQU4sQ0FBaEM7QUFDRCxHQUhXLENBQVo7QUFJRCxDQWhCRCxFQWdCRyw2Q0FoQkgsRUFnQmtELDBDQWhCbEQsRUFnQjhGLCtFQWhCOUYsRUFnQitLLDRGQWhCL0s7O0FBa0JBNnNDLFlBQVksQ0FBQyw4RUFBRCxFQUFpRixVQUFVcjRCLElBQVYsRUFBZ0I7QUFDM0d3MUIsRUFBQUEsYUFBQSxDQUFjeDFCLElBQWQsSUFBc0IsSUFBdEI7QUFDRCxDQUZXLENBQVo7O0FBSUFobkIsbUJBQUEsQ0FBb0JnbUUsU0FBcEI7OztBQ240Q0E7QUFDQTtBQUNBLElBQUlVLFdBQVcsR0FBRzFtRSxtQkFBQSxDQUFvQmdtRSxTQUFwQixLQUFrQ2htRSxJQUFwRDtBQUFBLElBQ0k7QUFDSjJtRSxlQUFlLEdBQUdELFdBQVcsQ0FBQ2x4RCxJQUFaLENBQWlCc3dDLEtBRm5DOzs7Ozs7Ozs7Ozs7OztBQ0ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk1bEQsSUFBSjtBQUFBLElBQ0lELElBREo7QUFBQSxJQUVJRSxXQUZKO0FBQUEsSUFHSUMsS0FISjtBQUFBLElBSUl3bUUsYUFKSjtBQUFBLElBS0lDLGFBTEo7QUFBQSxJQU1JOWpFLGVBTko7QUFBQSxJQU9JK2pFLElBUEo7QUFBQSxJQVFJbGxFLGNBQWMsR0FBRyxXQVJyQjtBQUFBLElBU0lDLG9CQUFvQixHQUFHRCxjQUFjLEdBQUcsUUFUNUM7QUFBQSxJQVVJbWxFLGFBVko7QUFBQSxJQVdJQyxPQUFPLEdBQUcsU0FBU0EsT0FBVCxDQUFpQnBoRSxPQUFqQixFQUEwQjtBQUN0QyxNQUFJb0IsR0FBRyxHQUFHcEIsT0FBTyxDQUFDbUUsYUFBUixJQUF5Qm5FLE9BQW5DOztBQUVBLE1BQUksRUFBRWhFLGNBQWMsSUFBSWdFLE9BQU8sQ0FBQ2pELEtBQTVCLEtBQXNDLGlCQUFpQmlELE9BQU8sQ0FBQ2pELEtBQW5FLEVBQTBFO0FBQ3hFO0FBQ0FmLElBQUFBLGNBQWMsR0FBRyxhQUFqQjtBQUNBQyxJQUFBQSxvQkFBb0IsR0FBR0QsY0FBYyxHQUFHLFFBQXhDO0FBQ0Q7O0FBRUQsU0FBT29GLEdBQUcsQ0FBQ1csVUFBSixLQUFtQlgsR0FBRyxHQUFHQSxHQUFHLENBQUNXLFVBQTdCLENBQVAsRUFBaUQsQ0FBRTs7QUFFbkQxSCxFQUFBQSxJQUFJLEdBQUdtQixNQUFQO0FBQ0EyQixFQUFBQSxlQUFlLEdBQUcsSUFBSWhELFFBQUosRUFBbEI7O0FBRUEsTUFBSWlILEdBQUosRUFBUztBQUNQOUcsSUFBQUEsSUFBSSxHQUFHOEcsR0FBUDtBQUNBN0csSUFBQUEsV0FBVyxHQUFHNkcsR0FBRyxDQUFDRyxlQUFsQjtBQUNBL0csSUFBQUEsS0FBSyxHQUFHNEcsR0FBRyxDQUFDSSxJQUFaO0FBQ0EwL0QsSUFBQUEsSUFBSSxHQUFHNW1FLElBQUksQ0FBQ3NDLGVBQUwsQ0FBcUIsNEJBQXJCLEVBQW1ELEdBQW5ELENBQVAsQ0FKTyxDQUl5RDs7QUFFaEVza0UsSUFBQUEsSUFBSSxDQUFDbmtFLEtBQUwsQ0FBVzQ0QyxTQUFYLEdBQXVCLE1BQXZCLENBTk8sQ0FNd0I7O0FBRS9CLFFBQUkwckIsRUFBRSxHQUFHamdFLEdBQUcsQ0FBQ3RFLGFBQUosQ0FBa0IsS0FBbEIsQ0FBVDtBQUFBLFFBQ0k4dUIsRUFBRSxHQUFHeHFCLEdBQUcsQ0FBQ3RFLGFBQUosQ0FBa0IsS0FBbEIsQ0FEVDs7QUFHQXRDLElBQUFBLEtBQUssQ0FBQ3NRLFdBQU4sQ0FBa0J1MkQsRUFBbEI7O0FBRUFBLElBQUFBLEVBQUUsQ0FBQ3YyRCxXQUFILENBQWU4Z0IsRUFBZjtBQUNBeTFDLElBQUFBLEVBQUUsQ0FBQ3RrRSxLQUFILENBQVN5TCxRQUFULEdBQW9CLFFBQXBCO0FBQ0E2NEQsSUFBQUEsRUFBRSxDQUFDdGtFLEtBQUgsQ0FBU2YsY0FBVCxJQUEyQixzQkFBM0I7QUFDQW1sRSxJQUFBQSxhQUFhLEdBQUd2MUMsRUFBRSxDQUFDd3hDLFlBQUgsS0FBb0JpRSxFQUFwQzs7QUFFQTdtRSxJQUFBQSxLQUFLLENBQUN1USxXQUFOLENBQWtCczJELEVBQWxCO0FBQ0Q7O0FBRUQsU0FBT2pnRSxHQUFQO0FBQ0QsQ0EvQ0Q7QUFBQSxJQWdESWtnRSxrQkFBa0IsR0FBRyxTQUFTQSxrQkFBVCxDQUE0QjNrRSxDQUE1QixFQUErQjtBQUN0RDtBQUNBLE1BQUkySyxDQUFKLEVBQU82cEIsS0FBUDs7QUFFQSxTQUFPeDBCLENBQUMsSUFBSUEsQ0FBQyxLQUFLbkMsS0FBbEIsRUFBeUI7QUFDdkIyMkIsSUFBQUEsS0FBSyxHQUFHeDBCLENBQUMsQ0FBQ2dULEtBQVY7QUFDQXdoQixJQUFBQSxLQUFLLElBQUlBLEtBQUssQ0FBQ2hlLE9BQWYsSUFBMEJnZSxLQUFLLENBQUNwa0IsR0FBTixDQUFVcFEsQ0FBVixFQUFhLEdBQWIsQ0FBMUIsQ0FGdUIsQ0FFc0I7O0FBRTdDLFFBQUl3MEIsS0FBSyxJQUFJLENBQUNBLEtBQUssQ0FBQ2tvQyxNQUFoQixJQUEwQixDQUFDbG9DLEtBQUssQ0FBQ21vQyxNQUFqQyxJQUEyQ25vQyxLQUFLLENBQUN0ZSxlQUFyRCxFQUFzRTtBQUNwRXNlLE1BQUFBLEtBQUssQ0FBQ2tvQyxNQUFOLEdBQWVsb0MsS0FBSyxDQUFDbW9DLE1BQU4sR0FBZSxJQUE5QjtBQUNBbm9DLE1BQUFBLEtBQUssQ0FBQ3RlLGVBQU4sQ0FBc0IsQ0FBdEIsRUFBeUJzZSxLQUF6QjtBQUNBN3BCLE1BQUFBLENBQUMsR0FBR0EsQ0FBQyxDQUFDckksSUFBRixDQUFPa3lCLEtBQVAsQ0FBSCxHQUFtQjdwQixDQUFDLEdBQUcsQ0FBQzZwQixLQUFELENBQXhCO0FBQ0Q7O0FBRUR4MEIsSUFBQUEsQ0FBQyxHQUFHQSxDQUFDLENBQUNvRixVQUFOO0FBQ0Q7O0FBRUQsU0FBT3VGLENBQVA7QUFDRCxDQWxFRDtBQUFBLElBbUVJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBaTZELFNBQVMsR0FBRyxFQXJGWjtBQUFBLElBc0ZJO0FBQ0pDLFNBQVMsR0FBRyxFQXZGWjtBQUFBLElBd0ZJcmdFLGdCQUFnQixHQUFHLFNBQVNBLGdCQUFULEdBQTRCO0FBQ2pELFNBQU85RyxJQUFJLENBQUNnSCxXQUFMLElBQW9CL0csSUFBSSxDQUFDZ0gsU0FBekIsSUFBc0MvRyxXQUFXLENBQUMrRyxTQUFsRCxJQUErRDlHLEtBQUssQ0FBQzhHLFNBQXJFLElBQWtGLENBQXpGO0FBQ0QsQ0ExRkQ7QUFBQSxJQTJGSUcsaUJBQWlCLEdBQUcsU0FBU0EsaUJBQVQsR0FBNkI7QUFDbkQsU0FBT3BILElBQUksQ0FBQ3FILFdBQUwsSUFBb0JwSCxJQUFJLENBQUNxSCxVQUF6QixJQUF1Q3BILFdBQVcsQ0FBQ29ILFVBQW5ELElBQWlFbkgsS0FBSyxDQUFDbUgsVUFBdkUsSUFBcUYsQ0FBNUY7QUFDRCxDQTdGRDtBQUFBLElBOEZJOC9ELFNBQVMsR0FBRyxTQUFTQSxTQUFULENBQW1CemhFLE9BQW5CLEVBQTRCO0FBQzFDLFNBQU9BLE9BQU8sQ0FBQ2dHLGVBQVIsS0FBNEIsQ0FBQ2hHLE9BQU8sQ0FBQ2dpQixPQUFSLEdBQWtCLEVBQW5CLEVBQXVCOWUsV0FBdkIsT0FBeUMsS0FBekMsR0FBaURsRCxPQUFqRCxHQUEyRCxJQUF2RixDQUFQO0FBQ0QsQ0FoR0Q7QUFBQSxJQWlHSXVJLFFBQVEsR0FBRyxTQUFTQSxRQUFULENBQWtCdkksT0FBbEIsRUFBMkI7QUFDeEMsTUFBSTNGLElBQUksQ0FBQytJLGdCQUFMLENBQXNCcEQsT0FBdEIsRUFBK0J3SSxRQUEvQixLQUE0QyxPQUFoRCxFQUF5RDtBQUN2RCxXQUFPLElBQVA7QUFDRDs7QUFFRHhJLEVBQUFBLE9BQU8sR0FBR0EsT0FBTyxDQUFDK0IsVUFBbEI7O0FBRUEsTUFBSS9CLE9BQU8sSUFBSUEsT0FBTyxDQUFDaUMsUUFBUixLQUFxQixDQUFwQyxFQUF1QztBQUNyQztBQUNBLFdBQU9zRyxRQUFRLENBQUN2SSxPQUFELENBQWY7QUFDRDtBQUNGLENBNUdEO0FBQUEsSUE2R0kwaEUsY0FBYyxHQUFHLFNBQVNBLGNBQVQsQ0FBd0IxaEUsT0FBeEIsRUFBaUN4QixDQUFqQyxFQUFvQztBQUN2RCxNQUFJd0IsT0FBTyxDQUFDK0IsVUFBUixLQUF1QnpILElBQUksSUFBSThtRSxPQUFPLENBQUNwaEUsT0FBRCxDQUF0QyxDQUFKLEVBQXNEO0FBQ3BELFFBQUlnd0IsR0FBRyxHQUFHeXhDLFNBQVMsQ0FBQ3poRSxPQUFELENBQW5CO0FBQUEsUUFDSXRELEVBQUUsR0FBR3N6QixHQUFHLEdBQUdBLEdBQUcsQ0FBQ3BvQixZQUFKLENBQWlCLE9BQWpCLEtBQTZCLDRCQUFoQyxHQUErRCw4QkFEM0U7QUFBQSxRQUVJbkwsSUFBSSxHQUFHdXpCLEdBQUcsR0FBR3h4QixDQUFDLEdBQUcsTUFBSCxHQUFZLEdBQWhCLEdBQXNCLEtBRnBDO0FBQUEsUUFHSWtFLENBQUMsR0FBR2xFLENBQUMsS0FBSyxDQUFOLEdBQVUsQ0FBVixHQUFjLEdBSHRCO0FBQUEsUUFJSW1FLENBQUMsR0FBR25FLENBQUMsS0FBSyxDQUFOLEdBQVUsR0FBVixHQUFnQixDQUp4QjtBQUFBLFFBS0lpbEMsR0FBRyxHQUFHLHlFQUxWO0FBQUEsUUFNSTltQyxDQUFDLEdBQUdyQyxJQUFJLENBQUNzQyxlQUFMLEdBQXVCdEMsSUFBSSxDQUFDc0MsZUFBTCxDQUFxQkYsRUFBRSxDQUFDRyxPQUFILENBQVcsUUFBWCxFQUFxQixNQUFyQixDQUFyQixFQUFtREosSUFBbkQsQ0FBdkIsR0FBa0ZuQyxJQUFJLENBQUN3QyxhQUFMLENBQW1CTCxJQUFuQixDQU4xRjs7QUFRQSxRQUFJK0IsQ0FBSixFQUFPO0FBQ0wsVUFBSSxDQUFDd3hCLEdBQUwsRUFBVTtBQUNSLFlBQUksQ0FBQ2d4QyxhQUFMLEVBQW9CO0FBQ2xCQSxVQUFBQSxhQUFhLEdBQUdVLGNBQWMsQ0FBQzFoRSxPQUFELENBQTlCO0FBQ0FnaEUsVUFBQUEsYUFBYSxDQUFDamtFLEtBQWQsQ0FBb0IrTyxPQUFwQixHQUE4QjIzQixHQUE5QjtBQUNEOztBQUVEOW1DLFFBQUFBLENBQUMsQ0FBQ0ksS0FBRixDQUFRK08sT0FBUixHQUFrQjIzQixHQUFHLEdBQUcsK0JBQU4sR0FBd0M5Z0MsQ0FBeEMsR0FBNEMsVUFBNUMsR0FBeURELENBQXpELEdBQTZELElBQS9FOztBQUVBcytELFFBQUFBLGFBQWEsQ0FBQ2wyRCxXQUFkLENBQTBCbk8sQ0FBMUI7QUFDRCxPQVRELE1BU087QUFDTHNrRSxRQUFBQSxhQUFhLEtBQUtBLGFBQWEsR0FBR1MsY0FBYyxDQUFDMWhFLE9BQUQsQ0FBbkMsQ0FBYjtBQUNBckQsUUFBQUEsQ0FBQyxDQUFDNm1CLFlBQUYsQ0FBZSxPQUFmLEVBQXdCLElBQXhCO0FBQ0E3bUIsUUFBQUEsQ0FBQyxDQUFDNm1CLFlBQUYsQ0FBZSxRQUFmLEVBQXlCLElBQXpCO0FBQ0E3bUIsUUFBQUEsQ0FBQyxDQUFDNm1CLFlBQUYsQ0FBZSxXQUFmLEVBQTRCLGVBQWU5Z0IsQ0FBZixHQUFtQixHQUFuQixHQUF5QkMsQ0FBekIsR0FBNkIsR0FBekQ7O0FBRUFzK0QsUUFBQUEsYUFBYSxDQUFDbjJELFdBQWQsQ0FBMEJuTyxDQUExQjtBQUNEO0FBQ0Y7O0FBRUQsV0FBT0EsQ0FBUDtBQUNEOztBQUVELFFBQU0sMkJBQU47QUFDRCxDQS9JRDtBQUFBLElBZ0pJZ2xFLFlBQVksR0FBRyxTQUFTQSxZQUFULENBQXNCMWxELENBQXRCLEVBQXlCO0FBQzFDO0FBQ0EsTUFBSWpELENBQUMsR0FBRyxJQUFJN2UsUUFBSixFQUFSO0FBQUEsTUFDSXFFLENBQUMsR0FBRyxDQURSOztBQUdBLFNBQU9BLENBQUMsR0FBR3lkLENBQUMsQ0FBQzJsRCxhQUFiLEVBQTRCcGpFLENBQUMsRUFBN0IsRUFBaUM7QUFDL0J3YSxJQUFBQSxDQUFDLENBQUMvUixRQUFGLENBQVdnVixDQUFDLENBQUM0bEQsT0FBRixDQUFVcmpFLENBQVYsRUFBYXlILE1BQXhCO0FBQ0Q7O0FBRUQsU0FBTytTLENBQVA7QUFDRCxDQTFKRDtBQUFBLElBMkpJOG9ELE9BQU8sR0FBRyxTQUFTQSxPQUFULENBQWlCOXhDLEdBQWpCLEVBQXNCO0FBQ2xDLE1BQUkvVCxDQUFDLEdBQUcrVCxHQUFHLENBQUMycUMsTUFBSixFQUFSO0FBQUEsTUFDSWhsQixTQURKOztBQUdBLE1BQUksQ0FBQzE1QixDQUFMLEVBQVE7QUFDTjtBQUNBMDVCLElBQUFBLFNBQVMsR0FBRzNsQixHQUFHLENBQUNqekIsS0FBSixDQUFVZixjQUFWLENBQVo7QUFDQWcwQixJQUFBQSxHQUFHLENBQUNqekIsS0FBSixDQUFVZixjQUFWLElBQTRCLE1BQTVCLENBSE0sQ0FHOEI7O0FBRXBDZzBCLElBQUFBLEdBQUcsQ0FBQ2xsQixXQUFKLENBQWdCbzJELElBQWhCO0FBQ0FqbEQsSUFBQUEsQ0FBQyxHQUFHaWxELElBQUksQ0FBQ3ZHLE1BQUwsRUFBSjtBQUNBM3FDLElBQUFBLEdBQUcsQ0FBQ2psQixXQUFKLENBQWdCbTJELElBQWhCO0FBQ0F2ckIsSUFBQUEsU0FBUyxHQUFHM2xCLEdBQUcsQ0FBQ2p6QixLQUFKLENBQVVmLGNBQVYsSUFBNEIyNUMsU0FBL0IsR0FBMkMzbEIsR0FBRyxDQUFDanpCLEtBQUosQ0FBVTZCLGNBQVYsQ0FBeUI1QyxjQUFjLENBQUNhLE9BQWYsQ0FBdUIsVUFBdkIsRUFBbUMsS0FBbkMsRUFBMENxRyxXQUExQyxFQUF6QixDQUFwRDtBQUNEOztBQUVELFNBQU8rWSxDQUFDLElBQUk5ZSxlQUFlLENBQUNvekIsS0FBaEIsRUFBWixDQWZrQyxDQWVHO0FBQ3RDLENBM0tEO0FBQUEsSUE0S0l3eEMsY0FBYyxHQUFHLFNBQVNBLGNBQVQsQ0FBd0IvaEUsT0FBeEIsRUFBaUNnaUUsYUFBakMsRUFBZ0Q7QUFDbkUsTUFBSWh5QyxHQUFHLEdBQUd5eEMsU0FBUyxDQUFDemhFLE9BQUQsQ0FBbkI7QUFBQSxNQUNJdzdELFNBQVMsR0FBR3g3RCxPQUFPLEtBQUtnd0IsR0FENUI7QUFBQSxNQUVJaXlDLFFBQVEsR0FBR2p5QyxHQUFHLEdBQUd1eEMsU0FBSCxHQUFlQyxTQUZqQztBQUFBLE1BR0lqMUQsTUFBTSxHQUFHdk0sT0FBTyxDQUFDK0IsVUFIckI7QUFBQSxNQUlJa2hDLFNBSko7QUFBQSxNQUtJaG5CLENBTEo7QUFBQSxNQU1JaEQsQ0FOSjtBQUFBLE1BT0l2VyxDQVBKO0FBQUEsTUFRSUMsQ0FSSjtBQUFBLE1BU0k0RCxFQVRKOztBQVdBLE1BQUl2RyxPQUFPLEtBQUszRixJQUFoQixFQUFzQjtBQUNwQixXQUFPMkYsT0FBUDtBQUNEOztBQUVEaWlFLEVBQUFBLFFBQVEsQ0FBQ3hqRSxNQUFULElBQW1Cd2pFLFFBQVEsQ0FBQ2hqRSxJQUFULENBQWN5aUUsY0FBYyxDQUFDMWhFLE9BQUQsRUFBVSxDQUFWLENBQTVCLEVBQTBDMGhFLGNBQWMsQ0FBQzFoRSxPQUFELEVBQVUsQ0FBVixDQUF4RCxFQUFzRTBoRSxjQUFjLENBQUMxaEUsT0FBRCxFQUFVLENBQVYsQ0FBcEYsQ0FBbkI7QUFDQWlqQyxFQUFBQSxTQUFTLEdBQUdqVCxHQUFHLEdBQUdpeEMsYUFBSCxHQUFtQkQsYUFBbEM7O0FBRUEsTUFBSWh4QyxHQUFKLEVBQVM7QUFDUCxRQUFJd3JDLFNBQUosRUFBZTtBQUNidmlELE1BQUFBLENBQUMsR0FBRzZvRCxPQUFPLENBQUM5aEUsT0FBRCxDQUFYO0FBQ0EwQyxNQUFBQSxDQUFDLEdBQUcsQ0FBQ3VXLENBQUMsQ0FBQ3RjLENBQUgsR0FBT3NjLENBQUMsQ0FBQzNSLENBQWI7QUFDQTNFLE1BQUFBLENBQUMsR0FBRyxDQUFDc1csQ0FBQyxDQUFDRSxDQUFILEdBQU9GLENBQUMsQ0FBQ0MsQ0FBYjtBQUNBK0MsTUFBQUEsQ0FBQyxHQUFHOWUsZUFBSjtBQUNELEtBTEQsTUFLTyxJQUFJNkMsT0FBTyxDQUFDK0YsT0FBWixFQUFxQjtBQUMxQmtULE1BQUFBLENBQUMsR0FBR2paLE9BQU8sQ0FBQytGLE9BQVIsRUFBSjtBQUNBa1csTUFBQUEsQ0FBQyxHQUFHamMsT0FBTyxDQUFDMjFDLFNBQVIsR0FBb0IzMUMsT0FBTyxDQUFDMjFDLFNBQVIsQ0FBa0JqdkMsT0FBdEMsR0FBZ0QsRUFBcEQsQ0FGMEIsQ0FFOEI7O0FBRXhEdVYsTUFBQUEsQ0FBQyxHQUFHLENBQUNBLENBQUMsQ0FBQzJsRCxhQUFILEdBQW1CemtFLGVBQW5CLEdBQXFDOGUsQ0FBQyxDQUFDMmxELGFBQUYsR0FBa0IsQ0FBbEIsR0FBc0JELFlBQVksQ0FBQzFsRCxDQUFELENBQWxDLEdBQXdDQSxDQUFDLENBQUM0bEQsT0FBRixDQUFVLENBQVYsRUFBYTU3RCxNQUE5RixDQUowQixDQUk0RTs7QUFFdEd2RCxNQUFBQSxDQUFDLEdBQUd1WixDQUFDLENBQUMzVSxDQUFGLEdBQU0yUixDQUFDLENBQUN2VyxDQUFSLEdBQVl1WixDQUFDLENBQUNqRCxDQUFGLEdBQU1DLENBQUMsQ0FBQ3RXLENBQXhCO0FBQ0FBLE1BQUFBLENBQUMsR0FBR3NaLENBQUMsQ0FBQ2hELENBQUYsR0FBTUEsQ0FBQyxDQUFDdlcsQ0FBUixHQUFZdVosQ0FBQyxDQUFDL0MsQ0FBRixHQUFNRCxDQUFDLENBQUN0VyxDQUF4QjtBQUNELEtBUk0sTUFRQTtBQUNMO0FBQ0FzWixNQUFBQSxDQUFDLEdBQUcsSUFBSTloQixRQUFKLEVBQUo7QUFDQXVJLE1BQUFBLENBQUMsR0FBR0MsQ0FBQyxHQUFHLENBQVI7QUFDRDs7QUFFRCxRQUFJcS9ELGFBQWEsSUFBSWhpRSxPQUFPLENBQUNnaUIsT0FBUixDQUFnQjllLFdBQWhCLE9BQWtDLEdBQXZELEVBQTREO0FBQzFEUixNQUFBQSxDQUFDLEdBQUdDLENBQUMsR0FBRyxDQUFSO0FBQ0Q7O0FBRUQsS0FBQzY0RCxTQUFTLEdBQUd4ckMsR0FBSCxHQUFTempCLE1BQW5CLEVBQTJCekIsV0FBM0IsQ0FBdUNtNEIsU0FBdkM7QUFDQUEsSUFBQUEsU0FBUyxDQUFDemYsWUFBVixDQUF1QixXQUF2QixFQUFvQyxZQUFZdkgsQ0FBQyxDQUFDM1UsQ0FBZCxHQUFrQixHQUFsQixHQUF3QjJVLENBQUMsQ0FBQ2hELENBQTFCLEdBQThCLEdBQTlCLEdBQW9DZ0QsQ0FBQyxDQUFDakQsQ0FBdEMsR0FBMEMsR0FBMUMsR0FBZ0RpRCxDQUFDLENBQUMvQyxDQUFsRCxHQUFzRCxHQUF0RCxJQUE2RCtDLENBQUMsQ0FBQ3RmLENBQUYsR0FBTStGLENBQW5FLElBQXdFLEdBQXhFLElBQStFdVosQ0FBQyxDQUFDOUMsQ0FBRixHQUFNeFcsQ0FBckYsSUFBMEYsR0FBOUg7QUFDRCxHQTFCRCxNQTBCTztBQUNMRCxJQUFBQSxDQUFDLEdBQUdDLENBQUMsR0FBRyxDQUFSOztBQUVBLFFBQUl3K0QsYUFBSixFQUFtQjtBQUNqQjtBQUNBbGxELE1BQUFBLENBQUMsR0FBR2pjLE9BQU8sQ0FBQ285RCxZQUFaO0FBQ0Fua0QsTUFBQUEsQ0FBQyxHQUFHalosT0FBSjs7QUFFQSxhQUFPaVosQ0FBQyxLQUFLQSxDQUFDLEdBQUdBLENBQUMsQ0FBQ2xYLFVBQVgsQ0FBRCxJQUEyQmtYLENBQUMsS0FBS2dELENBQWpDLElBQXNDaEQsQ0FBQyxDQUFDbFgsVUFBL0MsRUFBMkQ7QUFDekQsWUFBSSxDQUFDMUgsSUFBSSxDQUFDK0ksZ0JBQUwsQ0FBc0I2VixDQUF0QixFQUF5QmpkLGNBQXpCLElBQTJDLEVBQTVDLEVBQWdEeUMsTUFBaEQsR0FBeUQsQ0FBN0QsRUFBZ0U7QUFDOURpRSxVQUFBQSxDQUFDLEdBQUd1VyxDQUFDLENBQUM5UCxVQUFOO0FBQ0F4RyxVQUFBQSxDQUFDLEdBQUdzVyxDQUFDLENBQUMvUCxTQUFOO0FBQ0ErUCxVQUFBQSxDQUFDLEdBQUcsQ0FBSjtBQUNEO0FBQ0Y7QUFDRjs7QUFFRDFTLElBQUFBLEVBQUUsR0FBR2xNLElBQUksQ0FBQytJLGdCQUFMLENBQXNCcEQsT0FBdEIsQ0FBTDs7QUFFQSxRQUFJdUcsRUFBRSxDQUFDaUMsUUFBSCxLQUFnQixVQUFoQixJQUE4QmpDLEVBQUUsQ0FBQ2lDLFFBQUgsS0FBZ0IsT0FBbEQsRUFBMkQ7QUFDekR5VCxNQUFBQSxDQUFDLEdBQUdqYyxPQUFPLENBQUNvOUQsWUFBWjs7QUFFQSxhQUFPN3dELE1BQU0sSUFBSUEsTUFBTSxLQUFLMFAsQ0FBNUIsRUFBK0I7QUFDN0I7QUFDQXZaLFFBQUFBLENBQUMsSUFBSTZKLE1BQU0sQ0FBQzVLLFVBQVAsSUFBcUIsQ0FBMUI7QUFDQWdCLFFBQUFBLENBQUMsSUFBSTRKLE1BQU0sQ0FBQ2pMLFNBQVAsSUFBb0IsQ0FBekI7QUFDQWlMLFFBQUFBLE1BQU0sR0FBR0EsTUFBTSxDQUFDeEssVUFBaEI7QUFDRDtBQUNGOztBQUVEa1gsSUFBQUEsQ0FBQyxHQUFHZ3FCLFNBQVMsQ0FBQ2xtQyxLQUFkO0FBQ0FrYyxJQUFBQSxDQUFDLENBQUN2VixHQUFGLEdBQVExRCxPQUFPLENBQUNrSixTQUFSLEdBQW9CdkcsQ0FBcEIsR0FBd0IsSUFBaEM7QUFDQXNXLElBQUFBLENBQUMsQ0FBQ3hWLElBQUYsR0FBU3pELE9BQU8sQ0FBQ21KLFVBQVIsR0FBcUJ6RyxDQUFyQixHQUF5QixJQUFsQztBQUNBdVcsSUFBQUEsQ0FBQyxDQUFDamQsY0FBRCxDQUFELEdBQW9CdUssRUFBRSxDQUFDdkssY0FBRCxDQUF0QjtBQUNBaWQsSUFBQUEsQ0FBQyxDQUFDaGQsb0JBQUQsQ0FBRCxHQUEwQnNLLEVBQUUsQ0FBQ3RLLG9CQUFELENBQTVCLENBbENLLENBa0MrQztBQUNwRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQWdkLElBQUFBLENBQUMsQ0FBQ3pRLFFBQUYsR0FBYWpDLEVBQUUsQ0FBQ2lDLFFBQUgsS0FBZ0IsT0FBaEIsR0FBMEIsT0FBMUIsR0FBb0MsVUFBakQ7QUFDQXhJLElBQUFBLE9BQU8sQ0FBQytCLFVBQVIsQ0FBbUIrSSxXQUFuQixDQUErQm00QixTQUEvQjtBQUNEOztBQUVELFNBQU9BLFNBQVA7QUFDRCxDQXRRRDtBQUFBLElBdVFJaS9CLFVBQVUsR0FBRyxTQUFTQSxVQUFULENBQW9Cam1ELENBQXBCLEVBQXVCM1UsQ0FBdkIsRUFBMEIyUixDQUExQixFQUE2QkQsQ0FBN0IsRUFBZ0NFLENBQWhDLEVBQW1DdmMsQ0FBbkMsRUFBc0N3YyxDQUF0QyxFQUF5QztBQUN4RDhDLEVBQUFBLENBQUMsQ0FBQzNVLENBQUYsR0FBTUEsQ0FBTjtBQUNBMlUsRUFBQUEsQ0FBQyxDQUFDaEQsQ0FBRixHQUFNQSxDQUFOO0FBQ0FnRCxFQUFBQSxDQUFDLENBQUNqRCxDQUFGLEdBQU1BLENBQU47QUFDQWlELEVBQUFBLENBQUMsQ0FBQy9DLENBQUYsR0FBTUEsQ0FBTjtBQUNBK0MsRUFBQUEsQ0FBQyxDQUFDdGYsQ0FBRixHQUFNQSxDQUFOO0FBQ0FzZixFQUFBQSxDQUFDLENBQUM5QyxDQUFGLEdBQU1BLENBQU47QUFDQSxTQUFPOEMsQ0FBUDtBQUNELENBL1FEOztBQWlSTyxJQUFJOWhCLFFBQVEsR0FBRyxhQUFhLFlBQVk7QUFDN0MsV0FBU0EsUUFBVCxDQUFrQm1OLENBQWxCLEVBQXFCMlIsQ0FBckIsRUFBd0JELENBQXhCLEVBQTJCRSxDQUEzQixFQUE4QnZjLENBQTlCLEVBQWlDd2MsQ0FBakMsRUFBb0M7QUFDbEMsUUFBSTdSLENBQUMsS0FBSyxLQUFLLENBQWYsRUFBa0I7QUFDaEJBLE1BQUFBLENBQUMsR0FBRyxDQUFKO0FBQ0Q7O0FBRUQsUUFBSTJSLENBQUMsS0FBSyxLQUFLLENBQWYsRUFBa0I7QUFDaEJBLE1BQUFBLENBQUMsR0FBRyxDQUFKO0FBQ0Q7O0FBRUQsUUFBSUQsQ0FBQyxLQUFLLEtBQUssQ0FBZixFQUFrQjtBQUNoQkEsTUFBQUEsQ0FBQyxHQUFHLENBQUo7QUFDRDs7QUFFRCxRQUFJRSxDQUFDLEtBQUssS0FBSyxDQUFmLEVBQWtCO0FBQ2hCQSxNQUFBQSxDQUFDLEdBQUcsQ0FBSjtBQUNEOztBQUVELFFBQUl2YyxDQUFDLEtBQUssS0FBSyxDQUFmLEVBQWtCO0FBQ2hCQSxNQUFBQSxDQUFDLEdBQUcsQ0FBSjtBQUNEOztBQUVELFFBQUl3YyxDQUFDLEtBQUssS0FBSyxDQUFmLEVBQWtCO0FBQ2hCQSxNQUFBQSxDQUFDLEdBQUcsQ0FBSjtBQUNEOztBQUVEK29ELElBQUFBLFVBQVUsQ0FBQyxJQUFELEVBQU81NkQsQ0FBUCxFQUFVMlIsQ0FBVixFQUFhRCxDQUFiLEVBQWdCRSxDQUFoQixFQUFtQnZjLENBQW5CLEVBQXNCd2MsQ0FBdEIsQ0FBVjtBQUNEOztBQUVELE1BQUkzTCxNQUFNLEdBQUdyVCxRQUFRLENBQUNOLFNBQXRCOztBQUVBMlQsRUFBQUEsTUFBTSxDQUFDdUksT0FBUCxHQUFpQixTQUFTQSxPQUFULEdBQW1CO0FBQ2xDLFFBQUl6TyxDQUFDLEdBQUcsS0FBS0EsQ0FBYjtBQUFBLFFBQ0kyUixDQUFDLEdBQUcsS0FBS0EsQ0FEYjtBQUFBLFFBRUlELENBQUMsR0FBRyxLQUFLQSxDQUZiO0FBQUEsUUFHSUUsQ0FBQyxHQUFHLEtBQUtBLENBSGI7QUFBQSxRQUlJdmMsQ0FBQyxHQUFHLEtBQUtBLENBSmI7QUFBQSxRQUtJd2MsQ0FBQyxHQUFHLEtBQUtBLENBTGI7QUFBQSxRQU1JOGtELFdBQVcsR0FBRzMyRCxDQUFDLEdBQUc0UixDQUFKLEdBQVFELENBQUMsR0FBR0QsQ0FBWixJQUFpQixLQU5uQztBQU9BLFdBQU9rcEQsVUFBVSxDQUFDLElBQUQsRUFBT2hwRCxDQUFDLEdBQUcra0QsV0FBWCxFQUF3QixDQUFDaGxELENBQUQsR0FBS2dsRCxXQUE3QixFQUEwQyxDQUFDamxELENBQUQsR0FBS2lsRCxXQUEvQyxFQUE0RDMyRCxDQUFDLEdBQUcyMkQsV0FBaEUsRUFBNkUsQ0FBQ2psRCxDQUFDLEdBQUdHLENBQUosR0FBUUQsQ0FBQyxHQUFHdmMsQ0FBYixJQUFrQnNoRSxXQUEvRixFQUE0RyxFQUFFMzJELENBQUMsR0FBRzZSLENBQUosR0FBUUYsQ0FBQyxHQUFHdGMsQ0FBZCxJQUFtQnNoRSxXQUEvSCxDQUFqQjtBQUNELEdBVEQ7O0FBV0F6d0QsRUFBQUEsTUFBTSxDQUFDdkcsUUFBUCxHQUFrQixTQUFTQSxRQUFULENBQWtCaEIsTUFBbEIsRUFBMEI7QUFDMUMsUUFBSXFCLENBQUMsR0FBRyxLQUFLQSxDQUFiO0FBQUEsUUFDSTJSLENBQUMsR0FBRyxLQUFLQSxDQURiO0FBQUEsUUFFSUQsQ0FBQyxHQUFHLEtBQUtBLENBRmI7QUFBQSxRQUdJRSxDQUFDLEdBQUcsS0FBS0EsQ0FIYjtBQUFBLFFBSUl2YyxDQUFDLEdBQUcsS0FBS0EsQ0FKYjtBQUFBLFFBS0l3YyxDQUFDLEdBQUcsS0FBS0EsQ0FMYjtBQUFBLFFBTUk4aEMsRUFBRSxHQUFHaDFDLE1BQU0sQ0FBQ3FCLENBTmhCO0FBQUEsUUFPSTY2RCxFQUFFLEdBQUdsOEQsTUFBTSxDQUFDK1MsQ0FQaEI7QUFBQSxRQVFJb3BELEVBQUUsR0FBR244RCxNQUFNLENBQUNnVCxDQVJoQjtBQUFBLFFBU0kyUyxFQUFFLEdBQUczbEIsTUFBTSxDQUFDaVQsQ0FUaEI7QUFBQSxRQVVJbXBELEVBQUUsR0FBR3A4RCxNQUFNLENBQUN0SixDQVZoQjtBQUFBLFFBV0l1aUMsRUFBRSxHQUFHajVCLE1BQU0sQ0FBQ2tULENBWGhCO0FBWUEsV0FBTytvRCxVQUFVLENBQUMsSUFBRCxFQUFPam5CLEVBQUUsR0FBRzN6QyxDQUFMLEdBQVM4NkQsRUFBRSxHQUFHcHBELENBQXJCLEVBQXdCaWlDLEVBQUUsR0FBR2hpQyxDQUFMLEdBQVNtcEQsRUFBRSxHQUFHbHBELENBQXRDLEVBQXlDaXBELEVBQUUsR0FBRzc2RCxDQUFMLEdBQVNza0IsRUFBRSxHQUFHNVMsQ0FBdkQsRUFBMERtcEQsRUFBRSxHQUFHbHBELENBQUwsR0FBUzJTLEVBQUUsR0FBRzFTLENBQXhFLEVBQTJFdmMsQ0FBQyxHQUFHMGxFLEVBQUUsR0FBRy82RCxDQUFULEdBQWE0M0IsRUFBRSxHQUFHbG1CLENBQTdGLEVBQWdHRyxDQUFDLEdBQUdrcEQsRUFBRSxHQUFHcHBELENBQVQsR0FBYWltQixFQUFFLEdBQUdobUIsQ0FBbEgsQ0FBakI7QUFDRCxHQWREOztBQWdCQTFMLEVBQUFBLE1BQU0sQ0FBQytpQixLQUFQLEdBQWUsU0FBU0EsS0FBVCxHQUFpQjtBQUM5QixXQUFPLElBQUlwMkIsUUFBSixDQUFhLEtBQUttTixDQUFsQixFQUFxQixLQUFLMlIsQ0FBMUIsRUFBNkIsS0FBS0QsQ0FBbEMsRUFBcUMsS0FBS0UsQ0FBMUMsRUFBNkMsS0FBS3ZjLENBQWxELEVBQXFELEtBQUt3YyxDQUExRCxDQUFQO0FBQ0QsR0FGRDs7QUFJQTNMLEVBQUFBLE1BQU0sQ0FBQ3NJLE1BQVAsR0FBZ0IsU0FBU0EsTUFBVCxDQUFnQjdQLE1BQWhCLEVBQXdCO0FBQ3RDLFFBQUlxQixDQUFDLEdBQUcsS0FBS0EsQ0FBYjtBQUFBLFFBQ0kyUixDQUFDLEdBQUcsS0FBS0EsQ0FEYjtBQUFBLFFBRUlELENBQUMsR0FBRyxLQUFLQSxDQUZiO0FBQUEsUUFHSUUsQ0FBQyxHQUFHLEtBQUtBLENBSGI7QUFBQSxRQUlJdmMsQ0FBQyxHQUFHLEtBQUtBLENBSmI7QUFBQSxRQUtJd2MsQ0FBQyxHQUFHLEtBQUtBLENBTGI7QUFNQSxXQUFPN1IsQ0FBQyxLQUFLckIsTUFBTSxDQUFDcUIsQ0FBYixJQUFrQjJSLENBQUMsS0FBS2hULE1BQU0sQ0FBQ2dULENBQS9CLElBQW9DRCxDQUFDLEtBQUsvUyxNQUFNLENBQUMrUyxDQUFqRCxJQUFzREUsQ0FBQyxLQUFLalQsTUFBTSxDQUFDaVQsQ0FBbkUsSUFBd0V2YyxDQUFDLEtBQUtzSixNQUFNLENBQUN0SixDQUFyRixJQUEwRndjLENBQUMsS0FBS2xULE1BQU0sQ0FBQ2tULENBQTlHO0FBQ0QsR0FSRDs7QUFVQTNMLEVBQUFBLE1BQU0sQ0FBQzFJLEtBQVAsR0FBZSxTQUFTQSxLQUFULENBQWU4TyxLQUFmLEVBQXNCaVQsU0FBdEIsRUFBaUM7QUFDOUMsUUFBSUEsU0FBUyxLQUFLLEtBQUssQ0FBdkIsRUFBMEI7QUFDeEJBLE1BQUFBLFNBQVMsR0FBRyxFQUFaO0FBQ0Q7O0FBRUQsUUFBSW5rQixDQUFDLEdBQUdrUixLQUFLLENBQUNsUixDQUFkO0FBQUEsUUFDSUMsQ0FBQyxHQUFHaVIsS0FBSyxDQUFDalIsQ0FEZDtBQUFBLFFBRUkyRSxDQUFDLEdBQUcsS0FBS0EsQ0FGYjtBQUFBLFFBR0kyUixDQUFDLEdBQUcsS0FBS0EsQ0FIYjtBQUFBLFFBSUlELENBQUMsR0FBRyxLQUFLQSxDQUpiO0FBQUEsUUFLSUUsQ0FBQyxHQUFHLEtBQUtBLENBTGI7QUFBQSxRQU1JdmMsQ0FBQyxHQUFHLEtBQUtBLENBTmI7QUFBQSxRQU9Jd2MsQ0FBQyxHQUFHLEtBQUtBLENBUGI7QUFRQTBOLElBQUFBLFNBQVMsQ0FBQ25rQixDQUFWLEdBQWNBLENBQUMsR0FBRzRFLENBQUosR0FBUTNFLENBQUMsR0FBR3FXLENBQVosR0FBZ0JyYyxDQUFoQixJQUFxQixDQUFuQztBQUNBa3FCLElBQUFBLFNBQVMsQ0FBQ2xrQixDQUFWLEdBQWNELENBQUMsR0FBR3VXLENBQUosR0FBUXRXLENBQUMsR0FBR3VXLENBQVosR0FBZ0JDLENBQWhCLElBQXFCLENBQW5DO0FBQ0EsV0FBTzBOLFNBQVA7QUFDRCxHQWhCRDs7QUFrQkEsU0FBTzFzQixRQUFQO0FBQ0QsQ0EzRmtDLEVBQTVCLEVBMkZGO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVPLFNBQVNELGVBQVQsQ0FBeUI4RixPQUF6QixFQUFrQytWLE9BQWxDLEVBQTJDaXNELGFBQTNDLEVBQTBETSxvQkFBMUQsRUFBZ0Y7QUFDckY7QUFDQSxNQUFJLENBQUN0aUUsT0FBRCxJQUFZLENBQUNBLE9BQU8sQ0FBQytCLFVBQXJCLElBQW1DLENBQUN6SCxJQUFJLElBQUk4bUUsT0FBTyxDQUFDcGhFLE9BQUQsQ0FBaEIsRUFBMkJ1QixlQUEzQixLQUErQ3ZCLE9BQXRGLEVBQStGO0FBQzdGLFdBQU8sSUFBSTdGLFFBQUosRUFBUDtBQUNEOztBQUVELE1BQUlvb0UsVUFBVSxHQUFHakIsa0JBQWtCLENBQUN0aEUsT0FBRCxDQUFuQztBQUFBLE1BQ0lnd0IsR0FBRyxHQUFHeXhDLFNBQVMsQ0FBQ3poRSxPQUFELENBRG5CO0FBQUEsTUFFSXdpRSxLQUFLLEdBQUd4eUMsR0FBRyxHQUFHdXhDLFNBQUgsR0FBZUMsU0FGOUI7QUFBQSxNQUdJditCLFNBQVMsR0FBRzgrQixjQUFjLENBQUMvaEUsT0FBRCxFQUFVZ2lFLGFBQVYsQ0FIOUI7QUFBQSxNQUlJUyxFQUFFLEdBQUdELEtBQUssQ0FBQyxDQUFELENBQUwsQ0FBU2orRCxxQkFBVCxFQUpUO0FBQUEsTUFLSTQ5RCxFQUFFLEdBQUdLLEtBQUssQ0FBQyxDQUFELENBQUwsQ0FBU2orRCxxQkFBVCxFQUxUO0FBQUEsTUFNSW0rRCxFQUFFLEdBQUdGLEtBQUssQ0FBQyxDQUFELENBQUwsQ0FBU2orRCxxQkFBVCxFQU5UO0FBQUEsTUFPSWdJLE1BQU0sR0FBRzAyQixTQUFTLENBQUNsaEMsVUFQdkI7QUFBQSxNQVFJK04sT0FBTyxHQUFHLENBQUN3eUQsb0JBQUQsSUFBeUIvNUQsUUFBUSxDQUFDdkksT0FBRCxDQVIvQztBQUFBLE1BU0lpYyxDQUFDLEdBQUcsSUFBSTloQixRQUFKLENBQWEsQ0FBQ2dvRSxFQUFFLENBQUMxK0QsSUFBSCxHQUFVZy9ELEVBQUUsQ0FBQ2gvRCxJQUFkLElBQXNCLEdBQW5DLEVBQXdDLENBQUMwK0QsRUFBRSxDQUFDeitELEdBQUgsR0FBUysrRCxFQUFFLENBQUMvK0QsR0FBYixJQUFvQixHQUE1RCxFQUFpRSxDQUFDZy9ELEVBQUUsQ0FBQ2ovRCxJQUFILEdBQVVnL0QsRUFBRSxDQUFDaC9ELElBQWQsSUFBc0IsR0FBdkYsRUFBNEYsQ0FBQ2kvRCxFQUFFLENBQUNoL0QsR0FBSCxHQUFTKytELEVBQUUsQ0FBQy8rRCxHQUFiLElBQW9CLEdBQWhILEVBQXFIKytELEVBQUUsQ0FBQ2gvRCxJQUFILElBQVdxTSxPQUFPLEdBQUcsQ0FBSCxHQUFPck8saUJBQWlCLEVBQTFDLENBQXJILEVBQW9LZ2hFLEVBQUUsQ0FBQy8rRCxHQUFILElBQVVvTSxPQUFPLEdBQUcsQ0FBSCxHQUFPM08sZ0JBQWdCLEVBQXhDLENBQXBLLENBVFI7O0FBV0FvTCxFQUFBQSxNQUFNLENBQUN4QixXQUFQLENBQW1CazRCLFNBQW5COztBQUVBLE1BQUlzL0IsVUFBSixFQUFnQjtBQUNkRSxJQUFBQSxFQUFFLEdBQUdGLFVBQVUsQ0FBQzlqRSxNQUFoQjs7QUFFQSxXQUFPZ2tFLEVBQUUsRUFBVCxFQUFhO0FBQ1hOLE1BQUFBLEVBQUUsR0FBR0ksVUFBVSxDQUFDRSxFQUFELENBQWY7QUFDQU4sTUFBQUEsRUFBRSxDQUFDOUksTUFBSCxHQUFZOEksRUFBRSxDQUFDN0ksTUFBSCxHQUFZLENBQXhCO0FBQ0E2SSxNQUFBQSxFQUFFLENBQUN0dkQsZUFBSCxDQUFtQixDQUFuQixFQUFzQnN2RCxFQUF0QjtBQUNEO0FBQ0Y7O0FBRUQsU0FBT3BzRCxPQUFPLEdBQUdrRyxDQUFDLENBQUNsRyxPQUFGLEVBQUgsR0FBaUJrRyxDQUEvQjtBQUNEO0NBQzJFO0FBQzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7QUNuYUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFFLFVBQVUwbUQsTUFBVixFQUFrQkMsT0FBbEIsRUFBNEI7QUFFN0I7O0FBRUEsTUFBSyxzQkFBT0MsTUFBUCxPQUFrQixRQUFsQixJQUE4QixRQUFPQSxNQUFNLENBQUNDLE9BQWQsTUFBMEIsUUFBN0QsRUFBd0U7QUFFdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQUQsSUFBQUEsTUFBTSxDQUFDQyxPQUFQLEdBQWlCSCxNQUFNLENBQUM1NUQsUUFBUCxHQUNoQjY1RCxPQUFPLENBQUVELE1BQUYsRUFBVSxJQUFWLENBRFMsR0FFaEIsVUFBVXRnRCxDQUFWLEVBQWM7QUFDYixVQUFLLENBQUNBLENBQUMsQ0FBQ3RaLFFBQVIsRUFBbUI7QUFDbEIsY0FBTSxJQUFJZzZELEtBQUosQ0FBVywwQ0FBWCxDQUFOO0FBQ0E7O0FBQ0QsYUFBT0gsT0FBTyxDQUFFdmdELENBQUYsQ0FBZDtBQUNBLEtBUEY7QUFRQSxHQWpCRCxNQWlCTztBQUNOdWdELElBQUFBLE9BQU8sQ0FBRUQsTUFBRixDQUFQO0FBQ0EsR0F2QjRCLENBeUI5Qjs7QUFDQyxDQTFCRCxFQTBCSyxPQUFPbm5FLE1BQVAsS0FBa0IsV0FBbEIsR0FBZ0NBLE1BQWhDLEdBQXlDLElBMUI5QyxFQTBCb0QsVUFBVUEsTUFBVixFQUFrQnduRSxRQUFsQixFQUE2QjtBQUVqRjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE1BQUlDLEdBQUcsR0FBRyxFQUFWO0FBRUEsTUFBSUMsUUFBUSxHQUFHcHBFLE1BQU0sQ0FBQ3FwRSxjQUF0QjtBQUVBLE1BQUk5akQsTUFBSyxHQUFHNGpELEdBQUcsQ0FBQzVqRCxLQUFoQjtBQUVBLE1BQUkrakQsSUFBSSxHQUFHSCxHQUFHLENBQUNHLElBQUosR0FBVyxVQUFVQyxLQUFWLEVBQWtCO0FBQ3ZDLFdBQU9KLEdBQUcsQ0FBQ0csSUFBSixDQUFTMzdELElBQVQsQ0FBZTQ3RCxLQUFmLENBQVA7QUFDQSxHQUZVLEdBRVAsVUFBVUEsS0FBVixFQUFrQjtBQUNyQixXQUFPSixHQUFHLENBQUMxaUQsTUFBSixDQUFXemIsS0FBWCxDQUFrQixFQUFsQixFQUFzQnUrRCxLQUF0QixDQUFQO0FBQ0EsR0FKRDtBQU9BLE1BQUlwa0UsSUFBSSxHQUFHZ2tFLEdBQUcsQ0FBQ2hrRSxJQUFmO0FBRUEsTUFBSWdOLE9BQU8sR0FBR2czRCxHQUFHLENBQUNoM0QsT0FBbEI7QUFFQSxNQUFJcTNELFVBQVUsR0FBRyxFQUFqQjtBQUVBLE1BQUlDLFFBQVEsR0FBR0QsVUFBVSxDQUFDQyxRQUExQjtBQUVBLE1BQUlDLE1BQU0sR0FBR0YsVUFBVSxDQUFDRyxjQUF4QjtBQUVBLE1BQUlDLFVBQVUsR0FBR0YsTUFBTSxDQUFDRCxRQUF4QjtBQUVBLE1BQUlJLG9CQUFvQixHQUFHRCxVQUFVLENBQUNqOEQsSUFBWCxDQUFpQjNOLE1BQWpCLENBQTNCO0FBRUEsTUFBSThwRSxPQUFPLEdBQUcsRUFBZDs7QUFFQSxNQUFJQyxVQUFVLEdBQUcsU0FBU0EsVUFBVCxDQUFxQjdsRSxHQUFyQixFQUEyQjtBQUUxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQU8sT0FBT0EsR0FBUCxLQUFlLFVBQWYsSUFBNkIsT0FBT0EsR0FBRyxDQUFDaUUsUUFBWCxLQUF3QixRQUFyRCxJQUNOLE9BQU9qRSxHQUFHLENBQUM4bEUsSUFBWCxLQUFvQixVQURyQjtBQUVBLEdBWEY7O0FBY0EsTUFBSUMsUUFBUSxHQUFHLFNBQVNBLFFBQVQsQ0FBbUIvbEUsR0FBbkIsRUFBeUI7QUFDdEMsV0FBT0EsR0FBRyxJQUFJLElBQVAsSUFBZUEsR0FBRyxLQUFLQSxHQUFHLENBQUN4QyxNQUFsQztBQUNBLEdBRkY7O0FBS0EsTUFBSXVOLFFBQVEsR0FBR3ZOLE1BQU0sQ0FBQ3VOLFFBQXRCO0FBSUMsTUFBSWk3RCx5QkFBeUIsR0FBRztBQUMvQnZuRSxJQUFBQSxJQUFJLEVBQUUsSUFEeUI7QUFFL0J3bkUsSUFBQUEsR0FBRyxFQUFFLElBRjBCO0FBRy9CQyxJQUFBQSxLQUFLLEVBQUUsSUFId0I7QUFJL0JDLElBQUFBLFFBQVEsRUFBRTtBQUpxQixHQUFoQzs7QUFPQSxXQUFTQyxPQUFULENBQWtCQyxJQUFsQixFQUF3QnI3RCxJQUF4QixFQUE4QjVILEdBQTlCLEVBQW9DO0FBQ25DQSxJQUFBQSxHQUFHLEdBQUdBLEdBQUcsSUFBSTJILFFBQWI7QUFFQSxRQUFJdkssQ0FBSjtBQUFBLFFBQU9nTyxHQUFQO0FBQUEsUUFDQzgzRCxNQUFNLEdBQUdsakUsR0FBRyxDQUFDdEUsYUFBSixDQUFtQixRQUFuQixDQURWO0FBR0F3bkUsSUFBQUEsTUFBTSxDQUFDQyxJQUFQLEdBQWNGLElBQWQ7O0FBQ0EsUUFBS3I3RCxJQUFMLEVBQVk7QUFDWCxXQUFNeEssQ0FBTixJQUFXd2xFLHlCQUFYLEVBQXVDO0FBRXRDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0F4M0QsUUFBQUEsR0FBRyxHQUFHeEQsSUFBSSxDQUFFeEssQ0FBRixDQUFKLElBQWF3SyxJQUFJLENBQUNwQixZQUFMLElBQXFCb0IsSUFBSSxDQUFDcEIsWUFBTCxDQUFtQnBKLENBQW5CLENBQXhDOztBQUNBLFlBQUtnTyxHQUFMLEVBQVc7QUFDVjgzRCxVQUFBQSxNQUFNLENBQUM5Z0QsWUFBUCxDQUFxQmhsQixDQUFyQixFQUF3QmdPLEdBQXhCO0FBQ0E7QUFDRDtBQUNEOztBQUNEcEwsSUFBQUEsR0FBRyxDQUFDb2pFLElBQUosQ0FBUzE1RCxXQUFULENBQXNCdzVELE1BQXRCLEVBQStCdmlFLFVBQS9CLENBQTBDZ0osV0FBMUMsQ0FBdUR1NUQsTUFBdkQ7QUFDQTs7QUFHRixXQUFTRyxNQUFULENBQWlCem1FLEdBQWpCLEVBQXVCO0FBQ3RCLFFBQUtBLEdBQUcsSUFBSSxJQUFaLEVBQW1CO0FBQ2xCLGFBQU9BLEdBQUcsR0FBRyxFQUFiO0FBQ0EsS0FIcUIsQ0FLdEI7OztBQUNBLFdBQU8sUUFBT0EsR0FBUCxNQUFlLFFBQWYsSUFBMkIsT0FBT0EsR0FBUCxLQUFlLFVBQTFDLEdBQ05zbEUsVUFBVSxDQUFFQyxRQUFRLENBQUM5N0QsSUFBVCxDQUFlekosR0FBZixDQUFGLENBQVYsSUFBc0MsUUFEaEMsV0FFQ0EsR0FGRCxDQUFQO0FBR0E7QUFDRDtBQUNBO0FBQ0E7OztBQUlBLE1BQ0NzZixPQUFPLEdBQUcsT0FEWDtBQUFBLE1BR0M7QUFDQW9uRCxFQUFBQSxNQUFNLEdBQUcsU0FBVEEsTUFBUyxDQUFVM2pCLFFBQVYsRUFBb0I1N0MsT0FBcEIsRUFBOEI7QUFFdEM7QUFDQTtBQUNBLFdBQU8sSUFBSXUvRCxNQUFNLENBQUNDLEVBQVAsQ0FBVTF5QyxJQUFkLENBQW9COHVCLFFBQXBCLEVBQThCNTdDLE9BQTlCLENBQVA7QUFDQSxHQVRGOztBQVdBdS9ELEVBQUFBLE1BQU0sQ0FBQ0MsRUFBUCxHQUFZRCxNQUFNLENBQUM3cUUsU0FBUCxHQUFtQjtBQUU5QjtBQUNBK3FFLElBQUFBLE1BQU0sRUFBRXRuRCxPQUhzQjtBQUs5QnRqQixJQUFBQSxXQUFXLEVBQUUwcUUsTUFMaUI7QUFPOUI7QUFDQWptRSxJQUFBQSxNQUFNLEVBQUUsQ0FSc0I7QUFVOUJvSyxJQUFBQSxPQUFPLEVBQUUsbUJBQVc7QUFDbkIsYUFBT3dXLE1BQUssQ0FBQzVYLElBQU4sQ0FBWSxJQUFaLENBQVA7QUFDQSxLQVo2QjtBQWM5QjtBQUNBO0FBQ0FzRixJQUFBQSxHQUFHLEVBQUUsYUFBVTgzRCxHQUFWLEVBQWdCO0FBRXBCO0FBQ0EsVUFBS0EsR0FBRyxJQUFJLElBQVosRUFBbUI7QUFDbEIsZUFBT3hsRCxNQUFLLENBQUM1WCxJQUFOLENBQVksSUFBWixDQUFQO0FBQ0EsT0FMbUIsQ0FPcEI7OztBQUNBLGFBQU9vOUQsR0FBRyxHQUFHLENBQU4sR0FBVSxLQUFNQSxHQUFHLEdBQUcsS0FBS3BtRSxNQUFqQixDQUFWLEdBQXNDLEtBQU1vbUUsR0FBTixDQUE3QztBQUNBLEtBekI2QjtBQTJCOUI7QUFDQTtBQUNBQyxJQUFBQSxTQUFTLEVBQUUsbUJBQVVDLEtBQVYsRUFBa0I7QUFFNUI7QUFDQSxVQUFJQyxHQUFHLEdBQUdOLE1BQU0sQ0FBQ08sS0FBUCxDQUFjLEtBQUtqckUsV0FBTCxFQUFkLEVBQWtDK3FFLEtBQWxDLENBQVYsQ0FINEIsQ0FLNUI7O0FBQ0FDLE1BQUFBLEdBQUcsQ0FBQ0UsVUFBSixHQUFpQixJQUFqQixDQU40QixDQVE1Qjs7QUFDQSxhQUFPRixHQUFQO0FBQ0EsS0F2QzZCO0FBeUM5QjtBQUNBN2pCLElBQUFBLElBQUksRUFBRSxjQUFVdC9DLFFBQVYsRUFBcUI7QUFDMUIsYUFBTzZpRSxNQUFNLENBQUN2akIsSUFBUCxDQUFhLElBQWIsRUFBbUJ0L0MsUUFBbkIsQ0FBUDtBQUNBLEtBNUM2QjtBQThDOUJrYixJQUFBQSxHQUFHLEVBQUUsYUFBVWxiLFFBQVYsRUFBcUI7QUFDekIsYUFBTyxLQUFLaWpFLFNBQUwsQ0FBZ0JKLE1BQU0sQ0FBQzNuRCxHQUFQLENBQVksSUFBWixFQUFrQixVQUFVb29ELElBQVYsRUFBZ0IzbUUsQ0FBaEIsRUFBb0I7QUFDNUQsZUFBT3FELFFBQVEsQ0FBQzRGLElBQVQsQ0FBZTA5RCxJQUFmLEVBQXFCM21FLENBQXJCLEVBQXdCMm1FLElBQXhCLENBQVA7QUFDQSxPQUZzQixDQUFoQixDQUFQO0FBR0EsS0FsRDZCO0FBb0Q5QjlsRCxJQUFBQSxLQUFLLEVBQUUsaUJBQVc7QUFDakIsYUFBTyxLQUFLeWxELFNBQUwsQ0FBZ0J6bEQsTUFBSyxDQUFDdmEsS0FBTixDQUFhLElBQWIsRUFBbUJxRixTQUFuQixDQUFoQixDQUFQO0FBQ0EsS0F0RDZCO0FBd0Q5QjhpQixJQUFBQSxLQUFLLEVBQUUsaUJBQVc7QUFDakIsYUFBTyxLQUFLbTRDLEVBQUwsQ0FBUyxDQUFULENBQVA7QUFDQSxLQTFENkI7QUE0RDlCbDRDLElBQUFBLElBQUksRUFBRSxnQkFBVztBQUNoQixhQUFPLEtBQUtrNEMsRUFBTCxDQUFTLENBQUMsQ0FBVixDQUFQO0FBQ0EsS0E5RDZCO0FBZ0U5QkMsSUFBQUEsSUFBSSxFQUFFLGdCQUFXO0FBQ2hCLGFBQU8sS0FBS1AsU0FBTCxDQUFnQkosTUFBTSxDQUFDWSxJQUFQLENBQWEsSUFBYixFQUFtQixVQUFVQyxLQUFWLEVBQWlCL21FLENBQWpCLEVBQXFCO0FBQzlELGVBQU8sQ0FBRUEsQ0FBQyxHQUFHLENBQU4sSUFBWSxDQUFuQjtBQUNBLE9BRnNCLENBQWhCLENBQVA7QUFHQSxLQXBFNkI7QUFzRTlCZ25FLElBQUFBLEdBQUcsRUFBRSxlQUFXO0FBQ2YsYUFBTyxLQUFLVixTQUFMLENBQWdCSixNQUFNLENBQUNZLElBQVAsQ0FBYSxJQUFiLEVBQW1CLFVBQVVDLEtBQVYsRUFBaUIvbUUsQ0FBakIsRUFBcUI7QUFDOUQsZUFBT0EsQ0FBQyxHQUFHLENBQVg7QUFDQSxPQUZzQixDQUFoQixDQUFQO0FBR0EsS0ExRTZCO0FBNEU5QjRtRSxJQUFBQSxFQUFFLEVBQUUsWUFBVTVtRSxDQUFWLEVBQWM7QUFDakIsVUFBSWluRSxHQUFHLEdBQUcsS0FBS2huRSxNQUFmO0FBQUEsVUFDQ3VtQixDQUFDLEdBQUcsQ0FBQ3htQixDQUFELElBQU9BLENBQUMsR0FBRyxDQUFKLEdBQVFpbkUsR0FBUixHQUFjLENBQXJCLENBREw7QUFFQSxhQUFPLEtBQUtYLFNBQUwsQ0FBZ0I5L0MsQ0FBQyxJQUFJLENBQUwsSUFBVUEsQ0FBQyxHQUFHeWdELEdBQWQsR0FBb0IsQ0FBRSxLQUFNemdELENBQU4sQ0FBRixDQUFwQixHQUFvQyxFQUFwRCxDQUFQO0FBQ0EsS0FoRjZCO0FBa0Y5QnhkLElBQUFBLEdBQUcsRUFBRSxlQUFXO0FBQ2YsYUFBTyxLQUFLMDlELFVBQUwsSUFBbUIsS0FBS2xyRSxXQUFMLEVBQTFCO0FBQ0EsS0FwRjZCO0FBc0Y5QjtBQUNBO0FBQ0FpRixJQUFBQSxJQUFJLEVBQUVBLElBeEZ3QjtBQXlGOUJ5aUMsSUFBQUEsSUFBSSxFQUFFdWhDLEdBQUcsQ0FBQ3ZoQyxJQXpGb0I7QUEwRjlCbmlDLElBQUFBLE1BQU0sRUFBRTBqRSxHQUFHLENBQUMxakU7QUExRmtCLEdBQS9COztBQTZGQW1sRSxFQUFBQSxNQUFNLENBQUNnQixNQUFQLEdBQWdCaEIsTUFBTSxDQUFDQyxFQUFQLENBQVVlLE1BQVYsR0FBbUIsWUFBVztBQUM3QyxRQUFJQyxPQUFKO0FBQUEsUUFBYXZrRCxJQUFiO0FBQUEsUUFBbUI2aUQsR0FBbkI7QUFBQSxRQUF3Qi9sRSxJQUF4QjtBQUFBLFFBQThCMG5FLFdBQTlCO0FBQUEsUUFBMkNyMUMsS0FBM0M7QUFBQSxRQUNDdHZCLE1BQU0sR0FBR2tKLFNBQVMsQ0FBRSxDQUFGLENBQVQsSUFBa0IsRUFENUI7QUFBQSxRQUVDM0wsQ0FBQyxHQUFHLENBRkw7QUFBQSxRQUdDQyxNQUFNLEdBQUcwTCxTQUFTLENBQUMxTCxNQUhwQjtBQUFBLFFBSUNvbkUsSUFBSSxHQUFHLEtBSlIsQ0FENkMsQ0FPN0M7O0FBQ0EsUUFBSyxPQUFPNWtFLE1BQVAsS0FBa0IsU0FBdkIsRUFBbUM7QUFDbEM0a0UsTUFBQUEsSUFBSSxHQUFHNWtFLE1BQVAsQ0FEa0MsQ0FHbEM7O0FBQ0FBLE1BQUFBLE1BQU0sR0FBR2tKLFNBQVMsQ0FBRTNMLENBQUYsQ0FBVCxJQUFrQixFQUEzQjtBQUNBQSxNQUFBQSxDQUFDO0FBQ0QsS0FkNEMsQ0FnQjdDOzs7QUFDQSxRQUFLLFFBQU95QyxNQUFQLE1BQWtCLFFBQWxCLElBQThCLENBQUM0aUUsVUFBVSxDQUFFNWlFLE1BQUYsQ0FBOUMsRUFBMkQ7QUFDMURBLE1BQUFBLE1BQU0sR0FBRyxFQUFUO0FBQ0EsS0FuQjRDLENBcUI3Qzs7O0FBQ0EsUUFBS3pDLENBQUMsS0FBS0MsTUFBWCxFQUFvQjtBQUNuQndDLE1BQUFBLE1BQU0sR0FBRyxJQUFUO0FBQ0F6QyxNQUFBQSxDQUFDO0FBQ0Q7O0FBRUQsV0FBUUEsQ0FBQyxHQUFHQyxNQUFaLEVBQW9CRCxDQUFDLEVBQXJCLEVBQTBCO0FBRXpCO0FBQ0EsVUFBSyxDQUFFbW5FLE9BQU8sR0FBR3g3RCxTQUFTLENBQUUzTCxDQUFGLENBQXJCLEtBQWdDLElBQXJDLEVBQTRDO0FBRTNDO0FBQ0EsYUFBTTRpQixJQUFOLElBQWN1a0QsT0FBZCxFQUF3QjtBQUN2QnpuRSxVQUFBQSxJQUFJLEdBQUd5bkUsT0FBTyxDQUFFdmtELElBQUYsQ0FBZCxDQUR1QixDQUd2QjtBQUNBOztBQUNBLGNBQUtBLElBQUksS0FBSyxXQUFULElBQXdCbmdCLE1BQU0sS0FBSy9DLElBQXhDLEVBQStDO0FBQzlDO0FBQ0EsV0FQc0IsQ0FTdkI7OztBQUNBLGNBQUsybkUsSUFBSSxJQUFJM25FLElBQVIsS0FBa0J3bUUsTUFBTSxDQUFDb0IsYUFBUCxDQUFzQjVuRSxJQUF0QixNQUNwQjBuRSxXQUFXLEdBQUd0cEUsS0FBSyxDQUFDQyxPQUFOLENBQWUyQixJQUFmLENBRE0sQ0FBbEIsQ0FBTCxFQUM2QztBQUM1QytsRSxZQUFBQSxHQUFHLEdBQUdoakUsTUFBTSxDQUFFbWdCLElBQUYsQ0FBWixDQUQ0QyxDQUc1Qzs7QUFDQSxnQkFBS3drRCxXQUFXLElBQUksQ0FBQ3RwRSxLQUFLLENBQUNDLE9BQU4sQ0FBZTBuRSxHQUFmLENBQXJCLEVBQTRDO0FBQzNDMXpDLGNBQUFBLEtBQUssR0FBRyxFQUFSO0FBQ0EsYUFGRCxNQUVPLElBQUssQ0FBQ3ExQyxXQUFELElBQWdCLENBQUNsQixNQUFNLENBQUNvQixhQUFQLENBQXNCN0IsR0FBdEIsQ0FBdEIsRUFBb0Q7QUFDMUQxekMsY0FBQUEsS0FBSyxHQUFHLEVBQVI7QUFDQSxhQUZNLE1BRUE7QUFDTkEsY0FBQUEsS0FBSyxHQUFHMHpDLEdBQVI7QUFDQTs7QUFDRDJCLFlBQUFBLFdBQVcsR0FBRyxLQUFkLENBWDRDLENBYTVDOztBQUNBM2tFLFlBQUFBLE1BQU0sQ0FBRW1nQixJQUFGLENBQU4sR0FBaUJzakQsTUFBTSxDQUFDZ0IsTUFBUCxDQUFlRyxJQUFmLEVBQXFCdDFDLEtBQXJCLEVBQTRCcnlCLElBQTVCLENBQWpCLENBZDRDLENBZ0I3QztBQUNDLFdBbEJELE1Ba0JPLElBQUtBLElBQUksS0FBSzZuRSxTQUFkLEVBQTBCO0FBQ2hDOWtFLFlBQUFBLE1BQU0sQ0FBRW1nQixJQUFGLENBQU4sR0FBaUJsakIsSUFBakI7QUFDQTtBQUNEO0FBQ0Q7QUFDRCxLQWxFNEMsQ0FvRTdDOzs7QUFDQSxXQUFPK0MsTUFBUDtBQUNBLEdBdEVEOztBQXdFQXlqRSxFQUFBQSxNQUFNLENBQUNnQixNQUFQLENBQWU7QUFFZDtBQUNBTSxJQUFBQSxPQUFPLEVBQUUsV0FBVyxDQUFFMW9ELE9BQU8sR0FBR25oQixJQUFJLENBQUM4a0QsTUFBTCxFQUFaLEVBQTRCcGtELE9BQTVCLENBQXFDLEtBQXJDLEVBQTRDLEVBQTVDLENBSE47QUFLZDtBQUNBb3BFLElBQUFBLE9BQU8sRUFBRSxJQU5LO0FBUWR4TCxJQUFBQSxLQUFLLEVBQUUsZUFBVXlMLEdBQVYsRUFBZ0I7QUFDdEIsWUFBTSxJQUFJbkQsS0FBSixDQUFXbUQsR0FBWCxDQUFOO0FBQ0EsS0FWYTtBQVlkQyxJQUFBQSxJQUFJLEVBQUUsZ0JBQVcsQ0FBRSxDQVpMO0FBY2RMLElBQUFBLGFBQWEsRUFBRSx1QkFBVTluRSxHQUFWLEVBQWdCO0FBQzlCLFVBQUlvb0UsS0FBSixFQUFXQyxJQUFYLENBRDhCLENBRzlCO0FBQ0E7O0FBQ0EsVUFBSyxDQUFDcm9FLEdBQUQsSUFBUXVsRSxRQUFRLENBQUM5N0QsSUFBVCxDQUFlekosR0FBZixNQUF5QixpQkFBdEMsRUFBMEQ7QUFDekQsZUFBTyxLQUFQO0FBQ0E7O0FBRURvb0UsTUFBQUEsS0FBSyxHQUFHbEQsUUFBUSxDQUFFbGxFLEdBQUYsQ0FBaEIsQ0FUOEIsQ0FXOUI7O0FBQ0EsVUFBSyxDQUFDb29FLEtBQU4sRUFBYztBQUNiLGVBQU8sSUFBUDtBQUNBLE9BZDZCLENBZ0I5Qjs7O0FBQ0FDLE1BQUFBLElBQUksR0FBRzdDLE1BQU0sQ0FBQy83RCxJQUFQLENBQWEyK0QsS0FBYixFQUFvQixhQUFwQixLQUF1Q0EsS0FBSyxDQUFDcHNFLFdBQXBEO0FBQ0EsYUFBTyxPQUFPcXNFLElBQVAsS0FBZ0IsVUFBaEIsSUFBOEIzQyxVQUFVLENBQUNqOEQsSUFBWCxDQUFpQjQrRCxJQUFqQixNQUE0QjFDLG9CQUFqRTtBQUNBLEtBakNhO0FBbUNkMkMsSUFBQUEsYUFBYSxFQUFFLHVCQUFVdG9FLEdBQVYsRUFBZ0I7QUFDOUIsVUFBSW9qQixJQUFKOztBQUVBLFdBQU1BLElBQU4sSUFBY3BqQixHQUFkLEVBQW9CO0FBQ25CLGVBQU8sS0FBUDtBQUNBOztBQUNELGFBQU8sSUFBUDtBQUNBLEtBMUNhO0FBNENkO0FBQ0E7QUFDQXVvRSxJQUFBQSxVQUFVLEVBQUUsb0JBQVVsQyxJQUFWLEVBQWdCc0IsT0FBaEIsRUFBeUJ2a0UsR0FBekIsRUFBK0I7QUFDMUNnakUsTUFBQUEsT0FBTyxDQUFFQyxJQUFGLEVBQVE7QUFBRUgsUUFBQUEsS0FBSyxFQUFFeUIsT0FBTyxJQUFJQSxPQUFPLENBQUN6QjtBQUE1QixPQUFSLEVBQTZDOWlFLEdBQTdDLENBQVA7QUFDQSxLQWhEYTtBQWtEZCsvQyxJQUFBQSxJQUFJLEVBQUUsY0FBVW5qRCxHQUFWLEVBQWU2RCxRQUFmLEVBQTBCO0FBQy9CLFVBQUlwRCxNQUFKO0FBQUEsVUFBWUQsQ0FBQyxHQUFHLENBQWhCOztBQUVBLFVBQUtnb0UsV0FBVyxDQUFFeG9FLEdBQUYsQ0FBaEIsRUFBMEI7QUFDekJTLFFBQUFBLE1BQU0sR0FBR1QsR0FBRyxDQUFDUyxNQUFiOztBQUNBLGVBQVFELENBQUMsR0FBR0MsTUFBWixFQUFvQkQsQ0FBQyxFQUFyQixFQUEwQjtBQUN6QixjQUFLcUQsUUFBUSxDQUFDNEYsSUFBVCxDQUFlekosR0FBRyxDQUFFUSxDQUFGLENBQWxCLEVBQXlCQSxDQUF6QixFQUE0QlIsR0FBRyxDQUFFUSxDQUFGLENBQS9CLE1BQTJDLEtBQWhELEVBQXdEO0FBQ3ZEO0FBQ0E7QUFDRDtBQUNELE9BUEQsTUFPTztBQUNOLGFBQU1BLENBQU4sSUFBV1IsR0FBWCxFQUFpQjtBQUNoQixjQUFLNkQsUUFBUSxDQUFDNEYsSUFBVCxDQUFlekosR0FBRyxDQUFFUSxDQUFGLENBQWxCLEVBQXlCQSxDQUF6QixFQUE0QlIsR0FBRyxDQUFFUSxDQUFGLENBQS9CLE1BQTJDLEtBQWhELEVBQXdEO0FBQ3ZEO0FBQ0E7QUFDRDtBQUNEOztBQUVELGFBQU9SLEdBQVA7QUFDQSxLQXJFYTtBQXVFZDtBQUNBeW9FLElBQUFBLFNBQVMsRUFBRSxtQkFBVXhELEdBQVYsRUFBZXlELE9BQWYsRUFBeUI7QUFDbkMsVUFBSTFCLEdBQUcsR0FBRzBCLE9BQU8sSUFBSSxFQUFyQjs7QUFFQSxVQUFLekQsR0FBRyxJQUFJLElBQVosRUFBbUI7QUFDbEIsWUFBS3VELFdBQVcsQ0FBRTFzRSxNQUFNLENBQUVtcEUsR0FBRixDQUFSLENBQWhCLEVBQW9DO0FBQ25DeUIsVUFBQUEsTUFBTSxDQUFDTyxLQUFQLENBQWNELEdBQWQsRUFDQyxPQUFPL0IsR0FBUCxLQUFlLFFBQWYsR0FDQyxDQUFFQSxHQUFGLENBREQsR0FDV0EsR0FGWjtBQUlBLFNBTEQsTUFLTztBQUNOaGtFLFVBQUFBLElBQUksQ0FBQ3dJLElBQUwsQ0FBV3U5RCxHQUFYLEVBQWdCL0IsR0FBaEI7QUFDQTtBQUNEOztBQUVELGFBQU8rQixHQUFQO0FBQ0EsS0F2RmE7QUF5RmQyQixJQUFBQSxPQUFPLEVBQUUsaUJBQVV4QixJQUFWLEVBQWdCbEMsR0FBaEIsRUFBcUJ6a0UsQ0FBckIsRUFBeUI7QUFDakMsYUFBT3lrRSxHQUFHLElBQUksSUFBUCxHQUFjLENBQUMsQ0FBZixHQUFtQmgzRCxPQUFPLENBQUN4RSxJQUFSLENBQWN3N0QsR0FBZCxFQUFtQmtDLElBQW5CLEVBQXlCM21FLENBQXpCLENBQTFCO0FBQ0EsS0EzRmE7QUE2RmQ7QUFDQTtBQUNBeW1FLElBQUFBLEtBQUssRUFBRSxlQUFVaDRDLEtBQVYsRUFBaUIyNUMsTUFBakIsRUFBMEI7QUFDaEMsVUFBSW5CLEdBQUcsR0FBRyxDQUFDbUIsTUFBTSxDQUFDbm9FLE1BQWxCO0FBQUEsVUFDQ3VtQixDQUFDLEdBQUcsQ0FETDtBQUFBLFVBRUN4bUIsQ0FBQyxHQUFHeXVCLEtBQUssQ0FBQ3h1QixNQUZYOztBQUlBLGFBQVF1bUIsQ0FBQyxHQUFHeWdELEdBQVosRUFBaUJ6Z0QsQ0FBQyxFQUFsQixFQUF1QjtBQUN0QmlJLFFBQUFBLEtBQUssQ0FBRXp1QixDQUFDLEVBQUgsQ0FBTCxHQUFlb29FLE1BQU0sQ0FBRTVoRCxDQUFGLENBQXJCO0FBQ0E7O0FBRURpSSxNQUFBQSxLQUFLLENBQUN4dUIsTUFBTixHQUFlRCxDQUFmO0FBRUEsYUFBT3l1QixLQUFQO0FBQ0EsS0EzR2E7QUE2R2RxNEMsSUFBQUEsSUFBSSxFQUFFLGNBQVVQLEtBQVYsRUFBaUJsakUsUUFBakIsRUFBMkJnbEUsTUFBM0IsRUFBb0M7QUFDekMsVUFBSUMsZUFBSjtBQUFBLFVBQ0NqdkMsT0FBTyxHQUFHLEVBRFg7QUFBQSxVQUVDcjVCLENBQUMsR0FBRyxDQUZMO0FBQUEsVUFHQ0MsTUFBTSxHQUFHc21FLEtBQUssQ0FBQ3RtRSxNQUhoQjtBQUFBLFVBSUNzb0UsY0FBYyxHQUFHLENBQUNGLE1BSm5CLENBRHlDLENBT3pDO0FBQ0E7O0FBQ0EsYUFBUXJvRSxDQUFDLEdBQUdDLE1BQVosRUFBb0JELENBQUMsRUFBckIsRUFBMEI7QUFDekJzb0UsUUFBQUEsZUFBZSxHQUFHLENBQUNqbEUsUUFBUSxDQUFFa2pFLEtBQUssQ0FBRXZtRSxDQUFGLENBQVAsRUFBY0EsQ0FBZCxDQUEzQjs7QUFDQSxZQUFLc29FLGVBQWUsS0FBS0MsY0FBekIsRUFBMEM7QUFDekNsdkMsVUFBQUEsT0FBTyxDQUFDNTRCLElBQVIsQ0FBYzhsRSxLQUFLLENBQUV2bUUsQ0FBRixDQUFuQjtBQUNBO0FBQ0Q7O0FBRUQsYUFBT3E1QixPQUFQO0FBQ0EsS0E5SGE7QUFnSWQ7QUFDQTlhLElBQUFBLEdBQUcsRUFBRSxhQUFVZ29ELEtBQVYsRUFBaUJsakUsUUFBakIsRUFBMkJtbEUsR0FBM0IsRUFBaUM7QUFDckMsVUFBSXZvRSxNQUFKO0FBQUEsVUFBWTdDLEtBQVo7QUFBQSxVQUNDNEMsQ0FBQyxHQUFHLENBREw7QUFBQSxVQUVDd21FLEdBQUcsR0FBRyxFQUZQLENBRHFDLENBS3JDOztBQUNBLFVBQUt3QixXQUFXLENBQUV6QixLQUFGLENBQWhCLEVBQTRCO0FBQzNCdG1FLFFBQUFBLE1BQU0sR0FBR3NtRSxLQUFLLENBQUN0bUUsTUFBZjs7QUFDQSxlQUFRRCxDQUFDLEdBQUdDLE1BQVosRUFBb0JELENBQUMsRUFBckIsRUFBMEI7QUFDekI1QyxVQUFBQSxLQUFLLEdBQUdpRyxRQUFRLENBQUVrakUsS0FBSyxDQUFFdm1FLENBQUYsQ0FBUCxFQUFjQSxDQUFkLEVBQWlCd29FLEdBQWpCLENBQWhCOztBQUVBLGNBQUtwckUsS0FBSyxJQUFJLElBQWQsRUFBcUI7QUFDcEJvcEUsWUFBQUEsR0FBRyxDQUFDL2xFLElBQUosQ0FBVXJELEtBQVY7QUFDQTtBQUNELFNBUjBCLENBVTVCOztBQUNDLE9BWEQsTUFXTztBQUNOLGFBQU00QyxDQUFOLElBQVd1bUUsS0FBWCxFQUFtQjtBQUNsQm5wRSxVQUFBQSxLQUFLLEdBQUdpRyxRQUFRLENBQUVrakUsS0FBSyxDQUFFdm1FLENBQUYsQ0FBUCxFQUFjQSxDQUFkLEVBQWlCd29FLEdBQWpCLENBQWhCOztBQUVBLGNBQUtwckUsS0FBSyxJQUFJLElBQWQsRUFBcUI7QUFDcEJvcEUsWUFBQUEsR0FBRyxDQUFDL2xFLElBQUosQ0FBVXJELEtBQVY7QUFDQTtBQUNEO0FBQ0QsT0F6Qm9DLENBMkJyQzs7O0FBQ0EsYUFBT3duRSxJQUFJLENBQUU0QixHQUFGLENBQVg7QUFDQSxLQTlKYTtBQWdLZDtBQUNBaUMsSUFBQUEsSUFBSSxFQUFFLENBaktRO0FBbUtkO0FBQ0E7QUFDQXJELElBQUFBLE9BQU8sRUFBRUE7QUFyS0ssR0FBZjs7QUF3S0EsTUFBSyxPQUFPc0QsTUFBUCxLQUFrQixVQUF2QixFQUFvQztBQUNuQ3hDLElBQUFBLE1BQU0sQ0FBQ0MsRUFBUCxDQUFXdUMsTUFBTSxDQUFDQyxRQUFsQixJQUErQmxFLEdBQUcsQ0FBRWlFLE1BQU0sQ0FBQ0MsUUFBVCxDQUFsQztBQUNBLEdBM2NnRixDQTZjakY7OztBQUNBekMsRUFBQUEsTUFBTSxDQUFDdmpCLElBQVAsQ0FBYSx1RUFBdUV2MEMsS0FBdkUsQ0FBOEUsR0FBOUUsQ0FBYixFQUNDLFVBQVV5d0IsRUFBVixFQUFjamMsSUFBZCxFQUFxQjtBQUNwQmtpRCxJQUFBQSxVQUFVLENBQUUsYUFBYWxpRCxJQUFiLEdBQW9CLEdBQXRCLENBQVYsR0FBd0NBLElBQUksQ0FBQ2xlLFdBQUwsRUFBeEM7QUFDQSxHQUhGOztBQUtBLFdBQVNzakUsV0FBVCxDQUFzQnhvRSxHQUF0QixFQUE0QjtBQUUzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQUlTLE1BQU0sR0FBRyxDQUFDLENBQUNULEdBQUYsSUFBUyxZQUFZQSxHQUFyQixJQUE0QkEsR0FBRyxDQUFDUyxNQUE3QztBQUFBLFFBQ0NoQyxJQUFJLEdBQUdnb0UsTUFBTSxDQUFFem1FLEdBQUYsQ0FEZDs7QUFHQSxRQUFLNmxFLFVBQVUsQ0FBRTdsRSxHQUFGLENBQVYsSUFBcUIrbEUsUUFBUSxDQUFFL2xFLEdBQUYsQ0FBbEMsRUFBNEM7QUFDM0MsYUFBTyxLQUFQO0FBQ0E7O0FBRUQsV0FBT3ZCLElBQUksS0FBSyxPQUFULElBQW9CZ0MsTUFBTSxLQUFLLENBQS9CLElBQ04sT0FBT0EsTUFBUCxLQUFrQixRQUFsQixJQUE4QkEsTUFBTSxHQUFHLENBQXZDLElBQThDQSxNQUFNLEdBQUcsQ0FBWCxJQUFrQlQsR0FEL0Q7QUFFQTs7QUFDRCxNQUFJb3BFLE1BQU07QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNFLFlBQVU1ckUsTUFBVixFQUFtQjtBQUNyQixRQUFJZ0QsQ0FBSjtBQUFBLFFBQ0NvbEUsT0FERDtBQUFBLFFBRUN5RCxJQUZEO0FBQUEsUUFHQ0MsT0FIRDtBQUFBLFFBSUNDLEtBSkQ7QUFBQSxRQUtDQyxRQUxEO0FBQUEsUUFNQ0MsT0FORDtBQUFBLFFBT0NDLE1BUEQ7QUFBQSxRQVFDQyxnQkFSRDtBQUFBLFFBU0NDLFNBVEQ7QUFBQSxRQVVDQyxZQVZEO0FBQUEsUUFZQztBQUNBQyxJQUFBQSxXQWJEO0FBQUEsUUFjQy8rRCxRQWREO0FBQUEsUUFlQ2cvRCxPQWZEO0FBQUEsUUFnQkNDLGNBaEJEO0FBQUEsUUFpQkNDLFNBakJEO0FBQUEsUUFrQkNDLGFBbEJEO0FBQUEsUUFtQkNyd0MsT0FuQkQ7QUFBQSxRQW9CQ3N3QyxRQXBCRDtBQUFBLFFBc0JDO0FBQ0FuQyxJQUFBQSxPQUFPLEdBQUcsV0FBVyxJQUFJLElBQUkzb0UsSUFBSixFQXZCMUI7QUFBQSxRQXdCQytxRSxZQUFZLEdBQUc1c0UsTUFBTSxDQUFDdU4sUUF4QnZCO0FBQUEsUUF5QkNzL0QsT0FBTyxHQUFHLENBekJYO0FBQUEsUUEwQkNDLElBQUksR0FBRyxDQTFCUjtBQUFBLFFBMkJDQyxVQUFVLEdBQUdDLFdBQVcsRUEzQnpCO0FBQUEsUUE0QkNDLFVBQVUsR0FBR0QsV0FBVyxFQTVCekI7QUFBQSxRQTZCQ0UsYUFBYSxHQUFHRixXQUFXLEVBN0I1QjtBQUFBLFFBOEJDRyxzQkFBc0IsR0FBR0gsV0FBVyxFQTlCckM7QUFBQSxRQStCQ0ksU0FBUyxHQUFHLG1CQUFVdGhFLENBQVYsRUFBYTJSLENBQWIsRUFBaUI7QUFDNUIsVUFBSzNSLENBQUMsS0FBSzJSLENBQVgsRUFBZTtBQUNkNHVELFFBQUFBLFlBQVksR0FBRyxJQUFmO0FBQ0E7O0FBQ0QsYUFBTyxDQUFQO0FBQ0EsS0FwQ0Y7QUFBQSxRQXNDQztBQUNBckUsSUFBQUEsTUFBTSxHQUFLLEVBQUYsQ0FBT0MsY0F2Q2pCO0FBQUEsUUF3Q0NSLEdBQUcsR0FBRyxFQXhDUDtBQUFBLFFBeUNDbjRDLEdBQUcsR0FBR200QyxHQUFHLENBQUNuNEMsR0F6Q1g7QUFBQSxRQTBDQys5QyxVQUFVLEdBQUc1RixHQUFHLENBQUNoa0UsSUExQ2xCO0FBQUEsUUEyQ0NBLElBQUksR0FBR2drRSxHQUFHLENBQUNoa0UsSUEzQ1o7QUFBQSxRQTRDQ29nQixLQUFLLEdBQUc0akQsR0FBRyxDQUFDNWpELEtBNUNiO0FBQUEsUUE4Q0M7QUFDQTtBQUNBcFQsSUFBQUEsT0FBTyxHQUFHLFNBQVZBLE9BQVUsQ0FBVXJMLElBQVYsRUFBZ0J1a0UsSUFBaEIsRUFBdUI7QUFDaEMsVUFBSTNtRSxDQUFDLEdBQUcsQ0FBUjtBQUFBLFVBQ0NpbkUsR0FBRyxHQUFHN2tFLElBQUksQ0FBQ25DLE1BRFo7O0FBRUEsYUFBUUQsQ0FBQyxHQUFHaW5FLEdBQVosRUFBaUJqbkUsQ0FBQyxFQUFsQixFQUF1QjtBQUN0QixZQUFLb0MsSUFBSSxDQUFFcEMsQ0FBRixDQUFKLEtBQWMybUUsSUFBbkIsRUFBMEI7QUFDekIsaUJBQU8zbUUsQ0FBUDtBQUNBO0FBQ0Q7O0FBQ0QsYUFBTyxDQUFDLENBQVI7QUFDQSxLQXpERjtBQUFBLFFBMkRDc3FFLFFBQVEsR0FBRyw4RUFDVixtREE1REY7QUFBQSxRQThEQztBQUVBO0FBQ0FDLElBQUFBLFVBQVUsR0FBRyxxQkFqRWQ7QUFBQSxRQW1FQztBQUNBam9FLElBQUFBLFVBQVUsR0FBRyw0QkFBNEJpb0UsVUFBNUIsR0FDWix5Q0FyRUY7QUFBQSxRQXVFQztBQUNBNW5ELElBQUFBLFVBQVUsR0FBRyxRQUFRNG5ELFVBQVIsR0FBcUIsSUFBckIsR0FBNEJqb0UsVUFBNUIsR0FBeUMsTUFBekMsR0FBa0Rpb0UsVUFBbEQsR0FFWjtBQUNBLG1CQUhZLEdBR01BLFVBSE4sR0FLWjtBQUNBO0FBQ0EsOERBUFksR0FPaURqb0UsVUFQakQsR0FPOEQsTUFQOUQsR0FRWmlvRSxVQVJZLEdBUUMsTUFoRmY7QUFBQSxRQWtGQ0MsT0FBTyxHQUFHLE9BQU9sb0UsVUFBUCxHQUFvQixVQUFwQixHQUVUO0FBQ0E7QUFDQSwyREFKUyxHQU1UO0FBQ0EsOEJBUFMsR0FPb0JxZ0IsVUFQcEIsR0FPaUMsTUFQakMsR0FTVDtBQUNBLFFBVlMsR0FXVCxRQTdGRjtBQUFBLFFBK0ZDO0FBQ0E4bkQsSUFBQUEsV0FBVyxHQUFHLElBQUl4aEIsTUFBSixDQUFZc2hCLFVBQVUsR0FBRyxHQUF6QixFQUE4QixHQUE5QixDQWhHZjtBQUFBLFFBaUdDRyxLQUFLLEdBQUcsSUFBSXpoQixNQUFKLENBQVksTUFBTXNoQixVQUFOLEdBQW1CLDZCQUFuQixHQUNuQkEsVUFEbUIsR0FDTixJQUROLEVBQ1ksR0FEWixDQWpHVDtBQUFBLFFBb0dDSSxNQUFNLEdBQUcsSUFBSTFoQixNQUFKLENBQVksTUFBTXNoQixVQUFOLEdBQW1CLElBQW5CLEdBQTBCQSxVQUExQixHQUF1QyxHQUFuRCxDQXBHVjtBQUFBLFFBcUdDSyxZQUFZLEdBQUcsSUFBSTNoQixNQUFKLENBQVksTUFBTXNoQixVQUFOLEdBQW1CLFVBQW5CLEdBQWdDQSxVQUFoQyxHQUE2QyxHQUE3QyxHQUFtREEsVUFBbkQsR0FDMUIsR0FEYyxDQXJHaEI7QUFBQSxRQXVHQ00sUUFBUSxHQUFHLElBQUk1aEIsTUFBSixDQUFZc2hCLFVBQVUsR0FBRyxJQUF6QixDQXZHWjtBQUFBLFFBeUdDTyxPQUFPLEdBQUcsSUFBSTdoQixNQUFKLENBQVl1aEIsT0FBWixDQXpHWDtBQUFBLFFBMEdDTyxXQUFXLEdBQUcsSUFBSTloQixNQUFKLENBQVksTUFBTTNtRCxVQUFOLEdBQW1CLEdBQS9CLENBMUdmO0FBQUEsUUE0R0Mwb0UsU0FBUyxHQUFHO0FBQ1gsWUFBTSxJQUFJL2hCLE1BQUosQ0FBWSxRQUFRM21ELFVBQVIsR0FBcUIsR0FBakMsQ0FESztBQUVYLGVBQVMsSUFBSTJtRCxNQUFKLENBQVksVUFBVTNtRCxVQUFWLEdBQXVCLEdBQW5DLENBRkU7QUFHWCxhQUFPLElBQUkybUQsTUFBSixDQUFZLE9BQU8zbUQsVUFBUCxHQUFvQixPQUFoQyxDQUhJO0FBSVgsY0FBUSxJQUFJMm1ELE1BQUosQ0FBWSxNQUFNdG1DLFVBQWxCLENBSkc7QUFLWCxnQkFBVSxJQUFJc21DLE1BQUosQ0FBWSxNQUFNdWhCLE9BQWxCLENBTEM7QUFNWCxlQUFTLElBQUl2aEIsTUFBSixDQUFZLDJEQUNwQnNoQixVQURvQixHQUNQLDhCQURPLEdBQzBCQSxVQUQxQixHQUN1QyxhQUR2QyxHQUVwQkEsVUFGb0IsR0FFUCxZQUZPLEdBRVFBLFVBRlIsR0FFcUIsUUFGakMsRUFFMkMsR0FGM0MsQ0FORTtBQVNYLGNBQVEsSUFBSXRoQixNQUFKLENBQVksU0FBU3FoQixRQUFULEdBQW9CLElBQWhDLEVBQXNDLEdBQXRDLENBVEc7QUFXWDtBQUNBO0FBQ0Esc0JBQWdCLElBQUlyaEIsTUFBSixDQUFZLE1BQU1zaEIsVUFBTixHQUMzQixrREFEMkIsR0FDMEJBLFVBRDFCLEdBRTNCLGtCQUYyQixHQUVOQSxVQUZNLEdBRU8sa0JBRm5CLEVBRXVDLEdBRnZDO0FBYkwsS0E1R2I7QUFBQSxRQThIQ1UsS0FBSyxHQUFHLFFBOUhUO0FBQUEsUUErSENDLE9BQU8sR0FBRyxxQ0EvSFg7QUFBQSxRQWdJQ0MsT0FBTyxHQUFHLFFBaElYO0FBQUEsUUFrSUNDLE9BQU8sR0FBRyx3QkFsSVg7QUFBQSxRQW9JQztBQUNBQyxJQUFBQSxVQUFVLEdBQUcsa0NBcklkO0FBQUEsUUF1SUNDLFFBQVEsR0FBRyxNQXZJWjtBQUFBLFFBeUlDO0FBQ0E7QUFDQUMsSUFBQUEsU0FBUyxHQUFHLElBQUl0aUIsTUFBSixDQUFZLHlCQUF5QnNoQixVQUF6QixHQUFzQyxzQkFBbEQsRUFBMEUsR0FBMUUsQ0EzSWI7QUFBQSxRQTRJQ2lCLFNBQVMsR0FBRyxTQUFaQSxTQUFZLENBQVVDLE1BQVYsRUFBa0JDLE1BQWxCLEVBQTJCO0FBQ3RDLFVBQUlDLElBQUksR0FBRyxPQUFPRixNQUFNLENBQUM1cUQsS0FBUCxDQUFjLENBQWQsQ0FBUCxHQUEyQixPQUF0QztBQUVBLGFBQU82cUQsTUFBTSxHQUVaO0FBQ0FBLE1BQUFBLE1BSFksR0FLWjtBQUNBO0FBQ0E7QUFDQTtBQUNBQyxNQUFBQSxJQUFJLEdBQUcsQ0FBUCxHQUNDQyxNQUFNLENBQUNDLFlBQVAsQ0FBcUJGLElBQUksR0FBRyxPQUE1QixDQURELEdBRUNDLE1BQU0sQ0FBQ0MsWUFBUCxDQUFxQkYsSUFBSSxJQUFJLEVBQVIsR0FBYSxNQUFsQyxFQUEwQ0EsSUFBSSxHQUFHLEtBQVAsR0FBZSxNQUF6RCxDQVhGO0FBWUEsS0EzSkY7QUFBQSxRQTZKQztBQUNBO0FBQ0FHLElBQUFBLFVBQVUsR0FBRyxxREEvSmQ7QUFBQSxRQWdLQ0MsVUFBVSxHQUFHLFNBQWJBLFVBQWEsQ0FBVUMsRUFBVixFQUFjQyxXQUFkLEVBQTRCO0FBQ3hDLFVBQUtBLFdBQUwsRUFBbUI7QUFFbEI7QUFDQSxZQUFLRCxFQUFFLEtBQUssSUFBWixFQUFtQjtBQUNsQixpQkFBTyxRQUFQO0FBQ0EsU0FMaUIsQ0FPbEI7OztBQUNBLGVBQU9BLEVBQUUsQ0FBQ25yRCxLQUFILENBQVUsQ0FBVixFQUFhLENBQUMsQ0FBZCxJQUFvQixJQUFwQixHQUNObXJELEVBQUUsQ0FBQ0UsVUFBSCxDQUFlRixFQUFFLENBQUMvckUsTUFBSCxHQUFZLENBQTNCLEVBQStCOGtFLFFBQS9CLENBQXlDLEVBQXpDLENBRE0sR0FDMEMsR0FEakQ7QUFFQSxPQVh1QyxDQWF4Qzs7O0FBQ0EsYUFBTyxPQUFPaUgsRUFBZDtBQUNBLEtBL0tGO0FBQUEsUUFpTEM7QUFDQTtBQUNBO0FBQ0E7QUFDQUcsSUFBQUEsYUFBYSxHQUFHLFNBQWhCQSxhQUFnQixHQUFXO0FBQzFCN0MsTUFBQUEsV0FBVztBQUNYLEtBdkxGO0FBQUEsUUF5TEM4QyxrQkFBa0IsR0FBR0MsYUFBYSxDQUNqQyxVQUFVMUYsSUFBVixFQUFpQjtBQUNoQixhQUFPQSxJQUFJLENBQUMyRixRQUFMLEtBQWtCLElBQWxCLElBQTBCM0YsSUFBSSxDQUFDcDlELFFBQUwsQ0FBYzdFLFdBQWQsT0FBZ0MsVUFBakU7QUFDQSxLQUhnQyxFQUlqQztBQUFFNm5FLE1BQUFBLEdBQUcsRUFBRSxZQUFQO0FBQXFCbDhCLE1BQUFBLElBQUksRUFBRTtBQUEzQixLQUppQyxDQXpMbkMsQ0FEcUIsQ0FpTXJCOzs7QUFDQSxRQUFJO0FBQ0g1dkMsTUFBQUEsSUFBSSxDQUFDNkYsS0FBTCxDQUNHbStELEdBQUcsR0FBRzVqRCxLQUFLLENBQUM1WCxJQUFOLENBQVkyZ0UsWUFBWSxDQUFDNEMsVUFBekIsQ0FEVCxFQUVDNUMsWUFBWSxDQUFDNEMsVUFGZCxFQURHLENBTUg7QUFDQTtBQUNBOztBQUNBL0gsTUFBQUEsR0FBRyxDQUFFbUYsWUFBWSxDQUFDNEMsVUFBYixDQUF3QnZzRSxNQUExQixDQUFILENBQXNDd0QsUUFBdEM7QUFDQSxLQVZELENBVUUsT0FBUXRGLENBQVIsRUFBWTtBQUNic0MsTUFBQUEsSUFBSSxHQUFHO0FBQUU2RixRQUFBQSxLQUFLLEVBQUVtK0QsR0FBRyxDQUFDeGtFLE1BQUosR0FFZjtBQUNBLGtCQUFVd0MsTUFBVixFQUFrQmdxRSxHQUFsQixFQUF3QjtBQUN2QnBDLFVBQUFBLFVBQVUsQ0FBQy9qRSxLQUFYLENBQWtCN0QsTUFBbEIsRUFBMEJvZSxLQUFLLENBQUM1WCxJQUFOLENBQVl3akUsR0FBWixDQUExQjtBQUNBLFNBTGMsR0FPZjtBQUNBO0FBQ0Esa0JBQVVocUUsTUFBVixFQUFrQmdxRSxHQUFsQixFQUF3QjtBQUN2QixjQUFJam1ELENBQUMsR0FBRy9qQixNQUFNLENBQUN4QyxNQUFmO0FBQUEsY0FDQ0QsQ0FBQyxHQUFHLENBREwsQ0FEdUIsQ0FJdkI7O0FBQ0EsaUJBQVV5QyxNQUFNLENBQUUrakIsQ0FBQyxFQUFILENBQU4sR0FBZ0JpbUQsR0FBRyxDQUFFenNFLENBQUMsRUFBSCxDQUE3QixFQUF5QyxDQUFFOztBQUMzQ3lDLFVBQUFBLE1BQU0sQ0FBQ3hDLE1BQVAsR0FBZ0J1bUIsQ0FBQyxHQUFHLENBQXBCO0FBQ0E7QUFoQkssT0FBUDtBQWtCQTs7QUFFRCxhQUFTb2lELE1BQVQsQ0FBaUJybUIsUUFBakIsRUFBMkI1N0MsT0FBM0IsRUFBb0N1aEUsT0FBcEMsRUFBNkN3RSxJQUE3QyxFQUFvRDtBQUNuRCxVQUFJanZELENBQUo7QUFBQSxVQUFPemQsQ0FBUDtBQUFBLFVBQVUybUUsSUFBVjtBQUFBLFVBQWdCZ0csR0FBaEI7QUFBQSxVQUFxQjVuRCxLQUFyQjtBQUFBLFVBQTRCNm5ELE1BQTVCO0FBQUEsVUFBb0NDLFdBQXBDO0FBQUEsVUFDQ0MsVUFBVSxHQUFHbm1FLE9BQU8sSUFBSUEsT0FBTyxDQUFDaEIsYUFEakM7QUFBQSxVQUdDO0FBQ0FsQyxNQUFBQSxRQUFRLEdBQUdrRCxPQUFPLEdBQUdBLE9BQU8sQ0FBQ2xELFFBQVgsR0FBc0IsQ0FKekM7QUFNQXlrRSxNQUFBQSxPQUFPLEdBQUdBLE9BQU8sSUFBSSxFQUFyQixDQVBtRCxDQVNuRDs7QUFDQSxVQUFLLE9BQU8zbEIsUUFBUCxLQUFvQixRQUFwQixJQUFnQyxDQUFDQSxRQUFqQyxJQUNKOStDLFFBQVEsS0FBSyxDQUFiLElBQWtCQSxRQUFRLEtBQUssQ0FBL0IsSUFBb0NBLFFBQVEsS0FBSyxFQURsRCxFQUN1RDtBQUV0RCxlQUFPeWtFLE9BQVA7QUFDQSxPQWRrRCxDQWdCbkQ7OztBQUNBLFVBQUssQ0FBQ3dFLElBQU4sRUFBYTtBQUNacEQsUUFBQUEsV0FBVyxDQUFFM2lFLE9BQUYsQ0FBWDtBQUNBQSxRQUFBQSxPQUFPLEdBQUdBLE9BQU8sSUFBSTRELFFBQXJCOztBQUVBLFlBQUtpL0QsY0FBTCxFQUFzQjtBQUVyQjtBQUNBO0FBQ0EsY0FBSy9sRSxRQUFRLEtBQUssRUFBYixLQUFxQnNoQixLQUFLLEdBQUdzbUQsVUFBVSxDQUFDenBCLElBQVgsQ0FBaUJXLFFBQWpCLENBQTdCLENBQUwsRUFBa0U7QUFFakU7QUFDQSxnQkFBTzlrQyxDQUFDLEdBQUdzSCxLQUFLLENBQUUsQ0FBRixDQUFoQixFQUEwQjtBQUV6QjtBQUNBLGtCQUFLdGhCLFFBQVEsS0FBSyxDQUFsQixFQUFzQjtBQUNyQixvQkFBT2tqRSxJQUFJLEdBQUdoZ0UsT0FBTyxDQUFDb21FLGNBQVIsQ0FBd0J0dkQsQ0FBeEIsQ0FBZCxFQUE4QztBQUU3QztBQUNBO0FBQ0E7QUFDQSxzQkFBS2twRCxJQUFJLENBQUMvb0QsRUFBTCxLQUFZSCxDQUFqQixFQUFxQjtBQUNwQnlxRCxvQkFBQUEsT0FBTyxDQUFDem5FLElBQVIsQ0FBY2ttRSxJQUFkO0FBQ0EsMkJBQU91QixPQUFQO0FBQ0E7QUFDRCxpQkFURCxNQVNPO0FBQ04seUJBQU9BLE9BQVA7QUFDQSxpQkFab0IsQ0FjdEI7O0FBQ0MsZUFmRCxNQWVPO0FBRU47QUFDQTtBQUNBO0FBQ0Esb0JBQUs0RSxVQUFVLEtBQU1uRyxJQUFJLEdBQUdtRyxVQUFVLENBQUNDLGNBQVgsQ0FBMkJ0dkQsQ0FBM0IsQ0FBYixDQUFWLElBQ0prc0QsUUFBUSxDQUFFaGpFLE9BQUYsRUFBV2dnRSxJQUFYLENBREosSUFFSkEsSUFBSSxDQUFDL29ELEVBQUwsS0FBWUgsQ0FGYixFQUVpQjtBQUVoQnlxRCxrQkFBQUEsT0FBTyxDQUFDem5FLElBQVIsQ0FBY2ttRSxJQUFkO0FBQ0EseUJBQU91QixPQUFQO0FBQ0E7QUFDRCxlQTlCd0IsQ0FnQzFCOztBQUNDLGFBakNELE1BaUNPLElBQUtuakQsS0FBSyxDQUFFLENBQUYsQ0FBVixFQUFrQjtBQUN4QnRrQixjQUFBQSxJQUFJLENBQUM2RixLQUFMLENBQVk0aEUsT0FBWixFQUFxQnZoRSxPQUFPLENBQUNxbUUsb0JBQVIsQ0FBOEJ6cUIsUUFBOUIsQ0FBckI7QUFDQSxxQkFBTzJsQixPQUFQLENBRndCLENBSXpCO0FBQ0MsYUFMTSxNQUtBLElBQUssQ0FBRXpxRCxDQUFDLEdBQUdzSCxLQUFLLENBQUUsQ0FBRixDQUFYLEtBQXNCcWdELE9BQU8sQ0FBQzZILHNCQUE5QixJQUNYdG1FLE9BQU8sQ0FBQ3NtRSxzQkFERixFQUMyQjtBQUVqQ3hzRSxjQUFBQSxJQUFJLENBQUM2RixLQUFMLENBQVk0aEUsT0FBWixFQUFxQnZoRSxPQUFPLENBQUNzbUUsc0JBQVIsQ0FBZ0N4dkQsQ0FBaEMsQ0FBckI7QUFDQSxxQkFBT3lxRCxPQUFQO0FBQ0E7QUFDRCxXQW5Eb0IsQ0FxRHJCOzs7QUFDQSxjQUFLOUMsT0FBTyxDQUFDOEgsR0FBUixJQUNKLENBQUMvQyxzQkFBc0IsQ0FBRTVuQixRQUFRLEdBQUcsR0FBYixDQURuQixLQUVGLENBQUNrbkIsU0FBRCxJQUFjLENBQUNBLFNBQVMsQ0FBQ25nRSxJQUFWLENBQWdCaTVDLFFBQWhCLENBRmIsT0FJSjtBQUNBO0FBQ0U5K0MsVUFBQUEsUUFBUSxLQUFLLENBQWIsSUFBa0JrRCxPQUFPLENBQUM0QyxRQUFSLENBQWlCN0UsV0FBakIsT0FBbUMsUUFObkQsQ0FBTCxFQU1xRTtBQUVwRW1vRSxZQUFBQSxXQUFXLEdBQUd0cUIsUUFBZDtBQUNBdXFCLFlBQUFBLFVBQVUsR0FBR25tRSxPQUFiLENBSG9FLENBS3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBLGdCQUFLbEQsUUFBUSxLQUFLLENBQWIsS0FDRm9uRSxRQUFRLENBQUN2aEUsSUFBVCxDQUFlaTVDLFFBQWYsS0FBNkJxb0IsWUFBWSxDQUFDdGhFLElBQWIsQ0FBbUJpNUMsUUFBbkIsQ0FEM0IsQ0FBTCxFQUNrRTtBQUVqRTtBQUNBdXFCLGNBQUFBLFVBQVUsR0FBR3hCLFFBQVEsQ0FBQ2hpRSxJQUFULENBQWVpNUMsUUFBZixLQUE2QjRxQixXQUFXLENBQUV4bUUsT0FBTyxDQUFDcEQsVUFBVixDQUF4QyxJQUNab0QsT0FERCxDQUhpRSxDQU1qRTtBQUNBOztBQUNBLGtCQUFLbW1FLFVBQVUsS0FBS25tRSxPQUFmLElBQTBCLENBQUN5K0QsT0FBTyxDQUFDenJCLEtBQXhDLEVBQWdEO0FBRS9DO0FBQ0Esb0JBQU9nekIsR0FBRyxHQUFHaG1FLE9BQU8sQ0FBQ3lDLFlBQVIsQ0FBc0IsSUFBdEIsQ0FBYixFQUE4QztBQUM3Q3VqRSxrQkFBQUEsR0FBRyxHQUFHQSxHQUFHLENBQUN0dUUsT0FBSixDQUFheXRFLFVBQWIsRUFBeUJDLFVBQXpCLENBQU47QUFDQSxpQkFGRCxNQUVPO0FBQ05wbEUsa0JBQUFBLE9BQU8sQ0FBQ3FlLFlBQVIsQ0FBc0IsSUFBdEIsRUFBOEIybkQsR0FBRyxHQUFHbkYsT0FBcEM7QUFDQTtBQUNELGVBaEJnRSxDQWtCakU7OztBQUNBb0YsY0FBQUEsTUFBTSxHQUFHNUQsUUFBUSxDQUFFem1CLFFBQUYsQ0FBakI7QUFDQXZpRCxjQUFBQSxDQUFDLEdBQUc0c0UsTUFBTSxDQUFDM3NFLE1BQVg7O0FBQ0EscUJBQVFELENBQUMsRUFBVCxFQUFjO0FBQ2I0c0UsZ0JBQUFBLE1BQU0sQ0FBRTVzRSxDQUFGLENBQU4sR0FBYyxDQUFFMnNFLEdBQUcsR0FBRyxNQUFNQSxHQUFULEdBQWUsUUFBcEIsSUFBaUMsR0FBakMsR0FDYlMsVUFBVSxDQUFFUixNQUFNLENBQUU1c0UsQ0FBRixDQUFSLENBRFg7QUFFQTs7QUFDRDZzRSxjQUFBQSxXQUFXLEdBQUdELE1BQU0sQ0FBQ2xvRCxJQUFQLENBQWEsR0FBYixDQUFkO0FBQ0E7O0FBRUQsZ0JBQUk7QUFDSGprQixjQUFBQSxJQUFJLENBQUM2RixLQUFMLENBQVk0aEUsT0FBWixFQUNDNEUsVUFBVSxDQUFDeHFCLGdCQUFYLENBQTZCdXFCLFdBQTdCLENBREQ7QUFHQSxxQkFBTzNFLE9BQVA7QUFDQSxhQUxELENBS0UsT0FBUW1GLFFBQVIsRUFBbUI7QUFDcEJsRCxjQUFBQSxzQkFBc0IsQ0FBRTVuQixRQUFGLEVBQVksSUFBWixDQUF0QjtBQUNBLGFBUEQsU0FPVTtBQUNULGtCQUFLb3FCLEdBQUcsS0FBS25GLE9BQWIsRUFBdUI7QUFDdEI3Z0UsZ0JBQUFBLE9BQU8sQ0FBQzAxRCxlQUFSLENBQXlCLElBQXpCO0FBQ0E7QUFDRDtBQUNEO0FBQ0Q7QUFDRCxPQXhJa0QsQ0EwSW5EOzs7QUFDQSxhQUFPNk0sTUFBTSxDQUFFM21CLFFBQVEsQ0FBQ2xrRCxPQUFULENBQWtCcXNFLEtBQWxCLEVBQXlCLElBQXpCLENBQUYsRUFBbUMvakUsT0FBbkMsRUFBNEN1aEUsT0FBNUMsRUFBcUR3RSxJQUFyRCxDQUFiO0FBQ0E7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBLGFBQVMxQyxXQUFULEdBQXVCO0FBQ3RCLFVBQUlzRCxJQUFJLEdBQUcsRUFBWDs7QUFFQSxlQUFTMzZDLEtBQVQsQ0FBZ0JxQyxHQUFoQixFQUFxQjUzQixLQUFyQixFQUE2QjtBQUU1QjtBQUNBLFlBQUtrd0UsSUFBSSxDQUFDN3NFLElBQUwsQ0FBV3UwQixHQUFHLEdBQUcsR0FBakIsSUFBeUI2ekMsSUFBSSxDQUFDMEUsV0FBbkMsRUFBaUQ7QUFFaEQ7QUFDQSxpQkFBTzU2QyxLQUFLLENBQUUyNkMsSUFBSSxDQUFDM3NELEtBQUwsRUFBRixDQUFaO0FBQ0E7O0FBQ0QsZUFBU2dTLEtBQUssQ0FBRXFDLEdBQUcsR0FBRyxHQUFSLENBQUwsR0FBcUI1M0IsS0FBOUI7QUFDQTs7QUFDRCxhQUFPdTFCLEtBQVA7QUFDQTtBQUVEO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQSxhQUFTNjZDLFlBQVQsQ0FBdUJySCxFQUF2QixFQUE0QjtBQUMzQkEsTUFBQUEsRUFBRSxDQUFFcUIsT0FBRixDQUFGLEdBQWdCLElBQWhCO0FBQ0EsYUFBT3JCLEVBQVA7QUFDQTtBQUVEO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQSxhQUFTc0gsTUFBVCxDQUFpQnRILEVBQWpCLEVBQXNCO0FBQ3JCLFVBQUkxdkMsRUFBRSxHQUFHbHNCLFFBQVEsQ0FBQ2pNLGFBQVQsQ0FBd0IsVUFBeEIsQ0FBVDs7QUFFQSxVQUFJO0FBQ0gsZUFBTyxDQUFDLENBQUM2bkUsRUFBRSxDQUFFMXZDLEVBQUYsQ0FBWDtBQUNBLE9BRkQsQ0FFRSxPQUFRdDRCLENBQVIsRUFBWTtBQUNiLGVBQU8sS0FBUDtBQUNBLE9BSkQsU0FJVTtBQUVUO0FBQ0EsWUFBS3M0QixFQUFFLENBQUNsekIsVUFBUixFQUFxQjtBQUNwQmt6QixVQUFBQSxFQUFFLENBQUNsekIsVUFBSCxDQUFjZ0osV0FBZCxDQUEyQmtxQixFQUEzQjtBQUNBLFNBTFEsQ0FPVDs7O0FBQ0FBLFFBQUFBLEVBQUUsR0FBRyxJQUFMO0FBQ0E7QUFDRDtBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBLGFBQVNpM0MsU0FBVCxDQUFvQnRxRCxLQUFwQixFQUEyQnVxRCxPQUEzQixFQUFxQztBQUNwQyxVQUFJbEosR0FBRyxHQUFHcmhELEtBQUssQ0FBQ2hWLEtBQU4sQ0FBYSxHQUFiLENBQVY7QUFBQSxVQUNDcE8sQ0FBQyxHQUFHeWtFLEdBQUcsQ0FBQ3hrRSxNQURUOztBQUdBLGFBQVFELENBQUMsRUFBVCxFQUFjO0FBQ2I2b0UsUUFBQUEsSUFBSSxDQUFDK0UsVUFBTCxDQUFpQm5KLEdBQUcsQ0FBRXprRSxDQUFGLENBQXBCLElBQThCMnRFLE9BQTlCO0FBQ0E7QUFDRDtBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0EsYUFBU0UsWUFBVCxDQUF1Qi9rRSxDQUF2QixFQUEwQjJSLENBQTFCLEVBQThCO0FBQzdCLFVBQUlxekQsR0FBRyxHQUFHcnpELENBQUMsSUFBSTNSLENBQWY7QUFBQSxVQUNDaWxFLElBQUksR0FBR0QsR0FBRyxJQUFJaGxFLENBQUMsQ0FBQ3JGLFFBQUYsS0FBZSxDQUF0QixJQUEyQmdYLENBQUMsQ0FBQ2hYLFFBQUYsS0FBZSxDQUExQyxJQUNOcUYsQ0FBQyxDQUFDa2xFLFdBQUYsR0FBZ0J2ekQsQ0FBQyxDQUFDdXpELFdBRnBCLENBRDZCLENBSzdCOztBQUNBLFVBQUtELElBQUwsRUFBWTtBQUNYLGVBQU9BLElBQVA7QUFDQSxPQVI0QixDQVU3Qjs7O0FBQ0EsVUFBS0QsR0FBTCxFQUFXO0FBQ1YsZUFBVUEsR0FBRyxHQUFHQSxHQUFHLENBQUN6aEUsV0FBcEIsRUFBb0M7QUFDbkMsY0FBS3loRSxHQUFHLEtBQUtyekQsQ0FBYixFQUFpQjtBQUNoQixtQkFBTyxDQUFDLENBQVI7QUFDQTtBQUNEO0FBQ0Q7O0FBRUQsYUFBTzNSLENBQUMsR0FBRyxDQUFILEdBQU8sQ0FBQyxDQUFoQjtBQUNBO0FBRUQ7QUFDQTtBQUNBO0FBQ0E7OztBQUNBLGFBQVNtbEUsaUJBQVQsQ0FBNEJod0UsSUFBNUIsRUFBbUM7QUFDbEMsYUFBTyxVQUFVMG9FLElBQVYsRUFBaUI7QUFDdkIsWUFBSS9qRCxJQUFJLEdBQUcrakQsSUFBSSxDQUFDcDlELFFBQUwsQ0FBYzdFLFdBQWQsRUFBWDtBQUNBLGVBQU9rZSxJQUFJLEtBQUssT0FBVCxJQUFvQitqRCxJQUFJLENBQUMxb0UsSUFBTCxLQUFjQSxJQUF6QztBQUNBLE9BSEQ7QUFJQTtBQUVEO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQSxhQUFTaXdFLGtCQUFULENBQTZCandFLElBQTdCLEVBQW9DO0FBQ25DLGFBQU8sVUFBVTBvRSxJQUFWLEVBQWlCO0FBQ3ZCLFlBQUkvakQsSUFBSSxHQUFHK2pELElBQUksQ0FBQ3A5RCxRQUFMLENBQWM3RSxXQUFkLEVBQVg7QUFDQSxlQUFPLENBQUVrZSxJQUFJLEtBQUssT0FBVCxJQUFvQkEsSUFBSSxLQUFLLFFBQS9CLEtBQTZDK2pELElBQUksQ0FBQzFvRSxJQUFMLEtBQWNBLElBQWxFO0FBQ0EsT0FIRDtBQUlBO0FBRUQ7QUFDQTtBQUNBO0FBQ0E7OztBQUNBLGFBQVNrd0Usb0JBQVQsQ0FBK0I3QixRQUEvQixFQUEwQztBQUV6QztBQUNBLGFBQU8sVUFBVTNGLElBQVYsRUFBaUI7QUFFdkI7QUFDQTtBQUNBO0FBQ0EsWUFBSyxVQUFVQSxJQUFmLEVBQXNCO0FBRXJCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBS0EsSUFBSSxDQUFDcGpFLFVBQUwsSUFBbUJvakUsSUFBSSxDQUFDMkYsUUFBTCxLQUFrQixLQUExQyxFQUFrRDtBQUVqRDtBQUNBLGdCQUFLLFdBQVczRixJQUFoQixFQUF1QjtBQUN0QixrQkFBSyxXQUFXQSxJQUFJLENBQUNwakUsVUFBckIsRUFBa0M7QUFDakMsdUJBQU9vakUsSUFBSSxDQUFDcGpFLFVBQUwsQ0FBZ0Irb0UsUUFBaEIsS0FBNkJBLFFBQXBDO0FBQ0EsZUFGRCxNQUVPO0FBQ04sdUJBQU8zRixJQUFJLENBQUMyRixRQUFMLEtBQWtCQSxRQUF6QjtBQUNBO0FBQ0QsYUFUZ0QsQ0FXakQ7QUFDQTs7O0FBQ0EsbUJBQU8zRixJQUFJLENBQUN5SCxVQUFMLEtBQW9COUIsUUFBcEIsSUFFTjs7QUFDQTtBQUNBM0YsWUFBQUEsSUFBSSxDQUFDeUgsVUFBTCxLQUFvQixDQUFDOUIsUUFBckIsSUFDQUYsa0JBQWtCLENBQUV6RixJQUFGLENBQWxCLEtBQStCMkYsUUFMaEM7QUFNQTs7QUFFRCxpQkFBTzNGLElBQUksQ0FBQzJGLFFBQUwsS0FBa0JBLFFBQXpCLENBOUJxQixDQWdDdEI7QUFDQTtBQUNBO0FBQ0MsU0FuQ0QsTUFtQ08sSUFBSyxXQUFXM0YsSUFBaEIsRUFBdUI7QUFDN0IsaUJBQU9BLElBQUksQ0FBQzJGLFFBQUwsS0FBa0JBLFFBQXpCO0FBQ0EsU0ExQ3NCLENBNEN2Qjs7O0FBQ0EsZUFBTyxLQUFQO0FBQ0EsT0E5Q0Q7QUErQ0E7QUFFRDtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0EsYUFBUytCLHNCQUFULENBQWlDbEksRUFBakMsRUFBc0M7QUFDckMsYUFBT3FILFlBQVksQ0FBRSxVQUFVYyxRQUFWLEVBQXFCO0FBQ3pDQSxRQUFBQSxRQUFRLEdBQUcsQ0FBQ0EsUUFBWjtBQUNBLGVBQU9kLFlBQVksQ0FBRSxVQUFVZCxJQUFWLEVBQWdCcnpDLE9BQWhCLEVBQTBCO0FBQzlDLGNBQUk3UyxDQUFKO0FBQUEsY0FDQytuRCxZQUFZLEdBQUdwSSxFQUFFLENBQUUsRUFBRixFQUFNdUcsSUFBSSxDQUFDenNFLE1BQVgsRUFBbUJxdUUsUUFBbkIsQ0FEbEI7QUFBQSxjQUVDdHVFLENBQUMsR0FBR3V1RSxZQUFZLENBQUN0dUUsTUFGbEIsQ0FEOEMsQ0FLOUM7O0FBQ0EsaUJBQVFELENBQUMsRUFBVCxFQUFjO0FBQ2IsZ0JBQUswc0UsSUFBSSxDQUFJbG1ELENBQUMsR0FBRytuRCxZQUFZLENBQUV2dUUsQ0FBRixDQUFwQixDQUFULEVBQXlDO0FBQ3hDMHNFLGNBQUFBLElBQUksQ0FBRWxtRCxDQUFGLENBQUosR0FBWSxFQUFHNlMsT0FBTyxDQUFFN1MsQ0FBRixDQUFQLEdBQWVrbUQsSUFBSSxDQUFFbG1ELENBQUYsQ0FBdEIsQ0FBWjtBQUNBO0FBQ0Q7QUFDRCxTQVhrQixDQUFuQjtBQVlBLE9BZGtCLENBQW5CO0FBZUE7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQSxhQUFTMm1ELFdBQVQsQ0FBc0J4bUUsT0FBdEIsRUFBZ0M7QUFDL0IsYUFBT0EsT0FBTyxJQUFJLE9BQU9BLE9BQU8sQ0FBQ3FtRSxvQkFBZixLQUF3QyxXQUFuRCxJQUFrRXJtRSxPQUF6RTtBQUNBLEtBMWpCb0IsQ0E0akJyQjs7O0FBQ0F5K0QsSUFBQUEsT0FBTyxHQUFHd0QsTUFBTSxDQUFDeEQsT0FBUCxHQUFpQixFQUEzQjtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0EyRCxJQUFBQSxLQUFLLEdBQUdILE1BQU0sQ0FBQ0csS0FBUCxHQUFlLFVBQVVwQyxJQUFWLEVBQWlCO0FBQ3ZDLFVBQUk2SCxTQUFTLEdBQUc3SCxJQUFJLElBQUlBLElBQUksQ0FBQzhILFlBQTdCO0FBQUEsVUFDQ2xGLE9BQU8sR0FBRzVDLElBQUksSUFBSSxDQUFFQSxJQUFJLENBQUNoaEUsYUFBTCxJQUFzQmdoRSxJQUF4QixFQUErQjVqRSxlQURsRCxDQUR1QyxDQUl2QztBQUNBO0FBQ0E7O0FBQ0EsYUFBTyxDQUFDa29FLEtBQUssQ0FBQzNoRSxJQUFOLENBQVlrbEUsU0FBUyxJQUFJakYsT0FBTyxJQUFJQSxPQUFPLENBQUNoZ0UsUUFBaEMsSUFBNEMsTUFBeEQsQ0FBUjtBQUNBLEtBUkQ7QUFVQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQSsvRCxJQUFBQSxXQUFXLEdBQUdWLE1BQU0sQ0FBQ1UsV0FBUCxHQUFxQixVQUFVOStELElBQVYsRUFBaUI7QUFDbkQsVUFBSWtrRSxVQUFKO0FBQUEsVUFBZ0JDLFNBQWhCO0FBQUEsVUFDQy9yRSxHQUFHLEdBQUc0SCxJQUFJLEdBQUdBLElBQUksQ0FBQzdFLGFBQUwsSUFBc0I2RSxJQUF6QixHQUFnQ28vRCxZQUQzQyxDQURtRCxDQUluRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBLFVBQUtobkUsR0FBRyxJQUFJMkgsUUFBUCxJQUFtQjNILEdBQUcsQ0FBQ2EsUUFBSixLQUFpQixDQUFwQyxJQUF5QyxDQUFDYixHQUFHLENBQUNHLGVBQW5ELEVBQXFFO0FBQ3BFLGVBQU93SCxRQUFQO0FBQ0EsT0FYa0QsQ0FhbkQ7OztBQUNBQSxNQUFBQSxRQUFRLEdBQUczSCxHQUFYO0FBQ0EybUUsTUFBQUEsT0FBTyxHQUFHaC9ELFFBQVEsQ0FBQ3hILGVBQW5CO0FBQ0F5bUUsTUFBQUEsY0FBYyxHQUFHLENBQUNULEtBQUssQ0FBRXgrRCxRQUFGLENBQXZCLENBaEJtRCxDQWtCbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBLFVBQUtxL0QsWUFBWSxJQUFJci9ELFFBQWhCLEtBQ0Zva0UsU0FBUyxHQUFHcGtFLFFBQVEsQ0FBQ3FrRSxXQURuQixLQUNvQ0QsU0FBUyxDQUFDenBFLEdBQVYsS0FBa0J5cEUsU0FEM0QsRUFDdUU7QUFFdEU7QUFDQSxZQUFLQSxTQUFTLENBQUNqdEUsZ0JBQWYsRUFBa0M7QUFDakNpdEUsVUFBQUEsU0FBUyxDQUFDanRFLGdCQUFWLENBQTRCLFFBQTVCLEVBQXNDeXFFLGFBQXRDLEVBQXFELEtBQXJELEVBRGlDLENBR2xDO0FBQ0MsU0FKRCxNQUlPLElBQUt3QyxTQUFTLENBQUNFLFdBQWYsRUFBNkI7QUFDbkNGLFVBQUFBLFNBQVMsQ0FBQ0UsV0FBVixDQUF1QixVQUF2QixFQUFtQzFDLGFBQW5DO0FBQ0E7QUFDRCxPQW5Da0QsQ0FxQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBL0csTUFBQUEsT0FBTyxDQUFDenJCLEtBQVIsR0FBZ0I4ekIsTUFBTSxDQUFFLFVBQVVoM0MsRUFBVixFQUFlO0FBQ3RDOHlDLFFBQUFBLE9BQU8sQ0FBQ2o5RCxXQUFSLENBQXFCbXFCLEVBQXJCLEVBQTBCbnFCLFdBQTFCLENBQXVDL0IsUUFBUSxDQUFDak0sYUFBVCxDQUF3QixLQUF4QixDQUF2QztBQUNBLGVBQU8sT0FBT200QixFQUFFLENBQUM2ckIsZ0JBQVYsS0FBK0IsV0FBL0IsSUFDTixDQUFDN3JCLEVBQUUsQ0FBQzZyQixnQkFBSCxDQUFxQixxQkFBckIsRUFBNkNyaUQsTUFEL0M7QUFFQSxPQUpxQixDQUF0QjtBQU1BO0FBQ0Q7QUFFQztBQUNBO0FBQ0E7O0FBQ0FtbEUsTUFBQUEsT0FBTyxDQUFDemlELFVBQVIsR0FBcUI4cUQsTUFBTSxDQUFFLFVBQVVoM0MsRUFBVixFQUFlO0FBQzNDQSxRQUFBQSxFQUFFLENBQUNtWixTQUFILEdBQWUsR0FBZjtBQUNBLGVBQU8sQ0FBQ25aLEVBQUUsQ0FBQ3J0QixZQUFILENBQWlCLFdBQWpCLENBQVI7QUFDQSxPQUgwQixDQUEzQjtBQUtBO0FBQ0Q7QUFFQzs7QUFDQWc4RCxNQUFBQSxPQUFPLENBQUM0SCxvQkFBUixHQUErQlMsTUFBTSxDQUFFLFVBQVVoM0MsRUFBVixFQUFlO0FBQ3JEQSxRQUFBQSxFQUFFLENBQUNucUIsV0FBSCxDQUFnQi9CLFFBQVEsQ0FBQ3VrRSxhQUFULENBQXdCLEVBQXhCLENBQWhCO0FBQ0EsZUFBTyxDQUFDcjRDLEVBQUUsQ0FBQ3UyQyxvQkFBSCxDQUF5QixHQUF6QixFQUErQi9zRSxNQUF2QztBQUNBLE9BSG9DLENBQXJDLENBL0RtRCxDQW9FbkQ7O0FBQ0FtbEUsTUFBQUEsT0FBTyxDQUFDNkgsc0JBQVIsR0FBaUM3QixPQUFPLENBQUM5aEUsSUFBUixDQUFjaUIsUUFBUSxDQUFDMGlFLHNCQUF2QixDQUFqQyxDQXJFbUQsQ0F1RW5EO0FBQ0E7QUFDQTtBQUNBOztBQUNBN0gsTUFBQUEsT0FBTyxDQUFDN21DLE9BQVIsR0FBa0JrdkMsTUFBTSxDQUFFLFVBQVVoM0MsRUFBVixFQUFlO0FBQ3hDOHlDLFFBQUFBLE9BQU8sQ0FBQ2o5RCxXQUFSLENBQXFCbXFCLEVBQXJCLEVBQTBCN1ksRUFBMUIsR0FBK0I0cEQsT0FBL0I7QUFDQSxlQUFPLENBQUNqOUQsUUFBUSxDQUFDd2tFLGlCQUFWLElBQStCLENBQUN4a0UsUUFBUSxDQUFDd2tFLGlCQUFULENBQTRCdkgsT0FBNUIsRUFBc0N2bkUsTUFBN0U7QUFDQSxPQUh1QixDQUF4QixDQTNFbUQsQ0FnRm5EOztBQUNBLFVBQUttbEUsT0FBTyxDQUFDN21DLE9BQWIsRUFBdUI7QUFDdEJzcUMsUUFBQUEsSUFBSSxDQUFDenFDLE1BQUwsQ0FBYSxJQUFiLElBQXNCLFVBQVV4Z0IsRUFBVixFQUFlO0FBQ3BDLGNBQUlveEQsTUFBTSxHQUFHcHhELEVBQUUsQ0FBQ3ZmLE9BQUgsQ0FBWWt0RSxTQUFaLEVBQXVCQyxTQUF2QixDQUFiO0FBQ0EsaUJBQU8sVUFBVTdFLElBQVYsRUFBaUI7QUFDdkIsbUJBQU9BLElBQUksQ0FBQ3Y5RCxZQUFMLENBQW1CLElBQW5CLE1BQThCNGxFLE1BQXJDO0FBQ0EsV0FGRDtBQUdBLFNBTEQ7O0FBTUFuRyxRQUFBQSxJQUFJLENBQUNvRyxJQUFMLENBQVcsSUFBWCxJQUFvQixVQUFVcnhELEVBQVYsRUFBY2pYLE9BQWQsRUFBd0I7QUFDM0MsY0FBSyxPQUFPQSxPQUFPLENBQUNvbUUsY0FBZixLQUFrQyxXQUFsQyxJQUFpRHZELGNBQXRELEVBQXVFO0FBQ3RFLGdCQUFJN0MsSUFBSSxHQUFHaGdFLE9BQU8sQ0FBQ29tRSxjQUFSLENBQXdCbnZELEVBQXhCLENBQVg7QUFDQSxtQkFBTytvRCxJQUFJLEdBQUcsQ0FBRUEsSUFBRixDQUFILEdBQWMsRUFBekI7QUFDQTtBQUNELFNBTEQ7QUFNQSxPQWJELE1BYU87QUFDTmtDLFFBQUFBLElBQUksQ0FBQ3pxQyxNQUFMLENBQWEsSUFBYixJQUF1QixVQUFVeGdCLEVBQVYsRUFBZTtBQUNyQyxjQUFJb3hELE1BQU0sR0FBR3B4RCxFQUFFLENBQUN2ZixPQUFILENBQVlrdEUsU0FBWixFQUF1QkMsU0FBdkIsQ0FBYjtBQUNBLGlCQUFPLFVBQVU3RSxJQUFWLEVBQWlCO0FBQ3ZCLGdCQUFJbjhELElBQUksR0FBRyxPQUFPbThELElBQUksQ0FBQ3VJLGdCQUFaLEtBQWlDLFdBQWpDLElBQ1Z2SSxJQUFJLENBQUN1SSxnQkFBTCxDQUF1QixJQUF2QixDQUREO0FBRUEsbUJBQU8xa0UsSUFBSSxJQUFJQSxJQUFJLENBQUNwTixLQUFMLEtBQWU0eEUsTUFBOUI7QUFDQSxXQUpEO0FBS0EsU0FQRCxDQURNLENBVU47QUFDQTs7O0FBQ0FuRyxRQUFBQSxJQUFJLENBQUNvRyxJQUFMLENBQVcsSUFBWCxJQUFvQixVQUFVcnhELEVBQVYsRUFBY2pYLE9BQWQsRUFBd0I7QUFDM0MsY0FBSyxPQUFPQSxPQUFPLENBQUNvbUUsY0FBZixLQUFrQyxXQUFsQyxJQUFpRHZELGNBQXRELEVBQXVFO0FBQ3RFLGdCQUFJaC9ELElBQUo7QUFBQSxnQkFBVXhLLENBQVY7QUFBQSxnQkFBYXVtRSxLQUFiO0FBQUEsZ0JBQ0NJLElBQUksR0FBR2hnRSxPQUFPLENBQUNvbUUsY0FBUixDQUF3Qm52RCxFQUF4QixDQURSOztBQUdBLGdCQUFLK29ELElBQUwsRUFBWTtBQUVYO0FBQ0FuOEQsY0FBQUEsSUFBSSxHQUFHbThELElBQUksQ0FBQ3VJLGdCQUFMLENBQXVCLElBQXZCLENBQVA7O0FBQ0Esa0JBQUsxa0UsSUFBSSxJQUFJQSxJQUFJLENBQUNwTixLQUFMLEtBQWV3Z0IsRUFBNUIsRUFBaUM7QUFDaEMsdUJBQU8sQ0FBRStvRCxJQUFGLENBQVA7QUFDQSxlQU5VLENBUVg7OztBQUNBSixjQUFBQSxLQUFLLEdBQUc1L0QsT0FBTyxDQUFDb29FLGlCQUFSLENBQTJCbnhELEVBQTNCLENBQVI7QUFDQTVkLGNBQUFBLENBQUMsR0FBRyxDQUFKOztBQUNBLHFCQUFVMm1FLElBQUksR0FBR0osS0FBSyxDQUFFdm1FLENBQUMsRUFBSCxDQUF0QixFQUFrQztBQUNqQ3dLLGdCQUFBQSxJQUFJLEdBQUdtOEQsSUFBSSxDQUFDdUksZ0JBQUwsQ0FBdUIsSUFBdkIsQ0FBUDs7QUFDQSxvQkFBSzFrRSxJQUFJLElBQUlBLElBQUksQ0FBQ3BOLEtBQUwsS0FBZXdnQixFQUE1QixFQUFpQztBQUNoQyx5QkFBTyxDQUFFK29ELElBQUYsQ0FBUDtBQUNBO0FBQ0Q7QUFDRDs7QUFFRCxtQkFBTyxFQUFQO0FBQ0E7QUFDRCxTQTFCRDtBQTJCQSxPQXJJa0QsQ0F1SW5EOzs7QUFDQWtDLE1BQUFBLElBQUksQ0FBQ29HLElBQUwsQ0FBVyxLQUFYLElBQXFCN0osT0FBTyxDQUFDNEgsb0JBQVIsR0FDcEIsVUFBVW1DLEdBQVYsRUFBZXhvRSxPQUFmLEVBQXlCO0FBQ3hCLFlBQUssT0FBT0EsT0FBTyxDQUFDcW1FLG9CQUFmLEtBQXdDLFdBQTdDLEVBQTJEO0FBQzFELGlCQUFPcm1FLE9BQU8sQ0FBQ3FtRSxvQkFBUixDQUE4Qm1DLEdBQTlCLENBQVAsQ0FEMEQsQ0FHM0Q7QUFDQyxTQUpELE1BSU8sSUFBSy9KLE9BQU8sQ0FBQzhILEdBQWIsRUFBbUI7QUFDekIsaUJBQU92bUUsT0FBTyxDQUFDMjdDLGdCQUFSLENBQTBCNnNCLEdBQTFCLENBQVA7QUFDQTtBQUNELE9BVG1CLEdBV3BCLFVBQVVBLEdBQVYsRUFBZXhvRSxPQUFmLEVBQXlCO0FBQ3hCLFlBQUlnZ0UsSUFBSjtBQUFBLFlBQ0N5SSxHQUFHLEdBQUcsRUFEUDtBQUFBLFlBRUNwdkUsQ0FBQyxHQUFHLENBRkw7QUFBQSxZQUlDO0FBQ0Frb0UsUUFBQUEsT0FBTyxHQUFHdmhFLE9BQU8sQ0FBQ3FtRSxvQkFBUixDQUE4Qm1DLEdBQTlCLENBTFgsQ0FEd0IsQ0FReEI7O0FBQ0EsWUFBS0EsR0FBRyxLQUFLLEdBQWIsRUFBbUI7QUFDbEIsaUJBQVV4SSxJQUFJLEdBQUd1QixPQUFPLENBQUVsb0UsQ0FBQyxFQUFILENBQXhCLEVBQW9DO0FBQ25DLGdCQUFLMm1FLElBQUksQ0FBQ2xqRSxRQUFMLEtBQWtCLENBQXZCLEVBQTJCO0FBQzFCMnJFLGNBQUFBLEdBQUcsQ0FBQzN1RSxJQUFKLENBQVVrbUUsSUFBVjtBQUNBO0FBQ0Q7O0FBRUQsaUJBQU95SSxHQUFQO0FBQ0E7O0FBQ0QsZUFBT2xILE9BQVA7QUFDQSxPQTlCRixDQXhJbUQsQ0F3S25EOztBQUNBVyxNQUFBQSxJQUFJLENBQUNvRyxJQUFMLENBQVcsT0FBWCxJQUF1QjdKLE9BQU8sQ0FBQzZILHNCQUFSLElBQWtDLFVBQVVyOUIsU0FBVixFQUFxQmpwQyxPQUFyQixFQUErQjtBQUN2RixZQUFLLE9BQU9BLE9BQU8sQ0FBQ3NtRSxzQkFBZixLQUEwQyxXQUExQyxJQUF5RHpELGNBQTlELEVBQStFO0FBQzlFLGlCQUFPN2lFLE9BQU8sQ0FBQ3NtRSxzQkFBUixDQUFnQ3I5QixTQUFoQyxDQUFQO0FBQ0E7QUFDRCxPQUpEO0FBTUE7QUFDRDtBQUVDO0FBRUE7OztBQUNBODVCLE1BQUFBLGFBQWEsR0FBRyxFQUFoQixDQXJMbUQsQ0F1TG5EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0FELE1BQUFBLFNBQVMsR0FBRyxFQUFaOztBQUVBLFVBQU9yRSxPQUFPLENBQUM4SCxHQUFSLEdBQWM5QixPQUFPLENBQUM5aEUsSUFBUixDQUFjaUIsUUFBUSxDQUFDKzNDLGdCQUF2QixDQUFyQixFQUFtRTtBQUVsRTtBQUNBO0FBQ0FtckIsUUFBQUEsTUFBTSxDQUFFLFVBQVVoM0MsRUFBVixFQUFlO0FBRXRCLGNBQUk0NEMsS0FBSixDQUZzQixDQUl0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBOUYsVUFBQUEsT0FBTyxDQUFDajlELFdBQVIsQ0FBcUJtcUIsRUFBckIsRUFBMEJ4b0IsU0FBMUIsR0FBc0MsWUFBWXU1RCxPQUFaLEdBQXNCLFFBQXRCLEdBQ3JDLGNBRHFDLEdBQ3BCQSxPQURvQixHQUNWLDJCQURVLEdBRXJDLHdDQUZELENBVHNCLENBYXRCO0FBQ0E7QUFDQTtBQUNBOztBQUNBLGNBQUsvd0MsRUFBRSxDQUFDNnJCLGdCQUFILENBQXFCLHNCQUFyQixFQUE4Q3JpRCxNQUFuRCxFQUE0RDtBQUMzRHdwRSxZQUFBQSxTQUFTLENBQUNocEUsSUFBVixDQUFnQixXQUFXOHBFLFVBQVgsR0FBd0IsY0FBeEM7QUFDQSxXQW5CcUIsQ0FxQnRCO0FBQ0E7OztBQUNBLGNBQUssQ0FBQzl6QyxFQUFFLENBQUM2ckIsZ0JBQUgsQ0FBcUIsWUFBckIsRUFBb0NyaUQsTUFBMUMsRUFBbUQ7QUFDbER3cEUsWUFBQUEsU0FBUyxDQUFDaHBFLElBQVYsQ0FBZ0IsUUFBUThwRSxVQUFSLEdBQXFCLFlBQXJCLEdBQW9DRCxRQUFwQyxHQUErQyxHQUEvRDtBQUNBLFdBekJxQixDQTJCdEI7OztBQUNBLGNBQUssQ0FBQzd6QyxFQUFFLENBQUM2ckIsZ0JBQUgsQ0FBcUIsVUFBVWtsQixPQUFWLEdBQW9CLElBQXpDLEVBQWdEdm5FLE1BQXRELEVBQStEO0FBQzlEd3BFLFlBQUFBLFNBQVMsQ0FBQ2hwRSxJQUFWLENBQWdCLElBQWhCO0FBQ0EsV0E5QnFCLENBZ0N0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQTR1RSxVQUFBQSxLQUFLLEdBQUc5a0UsUUFBUSxDQUFDak0sYUFBVCxDQUF3QixPQUF4QixDQUFSO0FBQ0Erd0UsVUFBQUEsS0FBSyxDQUFDcnFELFlBQU4sQ0FBb0IsTUFBcEIsRUFBNEIsRUFBNUI7QUFDQXlSLFVBQUFBLEVBQUUsQ0FBQ25xQixXQUFILENBQWdCK2lFLEtBQWhCOztBQUNBLGNBQUssQ0FBQzU0QyxFQUFFLENBQUM2ckIsZ0JBQUgsQ0FBcUIsV0FBckIsRUFBbUNyaUQsTUFBekMsRUFBa0Q7QUFDakR3cEUsWUFBQUEsU0FBUyxDQUFDaHBFLElBQVYsQ0FBZ0IsUUFBUThwRSxVQUFSLEdBQXFCLE9BQXJCLEdBQStCQSxVQUEvQixHQUE0QyxJQUE1QyxHQUNmQSxVQURlLEdBQ0YsY0FEZDtBQUVBLFdBM0NxQixDQTZDdEI7QUFDQTtBQUNBOzs7QUFDQSxjQUFLLENBQUM5ekMsRUFBRSxDQUFDNnJCLGdCQUFILENBQXFCLFVBQXJCLEVBQWtDcmlELE1BQXhDLEVBQWlEO0FBQ2hEd3BFLFlBQUFBLFNBQVMsQ0FBQ2hwRSxJQUFWLENBQWdCLFVBQWhCO0FBQ0EsV0FsRHFCLENBb0R0QjtBQUNBO0FBQ0E7OztBQUNBLGNBQUssQ0FBQ2cyQixFQUFFLENBQUM2ckIsZ0JBQUgsQ0FBcUIsT0FBT2tsQixPQUFQLEdBQWlCLElBQXRDLEVBQTZDdm5FLE1BQW5ELEVBQTREO0FBQzNEd3BFLFlBQUFBLFNBQVMsQ0FBQ2hwRSxJQUFWLENBQWdCLFVBQWhCO0FBQ0EsV0F6RHFCLENBMkR0QjtBQUNBOzs7QUFDQWcyQixVQUFBQSxFQUFFLENBQUM2ckIsZ0JBQUgsQ0FBcUIsTUFBckI7QUFDQW1uQixVQUFBQSxTQUFTLENBQUNocEUsSUFBVixDQUFnQixhQUFoQjtBQUNBLFNBL0RLLENBQU47QUFpRUFndEUsUUFBQUEsTUFBTSxDQUFFLFVBQVVoM0MsRUFBVixFQUFlO0FBQ3RCQSxVQUFBQSxFQUFFLENBQUN4b0IsU0FBSCxHQUFlLHdDQUNkLGdEQURELENBRHNCLENBSXRCO0FBQ0E7O0FBQ0EsY0FBSW9oRSxLQUFLLEdBQUc5a0UsUUFBUSxDQUFDak0sYUFBVCxDQUF3QixPQUF4QixDQUFaO0FBQ0Erd0UsVUFBQUEsS0FBSyxDQUFDcnFELFlBQU4sQ0FBb0IsTUFBcEIsRUFBNEIsUUFBNUI7QUFDQXlSLFVBQUFBLEVBQUUsQ0FBQ25xQixXQUFILENBQWdCK2lFLEtBQWhCLEVBQXdCcnFELFlBQXhCLENBQXNDLE1BQXRDLEVBQThDLEdBQTlDLEVBUnNCLENBVXRCO0FBQ0E7O0FBQ0EsY0FBS3lSLEVBQUUsQ0FBQzZyQixnQkFBSCxDQUFxQixVQUFyQixFQUFrQ3JpRCxNQUF2QyxFQUFnRDtBQUMvQ3dwRSxZQUFBQSxTQUFTLENBQUNocEUsSUFBVixDQUFnQixTQUFTOHBFLFVBQVQsR0FBc0IsYUFBdEM7QUFDQSxXQWRxQixDQWdCdEI7QUFDQTs7O0FBQ0EsY0FBSzl6QyxFQUFFLENBQUM2ckIsZ0JBQUgsQ0FBcUIsVUFBckIsRUFBa0NyaUQsTUFBbEMsS0FBNkMsQ0FBbEQsRUFBc0Q7QUFDckR3cEUsWUFBQUEsU0FBUyxDQUFDaHBFLElBQVYsQ0FBZ0IsVUFBaEIsRUFBNEIsV0FBNUI7QUFDQSxXQXBCcUIsQ0FzQnRCO0FBQ0E7OztBQUNBOG9FLFVBQUFBLE9BQU8sQ0FBQ2o5RCxXQUFSLENBQXFCbXFCLEVBQXJCLEVBQTBCNjFDLFFBQTFCLEdBQXFDLElBQXJDOztBQUNBLGNBQUs3MUMsRUFBRSxDQUFDNnJCLGdCQUFILENBQXFCLFdBQXJCLEVBQW1DcmlELE1BQW5DLEtBQThDLENBQW5ELEVBQXVEO0FBQ3REd3BFLFlBQUFBLFNBQVMsQ0FBQ2hwRSxJQUFWLENBQWdCLFVBQWhCLEVBQTRCLFdBQTVCO0FBQ0EsV0EzQnFCLENBNkJ0QjtBQUNBOzs7QUFDQWcyQixVQUFBQSxFQUFFLENBQUM2ckIsZ0JBQUgsQ0FBcUIsTUFBckI7QUFDQW1uQixVQUFBQSxTQUFTLENBQUNocEUsSUFBVixDQUFnQixNQUFoQjtBQUNBLFNBakNLLENBQU47QUFrQ0E7O0FBRUQsVUFBTzJrRSxPQUFPLENBQUNrSyxlQUFSLEdBQTBCbEUsT0FBTyxDQUFDOWhFLElBQVIsQ0FBZ0IrdkIsT0FBTyxHQUFHa3dDLE9BQU8sQ0FBQ2x3QyxPQUFSLElBQzFEa3dDLE9BQU8sQ0FBQ2dHLHFCQURrRCxJQUUxRGhHLE9BQU8sQ0FBQ2lHLGtCQUZrRCxJQUcxRGpHLE9BQU8sQ0FBQ2tHLGdCQUhrRCxJQUkxRGxHLE9BQU8sQ0FBQ21HLGlCQUp3QixDQUFqQyxFQUltQztBQUVsQ2pDLFFBQUFBLE1BQU0sQ0FBRSxVQUFVaDNDLEVBQVYsRUFBZTtBQUV0QjtBQUNBO0FBQ0EydUMsVUFBQUEsT0FBTyxDQUFDdUssaUJBQVIsR0FBNEJ0MkMsT0FBTyxDQUFDcHdCLElBQVIsQ0FBY3d0QixFQUFkLEVBQWtCLEdBQWxCLENBQTVCLENBSnNCLENBTXRCO0FBQ0E7O0FBQ0E0QyxVQUFBQSxPQUFPLENBQUNwd0IsSUFBUixDQUFjd3RCLEVBQWQsRUFBa0IsV0FBbEI7QUFDQWl6QyxVQUFBQSxhQUFhLENBQUNqcEUsSUFBZCxDQUFvQixJQUFwQixFQUEwQitwRSxPQUExQjtBQUNBLFNBVkssQ0FBTjtBQVdBOztBQUVEZixNQUFBQSxTQUFTLEdBQUdBLFNBQVMsQ0FBQ3hwRSxNQUFWLElBQW9CLElBQUlncEQsTUFBSixDQUFZd2dCLFNBQVMsQ0FBQy9rRCxJQUFWLENBQWdCLEdBQWhCLENBQVosQ0FBaEM7QUFDQWdsRCxNQUFBQSxhQUFhLEdBQUdBLGFBQWEsQ0FBQ3pwRSxNQUFkLElBQXdCLElBQUlncEQsTUFBSixDQUFZeWdCLGFBQWEsQ0FBQ2hsRCxJQUFkLENBQW9CLEdBQXBCLENBQVosQ0FBeEM7QUFFQTtBQUNEOztBQUNDZ3FELE1BQUFBLFVBQVUsR0FBR3RELE9BQU8sQ0FBQzloRSxJQUFSLENBQWNpZ0UsT0FBTyxDQUFDcUcsdUJBQXRCLENBQWIsQ0EvVG1ELENBaVVuRDtBQUNBO0FBQ0E7O0FBQ0FqRyxNQUFBQSxRQUFRLEdBQUcrRSxVQUFVLElBQUl0RCxPQUFPLENBQUM5aEUsSUFBUixDQUFjaWdFLE9BQU8sQ0FBQ0ksUUFBdEIsQ0FBZCxHQUNWLFVBQVU3Z0UsQ0FBVixFQUFhMlIsQ0FBYixFQUFpQjtBQUNoQixZQUFJbzFELEtBQUssR0FBRy9tRSxDQUFDLENBQUNyRixRQUFGLEtBQWUsQ0FBZixHQUFtQnFGLENBQUMsQ0FBQy9GLGVBQXJCLEdBQXVDK0YsQ0FBbkQ7QUFBQSxZQUNDZ25FLEdBQUcsR0FBR3IxRCxDQUFDLElBQUlBLENBQUMsQ0FBQ2xYLFVBRGQ7QUFFQSxlQUFPdUYsQ0FBQyxLQUFLZ25FLEdBQU4sSUFBYSxDQUFDLEVBQUdBLEdBQUcsSUFBSUEsR0FBRyxDQUFDcnNFLFFBQUosS0FBaUIsQ0FBeEIsS0FDdkJvc0UsS0FBSyxDQUFDbEcsUUFBTixHQUNDa0csS0FBSyxDQUFDbEcsUUFBTixDQUFnQm1HLEdBQWhCLENBREQsR0FFQ2huRSxDQUFDLENBQUM4bUUsdUJBQUYsSUFBNkI5bUUsQ0FBQyxDQUFDOG1FLHVCQUFGLENBQTJCRSxHQUEzQixJQUFtQyxFQUgxQyxDQUFILENBQXJCO0FBS0EsT0FUUyxHQVVWLFVBQVVobkUsQ0FBVixFQUFhMlIsQ0FBYixFQUFpQjtBQUNoQixZQUFLQSxDQUFMLEVBQVM7QUFDUixpQkFBVUEsQ0FBQyxHQUFHQSxDQUFDLENBQUNsWCxVQUFoQixFQUErQjtBQUM5QixnQkFBS2tYLENBQUMsS0FBSzNSLENBQVgsRUFBZTtBQUNkLHFCQUFPLElBQVA7QUFDQTtBQUNEO0FBQ0Q7O0FBQ0QsZUFBTyxLQUFQO0FBQ0EsT0FuQkY7QUFxQkE7QUFDRDtBQUVDOztBQUNBc2hFLE1BQUFBLFNBQVMsR0FBR3NFLFVBQVUsR0FDdEIsVUFBVTVsRSxDQUFWLEVBQWEyUixDQUFiLEVBQWlCO0FBRWhCO0FBQ0EsWUFBSzNSLENBQUMsS0FBSzJSLENBQVgsRUFBZTtBQUNkNHVELFVBQUFBLFlBQVksR0FBRyxJQUFmO0FBQ0EsaUJBQU8sQ0FBUDtBQUNBLFNBTmUsQ0FRaEI7OztBQUNBLFlBQUkwRyxPQUFPLEdBQUcsQ0FBQ2puRSxDQUFDLENBQUM4bUUsdUJBQUgsR0FBNkIsQ0FBQ24xRCxDQUFDLENBQUNtMUQsdUJBQTlDOztBQUNBLFlBQUtHLE9BQUwsRUFBZTtBQUNkLGlCQUFPQSxPQUFQO0FBQ0EsU0FaZSxDQWNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQUEsUUFBQUEsT0FBTyxHQUFHLENBQUVqbkUsQ0FBQyxDQUFDbkQsYUFBRixJQUFtQm1ELENBQXJCLE1BQThCMlIsQ0FBQyxDQUFDOVUsYUFBRixJQUFtQjhVLENBQWpELElBQ1QzUixDQUFDLENBQUM4bUUsdUJBQUYsQ0FBMkJuMUQsQ0FBM0IsQ0FEUyxHQUdUO0FBQ0EsU0FKRCxDQW5CZ0IsQ0F5QmhCOztBQUNBLFlBQUtzMUQsT0FBTyxHQUFHLENBQVYsSUFDRixDQUFDM0ssT0FBTyxDQUFDNEssWUFBVCxJQUF5QnYxRCxDQUFDLENBQUNtMUQsdUJBQUYsQ0FBMkI5bUUsQ0FBM0IsTUFBbUNpbkUsT0FEL0QsRUFDMkU7QUFFMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQUtqbkUsQ0FBQyxJQUFJeUIsUUFBTCxJQUFpQnpCLENBQUMsQ0FBQ25ELGFBQUYsSUFBbUJpa0UsWUFBbkIsSUFDckJELFFBQVEsQ0FBRUMsWUFBRixFQUFnQjlnRSxDQUFoQixDQURULEVBQytCO0FBQzlCLG1CQUFPLENBQUMsQ0FBUjtBQUNBLFdBVnlFLENBWTFFO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQSxjQUFLMlIsQ0FBQyxJQUFJbFEsUUFBTCxJQUFpQmtRLENBQUMsQ0FBQzlVLGFBQUYsSUFBbUJpa0UsWUFBbkIsSUFDckJELFFBQVEsQ0FBRUMsWUFBRixFQUFnQm52RCxDQUFoQixDQURULEVBQytCO0FBQzlCLG1CQUFPLENBQVA7QUFDQSxXQW5CeUUsQ0FxQjFFOzs7QUFDQSxpQkFBTzJ1RCxTQUFTLEdBQ2IzN0QsT0FBTyxDQUFFMjdELFNBQUYsRUFBYXRnRSxDQUFiLENBQVAsR0FBMEIyRSxPQUFPLENBQUUyN0QsU0FBRixFQUFhM3VELENBQWIsQ0FEcEIsR0FFZixDQUZEO0FBR0E7O0FBRUQsZUFBT3MxRCxPQUFPLEdBQUcsQ0FBVixHQUFjLENBQUMsQ0FBZixHQUFtQixDQUExQjtBQUNBLE9BeERxQixHQXlEdEIsVUFBVWpuRSxDQUFWLEVBQWEyUixDQUFiLEVBQWlCO0FBRWhCO0FBQ0EsWUFBSzNSLENBQUMsS0FBSzJSLENBQVgsRUFBZTtBQUNkNHVELFVBQUFBLFlBQVksR0FBRyxJQUFmO0FBQ0EsaUJBQU8sQ0FBUDtBQUNBOztBQUVELFlBQUl5RSxHQUFKO0FBQUEsWUFDQzl0RSxDQUFDLEdBQUcsQ0FETDtBQUFBLFlBRUNpd0UsR0FBRyxHQUFHbm5FLENBQUMsQ0FBQ3ZGLFVBRlQ7QUFBQSxZQUdDdXNFLEdBQUcsR0FBR3IxRCxDQUFDLENBQUNsWCxVQUhUO0FBQUEsWUFJQzJzRSxFQUFFLEdBQUcsQ0FBRXBuRSxDQUFGLENBSk47QUFBQSxZQUtDcW5FLEVBQUUsR0FBRyxDQUFFMTFELENBQUYsQ0FMTixDQVJnQixDQWVoQjs7QUFDQSxZQUFLLENBQUN3MUQsR0FBRCxJQUFRLENBQUNILEdBQWQsRUFBb0I7QUFFbkI7QUFDQTtBQUNBOztBQUNBO0FBQ0EsaUJBQU9obkUsQ0FBQyxJQUFJeUIsUUFBTCxHQUFnQixDQUFDLENBQWpCLEdBQ05rUSxDQUFDLElBQUlsUSxRQUFMLEdBQWdCLENBQWhCO0FBQ0E7QUFDQTBsRSxVQUFBQSxHQUFHLEdBQUcsQ0FBQyxDQUFKLEdBQ0hILEdBQUcsR0FBRyxDQUFILEdBQ0gxRyxTQUFTLEdBQ1AzN0QsT0FBTyxDQUFFMjdELFNBQUYsRUFBYXRnRSxDQUFiLENBQVAsR0FBMEIyRSxPQUFPLENBQUUyN0QsU0FBRixFQUFhM3VELENBQWIsQ0FEMUIsR0FFVCxDQVBELENBTm1CLENBZXBCO0FBQ0MsU0FoQkQsTUFnQk8sSUFBS3cxRCxHQUFHLEtBQUtILEdBQWIsRUFBbUI7QUFDekIsaUJBQU9qQyxZQUFZLENBQUUva0UsQ0FBRixFQUFLMlIsQ0FBTCxDQUFuQjtBQUNBLFNBbENlLENBb0NoQjs7O0FBQ0FxekQsUUFBQUEsR0FBRyxHQUFHaGxFLENBQU47O0FBQ0EsZUFBVWdsRSxHQUFHLEdBQUdBLEdBQUcsQ0FBQ3ZxRSxVQUFwQixFQUFtQztBQUNsQzJzRSxVQUFBQSxFQUFFLENBQUM3aEQsT0FBSCxDQUFZeS9DLEdBQVo7QUFDQTs7QUFDREEsUUFBQUEsR0FBRyxHQUFHcnpELENBQU47O0FBQ0EsZUFBVXF6RCxHQUFHLEdBQUdBLEdBQUcsQ0FBQ3ZxRSxVQUFwQixFQUFtQztBQUNsQzRzRSxVQUFBQSxFQUFFLENBQUM5aEQsT0FBSCxDQUFZeS9DLEdBQVo7QUFDQSxTQTVDZSxDQThDaEI7OztBQUNBLGVBQVFvQyxFQUFFLENBQUVsd0UsQ0FBRixDQUFGLEtBQVltd0UsRUFBRSxDQUFFbndFLENBQUYsQ0FBdEIsRUFBOEI7QUFDN0JBLFVBQUFBLENBQUM7QUFDRDs7QUFFRCxlQUFPQSxDQUFDLEdBRVA7QUFDQTZ0RSxRQUFBQSxZQUFZLENBQUVxQyxFQUFFLENBQUVsd0UsQ0FBRixDQUFKLEVBQVdtd0UsRUFBRSxDQUFFbndFLENBQUYsQ0FBYixDQUhMLEdBS1A7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQWt3RSxRQUFBQSxFQUFFLENBQUVsd0UsQ0FBRixDQUFGLElBQVc0cEUsWUFBWCxHQUEwQixDQUFDLENBQTNCLEdBQ0F1RyxFQUFFLENBQUVud0UsQ0FBRixDQUFGLElBQVc0cEUsWUFBWCxHQUEwQixDQUExQjtBQUNBO0FBQ0EsU0FiRDtBQWNBLE9BMUhEO0FBNEhBLGFBQU9yL0QsUUFBUDtBQUNBLEtBMWREOztBQTRkQXErRCxJQUFBQSxNQUFNLENBQUN2dkMsT0FBUCxHQUFpQixVQUFVKzJDLElBQVYsRUFBZ0Jyd0UsUUFBaEIsRUFBMkI7QUFDM0MsYUFBTzZvRSxNQUFNLENBQUV3SCxJQUFGLEVBQVEsSUFBUixFQUFjLElBQWQsRUFBb0Jyd0UsUUFBcEIsQ0FBYjtBQUNBLEtBRkQ7O0FBSUE2b0UsSUFBQUEsTUFBTSxDQUFDMEcsZUFBUCxHQUF5QixVQUFVM0ksSUFBVixFQUFnQnlKLElBQWhCLEVBQXVCO0FBQy9DOUcsTUFBQUEsV0FBVyxDQUFFM0MsSUFBRixDQUFYOztBQUVBLFVBQUt2QixPQUFPLENBQUNrSyxlQUFSLElBQTJCOUYsY0FBM0IsSUFDSixDQUFDVyxzQkFBc0IsQ0FBRWlHLElBQUksR0FBRyxHQUFULENBRG5CLEtBRUYsQ0FBQzFHLGFBQUQsSUFBa0IsQ0FBQ0EsYUFBYSxDQUFDcGdFLElBQWQsQ0FBb0I4bUUsSUFBcEIsQ0FGakIsTUFHRixDQUFDM0csU0FBRCxJQUFrQixDQUFDQSxTQUFTLENBQUNuZ0UsSUFBVixDQUFnQjhtRSxJQUFoQixDQUhqQixDQUFMLEVBR2lEO0FBRWhELFlBQUk7QUFDSCxjQUFJNUosR0FBRyxHQUFHbnRDLE9BQU8sQ0FBQ3B3QixJQUFSLENBQWMwOUQsSUFBZCxFQUFvQnlKLElBQXBCLENBQVYsQ0FERyxDQUdIOztBQUNBLGNBQUs1SixHQUFHLElBQUlwQixPQUFPLENBQUN1SyxpQkFBZixJQUVKO0FBQ0E7QUFDQWhKLFVBQUFBLElBQUksQ0FBQ3A4RCxRQUFMLElBQWlCbzhELElBQUksQ0FBQ3A4RCxRQUFMLENBQWM5RyxRQUFkLEtBQTJCLEVBSjdDLEVBSWtEO0FBQ2pELG1CQUFPK2lFLEdBQVA7QUFDQTtBQUNELFNBWEQsQ0FXRSxPQUFRcm9FLENBQVIsRUFBWTtBQUNiZ3NFLFVBQUFBLHNCQUFzQixDQUFFaUcsSUFBRixFQUFRLElBQVIsQ0FBdEI7QUFDQTtBQUNEOztBQUVELGFBQU94SCxNQUFNLENBQUV3SCxJQUFGLEVBQVE3bEUsUUFBUixFQUFrQixJQUFsQixFQUF3QixDQUFFbzhELElBQUYsQ0FBeEIsQ0FBTixDQUF5QzFtRSxNQUF6QyxHQUFrRCxDQUF6RDtBQUNBLEtBekJEOztBQTJCQTJvRSxJQUFBQSxNQUFNLENBQUNlLFFBQVAsR0FBa0IsVUFBVWhqRSxPQUFWLEVBQW1CZ2dFLElBQW5CLEVBQTBCO0FBRTNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFLLENBQUVoZ0UsT0FBTyxDQUFDaEIsYUFBUixJQUF5QmdCLE9BQTNCLEtBQXdDNEQsUUFBN0MsRUFBd0Q7QUFDdkQrK0QsUUFBQUEsV0FBVyxDQUFFM2lFLE9BQUYsQ0FBWDtBQUNBOztBQUNELGFBQU9nakUsUUFBUSxDQUFFaGpFLE9BQUYsRUFBV2dnRSxJQUFYLENBQWY7QUFDQSxLQVhEOztBQWFBaUMsSUFBQUEsTUFBTSxDQUFDbG1ELElBQVAsR0FBYyxVQUFVaWtELElBQVYsRUFBZ0IvakQsSUFBaEIsRUFBdUI7QUFFcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQUssQ0FBRStqRCxJQUFJLENBQUNoaEUsYUFBTCxJQUFzQmdoRSxJQUF4QixLQUFrQ3A4RCxRQUF2QyxFQUFrRDtBQUNqRCsrRCxRQUFBQSxXQUFXLENBQUUzQyxJQUFGLENBQVg7QUFDQTs7QUFFRCxVQUFJUixFQUFFLEdBQUcwQyxJQUFJLENBQUMrRSxVQUFMLENBQWlCaHJELElBQUksQ0FBQ2xlLFdBQUwsRUFBakIsQ0FBVDtBQUFBLFVBRUM7QUFDQXNKLE1BQUFBLEdBQUcsR0FBR200RCxFQUFFLElBQUluQixNQUFNLENBQUMvN0QsSUFBUCxDQUFhNC9ELElBQUksQ0FBQytFLFVBQWxCLEVBQThCaHJELElBQUksQ0FBQ2xlLFdBQUwsRUFBOUIsQ0FBTixHQUNMeWhFLEVBQUUsQ0FBRVEsSUFBRixFQUFRL2pELElBQVIsRUFBYyxDQUFDNG1ELGNBQWYsQ0FERyxHQUVMakMsU0FMRjtBQU9BLGFBQU92NUQsR0FBRyxLQUFLdTVELFNBQVIsR0FDTnY1RCxHQURNLEdBRU5vM0QsT0FBTyxDQUFDemlELFVBQVIsSUFBc0IsQ0FBQzZtRCxjQUF2QixHQUNDN0MsSUFBSSxDQUFDdjlELFlBQUwsQ0FBbUJ3WixJQUFuQixDQURELEdBRUMsQ0FBRTVVLEdBQUcsR0FBRzI0RCxJQUFJLENBQUN1SSxnQkFBTCxDQUF1QnRzRCxJQUF2QixDQUFSLEtBQTJDNVUsR0FBRyxDQUFDcWlFLFNBQS9DLEdBQ0NyaUUsR0FBRyxDQUFDNVEsS0FETCxHQUVDLElBTkg7QUFPQSxLQXpCRDs7QUEyQkF3ckUsSUFBQUEsTUFBTSxDQUFDNkMsTUFBUCxHQUFnQixVQUFVNkUsR0FBVixFQUFnQjtBQUMvQixhQUFPLENBQUVBLEdBQUcsR0FBRyxFQUFSLEVBQWFqeUUsT0FBYixDQUFzQnl0RSxVQUF0QixFQUFrQ0MsVUFBbEMsQ0FBUDtBQUNBLEtBRkQ7O0FBSUFuRCxJQUFBQSxNQUFNLENBQUMzTSxLQUFQLEdBQWUsVUFBVXlMLEdBQVYsRUFBZ0I7QUFDOUIsWUFBTSxJQUFJbkQsS0FBSixDQUFXLDRDQUE0Q21ELEdBQXZELENBQU47QUFDQSxLQUZEO0FBSUE7QUFDQTtBQUNBO0FBQ0E7OztBQUNBa0IsSUFBQUEsTUFBTSxDQUFDMkgsVUFBUCxHQUFvQixVQUFVckksT0FBVixFQUFvQjtBQUN2QyxVQUFJdkIsSUFBSjtBQUFBLFVBQ0M2SixVQUFVLEdBQUcsRUFEZDtBQUFBLFVBRUNocUQsQ0FBQyxHQUFHLENBRkw7QUFBQSxVQUdDeG1CLENBQUMsR0FBRyxDQUhMLENBRHVDLENBTXZDOztBQUNBcXBFLE1BQUFBLFlBQVksR0FBRyxDQUFDakUsT0FBTyxDQUFDcUwsZ0JBQXhCO0FBQ0FySCxNQUFBQSxTQUFTLEdBQUcsQ0FBQ2hFLE9BQU8sQ0FBQ3NMLFVBQVQsSUFBdUJ4SSxPQUFPLENBQUNybkQsS0FBUixDQUFlLENBQWYsQ0FBbkM7QUFDQXFuRCxNQUFBQSxPQUFPLENBQUNobEMsSUFBUixDQUFja25DLFNBQWQ7O0FBRUEsVUFBS2YsWUFBTCxFQUFvQjtBQUNuQixlQUFVMUMsSUFBSSxHQUFHdUIsT0FBTyxDQUFFbG9FLENBQUMsRUFBSCxDQUF4QixFQUFvQztBQUNuQyxjQUFLMm1FLElBQUksS0FBS3VCLE9BQU8sQ0FBRWxvRSxDQUFGLENBQXJCLEVBQTZCO0FBQzVCd21CLFlBQUFBLENBQUMsR0FBR2dxRCxVQUFVLENBQUMvdkUsSUFBWCxDQUFpQlQsQ0FBakIsQ0FBSjtBQUNBO0FBQ0Q7O0FBQ0QsZUFBUXdtQixDQUFDLEVBQVQsRUFBYztBQUNiMGhELFVBQUFBLE9BQU8sQ0FBQ25uRSxNQUFSLENBQWdCeXZFLFVBQVUsQ0FBRWhxRCxDQUFGLENBQTFCLEVBQWlDLENBQWpDO0FBQ0E7QUFDRCxPQXBCc0MsQ0FzQnZDO0FBQ0E7OztBQUNBNGlELE1BQUFBLFNBQVMsR0FBRyxJQUFaO0FBRUEsYUFBT2xCLE9BQVA7QUFDQSxLQTNCRDtBQTZCQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0FZLElBQUFBLE9BQU8sR0FBR0YsTUFBTSxDQUFDRSxPQUFQLEdBQWlCLFVBQVVuQyxJQUFWLEVBQWlCO0FBQzNDLFVBQUluOEQsSUFBSjtBQUFBLFVBQ0NnOEQsR0FBRyxHQUFHLEVBRFA7QUFBQSxVQUVDeG1FLENBQUMsR0FBRyxDQUZMO0FBQUEsVUFHQ3lELFFBQVEsR0FBR2tqRSxJQUFJLENBQUNsakUsUUFIakI7O0FBS0EsVUFBSyxDQUFDQSxRQUFOLEVBQWlCO0FBRWhCO0FBQ0EsZUFBVStHLElBQUksR0FBR204RCxJQUFJLENBQUUzbUUsQ0FBQyxFQUFILENBQXJCLEVBQWlDO0FBRWhDO0FBQ0F3bUUsVUFBQUEsR0FBRyxJQUFJc0MsT0FBTyxDQUFFdCtELElBQUYsQ0FBZDtBQUNBO0FBQ0QsT0FSRCxNQVFPLElBQUsvRyxRQUFRLEtBQUssQ0FBYixJQUFrQkEsUUFBUSxLQUFLLENBQS9CLElBQW9DQSxRQUFRLEtBQUssRUFBdEQsRUFBMkQ7QUFFakU7QUFDQTtBQUNBLFlBQUssT0FBT2tqRSxJQUFJLENBQUNnSyxXQUFaLEtBQTRCLFFBQWpDLEVBQTRDO0FBQzNDLGlCQUFPaEssSUFBSSxDQUFDZ0ssV0FBWjtBQUNBLFNBRkQsTUFFTztBQUVOO0FBQ0EsZUFBTWhLLElBQUksR0FBR0EsSUFBSSxDQUFDbDhELFVBQWxCLEVBQThCazhELElBQTlCLEVBQW9DQSxJQUFJLEdBQUdBLElBQUksQ0FBQ3Q2RCxXQUFoRCxFQUE4RDtBQUM3RG02RCxZQUFBQSxHQUFHLElBQUlzQyxPQUFPLENBQUVuQyxJQUFGLENBQWQ7QUFDQTtBQUNEO0FBQ0QsT0FiTSxNQWFBLElBQUtsakUsUUFBUSxLQUFLLENBQWIsSUFBa0JBLFFBQVEsS0FBSyxDQUFwQyxFQUF3QztBQUM5QyxlQUFPa2pFLElBQUksQ0FBQzdqRCxTQUFaO0FBQ0EsT0E3QjBDLENBK0IzQzs7O0FBRUEsYUFBTzBqRCxHQUFQO0FBQ0EsS0FsQ0Q7O0FBb0NBcUMsSUFBQUEsSUFBSSxHQUFHRCxNQUFNLENBQUNnSSxTQUFQLEdBQW1CO0FBRXpCO0FBQ0FyRCxNQUFBQSxXQUFXLEVBQUUsRUFIWTtBQUt6QnNELE1BQUFBLFlBQVksRUFBRXJELFlBTFc7QUFPekJ6b0QsTUFBQUEsS0FBSyxFQUFFaW1ELFNBUGtCO0FBU3pCNEMsTUFBQUEsVUFBVSxFQUFFLEVBVGE7QUFXekJxQixNQUFBQSxJQUFJLEVBQUUsRUFYbUI7QUFhekJqK0MsTUFBQUEsUUFBUSxFQUFFO0FBQ1QsYUFBSztBQUFFdTdDLFVBQUFBLEdBQUcsRUFBRSxZQUFQO0FBQXFCOTlDLFVBQUFBLEtBQUssRUFBRTtBQUE1QixTQURJO0FBRVQsYUFBSztBQUFFODlDLFVBQUFBLEdBQUcsRUFBRTtBQUFQLFNBRkk7QUFHVCxhQUFLO0FBQUVBLFVBQUFBLEdBQUcsRUFBRSxpQkFBUDtBQUEwQjk5QyxVQUFBQSxLQUFLLEVBQUU7QUFBakMsU0FISTtBQUlULGFBQUs7QUFBRTg5QyxVQUFBQSxHQUFHLEVBQUU7QUFBUDtBQUpJLE9BYmU7QUFvQnpCdUUsTUFBQUEsU0FBUyxFQUFFO0FBQ1YsZ0JBQVEsY0FBVS9yRCxLQUFWLEVBQWtCO0FBQ3pCQSxVQUFBQSxLQUFLLENBQUUsQ0FBRixDQUFMLEdBQWFBLEtBQUssQ0FBRSxDQUFGLENBQUwsQ0FBVzFtQixPQUFYLENBQW9Ca3RFLFNBQXBCLEVBQStCQyxTQUEvQixDQUFiLENBRHlCLENBR3pCOztBQUNBem1ELFVBQUFBLEtBQUssQ0FBRSxDQUFGLENBQUwsR0FBYSxDQUFFQSxLQUFLLENBQUUsQ0FBRixDQUFMLElBQWNBLEtBQUssQ0FBRSxDQUFGLENBQW5CLElBQ2RBLEtBQUssQ0FBRSxDQUFGLENBRFMsSUFDQSxFQURGLEVBQ08xbUIsT0FEUCxDQUNnQmt0RSxTQURoQixFQUMyQkMsU0FEM0IsQ0FBYjs7QUFHQSxjQUFLem1ELEtBQUssQ0FBRSxDQUFGLENBQUwsS0FBZSxJQUFwQixFQUEyQjtBQUMxQkEsWUFBQUEsS0FBSyxDQUFFLENBQUYsQ0FBTCxHQUFhLE1BQU1BLEtBQUssQ0FBRSxDQUFGLENBQVgsR0FBbUIsR0FBaEM7QUFDQTs7QUFFRCxpQkFBT0EsS0FBSyxDQUFDbEUsS0FBTixDQUFhLENBQWIsRUFBZ0IsQ0FBaEIsQ0FBUDtBQUNBLFNBYlM7QUFlVixpQkFBUyxlQUFVa0UsS0FBVixFQUFrQjtBQUUxQjtBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNHQSxVQUFBQSxLQUFLLENBQUUsQ0FBRixDQUFMLEdBQWFBLEtBQUssQ0FBRSxDQUFGLENBQUwsQ0FBV3JnQixXQUFYLEVBQWI7O0FBRUEsY0FBS3FnQixLQUFLLENBQUUsQ0FBRixDQUFMLENBQVdsRSxLQUFYLENBQWtCLENBQWxCLEVBQXFCLENBQXJCLE1BQTZCLEtBQWxDLEVBQTBDO0FBRXpDO0FBQ0EsZ0JBQUssQ0FBQ2tFLEtBQUssQ0FBRSxDQUFGLENBQVgsRUFBbUI7QUFDbEI2akQsY0FBQUEsTUFBTSxDQUFDM00sS0FBUCxDQUFjbDNDLEtBQUssQ0FBRSxDQUFGLENBQW5CO0FBQ0EsYUFMd0MsQ0FPekM7QUFDQTs7O0FBQ0FBLFlBQUFBLEtBQUssQ0FBRSxDQUFGLENBQUwsR0FBYSxFQUFHQSxLQUFLLENBQUUsQ0FBRixDQUFMLEdBQ2ZBLEtBQUssQ0FBRSxDQUFGLENBQUwsSUFBZUEsS0FBSyxDQUFFLENBQUYsQ0FBTCxJQUFjLENBQTdCLENBRGUsR0FFZixLQUFNQSxLQUFLLENBQUUsQ0FBRixDQUFMLEtBQWUsTUFBZixJQUF5QkEsS0FBSyxDQUFFLENBQUYsQ0FBTCxLQUFlLEtBQTlDLENBRlksQ0FBYjtBQUdBQSxZQUFBQSxLQUFLLENBQUUsQ0FBRixDQUFMLEdBQWEsRUFBS0EsS0FBSyxDQUFFLENBQUYsQ0FBTCxHQUFhQSxLQUFLLENBQUUsQ0FBRixDQUFwQixJQUErQkEsS0FBSyxDQUFFLENBQUYsQ0FBTCxLQUFlLEtBQWpELENBQWIsQ0FaeUMsQ0FjekM7QUFDQSxXQWZELE1BZU8sSUFBS0EsS0FBSyxDQUFFLENBQUYsQ0FBVixFQUFrQjtBQUN4QjZqRCxZQUFBQSxNQUFNLENBQUMzTSxLQUFQLENBQWNsM0MsS0FBSyxDQUFFLENBQUYsQ0FBbkI7QUFDQTs7QUFFRCxpQkFBT0EsS0FBUDtBQUNBLFNBakRTO0FBbURWLGtCQUFVLGdCQUFVQSxLQUFWLEVBQWtCO0FBQzNCLGNBQUlnc0QsTUFBSjtBQUFBLGNBQ0NDLFFBQVEsR0FBRyxDQUFDanNELEtBQUssQ0FBRSxDQUFGLENBQU4sSUFBZUEsS0FBSyxDQUFFLENBQUYsQ0FEaEM7O0FBR0EsY0FBS2ltRCxTQUFTLENBQUUsT0FBRixDQUFULENBQXFCMWhFLElBQXJCLENBQTJCeWIsS0FBSyxDQUFFLENBQUYsQ0FBaEMsQ0FBTCxFQUErQztBQUM5QyxtQkFBTyxJQUFQO0FBQ0EsV0FOMEIsQ0FRM0I7OztBQUNBLGNBQUtBLEtBQUssQ0FBRSxDQUFGLENBQVYsRUFBa0I7QUFDakJBLFlBQUFBLEtBQUssQ0FBRSxDQUFGLENBQUwsR0FBYUEsS0FBSyxDQUFFLENBQUYsQ0FBTCxJQUFjQSxLQUFLLENBQUUsQ0FBRixDQUFuQixJQUE0QixFQUF6QyxDQURpQixDQUdsQjtBQUNDLFdBSkQsTUFJTyxJQUFLaXNELFFBQVEsSUFBSWxHLE9BQU8sQ0FBQ3hoRSxJQUFSLENBQWMwbkUsUUFBZCxDQUFaLE1BRVg7QUFDRUQsVUFBQUEsTUFBTSxHQUFHL0gsUUFBUSxDQUFFZ0ksUUFBRixFQUFZLElBQVosQ0FIUixPQUtYO0FBQ0VELFVBQUFBLE1BQU0sR0FBR0MsUUFBUSxDQUFDdmpFLE9BQVQsQ0FBa0IsR0FBbEIsRUFBdUJ1akUsUUFBUSxDQUFDL3dFLE1BQVQsR0FBa0I4d0UsTUFBekMsSUFBb0RDLFFBQVEsQ0FBQy93RSxNQU43RCxDQUFMLEVBTTZFO0FBRW5GO0FBQ0E4a0IsWUFBQUEsS0FBSyxDQUFFLENBQUYsQ0FBTCxHQUFhQSxLQUFLLENBQUUsQ0FBRixDQUFMLENBQVdsRSxLQUFYLENBQWtCLENBQWxCLEVBQXFCa3dELE1BQXJCLENBQWI7QUFDQWhzRCxZQUFBQSxLQUFLLENBQUUsQ0FBRixDQUFMLEdBQWFpc0QsUUFBUSxDQUFDbndELEtBQVQsQ0FBZ0IsQ0FBaEIsRUFBbUJrd0QsTUFBbkIsQ0FBYjtBQUNBLFdBeEIwQixDQTBCM0I7OztBQUNBLGlCQUFPaHNELEtBQUssQ0FBQ2xFLEtBQU4sQ0FBYSxDQUFiLEVBQWdCLENBQWhCLENBQVA7QUFDQTtBQS9FUyxPQXBCYztBQXNHekJ1ZCxNQUFBQSxNQUFNLEVBQUU7QUFFUCxlQUFPLGFBQVU2eUMsZ0JBQVYsRUFBNkI7QUFDbkMsY0FBSTFuRSxRQUFRLEdBQUcwbkUsZ0JBQWdCLENBQUM1eUUsT0FBakIsQ0FBMEJrdEUsU0FBMUIsRUFBcUNDLFNBQXJDLEVBQWlEOW1FLFdBQWpELEVBQWY7QUFDQSxpQkFBT3VzRSxnQkFBZ0IsS0FBSyxHQUFyQixHQUNOLFlBQVc7QUFDVixtQkFBTyxJQUFQO0FBQ0EsV0FISyxHQUlOLFVBQVV0SyxJQUFWLEVBQWlCO0FBQ2hCLG1CQUFPQSxJQUFJLENBQUNwOUQsUUFBTCxJQUFpQm85RCxJQUFJLENBQUNwOUQsUUFBTCxDQUFjN0UsV0FBZCxPQUFnQzZFLFFBQXhEO0FBQ0EsV0FORjtBQU9BLFNBWE07QUFhUCxpQkFBUyxlQUFVcW1DLFNBQVYsRUFBc0I7QUFDOUIsY0FBSXNoQyxPQUFPLEdBQUduSCxVQUFVLENBQUVuNkIsU0FBUyxHQUFHLEdBQWQsQ0FBeEI7QUFFQSxpQkFBT3NoQyxPQUFPLElBQ2IsQ0FBRUEsT0FBTyxHQUFHLElBQUlqb0IsTUFBSixDQUFZLFFBQVFzaEIsVUFBUixHQUN2QixHQUR1QixHQUNqQjM2QixTQURpQixHQUNMLEdBREssR0FDQzI2QixVQURELEdBQ2MsS0FEMUIsQ0FBWixLQUNtRFIsVUFBVSxDQUMzRG42QixTQUQyRCxFQUNoRCxVQUFVKzJCLElBQVYsRUFBaUI7QUFDM0IsbUJBQU91SyxPQUFPLENBQUM1bkUsSUFBUixDQUNOLE9BQU9xOUQsSUFBSSxDQUFDLzJCLFNBQVosS0FBMEIsUUFBMUIsSUFBc0MrMkIsSUFBSSxDQUFDLzJCLFNBQTNDLElBQ0EsT0FBTysyQixJQUFJLENBQUN2OUQsWUFBWixLQUE2QixXQUE3QixJQUNDdTlELElBQUksQ0FBQ3Y5RCxZQUFMLENBQW1CLE9BQW5CLENBRkQsSUFHQSxFQUpNLENBQVA7QUFNRixXQVI0RCxDQUY5RDtBQVdBLFNBM0JNO0FBNkJQLGdCQUFRLGNBQVV3WixJQUFWLEVBQWdCdzRCLFFBQWhCLEVBQTBCKzFCLEtBQTFCLEVBQWtDO0FBQ3pDLGlCQUFPLFVBQVV4SyxJQUFWLEVBQWlCO0FBQ3ZCLGdCQUFJdGdFLE1BQU0sR0FBR3VpRSxNQUFNLENBQUNsbUQsSUFBUCxDQUFhaWtELElBQWIsRUFBbUIvakQsSUFBbkIsQ0FBYjs7QUFFQSxnQkFBS3ZjLE1BQU0sSUFBSSxJQUFmLEVBQXNCO0FBQ3JCLHFCQUFPKzBDLFFBQVEsS0FBSyxJQUFwQjtBQUNBOztBQUNELGdCQUFLLENBQUNBLFFBQU4sRUFBaUI7QUFDaEIscUJBQU8sSUFBUDtBQUNBOztBQUVELzBDLFlBQUFBLE1BQU0sSUFBSSxFQUFWO0FBRUE7O0FBRUEsbUJBQU8rMEMsUUFBUSxLQUFLLEdBQWIsR0FBbUIvMEMsTUFBTSxLQUFLOHFFLEtBQTlCLEdBQ04vMUIsUUFBUSxLQUFLLElBQWIsR0FBb0IvMEMsTUFBTSxLQUFLOHFFLEtBQS9CLEdBQ0EvMUIsUUFBUSxLQUFLLElBQWIsR0FBb0IrMUIsS0FBSyxJQUFJOXFFLE1BQU0sQ0FBQ29ILE9BQVAsQ0FBZ0IwakUsS0FBaEIsTUFBNEIsQ0FBekQsR0FDQS8xQixRQUFRLEtBQUssSUFBYixHQUFvQisxQixLQUFLLElBQUk5cUUsTUFBTSxDQUFDb0gsT0FBUCxDQUFnQjBqRSxLQUFoQixJQUEwQixDQUFDLENBQXhELEdBQ0EvMUIsUUFBUSxLQUFLLElBQWIsR0FBb0IrMUIsS0FBSyxJQUFJOXFFLE1BQU0sQ0FBQ3dhLEtBQVAsQ0FBYyxDQUFDc3dELEtBQUssQ0FBQ2x4RSxNQUFyQixNQUFrQ2t4RSxLQUEvRCxHQUNBLzFCLFFBQVEsS0FBSyxJQUFiLEdBQW9CLENBQUUsTUFBTS8wQyxNQUFNLENBQUNoSSxPQUFQLENBQWdCb3NFLFdBQWhCLEVBQTZCLEdBQTdCLENBQU4sR0FBMkMsR0FBN0MsRUFBbURoOUQsT0FBbkQsQ0FBNEQwakUsS0FBNUQsSUFBc0UsQ0FBQyxDQUEzRixHQUNBLzFCLFFBQVEsS0FBSyxJQUFiLEdBQW9CLzBDLE1BQU0sS0FBSzhxRSxLQUFYLElBQW9COXFFLE1BQU0sQ0FBQ3dhLEtBQVAsQ0FBYyxDQUFkLEVBQWlCc3dELEtBQUssQ0FBQ2x4RSxNQUFOLEdBQWUsQ0FBaEMsTUFBd0NreEUsS0FBSyxHQUFHLEdBQXhGLEdBQ0EsS0FQRDtBQVFBO0FBRUEsV0F4QkQ7QUF5QkEsU0F2RE07QUF5RFAsaUJBQVMsZUFBVWx6RSxJQUFWLEVBQWdCbXpFLElBQWhCLEVBQXNCQyxTQUF0QixFQUFpQzVpRCxLQUFqQyxFQUF3Q0MsSUFBeEMsRUFBK0M7QUFDdkQsY0FBSTRpRCxNQUFNLEdBQUdyekUsSUFBSSxDQUFDNGlCLEtBQUwsQ0FBWSxDQUFaLEVBQWUsQ0FBZixNQUF1QixLQUFwQztBQUFBLGNBQ0Mwd0QsT0FBTyxHQUFHdHpFLElBQUksQ0FBQzRpQixLQUFMLENBQVksQ0FBQyxDQUFiLE1BQXFCLE1BRGhDO0FBQUEsY0FFQzJ3RCxNQUFNLEdBQUdKLElBQUksS0FBSyxTQUZuQjtBQUlBLGlCQUFPM2lELEtBQUssS0FBSyxDQUFWLElBQWVDLElBQUksS0FBSyxDQUF4QixHQUVOO0FBQ0Esb0JBQVVpNEMsSUFBVixFQUFpQjtBQUNoQixtQkFBTyxDQUFDLENBQUNBLElBQUksQ0FBQ3BqRSxVQUFkO0FBQ0EsV0FMSyxHQU9OLFVBQVVvakUsSUFBVixFQUFnQjhLLFFBQWhCLEVBQTBCQyxHQUExQixFQUFnQztBQUMvQixnQkFBSS8rQyxLQUFKO0FBQUEsZ0JBQVdnL0MsV0FBWDtBQUFBLGdCQUF3QkMsVUFBeEI7QUFBQSxnQkFBb0NwbkUsSUFBcEM7QUFBQSxnQkFBMENxbkUsU0FBMUM7QUFBQSxnQkFBcUR4NkQsS0FBckQ7QUFBQSxnQkFDQ2sxRCxHQUFHLEdBQUcrRSxNQUFNLEtBQUtDLE9BQVgsR0FBcUIsYUFBckIsR0FBcUMsaUJBRDVDO0FBQUEsZ0JBRUN4akUsTUFBTSxHQUFHNDRELElBQUksQ0FBQ3BqRSxVQUZmO0FBQUEsZ0JBR0NxZixJQUFJLEdBQUc0dUQsTUFBTSxJQUFJN0ssSUFBSSxDQUFDcDlELFFBQUwsQ0FBYzdFLFdBQWQsRUFIbEI7QUFBQSxnQkFJQ290RSxRQUFRLEdBQUcsQ0FBQ0osR0FBRCxJQUFRLENBQUNGLE1BSnJCO0FBQUEsZ0JBS0N6RCxJQUFJLEdBQUcsS0FMUjs7QUFPQSxnQkFBS2hnRSxNQUFMLEVBQWM7QUFFYjtBQUNBLGtCQUFLdWpFLE1BQUwsRUFBYztBQUNiLHVCQUFRL0UsR0FBUixFQUFjO0FBQ2IvaEUsa0JBQUFBLElBQUksR0FBR204RCxJQUFQOztBQUNBLHlCQUFVbjhELElBQUksR0FBR0EsSUFBSSxDQUFFK2hFLEdBQUYsQ0FBckIsRUFBaUM7QUFDaEMsd0JBQUtpRixNQUFNLEdBQ1ZobkUsSUFBSSxDQUFDakIsUUFBTCxDQUFjN0UsV0FBZCxPQUFnQ2tlLElBRHRCLEdBRVZwWSxJQUFJLENBQUMvRyxRQUFMLEtBQWtCLENBRm5CLEVBRXVCO0FBRXRCLDZCQUFPLEtBQVA7QUFDQTtBQUNELG1CQVRZLENBV2I7OztBQUNBNFQsa0JBQUFBLEtBQUssR0FBR2sxRCxHQUFHLEdBQUd0dUUsSUFBSSxLQUFLLE1BQVQsSUFBbUIsQ0FBQ29aLEtBQXBCLElBQTZCLGFBQTNDO0FBQ0E7O0FBQ0QsdUJBQU8sSUFBUDtBQUNBOztBQUVEQSxjQUFBQSxLQUFLLEdBQUcsQ0FBRWs2RCxPQUFPLEdBQUd4akUsTUFBTSxDQUFDdEQsVUFBVixHQUF1QnNELE1BQU0sQ0FBQ2drRSxTQUF2QyxDQUFSLENBckJhLENBdUJiOztBQUNBLGtCQUFLUixPQUFPLElBQUlPLFFBQWhCLEVBQTJCO0FBRTFCO0FBRUE7QUFDQXRuRSxnQkFBQUEsSUFBSSxHQUFHdUQsTUFBUDtBQUNBNmpFLGdCQUFBQSxVQUFVLEdBQUdwbkUsSUFBSSxDQUFFZzlELE9BQUYsQ0FBSixLQUFxQmg5RCxJQUFJLENBQUVnOUQsT0FBRixDQUFKLEdBQWtCLEVBQXZDLENBQWIsQ0FOMEIsQ0FRMUI7QUFDQTs7QUFDQW1LLGdCQUFBQSxXQUFXLEdBQUdDLFVBQVUsQ0FBRXBuRSxJQUFJLENBQUN3bkUsUUFBUCxDQUFWLEtBQ1hKLFVBQVUsQ0FBRXBuRSxJQUFJLENBQUN3bkUsUUFBUCxDQUFWLEdBQThCLEVBRG5CLENBQWQ7QUFHQXIvQyxnQkFBQUEsS0FBSyxHQUFHZy9DLFdBQVcsQ0FBRTF6RSxJQUFGLENBQVgsSUFBdUIsRUFBL0I7QUFDQTR6RSxnQkFBQUEsU0FBUyxHQUFHbC9DLEtBQUssQ0FBRSxDQUFGLENBQUwsS0FBZWszQyxPQUFmLElBQTBCbDNDLEtBQUssQ0FBRSxDQUFGLENBQTNDO0FBQ0FvN0MsZ0JBQUFBLElBQUksR0FBRzhELFNBQVMsSUFBSWwvQyxLQUFLLENBQUUsQ0FBRixDQUF6QjtBQUNBbm9CLGdCQUFBQSxJQUFJLEdBQUdxbkUsU0FBUyxJQUFJOWpFLE1BQU0sQ0FBQ3krRCxVQUFQLENBQW1CcUYsU0FBbkIsQ0FBcEI7O0FBRUEsdUJBQVVybkUsSUFBSSxHQUFHLEVBQUVxbkUsU0FBRixJQUFlcm5FLElBQWYsSUFBdUJBLElBQUksQ0FBRStoRSxHQUFGLENBQTNCLE1BRWhCO0FBQ0V3QixnQkFBQUEsSUFBSSxHQUFHOEQsU0FBUyxHQUFHLENBSEwsS0FHWXg2RCxLQUFLLENBQUNpVixHQUFOLEVBSDdCLEVBRzZDO0FBRTVDO0FBQ0Esc0JBQUs5aEIsSUFBSSxDQUFDL0csUUFBTCxLQUFrQixDQUFsQixJQUF1QixFQUFFc3FFLElBQXpCLElBQWlDdmpFLElBQUksS0FBS204RCxJQUEvQyxFQUFzRDtBQUNyRGdMLG9CQUFBQSxXQUFXLENBQUUxekUsSUFBRixDQUFYLEdBQXNCLENBQUU0ckUsT0FBRixFQUFXZ0ksU0FBWCxFQUFzQjlELElBQXRCLENBQXRCO0FBQ0E7QUFDQTtBQUNEO0FBRUQsZUE5QkQsTUE4Qk87QUFFTjtBQUNBLG9CQUFLK0QsUUFBTCxFQUFnQjtBQUVmO0FBQ0F0bkUsa0JBQUFBLElBQUksR0FBR204RCxJQUFQO0FBQ0FpTCxrQkFBQUEsVUFBVSxHQUFHcG5FLElBQUksQ0FBRWc5RCxPQUFGLENBQUosS0FBcUJoOUQsSUFBSSxDQUFFZzlELE9BQUYsQ0FBSixHQUFrQixFQUF2QyxDQUFiLENBSmUsQ0FNZjtBQUNBOztBQUNBbUssa0JBQUFBLFdBQVcsR0FBR0MsVUFBVSxDQUFFcG5FLElBQUksQ0FBQ3duRSxRQUFQLENBQVYsS0FDWEosVUFBVSxDQUFFcG5FLElBQUksQ0FBQ3duRSxRQUFQLENBQVYsR0FBOEIsRUFEbkIsQ0FBZDtBQUdBci9DLGtCQUFBQSxLQUFLLEdBQUdnL0MsV0FBVyxDQUFFMXpFLElBQUYsQ0FBWCxJQUF1QixFQUEvQjtBQUNBNHpFLGtCQUFBQSxTQUFTLEdBQUdsL0MsS0FBSyxDQUFFLENBQUYsQ0FBTCxLQUFlazNDLE9BQWYsSUFBMEJsM0MsS0FBSyxDQUFFLENBQUYsQ0FBM0M7QUFDQW83QyxrQkFBQUEsSUFBSSxHQUFHOEQsU0FBUDtBQUNBLGlCQWpCSyxDQW1CTjtBQUNBOzs7QUFDQSxvQkFBSzlELElBQUksS0FBSyxLQUFkLEVBQXNCO0FBRXJCO0FBQ0EseUJBQVV2akUsSUFBSSxHQUFHLEVBQUVxbkUsU0FBRixJQUFlcm5FLElBQWYsSUFBdUJBLElBQUksQ0FBRStoRSxHQUFGLENBQTNCLEtBQ2R3QixJQUFJLEdBQUc4RCxTQUFTLEdBQUcsQ0FETCxLQUNZeDZELEtBQUssQ0FBQ2lWLEdBQU4sRUFEN0IsRUFDNkM7QUFFNUMsd0JBQUssQ0FBRWtsRCxNQUFNLEdBQ1pobkUsSUFBSSxDQUFDakIsUUFBTCxDQUFjN0UsV0FBZCxPQUFnQ2tlLElBRHBCLEdBRVpwWSxJQUFJLENBQUMvRyxRQUFMLEtBQWtCLENBRmQsS0FHSixFQUFFc3FFLElBSEgsRUFHVTtBQUVUO0FBQ0EsMEJBQUsrRCxRQUFMLEVBQWdCO0FBQ2ZGLHdCQUFBQSxVQUFVLEdBQUdwbkUsSUFBSSxDQUFFZzlELE9BQUYsQ0FBSixLQUNWaDlELElBQUksQ0FBRWc5RCxPQUFGLENBQUosR0FBa0IsRUFEUixDQUFiLENBRGUsQ0FJZjtBQUNBOztBQUNBbUssd0JBQUFBLFdBQVcsR0FBR0MsVUFBVSxDQUFFcG5FLElBQUksQ0FBQ3duRSxRQUFQLENBQVYsS0FDWEosVUFBVSxDQUFFcG5FLElBQUksQ0FBQ3duRSxRQUFQLENBQVYsR0FBOEIsRUFEbkIsQ0FBZDtBQUdBTCx3QkFBQUEsV0FBVyxDQUFFMXpFLElBQUYsQ0FBWCxHQUFzQixDQUFFNHJFLE9BQUYsRUFBV2tFLElBQVgsQ0FBdEI7QUFDQTs7QUFFRCwwQkFBS3ZqRSxJQUFJLEtBQUttOEQsSUFBZCxFQUFxQjtBQUNwQjtBQUNBO0FBQ0Q7QUFDRDtBQUNEO0FBQ0QsZUF6R1ksQ0EyR2I7OztBQUNBb0gsY0FBQUEsSUFBSSxJQUFJci9DLElBQVI7QUFDQSxxQkFBT3EvQyxJQUFJLEtBQUt0L0MsS0FBVCxJQUFvQnMvQyxJQUFJLEdBQUd0L0MsS0FBUCxLQUFpQixDQUFqQixJQUFzQnMvQyxJQUFJLEdBQUd0L0MsS0FBUCxJQUFnQixDQUFqRTtBQUNBO0FBQ0QsV0E5SEY7QUErSEEsU0E3TE07QUErTFAsa0JBQVUsZ0JBQVV3akQsTUFBVixFQUFrQjNELFFBQWxCLEVBQTZCO0FBRXRDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBSWxYLElBQUo7QUFBQSxjQUNDK08sRUFBRSxHQUFHMEMsSUFBSSxDQUFDMkIsT0FBTCxDQUFjeUgsTUFBZCxLQUEwQnBKLElBQUksQ0FBQ3FKLFVBQUwsQ0FBaUJELE1BQU0sQ0FBQ3Z0RSxXQUFQLEVBQWpCLENBQTFCLElBQ0pra0UsTUFBTSxDQUFDM00sS0FBUCxDQUFjLHlCQUF5QmdXLE1BQXZDLENBRkYsQ0FOc0MsQ0FVdEM7QUFDQTtBQUNBOztBQUNBLGNBQUs5TCxFQUFFLENBQUVxQixPQUFGLENBQVAsRUFBcUI7QUFDcEIsbUJBQU9yQixFQUFFLENBQUVtSSxRQUFGLENBQVQ7QUFDQSxXQWZxQyxDQWlCdEM7OztBQUNBLGNBQUtuSSxFQUFFLENBQUNsbUUsTUFBSCxHQUFZLENBQWpCLEVBQXFCO0FBQ3BCbTNELFlBQUFBLElBQUksR0FBRyxDQUFFNmEsTUFBRixFQUFVQSxNQUFWLEVBQWtCLEVBQWxCLEVBQXNCM0QsUUFBdEIsQ0FBUDtBQUNBLG1CQUFPekYsSUFBSSxDQUFDcUosVUFBTCxDQUFnQmpOLGNBQWhCLENBQWdDZ04sTUFBTSxDQUFDdnRFLFdBQVAsRUFBaEMsSUFDTjhvRSxZQUFZLENBQUUsVUFBVWQsSUFBVixFQUFnQnJ6QyxPQUFoQixFQUEwQjtBQUN2QyxrQkFBSTg0QyxHQUFKO0FBQUEsa0JBQ0NDLE9BQU8sR0FBR2pNLEVBQUUsQ0FBRXVHLElBQUYsRUFBUTRCLFFBQVIsQ0FEYjtBQUFBLGtCQUVDdHVFLENBQUMsR0FBR295RSxPQUFPLENBQUNueUUsTUFGYjs7QUFHQSxxQkFBUUQsQ0FBQyxFQUFULEVBQWM7QUFDYm15RSxnQkFBQUEsR0FBRyxHQUFHMWtFLE9BQU8sQ0FBRWkvRCxJQUFGLEVBQVEwRixPQUFPLENBQUVweUUsQ0FBRixDQUFmLENBQWI7QUFDQTBzRSxnQkFBQUEsSUFBSSxDQUFFeUYsR0FBRixDQUFKLEdBQWMsRUFBRzk0QyxPQUFPLENBQUU4NEMsR0FBRixDQUFQLEdBQWlCQyxPQUFPLENBQUVweUUsQ0FBRixDQUEzQixDQUFkO0FBQ0E7QUFDRCxhQVJXLENBRE4sR0FVTixVQUFVMm1FLElBQVYsRUFBaUI7QUFDaEIscUJBQU9SLEVBQUUsQ0FBRVEsSUFBRixFQUFRLENBQVIsRUFBV3ZQLElBQVgsQ0FBVDtBQUNBLGFBWkY7QUFhQTs7QUFFRCxpQkFBTytPLEVBQVA7QUFDQTtBQW5PTSxPQXRHaUI7QUE0VXpCcUUsTUFBQUEsT0FBTyxFQUFFO0FBRVI7QUFDQSxlQUFPZ0QsWUFBWSxDQUFFLFVBQVVqckIsUUFBVixFQUFxQjtBQUV6QztBQUNBO0FBQ0E7QUFDQSxjQUFJOHNCLEtBQUssR0FBRyxFQUFaO0FBQUEsY0FDQ25ILE9BQU8sR0FBRyxFQURYO0FBQUEsY0FFQ21LLE9BQU8sR0FBR3BKLE9BQU8sQ0FBRTFtQixRQUFRLENBQUNsa0QsT0FBVCxDQUFrQnFzRSxLQUFsQixFQUF5QixJQUF6QixDQUFGLENBRmxCO0FBSUEsaUJBQU8ySCxPQUFPLENBQUU3SyxPQUFGLENBQVAsR0FDTmdHLFlBQVksQ0FBRSxVQUFVZCxJQUFWLEVBQWdCcnpDLE9BQWhCLEVBQXlCbzRDLFFBQXpCLEVBQW1DQyxHQUFuQyxFQUF5QztBQUN0RCxnQkFBSS9LLElBQUo7QUFBQSxnQkFDQzJMLFNBQVMsR0FBR0QsT0FBTyxDQUFFM0YsSUFBRixFQUFRLElBQVIsRUFBY2dGLEdBQWQsRUFBbUIsRUFBbkIsQ0FEcEI7QUFBQSxnQkFFQzF4RSxDQUFDLEdBQUcwc0UsSUFBSSxDQUFDenNFLE1BRlYsQ0FEc0QsQ0FLdEQ7O0FBQ0EsbUJBQVFELENBQUMsRUFBVCxFQUFjO0FBQ2Isa0JBQU8ybUUsSUFBSSxHQUFHMkwsU0FBUyxDQUFFdHlFLENBQUYsQ0FBdkIsRUFBaUM7QUFDaEMwc0UsZ0JBQUFBLElBQUksQ0FBRTFzRSxDQUFGLENBQUosR0FBWSxFQUFHcTVCLE9BQU8sQ0FBRXI1QixDQUFGLENBQVAsR0FBZTJtRSxJQUFsQixDQUFaO0FBQ0E7QUFDRDtBQUNELFdBWFcsQ0FETixHQWFOLFVBQVVBLElBQVYsRUFBZ0I4SyxRQUFoQixFQUEwQkMsR0FBMUIsRUFBZ0M7QUFDL0JyQyxZQUFBQSxLQUFLLENBQUUsQ0FBRixDQUFMLEdBQWExSSxJQUFiO0FBQ0EwTCxZQUFBQSxPQUFPLENBQUVoRCxLQUFGLEVBQVMsSUFBVCxFQUFlcUMsR0FBZixFQUFvQnhKLE9BQXBCLENBQVAsQ0FGK0IsQ0FJL0I7O0FBQ0FtSCxZQUFBQSxLQUFLLENBQUUsQ0FBRixDQUFMLEdBQWEsSUFBYjtBQUNBLG1CQUFPLENBQUNuSCxPQUFPLENBQUM1N0MsR0FBUixFQUFSO0FBQ0EsV0FwQkY7QUFxQkEsU0E5QmtCLENBSFg7QUFtQ1IsZUFBT2toRCxZQUFZLENBQUUsVUFBVWpyQixRQUFWLEVBQXFCO0FBQ3pDLGlCQUFPLFVBQVVva0IsSUFBVixFQUFpQjtBQUN2QixtQkFBT2lDLE1BQU0sQ0FBRXJtQixRQUFGLEVBQVlva0IsSUFBWixDQUFOLENBQXlCMW1FLE1BQXpCLEdBQWtDLENBQXpDO0FBQ0EsV0FGRDtBQUdBLFNBSmtCLENBbkNYO0FBeUNSLG9CQUFZdXRFLFlBQVksQ0FBRSxVQUFVekgsSUFBVixFQUFpQjtBQUMxQ0EsVUFBQUEsSUFBSSxHQUFHQSxJQUFJLENBQUMxbkUsT0FBTCxDQUFja3RFLFNBQWQsRUFBeUJDLFNBQXpCLENBQVA7QUFDQSxpQkFBTyxVQUFVN0UsSUFBVixFQUFpQjtBQUN2QixtQkFBTyxDQUFFQSxJQUFJLENBQUNnSyxXQUFMLElBQW9CN0gsT0FBTyxDQUFFbkMsSUFBRixDQUE3QixFQUF3Q2w1RCxPQUF4QyxDQUFpRHM0RCxJQUFqRCxJQUEwRCxDQUFDLENBQWxFO0FBQ0EsV0FGRDtBQUdBLFNBTHVCLENBekNoQjtBQWdEUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFReUgsWUFBWSxDQUFFLFVBQVUrRSxJQUFWLEVBQWlCO0FBRXRDO0FBQ0EsY0FBSyxDQUFDeEgsV0FBVyxDQUFDemhFLElBQVosQ0FBa0JpcEUsSUFBSSxJQUFJLEVBQTFCLENBQU4sRUFBdUM7QUFDdEMzSixZQUFBQSxNQUFNLENBQUMzTSxLQUFQLENBQWMsdUJBQXVCc1csSUFBckM7QUFDQTs7QUFDREEsVUFBQUEsSUFBSSxHQUFHQSxJQUFJLENBQUNsMEUsT0FBTCxDQUFja3RFLFNBQWQsRUFBeUJDLFNBQXpCLEVBQXFDOW1FLFdBQXJDLEVBQVA7QUFDQSxpQkFBTyxVQUFVaWlFLElBQVYsRUFBaUI7QUFDdkIsZ0JBQUk2TCxRQUFKOztBQUNBLGVBQUc7QUFDRixrQkFBT0EsUUFBUSxHQUFHaEosY0FBYyxHQUMvQjdDLElBQUksQ0FBQzRMLElBRDBCLEdBRS9CNUwsSUFBSSxDQUFDdjlELFlBQUwsQ0FBbUIsVUFBbkIsS0FBbUN1OUQsSUFBSSxDQUFDdjlELFlBQUwsQ0FBbUIsTUFBbkIsQ0FGcEMsRUFFb0U7QUFFbkVvcEUsZ0JBQUFBLFFBQVEsR0FBR0EsUUFBUSxDQUFDOXRFLFdBQVQsRUFBWDtBQUNBLHVCQUFPOHRFLFFBQVEsS0FBS0QsSUFBYixJQUFxQkMsUUFBUSxDQUFDL2tFLE9BQVQsQ0FBa0I4a0UsSUFBSSxHQUFHLEdBQXpCLE1BQW1DLENBQS9EO0FBQ0E7QUFDRCxhQVJELFFBUVUsQ0FBRTVMLElBQUksR0FBR0EsSUFBSSxDQUFDcGpFLFVBQWQsS0FBOEJvakUsSUFBSSxDQUFDbGpFLFFBQUwsS0FBa0IsQ0FSMUQ7O0FBU0EsbUJBQU8sS0FBUDtBQUNBLFdBWkQ7QUFhQSxTQXBCbUIsQ0F2RFo7QUE2RVI7QUFDQSxrQkFBVSxnQkFBVWtqRSxJQUFWLEVBQWlCO0FBQzFCLGNBQUk4TCxJQUFJLEdBQUd6MUUsTUFBTSxDQUFDMDFFLFFBQVAsSUFBbUIxMUUsTUFBTSxDQUFDMDFFLFFBQVAsQ0FBZ0JELElBQTlDO0FBQ0EsaUJBQU9BLElBQUksSUFBSUEsSUFBSSxDQUFDNXhELEtBQUwsQ0FBWSxDQUFaLE1BQW9COGxELElBQUksQ0FBQy9vRCxFQUF4QztBQUNBLFNBakZPO0FBbUZSLGdCQUFRLGNBQVUrb0QsSUFBVixFQUFpQjtBQUN4QixpQkFBT0EsSUFBSSxLQUFLNEMsT0FBaEI7QUFDQSxTQXJGTztBQXVGUixpQkFBUyxlQUFVNUMsSUFBVixFQUFpQjtBQUN6QixpQkFBT0EsSUFBSSxLQUFLcDhELFFBQVEsQ0FBQ29vRSxhQUFsQixLQUNKLENBQUNwb0UsUUFBUSxDQUFDcW9FLFFBQVYsSUFBc0Jyb0UsUUFBUSxDQUFDcW9FLFFBQVQsRUFEbEIsS0FFTixDQUFDLEVBQUdqTSxJQUFJLENBQUMxb0UsSUFBTCxJQUFhMG9FLElBQUksQ0FBQ2tNLElBQWxCLElBQTBCLENBQUNsTSxJQUFJLENBQUNtTSxRQUFuQyxDQUZGO0FBR0EsU0EzRk87QUE2RlI7QUFDQSxtQkFBVzNFLG9CQUFvQixDQUFFLEtBQUYsQ0E5RnZCO0FBK0ZSLG9CQUFZQSxvQkFBb0IsQ0FBRSxJQUFGLENBL0Z4QjtBQWlHUixtQkFBVyxpQkFBVXhILElBQVYsRUFBaUI7QUFFM0I7QUFDQTtBQUNBLGNBQUlwOUQsUUFBUSxHQUFHbzlELElBQUksQ0FBQ3A5RCxRQUFMLENBQWM3RSxXQUFkLEVBQWY7QUFDQSxpQkFBUzZFLFFBQVEsS0FBSyxPQUFiLElBQXdCLENBQUMsQ0FBQ285RCxJQUFJLENBQUNvTSxPQUFqQyxJQUNKeHBFLFFBQVEsS0FBSyxRQUFiLElBQXlCLENBQUMsQ0FBQ285RCxJQUFJLENBQUNxTSxRQURuQztBQUVBLFNBeEdPO0FBMEdSLG9CQUFZLGtCQUFVck0sSUFBVixFQUFpQjtBQUU1QjtBQUNBO0FBQ0EsY0FBS0EsSUFBSSxDQUFDcGpFLFVBQVYsRUFBdUI7QUFDdEI7QUFDQW9qRSxZQUFBQSxJQUFJLENBQUNwakUsVUFBTCxDQUFnQjB2RSxhQUFoQjtBQUNBOztBQUVELGlCQUFPdE0sSUFBSSxDQUFDcU0sUUFBTCxLQUFrQixJQUF6QjtBQUNBLFNBcEhPO0FBc0hSO0FBQ0EsaUJBQVMsZUFBVXJNLElBQVYsRUFBaUI7QUFFekI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFNQSxJQUFJLEdBQUdBLElBQUksQ0FBQ2w4RCxVQUFsQixFQUE4Qms4RCxJQUE5QixFQUFvQ0EsSUFBSSxHQUFHQSxJQUFJLENBQUN0NkQsV0FBaEQsRUFBOEQ7QUFDN0QsZ0JBQUtzNkQsSUFBSSxDQUFDbGpFLFFBQUwsR0FBZ0IsQ0FBckIsRUFBeUI7QUFDeEIscUJBQU8sS0FBUDtBQUNBO0FBQ0Q7O0FBQ0QsaUJBQU8sSUFBUDtBQUNBLFNBbklPO0FBcUlSLGtCQUFVLGdCQUFVa2pFLElBQVYsRUFBaUI7QUFDMUIsaUJBQU8sQ0FBQ2tDLElBQUksQ0FBQzJCLE9BQUwsQ0FBYyxPQUFkLEVBQXlCN0QsSUFBekIsQ0FBUjtBQUNBLFNBdklPO0FBeUlSO0FBQ0Esa0JBQVUsZ0JBQVVBLElBQVYsRUFBaUI7QUFDMUIsaUJBQU93RSxPQUFPLENBQUM3aEUsSUFBUixDQUFjcTlELElBQUksQ0FBQ3A5RCxRQUFuQixDQUFQO0FBQ0EsU0E1SU87QUE4SVIsaUJBQVMsZUFBVW85RCxJQUFWLEVBQWlCO0FBQ3pCLGlCQUFPdUUsT0FBTyxDQUFDNWhFLElBQVIsQ0FBY3E5RCxJQUFJLENBQUNwOUQsUUFBbkIsQ0FBUDtBQUNBLFNBaEpPO0FBa0pSLGtCQUFVLGdCQUFVbzlELElBQVYsRUFBaUI7QUFDMUIsY0FBSS9qRCxJQUFJLEdBQUcrakQsSUFBSSxDQUFDcDlELFFBQUwsQ0FBYzdFLFdBQWQsRUFBWDtBQUNBLGlCQUFPa2UsSUFBSSxLQUFLLE9BQVQsSUFBb0IrakQsSUFBSSxDQUFDMW9FLElBQUwsS0FBYyxRQUFsQyxJQUE4QzJrQixJQUFJLEtBQUssUUFBOUQ7QUFDQSxTQXJKTztBQXVKUixnQkFBUSxjQUFVK2pELElBQVYsRUFBaUI7QUFDeEIsY0FBSWprRCxJQUFKO0FBQ0EsaUJBQU9pa0QsSUFBSSxDQUFDcDlELFFBQUwsQ0FBYzdFLFdBQWQsT0FBZ0MsT0FBaEMsSUFDTmlpRSxJQUFJLENBQUMxb0UsSUFBTCxLQUFjLE1BRFIsTUFHTjtBQUNBO0FBQ0UsV0FBRXlrQixJQUFJLEdBQUdpa0QsSUFBSSxDQUFDdjlELFlBQUwsQ0FBbUIsTUFBbkIsQ0FBVCxLQUEwQyxJQUExQyxJQUNEc1osSUFBSSxDQUFDaGUsV0FBTCxPQUF1QixNQU5sQixDQUFQO0FBT0EsU0FoS087QUFrS1I7QUFDQSxpQkFBUzJwRSxzQkFBc0IsQ0FBRSxZQUFXO0FBQzNDLGlCQUFPLENBQUUsQ0FBRixDQUFQO0FBQ0EsU0FGOEIsQ0FuS3ZCO0FBdUtSLGdCQUFRQSxzQkFBc0IsQ0FBRSxVQUFVNkUsYUFBVixFQUF5Qmp6RSxNQUF6QixFQUFrQztBQUNqRSxpQkFBTyxDQUFFQSxNQUFNLEdBQUcsQ0FBWCxDQUFQO0FBQ0EsU0FGNkIsQ0F2S3RCO0FBMktSLGNBQU1vdUUsc0JBQXNCLENBQUUsVUFBVTZFLGFBQVYsRUFBeUJqekUsTUFBekIsRUFBaUNxdUUsUUFBakMsRUFBNEM7QUFDekUsaUJBQU8sQ0FBRUEsUUFBUSxHQUFHLENBQVgsR0FBZUEsUUFBUSxHQUFHcnVFLE1BQTFCLEdBQW1DcXVFLFFBQXJDLENBQVA7QUFDQSxTQUYyQixDQTNLcEI7QUErS1IsZ0JBQVFELHNCQUFzQixDQUFFLFVBQVVFLFlBQVYsRUFBd0J0dUUsTUFBeEIsRUFBaUM7QUFDaEUsY0FBSUQsQ0FBQyxHQUFHLENBQVI7O0FBQ0EsaUJBQVFBLENBQUMsR0FBR0MsTUFBWixFQUFvQkQsQ0FBQyxJQUFJLENBQXpCLEVBQTZCO0FBQzVCdXVFLFlBQUFBLFlBQVksQ0FBQzl0RSxJQUFiLENBQW1CVCxDQUFuQjtBQUNBOztBQUNELGlCQUFPdXVFLFlBQVA7QUFDQSxTQU42QixDQS9LdEI7QUF1TFIsZUFBT0Ysc0JBQXNCLENBQUUsVUFBVUUsWUFBVixFQUF3QnR1RSxNQUF4QixFQUFpQztBQUMvRCxjQUFJRCxDQUFDLEdBQUcsQ0FBUjs7QUFDQSxpQkFBUUEsQ0FBQyxHQUFHQyxNQUFaLEVBQW9CRCxDQUFDLElBQUksQ0FBekIsRUFBNkI7QUFDNUJ1dUUsWUFBQUEsWUFBWSxDQUFDOXRFLElBQWIsQ0FBbUJULENBQW5CO0FBQ0E7O0FBQ0QsaUJBQU91dUUsWUFBUDtBQUNBLFNBTjRCLENBdkxyQjtBQStMUixjQUFNRixzQkFBc0IsQ0FBRSxVQUFVRSxZQUFWLEVBQXdCdHVFLE1BQXhCLEVBQWdDcXVFLFFBQWhDLEVBQTJDO0FBQ3hFLGNBQUl0dUUsQ0FBQyxHQUFHc3VFLFFBQVEsR0FBRyxDQUFYLEdBQ1BBLFFBQVEsR0FBR3J1RSxNQURKLEdBRVBxdUUsUUFBUSxHQUFHcnVFLE1BQVgsR0FDQ0EsTUFERCxHQUVDcXVFLFFBSkY7O0FBS0EsaUJBQVEsRUFBRXR1RSxDQUFGLElBQU8sQ0FBZixHQUFvQjtBQUNuQnV1RSxZQUFBQSxZQUFZLENBQUM5dEUsSUFBYixDQUFtQlQsQ0FBbkI7QUFDQTs7QUFDRCxpQkFBT3V1RSxZQUFQO0FBQ0EsU0FWMkIsQ0EvTHBCO0FBMk1SLGNBQU1GLHNCQUFzQixDQUFFLFVBQVVFLFlBQVYsRUFBd0J0dUUsTUFBeEIsRUFBZ0NxdUUsUUFBaEMsRUFBMkM7QUFDeEUsY0FBSXR1RSxDQUFDLEdBQUdzdUUsUUFBUSxHQUFHLENBQVgsR0FBZUEsUUFBUSxHQUFHcnVFLE1BQTFCLEdBQW1DcXVFLFFBQTNDOztBQUNBLGlCQUFRLEVBQUV0dUUsQ0FBRixHQUFNQyxNQUFkLEdBQXdCO0FBQ3ZCc3VFLFlBQUFBLFlBQVksQ0FBQzl0RSxJQUFiLENBQW1CVCxDQUFuQjtBQUNBOztBQUNELGlCQUFPdXVFLFlBQVA7QUFDQSxTQU4yQjtBQTNNcEI7QUE1VWdCLEtBQTFCO0FBaWlCQTFGLElBQUFBLElBQUksQ0FBQzJCLE9BQUwsQ0FBYyxLQUFkLElBQXdCM0IsSUFBSSxDQUFDMkIsT0FBTCxDQUFjLElBQWQsQ0FBeEIsQ0F4dURxQixDQTB1RHJCOztBQUNBLFNBQU14cUUsQ0FBTixJQUFXO0FBQUVtekUsTUFBQUEsS0FBSyxFQUFFLElBQVQ7QUFBZUMsTUFBQUEsUUFBUSxFQUFFLElBQXpCO0FBQStCQyxNQUFBQSxJQUFJLEVBQUUsSUFBckM7QUFBMkNDLE1BQUFBLFFBQVEsRUFBRSxJQUFyRDtBQUEyREMsTUFBQUEsS0FBSyxFQUFFO0FBQWxFLEtBQVgsRUFBc0Y7QUFDckYxSyxNQUFBQSxJQUFJLENBQUMyQixPQUFMLENBQWN4cUUsQ0FBZCxJQUFvQml1RSxpQkFBaUIsQ0FBRWp1RSxDQUFGLENBQXJDO0FBQ0E7O0FBQ0QsU0FBTUEsQ0FBTixJQUFXO0FBQUV3ekUsTUFBQUEsTUFBTSxFQUFFLElBQVY7QUFBZ0JoN0MsTUFBQUEsS0FBSyxFQUFFO0FBQXZCLEtBQVgsRUFBMkM7QUFDMUNxd0MsTUFBQUEsSUFBSSxDQUFDMkIsT0FBTCxDQUFjeHFFLENBQWQsSUFBb0JrdUUsa0JBQWtCLENBQUVsdUUsQ0FBRixDQUF0QztBQUNBLEtBaHZEb0IsQ0FrdkRyQjs7O0FBQ0EsYUFBU2t5RSxVQUFULEdBQXNCLENBQUU7O0FBQ3hCQSxJQUFBQSxVQUFVLENBQUM3MkUsU0FBWCxHQUF1Qnd0RSxJQUFJLENBQUM0SyxPQUFMLEdBQWU1SyxJQUFJLENBQUMyQixPQUEzQztBQUNBM0IsSUFBQUEsSUFBSSxDQUFDcUosVUFBTCxHQUFrQixJQUFJQSxVQUFKLEVBQWxCOztBQUVBbEosSUFBQUEsUUFBUSxHQUFHSixNQUFNLENBQUNJLFFBQVAsR0FBa0IsVUFBVXptQixRQUFWLEVBQW9CbXhCLFNBQXBCLEVBQWdDO0FBQzVELFVBQUl0QixPQUFKO0FBQUEsVUFBYXJ0RCxLQUFiO0FBQUEsVUFBb0I0dUQsTUFBcEI7QUFBQSxVQUE0QjExRSxJQUE1QjtBQUFBLFVBQ0MyMUUsS0FERDtBQUFBLFVBQ1FoSCxNQURSO0FBQUEsVUFDZ0JpSCxVQURoQjtBQUFBLFVBRUNDLE1BQU0sR0FBRzdKLFVBQVUsQ0FBRTFuQixRQUFRLEdBQUcsR0FBYixDQUZwQjs7QUFJQSxVQUFLdXhCLE1BQUwsRUFBYztBQUNiLGVBQU9KLFNBQVMsR0FBRyxDQUFILEdBQU9JLE1BQU0sQ0FBQ2p6RCxLQUFQLENBQWMsQ0FBZCxDQUF2QjtBQUNBOztBQUVEK3lELE1BQUFBLEtBQUssR0FBR3J4QixRQUFSO0FBQ0FxcUIsTUFBQUEsTUFBTSxHQUFHLEVBQVQ7QUFDQWlILE1BQUFBLFVBQVUsR0FBR2hMLElBQUksQ0FBQ2lJLFNBQWxCOztBQUVBLGFBQVE4QyxLQUFSLEVBQWdCO0FBRWY7QUFDQSxZQUFLLENBQUN4QixPQUFELEtBQWNydEQsS0FBSyxHQUFHNGxELE1BQU0sQ0FBQy9vQixJQUFQLENBQWFneUIsS0FBYixDQUF0QixDQUFMLEVBQW9EO0FBQ25ELGNBQUs3dUQsS0FBTCxFQUFhO0FBRVo7QUFDQTZ1RCxZQUFBQSxLQUFLLEdBQUdBLEtBQUssQ0FBQy95RCxLQUFOLENBQWFrRSxLQUFLLENBQUUsQ0FBRixDQUFMLENBQVc5a0IsTUFBeEIsS0FBb0MyekUsS0FBNUM7QUFDQTs7QUFDRGhILFVBQUFBLE1BQU0sQ0FBQ25zRSxJQUFQLENBQWVrekUsTUFBTSxHQUFHLEVBQXhCO0FBQ0E7O0FBRUR2QixRQUFBQSxPQUFPLEdBQUcsS0FBVixDQVplLENBY2Y7O0FBQ0EsWUFBT3J0RCxLQUFLLEdBQUc2bEQsWUFBWSxDQUFDaHBCLElBQWIsQ0FBbUJneUIsS0FBbkIsQ0FBZixFQUE4QztBQUM3Q3hCLFVBQUFBLE9BQU8sR0FBR3J0RCxLQUFLLENBQUNwRSxLQUFOLEVBQVY7QUFDQWd6RCxVQUFBQSxNQUFNLENBQUNsekUsSUFBUCxDQUFhO0FBQ1pyRCxZQUFBQSxLQUFLLEVBQUVnMUUsT0FESztBQUdaO0FBQ0FuMEUsWUFBQUEsSUFBSSxFQUFFOG1CLEtBQUssQ0FBRSxDQUFGLENBQUwsQ0FBVzFtQixPQUFYLENBQW9CcXNFLEtBQXBCLEVBQTJCLEdBQTNCO0FBSk0sV0FBYjtBQU1Ba0osVUFBQUEsS0FBSyxHQUFHQSxLQUFLLENBQUMveUQsS0FBTixDQUFhdXhELE9BQU8sQ0FBQ255RSxNQUFyQixDQUFSO0FBQ0EsU0F4QmMsQ0EwQmY7OztBQUNBLGFBQU1oQyxJQUFOLElBQWM0cUUsSUFBSSxDQUFDenFDLE1BQW5CLEVBQTRCO0FBQzNCLGNBQUssQ0FBRXJaLEtBQUssR0FBR2ltRCxTQUFTLENBQUUvc0UsSUFBRixDQUFULENBQWtCMmpELElBQWxCLENBQXdCZ3lCLEtBQXhCLENBQVYsTUFBaUQsQ0FBQ0MsVUFBVSxDQUFFNTFFLElBQUYsQ0FBWCxLQUNuRDhtQixLQUFLLEdBQUc4dUQsVUFBVSxDQUFFNTFFLElBQUYsQ0FBVixDQUFvQjhtQixLQUFwQixDQUQyQyxDQUFqRCxDQUFMLEVBQzZDO0FBQzVDcXRELFlBQUFBLE9BQU8sR0FBR3J0RCxLQUFLLENBQUNwRSxLQUFOLEVBQVY7QUFDQWd6RCxZQUFBQSxNQUFNLENBQUNsekUsSUFBUCxDQUFhO0FBQ1pyRCxjQUFBQSxLQUFLLEVBQUVnMUUsT0FESztBQUVabjBFLGNBQUFBLElBQUksRUFBRUEsSUFGTTtBQUdabzdCLGNBQUFBLE9BQU8sRUFBRXRVO0FBSEcsYUFBYjtBQUtBNnVELFlBQUFBLEtBQUssR0FBR0EsS0FBSyxDQUFDL3lELEtBQU4sQ0FBYXV4RCxPQUFPLENBQUNueUUsTUFBckIsQ0FBUjtBQUNBO0FBQ0Q7O0FBRUQsWUFBSyxDQUFDbXlFLE9BQU4sRUFBZ0I7QUFDZjtBQUNBO0FBQ0QsT0F4RDJELENBMEQ1RDtBQUNBO0FBQ0E7OztBQUNBLGFBQU9zQixTQUFTLEdBQ2ZFLEtBQUssQ0FBQzN6RSxNQURTLEdBRWYyekUsS0FBSyxHQUNKaEwsTUFBTSxDQUFDM00sS0FBUCxDQUFjMVosUUFBZCxDQURJLEdBR0o7QUFDQTBuQixNQUFBQSxVQUFVLENBQUUxbkIsUUFBRixFQUFZcXFCLE1BQVosQ0FBVixDQUErQi9yRCxLQUEvQixDQUFzQyxDQUF0QyxDQU5GO0FBT0EsS0FwRUQ7O0FBc0VBLGFBQVN1c0QsVUFBVCxDQUFxQnVHLE1BQXJCLEVBQThCO0FBQzdCLFVBQUkzekUsQ0FBQyxHQUFHLENBQVI7QUFBQSxVQUNDaW5FLEdBQUcsR0FBRzBNLE1BQU0sQ0FBQzF6RSxNQURkO0FBQUEsVUFFQ3NpRCxRQUFRLEdBQUcsRUFGWjs7QUFHQSxhQUFRdmlELENBQUMsR0FBR2luRSxHQUFaLEVBQWlCam5FLENBQUMsRUFBbEIsRUFBdUI7QUFDdEJ1aUQsUUFBQUEsUUFBUSxJQUFJb3hCLE1BQU0sQ0FBRTN6RSxDQUFGLENBQU4sQ0FBWTVDLEtBQXhCO0FBQ0E7O0FBQ0QsYUFBT21sRCxRQUFQO0FBQ0E7O0FBRUQsYUFBUzhwQixhQUFULENBQXdCZ0csT0FBeEIsRUFBaUMwQixVQUFqQyxFQUE2Q2g0QixJQUE3QyxFQUFvRDtBQUNuRCxVQUFJd3dCLEdBQUcsR0FBR3dILFVBQVUsQ0FBQ3hILEdBQXJCO0FBQUEsVUFDQ3lILElBQUksR0FBR0QsVUFBVSxDQUFDMWpDLElBRG5CO0FBQUEsVUFFQ3JiLEdBQUcsR0FBR2cvQyxJQUFJLElBQUl6SCxHQUZmO0FBQUEsVUFHQzBILGdCQUFnQixHQUFHbDRCLElBQUksSUFBSS9tQixHQUFHLEtBQUssWUFIcEM7QUFBQSxVQUlDay9DLFFBQVEsR0FBR3BLLElBQUksRUFKaEI7QUFNQSxhQUFPaUssVUFBVSxDQUFDdGxELEtBQVgsR0FFTjtBQUNBLGdCQUFVazRDLElBQVYsRUFBZ0JoZ0UsT0FBaEIsRUFBeUIrcUUsR0FBekIsRUFBK0I7QUFDOUIsZUFBVS9LLElBQUksR0FBR0EsSUFBSSxDQUFFNEYsR0FBRixDQUFyQixFQUFpQztBQUNoQyxjQUFLNUYsSUFBSSxDQUFDbGpFLFFBQUwsS0FBa0IsQ0FBbEIsSUFBdUJ3d0UsZ0JBQTVCLEVBQStDO0FBQzlDLG1CQUFPNUIsT0FBTyxDQUFFMUwsSUFBRixFQUFRaGdFLE9BQVIsRUFBaUIrcUUsR0FBakIsQ0FBZDtBQUNBO0FBQ0Q7O0FBQ0QsZUFBTyxLQUFQO0FBQ0EsT0FWSyxHQVlOO0FBQ0EsZ0JBQVUvSyxJQUFWLEVBQWdCaGdFLE9BQWhCLEVBQXlCK3FFLEdBQXpCLEVBQStCO0FBQzlCLFlBQUl5QyxRQUFKO0FBQUEsWUFBY3hDLFdBQWQ7QUFBQSxZQUEyQkMsVUFBM0I7QUFBQSxZQUNDd0MsUUFBUSxHQUFHLENBQUV2SyxPQUFGLEVBQVdxSyxRQUFYLENBRFosQ0FEOEIsQ0FJOUI7O0FBQ0EsWUFBS3hDLEdBQUwsRUFBVztBQUNWLGlCQUFVL0ssSUFBSSxHQUFHQSxJQUFJLENBQUU0RixHQUFGLENBQXJCLEVBQWlDO0FBQ2hDLGdCQUFLNUYsSUFBSSxDQUFDbGpFLFFBQUwsS0FBa0IsQ0FBbEIsSUFBdUJ3d0UsZ0JBQTVCLEVBQStDO0FBQzlDLGtCQUFLNUIsT0FBTyxDQUFFMUwsSUFBRixFQUFRaGdFLE9BQVIsRUFBaUIrcUUsR0FBakIsQ0FBWixFQUFxQztBQUNwQyx1QkFBTyxJQUFQO0FBQ0E7QUFDRDtBQUNEO0FBQ0QsU0FSRCxNQVFPO0FBQ04saUJBQVUvSyxJQUFJLEdBQUdBLElBQUksQ0FBRTRGLEdBQUYsQ0FBckIsRUFBaUM7QUFDaEMsZ0JBQUs1RixJQUFJLENBQUNsakUsUUFBTCxLQUFrQixDQUFsQixJQUF1Qnd3RSxnQkFBNUIsRUFBK0M7QUFDOUNyQyxjQUFBQSxVQUFVLEdBQUdqTCxJQUFJLENBQUVhLE9BQUYsQ0FBSixLQUFxQmIsSUFBSSxDQUFFYSxPQUFGLENBQUosR0FBa0IsRUFBdkMsQ0FBYixDQUQ4QyxDQUc5QztBQUNBOztBQUNBbUssY0FBQUEsV0FBVyxHQUFHQyxVQUFVLENBQUVqTCxJQUFJLENBQUNxTCxRQUFQLENBQVYsS0FDWEosVUFBVSxDQUFFakwsSUFBSSxDQUFDcUwsUUFBUCxDQUFWLEdBQThCLEVBRG5CLENBQWQ7O0FBR0Esa0JBQUtnQyxJQUFJLElBQUlBLElBQUksS0FBS3JOLElBQUksQ0FBQ3A5RCxRQUFMLENBQWM3RSxXQUFkLEVBQXRCLEVBQW9EO0FBQ25EaWlFLGdCQUFBQSxJQUFJLEdBQUdBLElBQUksQ0FBRTRGLEdBQUYsQ0FBSixJQUFlNUYsSUFBdEI7QUFDQSxlQUZELE1BRU8sSUFBSyxDQUFFd04sUUFBUSxHQUFHeEMsV0FBVyxDQUFFMzhDLEdBQUYsQ0FBeEIsS0FDWG0vQyxRQUFRLENBQUUsQ0FBRixDQUFSLEtBQWtCdEssT0FEUCxJQUNrQnNLLFFBQVEsQ0FBRSxDQUFGLENBQVIsS0FBa0JELFFBRHpDLEVBQ29EO0FBRTFEO0FBQ0EsdUJBQVNFLFFBQVEsQ0FBRSxDQUFGLENBQVIsR0FBZ0JELFFBQVEsQ0FBRSxDQUFGLENBQWpDO0FBQ0EsZUFMTSxNQUtBO0FBRU47QUFDQXhDLGdCQUFBQSxXQUFXLENBQUUzOEMsR0FBRixDQUFYLEdBQXFCby9DLFFBQXJCLENBSE0sQ0FLTjs7QUFDQSxvQkFBT0EsUUFBUSxDQUFFLENBQUYsQ0FBUixHQUFnQi9CLE9BQU8sQ0FBRTFMLElBQUYsRUFBUWhnRSxPQUFSLEVBQWlCK3FFLEdBQWpCLENBQTlCLEVBQXlEO0FBQ3hELHlCQUFPLElBQVA7QUFDQTtBQUNEO0FBQ0Q7QUFDRDtBQUNEOztBQUNELGVBQU8sS0FBUDtBQUNBLE9BekRGO0FBMERBOztBQUVELGFBQVMyQyxjQUFULENBQXlCQyxRQUF6QixFQUFvQztBQUNuQyxhQUFPQSxRQUFRLENBQUNyMEUsTUFBVCxHQUFrQixDQUFsQixHQUNOLFVBQVUwbUUsSUFBVixFQUFnQmhnRSxPQUFoQixFQUF5QitxRSxHQUF6QixFQUErQjtBQUM5QixZQUFJMXhFLENBQUMsR0FBR3MwRSxRQUFRLENBQUNyMEUsTUFBakI7O0FBQ0EsZUFBUUQsQ0FBQyxFQUFULEVBQWM7QUFDYixjQUFLLENBQUNzMEUsUUFBUSxDQUFFdDBFLENBQUYsQ0FBUixDQUFlMm1FLElBQWYsRUFBcUJoZ0UsT0FBckIsRUFBOEIrcUUsR0FBOUIsQ0FBTixFQUE0QztBQUMzQyxtQkFBTyxLQUFQO0FBQ0E7QUFDRDs7QUFDRCxlQUFPLElBQVA7QUFDQSxPQVRLLEdBVU40QyxRQUFRLENBQUUsQ0FBRixDQVZUO0FBV0E7O0FBRUQsYUFBU0MsZ0JBQVQsQ0FBMkJoeUIsUUFBM0IsRUFBcUNpeUIsUUFBckMsRUFBK0N0TSxPQUEvQyxFQUF5RDtBQUN4RCxVQUFJbG9FLENBQUMsR0FBRyxDQUFSO0FBQUEsVUFDQ2luRSxHQUFHLEdBQUd1TixRQUFRLENBQUN2MEUsTUFEaEI7O0FBRUEsYUFBUUQsQ0FBQyxHQUFHaW5FLEdBQVosRUFBaUJqbkUsQ0FBQyxFQUFsQixFQUF1QjtBQUN0QjRvRSxRQUFBQSxNQUFNLENBQUVybUIsUUFBRixFQUFZaXlCLFFBQVEsQ0FBRXgwRSxDQUFGLENBQXBCLEVBQTJCa29FLE9BQTNCLENBQU47QUFDQTs7QUFDRCxhQUFPQSxPQUFQO0FBQ0E7O0FBRUQsYUFBU3VNLFFBQVQsQ0FBbUJuQyxTQUFuQixFQUE4Qi96RCxHQUE5QixFQUFtQzZmLE1BQW5DLEVBQTJDejNCLE9BQTNDLEVBQW9EK3FFLEdBQXBELEVBQTBEO0FBQ3pELFVBQUkvSyxJQUFKO0FBQUEsVUFDQytOLFlBQVksR0FBRyxFQURoQjtBQUFBLFVBRUMxMEUsQ0FBQyxHQUFHLENBRkw7QUFBQSxVQUdDaW5FLEdBQUcsR0FBR3FMLFNBQVMsQ0FBQ3J5RSxNQUhqQjtBQUFBLFVBSUMwMEUsTUFBTSxHQUFHcDJELEdBQUcsSUFBSSxJQUpqQjs7QUFNQSxhQUFRdmUsQ0FBQyxHQUFHaW5FLEdBQVosRUFBaUJqbkUsQ0FBQyxFQUFsQixFQUF1QjtBQUN0QixZQUFPMm1FLElBQUksR0FBRzJMLFNBQVMsQ0FBRXR5RSxDQUFGLENBQXZCLEVBQWlDO0FBQ2hDLGNBQUssQ0FBQ28rQixNQUFELElBQVdBLE1BQU0sQ0FBRXVvQyxJQUFGLEVBQVFoZ0UsT0FBUixFQUFpQitxRSxHQUFqQixDQUF0QixFQUErQztBQUM5Q2dELFlBQUFBLFlBQVksQ0FBQ2owRSxJQUFiLENBQW1Ca21FLElBQW5COztBQUNBLGdCQUFLZ08sTUFBTCxFQUFjO0FBQ2JwMkQsY0FBQUEsR0FBRyxDQUFDOWQsSUFBSixDQUFVVCxDQUFWO0FBQ0E7QUFDRDtBQUNEO0FBQ0Q7O0FBRUQsYUFBTzAwRSxZQUFQO0FBQ0E7O0FBRUQsYUFBU0UsVUFBVCxDQUFxQjlELFNBQXJCLEVBQWdDdnVCLFFBQWhDLEVBQTBDOHZCLE9BQTFDLEVBQW1Ed0MsVUFBbkQsRUFBK0RDLFVBQS9ELEVBQTJFQyxZQUEzRSxFQUEwRjtBQUN6RixVQUFLRixVQUFVLElBQUksQ0FBQ0EsVUFBVSxDQUFFck4sT0FBRixDQUE5QixFQUE0QztBQUMzQ3FOLFFBQUFBLFVBQVUsR0FBR0QsVUFBVSxDQUFFQyxVQUFGLENBQXZCO0FBQ0E7O0FBQ0QsVUFBS0MsVUFBVSxJQUFJLENBQUNBLFVBQVUsQ0FBRXROLE9BQUYsQ0FBOUIsRUFBNEM7QUFDM0NzTixRQUFBQSxVQUFVLEdBQUdGLFVBQVUsQ0FBRUUsVUFBRixFQUFjQyxZQUFkLENBQXZCO0FBQ0E7O0FBQ0QsYUFBT3ZILFlBQVksQ0FBRSxVQUFVZCxJQUFWLEVBQWdCeEUsT0FBaEIsRUFBeUJ2aEUsT0FBekIsRUFBa0MrcUUsR0FBbEMsRUFBd0M7QUFDNUQsWUFBSW4zRCxJQUFKO0FBQUEsWUFBVXZhLENBQVY7QUFBQSxZQUFhMm1FLElBQWI7QUFBQSxZQUNDcU8sTUFBTSxHQUFHLEVBRFY7QUFBQSxZQUVDQyxPQUFPLEdBQUcsRUFGWDtBQUFBLFlBR0NDLFdBQVcsR0FBR2hOLE9BQU8sQ0FBQ2pvRSxNQUh2QjtBQUFBLFlBS0M7QUFDQXNtRSxRQUFBQSxLQUFLLEdBQUdtRyxJQUFJLElBQUk2SCxnQkFBZ0IsQ0FDL0JoeUIsUUFBUSxJQUFJLEdBRG1CLEVBRS9CNTdDLE9BQU8sQ0FBQ2xELFFBQVIsR0FBbUIsQ0FBRWtELE9BQUYsQ0FBbkIsR0FBaUNBLE9BRkYsRUFHL0IsRUFIK0IsQ0FOakM7QUFBQSxZQVlDO0FBQ0F3dUUsUUFBQUEsU0FBUyxHQUFHckUsU0FBUyxLQUFNcEUsSUFBSSxJQUFJLENBQUNucUIsUUFBZixDQUFULEdBQ1hreUIsUUFBUSxDQUFFbE8sS0FBRixFQUFTeU8sTUFBVCxFQUFpQmxFLFNBQWpCLEVBQTRCbnFFLE9BQTVCLEVBQXFDK3FFLEdBQXJDLENBREcsR0FFWG5MLEtBZkY7QUFBQSxZQWlCQzZPLFVBQVUsR0FBRy9DLE9BQU8sR0FFbkI7QUFDQXlDLFFBQUFBLFVBQVUsS0FBTXBJLElBQUksR0FBR29FLFNBQUgsR0FBZW9FLFdBQVcsSUFBSUwsVUFBeEMsQ0FBVixHQUVDO0FBQ0EsVUFIRCxHQUtDO0FBQ0EzTSxRQUFBQSxPQVRrQixHQVVuQmlOLFNBM0JGLENBRDRELENBOEI1RDs7QUFDQSxZQUFLOUMsT0FBTCxFQUFlO0FBQ2RBLFVBQUFBLE9BQU8sQ0FBRThDLFNBQUYsRUFBYUMsVUFBYixFQUF5Qnp1RSxPQUF6QixFQUFrQytxRSxHQUFsQyxDQUFQO0FBQ0EsU0FqQzJELENBbUM1RDs7O0FBQ0EsWUFBS21ELFVBQUwsRUFBa0I7QUFDakJ0NkQsVUFBQUEsSUFBSSxHQUFHazZELFFBQVEsQ0FBRVcsVUFBRixFQUFjSCxPQUFkLENBQWY7QUFDQUosVUFBQUEsVUFBVSxDQUFFdDZELElBQUYsRUFBUSxFQUFSLEVBQVk1VCxPQUFaLEVBQXFCK3FFLEdBQXJCLENBQVYsQ0FGaUIsQ0FJakI7O0FBQ0ExeEUsVUFBQUEsQ0FBQyxHQUFHdWEsSUFBSSxDQUFDdGEsTUFBVDs7QUFDQSxpQkFBUUQsQ0FBQyxFQUFULEVBQWM7QUFDYixnQkFBTzJtRSxJQUFJLEdBQUdwc0QsSUFBSSxDQUFFdmEsQ0FBRixDQUFsQixFQUE0QjtBQUMzQm8xRSxjQUFBQSxVQUFVLENBQUVILE9BQU8sQ0FBRWoxRSxDQUFGLENBQVQsQ0FBVixHQUE2QixFQUFHbTFFLFNBQVMsQ0FBRUYsT0FBTyxDQUFFajFFLENBQUYsQ0FBVCxDQUFULEdBQTRCMm1FLElBQS9CLENBQTdCO0FBQ0E7QUFDRDtBQUNEOztBQUVELFlBQUsrRixJQUFMLEVBQVk7QUFDWCxjQUFLb0ksVUFBVSxJQUFJaEUsU0FBbkIsRUFBK0I7QUFDOUIsZ0JBQUtnRSxVQUFMLEVBQWtCO0FBRWpCO0FBQ0F2NkQsY0FBQUEsSUFBSSxHQUFHLEVBQVA7QUFDQXZhLGNBQUFBLENBQUMsR0FBR28xRSxVQUFVLENBQUNuMUUsTUFBZjs7QUFDQSxxQkFBUUQsQ0FBQyxFQUFULEVBQWM7QUFDYixvQkFBTzJtRSxJQUFJLEdBQUd5TyxVQUFVLENBQUVwMUUsQ0FBRixDQUF4QixFQUFrQztBQUVqQztBQUNBdWEsa0JBQUFBLElBQUksQ0FBQzlaLElBQUwsQ0FBYTAwRSxTQUFTLENBQUVuMUUsQ0FBRixDQUFULEdBQWlCMm1FLElBQTlCO0FBQ0E7QUFDRDs7QUFDRG1PLGNBQUFBLFVBQVUsQ0FBRSxJQUFGLEVBQVVNLFVBQVUsR0FBRyxFQUF2QixFQUE2Qjc2RCxJQUE3QixFQUFtQ20zRCxHQUFuQyxDQUFWO0FBQ0EsYUFkNkIsQ0FnQjlCOzs7QUFDQTF4RSxZQUFBQSxDQUFDLEdBQUdvMUUsVUFBVSxDQUFDbjFFLE1BQWY7O0FBQ0EsbUJBQVFELENBQUMsRUFBVCxFQUFjO0FBQ2Isa0JBQUssQ0FBRTJtRSxJQUFJLEdBQUd5TyxVQUFVLENBQUVwMUUsQ0FBRixDQUFuQixLQUNKLENBQUV1YSxJQUFJLEdBQUd1NkQsVUFBVSxHQUFHcm5FLE9BQU8sQ0FBRWkvRCxJQUFGLEVBQVEvRixJQUFSLENBQVYsR0FBMkJxTyxNQUFNLENBQUVoMUUsQ0FBRixDQUFwRCxJQUE4RCxDQUFDLENBRGhFLEVBQ29FO0FBRW5FMHNFLGdCQUFBQSxJQUFJLENBQUVueUQsSUFBRixDQUFKLEdBQWUsRUFBRzJ0RCxPQUFPLENBQUUzdEQsSUFBRixDQUFQLEdBQWtCb3NELElBQXJCLENBQWY7QUFDQTtBQUNEO0FBQ0QsV0ExQlUsQ0E0Qlo7O0FBQ0MsU0E3QkQsTUE2Qk87QUFDTnlPLFVBQUFBLFVBQVUsR0FBR1gsUUFBUSxDQUNwQlcsVUFBVSxLQUFLbE4sT0FBZixHQUNDa04sVUFBVSxDQUFDcjBFLE1BQVgsQ0FBbUJtMEUsV0FBbkIsRUFBZ0NFLFVBQVUsQ0FBQ24xRSxNQUEzQyxDQURELEdBRUNtMUUsVUFIbUIsQ0FBckI7O0FBS0EsY0FBS04sVUFBTCxFQUFrQjtBQUNqQkEsWUFBQUEsVUFBVSxDQUFFLElBQUYsRUFBUTVNLE9BQVIsRUFBaUJrTixVQUFqQixFQUE2QjFELEdBQTdCLENBQVY7QUFDQSxXQUZELE1BRU87QUFDTmp4RSxZQUFBQSxJQUFJLENBQUM2RixLQUFMLENBQVk0aEUsT0FBWixFQUFxQmtOLFVBQXJCO0FBQ0E7QUFDRDtBQUNELE9BMUZrQixDQUFuQjtBQTJGQTs7QUFFRCxhQUFTQyxpQkFBVCxDQUE0QjFCLE1BQTVCLEVBQXFDO0FBQ3BDLFVBQUkyQixZQUFKO0FBQUEsVUFBa0JqRCxPQUFsQjtBQUFBLFVBQTJCN3JELENBQTNCO0FBQUEsVUFDQ3lnRCxHQUFHLEdBQUcwTSxNQUFNLENBQUMxekUsTUFEZDtBQUFBLFVBRUNzMUUsZUFBZSxHQUFHMU0sSUFBSSxDQUFDNzNDLFFBQUwsQ0FBZTJpRCxNQUFNLENBQUUsQ0FBRixDQUFOLENBQVkxMUUsSUFBM0IsQ0FGbkI7QUFBQSxVQUdDdTNFLGdCQUFnQixHQUFHRCxlQUFlLElBQUkxTSxJQUFJLENBQUM3M0MsUUFBTCxDQUFlLEdBQWYsQ0FIdkM7QUFBQSxVQUlDaHhCLENBQUMsR0FBR3UxRSxlQUFlLEdBQUcsQ0FBSCxHQUFPLENBSjNCO0FBQUEsVUFNQztBQUNBRSxNQUFBQSxZQUFZLEdBQUdwSixhQUFhLENBQUUsVUFBVTFGLElBQVYsRUFBaUI7QUFDOUMsZUFBT0EsSUFBSSxLQUFLMk8sWUFBaEI7QUFDQSxPQUYyQixFQUV6QkUsZ0JBRnlCLEVBRVAsSUFGTyxDQVA3QjtBQUFBLFVBVUNFLGVBQWUsR0FBR3JKLGFBQWEsQ0FBRSxVQUFVMUYsSUFBVixFQUFpQjtBQUNqRCxlQUFPbDVELE9BQU8sQ0FBRTZuRSxZQUFGLEVBQWdCM08sSUFBaEIsQ0FBUCxHQUFnQyxDQUFDLENBQXhDO0FBQ0EsT0FGOEIsRUFFNUI2TyxnQkFGNEIsRUFFVixJQUZVLENBVmhDO0FBQUEsVUFhQ2xCLFFBQVEsR0FBRyxDQUFFLFVBQVUzTixJQUFWLEVBQWdCaGdFLE9BQWhCLEVBQXlCK3FFLEdBQXpCLEVBQStCO0FBQzNDLFlBQUlsTCxHQUFHLEdBQUssQ0FBQytPLGVBQUQsS0FBc0I3RCxHQUFHLElBQUkvcUUsT0FBTyxLQUFLd2lFLGdCQUF6QyxDQUFGLEtBQ1QsQ0FBRW1NLFlBQVksR0FBRzN1RSxPQUFqQixFQUEyQmxELFFBQTNCLEdBQ0NneUUsWUFBWSxDQUFFOU8sSUFBRixFQUFRaGdFLE9BQVIsRUFBaUIrcUUsR0FBakIsQ0FEYixHQUVDZ0UsZUFBZSxDQUFFL08sSUFBRixFQUFRaGdFLE9BQVIsRUFBaUIrcUUsR0FBakIsQ0FIUCxDQUFWLENBRDJDLENBTTNDOztBQUNBNEQsUUFBQUEsWUFBWSxHQUFHLElBQWY7QUFDQSxlQUFPOU8sR0FBUDtBQUNBLE9BVFUsQ0FiWjs7QUF3QkEsYUFBUXhtRSxDQUFDLEdBQUdpbkUsR0FBWixFQUFpQmpuRSxDQUFDLEVBQWxCLEVBQXVCO0FBQ3RCLFlBQU9xeUUsT0FBTyxHQUFHeEosSUFBSSxDQUFDNzNDLFFBQUwsQ0FBZTJpRCxNQUFNLENBQUUzekUsQ0FBRixDQUFOLENBQVkvQixJQUEzQixDQUFqQixFQUF1RDtBQUN0RHEyRSxVQUFBQSxRQUFRLEdBQUcsQ0FBRWpJLGFBQWEsQ0FBRWdJLGNBQWMsQ0FBRUMsUUFBRixDQUFoQixFQUE4QmpDLE9BQTlCLENBQWYsQ0FBWDtBQUNBLFNBRkQsTUFFTztBQUNOQSxVQUFBQSxPQUFPLEdBQUd4SixJQUFJLENBQUN6cUMsTUFBTCxDQUFhdTFDLE1BQU0sQ0FBRTN6RSxDQUFGLENBQU4sQ0FBWS9CLElBQXpCLEVBQWdDcUksS0FBaEMsQ0FBdUMsSUFBdkMsRUFBNkNxdEUsTUFBTSxDQUFFM3pFLENBQUYsQ0FBTixDQUFZcTVCLE9BQXpELENBQVYsQ0FETSxDQUdOOztBQUNBLGNBQUtnNUMsT0FBTyxDQUFFN0ssT0FBRixDQUFaLEVBQTBCO0FBRXpCO0FBQ0FoaEQsWUFBQUEsQ0FBQyxHQUFHLEVBQUV4bUIsQ0FBTjs7QUFDQSxtQkFBUXdtQixDQUFDLEdBQUd5Z0QsR0FBWixFQUFpQnpnRCxDQUFDLEVBQWxCLEVBQXVCO0FBQ3RCLGtCQUFLcWlELElBQUksQ0FBQzczQyxRQUFMLENBQWUyaUQsTUFBTSxDQUFFbnRELENBQUYsQ0FBTixDQUFZdm9CLElBQTNCLENBQUwsRUFBeUM7QUFDeEM7QUFDQTtBQUNEOztBQUNELG1CQUFPMjJFLFVBQVUsQ0FDaEI1MEUsQ0FBQyxHQUFHLENBQUosSUFBU3EwRSxjQUFjLENBQUVDLFFBQUYsQ0FEUCxFQUVoQnQwRSxDQUFDLEdBQUcsQ0FBSixJQUFTb3RFLFVBQVUsRUFFbkI7QUFDQXVHLFlBQUFBLE1BQU0sQ0FDSjl5RCxLQURGLENBQ1MsQ0FEVCxFQUNZN2dCLENBQUMsR0FBRyxDQURoQixFQUVFK2hCLE1BRkYsQ0FFVTtBQUFFM2tCLGNBQUFBLEtBQUssRUFBRXUyRSxNQUFNLENBQUUzekUsQ0FBQyxHQUFHLENBQU4sQ0FBTixDQUFnQi9CLElBQWhCLEtBQXlCLEdBQXpCLEdBQStCLEdBQS9CLEdBQXFDO0FBQTlDLGFBRlYsQ0FIbUIsQ0FBVixDQU1QSSxPQU5PLENBTUVxc0UsS0FORixFQU1TLElBTlQsQ0FGTyxFQVNoQjJILE9BVGdCLEVBVWhCcnlFLENBQUMsR0FBR3dtQixDQUFKLElBQVM2dUQsaUJBQWlCLENBQUUxQixNQUFNLENBQUM5eUQsS0FBUCxDQUFjN2dCLENBQWQsRUFBaUJ3bUIsQ0FBakIsQ0FBRixDQVZWLEVBV2hCQSxDQUFDLEdBQUd5Z0QsR0FBSixJQUFXb08saUJBQWlCLENBQUkxQixNQUFNLEdBQUdBLE1BQU0sQ0FBQzl5RCxLQUFQLENBQWMyRixDQUFkLENBQWIsQ0FYWixFQVloQkEsQ0FBQyxHQUFHeWdELEdBQUosSUFBV21HLFVBQVUsQ0FBRXVHLE1BQUYsQ0FaTCxDQUFqQjtBQWNBOztBQUNEVyxVQUFBQSxRQUFRLENBQUM3ekUsSUFBVCxDQUFlNHhFLE9BQWY7QUFDQTtBQUNEOztBQUVELGFBQU9nQyxjQUFjLENBQUVDLFFBQUYsQ0FBckI7QUFDQTs7QUFFRCxhQUFTcUIsd0JBQVQsQ0FBbUNDLGVBQW5DLEVBQW9EQyxXQUFwRCxFQUFrRTtBQUNqRSxVQUFJQyxLQUFLLEdBQUdELFdBQVcsQ0FBQzUxRSxNQUFaLEdBQXFCLENBQWpDO0FBQUEsVUFDQzgxRSxTQUFTLEdBQUdILGVBQWUsQ0FBQzMxRSxNQUFoQixHQUF5QixDQUR0QztBQUFBLFVBRUMrMUUsWUFBWSxHQUFHLFNBQWZBLFlBQWUsQ0FBVXRKLElBQVYsRUFBZ0IvbEUsT0FBaEIsRUFBeUIrcUUsR0FBekIsRUFBOEJ4SixPQUE5QixFQUF1QytOLFNBQXZDLEVBQW1EO0FBQ2pFLFlBQUl0UCxJQUFKO0FBQUEsWUFBVW5nRCxDQUFWO0FBQUEsWUFBYTZyRCxPQUFiO0FBQUEsWUFDQzZELFlBQVksR0FBRyxDQURoQjtBQUFBLFlBRUNsMkUsQ0FBQyxHQUFHLEdBRkw7QUFBQSxZQUdDc3lFLFNBQVMsR0FBRzVGLElBQUksSUFBSSxFQUhyQjtBQUFBLFlBSUN5SixVQUFVLEdBQUcsRUFKZDtBQUFBLFlBS0NDLGFBQWEsR0FBR2pOLGdCQUxqQjtBQUFBLFlBT0M7QUFDQTVDLFFBQUFBLEtBQUssR0FBR21HLElBQUksSUFBSXFKLFNBQVMsSUFBSWxOLElBQUksQ0FBQ29HLElBQUwsQ0FBVyxLQUFYLEVBQW9CLEdBQXBCLEVBQXlCZ0gsU0FBekIsQ0FSOUI7QUFBQSxZQVVDO0FBQ0FJLFFBQUFBLGFBQWEsR0FBS3hNLE9BQU8sSUFBSXVNLGFBQWEsSUFBSSxJQUFqQixHQUF3QixDQUF4QixHQUE0Qno0RSxJQUFJLENBQUM4a0QsTUFBTCxNQUFpQixHQVgzRTtBQUFBLFlBWUN3a0IsR0FBRyxHQUFHVixLQUFLLENBQUN0bUUsTUFaYjs7QUFjQSxZQUFLZzJFLFNBQUwsRUFBaUI7QUFFaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTlNLFVBQUFBLGdCQUFnQixHQUFHeGlFLE9BQU8sSUFBSTRELFFBQVgsSUFBdUI1RCxPQUF2QixJQUFrQ3N2RSxTQUFyRDtBQUNBLFNBdEJnRSxDQXdCakU7QUFDQTtBQUNBOzs7QUFDQSxlQUFRajJFLENBQUMsS0FBS2luRSxHQUFOLElBQWEsQ0FBRU4sSUFBSSxHQUFHSixLQUFLLENBQUV2bUUsQ0FBRixDQUFkLEtBQXlCLElBQTlDLEVBQW9EQSxDQUFDLEVBQXJELEVBQTBEO0FBQ3pELGNBQUsrMUUsU0FBUyxJQUFJcFAsSUFBbEIsRUFBeUI7QUFDeEJuZ0QsWUFBQUEsQ0FBQyxHQUFHLENBQUosQ0FEd0IsQ0FHeEI7QUFDQTtBQUNBO0FBQ0E7O0FBQ0EsZ0JBQUssQ0FBQzdmLE9BQUQsSUFBWWdnRSxJQUFJLENBQUNoaEUsYUFBTCxJQUFzQjRFLFFBQXZDLEVBQWtEO0FBQ2pEKytELGNBQUFBLFdBQVcsQ0FBRTNDLElBQUYsQ0FBWDtBQUNBK0ssY0FBQUEsR0FBRyxHQUFHLENBQUNsSSxjQUFQO0FBQ0E7O0FBQ0QsbUJBQVU2SSxPQUFPLEdBQUd1RCxlQUFlLENBQUVwdkQsQ0FBQyxFQUFILENBQW5DLEVBQStDO0FBQzlDLGtCQUFLNnJELE9BQU8sQ0FBRTFMLElBQUYsRUFBUWhnRSxPQUFPLElBQUk0RCxRQUFuQixFQUE2Qm1uRSxHQUE3QixDQUFaLEVBQWlEO0FBQ2hEeEosZ0JBQUFBLE9BQU8sQ0FBQ3puRSxJQUFSLENBQWNrbUUsSUFBZDtBQUNBO0FBQ0E7QUFDRDs7QUFDRCxnQkFBS3NQLFNBQUwsRUFBaUI7QUFDaEJwTSxjQUFBQSxPQUFPLEdBQUd3TSxhQUFWO0FBQ0E7QUFDRCxXQXJCd0QsQ0F1QnpEOzs7QUFDQSxjQUFLUCxLQUFMLEVBQWE7QUFFWjtBQUNBLGdCQUFPblAsSUFBSSxHQUFHLENBQUMwTCxPQUFELElBQVkxTCxJQUExQixFQUFtQztBQUNsQ3VQLGNBQUFBLFlBQVk7QUFDWixhQUxXLENBT1o7OztBQUNBLGdCQUFLeEosSUFBTCxFQUFZO0FBQ1g0RixjQUFBQSxTQUFTLENBQUM3eEUsSUFBVixDQUFnQmttRSxJQUFoQjtBQUNBO0FBQ0Q7QUFDRCxTQS9EZ0UsQ0FpRWpFO0FBQ0E7OztBQUNBdVAsUUFBQUEsWUFBWSxJQUFJbDJFLENBQWhCLENBbkVpRSxDQXFFakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0EsWUFBSzgxRSxLQUFLLElBQUk5MUUsQ0FBQyxLQUFLazJFLFlBQXBCLEVBQW1DO0FBQ2xDMXZELFVBQUFBLENBQUMsR0FBRyxDQUFKOztBQUNBLGlCQUFVNnJELE9BQU8sR0FBR3dELFdBQVcsQ0FBRXJ2RCxDQUFDLEVBQUgsQ0FBL0IsRUFBMkM7QUFDMUM2ckQsWUFBQUEsT0FBTyxDQUFFQyxTQUFGLEVBQWE2RCxVQUFiLEVBQXlCeHZFLE9BQXpCLEVBQWtDK3FFLEdBQWxDLENBQVA7QUFDQTs7QUFFRCxjQUFLaEYsSUFBTCxFQUFZO0FBRVg7QUFDQSxnQkFBS3dKLFlBQVksR0FBRyxDQUFwQixFQUF3QjtBQUN2QixxQkFBUWwyRSxDQUFDLEVBQVQsRUFBYztBQUNiLG9CQUFLLEVBQUdzeUUsU0FBUyxDQUFFdHlFLENBQUYsQ0FBVCxJQUFrQm0yRSxVQUFVLENBQUVuMkUsQ0FBRixDQUEvQixDQUFMLEVBQThDO0FBQzdDbTJFLGtCQUFBQSxVQUFVLENBQUVuMkUsQ0FBRixDQUFWLEdBQWtCc3NCLEdBQUcsQ0FBQ3JqQixJQUFKLENBQVVpL0QsT0FBVixDQUFsQjtBQUNBO0FBQ0Q7QUFDRCxhQVRVLENBV1g7OztBQUNBaU8sWUFBQUEsVUFBVSxHQUFHMUIsUUFBUSxDQUFFMEIsVUFBRixDQUFyQjtBQUNBLFdBbkJpQyxDQXFCbEM7OztBQUNBMTFFLFVBQUFBLElBQUksQ0FBQzZGLEtBQUwsQ0FBWTRoRSxPQUFaLEVBQXFCaU8sVUFBckIsRUF0QmtDLENBd0JsQzs7QUFDQSxjQUFLRixTQUFTLElBQUksQ0FBQ3ZKLElBQWQsSUFBc0J5SixVQUFVLENBQUNsMkUsTUFBWCxHQUFvQixDQUExQyxJQUNGaTJFLFlBQVksR0FBR0wsV0FBVyxDQUFDNTFFLE1BQTdCLEdBQXdDLENBRHpDLEVBQzZDO0FBRTVDMm9FLFlBQUFBLE1BQU0sQ0FBQzJILFVBQVAsQ0FBbUJySSxPQUFuQjtBQUNBO0FBQ0QsU0ExR2dFLENBNEdqRTs7O0FBQ0EsWUFBSytOLFNBQUwsRUFBaUI7QUFDaEJwTSxVQUFBQSxPQUFPLEdBQUd3TSxhQUFWO0FBQ0FsTixVQUFBQSxnQkFBZ0IsR0FBR2lOLGFBQW5CO0FBQ0E7O0FBRUQsZUFBTzlELFNBQVA7QUFDQSxPQXJIRjs7QUF1SEEsYUFBT3dELEtBQUssR0FDWHRJLFlBQVksQ0FBRXdJLFlBQUYsQ0FERCxHQUVYQSxZQUZEO0FBR0E7O0FBRUQvTSxJQUFBQSxPQUFPLEdBQUdMLE1BQU0sQ0FBQ0ssT0FBUCxHQUFpQixVQUFVMW1CLFFBQVYsRUFBb0J4OUI7QUFBTTtBQUExQixNQUFvRDtBQUM5RSxVQUFJL2tCLENBQUo7QUFBQSxVQUNDNjFFLFdBQVcsR0FBRyxFQURmO0FBQUEsVUFFQ0QsZUFBZSxHQUFHLEVBRm5CO0FBQUEsVUFHQzlCLE1BQU0sR0FBRzVKLGFBQWEsQ0FBRTNuQixRQUFRLEdBQUcsR0FBYixDQUh2Qjs7QUFLQSxVQUFLLENBQUN1eEIsTUFBTixFQUFlO0FBRWQ7QUFDQSxZQUFLLENBQUMvdUQsS0FBTixFQUFjO0FBQ2JBLFVBQUFBLEtBQUssR0FBR2lrRCxRQUFRLENBQUV6bUIsUUFBRixDQUFoQjtBQUNBOztBQUNEdmlELFFBQUFBLENBQUMsR0FBRytrQixLQUFLLENBQUM5a0IsTUFBVjs7QUFDQSxlQUFRRCxDQUFDLEVBQVQsRUFBYztBQUNiOHpFLFVBQUFBLE1BQU0sR0FBR3VCLGlCQUFpQixDQUFFdHdELEtBQUssQ0FBRS9rQixDQUFGLENBQVAsQ0FBMUI7O0FBQ0EsY0FBSzh6RSxNQUFNLENBQUV0TSxPQUFGLENBQVgsRUFBeUI7QUFDeEJxTyxZQUFBQSxXQUFXLENBQUNwMUUsSUFBWixDQUFrQnF6RSxNQUFsQjtBQUNBLFdBRkQsTUFFTztBQUNOOEIsWUFBQUEsZUFBZSxDQUFDbjFFLElBQWhCLENBQXNCcXpFLE1BQXRCO0FBQ0E7QUFDRCxTQWRhLENBZ0JkOzs7QUFDQUEsUUFBQUEsTUFBTSxHQUFHNUosYUFBYSxDQUNyQjNuQixRQURxQixFQUVyQm96Qix3QkFBd0IsQ0FBRUMsZUFBRixFQUFtQkMsV0FBbkIsQ0FGSCxDQUF0QixDQWpCYyxDQXNCZDs7QUFDQS9CLFFBQUFBLE1BQU0sQ0FBQ3Z4QixRQUFQLEdBQWtCQSxRQUFsQjtBQUNBOztBQUNELGFBQU91eEIsTUFBUDtBQUNBLEtBaENEO0FBa0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0E1SyxJQUFBQSxNQUFNLEdBQUdOLE1BQU0sQ0FBQ00sTUFBUCxHQUFnQixVQUFVM21CLFFBQVYsRUFBb0I1N0MsT0FBcEIsRUFBNkJ1aEUsT0FBN0IsRUFBc0N3RSxJQUF0QyxFQUE2QztBQUNyRSxVQUFJMXNFLENBQUo7QUFBQSxVQUFPMnpFLE1BQVA7QUFBQSxVQUFlMkMsS0FBZjtBQUFBLFVBQXNCcjRFLElBQXRCO0FBQUEsVUFBNEJneEUsSUFBNUI7QUFBQSxVQUNDc0gsUUFBUSxHQUFHLE9BQU9oMEIsUUFBUCxLQUFvQixVQUFwQixJQUFrQ0EsUUFEOUM7QUFBQSxVQUVDeDlCLEtBQUssR0FBRyxDQUFDMm5ELElBQUQsSUFBUzFELFFBQVEsQ0FBSXptQixRQUFRLEdBQUdnMEIsUUFBUSxDQUFDaDBCLFFBQVQsSUFBcUJBLFFBQXBDLENBRjFCO0FBSUEybEIsTUFBQUEsT0FBTyxHQUFHQSxPQUFPLElBQUksRUFBckIsQ0FMcUUsQ0FPckU7QUFDQTs7QUFDQSxVQUFLbmpELEtBQUssQ0FBQzlrQixNQUFOLEtBQWlCLENBQXRCLEVBQTBCO0FBRXpCO0FBQ0EwekUsUUFBQUEsTUFBTSxHQUFHNXVELEtBQUssQ0FBRSxDQUFGLENBQUwsR0FBYUEsS0FBSyxDQUFFLENBQUYsQ0FBTCxDQUFXbEUsS0FBWCxDQUFrQixDQUFsQixDQUF0Qjs7QUFDQSxZQUFLOHlELE1BQU0sQ0FBQzF6RSxNQUFQLEdBQWdCLENBQWhCLElBQXFCLENBQUVxMkUsS0FBSyxHQUFHM0MsTUFBTSxDQUFFLENBQUYsQ0FBaEIsRUFBd0IxMUUsSUFBeEIsS0FBaUMsSUFBdEQsSUFDSjBJLE9BQU8sQ0FBQ2xELFFBQVIsS0FBcUIsQ0FEakIsSUFDc0IrbEUsY0FEdEIsSUFDd0NYLElBQUksQ0FBQzczQyxRQUFMLENBQWUyaUQsTUFBTSxDQUFFLENBQUYsQ0FBTixDQUFZMTFFLElBQTNCLENBRDdDLEVBQ2lGO0FBRWhGMEksVUFBQUEsT0FBTyxHQUFHLENBQUVraUUsSUFBSSxDQUFDb0csSUFBTCxDQUFXLElBQVgsRUFBbUJxSCxLQUFLLENBQUNqOUMsT0FBTixDQUFlLENBQWYsRUFDN0JoN0IsT0FENkIsQ0FDcEJrdEUsU0FEb0IsRUFDVEMsU0FEUyxDQUFuQixFQUN1QjdrRSxPQUR2QixLQUNvQyxFQUR0QyxFQUM0QyxDQUQ1QyxDQUFWOztBQUVBLGNBQUssQ0FBQ0EsT0FBTixFQUFnQjtBQUNmLG1CQUFPdWhFLE9BQVAsQ0FEZSxDQUdoQjtBQUNDLFdBSkQsTUFJTyxJQUFLcU8sUUFBTCxFQUFnQjtBQUN0QjV2RSxZQUFBQSxPQUFPLEdBQUdBLE9BQU8sQ0FBQ3BELFVBQWxCO0FBQ0E7O0FBRURnL0MsVUFBQUEsUUFBUSxHQUFHQSxRQUFRLENBQUMxaEMsS0FBVCxDQUFnQjh5RCxNQUFNLENBQUNoekQsS0FBUCxHQUFldmpCLEtBQWYsQ0FBcUI2QyxNQUFyQyxDQUFYO0FBQ0EsU0FsQndCLENBb0J6Qjs7O0FBQ0FELFFBQUFBLENBQUMsR0FBR2dyRSxTQUFTLENBQUUsY0FBRixDQUFULENBQTRCMWhFLElBQTVCLENBQWtDaTVDLFFBQWxDLElBQStDLENBQS9DLEdBQW1Eb3hCLE1BQU0sQ0FBQzF6RSxNQUE5RDs7QUFDQSxlQUFRRCxDQUFDLEVBQVQsRUFBYztBQUNiczJFLFVBQUFBLEtBQUssR0FBRzNDLE1BQU0sQ0FBRTN6RSxDQUFGLENBQWQsQ0FEYSxDQUdiOztBQUNBLGNBQUs2b0UsSUFBSSxDQUFDNzNDLFFBQUwsQ0FBaUIveUIsSUFBSSxHQUFHcTRFLEtBQUssQ0FBQ3I0RSxJQUE5QixDQUFMLEVBQThDO0FBQzdDO0FBQ0E7O0FBQ0QsY0FBT2d4RSxJQUFJLEdBQUdwRyxJQUFJLENBQUNvRyxJQUFMLENBQVdoeEUsSUFBWCxDQUFkLEVBQW9DO0FBRW5DO0FBQ0EsZ0JBQU95dUUsSUFBSSxHQUFHdUMsSUFBSSxDQUNqQnFILEtBQUssQ0FBQ2o5QyxPQUFOLENBQWUsQ0FBZixFQUFtQmg3QixPQUFuQixDQUE0Qmt0RSxTQUE1QixFQUF1Q0MsU0FBdkMsQ0FEaUIsRUFFakJGLFFBQVEsQ0FBQ2hpRSxJQUFULENBQWVxcUUsTUFBTSxDQUFFLENBQUYsQ0FBTixDQUFZMTFFLElBQTNCLEtBQXFDa3ZFLFdBQVcsQ0FBRXhtRSxPQUFPLENBQUNwRCxVQUFWLENBQWhELElBQ0NvRCxPQUhnQixDQUFsQixFQUlNO0FBRUw7QUFDQWd0RSxjQUFBQSxNQUFNLENBQUM1eUUsTUFBUCxDQUFlZixDQUFmLEVBQWtCLENBQWxCO0FBQ0F1aUQsY0FBQUEsUUFBUSxHQUFHbXFCLElBQUksQ0FBQ3pzRSxNQUFMLElBQWVtdEUsVUFBVSxDQUFFdUcsTUFBRixDQUFwQzs7QUFDQSxrQkFBSyxDQUFDcHhCLFFBQU4sRUFBaUI7QUFDaEI5aEQsZ0JBQUFBLElBQUksQ0FBQzZGLEtBQUwsQ0FBWTRoRSxPQUFaLEVBQXFCd0UsSUFBckI7QUFDQSx1QkFBT3hFLE9BQVA7QUFDQTs7QUFFRDtBQUNBO0FBQ0Q7QUFDRDtBQUNELE9BM0RvRSxDQTZEckU7QUFDQTs7O0FBQ0EsT0FBRXFPLFFBQVEsSUFBSXROLE9BQU8sQ0FBRTFtQixRQUFGLEVBQVl4OUIsS0FBWixDQUFyQixFQUNDMm5ELElBREQsRUFFQy9sRSxPQUZELEVBR0MsQ0FBQzZpRSxjQUhGLEVBSUN0QixPQUpELEVBS0MsQ0FBQ3ZoRSxPQUFELElBQVkya0UsUUFBUSxDQUFDaGlFLElBQVQsQ0FBZWk1QyxRQUFmLEtBQTZCNHFCLFdBQVcsQ0FBRXhtRSxPQUFPLENBQUNwRCxVQUFWLENBQXBELElBQThFb0QsT0FML0U7QUFPQSxhQUFPdWhFLE9BQVA7QUFDQSxLQXZFRCxDQWp3RXFCLENBMDBFckI7QUFFQTs7O0FBQ0E5QyxJQUFBQSxPQUFPLENBQUNzTCxVQUFSLEdBQXFCbEosT0FBTyxDQUFDcDVELEtBQVIsQ0FBZSxFQUFmLEVBQW9CODBCLElBQXBCLENBQTBCa25DLFNBQTFCLEVBQXNDMWxELElBQXRDLENBQTRDLEVBQTVDLE1BQXFEOGlELE9BQTFFLENBNzBFcUIsQ0ErMEVyQjtBQUNBOztBQUNBcEMsSUFBQUEsT0FBTyxDQUFDcUwsZ0JBQVIsR0FBMkIsQ0FBQyxDQUFDcEgsWUFBN0IsQ0FqMUVxQixDQW0xRXJCOztBQUNBQyxJQUFBQSxXQUFXLEdBcDFFVSxDQXMxRXJCO0FBQ0E7O0FBQ0FsRSxJQUFBQSxPQUFPLENBQUM0SyxZQUFSLEdBQXVCdkMsTUFBTSxDQUFFLFVBQVVoM0MsRUFBVixFQUFlO0FBRTdDO0FBQ0EsYUFBT0EsRUFBRSxDQUFDbTVDLHVCQUFILENBQTRCcmxFLFFBQVEsQ0FBQ2pNLGFBQVQsQ0FBd0IsVUFBeEIsQ0FBNUIsSUFBcUUsQ0FBNUU7QUFDQSxLQUo0QixDQUE3QixDQXgxRXFCLENBODFFckI7QUFDQTtBQUNBOztBQUNBLFFBQUssQ0FBQ212RSxNQUFNLENBQUUsVUFBVWgzQyxFQUFWLEVBQWU7QUFDNUJBLE1BQUFBLEVBQUUsQ0FBQ3hvQixTQUFILEdBQWUsa0JBQWY7QUFDQSxhQUFPd29CLEVBQUUsQ0FBQ2hzQixVQUFILENBQWNyQixZQUFkLENBQTRCLE1BQTVCLE1BQXlDLEdBQWhEO0FBQ0EsS0FIVyxDQUFaLEVBR007QUFDTHNrRSxNQUFBQSxTQUFTLENBQUUsd0JBQUYsRUFBNEIsVUFBVS9HLElBQVYsRUFBZ0IvakQsSUFBaEIsRUFBc0JtbUQsS0FBdEIsRUFBOEI7QUFDbEUsWUFBSyxDQUFDQSxLQUFOLEVBQWM7QUFDYixpQkFBT3BDLElBQUksQ0FBQ3Y5RCxZQUFMLENBQW1Cd1osSUFBbkIsRUFBeUJBLElBQUksQ0FBQ2xlLFdBQUwsT0FBdUIsTUFBdkIsR0FBZ0MsQ0FBaEMsR0FBb0MsQ0FBN0QsQ0FBUDtBQUNBO0FBQ0QsT0FKUSxDQUFUO0FBS0EsS0ExMkVvQixDQTQyRXJCO0FBQ0E7OztBQUNBLFFBQUssQ0FBQzBnRSxPQUFPLENBQUN6aUQsVUFBVCxJQUF1QixDQUFDOHFELE1BQU0sQ0FBRSxVQUFVaDNDLEVBQVYsRUFBZTtBQUNuREEsTUFBQUEsRUFBRSxDQUFDeG9CLFNBQUgsR0FBZSxVQUFmO0FBQ0F3b0IsTUFBQUEsRUFBRSxDQUFDaHNCLFVBQUgsQ0FBY3VhLFlBQWQsQ0FBNEIsT0FBNUIsRUFBcUMsRUFBckM7QUFDQSxhQUFPeVIsRUFBRSxDQUFDaHNCLFVBQUgsQ0FBY3JCLFlBQWQsQ0FBNEIsT0FBNUIsTUFBMEMsRUFBakQ7QUFDQSxLQUprQyxDQUFuQyxFQUlNO0FBQ0xza0UsTUFBQUEsU0FBUyxDQUFFLE9BQUYsRUFBVyxVQUFVL0csSUFBVixFQUFnQjZQLEtBQWhCLEVBQXVCek4sS0FBdkIsRUFBK0I7QUFDbEQsWUFBSyxDQUFDQSxLQUFELElBQVVwQyxJQUFJLENBQUNwOUQsUUFBTCxDQUFjN0UsV0FBZCxPQUFnQyxPQUEvQyxFQUF5RDtBQUN4RCxpQkFBT2lpRSxJQUFJLENBQUM4UCxZQUFaO0FBQ0E7QUFDRCxPQUpRLENBQVQ7QUFLQSxLQXgzRW9CLENBMDNFckI7QUFDQTs7O0FBQ0EsUUFBSyxDQUFDaEosTUFBTSxDQUFFLFVBQVVoM0MsRUFBVixFQUFlO0FBQzVCLGFBQU9BLEVBQUUsQ0FBQ3J0QixZQUFILENBQWlCLFVBQWpCLEtBQWlDLElBQXhDO0FBQ0EsS0FGVyxDQUFaLEVBRU07QUFDTHNrRSxNQUFBQSxTQUFTLENBQUVwRCxRQUFGLEVBQVksVUFBVTNELElBQVYsRUFBZ0IvakQsSUFBaEIsRUFBc0JtbUQsS0FBdEIsRUFBOEI7QUFDbEQsWUFBSS82RCxHQUFKOztBQUNBLFlBQUssQ0FBQys2RCxLQUFOLEVBQWM7QUFDYixpQkFBT3BDLElBQUksQ0FBRS9qRCxJQUFGLENBQUosS0FBaUIsSUFBakIsR0FBd0JBLElBQUksQ0FBQ2xlLFdBQUwsRUFBeEIsR0FDTixDQUFFc0osR0FBRyxHQUFHMjRELElBQUksQ0FBQ3VJLGdCQUFMLENBQXVCdHNELElBQXZCLENBQVIsS0FBMkM1VSxHQUFHLENBQUNxaUUsU0FBL0MsR0FDQ3JpRSxHQUFHLENBQUM1USxLQURMLEdBRUMsSUFIRjtBQUlBO0FBQ0QsT0FSUSxDQUFUO0FBU0E7O0FBRUQsV0FBT3dyRSxNQUFQO0FBRUMsR0E1NEVELENBNDRFSzVyRSxNQTU0RUwsQ0FYQTs7QUEyNUVBa3BFLEVBQUFBLE1BQU0sQ0FBQytJLElBQVAsR0FBY3JHLE1BQWQ7QUFDQTFDLEVBQUFBLE1BQU0sQ0FBQ2tLLElBQVAsR0FBY3hILE1BQU0sQ0FBQ2dJLFNBQXJCLENBLzNGaUYsQ0FpNEZqRjs7QUFDQTFLLEVBQUFBLE1BQU0sQ0FBQ2tLLElBQVAsQ0FBYSxHQUFiLElBQXFCbEssTUFBTSxDQUFDa0ssSUFBUCxDQUFZNUYsT0FBakM7QUFDQXRFLEVBQUFBLE1BQU0sQ0FBQ3FLLFVBQVAsR0FBb0JySyxNQUFNLENBQUN3USxNQUFQLEdBQWdCOU4sTUFBTSxDQUFDMkgsVUFBM0M7QUFDQXJLLEVBQUFBLE1BQU0sQ0FBQ0gsSUFBUCxHQUFjNkMsTUFBTSxDQUFDRSxPQUFyQjtBQUNBNUMsRUFBQUEsTUFBTSxDQUFDeVEsUUFBUCxHQUFrQi9OLE1BQU0sQ0FBQ0csS0FBekI7QUFDQTdDLEVBQUFBLE1BQU0sQ0FBQ3lELFFBQVAsR0FBa0JmLE1BQU0sQ0FBQ2UsUUFBekI7QUFDQXpELEVBQUFBLE1BQU0sQ0FBQzBRLGNBQVAsR0FBd0JoTyxNQUFNLENBQUM2QyxNQUEvQjs7QUFLQSxNQUFJYyxHQUFHLEdBQUcsYUFBVTVGLElBQVYsRUFBZ0I0RixJQUFoQixFQUFxQnNLLEtBQXJCLEVBQTZCO0FBQ3RDLFFBQUl6RSxPQUFPLEdBQUcsRUFBZDtBQUFBLFFBQ0MwRSxRQUFRLEdBQUdELEtBQUssS0FBS3RQLFNBRHRCOztBQUdBLFdBQVEsQ0FBRVosSUFBSSxHQUFHQSxJQUFJLENBQUU0RixJQUFGLENBQWIsS0FBMEI1RixJQUFJLENBQUNsakUsUUFBTCxLQUFrQixDQUFwRCxFQUF3RDtBQUN2RCxVQUFLa2pFLElBQUksQ0FBQ2xqRSxRQUFMLEtBQWtCLENBQXZCLEVBQTJCO0FBQzFCLFlBQUtxekUsUUFBUSxJQUFJNVEsTUFBTSxDQUFFUyxJQUFGLENBQU4sQ0FBZW9RLEVBQWYsQ0FBbUJGLEtBQW5CLENBQWpCLEVBQThDO0FBQzdDO0FBQ0E7O0FBQ0R6RSxRQUFBQSxPQUFPLENBQUMzeEUsSUFBUixDQUFja21FLElBQWQ7QUFDQTtBQUNEOztBQUNELFdBQU95TCxPQUFQO0FBQ0EsR0FiRDs7QUFnQkEsTUFBSTNPLFNBQVEsR0FBRyxTQUFYQSxRQUFXLENBQVUzdUQsQ0FBVixFQUFhNnhELElBQWIsRUFBb0I7QUFDbEMsUUFBSXlMLE9BQU8sR0FBRyxFQUFkOztBQUVBLFdBQVF0OUQsQ0FBUixFQUFXQSxDQUFDLEdBQUdBLENBQUMsQ0FBQ3pJLFdBQWpCLEVBQStCO0FBQzlCLFVBQUt5SSxDQUFDLENBQUNyUixRQUFGLEtBQWUsQ0FBZixJQUFvQnFSLENBQUMsS0FBSzZ4RCxJQUEvQixFQUFzQztBQUNyQ3lMLFFBQUFBLE9BQU8sQ0FBQzN4RSxJQUFSLENBQWNxVSxDQUFkO0FBQ0E7QUFDRDs7QUFFRCxXQUFPczlELE9BQVA7QUFDQSxHQVZEOztBQWFBLE1BQUk0RSxhQUFhLEdBQUc5USxNQUFNLENBQUNrSyxJQUFQLENBQVlyckQsS0FBWixDQUFrQmt5RCxZQUF0Qzs7QUFJQSxXQUFTMXRFLFFBQVQsQ0FBbUJvOUQsSUFBbkIsRUFBeUIvakQsSUFBekIsRUFBZ0M7QUFFL0IsV0FBTytqRCxJQUFJLENBQUNwOUQsUUFBTCxJQUFpQm85RCxJQUFJLENBQUNwOUQsUUFBTCxDQUFjN0UsV0FBZCxPQUFnQ2tlLElBQUksQ0FBQ2xlLFdBQUwsRUFBeEQ7QUFFQTs7QUFDRCxNQUFJd3lFLFVBQVUsR0FBSyxpRUFBbkIsQ0FsN0ZpRixDQXM3RmpGOztBQUNBLFdBQVNDLE1BQVQsQ0FBaUJwM0UsUUFBakIsRUFBMkJxM0UsU0FBM0IsRUFBc0NDLEdBQXRDLEVBQTRDO0FBQzNDLFFBQUtoUyxVQUFVLENBQUUrUixTQUFGLENBQWYsRUFBK0I7QUFDOUIsYUFBT2xSLE1BQU0sQ0FBQ1ksSUFBUCxDQUFhL21FLFFBQWIsRUFBdUIsVUFBVTRtRSxJQUFWLEVBQWdCM21FLENBQWhCLEVBQW9CO0FBQ2pELGVBQU8sQ0FBQyxDQUFDbzNFLFNBQVMsQ0FBQ251RSxJQUFWLENBQWdCMDlELElBQWhCLEVBQXNCM21FLENBQXRCLEVBQXlCMm1FLElBQXpCLENBQUYsS0FBc0MwUSxHQUE3QztBQUNBLE9BRk0sQ0FBUDtBQUdBLEtBTDBDLENBTzNDOzs7QUFDQSxRQUFLRCxTQUFTLENBQUMzekUsUUFBZixFQUEwQjtBQUN6QixhQUFPeWlFLE1BQU0sQ0FBQ1ksSUFBUCxDQUFhL21FLFFBQWIsRUFBdUIsVUFBVTRtRSxJQUFWLEVBQWlCO0FBQzlDLGVBQVNBLElBQUksS0FBS3lRLFNBQVgsS0FBMkJDLEdBQWxDO0FBQ0EsT0FGTSxDQUFQO0FBR0EsS0FaMEMsQ0FjM0M7OztBQUNBLFFBQUssT0FBT0QsU0FBUCxLQUFxQixRQUExQixFQUFxQztBQUNwQyxhQUFPbFIsTUFBTSxDQUFDWSxJQUFQLENBQWEvbUUsUUFBYixFQUF1QixVQUFVNG1FLElBQVYsRUFBaUI7QUFDOUMsZUFBU2w1RCxPQUFPLENBQUN4RSxJQUFSLENBQWNtdUUsU0FBZCxFQUF5QnpRLElBQXpCLElBQWtDLENBQUMsQ0FBckMsS0FBNkMwUSxHQUFwRDtBQUNBLE9BRk0sQ0FBUDtBQUdBLEtBbkIwQyxDQXFCM0M7OztBQUNBLFdBQU9uUixNQUFNLENBQUM5bkMsTUFBUCxDQUFlZzVDLFNBQWYsRUFBMEJyM0UsUUFBMUIsRUFBb0NzM0UsR0FBcEMsQ0FBUDtBQUNBOztBQUVEblIsRUFBQUEsTUFBTSxDQUFDOW5DLE1BQVAsR0FBZ0IsVUFBVWd5QyxJQUFWLEVBQWdCN0osS0FBaEIsRUFBdUI4USxHQUF2QixFQUE2QjtBQUM1QyxRQUFJMVEsSUFBSSxHQUFHSixLQUFLLENBQUUsQ0FBRixDQUFoQjs7QUFFQSxRQUFLOFEsR0FBTCxFQUFXO0FBQ1ZqSCxNQUFBQSxJQUFJLEdBQUcsVUFBVUEsSUFBVixHQUFpQixHQUF4QjtBQUNBOztBQUVELFFBQUs3SixLQUFLLENBQUN0bUUsTUFBTixLQUFpQixDQUFqQixJQUFzQjBtRSxJQUFJLENBQUNsakUsUUFBTCxLQUFrQixDQUE3QyxFQUFpRDtBQUNoRCxhQUFPeWlFLE1BQU0sQ0FBQytJLElBQVAsQ0FBWUssZUFBWixDQUE2QjNJLElBQTdCLEVBQW1DeUosSUFBbkMsSUFBNEMsQ0FBRXpKLElBQUYsQ0FBNUMsR0FBdUQsRUFBOUQ7QUFDQTs7QUFFRCxXQUFPVCxNQUFNLENBQUMrSSxJQUFQLENBQVk1MUMsT0FBWixDQUFxQisyQyxJQUFyQixFQUEyQmxLLE1BQU0sQ0FBQ1ksSUFBUCxDQUFhUCxLQUFiLEVBQW9CLFVBQVVJLElBQVYsRUFBaUI7QUFDdEUsYUFBT0EsSUFBSSxDQUFDbGpFLFFBQUwsS0FBa0IsQ0FBekI7QUFDQSxLQUZpQyxDQUEzQixDQUFQO0FBR0EsR0FkRDs7QUFnQkF5aUUsRUFBQUEsTUFBTSxDQUFDQyxFQUFQLENBQVVlLE1BQVYsQ0FBa0I7QUFDakIrSCxJQUFBQSxJQUFJLEVBQUUsY0FBVTFzQixRQUFWLEVBQXFCO0FBQzFCLFVBQUl2aUQsQ0FBSjtBQUFBLFVBQU93bUUsR0FBUDtBQUFBLFVBQ0NTLEdBQUcsR0FBRyxLQUFLaG5FLE1BRFo7QUFBQSxVQUVDakYsSUFBSSxHQUFHLElBRlI7O0FBSUEsVUFBSyxPQUFPdW5ELFFBQVAsS0FBb0IsUUFBekIsRUFBb0M7QUFDbkMsZUFBTyxLQUFLK2pCLFNBQUwsQ0FBZ0JKLE1BQU0sQ0FBRTNqQixRQUFGLENBQU4sQ0FBbUJua0IsTUFBbkIsQ0FBMkIsWUFBVztBQUM1RCxlQUFNcCtCLENBQUMsR0FBRyxDQUFWLEVBQWFBLENBQUMsR0FBR2luRSxHQUFqQixFQUFzQmpuRSxDQUFDLEVBQXZCLEVBQTRCO0FBQzNCLGdCQUFLa21FLE1BQU0sQ0FBQ3lELFFBQVAsQ0FBaUIzdUUsSUFBSSxDQUFFZ0YsQ0FBRixDQUFyQixFQUE0QixJQUE1QixDQUFMLEVBQTBDO0FBQ3pDLHFCQUFPLElBQVA7QUFDQTtBQUNEO0FBQ0QsU0FOc0IsQ0FBaEIsQ0FBUDtBQU9BOztBQUVEd21FLE1BQUFBLEdBQUcsR0FBRyxLQUFLRixTQUFMLENBQWdCLEVBQWhCLENBQU47O0FBRUEsV0FBTXRtRSxDQUFDLEdBQUcsQ0FBVixFQUFhQSxDQUFDLEdBQUdpbkUsR0FBakIsRUFBc0JqbkUsQ0FBQyxFQUF2QixFQUE0QjtBQUMzQmttRSxRQUFBQSxNQUFNLENBQUMrSSxJQUFQLENBQWExc0IsUUFBYixFQUF1QnZuRCxJQUFJLENBQUVnRixDQUFGLENBQTNCLEVBQWtDd21FLEdBQWxDO0FBQ0E7O0FBRUQsYUFBT1MsR0FBRyxHQUFHLENBQU4sR0FBVWYsTUFBTSxDQUFDcUssVUFBUCxDQUFtQi9KLEdBQW5CLENBQVYsR0FBcUNBLEdBQTVDO0FBQ0EsS0F2QmdCO0FBd0JqQnBvQyxJQUFBQSxNQUFNLEVBQUUsZ0JBQVVta0IsUUFBVixFQUFxQjtBQUM1QixhQUFPLEtBQUsrakIsU0FBTCxDQUFnQjZRLE1BQU0sQ0FBRSxJQUFGLEVBQVE1MEIsUUFBUSxJQUFJLEVBQXBCLEVBQXdCLEtBQXhCLENBQXRCLENBQVA7QUFDQSxLQTFCZ0I7QUEyQmpCODBCLElBQUFBLEdBQUcsRUFBRSxhQUFVOTBCLFFBQVYsRUFBcUI7QUFDekIsYUFBTyxLQUFLK2pCLFNBQUwsQ0FBZ0I2USxNQUFNLENBQUUsSUFBRixFQUFRNTBCLFFBQVEsSUFBSSxFQUFwQixFQUF3QixJQUF4QixDQUF0QixDQUFQO0FBQ0EsS0E3QmdCO0FBOEJqQncwQixJQUFBQSxFQUFFLEVBQUUsWUFBVXgwQixRQUFWLEVBQXFCO0FBQ3hCLGFBQU8sQ0FBQyxDQUFDNDBCLE1BQU0sQ0FDZCxJQURjLEVBR2Q7QUFDQTtBQUNBLGFBQU81MEIsUUFBUCxLQUFvQixRQUFwQixJQUFnQ3kwQixhQUFhLENBQUMxdEUsSUFBZCxDQUFvQmk1QyxRQUFwQixDQUFoQyxHQUNDMmpCLE1BQU0sQ0FBRTNqQixRQUFGLENBRFAsR0FFQ0EsUUFBUSxJQUFJLEVBUEMsRUFRZCxLQVJjLENBQU4sQ0FTUHRpRCxNQVRGO0FBVUE7QUF6Q2dCLEdBQWxCLEVBaCtGaUYsQ0E2Z0dqRjtBQUdBOztBQUNBLE1BQUlxM0UsVUFBSjtBQUFBLE1BRUM7QUFDQTtBQUNBO0FBQ0E7QUFDQWpNLEVBQUFBLFVBQVUsR0FBRyxxQ0FOZDtBQUFBLE1BUUM1M0MsSUFBSSxHQUFHeXlDLE1BQU0sQ0FBQ0MsRUFBUCxDQUFVMXlDLElBQVYsR0FBaUIsVUFBVTh1QixRQUFWLEVBQW9CNTdDLE9BQXBCLEVBQTZCNHdFLElBQTdCLEVBQW9DO0FBQzNELFFBQUl4eUQsS0FBSixFQUFXNGhELElBQVgsQ0FEMkQsQ0FHM0Q7O0FBQ0EsUUFBSyxDQUFDcGtCLFFBQU4sRUFBaUI7QUFDaEIsYUFBTyxJQUFQO0FBQ0EsS0FOMEQsQ0FRM0Q7QUFDQTs7O0FBQ0FnMUIsSUFBQUEsSUFBSSxHQUFHQSxJQUFJLElBQUlELFVBQWYsQ0FWMkQsQ0FZM0Q7O0FBQ0EsUUFBSyxPQUFPLzBCLFFBQVAsS0FBb0IsUUFBekIsRUFBb0M7QUFDbkMsVUFBS0EsUUFBUSxDQUFFLENBQUYsQ0FBUixLQUFrQixHQUFsQixJQUNKQSxRQUFRLENBQUVBLFFBQVEsQ0FBQ3RpRCxNQUFULEdBQWtCLENBQXBCLENBQVIsS0FBb0MsR0FEaEMsSUFFSnNpRCxRQUFRLENBQUN0aUQsTUFBVCxJQUFtQixDQUZwQixFQUV3QjtBQUV2QjtBQUNBOGtCLFFBQUFBLEtBQUssR0FBRyxDQUFFLElBQUYsRUFBUXc5QixRQUFSLEVBQWtCLElBQWxCLENBQVI7QUFFQSxPQVBELE1BT087QUFDTng5QixRQUFBQSxLQUFLLEdBQUdzbUQsVUFBVSxDQUFDenBCLElBQVgsQ0FBaUJXLFFBQWpCLENBQVI7QUFDQSxPQVZrQyxDQVluQzs7O0FBQ0EsVUFBS3g5QixLQUFLLEtBQU1BLEtBQUssQ0FBRSxDQUFGLENBQUwsSUFBYyxDQUFDcGUsT0FBckIsQ0FBVixFQUEyQztBQUUxQztBQUNBLFlBQUtvZSxLQUFLLENBQUUsQ0FBRixDQUFWLEVBQWtCO0FBQ2pCcGUsVUFBQUEsT0FBTyxHQUFHQSxPQUFPLFlBQVl1L0QsTUFBbkIsR0FBNEJ2L0QsT0FBTyxDQUFFLENBQUYsQ0FBbkMsR0FBMkNBLE9BQXJELENBRGlCLENBR2pCO0FBQ0E7O0FBQ0F1L0QsVUFBQUEsTUFBTSxDQUFDTyxLQUFQLENBQWMsSUFBZCxFQUFvQlAsTUFBTSxDQUFDc1IsU0FBUCxDQUNuQnp5RCxLQUFLLENBQUUsQ0FBRixDQURjLEVBRW5CcGUsT0FBTyxJQUFJQSxPQUFPLENBQUNsRCxRQUFuQixHQUE4QmtELE9BQU8sQ0FBQ2hCLGFBQVIsSUFBeUJnQixPQUF2RCxHQUFpRTRELFFBRjlDLEVBR25CLElBSG1CLENBQXBCLEVBTGlCLENBV2pCOztBQUNBLGNBQUsyc0UsVUFBVSxDQUFDNXRFLElBQVgsQ0FBaUJ5YixLQUFLLENBQUUsQ0FBRixDQUF0QixLQUFpQ21oRCxNQUFNLENBQUNvQixhQUFQLENBQXNCM2dFLE9BQXRCLENBQXRDLEVBQXdFO0FBQ3ZFLGlCQUFNb2UsS0FBTixJQUFlcGUsT0FBZixFQUF5QjtBQUV4QjtBQUNBLGtCQUFLMCtELFVBQVUsQ0FBRSxLQUFNdGdELEtBQU4sQ0FBRixDQUFmLEVBQW1DO0FBQ2xDLHFCQUFNQSxLQUFOLEVBQWVwZSxPQUFPLENBQUVvZSxLQUFGLENBQXRCLEVBRGtDLENBR25DO0FBQ0MsZUFKRCxNQUlPO0FBQ04scUJBQUtyQyxJQUFMLENBQVdxQyxLQUFYLEVBQWtCcGUsT0FBTyxDQUFFb2UsS0FBRixDQUF6QjtBQUNBO0FBQ0Q7QUFDRDs7QUFFRCxpQkFBTyxJQUFQLENBMUJpQixDQTRCbEI7QUFDQyxTQTdCRCxNQTZCTztBQUNONGhELFVBQUFBLElBQUksR0FBR3A4RCxRQUFRLENBQUN3aUUsY0FBVCxDQUF5QmhvRCxLQUFLLENBQUUsQ0FBRixDQUE5QixDQUFQOztBQUVBLGNBQUs0aEQsSUFBTCxFQUFZO0FBRVg7QUFDQSxpQkFBTSxDQUFOLElBQVlBLElBQVo7QUFDQSxpQkFBSzFtRSxNQUFMLEdBQWMsQ0FBZDtBQUNBOztBQUNELGlCQUFPLElBQVA7QUFDQSxTQTFDeUMsQ0E0QzNDOztBQUNDLE9BN0NELE1BNkNPLElBQUssQ0FBQzBHLE9BQUQsSUFBWUEsT0FBTyxDQUFDeS9ELE1BQXpCLEVBQWtDO0FBQ3hDLGVBQU8sQ0FBRXovRCxPQUFPLElBQUk0d0UsSUFBYixFQUFvQnRJLElBQXBCLENBQTBCMXNCLFFBQTFCLENBQVAsQ0FEd0MsQ0FHekM7QUFDQTtBQUNDLE9BTE0sTUFLQTtBQUNOLGVBQU8sS0FBSy9tRCxXQUFMLENBQWtCbUwsT0FBbEIsRUFBNEJzb0UsSUFBNUIsQ0FBa0Mxc0IsUUFBbEMsQ0FBUDtBQUNBLE9BakVrQyxDQW1FcEM7O0FBQ0MsS0FwRUQsTUFvRU8sSUFBS0EsUUFBUSxDQUFDOStDLFFBQWQsRUFBeUI7QUFDL0IsV0FBTSxDQUFOLElBQVk4K0MsUUFBWjtBQUNBLFdBQUt0aUQsTUFBTCxHQUFjLENBQWQ7QUFDQSxhQUFPLElBQVAsQ0FIK0IsQ0FLaEM7QUFDQTtBQUNDLEtBUE0sTUFPQSxJQUFLb2xFLFVBQVUsQ0FBRTlpQixRQUFGLENBQWYsRUFBOEI7QUFDcEMsYUFBT2cxQixJQUFJLENBQUNFLEtBQUwsS0FBZWxRLFNBQWYsR0FDTmdRLElBQUksQ0FBQ0UsS0FBTCxDQUFZbDFCLFFBQVosQ0FETSxHQUdOO0FBQ0FBLE1BQUFBLFFBQVEsQ0FBRTJqQixNQUFGLENBSlQ7QUFLQTs7QUFFRCxXQUFPQSxNQUFNLENBQUMrQixTQUFQLENBQWtCMWxCLFFBQWxCLEVBQTRCLElBQTVCLENBQVA7QUFDQSxHQXpHRixDQWpoR2lGLENBNG5HakY7OztBQUNBOXVCLEVBQUFBLElBQUksQ0FBQ3A0QixTQUFMLEdBQWlCNnFFLE1BQU0sQ0FBQ0MsRUFBeEIsQ0E3bkdpRixDQStuR2pGOztBQUNBbVIsRUFBQUEsVUFBVSxHQUFHcFIsTUFBTSxDQUFFMzdELFFBQUYsQ0FBbkI7QUFHQSxNQUFJbXRFLFlBQVksR0FBRyxnQ0FBbkI7QUFBQSxNQUVDO0FBQ0FDLEVBQUFBLGdCQUFnQixHQUFHO0FBQ2xCejNFLElBQUFBLFFBQVEsRUFBRSxJQURRO0FBRWxCMDNFLElBQUFBLFFBQVEsRUFBRSxJQUZRO0FBR2xCdm5DLElBQUFBLElBQUksRUFBRSxJQUhZO0FBSWxCeU0sSUFBQUEsSUFBSSxFQUFFO0FBSlksR0FIcEI7QUFVQW9wQixFQUFBQSxNQUFNLENBQUNDLEVBQVAsQ0FBVWUsTUFBVixDQUFrQjtBQUNqQjJRLElBQUFBLEdBQUcsRUFBRSxhQUFVcDFFLE1BQVYsRUFBbUI7QUFDdkIsVUFBSTZiLE9BQU8sR0FBRzRuRCxNQUFNLENBQUV6akUsTUFBRixFQUFVLElBQVYsQ0FBcEI7QUFBQSxVQUNDc0csQ0FBQyxHQUFHdVYsT0FBTyxDQUFDcmUsTUFEYjtBQUdBLGFBQU8sS0FBS20rQixNQUFMLENBQWEsWUFBVztBQUM5QixZQUFJcCtCLENBQUMsR0FBRyxDQUFSOztBQUNBLGVBQVFBLENBQUMsR0FBRytJLENBQVosRUFBZS9JLENBQUMsRUFBaEIsRUFBcUI7QUFDcEIsY0FBS2ttRSxNQUFNLENBQUN5RCxRQUFQLENBQWlCLElBQWpCLEVBQXVCcnJELE9BQU8sQ0FBRXRlLENBQUYsQ0FBOUIsQ0FBTCxFQUE2QztBQUM1QyxtQkFBTyxJQUFQO0FBQ0E7QUFDRDtBQUNELE9BUE0sQ0FBUDtBQVFBLEtBYmdCO0FBZWpCZ1YsSUFBQUEsT0FBTyxFQUFFLGlCQUFVNDdELFNBQVYsRUFBcUJqcUUsT0FBckIsRUFBK0I7QUFDdkMsVUFBSW1uRSxHQUFKO0FBQUEsVUFDQzl0RSxDQUFDLEdBQUcsQ0FETDtBQUFBLFVBRUMrSSxDQUFDLEdBQUcsS0FBSzlJLE1BRlY7QUFBQSxVQUdDbXlFLE9BQU8sR0FBRyxFQUhYO0FBQUEsVUFJQzl6RCxPQUFPLEdBQUcsT0FBT3N5RCxTQUFQLEtBQXFCLFFBQXJCLElBQWlDMUssTUFBTSxDQUFFMEssU0FBRixDQUpsRCxDQUR1QyxDQU92Qzs7QUFDQSxVQUFLLENBQUNvRyxhQUFhLENBQUMxdEUsSUFBZCxDQUFvQnNuRSxTQUFwQixDQUFOLEVBQXdDO0FBQ3ZDLGVBQVE1d0UsQ0FBQyxHQUFHK0ksQ0FBWixFQUFlL0ksQ0FBQyxFQUFoQixFQUFxQjtBQUNwQixlQUFNOHRFLEdBQUcsR0FBRyxLQUFNOXRFLENBQU4sQ0FBWixFQUF1Qjh0RSxHQUFHLElBQUlBLEdBQUcsS0FBS25uRSxPQUF0QyxFQUErQ21uRSxHQUFHLEdBQUdBLEdBQUcsQ0FBQ3ZxRSxVQUF6RCxFQUFzRTtBQUVyRTtBQUNBLGdCQUFLdXFFLEdBQUcsQ0FBQ3JxRSxRQUFKLEdBQWUsRUFBZixLQUF1QjZhLE9BQU8sR0FDbENBLE9BQU8sQ0FBQ3VELEtBQVIsQ0FBZWlzRCxHQUFmLElBQXVCLENBQUMsQ0FEVSxHQUdsQztBQUNBQSxZQUFBQSxHQUFHLENBQUNycUUsUUFBSixLQUFpQixDQUFqQixJQUNDeWlFLE1BQU0sQ0FBQytJLElBQVAsQ0FBWUssZUFBWixDQUE2QnhCLEdBQTdCLEVBQWtDOEMsU0FBbEMsQ0FMRyxDQUFMLEVBS29EO0FBRW5Ed0IsY0FBQUEsT0FBTyxDQUFDM3hFLElBQVIsQ0FBY3F0RSxHQUFkO0FBQ0E7QUFDQTtBQUNEO0FBQ0Q7QUFDRDs7QUFFRCxhQUFPLEtBQUt4SCxTQUFMLENBQWdCOEwsT0FBTyxDQUFDbnlFLE1BQVIsR0FBaUIsQ0FBakIsR0FBcUJpbUUsTUFBTSxDQUFDcUssVUFBUCxDQUFtQjZCLE9BQW5CLENBQXJCLEdBQW9EQSxPQUFwRSxDQUFQO0FBQ0EsS0EzQ2dCO0FBNkNqQjtBQUNBdndELElBQUFBLEtBQUssRUFBRSxlQUFVOGtELElBQVYsRUFBaUI7QUFFdkI7QUFDQSxVQUFLLENBQUNBLElBQU4sRUFBYTtBQUNaLGVBQVMsS0FBTSxDQUFOLEtBQWEsS0FBTSxDQUFOLEVBQVVwakUsVUFBekIsR0FBd0MsS0FBS2tyQixLQUFMLEdBQWFxcEQsT0FBYixHQUF1QjczRSxNQUEvRCxHQUF3RSxDQUFDLENBQWhGO0FBQ0EsT0FMc0IsQ0FPdkI7OztBQUNBLFVBQUssT0FBTzBtRSxJQUFQLEtBQWdCLFFBQXJCLEVBQWdDO0FBQy9CLGVBQU9sNUQsT0FBTyxDQUFDeEUsSUFBUixDQUFjaTlELE1BQU0sQ0FBRVMsSUFBRixDQUFwQixFQUE4QixLQUFNLENBQU4sQ0FBOUIsQ0FBUDtBQUNBLE9BVnNCLENBWXZCOzs7QUFDQSxhQUFPbDVELE9BQU8sQ0FBQ3hFLElBQVIsQ0FBYyxJQUFkLEVBRU47QUFDQTA5RCxNQUFBQSxJQUFJLENBQUNQLE1BQUwsR0FBY08sSUFBSSxDQUFFLENBQUYsQ0FBbEIsR0FBMEJBLElBSHBCLENBQVA7QUFLQSxLQWhFZ0I7QUFrRWpCaG1FLElBQUFBLEdBQUcsRUFBRSxhQUFVNGhELFFBQVYsRUFBb0I1N0MsT0FBcEIsRUFBOEI7QUFDbEMsYUFBTyxLQUFLMi9ELFNBQUwsQ0FDTkosTUFBTSxDQUFDcUssVUFBUCxDQUNDckssTUFBTSxDQUFDTyxLQUFQLENBQWMsS0FBS2w0RCxHQUFMLEVBQWQsRUFBMEIyM0QsTUFBTSxDQUFFM2pCLFFBQUYsRUFBWTU3QyxPQUFaLENBQWhDLENBREQsQ0FETSxDQUFQO0FBS0EsS0F4RWdCO0FBMEVqQm94RSxJQUFBQSxPQUFPLEVBQUUsaUJBQVV4MUIsUUFBVixFQUFxQjtBQUM3QixhQUFPLEtBQUs1aEQsR0FBTCxDQUFVNGhELFFBQVEsSUFBSSxJQUFaLEdBQ2hCLEtBQUtta0IsVUFEVyxHQUNFLEtBQUtBLFVBQUwsQ0FBZ0J0b0MsTUFBaEIsQ0FBd0Jta0IsUUFBeEIsQ0FEWixDQUFQO0FBR0E7QUE5RWdCLEdBQWxCOztBQWlGQSxXQUFTeTFCLE9BQVQsQ0FBa0JsSyxHQUFsQixFQUF1QnZCLEdBQXZCLEVBQTZCO0FBQzVCLFdBQVEsQ0FBRXVCLEdBQUcsR0FBR0EsR0FBRyxDQUFFdkIsR0FBRixDQUFYLEtBQXdCdUIsR0FBRyxDQUFDcnFFLFFBQUosS0FBaUIsQ0FBakQsRUFBcUQsQ0FBRTs7QUFDdkQsV0FBT3FxRSxHQUFQO0FBQ0E7O0FBRUQ1SCxFQUFBQSxNQUFNLENBQUN2akIsSUFBUCxDQUFhO0FBQ1o1MEMsSUFBQUEsTUFBTSxFQUFFLGdCQUFVNDRELElBQVYsRUFBaUI7QUFDeEIsVUFBSTU0RCxNQUFNLEdBQUc0NEQsSUFBSSxDQUFDcGpFLFVBQWxCO0FBQ0EsYUFBT3dLLE1BQU0sSUFBSUEsTUFBTSxDQUFDdEssUUFBUCxLQUFvQixFQUE5QixHQUFtQ3NLLE1BQW5DLEdBQTRDLElBQW5EO0FBQ0EsS0FKVztBQUtaa3FFLElBQUFBLE9BQU8sRUFBRSxpQkFBVXRSLElBQVYsRUFBaUI7QUFDekIsYUFBTzRGLEdBQUcsQ0FBRTVGLElBQUYsRUFBUSxZQUFSLENBQVY7QUFDQSxLQVBXO0FBUVp1UixJQUFBQSxZQUFZLEVBQUUsc0JBQVV2UixJQUFWLEVBQWdCOW5DLEVBQWhCLEVBQW9CZzRDLEtBQXBCLEVBQTRCO0FBQ3pDLGFBQU90SyxHQUFHLENBQUU1RixJQUFGLEVBQVEsWUFBUixFQUFzQmtRLEtBQXRCLENBQVY7QUFDQSxLQVZXO0FBV1p4bUMsSUFBQUEsSUFBSSxFQUFFLGNBQVVzMkIsSUFBVixFQUFpQjtBQUN0QixhQUFPcVIsT0FBTyxDQUFFclIsSUFBRixFQUFRLGFBQVIsQ0FBZDtBQUNBLEtBYlc7QUFjWjdwQixJQUFBQSxJQUFJLEVBQUUsY0FBVTZwQixJQUFWLEVBQWlCO0FBQ3RCLGFBQU9xUixPQUFPLENBQUVyUixJQUFGLEVBQVEsaUJBQVIsQ0FBZDtBQUNBLEtBaEJXO0FBaUJad1IsSUFBQUEsT0FBTyxFQUFFLGlCQUFVeFIsSUFBVixFQUFpQjtBQUN6QixhQUFPNEYsR0FBRyxDQUFFNUYsSUFBRixFQUFRLGFBQVIsQ0FBVjtBQUNBLEtBbkJXO0FBb0JabVIsSUFBQUEsT0FBTyxFQUFFLGlCQUFVblIsSUFBVixFQUFpQjtBQUN6QixhQUFPNEYsR0FBRyxDQUFFNUYsSUFBRixFQUFRLGlCQUFSLENBQVY7QUFDQSxLQXRCVztBQXVCWnlSLElBQUFBLFNBQVMsRUFBRSxtQkFBVXpSLElBQVYsRUFBZ0I5bkMsRUFBaEIsRUFBb0JnNEMsS0FBcEIsRUFBNEI7QUFDdEMsYUFBT3RLLEdBQUcsQ0FBRTVGLElBQUYsRUFBUSxhQUFSLEVBQXVCa1EsS0FBdkIsQ0FBVjtBQUNBLEtBekJXO0FBMEJad0IsSUFBQUEsU0FBUyxFQUFFLG1CQUFVMVIsSUFBVixFQUFnQjluQyxFQUFoQixFQUFvQmc0QyxLQUFwQixFQUE0QjtBQUN0QyxhQUFPdEssR0FBRyxDQUFFNUYsSUFBRixFQUFRLGlCQUFSLEVBQTJCa1EsS0FBM0IsQ0FBVjtBQUNBLEtBNUJXO0FBNkJacFQsSUFBQUEsUUFBUSxFQUFFLGtCQUFVa0QsSUFBVixFQUFpQjtBQUMxQixhQUFPbEQsU0FBUSxDQUFFLENBQUVrRCxJQUFJLENBQUNwakUsVUFBTCxJQUFtQixFQUFyQixFQUEwQmtILFVBQTVCLEVBQXdDazhELElBQXhDLENBQWY7QUFDQSxLQS9CVztBQWdDWnptRSxJQUFBQSxRQUFRLEVBQUUsa0JBQVV5bUUsSUFBVixFQUFpQjtBQUMxQixhQUFPbEQsU0FBUSxDQUFFa0QsSUFBSSxDQUFDbDhELFVBQVAsQ0FBZjtBQUNBLEtBbENXO0FBbUNabXRFLElBQUFBLFFBQVEsRUFBRSxrQkFBVWpSLElBQVYsRUFBaUI7QUFDMUIsVUFBS0EsSUFBSSxDQUFDMlIsZUFBTCxJQUF3QixJQUF4QixJQUVKO0FBQ0E7QUFDQTtBQUNBNVQsTUFBQUEsUUFBUSxDQUFFaUMsSUFBSSxDQUFDMlIsZUFBUCxDQUxULEVBS29DO0FBRW5DLGVBQU8zUixJQUFJLENBQUMyUixlQUFaO0FBQ0EsT0FUeUIsQ0FXMUI7QUFDQTtBQUNBOzs7QUFDQSxVQUFLL3VFLFFBQVEsQ0FBRW85RCxJQUFGLEVBQVEsVUFBUixDQUFiLEVBQW9DO0FBQ25DQSxRQUFBQSxJQUFJLEdBQUdBLElBQUksQ0FBQ3I4RCxPQUFMLElBQWdCcThELElBQXZCO0FBQ0E7O0FBRUQsYUFBT1QsTUFBTSxDQUFDTyxLQUFQLENBQWMsRUFBZCxFQUFrQkUsSUFBSSxDQUFDNkYsVUFBdkIsQ0FBUDtBQUNBO0FBdERXLEdBQWIsRUF1REcsVUFBVTVwRCxJQUFWLEVBQWdCdWpELEVBQWhCLEVBQXFCO0FBQ3ZCRCxJQUFBQSxNQUFNLENBQUNDLEVBQVAsQ0FBV3ZqRCxJQUFYLElBQW9CLFVBQVVpMEQsS0FBVixFQUFpQnQwQixRQUFqQixFQUE0QjtBQUMvQyxVQUFJNnZCLE9BQU8sR0FBR2xNLE1BQU0sQ0FBQzNuRCxHQUFQLENBQVksSUFBWixFQUFrQjRuRCxFQUFsQixFQUFzQjBRLEtBQXRCLENBQWQ7O0FBRUEsVUFBS2owRCxJQUFJLENBQUMvQixLQUFMLENBQVksQ0FBQyxDQUFiLE1BQXFCLE9BQTFCLEVBQW9DO0FBQ25DMGhDLFFBQUFBLFFBQVEsR0FBR3MwQixLQUFYO0FBQ0E7O0FBRUQsVUFBS3QwQixRQUFRLElBQUksT0FBT0EsUUFBUCxLQUFvQixRQUFyQyxFQUFnRDtBQUMvQzZ2QixRQUFBQSxPQUFPLEdBQUdsTSxNQUFNLENBQUM5bkMsTUFBUCxDQUFlbWtCLFFBQWYsRUFBeUI2dkIsT0FBekIsQ0FBVjtBQUNBOztBQUVELFVBQUssS0FBS255RSxNQUFMLEdBQWMsQ0FBbkIsRUFBdUI7QUFFdEI7QUFDQSxZQUFLLENBQUMwM0UsZ0JBQWdCLENBQUUvMEQsSUFBRixDQUF0QixFQUFpQztBQUNoQ3NqRCxVQUFBQSxNQUFNLENBQUNxSyxVQUFQLENBQW1CNkIsT0FBbkI7QUFDQSxTQUxxQixDQU90Qjs7O0FBQ0EsWUFBS3NGLFlBQVksQ0FBQ3B1RSxJQUFiLENBQW1Cc1osSUFBbkIsQ0FBTCxFQUFpQztBQUNoQ3d2RCxVQUFBQSxPQUFPLENBQUNseEQsT0FBUjtBQUNBO0FBQ0Q7O0FBRUQsYUFBTyxLQUFLb2xELFNBQUwsQ0FBZ0I4TCxPQUFoQixDQUFQO0FBQ0EsS0F6QkQ7QUEwQkEsR0FsRkQ7QUFtRkEsTUFBSW1HLGFBQWEsR0FBSyxtQkFBdEIsQ0F0ekdpRixDQTB6R2pGOztBQUNBLFdBQVNDLGFBQVQsQ0FBd0JyUixPQUF4QixFQUFrQztBQUNqQyxRQUFJc1IsTUFBTSxHQUFHLEVBQWI7QUFDQXZTLElBQUFBLE1BQU0sQ0FBQ3ZqQixJQUFQLENBQWF3a0IsT0FBTyxDQUFDcGlELEtBQVIsQ0FBZXd6RCxhQUFmLEtBQWtDLEVBQS9DLEVBQW1ELFVBQVVHLENBQVYsRUFBYUMsSUFBYixFQUFvQjtBQUN0RUYsTUFBQUEsTUFBTSxDQUFFRSxJQUFGLENBQU4sR0FBaUIsSUFBakI7QUFDQSxLQUZEO0FBR0EsV0FBT0YsTUFBUDtBQUNBO0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBdlMsRUFBQUEsTUFBTSxDQUFDMFMsU0FBUCxHQUFtQixVQUFVelIsT0FBVixFQUFvQjtBQUV0QztBQUNBO0FBQ0FBLElBQUFBLE9BQU8sR0FBRyxPQUFPQSxPQUFQLEtBQW1CLFFBQW5CLEdBQ1RxUixhQUFhLENBQUVyUixPQUFGLENBREosR0FFVGpCLE1BQU0sQ0FBQ2dCLE1BQVAsQ0FBZSxFQUFmLEVBQW1CQyxPQUFuQixDQUZEOztBQUlBLFFBQUk7QUFDSDBSLElBQUFBLE1BREQ7QUFBQSxRQUdDO0FBQ0FDLElBQUFBLE1BSkQ7QUFBQSxRQU1DO0FBQ0FDLElBQUFBLE1BUEQ7QUFBQSxRQVNDO0FBQ0F0OUMsSUFBQUEsT0FWRDtBQUFBLFFBWUM7QUFDQXI1QixJQUFBQSxJQUFJLEdBQUcsRUFiUjtBQUFBLFFBZUM7QUFDQTQyRSxJQUFBQSxLQUFLLEdBQUcsRUFoQlQ7QUFBQSxRQWtCQztBQUNBQyxJQUFBQSxXQUFXLEdBQUcsQ0FBQyxDQW5CaEI7QUFBQSxRQXFCQztBQUNBQyxJQUFBQSxJQUFJLEdBQUcsU0FBUEEsSUFBTyxHQUFXO0FBRWpCO0FBQ0F6OUMsTUFBQUEsT0FBTSxHQUFHQSxPQUFNLElBQUkwckMsT0FBTyxDQUFDajhCLElBQTNCLENBSGlCLENBS2pCO0FBQ0E7O0FBQ0E2dEMsTUFBQUEsTUFBSyxHQUFHRixNQUFNLEdBQUcsSUFBakI7O0FBQ0EsYUFBUUcsS0FBSyxDQUFDLzRFLE1BQWQsRUFBc0JnNUUsV0FBVyxHQUFHLENBQUMsQ0FBckMsRUFBeUM7QUFDeENILFFBQUFBLE1BQU0sR0FBR0UsS0FBSyxDQUFDcjRELEtBQU4sRUFBVDs7QUFDQSxlQUFRLEVBQUVzNEQsV0FBRixHQUFnQjcyRSxJQUFJLENBQUNuQyxNQUE3QixFQUFzQztBQUVyQztBQUNBLGNBQUttQyxJQUFJLENBQUU2MkUsV0FBRixDQUFKLENBQW9CM3lFLEtBQXBCLENBQTJCd3lFLE1BQU0sQ0FBRSxDQUFGLENBQWpDLEVBQXdDQSxNQUFNLENBQUUsQ0FBRixDQUE5QyxNQUEwRCxLQUExRCxJQUNKM1IsT0FBTyxDQUFDZ1MsV0FEVCxFQUN1QjtBQUV0QjtBQUNBRixZQUFBQSxXQUFXLEdBQUc3MkUsSUFBSSxDQUFDbkMsTUFBbkI7QUFDQTY0RSxZQUFBQSxNQUFNLEdBQUcsS0FBVDtBQUNBO0FBQ0Q7QUFDRCxPQXJCZ0IsQ0F1QmpCOzs7QUFDQSxVQUFLLENBQUMzUixPQUFPLENBQUMyUixNQUFkLEVBQXVCO0FBQ3RCQSxRQUFBQSxNQUFNLEdBQUcsS0FBVDtBQUNBOztBQUVERCxNQUFBQSxNQUFNLEdBQUcsS0FBVCxDQTVCaUIsQ0E4QmpCOztBQUNBLFVBQUtwOUMsT0FBTCxFQUFjO0FBRWI7QUFDQSxZQUFLcTlDLE1BQUwsRUFBYztBQUNiMTJFLFVBQUFBLElBQUksR0FBRyxFQUFQLENBRGEsQ0FHZDtBQUNDLFNBSkQsTUFJTztBQUNOQSxVQUFBQSxJQUFJLEdBQUcsRUFBUDtBQUNBO0FBQ0Q7QUFDRCxLQWhFRjtBQUFBLFFBa0VDO0FBQ0FwSCxJQUFBQSxJQUFJLEdBQUc7QUFFTjtBQUNBMkYsTUFBQUEsR0FBRyxFQUFFLGVBQVc7QUFDZixZQUFLeUIsSUFBTCxFQUFZO0FBRVg7QUFDQSxjQUFLMDJFLE1BQU0sSUFBSSxDQUFDRCxNQUFoQixFQUF5QjtBQUN4QkksWUFBQUEsV0FBVyxHQUFHNzJFLElBQUksQ0FBQ25DLE1BQUwsR0FBYyxDQUE1QjtBQUNBKzRFLFlBQUFBLEtBQUssQ0FBQ3Y0RSxJQUFOLENBQVlxNEUsTUFBWjtBQUNBOztBQUVELFdBQUUsU0FBU240RSxHQUFULENBQWN5MkQsSUFBZCxFQUFxQjtBQUN0QjhPLFlBQUFBLE1BQU0sQ0FBQ3ZqQixJQUFQLENBQWF5VSxJQUFiLEVBQW1CLFVBQVVzaEIsQ0FBVixFQUFhbFEsR0FBYixFQUFtQjtBQUNyQyxrQkFBS25ELFVBQVUsQ0FBRW1ELEdBQUYsQ0FBZixFQUF5QjtBQUN4QixvQkFBSyxDQUFDckIsT0FBTyxDQUFDdVAsTUFBVCxJQUFtQixDQUFDMTdFLElBQUksQ0FBQzY4RSxHQUFMLENBQVVyUCxHQUFWLENBQXpCLEVBQTJDO0FBQzFDcG1FLGtCQUFBQSxJQUFJLENBQUMzQixJQUFMLENBQVcrbkUsR0FBWDtBQUNBO0FBQ0QsZUFKRCxNQUlPLElBQUtBLEdBQUcsSUFBSUEsR0FBRyxDQUFDdm9FLE1BQVgsSUFBcUJnbUUsTUFBTSxDQUFFdUMsR0FBRixDQUFOLEtBQWtCLFFBQTVDLEVBQXVEO0FBRTdEO0FBQ0E3bkUsZ0JBQUFBLEdBQUcsQ0FBRTZuRSxHQUFGLENBQUg7QUFDQTtBQUNELGFBVkQ7QUFXQSxXQVpELEVBWUs3OEQsU0FaTDs7QUFjQSxjQUFLbXRFLE1BQU0sSUFBSSxDQUFDRCxNQUFoQixFQUF5QjtBQUN4QkssWUFBQUEsSUFBSTtBQUNKO0FBQ0Q7O0FBQ0QsZUFBTyxJQUFQO0FBQ0EsT0EvQks7QUFpQ047QUFDQXI0RSxNQUFBQSxNQUFNLEVBQUUsa0JBQVc7QUFDbEJxbEUsUUFBQUEsTUFBTSxDQUFDdmpCLElBQVAsQ0FBYWgzQyxTQUFiLEVBQXdCLFVBQVUrc0UsQ0FBVixFQUFhbFEsR0FBYixFQUFtQjtBQUMxQyxjQUFJM21ELEtBQUo7O0FBQ0EsaUJBQVEsQ0FBRUEsS0FBSyxHQUFHcWtELE1BQU0sQ0FBQ2lDLE9BQVAsQ0FBZ0JLLEdBQWhCLEVBQXFCcG1FLElBQXJCLEVBQTJCeWYsS0FBM0IsQ0FBVixJQUFpRCxDQUFDLENBQTFELEVBQThEO0FBQzdEemYsWUFBQUEsSUFBSSxDQUFDckIsTUFBTCxDQUFhOGdCLEtBQWIsRUFBb0IsQ0FBcEIsRUFENkQsQ0FHN0Q7O0FBQ0EsZ0JBQUtBLEtBQUssSUFBSW8zRCxXQUFkLEVBQTRCO0FBQzNCQSxjQUFBQSxXQUFXO0FBQ1g7QUFDRDtBQUNELFNBVkQ7QUFXQSxlQUFPLElBQVA7QUFDQSxPQS9DSztBQWlETjtBQUNBO0FBQ0FwQixNQUFBQSxHQUFHLEVBQUUsYUFBVTFSLEVBQVYsRUFBZTtBQUNuQixlQUFPQSxFQUFFLEdBQ1JELE1BQU0sQ0FBQ2lDLE9BQVAsQ0FBZ0JoQyxFQUFoQixFQUFvQi9qRSxJQUFwQixJQUE2QixDQUFDLENBRHRCLEdBRVJBLElBQUksQ0FBQ25DLE1BQUwsR0FBYyxDQUZmO0FBR0EsT0F2REs7QUF5RE47QUFDQW01RSxNQUFBQSxLQUFLLEVBQUUsaUJBQVc7QUFDakIsWUFBS2gzRSxJQUFMLEVBQVk7QUFDWEEsVUFBQUEsSUFBSSxHQUFHLEVBQVA7QUFDQTs7QUFDRCxlQUFPLElBQVA7QUFDQSxPQS9ESztBQWlFTjtBQUNBO0FBQ0E7QUFDQWdLLE1BQUFBLE9BQU8sRUFBRSxtQkFBVztBQUNuQnF2QixRQUFBQSxPQUFNLEdBQUd1OUMsS0FBSyxHQUFHLEVBQWpCO0FBQ0E1MkUsUUFBQUEsSUFBSSxHQUFHMDJFLE1BQU0sR0FBRyxFQUFoQjtBQUNBLGVBQU8sSUFBUDtBQUNBLE9BeEVLO0FBeUVOeE0sTUFBQUEsUUFBUSxFQUFFLG9CQUFXO0FBQ3BCLGVBQU8sQ0FBQ2xxRSxJQUFSO0FBQ0EsT0EzRUs7QUE2RU47QUFDQTtBQUNBO0FBQ0FpM0UsTUFBQUEsSUFBSSxFQUFFLGdCQUFXO0FBQ2hCNTlDLFFBQUFBLE9BQU0sR0FBR3U5QyxLQUFLLEdBQUcsRUFBakI7O0FBQ0EsWUFBSyxDQUFDRixNQUFELElBQVcsQ0FBQ0QsTUFBakIsRUFBMEI7QUFDekJ6MkUsVUFBQUEsSUFBSSxHQUFHMDJFLE1BQU0sR0FBRyxFQUFoQjtBQUNBOztBQUNELGVBQU8sSUFBUDtBQUNBLE9BdEZLO0FBdUZOcjlDLE1BQUFBLE1BQU0sRUFBRSxrQkFBVztBQUNsQixlQUFPLENBQUMsQ0FBQ0EsT0FBVDtBQUNBLE9BekZLO0FBMkZOO0FBQ0E2OUMsTUFBQUEsUUFBUSxFQUFFLGtCQUFVM3lFLE9BQVYsRUFBbUJ5d0QsSUFBbkIsRUFBMEI7QUFDbkMsWUFBSyxDQUFDMzdCLE9BQU4sRUFBZTtBQUNkMjdCLFVBQUFBLElBQUksR0FBR0EsSUFBSSxJQUFJLEVBQWY7QUFDQUEsVUFBQUEsSUFBSSxHQUFHLENBQUV6d0QsT0FBRixFQUFXeXdELElBQUksQ0FBQ3YyQyxLQUFMLEdBQWF1MkMsSUFBSSxDQUFDdjJDLEtBQUwsRUFBYixHQUE0QnUyQyxJQUF2QyxDQUFQO0FBQ0E0aEIsVUFBQUEsS0FBSyxDQUFDdjRFLElBQU4sQ0FBWTIyRCxJQUFaOztBQUNBLGNBQUssQ0FBQ3loQixNQUFOLEVBQWU7QUFDZEssWUFBQUEsSUFBSTtBQUNKO0FBQ0Q7O0FBQ0QsZUFBTyxJQUFQO0FBQ0EsT0F0R0s7QUF3R047QUFDQUEsTUFBQUEsSUFBSSxFQUFFLGdCQUFXO0FBQ2hCbCtFLFFBQUFBLElBQUksQ0FBQ3MrRSxRQUFMLENBQWUsSUFBZixFQUFxQjN0RSxTQUFyQjtBQUNBLGVBQU8sSUFBUDtBQUNBLE9BNUdLO0FBOEdOO0FBQ0FvdEUsTUFBQUEsS0FBSyxFQUFFLGlCQUFXO0FBQ2pCLGVBQU8sQ0FBQyxDQUFDQSxNQUFUO0FBQ0E7QUFqSEssS0FuRVI7O0FBdUxBLFdBQU8vOUUsSUFBUDtBQUNBLEdBaE1EOztBQW1NQSxXQUFTdStFLFFBQVQsQ0FBbUJqcEQsQ0FBbkIsRUFBdUI7QUFDdEIsV0FBT0EsQ0FBUDtBQUNBOztBQUNELFdBQVNrcEQsT0FBVCxDQUFrQnp0RCxFQUFsQixFQUF1QjtBQUN0QixVQUFNQSxFQUFOO0FBQ0E7O0FBRUQsV0FBUzB0RCxVQUFULENBQXFCcjhFLEtBQXJCLEVBQTRCc3hELE9BQTVCLEVBQXFDZ3JCLE1BQXJDLEVBQTZDQyxPQUE3QyxFQUF1RDtBQUN0RCxRQUFJQyxNQUFKOztBQUVBLFFBQUk7QUFFSDtBQUNBLFVBQUt4OEUsS0FBSyxJQUFJaW9FLFVBQVUsQ0FBSXVVLE1BQU0sR0FBR3g4RSxLQUFLLENBQUN5OEUsT0FBbkIsQ0FBeEIsRUFBeUQ7QUFDeERELFFBQUFBLE1BQU0sQ0FBQzN3RSxJQUFQLENBQWE3TCxLQUFiLEVBQXFCMHNFLElBQXJCLENBQTJCcGIsT0FBM0IsRUFBcUNvckIsSUFBckMsQ0FBMkNKLE1BQTNDLEVBRHdELENBR3pEO0FBQ0MsT0FKRCxNQUlPLElBQUt0OEUsS0FBSyxJQUFJaW9FLFVBQVUsQ0FBSXVVLE1BQU0sR0FBR3g4RSxLQUFLLENBQUNteEQsSUFBbkIsQ0FBeEIsRUFBc0Q7QUFDNURxckIsUUFBQUEsTUFBTSxDQUFDM3dFLElBQVAsQ0FBYTdMLEtBQWIsRUFBb0JzeEQsT0FBcEIsRUFBNkJnckIsTUFBN0IsRUFENEQsQ0FHN0Q7QUFDQyxPQUpNLE1BSUE7QUFFTjtBQUNBO0FBQ0E7QUFDQWhyQixRQUFBQSxPQUFPLENBQUNwb0QsS0FBUixDQUFlaWhFLFNBQWYsRUFBMEIsQ0FBRW5xRSxLQUFGLEVBQVV5akIsS0FBVixDQUFpQjg0RCxPQUFqQixDQUExQjtBQUNBLE9BakJFLENBbUJKO0FBQ0E7QUFDQTs7QUFDQyxLQXRCRCxDQXNCRSxPQUFRdjhFLEtBQVIsRUFBZ0I7QUFFakI7QUFDQTtBQUNBczhFLE1BQUFBLE1BQU0sQ0FBQ3B6RSxLQUFQLENBQWNpaEUsU0FBZCxFQUF5QixDQUFFbnFFLEtBQUYsQ0FBekI7QUFDQTtBQUNEOztBQUVEOG9FLEVBQUFBLE1BQU0sQ0FBQ2dCLE1BQVAsQ0FBZTtBQUVkNlMsSUFBQUEsUUFBUSxFQUFFLGtCQUFVeDVFLElBQVYsRUFBaUI7QUFDMUIsVUFBSXk1RSxNQUFNLEdBQUcsQ0FFWDtBQUNBO0FBQ0EsT0FBRSxRQUFGLEVBQVksVUFBWixFQUF3QjlULE1BQU0sQ0FBQzBTLFNBQVAsQ0FBa0IsUUFBbEIsQ0FBeEIsRUFDQzFTLE1BQU0sQ0FBQzBTLFNBQVAsQ0FBa0IsUUFBbEIsQ0FERCxFQUMrQixDQUQvQixDQUpXLEVBTVgsQ0FBRSxTQUFGLEVBQWEsTUFBYixFQUFxQjFTLE1BQU0sQ0FBQzBTLFNBQVAsQ0FBa0IsYUFBbEIsQ0FBckIsRUFDQzFTLE1BQU0sQ0FBQzBTLFNBQVAsQ0FBa0IsYUFBbEIsQ0FERCxFQUNvQyxDQURwQyxFQUN1QyxVQUR2QyxDQU5XLEVBUVgsQ0FBRSxRQUFGLEVBQVksTUFBWixFQUFvQjFTLE1BQU0sQ0FBQzBTLFNBQVAsQ0FBa0IsYUFBbEIsQ0FBcEIsRUFDQzFTLE1BQU0sQ0FBQzBTLFNBQVAsQ0FBa0IsYUFBbEIsQ0FERCxFQUNvQyxDQURwQyxFQUN1QyxVQUR2QyxDQVJXLENBQWI7QUFBQSxVQVdDdHdDLE1BQUssR0FBRyxTQVhUO0FBQUEsVUFZQ3V4QyxRQUFPLEdBQUc7QUFDVHZ4QyxRQUFBQSxLQUFLLEVBQUUsaUJBQVc7QUFDakIsaUJBQU9BLE1BQVA7QUFDQSxTQUhRO0FBSVQyeEMsUUFBQUEsTUFBTSxFQUFFLGtCQUFXO0FBQ2xCQyxVQUFBQSxRQUFRLENBQUNwUSxJQUFULENBQWVuK0QsU0FBZixFQUEyQm11RSxJQUEzQixDQUFpQ251RSxTQUFqQztBQUNBLGlCQUFPLElBQVA7QUFDQSxTQVBRO0FBUVQsaUJBQVMsZ0JBQVV3NkQsRUFBVixFQUFlO0FBQ3ZCLGlCQUFPMFQsUUFBTyxDQUFDdHJCLElBQVIsQ0FBYyxJQUFkLEVBQW9CNFgsRUFBcEIsQ0FBUDtBQUNBLFNBVlE7QUFZVDtBQUNBcGlCLFFBQUFBLElBQUksRUFBRTtBQUFVO0FBQVYsZUFBNkM7QUFDbEQsY0FBSW8yQixHQUFHLEdBQUd4dUUsU0FBVjtBQUVBLGlCQUFPdTZELE1BQU0sQ0FBQzZULFFBQVAsQ0FBaUIsVUFBVUssUUFBVixFQUFxQjtBQUM1Q2xVLFlBQUFBLE1BQU0sQ0FBQ3ZqQixJQUFQLENBQWFxM0IsTUFBYixFQUFxQixVQUFVbjdDLEVBQVYsRUFBY3c3QyxLQUFkLEVBQXNCO0FBRTFDO0FBQ0Esa0JBQUlsVSxFQUFFLEdBQUdkLFVBQVUsQ0FBRThVLEdBQUcsQ0FBRUUsS0FBSyxDQUFFLENBQUYsQ0FBUCxDQUFMLENBQVYsSUFBbUNGLEdBQUcsQ0FBRUUsS0FBSyxDQUFFLENBQUYsQ0FBUCxDQUEvQyxDQUgwQyxDQUsxQztBQUNBO0FBQ0E7O0FBQ0FILGNBQUFBLFFBQVEsQ0FBRUcsS0FBSyxDQUFFLENBQUYsQ0FBUCxDQUFSLENBQXdCLFlBQVc7QUFDbEMsb0JBQUlDLFFBQVEsR0FBR25VLEVBQUUsSUFBSUEsRUFBRSxDQUFDNy9ELEtBQUgsQ0FBVSxJQUFWLEVBQWdCcUYsU0FBaEIsQ0FBckI7O0FBQ0Esb0JBQUsydUUsUUFBUSxJQUFJalYsVUFBVSxDQUFFaVYsUUFBUSxDQUFDVCxPQUFYLENBQTNCLEVBQWtEO0FBQ2pEUyxrQkFBQUEsUUFBUSxDQUFDVCxPQUFULEdBQ0V6NUQsUUFERixDQUNZZzZELFFBQVEsQ0FBQ0csTUFEckIsRUFFRXpRLElBRkYsQ0FFUXNRLFFBQVEsQ0FBQzFyQixPQUZqQixFQUdFb3JCLElBSEYsQ0FHUU0sUUFBUSxDQUFDVixNQUhqQjtBQUlBLGlCQUxELE1BS087QUFDTlUsa0JBQUFBLFFBQVEsQ0FBRUMsS0FBSyxDQUFFLENBQUYsQ0FBTCxHQUFhLE1BQWYsQ0FBUixDQUNDLElBREQsRUFFQ2xVLEVBQUUsR0FBRyxDQUFFbVUsUUFBRixDQUFILEdBQWtCM3VFLFNBRnJCO0FBSUE7QUFDRCxlQWJEO0FBY0EsYUF0QkQ7QUF1QkF3dUUsWUFBQUEsR0FBRyxHQUFHLElBQU47QUFDQSxXQXpCTSxFQXlCSE4sT0F6QkcsRUFBUDtBQTBCQSxTQTFDUTtBQTJDVHRyQixRQUFBQSxJQUFJLEVBQUUsY0FBVUMsV0FBVixFQUF1QmdzQixVQUF2QixFQUFtQ0MsVUFBbkMsRUFBZ0Q7QUFDckQsY0FBSUMsUUFBUSxHQUFHLENBQWY7O0FBQ0EsbUJBQVNoc0IsT0FBVCxDQUFrQmlzQixLQUFsQixFQUF5QlQsUUFBekIsRUFBbUN2TSxPQUFuQyxFQUE0Q2lOLE9BQTVDLEVBQXNEO0FBQ3JELG1CQUFPLFlBQVc7QUFDakIsa0JBQUlDLElBQUksR0FBRyxJQUFYO0FBQUEsa0JBQ0N6akIsSUFBSSxHQUFHenJELFNBRFI7QUFBQSxrQkFFQ212RSxVQUFVLEdBQUcsU0FBYkEsVUFBYSxHQUFXO0FBQ3ZCLG9CQUFJUixRQUFKLEVBQWMvckIsSUFBZCxDQUR1QixDQUd2QjtBQUNBO0FBQ0E7O0FBQ0Esb0JBQUtvc0IsS0FBSyxHQUFHRCxRQUFiLEVBQXdCO0FBQ3ZCO0FBQ0E7O0FBRURKLGdCQUFBQSxRQUFRLEdBQUczTSxPQUFPLENBQUNybkUsS0FBUixDQUFldTBFLElBQWYsRUFBcUJ6akIsSUFBckIsQ0FBWCxDQVZ1QixDQVl2QjtBQUNBOztBQUNBLG9CQUFLa2pCLFFBQVEsS0FBS0osUUFBUSxDQUFDTCxPQUFULEVBQWxCLEVBQXVDO0FBQ3RDLHdCQUFNLElBQUlrQixTQUFKLENBQWUsMEJBQWYsQ0FBTjtBQUNBLGlCQWhCc0IsQ0FrQnZCO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQXhzQixnQkFBQUEsSUFBSSxHQUFHK3JCLFFBQVEsTUFFZDtBQUNBO0FBQ0E7QUFDRSx3QkFBT0EsUUFBUCxNQUFvQixRQUFwQixJQUNELE9BQU9BLFFBQVAsS0FBb0IsVUFOUCxDQUFSLElBT05BLFFBQVEsQ0FBQy9yQixJQVBWLENBdEJ1QixDQStCdkI7O0FBQ0Esb0JBQUs4VyxVQUFVLENBQUU5VyxJQUFGLENBQWYsRUFBMEI7QUFFekI7QUFDQSxzQkFBS3FzQixPQUFMLEVBQWU7QUFDZHJzQixvQkFBQUEsSUFBSSxDQUFDdGxELElBQUwsQ0FDQ3F4RSxRQURELEVBRUM1ckIsT0FBTyxDQUFFZ3NCLFFBQUYsRUFBWVIsUUFBWixFQUFzQlgsUUFBdEIsRUFBZ0NxQixPQUFoQyxDQUZSLEVBR0Nsc0IsT0FBTyxDQUFFZ3NCLFFBQUYsRUFBWVIsUUFBWixFQUFzQlYsT0FBdEIsRUFBK0JvQixPQUEvQixDQUhSLEVBRGMsQ0FPZjtBQUNDLG1CQVJELE1BUU87QUFFTjtBQUNBRixvQkFBQUEsUUFBUTtBQUVSbnNCLG9CQUFBQSxJQUFJLENBQUN0bEQsSUFBTCxDQUNDcXhFLFFBREQsRUFFQzVyQixPQUFPLENBQUVnc0IsUUFBRixFQUFZUixRQUFaLEVBQXNCWCxRQUF0QixFQUFnQ3FCLE9BQWhDLENBRlIsRUFHQ2xzQixPQUFPLENBQUVnc0IsUUFBRixFQUFZUixRQUFaLEVBQXNCVixPQUF0QixFQUErQm9CLE9BQS9CLENBSFIsRUFJQ2xzQixPQUFPLENBQUVnc0IsUUFBRixFQUFZUixRQUFaLEVBQXNCWCxRQUF0QixFQUNOVyxRQUFRLENBQUNjLFVBREgsQ0FKUjtBQU9BLG1CQXZCd0IsQ0F5QjFCOztBQUNDLGlCQTFCRCxNQTBCTztBQUVOO0FBQ0E7QUFDQSxzQkFBS3JOLE9BQU8sS0FBSzRMLFFBQWpCLEVBQTRCO0FBQzNCc0Isb0JBQUFBLElBQUksR0FBR3RULFNBQVA7QUFDQW5RLG9CQUFBQSxJQUFJLEdBQUcsQ0FBRWtqQixRQUFGLENBQVA7QUFDQSxtQkFQSyxDQVNOO0FBQ0E7OztBQUNBLG1CQUFFTSxPQUFPLElBQUlWLFFBQVEsQ0FBQ2UsV0FBdEIsRUFBcUNKLElBQXJDLEVBQTJDempCLElBQTNDO0FBQ0E7QUFDRCxlQXpFRjtBQUFBLGtCQTJFQztBQUNBOGpCLGNBQUFBLE9BQU8sR0FBR04sT0FBTyxHQUNoQkUsVUFEZ0IsR0FFaEIsWUFBVztBQUNWLG9CQUFJO0FBQ0hBLGtCQUFBQSxVQUFVO0FBQ1YsaUJBRkQsQ0FFRSxPQUFRMzhFLENBQVIsRUFBWTtBQUViLHNCQUFLK25FLE1BQU0sQ0FBQzZULFFBQVAsQ0FBZ0JvQixhQUFyQixFQUFxQztBQUNwQ2pWLG9CQUFBQSxNQUFNLENBQUM2VCxRQUFQLENBQWdCb0IsYUFBaEIsQ0FBK0JoOUUsQ0FBL0IsRUFDQys4RSxPQUFPLENBQUNFLFVBRFQ7QUFFQSxtQkFMWSxDQU9iO0FBQ0E7QUFDQTs7O0FBQ0Esc0JBQUtULEtBQUssR0FBRyxDQUFSLElBQWFELFFBQWxCLEVBQTZCO0FBRTVCO0FBQ0E7QUFDQSx3QkFBSy9NLE9BQU8sS0FBSzZMLE9BQWpCLEVBQTJCO0FBQzFCcUIsc0JBQUFBLElBQUksR0FBR3RULFNBQVA7QUFDQW5RLHNCQUFBQSxJQUFJLEdBQUcsQ0FBRWo1RCxDQUFGLENBQVA7QUFDQTs7QUFFRCs3RSxvQkFBQUEsUUFBUSxDQUFDbUIsVUFBVCxDQUFxQlIsSUFBckIsRUFBMkJ6akIsSUFBM0I7QUFDQTtBQUNEO0FBQ0QsZUF2R0gsQ0FEaUIsQ0EwR2pCO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQSxrQkFBS3VqQixLQUFMLEVBQWE7QUFDWk8sZ0JBQUFBLE9BQU87QUFDUCxlQUZELE1BRU87QUFFTjtBQUNBO0FBQ0Esb0JBQUtoVixNQUFNLENBQUM2VCxRQUFQLENBQWdCdUIsWUFBckIsRUFBb0M7QUFDbkNKLGtCQUFBQSxPQUFPLENBQUNFLFVBQVIsR0FBcUJsVixNQUFNLENBQUM2VCxRQUFQLENBQWdCdUIsWUFBaEIsRUFBckI7QUFDQTs7QUFDRHQrRSxnQkFBQUEsTUFBTSxDQUFDdzhCLFVBQVAsQ0FBbUIwaEQsT0FBbkI7QUFDQTtBQUNELGFBekhEO0FBMEhBOztBQUVELGlCQUFPaFYsTUFBTSxDQUFDNlQsUUFBUCxDQUFpQixVQUFVSyxRQUFWLEVBQXFCO0FBRTVDO0FBQ0FKLFlBQUFBLE1BQU0sQ0FBRSxDQUFGLENBQU4sQ0FBYSxDQUFiLEVBQWlCcjVFLEdBQWpCLENBQ0MrdEQsT0FBTyxDQUNOLENBRE0sRUFFTjByQixRQUZNLEVBR04vVSxVQUFVLENBQUVvVixVQUFGLENBQVYsR0FDQ0EsVUFERCxHQUVDbEIsUUFMSyxFQU1OYSxRQUFRLENBQUNZLFVBTkgsQ0FEUixFQUg0QyxDQWM1Qzs7QUFDQWhCLFlBQUFBLE1BQU0sQ0FBRSxDQUFGLENBQU4sQ0FBYSxDQUFiLEVBQWlCcjVFLEdBQWpCLENBQ0MrdEQsT0FBTyxDQUNOLENBRE0sRUFFTjByQixRQUZNLEVBR04vVSxVQUFVLENBQUU3VyxXQUFGLENBQVYsR0FDQ0EsV0FERCxHQUVDK3FCLFFBTEssQ0FEUixFQWY0QyxDQXlCNUM7O0FBQ0FTLFlBQUFBLE1BQU0sQ0FBRSxDQUFGLENBQU4sQ0FBYSxDQUFiLEVBQWlCcjVFLEdBQWpCLENBQ0MrdEQsT0FBTyxDQUNOLENBRE0sRUFFTjByQixRQUZNLEVBR04vVSxVQUFVLENBQUVtVixVQUFGLENBQVYsR0FDQ0EsVUFERCxHQUVDaEIsT0FMSyxDQURSO0FBU0EsV0FuQ00sRUFtQ0hLLE9BbkNHLEVBQVA7QUFvQ0EsU0E5TVE7QUFnTlQ7QUFDQTtBQUNBQSxRQUFBQSxPQUFPLEVBQUUsaUJBQVVyNkUsR0FBVixFQUFnQjtBQUN4QixpQkFBT0EsR0FBRyxJQUFJLElBQVAsR0FBYzBtRSxNQUFNLENBQUNnQixNQUFQLENBQWUxbkUsR0FBZixFQUFvQnE2RSxRQUFwQixDQUFkLEdBQThDQSxRQUFyRDtBQUNBO0FBcE5RLE9BWlg7QUFBQSxVQWtPQ0ssUUFBUSxHQUFHLEVBbE9aLENBRDBCLENBcU8xQjs7QUFDQWhVLE1BQUFBLE1BQU0sQ0FBQ3ZqQixJQUFQLENBQWFxM0IsTUFBYixFQUFxQixVQUFVaDZFLENBQVYsRUFBYXE2RSxLQUFiLEVBQXFCO0FBQ3pDLFlBQUlqNEUsSUFBSSxHQUFHaTRFLEtBQUssQ0FBRSxDQUFGLENBQWhCO0FBQUEsWUFDQ2tCLFdBQVcsR0FBR2xCLEtBQUssQ0FBRSxDQUFGLENBRHBCLENBRHlDLENBSXpDO0FBQ0E7QUFDQTs7QUFDQVIsUUFBQUEsUUFBTyxDQUFFUSxLQUFLLENBQUUsQ0FBRixDQUFQLENBQVAsR0FBd0JqNEUsSUFBSSxDQUFDekIsR0FBN0IsQ0FQeUMsQ0FTekM7O0FBQ0EsWUFBSzQ2RSxXQUFMLEVBQW1CO0FBQ2xCbjVFLFVBQUFBLElBQUksQ0FBQ3pCLEdBQUwsQ0FDQyxZQUFXO0FBRVY7QUFDQTtBQUNBMm5DLFlBQUFBLE1BQUssR0FBR2l6QyxXQUFSO0FBQ0EsV0FORixFQVFDO0FBQ0E7QUFDQXZCLFVBQUFBLE1BQU0sQ0FBRSxJQUFJaDZFLENBQU4sQ0FBTixDQUFpQixDQUFqQixFQUFxQm9NLE9BVnRCLEVBWUM7QUFDQTtBQUNBNHRFLFVBQUFBLE1BQU0sQ0FBRSxJQUFJaDZFLENBQU4sQ0FBTixDQUFpQixDQUFqQixFQUFxQm9NLE9BZHRCLEVBZ0JDO0FBQ0E0dEUsVUFBQUEsTUFBTSxDQUFFLENBQUYsQ0FBTixDQUFhLENBQWIsRUFBaUJYLElBakJsQixFQW1CQztBQUNBVyxVQUFBQSxNQUFNLENBQUUsQ0FBRixDQUFOLENBQWEsQ0FBYixFQUFpQlgsSUFwQmxCO0FBc0JBLFNBakN3QyxDQW1DekM7QUFDQTtBQUNBOzs7QUFDQWozRSxRQUFBQSxJQUFJLENBQUN6QixHQUFMLENBQVUwNUUsS0FBSyxDQUFFLENBQUYsQ0FBTCxDQUFXbkIsSUFBckIsRUF0Q3lDLENBd0N6QztBQUNBO0FBQ0E7O0FBQ0FnQixRQUFBQSxRQUFRLENBQUVHLEtBQUssQ0FBRSxDQUFGLENBQVAsQ0FBUixHQUF5QixZQUFXO0FBQ25DSCxVQUFBQSxRQUFRLENBQUVHLEtBQUssQ0FBRSxDQUFGLENBQUwsR0FBYSxNQUFmLENBQVIsQ0FBaUMsU0FBU0gsUUFBVCxHQUFvQjNTLFNBQXBCLEdBQWdDLElBQWpFLEVBQXVFNTdELFNBQXZFO0FBQ0EsaUJBQU8sSUFBUDtBQUNBLFNBSEQsQ0EzQ3lDLENBZ0R6QztBQUNBO0FBQ0E7OztBQUNBdXVFLFFBQUFBLFFBQVEsQ0FBRUcsS0FBSyxDQUFFLENBQUYsQ0FBTCxHQUFhLE1BQWYsQ0FBUixHQUFrQ2o0RSxJQUFJLENBQUNrM0UsUUFBdkM7QUFDQSxPQXBERCxFQXRPMEIsQ0E0UjFCOztBQUNBTyxNQUFBQSxRQUFPLENBQUNBLE9BQVIsQ0FBaUJLLFFBQWpCLEVBN1IwQixDQStSMUI7OztBQUNBLFVBQUszNUUsSUFBTCxFQUFZO0FBQ1hBLFFBQUFBLElBQUksQ0FBQzBJLElBQUwsQ0FBV2l4RSxRQUFYLEVBQXFCQSxRQUFyQjtBQUNBLE9BbFN5QixDQW9TMUI7OztBQUNBLGFBQU9BLFFBQVA7QUFDQSxLQXhTYTtBQTBTZDtBQUNBc0IsSUFBQUEsSUFBSSxFQUFFLGNBQVVDLFdBQVYsRUFBd0I7QUFDN0IsVUFFQztBQUNBQyxNQUFBQSxTQUFTLEdBQUcvdkUsU0FBUyxDQUFDMUwsTUFIdkI7QUFBQSxVQUtDO0FBQ0FELE1BQUFBLENBQUMsR0FBRzA3RSxTQU5MO0FBQUEsVUFRQztBQUNBQyxNQUFBQSxlQUFlLEdBQUc3OUUsS0FBSyxDQUFFa0MsQ0FBRixDQVR4QjtBQUFBLFVBVUM0N0UsYUFBYSxHQUFHLzZELE1BQUssQ0FBQzVYLElBQU4sQ0FBWTBDLFNBQVosQ0FWakI7QUFBQSxVQVlDO0FBQ0Frd0UsTUFBQUEsT0FBTyxHQUFHM1YsTUFBTSxDQUFDNlQsUUFBUCxFQWJYO0FBQUEsVUFlQztBQUNBK0IsTUFBQUEsVUFBVSxHQUFHLFNBQWJBLFVBQWEsQ0FBVTk3RSxDQUFWLEVBQWM7QUFDMUIsZUFBTyxVQUFVNUMsS0FBVixFQUFrQjtBQUN4QnUrRSxVQUFBQSxlQUFlLENBQUUzN0UsQ0FBRixDQUFmLEdBQXVCLElBQXZCO0FBQ0E0N0UsVUFBQUEsYUFBYSxDQUFFNTdFLENBQUYsQ0FBYixHQUFxQjJMLFNBQVMsQ0FBQzFMLE1BQVYsR0FBbUIsQ0FBbkIsR0FBdUI0Z0IsTUFBSyxDQUFDNVgsSUFBTixDQUFZMEMsU0FBWixDQUF2QixHQUFpRHZPLEtBQXRFOztBQUNBLGNBQUssQ0FBRyxHQUFFcytFLFNBQVYsRUFBd0I7QUFDdkJHLFlBQUFBLE9BQU8sQ0FBQ1osV0FBUixDQUFxQlUsZUFBckIsRUFBc0NDLGFBQXRDO0FBQ0E7QUFDRCxTQU5EO0FBT0EsT0F4QkYsQ0FENkIsQ0EyQjdCOzs7QUFDQSxVQUFLRixTQUFTLElBQUksQ0FBbEIsRUFBc0I7QUFDckJqQyxRQUFBQSxVQUFVLENBQUVnQyxXQUFGLEVBQWVJLE9BQU8sQ0FBQy9SLElBQVIsQ0FBY2dTLFVBQVUsQ0FBRTk3RSxDQUFGLENBQXhCLEVBQWdDMHVELE9BQS9DLEVBQXdEbXRCLE9BQU8sQ0FBQ25DLE1BQWhFLEVBQ1QsQ0FBQ2dDLFNBRFEsQ0FBVixDQURxQixDQUlyQjs7QUFDQSxZQUFLRyxPQUFPLENBQUN2ekMsS0FBUixPQUFvQixTQUFwQixJQUNKKzhCLFVBQVUsQ0FBRXVXLGFBQWEsQ0FBRTU3RSxDQUFGLENBQWIsSUFBc0I0N0UsYUFBYSxDQUFFNTdFLENBQUYsQ0FBYixDQUFtQnV1RCxJQUEzQyxDQURYLEVBQytEO0FBRTlELGlCQUFPc3RCLE9BQU8sQ0FBQ3R0QixJQUFSLEVBQVA7QUFDQTtBQUNELE9BdEM0QixDQXdDN0I7OztBQUNBLGFBQVF2dUQsQ0FBQyxFQUFULEVBQWM7QUFDYnk1RSxRQUFBQSxVQUFVLENBQUVtQyxhQUFhLENBQUU1N0UsQ0FBRixDQUFmLEVBQXNCODdFLFVBQVUsQ0FBRTk3RSxDQUFGLENBQWhDLEVBQXVDNjdFLE9BQU8sQ0FBQ25DLE1BQS9DLENBQVY7QUFDQTs7QUFFRCxhQUFPbUMsT0FBTyxDQUFDaEMsT0FBUixFQUFQO0FBQ0E7QUF6VmEsR0FBZixFQXBrSGlGLENBaTZIakY7QUFDQTs7QUFDQSxNQUFJa0MsV0FBVyxHQUFHLHdEQUFsQjs7QUFFQTdWLEVBQUFBLE1BQU0sQ0FBQzZULFFBQVAsQ0FBZ0JvQixhQUFoQixHQUFnQyxVQUFVbGYsS0FBVixFQUFpQitmLEtBQWpCLEVBQXlCO0FBRXhEO0FBQ0E7QUFDQSxRQUFLaC9FLE1BQU0sQ0FBQzZSLE9BQVAsSUFBa0I3UixNQUFNLENBQUM2UixPQUFQLENBQWVDLElBQWpDLElBQXlDbXRELEtBQXpDLElBQWtEOGYsV0FBVyxDQUFDenlFLElBQVosQ0FBa0IyeUQsS0FBSyxDQUFDcjVDLElBQXhCLENBQXZELEVBQXdGO0FBQ3ZGNWxCLE1BQUFBLE1BQU0sQ0FBQzZSLE9BQVAsQ0FBZUMsSUFBZixDQUFxQixnQ0FBZ0NtdEQsS0FBSyxDQUFDbGlCLE9BQTNELEVBQW9Fa2lCLEtBQUssQ0FBQytmLEtBQTFFLEVBQWlGQSxLQUFqRjtBQUNBO0FBQ0QsR0FQRDs7QUFZQTlWLEVBQUFBLE1BQU0sQ0FBQytWLGNBQVAsR0FBd0IsVUFBVWhnQixLQUFWLEVBQWtCO0FBQ3pDai9ELElBQUFBLE1BQU0sQ0FBQ3c4QixVQUFQLENBQW1CLFlBQVc7QUFDN0IsWUFBTXlpQyxLQUFOO0FBQ0EsS0FGRDtBQUdBLEdBSkQsQ0FqN0hpRixDQTA3SGpGOzs7QUFDQSxNQUFJaWdCLFNBQVMsR0FBR2hXLE1BQU0sQ0FBQzZULFFBQVAsRUFBaEI7O0FBRUE3VCxFQUFBQSxNQUFNLENBQUNDLEVBQVAsQ0FBVXNSLEtBQVYsR0FBa0IsVUFBVXRSLEVBQVYsRUFBZTtBQUVoQytWLElBQUFBLFNBQVMsQ0FDUDN0QixJQURGLENBQ1E0WCxFQURSLEVBR0M7QUFDQTtBQUNBO0FBTEQsY0FNUyxVQUFVbEssS0FBVixFQUFrQjtBQUN6QmlLLE1BQUFBLE1BQU0sQ0FBQytWLGNBQVAsQ0FBdUJoZ0IsS0FBdkI7QUFDQSxLQVJGO0FBVUEsV0FBTyxJQUFQO0FBQ0EsR0FiRDs7QUFlQWlLLEVBQUFBLE1BQU0sQ0FBQ2dCLE1BQVAsQ0FBZTtBQUVkO0FBQ0FPLElBQUFBLE9BQU8sRUFBRSxLQUhLO0FBS2Q7QUFDQTtBQUNBMFUsSUFBQUEsU0FBUyxFQUFFLENBUEc7QUFTZDtBQUNBMUUsSUFBQUEsS0FBSyxFQUFFLGVBQVUyRSxJQUFWLEVBQWlCO0FBRXZCO0FBQ0EsVUFBS0EsSUFBSSxLQUFLLElBQVQsR0FBZ0IsRUFBRWxXLE1BQU0sQ0FBQ2lXLFNBQXpCLEdBQXFDalcsTUFBTSxDQUFDdUIsT0FBakQsRUFBMkQ7QUFDMUQ7QUFDQSxPQUxzQixDQU92Qjs7O0FBQ0F2QixNQUFBQSxNQUFNLENBQUN1QixPQUFQLEdBQWlCLElBQWpCLENBUnVCLENBVXZCOztBQUNBLFVBQUsyVSxJQUFJLEtBQUssSUFBVCxJQUFpQixFQUFFbFcsTUFBTSxDQUFDaVcsU0FBVCxHQUFxQixDQUEzQyxFQUErQztBQUM5QztBQUNBLE9BYnNCLENBZXZCOzs7QUFDQUQsTUFBQUEsU0FBUyxDQUFDakIsV0FBVixDQUF1QjF3RSxRQUF2QixFQUFpQyxDQUFFMjdELE1BQUYsQ0FBakM7QUFDQTtBQTNCYSxHQUFmO0FBOEJBQSxFQUFBQSxNQUFNLENBQUN1UixLQUFQLENBQWFscEIsSUFBYixHQUFvQjJ0QixTQUFTLENBQUMzdEIsSUFBOUIsQ0ExK0hpRixDQTQrSGpGOztBQUNBLFdBQVM4dEIsU0FBVCxHQUFxQjtBQUNwQjl4RSxJQUFBQSxRQUFRLENBQUN6SSxtQkFBVCxDQUE4QixrQkFBOUIsRUFBa0R1NkUsU0FBbEQ7QUFDQXIvRSxJQUFBQSxNQUFNLENBQUM4RSxtQkFBUCxDQUE0QixNQUE1QixFQUFvQ3U2RSxTQUFwQztBQUNBblcsSUFBQUEsTUFBTSxDQUFDdVIsS0FBUDtBQUNBLEdBai9IZ0YsQ0FtL0hqRjtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0EsTUFBS2x0RSxRQUFRLENBQUMreEUsVUFBVCxLQUF3QixVQUF4QixJQUNGL3hFLFFBQVEsQ0FBQyt4RSxVQUFULEtBQXdCLFNBQXhCLElBQXFDLENBQUMveEUsUUFBUSxDQUFDeEgsZUFBVCxDQUF5Qnc1RSxRQURsRSxFQUMrRTtBQUU5RTtBQUNBdi9FLElBQUFBLE1BQU0sQ0FBQ3c4QixVQUFQLENBQW1CMHNDLE1BQU0sQ0FBQ3VSLEtBQTFCO0FBRUEsR0FORCxNQU1PO0FBRU47QUFDQWx0RSxJQUFBQSxRQUFRLENBQUM3SSxnQkFBVCxDQUEyQixrQkFBM0IsRUFBK0MyNkUsU0FBL0MsRUFITSxDQUtOOztBQUNBci9FLElBQUFBLE1BQU0sQ0FBQzBFLGdCQUFQLENBQXlCLE1BQXpCLEVBQWlDMjZFLFNBQWpDO0FBQ0EsR0FwZ0lnRixDQXlnSWpGO0FBQ0E7OztBQUNBLE1BQUlHLE1BQU0sR0FBRyxTQUFUQSxNQUFTLENBQVVqVyxLQUFWLEVBQWlCSixFQUFqQixFQUFxQm54QyxHQUFyQixFQUEwQjUzQixLQUExQixFQUFpQ3EvRSxTQUFqQyxFQUE0Q0MsUUFBNUMsRUFBc0RoNUIsR0FBdEQsRUFBNEQ7QUFDeEUsUUFBSTFqRCxDQUFDLEdBQUcsQ0FBUjtBQUFBLFFBQ0NpbkUsR0FBRyxHQUFHVixLQUFLLENBQUN0bUUsTUFEYjtBQUFBLFFBRUMwOEUsSUFBSSxHQUFHM25ELEdBQUcsSUFBSSxJQUZmLENBRHdFLENBS3hFOztBQUNBLFFBQUtpeEMsTUFBTSxDQUFFanhDLEdBQUYsQ0FBTixLQUFrQixRQUF2QixFQUFrQztBQUNqQ3luRCxNQUFBQSxTQUFTLEdBQUcsSUFBWjs7QUFDQSxXQUFNejhFLENBQU4sSUFBV2cxQixHQUFYLEVBQWlCO0FBQ2hCd25ELFFBQUFBLE1BQU0sQ0FBRWpXLEtBQUYsRUFBU0osRUFBVCxFQUFhbm1FLENBQWIsRUFBZ0JnMUIsR0FBRyxDQUFFaDFCLENBQUYsQ0FBbkIsRUFBMEIsSUFBMUIsRUFBZ0MwOEUsUUFBaEMsRUFBMENoNUIsR0FBMUMsQ0FBTjtBQUNBLE9BSmdDLENBTWxDOztBQUNDLEtBUEQsTUFPTyxJQUFLdG1ELEtBQUssS0FBS21xRSxTQUFmLEVBQTJCO0FBQ2pDa1YsTUFBQUEsU0FBUyxHQUFHLElBQVo7O0FBRUEsVUFBSyxDQUFDcFgsVUFBVSxDQUFFam9FLEtBQUYsQ0FBaEIsRUFBNEI7QUFDM0JzbUQsUUFBQUEsR0FBRyxHQUFHLElBQU47QUFDQTs7QUFFRCxVQUFLaTVCLElBQUwsRUFBWTtBQUVYO0FBQ0EsWUFBS2o1QixHQUFMLEVBQVc7QUFDVnlpQixVQUFBQSxFQUFFLENBQUNsOUQsSUFBSCxDQUFTczlELEtBQVQsRUFBZ0JucEUsS0FBaEI7QUFDQStvRSxVQUFBQSxFQUFFLEdBQUcsSUFBTCxDQUZVLENBSVg7QUFDQyxTQUxELE1BS087QUFDTndXLFVBQUFBLElBQUksR0FBR3hXLEVBQVA7O0FBQ0FBLFVBQUFBLEVBQUUsR0FBRyxZQUFVUSxJQUFWLEVBQWdCemlCLElBQWhCLEVBQXNCOW1ELEtBQXRCLEVBQThCO0FBQ2xDLG1CQUFPdS9FLElBQUksQ0FBQzF6RSxJQUFMLENBQVdpOUQsTUFBTSxDQUFFUyxJQUFGLENBQWpCLEVBQTJCdnBFLEtBQTNCLENBQVA7QUFDQSxXQUZEO0FBR0E7QUFDRDs7QUFFRCxVQUFLK29FLEVBQUwsRUFBVTtBQUNULGVBQVFubUUsQ0FBQyxHQUFHaW5FLEdBQVosRUFBaUJqbkUsQ0FBQyxFQUFsQixFQUF1QjtBQUN0Qm1tRSxVQUFBQSxFQUFFLENBQ0RJLEtBQUssQ0FBRXZtRSxDQUFGLENBREosRUFDV2cxQixHQURYLEVBQ2dCMHVCLEdBQUcsR0FDbkJ0bUQsS0FEbUIsR0FFbkJBLEtBQUssQ0FBQzZMLElBQU4sQ0FBWXM5RCxLQUFLLENBQUV2bUUsQ0FBRixDQUFqQixFQUF3QkEsQ0FBeEIsRUFBMkJtbUUsRUFBRSxDQUFFSSxLQUFLLENBQUV2bUUsQ0FBRixDQUFQLEVBQWNnMUIsR0FBZCxDQUE3QixDQUhBLENBQUY7QUFLQTtBQUNEO0FBQ0Q7O0FBRUQsUUFBS3luRCxTQUFMLEVBQWlCO0FBQ2hCLGFBQU9sVyxLQUFQO0FBQ0EsS0FqRHVFLENBbUR4RTs7O0FBQ0EsUUFBS29XLElBQUwsRUFBWTtBQUNYLGFBQU94VyxFQUFFLENBQUNsOUQsSUFBSCxDQUFTczlELEtBQVQsQ0FBUDtBQUNBOztBQUVELFdBQU9VLEdBQUcsR0FBR2QsRUFBRSxDQUFFSSxLQUFLLENBQUUsQ0FBRixDQUFQLEVBQWN2eEMsR0FBZCxDQUFMLEdBQTJCMG5ELFFBQXJDO0FBQ0EsR0F6REQsQ0EzZ0lpRixDQXVrSWpGOzs7QUFDQSxNQUFJRSxTQUFTLEdBQUcsT0FBaEI7QUFBQSxNQUNDQyxVQUFVLEdBQUcsV0FEZCxDQXhrSWlGLENBMmtJakY7O0FBQ0EsV0FBU0MsVUFBVCxDQUFxQkMsSUFBckIsRUFBMkJDLE1BQTNCLEVBQW9DO0FBQ25DLFdBQU9BLE1BQU0sQ0FBQzl3RCxXQUFQLEVBQVA7QUFDQSxHQTlrSWdGLENBZ2xJakY7QUFDQTtBQUNBOzs7QUFDQSxXQUFTK3dELFNBQVQsQ0FBb0JDLE1BQXBCLEVBQTZCO0FBQzVCLFdBQU9BLE1BQU0sQ0FBQzcrRSxPQUFQLENBQWdCdStFLFNBQWhCLEVBQTJCLEtBQTNCLEVBQW1DditFLE9BQW5DLENBQTRDdytFLFVBQTVDLEVBQXdEQyxVQUF4RCxDQUFQO0FBQ0E7O0FBQ0QsTUFBSUssVUFBVSxHQUFHLFNBQWJBLFVBQWEsQ0FBVUMsS0FBVixFQUFrQjtBQUVsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFPQSxLQUFLLENBQUMzNUUsUUFBTixLQUFtQixDQUFuQixJQUF3QjI1RSxLQUFLLENBQUMzNUUsUUFBTixLQUFtQixDQUEzQyxJQUFnRCxDQUFHLENBQUMyNUUsS0FBSyxDQUFDMzVFLFFBQWpFO0FBQ0EsR0FURDs7QUFjQSxXQUFTNDVFLElBQVQsR0FBZ0I7QUFDZixTQUFLN1YsT0FBTCxHQUFldEIsTUFBTSxDQUFDc0IsT0FBUCxHQUFpQjZWLElBQUksQ0FBQ0MsR0FBTCxFQUFoQztBQUNBOztBQUVERCxFQUFBQSxJQUFJLENBQUNDLEdBQUwsR0FBVyxDQUFYO0FBRUFELEVBQUFBLElBQUksQ0FBQ2hpRixTQUFMLEdBQWlCO0FBRWhCczNCLElBQUFBLEtBQUssRUFBRSxlQUFVeXFELEtBQVYsRUFBa0I7QUFFeEI7QUFDQSxVQUFJaGdGLEtBQUssR0FBR2dnRixLQUFLLENBQUUsS0FBSzVWLE9BQVAsQ0FBakIsQ0FId0IsQ0FLeEI7O0FBQ0EsVUFBSyxDQUFDcHFFLEtBQU4sRUFBYztBQUNiQSxRQUFBQSxLQUFLLEdBQUcsRUFBUixDQURhLENBR2I7QUFDQTtBQUNBOztBQUNBLFlBQUsrL0UsVUFBVSxDQUFFQyxLQUFGLENBQWYsRUFBMkI7QUFFMUI7QUFDQTtBQUNBLGNBQUtBLEtBQUssQ0FBQzM1RSxRQUFYLEVBQXNCO0FBQ3JCMjVFLFlBQUFBLEtBQUssQ0FBRSxLQUFLNVYsT0FBUCxDQUFMLEdBQXdCcHFFLEtBQXhCLENBRHFCLENBR3RCO0FBQ0E7QUFDQTtBQUNDLFdBTkQsTUFNTztBQUNOOUIsWUFBQUEsTUFBTSxDQUFDZ1QsY0FBUCxDQUF1Qjh1RSxLQUF2QixFQUE4QixLQUFLNVYsT0FBbkMsRUFBNEM7QUFDM0NwcUUsY0FBQUEsS0FBSyxFQUFFQSxLQURvQztBQUUzQzAzQixjQUFBQSxZQUFZLEVBQUU7QUFGNkIsYUFBNUM7QUFJQTtBQUNEO0FBQ0Q7O0FBRUQsYUFBTzEzQixLQUFQO0FBQ0EsS0FsQ2U7QUFtQ2hCd00sSUFBQUEsR0FBRyxFQUFFLGFBQVV3ekUsS0FBVixFQUFpQi83RSxJQUFqQixFQUF1QmpFLEtBQXZCLEVBQStCO0FBQ25DLFVBQUlvekIsSUFBSjtBQUFBLFVBQ0NtQyxLQUFLLEdBQUcsS0FBS0EsS0FBTCxDQUFZeXFELEtBQVosQ0FEVCxDQURtQyxDQUluQztBQUNBOztBQUNBLFVBQUssT0FBTy83RSxJQUFQLEtBQWdCLFFBQXJCLEVBQWdDO0FBQy9Cc3hCLFFBQUFBLEtBQUssQ0FBRXNxRCxTQUFTLENBQUU1N0UsSUFBRixDQUFYLENBQUwsR0FBNkJqRSxLQUE3QixDQUQrQixDQUdoQztBQUNDLE9BSkQsTUFJTztBQUVOO0FBQ0EsYUFBTW96QixJQUFOLElBQWNudkIsSUFBZCxFQUFxQjtBQUNwQnN4QixVQUFBQSxLQUFLLENBQUVzcUQsU0FBUyxDQUFFenNELElBQUYsQ0FBWCxDQUFMLEdBQTZCbnZCLElBQUksQ0FBRW12QixJQUFGLENBQWpDO0FBQ0E7QUFDRDs7QUFDRCxhQUFPbUMsS0FBUDtBQUNBLEtBckRlO0FBc0RoQnBrQixJQUFBQSxHQUFHLEVBQUUsYUFBVTZ1RSxLQUFWLEVBQWlCcG9ELEdBQWpCLEVBQXVCO0FBQzNCLGFBQU9BLEdBQUcsS0FBS3V5QyxTQUFSLEdBQ04sS0FBSzUwQyxLQUFMLENBQVl5cUQsS0FBWixDQURNLEdBR047QUFDQUEsTUFBQUEsS0FBSyxDQUFFLEtBQUs1VixPQUFQLENBQUwsSUFBeUI0VixLQUFLLENBQUUsS0FBSzVWLE9BQVAsQ0FBTCxDQUF1QnlWLFNBQVMsQ0FBRWpvRCxHQUFGLENBQWhDLENBSjFCO0FBS0EsS0E1RGU7QUE2RGhCd25ELElBQUFBLE1BQU0sRUFBRSxnQkFBVVksS0FBVixFQUFpQnBvRCxHQUFqQixFQUFzQjUzQixLQUF0QixFQUE4QjtBQUVyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBSzQzQixHQUFHLEtBQUt1eUMsU0FBUixJQUNDdnlDLEdBQUcsSUFBSSxPQUFPQSxHQUFQLEtBQWUsUUFBeEIsSUFBc0M1M0IsS0FBSyxLQUFLbXFFLFNBRHBELEVBQ2tFO0FBRWpFLGVBQU8sS0FBS2g1RCxHQUFMLENBQVU2dUUsS0FBVixFQUFpQnBvRCxHQUFqQixDQUFQO0FBQ0EsT0FqQm9DLENBbUJyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBLFdBQUtwckIsR0FBTCxDQUFVd3pFLEtBQVYsRUFBaUJwb0QsR0FBakIsRUFBc0I1M0IsS0FBdEIsRUF6QnFDLENBMkJyQztBQUNBOztBQUNBLGFBQU9BLEtBQUssS0FBS21xRSxTQUFWLEdBQXNCbnFFLEtBQXRCLEdBQThCNDNCLEdBQXJDO0FBQ0EsS0EzRmU7QUE0RmhCbjBCLElBQUFBLE1BQU0sRUFBRSxnQkFBVXU4RSxLQUFWLEVBQWlCcG9ELEdBQWpCLEVBQXVCO0FBQzlCLFVBQUloMUIsQ0FBSjtBQUFBLFVBQ0MyeUIsS0FBSyxHQUFHeXFELEtBQUssQ0FBRSxLQUFLNVYsT0FBUCxDQURkOztBQUdBLFVBQUs3MEMsS0FBSyxLQUFLNDBDLFNBQWYsRUFBMkI7QUFDMUI7QUFDQTs7QUFFRCxVQUFLdnlDLEdBQUcsS0FBS3V5QyxTQUFiLEVBQXlCO0FBRXhCO0FBQ0EsWUFBS3pwRSxLQUFLLENBQUNDLE9BQU4sQ0FBZWkzQixHQUFmLENBQUwsRUFBNEI7QUFFM0I7QUFDQTtBQUNBQSxVQUFBQSxHQUFHLEdBQUdBLEdBQUcsQ0FBQ3pXLEdBQUosQ0FBUzArRCxTQUFULENBQU47QUFDQSxTQUxELE1BS087QUFDTmpvRCxVQUFBQSxHQUFHLEdBQUdpb0QsU0FBUyxDQUFFam9ELEdBQUYsQ0FBZixDQURNLENBR047QUFDQTs7QUFDQUEsVUFBQUEsR0FBRyxHQUFHQSxHQUFHLElBQUlyQyxLQUFQLEdBQ0wsQ0FBRXFDLEdBQUYsQ0FESyxHQUVIQSxHQUFHLENBQUNqUSxLQUFKLENBQVd3ekQsYUFBWCxLQUE4QixFQUZqQztBQUdBOztBQUVEdjRFLFFBQUFBLENBQUMsR0FBR2cxQixHQUFHLENBQUMvMEIsTUFBUjs7QUFFQSxlQUFRRCxDQUFDLEVBQVQsRUFBYztBQUNiLGlCQUFPMnlCLEtBQUssQ0FBRXFDLEdBQUcsQ0FBRWgxQixDQUFGLENBQUwsQ0FBWjtBQUNBO0FBQ0QsT0EvQjZCLENBaUM5Qjs7O0FBQ0EsVUFBS2cxQixHQUFHLEtBQUt1eUMsU0FBUixJQUFxQnJCLE1BQU0sQ0FBQzRCLGFBQVAsQ0FBc0JuMUMsS0FBdEIsQ0FBMUIsRUFBMEQ7QUFFekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFLeXFELEtBQUssQ0FBQzM1RSxRQUFYLEVBQXNCO0FBQ3JCMjVFLFVBQUFBLEtBQUssQ0FBRSxLQUFLNVYsT0FBUCxDQUFMLEdBQXdCRCxTQUF4QjtBQUNBLFNBRkQsTUFFTztBQUNOLGlCQUFPNlYsS0FBSyxDQUFFLEtBQUs1VixPQUFQLENBQVo7QUFDQTtBQUNEO0FBQ0QsS0ExSWU7QUEySWhCK1YsSUFBQUEsT0FBTyxFQUFFLGlCQUFVSCxLQUFWLEVBQWtCO0FBQzFCLFVBQUl6cUQsS0FBSyxHQUFHeXFELEtBQUssQ0FBRSxLQUFLNVYsT0FBUCxDQUFqQjtBQUNBLGFBQU83MEMsS0FBSyxLQUFLNDBDLFNBQVYsSUFBdUIsQ0FBQ3JCLE1BQU0sQ0FBQzRCLGFBQVAsQ0FBc0JuMUMsS0FBdEIsQ0FBL0I7QUFDQTtBQTlJZSxHQUFqQjtBQWdKQSxNQUFJNnFELFFBQVEsR0FBRyxJQUFJSCxJQUFKLEVBQWY7QUFFQSxNQUFJSSxRQUFRLEdBQUcsSUFBSUosSUFBSixFQUFmLENBNXZJaUYsQ0Fnd0lqRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsTUFBSUssTUFBTSxHQUFHLCtCQUFiO0FBQUEsTUFDQ0MsVUFBVSxHQUFHLFFBRGQ7O0FBR0EsV0FBU0MsT0FBVCxDQUFrQnY4RSxJQUFsQixFQUF5QjtBQUN4QixRQUFLQSxJQUFJLEtBQUssTUFBZCxFQUF1QjtBQUN0QixhQUFPLElBQVA7QUFDQTs7QUFFRCxRQUFLQSxJQUFJLEtBQUssT0FBZCxFQUF3QjtBQUN2QixhQUFPLEtBQVA7QUFDQTs7QUFFRCxRQUFLQSxJQUFJLEtBQUssTUFBZCxFQUF1QjtBQUN0QixhQUFPLElBQVA7QUFDQSxLQVh1QixDQWF4Qjs7O0FBQ0EsUUFBS0EsSUFBSSxLQUFLLENBQUNBLElBQUQsR0FBUSxFQUF0QixFQUEyQjtBQUMxQixhQUFPLENBQUNBLElBQVI7QUFDQTs7QUFFRCxRQUFLcThFLE1BQU0sQ0FBQ3AwRSxJQUFQLENBQWFqSSxJQUFiLENBQUwsRUFBMkI7QUFDMUIsYUFBT3c4RSxJQUFJLENBQUNDLEtBQUwsQ0FBWXo4RSxJQUFaLENBQVA7QUFDQTs7QUFFRCxXQUFPQSxJQUFQO0FBQ0E7O0FBRUQsV0FBUzA4RSxRQUFULENBQW1CcFgsSUFBbkIsRUFBeUIzeEMsR0FBekIsRUFBOEIzekIsSUFBOUIsRUFBcUM7QUFDcEMsUUFBSXVoQixJQUFKLENBRG9DLENBR3BDO0FBQ0E7O0FBQ0EsUUFBS3ZoQixJQUFJLEtBQUtrbUUsU0FBVCxJQUFzQlosSUFBSSxDQUFDbGpFLFFBQUwsS0FBa0IsQ0FBN0MsRUFBaUQ7QUFDaERtZixNQUFBQSxJQUFJLEdBQUcsVUFBVW9TLEdBQUcsQ0FBQzMyQixPQUFKLENBQWFzL0UsVUFBYixFQUF5QixLQUF6QixFQUFpQ2o1RSxXQUFqQyxFQUFqQjtBQUNBckQsTUFBQUEsSUFBSSxHQUFHc2xFLElBQUksQ0FBQ3Y5RCxZQUFMLENBQW1Cd1osSUFBbkIsQ0FBUDs7QUFFQSxVQUFLLE9BQU92aEIsSUFBUCxLQUFnQixRQUFyQixFQUFnQztBQUMvQixZQUFJO0FBQ0hBLFVBQUFBLElBQUksR0FBR3U4RSxPQUFPLENBQUV2OEUsSUFBRixDQUFkO0FBQ0EsU0FGRCxDQUVFLE9BQVFsRCxDQUFSLEVBQVksQ0FBRSxDQUhlLENBSy9COzs7QUFDQXMvRSxRQUFBQSxRQUFRLENBQUM3ekUsR0FBVCxDQUFjKzhELElBQWQsRUFBb0IzeEMsR0FBcEIsRUFBeUIzekIsSUFBekI7QUFDQSxPQVBELE1BT087QUFDTkEsUUFBQUEsSUFBSSxHQUFHa21FLFNBQVA7QUFDQTtBQUNEOztBQUNELFdBQU9sbUUsSUFBUDtBQUNBOztBQUVENmtFLEVBQUFBLE1BQU0sQ0FBQ2dCLE1BQVAsQ0FBZTtBQUNkcVcsSUFBQUEsT0FBTyxFQUFFLGlCQUFVNVcsSUFBVixFQUFpQjtBQUN6QixhQUFPOFcsUUFBUSxDQUFDRixPQUFULENBQWtCNVcsSUFBbEIsS0FBNEI2VyxRQUFRLENBQUNELE9BQVQsQ0FBa0I1VyxJQUFsQixDQUFuQztBQUNBLEtBSGE7QUFLZHRsRSxJQUFBQSxJQUFJLEVBQUUsY0FBVXNsRSxJQUFWLEVBQWdCL2pELElBQWhCLEVBQXNCdmhCLEtBQXRCLEVBQTZCO0FBQ2xDLGFBQU9vOEUsUUFBUSxDQUFDakIsTUFBVCxDQUFpQjdWLElBQWpCLEVBQXVCL2pELElBQXZCLEVBQTZCdmhCLEtBQTdCLENBQVA7QUFDQSxLQVBhO0FBU2QyOEUsSUFBQUEsVUFBVSxFQUFFLG9CQUFVclgsSUFBVixFQUFnQi9qRCxJQUFoQixFQUF1QjtBQUNsQzY2RCxNQUFBQSxRQUFRLENBQUM1OEUsTUFBVCxDQUFpQjhsRSxJQUFqQixFQUF1Qi9qRCxJQUF2QjtBQUNBLEtBWGE7QUFhZDtBQUNBO0FBQ0FxN0QsSUFBQUEsS0FBSyxFQUFFLGVBQVV0WCxJQUFWLEVBQWdCL2pELElBQWhCLEVBQXNCdmhCLElBQXRCLEVBQTZCO0FBQ25DLGFBQU9tOEUsUUFBUSxDQUFDaEIsTUFBVCxDQUFpQjdWLElBQWpCLEVBQXVCL2pELElBQXZCLEVBQTZCdmhCLElBQTdCLENBQVA7QUFDQSxLQWpCYTtBQW1CZDY4RSxJQUFBQSxXQUFXLEVBQUUscUJBQVV2WCxJQUFWLEVBQWdCL2pELElBQWhCLEVBQXVCO0FBQ25DNDZELE1BQUFBLFFBQVEsQ0FBQzM4RSxNQUFULENBQWlCOGxFLElBQWpCLEVBQXVCL2pELElBQXZCO0FBQ0E7QUFyQmEsR0FBZjtBQXdCQXNqRCxFQUFBQSxNQUFNLENBQUNDLEVBQVAsQ0FBVWUsTUFBVixDQUFrQjtBQUNqQjdsRSxJQUFBQSxJQUFJLEVBQUUsY0FBVTJ6QixHQUFWLEVBQWU1M0IsS0FBZixFQUF1QjtBQUM1QixVQUFJNEMsQ0FBSjtBQUFBLFVBQU80aUIsSUFBUDtBQUFBLFVBQWF2aEIsSUFBYjtBQUFBLFVBQ0NzbEUsSUFBSSxHQUFHLEtBQU0sQ0FBTixDQURSO0FBQUEsVUFFQ3ZqRCxLQUFLLEdBQUd1akQsSUFBSSxJQUFJQSxJQUFJLENBQUNoa0QsVUFGdEIsQ0FENEIsQ0FLNUI7O0FBQ0EsVUFBS3FTLEdBQUcsS0FBS3V5QyxTQUFiLEVBQXlCO0FBQ3hCLFlBQUssS0FBS3RuRSxNQUFWLEVBQW1CO0FBQ2xCb0IsVUFBQUEsSUFBSSxHQUFHbzhFLFFBQVEsQ0FBQ2x2RSxHQUFULENBQWNvNEQsSUFBZCxDQUFQOztBQUVBLGNBQUtBLElBQUksQ0FBQ2xqRSxRQUFMLEtBQWtCLENBQWxCLElBQXVCLENBQUMrNUUsUUFBUSxDQUFDanZFLEdBQVQsQ0FBY280RCxJQUFkLEVBQW9CLGNBQXBCLENBQTdCLEVBQW9FO0FBQ25FM21FLFlBQUFBLENBQUMsR0FBR29qQixLQUFLLENBQUNuakIsTUFBVjs7QUFDQSxtQkFBUUQsQ0FBQyxFQUFULEVBQWM7QUFFYjtBQUNBO0FBQ0Esa0JBQUtvakIsS0FBSyxDQUFFcGpCLENBQUYsQ0FBVixFQUFrQjtBQUNqQjRpQixnQkFBQUEsSUFBSSxHQUFHUSxLQUFLLENBQUVwakIsQ0FBRixDQUFMLENBQVc0aUIsSUFBbEI7O0FBQ0Esb0JBQUtBLElBQUksQ0FBQ25WLE9BQUwsQ0FBYyxPQUFkLE1BQTRCLENBQWpDLEVBQXFDO0FBQ3BDbVYsa0JBQUFBLElBQUksR0FBR3E2RCxTQUFTLENBQUVyNkQsSUFBSSxDQUFDL0IsS0FBTCxDQUFZLENBQVosQ0FBRixDQUFoQjtBQUNBazlELGtCQUFBQSxRQUFRLENBQUVwWCxJQUFGLEVBQVEvakQsSUFBUixFQUFjdmhCLElBQUksQ0FBRXVoQixJQUFGLENBQWxCLENBQVI7QUFDQTtBQUNEO0FBQ0Q7O0FBQ0Q0NkQsWUFBQUEsUUFBUSxDQUFDNXpFLEdBQVQsQ0FBYys4RCxJQUFkLEVBQW9CLGNBQXBCLEVBQW9DLElBQXBDO0FBQ0E7QUFDRDs7QUFFRCxlQUFPdGxFLElBQVA7QUFDQSxPQTdCMkIsQ0ErQjVCOzs7QUFDQSxVQUFLLFFBQU8yekIsR0FBUCxNQUFlLFFBQXBCLEVBQStCO0FBQzlCLGVBQU8sS0FBSzJ0QixJQUFMLENBQVcsWUFBVztBQUM1Qjg2QixVQUFBQSxRQUFRLENBQUM3ekUsR0FBVCxDQUFjLElBQWQsRUFBb0JvckIsR0FBcEI7QUFDQSxTQUZNLENBQVA7QUFHQTs7QUFFRCxhQUFPd25ELE1BQU0sQ0FBRSxJQUFGLEVBQVEsVUFBVXAvRSxLQUFWLEVBQWtCO0FBQ3RDLFlBQUlpRSxJQUFKLENBRHNDLENBR3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0EsWUFBS3NsRSxJQUFJLElBQUl2cEUsS0FBSyxLQUFLbXFFLFNBQXZCLEVBQW1DO0FBRWxDO0FBQ0E7QUFDQWxtRSxVQUFBQSxJQUFJLEdBQUdvOEUsUUFBUSxDQUFDbHZFLEdBQVQsQ0FBY280RCxJQUFkLEVBQW9CM3hDLEdBQXBCLENBQVA7O0FBQ0EsY0FBSzN6QixJQUFJLEtBQUtrbUUsU0FBZCxFQUEwQjtBQUN6QixtQkFBT2xtRSxJQUFQO0FBQ0EsV0FQaUMsQ0FTbEM7QUFDQTs7O0FBQ0FBLFVBQUFBLElBQUksR0FBRzA4RSxRQUFRLENBQUVwWCxJQUFGLEVBQVEzeEMsR0FBUixDQUFmOztBQUNBLGNBQUszekIsSUFBSSxLQUFLa21FLFNBQWQsRUFBMEI7QUFDekIsbUJBQU9sbUUsSUFBUDtBQUNBLFdBZGlDLENBZ0JsQzs7O0FBQ0E7QUFDQSxTQTFCcUMsQ0E0QnRDOzs7QUFDQSxhQUFLc2hELElBQUwsQ0FBVyxZQUFXO0FBRXJCO0FBQ0E4NkIsVUFBQUEsUUFBUSxDQUFDN3pFLEdBQVQsQ0FBYyxJQUFkLEVBQW9Cb3JCLEdBQXBCLEVBQXlCNTNCLEtBQXpCO0FBQ0EsU0FKRDtBQUtBLE9BbENZLEVBa0NWLElBbENVLEVBa0NKQSxLQWxDSSxFQWtDR3VPLFNBQVMsQ0FBQzFMLE1BQVYsR0FBbUIsQ0FsQ3RCLEVBa0N5QixJQWxDekIsRUFrQytCLElBbEMvQixDQUFiO0FBbUNBLEtBMUVnQjtBQTRFakIrOUUsSUFBQUEsVUFBVSxFQUFFLG9CQUFVaHBELEdBQVYsRUFBZ0I7QUFDM0IsYUFBTyxLQUFLMnRCLElBQUwsQ0FBVyxZQUFXO0FBQzVCODZCLFFBQUFBLFFBQVEsQ0FBQzU4RSxNQUFULENBQWlCLElBQWpCLEVBQXVCbTBCLEdBQXZCO0FBQ0EsT0FGTSxDQUFQO0FBR0E7QUFoRmdCLEdBQWxCO0FBb0ZBa3hDLEVBQUFBLE1BQU0sQ0FBQ2dCLE1BQVAsQ0FBZTtBQUNkOFIsSUFBQUEsS0FBSyxFQUFFLGVBQVVyUyxJQUFWLEVBQWdCMW9FLElBQWhCLEVBQXNCb0QsSUFBdEIsRUFBNkI7QUFDbkMsVUFBSTIzRSxLQUFKOztBQUVBLFVBQUtyUyxJQUFMLEVBQVk7QUFDWDFvRSxRQUFBQSxJQUFJLEdBQUcsQ0FBRUEsSUFBSSxJQUFJLElBQVYsSUFBbUIsT0FBMUI7QUFDQSs2RSxRQUFBQSxLQUFLLEdBQUd3RSxRQUFRLENBQUNqdkUsR0FBVCxDQUFjbzRELElBQWQsRUFBb0Ixb0UsSUFBcEIsQ0FBUixDQUZXLENBSVg7O0FBQ0EsWUFBS29ELElBQUwsRUFBWTtBQUNYLGNBQUssQ0FBQzIzRSxLQUFELElBQVVsN0UsS0FBSyxDQUFDQyxPQUFOLENBQWVzRCxJQUFmLENBQWYsRUFBdUM7QUFDdEMyM0UsWUFBQUEsS0FBSyxHQUFHd0UsUUFBUSxDQUFDaEIsTUFBVCxDQUFpQjdWLElBQWpCLEVBQXVCMW9FLElBQXZCLEVBQTZCaW9FLE1BQU0sQ0FBQytCLFNBQVAsQ0FBa0I1bUUsSUFBbEIsQ0FBN0IsQ0FBUjtBQUNBLFdBRkQsTUFFTztBQUNOMjNFLFlBQUFBLEtBQUssQ0FBQ3Y0RSxJQUFOLENBQVlZLElBQVo7QUFDQTtBQUNEOztBQUNELGVBQU8yM0UsS0FBSyxJQUFJLEVBQWhCO0FBQ0E7QUFDRCxLQWxCYTtBQW9CZG1GLElBQUFBLE9BQU8sRUFBRSxpQkFBVXhYLElBQVYsRUFBZ0Ixb0UsSUFBaEIsRUFBdUI7QUFDL0JBLE1BQUFBLElBQUksR0FBR0EsSUFBSSxJQUFJLElBQWY7O0FBRUEsVUFBSSs2RSxLQUFLLEdBQUc5UyxNQUFNLENBQUM4UyxLQUFQLENBQWNyUyxJQUFkLEVBQW9CMW9FLElBQXBCLENBQVo7QUFBQSxVQUNDbWdGLFdBQVcsR0FBR3BGLEtBQUssQ0FBQy80RSxNQURyQjtBQUFBLFVBRUNrbUUsRUFBRSxHQUFHNlMsS0FBSyxDQUFDcjRELEtBQU4sRUFGTjtBQUFBLFVBR0MwOUQsS0FBSyxHQUFHblksTUFBTSxDQUFDb1ksV0FBUCxDQUFvQjNYLElBQXBCLEVBQTBCMW9FLElBQTFCLENBSFQ7QUFBQSxVQUlDb3lDLElBQUksR0FBRyxTQUFQQSxJQUFPLEdBQVc7QUFDakI2MUIsUUFBQUEsTUFBTSxDQUFDaVksT0FBUCxDQUFnQnhYLElBQWhCLEVBQXNCMW9FLElBQXRCO0FBQ0EsT0FORixDQUgrQixDQVcvQjs7O0FBQ0EsVUFBS2tvRSxFQUFFLEtBQUssWUFBWixFQUEyQjtBQUMxQkEsUUFBQUEsRUFBRSxHQUFHNlMsS0FBSyxDQUFDcjRELEtBQU4sRUFBTDtBQUNBeTlELFFBQUFBLFdBQVc7QUFDWDs7QUFFRCxVQUFLalksRUFBTCxFQUFVO0FBRVQ7QUFDQTtBQUNBLFlBQUtsb0UsSUFBSSxLQUFLLElBQWQsRUFBcUI7QUFDcEIrNkUsVUFBQUEsS0FBSyxDQUFDM3FELE9BQU4sQ0FBZSxZQUFmO0FBQ0EsU0FOUSxDQVFUOzs7QUFDQSxlQUFPZ3dELEtBQUssQ0FBQ0UsSUFBYjtBQUNBcFksUUFBQUEsRUFBRSxDQUFDbDlELElBQUgsQ0FBUzA5RCxJQUFULEVBQWV0MkIsSUFBZixFQUFxQmd1QyxLQUFyQjtBQUNBOztBQUVELFVBQUssQ0FBQ0QsV0FBRCxJQUFnQkMsS0FBckIsRUFBNkI7QUFDNUJBLFFBQUFBLEtBQUssQ0FBQ2pGLEtBQU4sQ0FBWUYsSUFBWjtBQUNBO0FBQ0QsS0FyRGE7QUF1RGQ7QUFDQW9GLElBQUFBLFdBQVcsRUFBRSxxQkFBVTNYLElBQVYsRUFBZ0Ixb0UsSUFBaEIsRUFBdUI7QUFDbkMsVUFBSSsyQixHQUFHLEdBQUcvMkIsSUFBSSxHQUFHLFlBQWpCO0FBQ0EsYUFBT3UvRSxRQUFRLENBQUNqdkUsR0FBVCxDQUFjbzRELElBQWQsRUFBb0IzeEMsR0FBcEIsS0FBNkJ3b0QsUUFBUSxDQUFDaEIsTUFBVCxDQUFpQjdWLElBQWpCLEVBQXVCM3hDLEdBQXZCLEVBQTRCO0FBQy9Eb2tELFFBQUFBLEtBQUssRUFBRWxULE1BQU0sQ0FBQzBTLFNBQVAsQ0FBa0IsYUFBbEIsRUFBa0NqNEUsR0FBbEMsQ0FBdUMsWUFBVztBQUN4RDY4RSxVQUFBQSxRQUFRLENBQUMzOEUsTUFBVCxDQUFpQjhsRSxJQUFqQixFQUF1QixDQUFFMW9FLElBQUksR0FBRyxPQUFULEVBQWtCKzJCLEdBQWxCLENBQXZCO0FBQ0EsU0FGTTtBQUR3RCxPQUE1QixDQUFwQztBQUtBO0FBL0RhLEdBQWY7QUFrRUFreEMsRUFBQUEsTUFBTSxDQUFDQyxFQUFQLENBQVVlLE1BQVYsQ0FBa0I7QUFDakI4UixJQUFBQSxLQUFLLEVBQUUsZUFBVS82RSxJQUFWLEVBQWdCb0QsSUFBaEIsRUFBdUI7QUFDN0IsVUFBSWd4RCxNQUFNLEdBQUcsQ0FBYjs7QUFFQSxVQUFLLE9BQU9wMEQsSUFBUCxLQUFnQixRQUFyQixFQUFnQztBQUMvQm9ELFFBQUFBLElBQUksR0FBR3BELElBQVA7QUFDQUEsUUFBQUEsSUFBSSxHQUFHLElBQVA7QUFDQW8wRCxRQUFBQSxNQUFNO0FBQ047O0FBRUQsVUFBSzFtRCxTQUFTLENBQUMxTCxNQUFWLEdBQW1Cb3lELE1BQXhCLEVBQWlDO0FBQ2hDLGVBQU82VCxNQUFNLENBQUM4UyxLQUFQLENBQWMsS0FBTSxDQUFOLENBQWQsRUFBeUIvNkUsSUFBekIsQ0FBUDtBQUNBOztBQUVELGFBQU9vRCxJQUFJLEtBQUtrbUUsU0FBVCxHQUNOLElBRE0sR0FFTixLQUFLNWtCLElBQUwsQ0FBVyxZQUFXO0FBQ3JCLFlBQUlxMkIsS0FBSyxHQUFHOVMsTUFBTSxDQUFDOFMsS0FBUCxDQUFjLElBQWQsRUFBb0IvNkUsSUFBcEIsRUFBMEJvRCxJQUExQixDQUFaLENBRHFCLENBR3JCOztBQUNBNmtFLFFBQUFBLE1BQU0sQ0FBQ29ZLFdBQVAsQ0FBb0IsSUFBcEIsRUFBMEJyZ0YsSUFBMUI7O0FBRUEsWUFBS0EsSUFBSSxLQUFLLElBQVQsSUFBaUIrNkUsS0FBSyxDQUFFLENBQUYsQ0FBTCxLQUFlLFlBQXJDLEVBQW9EO0FBQ25EOVMsVUFBQUEsTUFBTSxDQUFDaVksT0FBUCxDQUFnQixJQUFoQixFQUFzQmxnRixJQUF0QjtBQUNBO0FBQ0QsT0FURCxDQUZEO0FBWUEsS0ExQmdCO0FBMkJqQmtnRixJQUFBQSxPQUFPLEVBQUUsaUJBQVVsZ0YsSUFBVixFQUFpQjtBQUN6QixhQUFPLEtBQUswa0QsSUFBTCxDQUFXLFlBQVc7QUFDNUJ1akIsUUFBQUEsTUFBTSxDQUFDaVksT0FBUCxDQUFnQixJQUFoQixFQUFzQmxnRixJQUF0QjtBQUNBLE9BRk0sQ0FBUDtBQUdBLEtBL0JnQjtBQWdDakJ1Z0YsSUFBQUEsVUFBVSxFQUFFLG9CQUFVdmdGLElBQVYsRUFBaUI7QUFDNUIsYUFBTyxLQUFLKzZFLEtBQUwsQ0FBWS82RSxJQUFJLElBQUksSUFBcEIsRUFBMEIsRUFBMUIsQ0FBUDtBQUNBLEtBbENnQjtBQW9DakI7QUFDQTtBQUNBNDdFLElBQUFBLE9BQU8sRUFBRSxpQkFBVTU3RSxJQUFWLEVBQWdCdUIsR0FBaEIsRUFBc0I7QUFDOUIsVUFBSTR2RSxHQUFKO0FBQUEsVUFDQ3FQLEtBQUssR0FBRyxDQURUO0FBQUEsVUFFQ0MsS0FBSyxHQUFHeFksTUFBTSxDQUFDNlQsUUFBUCxFQUZUO0FBQUEsVUFHQ2g2RSxRQUFRLEdBQUcsSUFIWjtBQUFBLFVBSUNDLENBQUMsR0FBRyxLQUFLQyxNQUpWO0FBQUEsVUFLQ3l1RCxPQUFPLEdBQUcsU0FBVkEsT0FBVSxHQUFXO0FBQ3BCLFlBQUssQ0FBRyxHQUFFK3ZCLEtBQVYsRUFBb0I7QUFDbkJDLFVBQUFBLEtBQUssQ0FBQ3pELFdBQU4sQ0FBbUJsN0UsUUFBbkIsRUFBNkIsQ0FBRUEsUUFBRixDQUE3QjtBQUNBO0FBQ0QsT0FURjs7QUFXQSxVQUFLLE9BQU85QixJQUFQLEtBQWdCLFFBQXJCLEVBQWdDO0FBQy9CdUIsUUFBQUEsR0FBRyxHQUFHdkIsSUFBTjtBQUNBQSxRQUFBQSxJQUFJLEdBQUdzcEUsU0FBUDtBQUNBOztBQUNEdHBFLE1BQUFBLElBQUksR0FBR0EsSUFBSSxJQUFJLElBQWY7O0FBRUEsYUFBUStCLENBQUMsRUFBVCxFQUFjO0FBQ2JvdkUsUUFBQUEsR0FBRyxHQUFHb08sUUFBUSxDQUFDanZFLEdBQVQsQ0FBY3hPLFFBQVEsQ0FBRUMsQ0FBRixDQUF0QixFQUE2Qi9CLElBQUksR0FBRyxZQUFwQyxDQUFOOztBQUNBLFlBQUtteEUsR0FBRyxJQUFJQSxHQUFHLENBQUNnSyxLQUFoQixFQUF3QjtBQUN2QnFGLFVBQUFBLEtBQUs7QUFDTHJQLFVBQUFBLEdBQUcsQ0FBQ2dLLEtBQUosQ0FBVXo0RSxHQUFWLENBQWUrdEQsT0FBZjtBQUNBO0FBQ0Q7O0FBQ0RBLE1BQUFBLE9BQU87QUFDUCxhQUFPZ3dCLEtBQUssQ0FBQzdFLE9BQU4sQ0FBZXI2RSxHQUFmLENBQVA7QUFDQTtBQWpFZ0IsR0FBbEI7QUFtRUEsTUFBSW0vRSxJQUFJLEdBQUsscUNBQUYsQ0FBMENyOUQsTUFBckQ7QUFFQSxNQUFJczlELE9BQU8sR0FBRyxJQUFJMzFCLE1BQUosQ0FBWSxtQkFBbUIwMUIsSUFBbkIsR0FBMEIsYUFBdEMsRUFBcUQsR0FBckQsQ0FBZDtBQUdBLE1BQUlFLFNBQVMsR0FBRyxDQUFFLEtBQUYsRUFBUyxPQUFULEVBQWtCLFFBQWxCLEVBQTRCLE1BQTVCLENBQWhCO0FBRUEsTUFBSTk3RSxlQUFlLEdBQUd3SCxRQUFRLENBQUN4SCxlQUEvQjs7QUFJQyxNQUFJKzdFLFVBQVUsR0FBRyxvQkFBVW5ZLElBQVYsRUFBaUI7QUFDaEMsV0FBT1QsTUFBTSxDQUFDeUQsUUFBUCxDQUFpQmhELElBQUksQ0FBQ2hoRSxhQUF0QixFQUFxQ2doRSxJQUFyQyxDQUFQO0FBQ0EsR0FGRjtBQUFBLE1BR0NvWSxRQUFRLEdBQUc7QUFBRUEsSUFBQUEsUUFBUSxFQUFFO0FBQVosR0FIWixDQXpqSmdGLENBOGpKaEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0EsTUFBS2g4RSxlQUFlLENBQUNpOEUsV0FBckIsRUFBbUM7QUFDbENGLElBQUFBLFVBQVUsR0FBRyxvQkFBVW5ZLElBQVYsRUFBaUI7QUFDN0IsYUFBT1QsTUFBTSxDQUFDeUQsUUFBUCxDQUFpQmhELElBQUksQ0FBQ2hoRSxhQUF0QixFQUFxQ2doRSxJQUFyQyxLQUNOQSxJQUFJLENBQUNxWSxXQUFMLENBQWtCRCxRQUFsQixNQUFpQ3BZLElBQUksQ0FBQ2hoRSxhQUR2QztBQUVBLEtBSEQ7QUFJQTs7QUFDRixNQUFJczVFLGtCQUFrQixHQUFHLFNBQXJCQSxrQkFBcUIsQ0FBVXRZLElBQVYsRUFBZ0Jsd0MsRUFBaEIsRUFBcUI7QUFFNUM7QUFDQTtBQUNBa3dDLElBQUFBLElBQUksR0FBR2x3QyxFQUFFLElBQUlrd0MsSUFBYixDQUo0QyxDQU01Qzs7QUFDQSxXQUFPQSxJQUFJLENBQUNwb0UsS0FBTCxDQUFXcU8sT0FBWCxLQUF1QixNQUF2QixJQUNOKzVELElBQUksQ0FBQ3BvRSxLQUFMLENBQVdxTyxPQUFYLEtBQXVCLEVBQXZCLElBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQWt5RSxJQUFBQSxVQUFVLENBQUVuWSxJQUFGLENBTlYsSUFRQVQsTUFBTSxDQUFDamhDLEdBQVAsQ0FBWTBoQyxJQUFaLEVBQWtCLFNBQWxCLE1BQWtDLE1BVG5DO0FBVUEsR0FqQkY7O0FBcUJBLFdBQVN1WSxTQUFULENBQW9CdlksSUFBcEIsRUFBMEJuMkMsSUFBMUIsRUFBZ0MydUQsVUFBaEMsRUFBNENqcEUsS0FBNUMsRUFBb0Q7QUFDbkQsUUFBSWtwRSxRQUFKO0FBQUEsUUFBYzc4QyxLQUFkO0FBQUEsUUFDQzg4QyxhQUFhLEdBQUcsRUFEakI7QUFBQSxRQUVDcnNCLFlBQVksR0FBRzk4QyxLQUFLLEdBQ25CLFlBQVc7QUFDVixhQUFPQSxLQUFLLENBQUM0M0QsR0FBTixFQUFQO0FBQ0EsS0FIa0IsR0FJbkIsWUFBVztBQUNWLGFBQU81SCxNQUFNLENBQUNqaEMsR0FBUCxDQUFZMGhDLElBQVosRUFBa0JuMkMsSUFBbEIsRUFBd0IsRUFBeEIsQ0FBUDtBQUNBLEtBUkg7QUFBQSxRQVNDOHVELE9BQU8sR0FBR3RzQixZQUFZLEVBVHZCO0FBQUEsUUFVQ3hoRCxJQUFJLEdBQUcydEUsVUFBVSxJQUFJQSxVQUFVLENBQUUsQ0FBRixDQUF4QixLQUFtQ2paLE1BQU0sQ0FBQ3FaLFNBQVAsQ0FBa0IvdUQsSUFBbEIsSUFBMkIsRUFBM0IsR0FBZ0MsSUFBbkUsQ0FWUjtBQUFBLFFBWUM7QUFDQWd2RCxJQUFBQSxhQUFhLEdBQUc3WSxJQUFJLENBQUNsakUsUUFBTCxLQUNieWlFLE1BQU0sQ0FBQ3FaLFNBQVAsQ0FBa0IvdUQsSUFBbEIsS0FBNEJoZixJQUFJLEtBQUssSUFBVCxJQUFpQixDQUFDOHRFLE9BRGpDLEtBRWZWLE9BQU8sQ0FBQ2g5QixJQUFSLENBQWNza0IsTUFBTSxDQUFDamhDLEdBQVAsQ0FBWTBoQyxJQUFaLEVBQWtCbjJDLElBQWxCLENBQWQsQ0FmRjs7QUFpQkEsUUFBS2d2RCxhQUFhLElBQUlBLGFBQWEsQ0FBRSxDQUFGLENBQWIsS0FBdUJodUUsSUFBN0MsRUFBb0Q7QUFFbkQ7QUFDQTtBQUNBOHRFLE1BQUFBLE9BQU8sR0FBR0EsT0FBTyxHQUFHLENBQXBCLENBSm1ELENBTW5EOztBQUNBOXRFLE1BQUFBLElBQUksR0FBR0EsSUFBSSxJQUFJZ3VFLGFBQWEsQ0FBRSxDQUFGLENBQTVCLENBUG1ELENBU25EOztBQUNBQSxNQUFBQSxhQUFhLEdBQUcsQ0FBQ0YsT0FBRCxJQUFZLENBQTVCOztBQUVBLGFBQVFELGFBQWEsRUFBckIsRUFBMEI7QUFFekI7QUFDQTtBQUNBblosUUFBQUEsTUFBTSxDQUFDM25FLEtBQVAsQ0FBY29vRSxJQUFkLEVBQW9CbjJDLElBQXBCLEVBQTBCZ3ZELGFBQWEsR0FBR2h1RSxJQUExQzs7QUFDQSxZQUFLLENBQUUsSUFBSSt3QixLQUFOLEtBQWtCLEtBQU1BLEtBQUssR0FBR3l3QixZQUFZLEtBQUtzc0IsT0FBakIsSUFBNEIsR0FBMUMsQ0FBbEIsS0FBdUUsQ0FBNUUsRUFBZ0Y7QUFDL0VELFVBQUFBLGFBQWEsR0FBRyxDQUFoQjtBQUNBOztBQUNERyxRQUFBQSxhQUFhLEdBQUdBLGFBQWEsR0FBR2o5QyxLQUFoQztBQUVBOztBQUVEaTlDLE1BQUFBLGFBQWEsR0FBR0EsYUFBYSxHQUFHLENBQWhDO0FBQ0F0WixNQUFBQSxNQUFNLENBQUMzbkUsS0FBUCxDQUFjb29FLElBQWQsRUFBb0JuMkMsSUFBcEIsRUFBMEJndkQsYUFBYSxHQUFHaHVFLElBQTFDLEVBekJtRCxDQTJCbkQ7O0FBQ0EydEUsTUFBQUEsVUFBVSxHQUFHQSxVQUFVLElBQUksRUFBM0I7QUFDQTs7QUFFRCxRQUFLQSxVQUFMLEVBQWtCO0FBQ2pCSyxNQUFBQSxhQUFhLEdBQUcsQ0FBQ0EsYUFBRCxJQUFrQixDQUFDRixPQUFuQixJQUE4QixDQUE5QyxDQURpQixDQUdqQjs7QUFDQUYsTUFBQUEsUUFBUSxHQUFHRCxVQUFVLENBQUUsQ0FBRixDQUFWLEdBQ1ZLLGFBQWEsR0FBRyxDQUFFTCxVQUFVLENBQUUsQ0FBRixDQUFWLEdBQWtCLENBQXBCLElBQTBCQSxVQUFVLENBQUUsQ0FBRixDQUQxQyxHQUVWLENBQUNBLFVBQVUsQ0FBRSxDQUFGLENBRlo7O0FBR0EsVUFBS2pwRSxLQUFMLEVBQWE7QUFDWkEsUUFBQUEsS0FBSyxDQUFDMUUsSUFBTixHQUFhQSxJQUFiO0FBQ0EwRSxRQUFBQSxLQUFLLENBQUNtQixLQUFOLEdBQWNtb0UsYUFBZDtBQUNBdHBFLFFBQUFBLEtBQUssQ0FBQ2xOLEdBQU4sR0FBWW8yRSxRQUFaO0FBQ0E7QUFDRDs7QUFDRCxXQUFPQSxRQUFQO0FBQ0E7O0FBR0QsTUFBSUssaUJBQWlCLEdBQUcsRUFBeEI7O0FBRUEsV0FBU0MsaUJBQVQsQ0FBNEIvWSxJQUE1QixFQUFtQztBQUNsQyxRQUFJcHNELElBQUo7QUFBQSxRQUNDM1gsR0FBRyxHQUFHK2pFLElBQUksQ0FBQ2hoRSxhQURaO0FBQUEsUUFFQzRELFFBQVEsR0FBR285RCxJQUFJLENBQUNwOUQsUUFGakI7QUFBQSxRQUdDcUQsT0FBTyxHQUFHNnlFLGlCQUFpQixDQUFFbDJFLFFBQUYsQ0FINUI7O0FBS0EsUUFBS3FELE9BQUwsRUFBZTtBQUNkLGFBQU9BLE9BQVA7QUFDQTs7QUFFRDJOLElBQUFBLElBQUksR0FBRzNYLEdBQUcsQ0FBQ0ksSUFBSixDQUFTc0osV0FBVCxDQUFzQjFKLEdBQUcsQ0FBQ3RFLGFBQUosQ0FBbUJpTCxRQUFuQixDQUF0QixDQUFQO0FBQ0FxRCxJQUFBQSxPQUFPLEdBQUdzNUQsTUFBTSxDQUFDamhDLEdBQVAsQ0FBWTFxQixJQUFaLEVBQWtCLFNBQWxCLENBQVY7QUFFQUEsSUFBQUEsSUFBSSxDQUFDaFgsVUFBTCxDQUFnQmdKLFdBQWhCLENBQTZCZ08sSUFBN0I7O0FBRUEsUUFBSzNOLE9BQU8sS0FBSyxNQUFqQixFQUEwQjtBQUN6QkEsTUFBQUEsT0FBTyxHQUFHLE9BQVY7QUFDQTs7QUFDRDZ5RSxJQUFBQSxpQkFBaUIsQ0FBRWwyRSxRQUFGLENBQWpCLEdBQWdDcUQsT0FBaEM7QUFFQSxXQUFPQSxPQUFQO0FBQ0E7O0FBRUQsV0FBUyt5RSxRQUFULENBQW1CNS9FLFFBQW5CLEVBQTZCNi9FLElBQTdCLEVBQW9DO0FBQ25DLFFBQUloekUsT0FBSjtBQUFBLFFBQWErNUQsSUFBYjtBQUFBLFFBQ0N0MkMsTUFBTSxHQUFHLEVBRFY7QUFBQSxRQUVDeE8sS0FBSyxHQUFHLENBRlQ7QUFBQSxRQUdDNWhCLE1BQU0sR0FBR0YsUUFBUSxDQUFDRSxNQUhuQixDQURtQyxDQU1uQzs7QUFDQSxXQUFRNGhCLEtBQUssR0FBRzVoQixNQUFoQixFQUF3QjRoQixLQUFLLEVBQTdCLEVBQWtDO0FBQ2pDOGtELE1BQUFBLElBQUksR0FBRzVtRSxRQUFRLENBQUU4aEIsS0FBRixDQUFmOztBQUNBLFVBQUssQ0FBQzhrRCxJQUFJLENBQUNwb0UsS0FBWCxFQUFtQjtBQUNsQjtBQUNBOztBQUVEcU8sTUFBQUEsT0FBTyxHQUFHKzVELElBQUksQ0FBQ3BvRSxLQUFMLENBQVdxTyxPQUFyQjs7QUFDQSxVQUFLZ3pFLElBQUwsRUFBWTtBQUVYO0FBQ0E7QUFDQTtBQUNBLFlBQUtoekUsT0FBTyxLQUFLLE1BQWpCLEVBQTBCO0FBQ3pCeWpCLFVBQUFBLE1BQU0sQ0FBRXhPLEtBQUYsQ0FBTixHQUFrQjI3RCxRQUFRLENBQUNqdkUsR0FBVCxDQUFjbzRELElBQWQsRUFBb0IsU0FBcEIsS0FBbUMsSUFBckQ7O0FBQ0EsY0FBSyxDQUFDdDJDLE1BQU0sQ0FBRXhPLEtBQUYsQ0FBWixFQUF3QjtBQUN2QjhrRCxZQUFBQSxJQUFJLENBQUNwb0UsS0FBTCxDQUFXcU8sT0FBWCxHQUFxQixFQUFyQjtBQUNBO0FBQ0Q7O0FBQ0QsWUFBSys1RCxJQUFJLENBQUNwb0UsS0FBTCxDQUFXcU8sT0FBWCxLQUF1QixFQUF2QixJQUE2QnF5RSxrQkFBa0IsQ0FBRXRZLElBQUYsQ0FBcEQsRUFBK0Q7QUFDOUR0MkMsVUFBQUEsTUFBTSxDQUFFeE8sS0FBRixDQUFOLEdBQWtCNjlELGlCQUFpQixDQUFFL1ksSUFBRixDQUFuQztBQUNBO0FBQ0QsT0FkRCxNQWNPO0FBQ04sWUFBSy81RCxPQUFPLEtBQUssTUFBakIsRUFBMEI7QUFDekJ5akIsVUFBQUEsTUFBTSxDQUFFeE8sS0FBRixDQUFOLEdBQWtCLE1BQWxCLENBRHlCLENBR3pCOztBQUNBMjdELFVBQUFBLFFBQVEsQ0FBQzV6RSxHQUFULENBQWMrOEQsSUFBZCxFQUFvQixTQUFwQixFQUErQi81RCxPQUEvQjtBQUNBO0FBQ0Q7QUFDRCxLQXBDa0MsQ0FzQ25DOzs7QUFDQSxTQUFNaVYsS0FBSyxHQUFHLENBQWQsRUFBaUJBLEtBQUssR0FBRzVoQixNQUF6QixFQUFpQzRoQixLQUFLLEVBQXRDLEVBQTJDO0FBQzFDLFVBQUt3TyxNQUFNLENBQUV4TyxLQUFGLENBQU4sSUFBbUIsSUFBeEIsRUFBK0I7QUFDOUI5aEIsUUFBQUEsUUFBUSxDQUFFOGhCLEtBQUYsQ0FBUixDQUFrQnRqQixLQUFsQixDQUF3QnFPLE9BQXhCLEdBQWtDeWpCLE1BQU0sQ0FBRXhPLEtBQUYsQ0FBeEM7QUFDQTtBQUNEOztBQUVELFdBQU85aEIsUUFBUDtBQUNBOztBQUVEbW1FLEVBQUFBLE1BQU0sQ0FBQ0MsRUFBUCxDQUFVZSxNQUFWLENBQWtCO0FBQ2pCMFksSUFBQUEsSUFBSSxFQUFFLGdCQUFXO0FBQ2hCLGFBQU9ELFFBQVEsQ0FBRSxJQUFGLEVBQVEsSUFBUixDQUFmO0FBQ0EsS0FIZ0I7QUFJakJFLElBQUFBLElBQUksRUFBRSxnQkFBVztBQUNoQixhQUFPRixRQUFRLENBQUUsSUFBRixDQUFmO0FBQ0EsS0FOZ0I7QUFPakJHLElBQUFBLE1BQU0sRUFBRSxnQkFBVXgzQyxLQUFWLEVBQWtCO0FBQ3pCLFVBQUssT0FBT0EsS0FBUCxLQUFpQixTQUF0QixFQUFrQztBQUNqQyxlQUFPQSxLQUFLLEdBQUcsS0FBS3MzQyxJQUFMLEVBQUgsR0FBaUIsS0FBS0MsSUFBTCxFQUE3QjtBQUNBOztBQUVELGFBQU8sS0FBS2w5QixJQUFMLENBQVcsWUFBVztBQUM1QixZQUFLczhCLGtCQUFrQixDQUFFLElBQUYsQ0FBdkIsRUFBa0M7QUFDakMvWSxVQUFBQSxNQUFNLENBQUUsSUFBRixDQUFOLENBQWUwWixJQUFmO0FBQ0EsU0FGRCxNQUVPO0FBQ04xWixVQUFBQSxNQUFNLENBQUUsSUFBRixDQUFOLENBQWUyWixJQUFmO0FBQ0E7QUFDRCxPQU5NLENBQVA7QUFPQTtBQW5CZ0IsR0FBbEI7QUFxQkEsTUFBSUUsY0FBYyxHQUFLLHVCQUF2QjtBQUVBLE1BQUlDLFFBQVEsR0FBSyxnQ0FBakI7QUFFQSxNQUFJQyxXQUFXLEdBQUssb0NBQXBCOztBQUlBLEdBQUUsWUFBVztBQUNaLFFBQUlDLFFBQVEsR0FBRzMxRSxRQUFRLENBQUM0MUUsc0JBQVQsRUFBZjtBQUFBLFFBQ0N2eUUsR0FBRyxHQUFHc3lFLFFBQVEsQ0FBQzV6RSxXQUFULENBQXNCL0IsUUFBUSxDQUFDak0sYUFBVCxDQUF3QixLQUF4QixDQUF0QixDQURQO0FBQUEsUUFFQyt3RSxLQUFLLEdBQUc5a0UsUUFBUSxDQUFDak0sYUFBVCxDQUF3QixPQUF4QixDQUZULENBRFksQ0FLWjtBQUNBO0FBQ0E7QUFDQTs7QUFDQSt3RSxJQUFBQSxLQUFLLENBQUNycUQsWUFBTixDQUFvQixNQUFwQixFQUE0QixPQUE1QjtBQUNBcXFELElBQUFBLEtBQUssQ0FBQ3JxRCxZQUFOLENBQW9CLFNBQXBCLEVBQStCLFNBQS9CO0FBQ0FxcUQsSUFBQUEsS0FBSyxDQUFDcnFELFlBQU4sQ0FBb0IsTUFBcEIsRUFBNEIsR0FBNUI7QUFFQXBYLElBQUFBLEdBQUcsQ0FBQ3RCLFdBQUosQ0FBaUIraUUsS0FBakIsRUFiWSxDQWVaO0FBQ0E7O0FBQ0FqSyxJQUFBQSxPQUFPLENBQUNnYixVQUFSLEdBQXFCeHlFLEdBQUcsQ0FBQ3l5RSxTQUFKLENBQWUsSUFBZixFQUFzQkEsU0FBdEIsQ0FBaUMsSUFBakMsRUFBd0N0TyxTQUF4QyxDQUFrRGdCLE9BQXZFLENBakJZLENBbUJaO0FBQ0E7O0FBQ0FubEUsSUFBQUEsR0FBRyxDQUFDSyxTQUFKLEdBQWdCLHdCQUFoQjtBQUNBbTNELElBQUFBLE9BQU8sQ0FBQ2tiLGNBQVIsR0FBeUIsQ0FBQyxDQUFDMXlFLEdBQUcsQ0FBQ3l5RSxTQUFKLENBQWUsSUFBZixFQUFzQnRPLFNBQXRCLENBQWdDMEUsWUFBM0QsQ0F0QlksQ0F3Qlo7QUFDQTtBQUNBOztBQUNBN29FLElBQUFBLEdBQUcsQ0FBQ0ssU0FBSixHQUFnQixtQkFBaEI7QUFDQW0zRCxJQUFBQSxPQUFPLENBQUNtYixNQUFSLEdBQWlCLENBQUMsQ0FBQzN5RSxHQUFHLENBQUNta0UsU0FBdkI7QUFDQSxHQTdCRCxJQXR3SmlGLENBc3lKakY7OztBQUNBLE1BQUl5TyxPQUFPLEdBQUc7QUFFYjtBQUNBO0FBQ0E7QUFDQUMsSUFBQUEsS0FBSyxFQUFFLENBQUUsQ0FBRixFQUFLLFNBQUwsRUFBZ0IsVUFBaEIsQ0FMTTtBQU1iQyxJQUFBQSxHQUFHLEVBQUUsQ0FBRSxDQUFGLEVBQUssbUJBQUwsRUFBMEIscUJBQTFCLENBTlE7QUFPYkMsSUFBQUEsRUFBRSxFQUFFLENBQUUsQ0FBRixFQUFLLGdCQUFMLEVBQXVCLGtCQUF2QixDQVBTO0FBUWJDLElBQUFBLEVBQUUsRUFBRSxDQUFFLENBQUYsRUFBSyxvQkFBTCxFQUEyQix1QkFBM0IsQ0FSUztBQVViQyxJQUFBQSxRQUFRLEVBQUUsQ0FBRSxDQUFGLEVBQUssRUFBTCxFQUFTLEVBQVQ7QUFWRyxHQUFkO0FBYUFMLEVBQUFBLE9BQU8sQ0FBQ00sS0FBUixHQUFnQk4sT0FBTyxDQUFDTyxLQUFSLEdBQWdCUCxPQUFPLENBQUNRLFFBQVIsR0FBbUJSLE9BQU8sQ0FBQ1MsT0FBUixHQUFrQlQsT0FBTyxDQUFDQyxLQUE3RTtBQUNBRCxFQUFBQSxPQUFPLENBQUNVLEVBQVIsR0FBYVYsT0FBTyxDQUFDSSxFQUFyQixDQXJ6SmlGLENBdXpKakY7O0FBQ0EsTUFBSyxDQUFDeGIsT0FBTyxDQUFDbWIsTUFBZCxFQUF1QjtBQUN0QkMsSUFBQUEsT0FBTyxDQUFDVyxRQUFSLEdBQW1CWCxPQUFPLENBQUNELE1BQVIsR0FBaUIsQ0FBRSxDQUFGLEVBQUssOEJBQUwsRUFBcUMsV0FBckMsQ0FBcEM7QUFDQTs7QUFHRCxXQUFTamlELE1BQVQsQ0FBaUIzM0IsT0FBakIsRUFBMEJ3b0UsR0FBMUIsRUFBZ0M7QUFFL0I7QUFDQTtBQUNBLFFBQUkzSSxHQUFKOztBQUVBLFFBQUssT0FBTzcvRCxPQUFPLENBQUNxbUUsb0JBQWYsS0FBd0MsV0FBN0MsRUFBMkQ7QUFDMUR4RyxNQUFBQSxHQUFHLEdBQUc3L0QsT0FBTyxDQUFDcW1FLG9CQUFSLENBQThCbUMsR0FBRyxJQUFJLEdBQXJDLENBQU47QUFFQSxLQUhELE1BR08sSUFBSyxPQUFPeG9FLE9BQU8sQ0FBQzI3QyxnQkFBZixLQUFvQyxXQUF6QyxFQUF1RDtBQUM3RGtrQixNQUFBQSxHQUFHLEdBQUc3L0QsT0FBTyxDQUFDMjdDLGdCQUFSLENBQTBCNnNCLEdBQUcsSUFBSSxHQUFqQyxDQUFOO0FBRUEsS0FITSxNQUdBO0FBQ04zSSxNQUFBQSxHQUFHLEdBQUcsRUFBTjtBQUNBOztBQUVELFFBQUsySSxHQUFHLEtBQUs1SCxTQUFSLElBQXFCNEgsR0FBRyxJQUFJNWxFLFFBQVEsQ0FBRTVDLE9BQUYsRUFBV3dvRSxHQUFYLENBQXpDLEVBQTREO0FBQzNELGFBQU9qSixNQUFNLENBQUNPLEtBQVAsQ0FBYyxDQUFFOS9ELE9BQUYsQ0FBZCxFQUEyQjYvRCxHQUEzQixDQUFQO0FBQ0E7O0FBRUQsV0FBT0EsR0FBUDtBQUNBLEdBbDFKZ0YsQ0FxMUpqRjs7O0FBQ0EsV0FBUzRhLGFBQVQsQ0FBd0I3YSxLQUF4QixFQUErQjhhLFdBQS9CLEVBQTZDO0FBQzVDLFFBQUlyaEYsQ0FBQyxHQUFHLENBQVI7QUFBQSxRQUNDK0ksQ0FBQyxHQUFHdzlELEtBQUssQ0FBQ3RtRSxNQURYOztBQUdBLFdBQVFELENBQUMsR0FBRytJLENBQVosRUFBZS9JLENBQUMsRUFBaEIsRUFBcUI7QUFDcEJ3OUUsTUFBQUEsUUFBUSxDQUFDNXpFLEdBQVQsQ0FDQzI4RCxLQUFLLENBQUV2bUUsQ0FBRixDQUROLEVBRUMsWUFGRCxFQUdDLENBQUNxaEYsV0FBRCxJQUFnQjdELFFBQVEsQ0FBQ2p2RSxHQUFULENBQWM4eUUsV0FBVyxDQUFFcmhGLENBQUYsQ0FBekIsRUFBZ0MsWUFBaEMsQ0FIakI7QUFLQTtBQUNEOztBQUdELE1BQUlpckUsS0FBSyxHQUFHLFdBQVo7O0FBRUEsV0FBU3FXLGFBQVQsQ0FBd0IvYSxLQUF4QixFQUErQjUvRCxPQUEvQixFQUF3QzQ2RSxPQUF4QyxFQUFpREMsU0FBakQsRUFBNERDLE9BQTVELEVBQXNFO0FBQ3JFLFFBQUk5YSxJQUFKO0FBQUEsUUFBVXlJLEdBQVY7QUFBQSxRQUFlRCxHQUFmO0FBQUEsUUFBb0J6cEQsSUFBcEI7QUFBQSxRQUEwQmc4RCxRQUExQjtBQUFBLFFBQW9DbDdELENBQXBDO0FBQUEsUUFDQzA1RCxRQUFRLEdBQUd2NUUsT0FBTyxDQUFDdzVFLHNCQUFSLEVBRFo7QUFBQSxRQUVDd0IsS0FBSyxHQUFHLEVBRlQ7QUFBQSxRQUdDM2hGLENBQUMsR0FBRyxDQUhMO0FBQUEsUUFJQytJLENBQUMsR0FBR3c5RCxLQUFLLENBQUN0bUUsTUFKWDs7QUFNQSxXQUFRRCxDQUFDLEdBQUcrSSxDQUFaLEVBQWUvSSxDQUFDLEVBQWhCLEVBQXFCO0FBQ3BCMm1FLE1BQUFBLElBQUksR0FBR0osS0FBSyxDQUFFdm1FLENBQUYsQ0FBWjs7QUFFQSxVQUFLMm1FLElBQUksSUFBSUEsSUFBSSxLQUFLLENBQXRCLEVBQTBCO0FBRXpCO0FBQ0EsWUFBS1YsTUFBTSxDQUFFVSxJQUFGLENBQU4sS0FBbUIsUUFBeEIsRUFBbUM7QUFFbEM7QUFDQTtBQUNBVCxVQUFBQSxNQUFNLENBQUNPLEtBQVAsQ0FBY2tiLEtBQWQsRUFBcUJoYixJQUFJLENBQUNsakUsUUFBTCxHQUFnQixDQUFFa2pFLElBQUYsQ0FBaEIsR0FBMkJBLElBQWhELEVBSmtDLENBTW5DO0FBQ0MsU0FQRCxNQU9PLElBQUssQ0FBQ3NFLEtBQUssQ0FBQzNoRSxJQUFOLENBQVlxOUQsSUFBWixDQUFOLEVBQTJCO0FBQ2pDZ2IsVUFBQUEsS0FBSyxDQUFDbGhGLElBQU4sQ0FBWWtHLE9BQU8sQ0FBQ2k3RSxjQUFSLENBQXdCamIsSUFBeEIsQ0FBWixFQURpQyxDQUdsQztBQUNDLFNBSk0sTUFJQTtBQUNOeUksVUFBQUEsR0FBRyxHQUFHQSxHQUFHLElBQUk4USxRQUFRLENBQUM1ekUsV0FBVCxDQUFzQjNGLE9BQU8sQ0FBQ3JJLGFBQVIsQ0FBdUIsS0FBdkIsQ0FBdEIsQ0FBYixDQURNLENBR047O0FBQ0E2d0UsVUFBQUEsR0FBRyxHQUFHLENBQUU2USxRQUFRLENBQUNwK0IsSUFBVCxDQUFlK2tCLElBQWYsS0FBeUIsQ0FBRSxFQUFGLEVBQU0sRUFBTixDQUEzQixFQUF5QyxDQUF6QyxFQUE2Q2ppRSxXQUE3QyxFQUFOO0FBQ0FnaEIsVUFBQUEsSUFBSSxHQUFHODZELE9BQU8sQ0FBRXJSLEdBQUYsQ0FBUCxJQUFrQnFSLE9BQU8sQ0FBQ0ssUUFBakM7QUFDQXpSLFVBQUFBLEdBQUcsQ0FBQ25oRSxTQUFKLEdBQWdCeVgsSUFBSSxDQUFFLENBQUYsQ0FBSixHQUFZd2dELE1BQU0sQ0FBQzJiLGFBQVAsQ0FBc0JsYixJQUF0QixDQUFaLEdBQTJDamhELElBQUksQ0FBRSxDQUFGLENBQS9ELENBTk0sQ0FRTjs7QUFDQWMsVUFBQUEsQ0FBQyxHQUFHZCxJQUFJLENBQUUsQ0FBRixDQUFSOztBQUNBLGlCQUFRYyxDQUFDLEVBQVQsRUFBYztBQUNiNG9ELFlBQUFBLEdBQUcsR0FBR0EsR0FBRyxDQUFDMkMsU0FBVjtBQUNBLFdBWkssQ0FjTjtBQUNBOzs7QUFDQTdMLFVBQUFBLE1BQU0sQ0FBQ08sS0FBUCxDQUFja2IsS0FBZCxFQUFxQnZTLEdBQUcsQ0FBQzVDLFVBQXpCLEVBaEJNLENBa0JOOztBQUNBNEMsVUFBQUEsR0FBRyxHQUFHOFEsUUFBUSxDQUFDejFFLFVBQWYsQ0FuQk0sQ0FxQk47O0FBQ0Eya0UsVUFBQUEsR0FBRyxDQUFDdUIsV0FBSixHQUFrQixFQUFsQjtBQUNBO0FBQ0Q7QUFDRCxLQWpEb0UsQ0FtRHJFOzs7QUFDQXVQLElBQUFBLFFBQVEsQ0FBQ3ZQLFdBQVQsR0FBdUIsRUFBdkI7QUFFQTN3RSxJQUFBQSxDQUFDLEdBQUcsQ0FBSjs7QUFDQSxXQUFVMm1FLElBQUksR0FBR2diLEtBQUssQ0FBRTNoRixDQUFDLEVBQUgsQ0FBdEIsRUFBa0M7QUFFakM7QUFDQSxVQUFLd2hGLFNBQVMsSUFBSXRiLE1BQU0sQ0FBQ2lDLE9BQVAsQ0FBZ0J4QixJQUFoQixFQUFzQjZhLFNBQXRCLElBQW9DLENBQUMsQ0FBdkQsRUFBMkQ7QUFDMUQsWUFBS0MsT0FBTCxFQUFlO0FBQ2RBLFVBQUFBLE9BQU8sQ0FBQ2hoRixJQUFSLENBQWNrbUUsSUFBZDtBQUNBOztBQUNEO0FBQ0E7O0FBRUQrYSxNQUFBQSxRQUFRLEdBQUc1QyxVQUFVLENBQUVuWSxJQUFGLENBQXJCLENBVmlDLENBWWpDOztBQUNBeUksTUFBQUEsR0FBRyxHQUFHOXdDLE1BQU0sQ0FBRTRoRCxRQUFRLENBQUM1ekUsV0FBVCxDQUFzQnE2RCxJQUF0QixDQUFGLEVBQWdDLFFBQWhDLENBQVosQ0FiaUMsQ0FlakM7O0FBQ0EsVUFBSythLFFBQUwsRUFBZ0I7QUFDZk4sUUFBQUEsYUFBYSxDQUFFaFMsR0FBRixDQUFiO0FBQ0EsT0FsQmdDLENBb0JqQzs7O0FBQ0EsVUFBS21TLE9BQUwsRUFBZTtBQUNkLzZELFFBQUFBLENBQUMsR0FBRyxDQUFKOztBQUNBLGVBQVVtZ0QsSUFBSSxHQUFHeUksR0FBRyxDQUFFNW9ELENBQUMsRUFBSCxDQUFwQixFQUFnQztBQUMvQixjQUFLeTVELFdBQVcsQ0FBQzMyRSxJQUFaLENBQWtCcTlELElBQUksQ0FBQzFvRSxJQUFMLElBQWEsRUFBL0IsQ0FBTCxFQUEyQztBQUMxQ3NqRixZQUFBQSxPQUFPLENBQUM5Z0YsSUFBUixDQUFja21FLElBQWQ7QUFDQTtBQUNEO0FBQ0Q7QUFDRDs7QUFFRCxXQUFPdVosUUFBUDtBQUNBOztBQUdELE1BQUk0QixjQUFjLEdBQUcscUJBQXJCOztBQUVBLFdBQVNDLFVBQVQsR0FBc0I7QUFDckIsV0FBTyxJQUFQO0FBQ0E7O0FBRUQsV0FBU0MsV0FBVCxHQUF1QjtBQUN0QixXQUFPLEtBQVA7QUFDQSxHQXg4SmdGLENBMDhKakY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQSxXQUFTQyxVQUFULENBQXFCdGIsSUFBckIsRUFBMkIxb0UsSUFBM0IsRUFBa0M7QUFDakMsV0FBUzBvRSxJQUFJLEtBQUt1YixpQkFBaUIsRUFBNUIsTUFBdUNqa0YsSUFBSSxLQUFLLE9BQWhELENBQVA7QUFDQSxHQWw5SmdGLENBbzlKakY7QUFDQTtBQUNBOzs7QUFDQSxXQUFTaWtGLGlCQUFULEdBQTZCO0FBQzVCLFFBQUk7QUFDSCxhQUFPMzNFLFFBQVEsQ0FBQ29vRSxhQUFoQjtBQUNBLEtBRkQsQ0FFRSxPQUFRd1AsR0FBUixFQUFjLENBQUc7QUFDbkI7O0FBRUQsV0FBU0MsR0FBVCxDQUFhemIsSUFBYixFQUFtQno0RCxLQUFuQixFQUEwQnEwQyxRQUExQixFQUFvQ2xoRCxJQUFwQyxFQUEwQzhrRSxFQUExQyxFQUE4Q2tjLEdBQTlDLEVBQW9EO0FBQ25ELFFBQUlDLE1BQUosRUFBWXJrRixJQUFaLENBRG1ELENBR25EOztBQUNBLFFBQUssUUFBT2lRLEtBQVAsTUFBaUIsUUFBdEIsRUFBaUM7QUFFaEM7QUFDQSxVQUFLLE9BQU9xMEMsUUFBUCxLQUFvQixRQUF6QixFQUFvQztBQUVuQztBQUNBbGhELFFBQUFBLElBQUksR0FBR0EsSUFBSSxJQUFJa2hELFFBQWY7QUFDQUEsUUFBQUEsUUFBUSxHQUFHZ2xCLFNBQVg7QUFDQTs7QUFDRCxXQUFNdHBFLElBQU4sSUFBY2lRLEtBQWQsRUFBc0I7QUFDckJrMEUsUUFBQUEsR0FBRSxDQUFFemIsSUFBRixFQUFRMW9FLElBQVIsRUFBY3NrRCxRQUFkLEVBQXdCbGhELElBQXhCLEVBQThCNk0sS0FBSyxDQUFFalEsSUFBRixDQUFuQyxFQUE2Q29rRixHQUE3QyxDQUFGO0FBQ0E7O0FBQ0QsYUFBTzFiLElBQVA7QUFDQTs7QUFFRCxRQUFLdGxFLElBQUksSUFBSSxJQUFSLElBQWdCOGtFLEVBQUUsSUFBSSxJQUEzQixFQUFrQztBQUVqQztBQUNBQSxNQUFBQSxFQUFFLEdBQUc1akIsUUFBTDtBQUNBbGhELE1BQUFBLElBQUksR0FBR2toRCxRQUFRLEdBQUdnbEIsU0FBbEI7QUFDQSxLQUxELE1BS08sSUFBS3BCLEVBQUUsSUFBSSxJQUFYLEVBQWtCO0FBQ3hCLFVBQUssT0FBTzVqQixRQUFQLEtBQW9CLFFBQXpCLEVBQW9DO0FBRW5DO0FBQ0E0akIsUUFBQUEsRUFBRSxHQUFHOWtFLElBQUw7QUFDQUEsUUFBQUEsSUFBSSxHQUFHa21FLFNBQVA7QUFDQSxPQUxELE1BS087QUFFTjtBQUNBcEIsUUFBQUEsRUFBRSxHQUFHOWtFLElBQUw7QUFDQUEsUUFBQUEsSUFBSSxHQUFHa2hELFFBQVA7QUFDQUEsUUFBQUEsUUFBUSxHQUFHZ2xCLFNBQVg7QUFDQTtBQUNEOztBQUNELFFBQUtwQixFQUFFLEtBQUssS0FBWixFQUFvQjtBQUNuQkEsTUFBQUEsRUFBRSxHQUFHNmIsV0FBTDtBQUNBLEtBRkQsTUFFTyxJQUFLLENBQUM3YixFQUFOLEVBQVc7QUFDakIsYUFBT1EsSUFBUDtBQUNBOztBQUVELFFBQUswYixHQUFHLEtBQUssQ0FBYixFQUFpQjtBQUNoQkMsTUFBQUEsTUFBTSxHQUFHbmMsRUFBVDs7QUFDQUEsTUFBQUEsRUFBRSxHQUFHLFlBQVVua0UsS0FBVixFQUFrQjtBQUV0QjtBQUNBa2tFLFFBQUFBLE1BQU0sR0FBR3FjLEdBQVQsQ0FBY3ZnRixLQUFkO0FBQ0EsZUFBT3NnRixNQUFNLENBQUNoOEUsS0FBUCxDQUFjLElBQWQsRUFBb0JxRixTQUFwQixDQUFQO0FBQ0EsT0FMRCxDQUZnQixDQVNoQjs7O0FBQ0F3NkQsTUFBQUEsRUFBRSxDQUFDc0MsSUFBSCxHQUFVNlosTUFBTSxDQUFDN1osSUFBUCxLQUFpQjZaLE1BQU0sQ0FBQzdaLElBQVAsR0FBY3ZDLE1BQU0sQ0FBQ3VDLElBQVAsRUFBL0IsQ0FBVjtBQUNBOztBQUNELFdBQU85QixJQUFJLENBQUNoa0IsSUFBTCxDQUFXLFlBQVc7QUFDNUJ1akIsTUFBQUEsTUFBTSxDQUFDbGtFLEtBQVAsQ0FBYXJCLEdBQWIsQ0FBa0IsSUFBbEIsRUFBd0J1TixLQUF4QixFQUErQmk0RCxFQUEvQixFQUFtQzlrRSxJQUFuQyxFQUF5Q2toRCxRQUF6QztBQUNBLEtBRk0sQ0FBUDtBQUdBO0FBRUQ7QUFDQTtBQUNBO0FBQ0E7OztBQUNBMmpCLEVBQUFBLE1BQU0sQ0FBQ2xrRSxLQUFQLEdBQWU7QUFFZG1pRSxJQUFBQSxNQUFNLEVBQUUsRUFGTTtBQUlkeGpFLElBQUFBLEdBQUcsRUFBRSxhQUFVZ21FLElBQVYsRUFBZ0J6NEQsS0FBaEIsRUFBdUJ5L0QsT0FBdkIsRUFBZ0N0c0UsSUFBaEMsRUFBc0NraEQsUUFBdEMsRUFBaUQ7QUFFckQsVUFBSWlnQyxXQUFKO0FBQUEsVUFBaUJDLFdBQWpCO0FBQUEsVUFBOEJyVCxHQUE5QjtBQUFBLFVBQ0M5dUMsTUFERDtBQUFBLFVBQ1M3ZixDQURUO0FBQUEsVUFDWWlpRSxTQURaO0FBQUEsVUFFQzlILE9BRkQ7QUFBQSxVQUVVK0gsUUFGVjtBQUFBLFVBRW9CMWtGLElBRnBCO0FBQUEsVUFFMEIya0YsVUFGMUI7QUFBQSxVQUVzQ0MsUUFGdEM7QUFBQSxVQUdDQyxRQUFRLEdBQUd0RixRQUFRLENBQUNqdkUsR0FBVCxDQUFjbzRELElBQWQsQ0FIWixDQUZxRCxDQU9yRDs7QUFDQSxVQUFLLENBQUN3VyxVQUFVLENBQUV4VyxJQUFGLENBQWhCLEVBQTJCO0FBQzFCO0FBQ0EsT0FWb0QsQ0FZckQ7OztBQUNBLFVBQUtnSCxPQUFPLENBQUNBLE9BQWIsRUFBdUI7QUFDdEI2VSxRQUFBQSxXQUFXLEdBQUc3VSxPQUFkO0FBQ0FBLFFBQUFBLE9BQU8sR0FBRzZVLFdBQVcsQ0FBQzdVLE9BQXRCO0FBQ0FwckIsUUFBQUEsUUFBUSxHQUFHaWdDLFdBQVcsQ0FBQ2pnQyxRQUF2QjtBQUNBLE9BakJvRCxDQW1CckQ7QUFDQTs7O0FBQ0EsVUFBS0EsUUFBTCxFQUFnQjtBQUNmMmpCLFFBQUFBLE1BQU0sQ0FBQytJLElBQVAsQ0FBWUssZUFBWixDQUE2QnZzRSxlQUE3QixFQUE4Q3cvQyxRQUE5QztBQUNBLE9BdkJvRCxDQXlCckQ7OztBQUNBLFVBQUssQ0FBQ29yQixPQUFPLENBQUNsRixJQUFkLEVBQXFCO0FBQ3BCa0YsUUFBQUEsT0FBTyxDQUFDbEYsSUFBUixHQUFldkMsTUFBTSxDQUFDdUMsSUFBUCxFQUFmO0FBQ0EsT0E1Qm9ELENBOEJyRDs7O0FBQ0EsVUFBSyxFQUFHbm9DLE1BQU0sR0FBR3dpRCxRQUFRLENBQUN4aUQsTUFBckIsQ0FBTCxFQUFxQztBQUNwQ0EsUUFBQUEsTUFBTSxHQUFHd2lELFFBQVEsQ0FBQ3hpRCxNQUFULEdBQWtCaGxDLE1BQU0sQ0FBQ0MsTUFBUCxDQUFlLElBQWYsQ0FBM0I7QUFDQTs7QUFDRCxVQUFLLEVBQUdrbkYsV0FBVyxHQUFHSyxRQUFRLENBQUN2eUUsTUFBMUIsQ0FBTCxFQUEwQztBQUN6Q2t5RSxRQUFBQSxXQUFXLEdBQUdLLFFBQVEsQ0FBQ3Z5RSxNQUFULEdBQWtCLFVBQVVwUyxDQUFWLEVBQWM7QUFFN0M7QUFDQTtBQUNBLGlCQUFPLE9BQU8rbkUsTUFBUCxLQUFrQixXQUFsQixJQUFpQ0EsTUFBTSxDQUFDbGtFLEtBQVAsQ0FBYStnRixTQUFiLEtBQTJCNWtGLENBQUMsQ0FBQ0YsSUFBOUQsR0FDTmlvRSxNQUFNLENBQUNsa0UsS0FBUCxDQUFhcW9ELFFBQWIsQ0FBc0IvakQsS0FBdEIsQ0FBNkJxZ0UsSUFBN0IsRUFBbUNoN0QsU0FBbkMsQ0FETSxHQUMyQzQ3RCxTQURsRDtBQUVBLFNBTkQ7QUFPQSxPQTFDb0QsQ0E0Q3JEOzs7QUFDQXI1RCxNQUFBQSxLQUFLLEdBQUcsQ0FBRUEsS0FBSyxJQUFJLEVBQVgsRUFBZ0I2VyxLQUFoQixDQUF1Qnd6RCxhQUF2QixLQUEwQyxDQUFFLEVBQUYsQ0FBbEQ7QUFDQTkzRCxNQUFBQSxDQUFDLEdBQUd2UyxLQUFLLENBQUNqTyxNQUFWOztBQUNBLGFBQVF3Z0IsQ0FBQyxFQUFULEVBQWM7QUFDYjJ1RCxRQUFBQSxHQUFHLEdBQUcwUyxjQUFjLENBQUNsZ0MsSUFBZixDQUFxQjF6QyxLQUFLLENBQUV1UyxDQUFGLENBQTFCLEtBQXFDLEVBQTNDO0FBQ0F4aUIsUUFBQUEsSUFBSSxHQUFHNGtGLFFBQVEsR0FBR3pULEdBQUcsQ0FBRSxDQUFGLENBQXJCO0FBQ0F3VCxRQUFBQSxVQUFVLEdBQUcsQ0FBRXhULEdBQUcsQ0FBRSxDQUFGLENBQUgsSUFBWSxFQUFkLEVBQW1CaGhFLEtBQW5CLENBQTBCLEdBQTFCLEVBQWdDODBCLElBQWhDLEVBQWIsQ0FIYSxDQUtiOztBQUNBLFlBQUssQ0FBQ2psQyxJQUFOLEVBQWE7QUFDWjtBQUNBLFNBUlksQ0FVYjs7O0FBQ0EyOEUsUUFBQUEsT0FBTyxHQUFHMVUsTUFBTSxDQUFDbGtFLEtBQVAsQ0FBYTQ0RSxPQUFiLENBQXNCMzhFLElBQXRCLEtBQWdDLEVBQTFDLENBWGEsQ0FhYjs7QUFDQUEsUUFBQUEsSUFBSSxHQUFHLENBQUVza0QsUUFBUSxHQUFHcTRCLE9BQU8sQ0FBQ29JLFlBQVgsR0FBMEJwSSxPQUFPLENBQUNxSSxRQUE1QyxLQUEwRGhsRixJQUFqRSxDQWRhLENBZ0JiOztBQUNBMjhFLFFBQUFBLE9BQU8sR0FBRzFVLE1BQU0sQ0FBQ2xrRSxLQUFQLENBQWE0NEUsT0FBYixDQUFzQjM4RSxJQUF0QixLQUFnQyxFQUExQyxDQWpCYSxDQW1CYjs7QUFDQXlrRixRQUFBQSxTQUFTLEdBQUd4YyxNQUFNLENBQUNnQixNQUFQLENBQWU7QUFDMUJqcEUsVUFBQUEsSUFBSSxFQUFFQSxJQURvQjtBQUUxQjRrRixVQUFBQSxRQUFRLEVBQUVBLFFBRmdCO0FBRzFCeGhGLFVBQUFBLElBQUksRUFBRUEsSUFIb0I7QUFJMUJzc0UsVUFBQUEsT0FBTyxFQUFFQSxPQUppQjtBQUsxQmxGLFVBQUFBLElBQUksRUFBRWtGLE9BQU8sQ0FBQ2xGLElBTFk7QUFNMUJsbUIsVUFBQUEsUUFBUSxFQUFFQSxRQU5nQjtBQU8xQjAwQixVQUFBQSxZQUFZLEVBQUUxMEIsUUFBUSxJQUFJMmpCLE1BQU0sQ0FBQ2tLLElBQVAsQ0FBWXJyRCxLQUFaLENBQWtCa3lELFlBQWxCLENBQStCM3RFLElBQS9CLENBQXFDaTVDLFFBQXJDLENBUEE7QUFRMUJpc0IsVUFBQUEsU0FBUyxFQUFFb1UsVUFBVSxDQUFDbCtELElBQVgsQ0FBaUIsR0FBakI7QUFSZSxTQUFmLEVBU1Q4OUQsV0FUUyxDQUFaLENBcEJhLENBK0JiOztBQUNBLFlBQUssRUFBR0csUUFBUSxHQUFHcmlELE1BQU0sQ0FBRXJpQyxJQUFGLENBQXBCLENBQUwsRUFBc0M7QUFDckMwa0YsVUFBQUEsUUFBUSxHQUFHcmlELE1BQU0sQ0FBRXJpQyxJQUFGLENBQU4sR0FBaUIsRUFBNUI7QUFDQTBrRixVQUFBQSxRQUFRLENBQUNPLGFBQVQsR0FBeUIsQ0FBekIsQ0FGcUMsQ0FJckM7O0FBQ0EsY0FBSyxDQUFDdEksT0FBTyxDQUFDdUksS0FBVCxJQUNKdkksT0FBTyxDQUFDdUksS0FBUixDQUFjbDZFLElBQWQsQ0FBb0IwOUQsSUFBcEIsRUFBMEJ0bEUsSUFBMUIsRUFBZ0N1aEYsVUFBaEMsRUFBNENILFdBQTVDLE1BQThELEtBRC9ELEVBQ3VFO0FBRXRFLGdCQUFLOWIsSUFBSSxDQUFDamxFLGdCQUFWLEVBQTZCO0FBQzVCaWxFLGNBQUFBLElBQUksQ0FBQ2psRSxnQkFBTCxDQUF1QnpELElBQXZCLEVBQTZCd2tGLFdBQTdCO0FBQ0E7QUFDRDtBQUNEOztBQUVELFlBQUs3SCxPQUFPLENBQUNqNkUsR0FBYixFQUFtQjtBQUNsQmk2RSxVQUFBQSxPQUFPLENBQUNqNkUsR0FBUixDQUFZc0ksSUFBWixDQUFrQjA5RCxJQUFsQixFQUF3QitiLFNBQXhCOztBQUVBLGNBQUssQ0FBQ0EsU0FBUyxDQUFDL1UsT0FBVixDQUFrQmxGLElBQXhCLEVBQStCO0FBQzlCaWEsWUFBQUEsU0FBUyxDQUFDL1UsT0FBVixDQUFrQmxGLElBQWxCLEdBQXlCa0YsT0FBTyxDQUFDbEYsSUFBakM7QUFDQTtBQUNELFNBcERZLENBc0RiOzs7QUFDQSxZQUFLbG1CLFFBQUwsRUFBZ0I7QUFDZm9nQyxVQUFBQSxRQUFRLENBQUM1aEYsTUFBVCxDQUFpQjRoRixRQUFRLENBQUNPLGFBQVQsRUFBakIsRUFBMkMsQ0FBM0MsRUFBOENSLFNBQTlDO0FBQ0EsU0FGRCxNQUVPO0FBQ05DLFVBQUFBLFFBQVEsQ0FBQ2xpRixJQUFULENBQWVpaUYsU0FBZjtBQUNBLFNBM0RZLENBNkRiOzs7QUFDQXhjLFFBQUFBLE1BQU0sQ0FBQ2xrRSxLQUFQLENBQWFtaUUsTUFBYixDQUFxQmxtRSxJQUFyQixJQUE4QixJQUE5QjtBQUNBO0FBRUQsS0FwSGE7QUFzSGQ7QUFDQTRDLElBQUFBLE1BQU0sRUFBRSxnQkFBVThsRSxJQUFWLEVBQWdCejRELEtBQWhCLEVBQXVCeS9ELE9BQXZCLEVBQWdDcHJCLFFBQWhDLEVBQTBDNmdDLFdBQTFDLEVBQXdEO0FBRS9ELFVBQUk1OEQsQ0FBSjtBQUFBLFVBQU82OEQsU0FBUDtBQUFBLFVBQWtCalUsR0FBbEI7QUFBQSxVQUNDOXVDLE1BREQ7QUFBQSxVQUNTN2YsQ0FEVDtBQUFBLFVBQ1lpaUUsU0FEWjtBQUFBLFVBRUM5SCxPQUZEO0FBQUEsVUFFVStILFFBRlY7QUFBQSxVQUVvQjFrRixJQUZwQjtBQUFBLFVBRTBCMmtGLFVBRjFCO0FBQUEsVUFFc0NDLFFBRnRDO0FBQUEsVUFHQ0MsUUFBUSxHQUFHdEYsUUFBUSxDQUFDRCxPQUFULENBQWtCNVcsSUFBbEIsS0FBNEI2VyxRQUFRLENBQUNqdkUsR0FBVCxDQUFjbzRELElBQWQsQ0FIeEM7O0FBS0EsVUFBSyxDQUFDbWMsUUFBRCxJQUFhLEVBQUd4aUQsTUFBTSxHQUFHd2lELFFBQVEsQ0FBQ3hpRCxNQUFyQixDQUFsQixFQUFrRDtBQUNqRDtBQUNBLE9BVDhELENBVy9EOzs7QUFDQXB5QixNQUFBQSxLQUFLLEdBQUcsQ0FBRUEsS0FBSyxJQUFJLEVBQVgsRUFBZ0I2VyxLQUFoQixDQUF1Qnd6RCxhQUF2QixLQUEwQyxDQUFFLEVBQUYsQ0FBbEQ7QUFDQTkzRCxNQUFBQSxDQUFDLEdBQUd2UyxLQUFLLENBQUNqTyxNQUFWOztBQUNBLGFBQVF3Z0IsQ0FBQyxFQUFULEVBQWM7QUFDYjJ1RCxRQUFBQSxHQUFHLEdBQUcwUyxjQUFjLENBQUNsZ0MsSUFBZixDQUFxQjF6QyxLQUFLLENBQUV1UyxDQUFGLENBQTFCLEtBQXFDLEVBQTNDO0FBQ0F4aUIsUUFBQUEsSUFBSSxHQUFHNGtGLFFBQVEsR0FBR3pULEdBQUcsQ0FBRSxDQUFGLENBQXJCO0FBQ0F3VCxRQUFBQSxVQUFVLEdBQUcsQ0FBRXhULEdBQUcsQ0FBRSxDQUFGLENBQUgsSUFBWSxFQUFkLEVBQW1CaGhFLEtBQW5CLENBQTBCLEdBQTFCLEVBQWdDODBCLElBQWhDLEVBQWIsQ0FIYSxDQUtiOztBQUNBLFlBQUssQ0FBQ2psQyxJQUFOLEVBQWE7QUFDWixlQUFNQSxJQUFOLElBQWNxaUMsTUFBZCxFQUF1QjtBQUN0QjRsQyxZQUFBQSxNQUFNLENBQUNsa0UsS0FBUCxDQUFhbkIsTUFBYixDQUFxQjhsRSxJQUFyQixFQUEyQjFvRSxJQUFJLEdBQUdpUSxLQUFLLENBQUV1UyxDQUFGLENBQXZDLEVBQThDa3RELE9BQTlDLEVBQXVEcHJCLFFBQXZELEVBQWlFLElBQWpFO0FBQ0E7O0FBQ0Q7QUFDQTs7QUFFRHE0QixRQUFBQSxPQUFPLEdBQUcxVSxNQUFNLENBQUNsa0UsS0FBUCxDQUFhNDRFLE9BQWIsQ0FBc0IzOEUsSUFBdEIsS0FBZ0MsRUFBMUM7QUFDQUEsUUFBQUEsSUFBSSxHQUFHLENBQUVza0QsUUFBUSxHQUFHcTRCLE9BQU8sQ0FBQ29JLFlBQVgsR0FBMEJwSSxPQUFPLENBQUNxSSxRQUE1QyxLQUEwRGhsRixJQUFqRTtBQUNBMGtGLFFBQUFBLFFBQVEsR0FBR3JpRCxNQUFNLENBQUVyaUMsSUFBRixDQUFOLElBQWtCLEVBQTdCO0FBQ0FteEUsUUFBQUEsR0FBRyxHQUFHQSxHQUFHLENBQUUsQ0FBRixDQUFILElBQ0wsSUFBSW5tQixNQUFKLENBQVksWUFBWTI1QixVQUFVLENBQUNsK0QsSUFBWCxDQUFpQixlQUFqQixDQUFaLEdBQWlELFNBQTdELENBREQsQ0FoQmEsQ0FtQmI7O0FBQ0EyK0QsUUFBQUEsU0FBUyxHQUFHNzhELENBQUMsR0FBR204RCxRQUFRLENBQUMxaUYsTUFBekI7O0FBQ0EsZUFBUXVtQixDQUFDLEVBQVQsRUFBYztBQUNiazhELFVBQUFBLFNBQVMsR0FBR0MsUUFBUSxDQUFFbjhELENBQUYsQ0FBcEI7O0FBRUEsY0FBSyxDQUFFNDhELFdBQVcsSUFBSVAsUUFBUSxLQUFLSCxTQUFTLENBQUNHLFFBQXhDLE1BQ0YsQ0FBQ2xWLE9BQUQsSUFBWUEsT0FBTyxDQUFDbEYsSUFBUixLQUFpQmlhLFNBQVMsQ0FBQ2phLElBRHJDLE1BRUYsQ0FBQzJHLEdBQUQsSUFBUUEsR0FBRyxDQUFDOWxFLElBQUosQ0FBVW81RSxTQUFTLENBQUNsVSxTQUFwQixDQUZOLE1BR0YsQ0FBQ2pzQixRQUFELElBQWFBLFFBQVEsS0FBS21nQyxTQUFTLENBQUNuZ0MsUUFBcEMsSUFDREEsUUFBUSxLQUFLLElBQWIsSUFBcUJtZ0MsU0FBUyxDQUFDbmdDLFFBSjVCLENBQUwsRUFJOEM7QUFDN0NvZ0MsWUFBQUEsUUFBUSxDQUFDNWhGLE1BQVQsQ0FBaUJ5bEIsQ0FBakIsRUFBb0IsQ0FBcEI7O0FBRUEsZ0JBQUtrOEQsU0FBUyxDQUFDbmdDLFFBQWYsRUFBMEI7QUFDekJvZ0MsY0FBQUEsUUFBUSxDQUFDTyxhQUFUO0FBQ0E7O0FBQ0QsZ0JBQUt0SSxPQUFPLENBQUMvNUUsTUFBYixFQUFzQjtBQUNyQis1RSxjQUFBQSxPQUFPLENBQUMvNUUsTUFBUixDQUFlb0ksSUFBZixDQUFxQjA5RCxJQUFyQixFQUEyQitiLFNBQTNCO0FBQ0E7QUFDRDtBQUNELFNBdENZLENBd0NiO0FBQ0E7OztBQUNBLFlBQUtXLFNBQVMsSUFBSSxDQUFDVixRQUFRLENBQUMxaUYsTUFBNUIsRUFBcUM7QUFDcEMsY0FBSyxDQUFDMjZFLE9BQU8sQ0FBQzBJLFFBQVQsSUFDSjFJLE9BQU8sQ0FBQzBJLFFBQVIsQ0FBaUJyNkUsSUFBakIsQ0FBdUIwOUQsSUFBdkIsRUFBNkJpYyxVQUE3QixFQUF5Q0UsUUFBUSxDQUFDdnlFLE1BQWxELE1BQStELEtBRGhFLEVBQ3dFO0FBRXZFMjFELFlBQUFBLE1BQU0sQ0FBQ3FkLFdBQVAsQ0FBb0I1YyxJQUFwQixFQUEwQjFvRSxJQUExQixFQUFnQzZrRixRQUFRLENBQUN2eUUsTUFBekM7QUFDQTs7QUFFRCxpQkFBTyt2QixNQUFNLENBQUVyaUMsSUFBRixDQUFiO0FBQ0E7QUFDRCxPQWpFOEQsQ0FtRS9EOzs7QUFDQSxVQUFLaW9FLE1BQU0sQ0FBQzRCLGFBQVAsQ0FBc0J4bkMsTUFBdEIsQ0FBTCxFQUFzQztBQUNyQ2s5QyxRQUFBQSxRQUFRLENBQUMzOEUsTUFBVCxDQUFpQjhsRSxJQUFqQixFQUF1QixlQUF2QjtBQUNBO0FBQ0QsS0E5TGE7QUFnTWR0YyxJQUFBQSxRQUFRLEVBQUUsa0JBQVVtNUIsV0FBVixFQUF3QjtBQUVqQyxVQUFJeGpGLENBQUo7QUFBQSxVQUFPd21CLENBQVA7QUFBQSxVQUFVZ2dELEdBQVY7QUFBQSxVQUFlNEwsT0FBZjtBQUFBLFVBQXdCc1EsU0FBeEI7QUFBQSxVQUFtQ2UsWUFBbkM7QUFBQSxVQUNDcnNCLElBQUksR0FBRyxJQUFJdDVELEtBQUosQ0FBVzZOLFNBQVMsQ0FBQzFMLE1BQXJCLENBRFI7QUFBQSxVQUdDO0FBQ0ErQixNQUFBQSxLQUFLLEdBQUdra0UsTUFBTSxDQUFDbGtFLEtBQVAsQ0FBYTBoRixHQUFiLENBQWtCRixXQUFsQixDQUpUO0FBQUEsVUFNQ2IsUUFBUSxHQUFHLENBQ1ZuRixRQUFRLENBQUNqdkUsR0FBVCxDQUFjLElBQWQsRUFBb0IsUUFBcEIsS0FBa0NqVCxNQUFNLENBQUNDLE1BQVAsQ0FBZSxJQUFmLENBRHhCLEVBRVJ5RyxLQUFLLENBQUMvRCxJQUZFLEtBRVEsRUFScEI7QUFBQSxVQVNDMjhFLE9BQU8sR0FBRzFVLE1BQU0sQ0FBQ2xrRSxLQUFQLENBQWE0NEUsT0FBYixDQUFzQjU0RSxLQUFLLENBQUMvRCxJQUE1QixLQUFzQyxFQVRqRCxDQUZpQyxDQWFqQzs7QUFDQW01RCxNQUFBQSxJQUFJLENBQUUsQ0FBRixDQUFKLEdBQVlwMUQsS0FBWjs7QUFFQSxXQUFNaEMsQ0FBQyxHQUFHLENBQVYsRUFBYUEsQ0FBQyxHQUFHMkwsU0FBUyxDQUFDMUwsTUFBM0IsRUFBbUNELENBQUMsRUFBcEMsRUFBeUM7QUFDeENvM0QsUUFBQUEsSUFBSSxDQUFFcDNELENBQUYsQ0FBSixHQUFZMkwsU0FBUyxDQUFFM0wsQ0FBRixDQUFyQjtBQUNBOztBQUVEZ0MsTUFBQUEsS0FBSyxDQUFDMmhGLGNBQU4sR0FBdUIsSUFBdkIsQ0FwQmlDLENBc0JqQzs7QUFDQSxVQUFLL0ksT0FBTyxDQUFDZ0osV0FBUixJQUF1QmhKLE9BQU8sQ0FBQ2dKLFdBQVIsQ0FBb0IzNkUsSUFBcEIsQ0FBMEIsSUFBMUIsRUFBZ0NqSCxLQUFoQyxNQUE0QyxLQUF4RSxFQUFnRjtBQUMvRTtBQUNBLE9BekJnQyxDQTJCakM7OztBQUNBeWhGLE1BQUFBLFlBQVksR0FBR3ZkLE1BQU0sQ0FBQ2xrRSxLQUFQLENBQWEyZ0YsUUFBYixDQUFzQjE1RSxJQUF0QixDQUE0QixJQUE1QixFQUFrQ2pILEtBQWxDLEVBQXlDMmdGLFFBQXpDLENBQWYsQ0E1QmlDLENBOEJqQzs7QUFDQTNpRixNQUFBQSxDQUFDLEdBQUcsQ0FBSjs7QUFDQSxhQUFRLENBQUVveUUsT0FBTyxHQUFHcVIsWUFBWSxDQUFFempGLENBQUMsRUFBSCxDQUF4QixLQUFxQyxDQUFDZ0MsS0FBSyxDQUFDNmhGLG9CQUFOLEVBQTlDLEVBQTZFO0FBQzVFN2hGLFFBQUFBLEtBQUssQ0FBQ3FXLGFBQU4sR0FBc0IrNUQsT0FBTyxDQUFDekwsSUFBOUI7QUFFQW5nRCxRQUFBQSxDQUFDLEdBQUcsQ0FBSjs7QUFDQSxlQUFRLENBQUVrOEQsU0FBUyxHQUFHdFEsT0FBTyxDQUFDdVEsUUFBUixDQUFrQm44RCxDQUFDLEVBQW5CLENBQWQsS0FDUCxDQUFDeGtCLEtBQUssQ0FBQzhoRiw2QkFBTixFQURGLEVBQzBDO0FBRXpDO0FBQ0E7QUFDQSxjQUFLLENBQUM5aEYsS0FBSyxDQUFDK2hGLFVBQVAsSUFBcUJyQixTQUFTLENBQUNsVSxTQUFWLEtBQXdCLEtBQTdDLElBQ0p4c0UsS0FBSyxDQUFDK2hGLFVBQU4sQ0FBaUJ6NkUsSUFBakIsQ0FBdUJvNUUsU0FBUyxDQUFDbFUsU0FBakMsQ0FERCxFQUNnRDtBQUUvQ3hzRSxZQUFBQSxLQUFLLENBQUMwZ0YsU0FBTixHQUFrQkEsU0FBbEI7QUFDQTFnRixZQUFBQSxLQUFLLENBQUNYLElBQU4sR0FBYXFoRixTQUFTLENBQUNyaEYsSUFBdkI7QUFFQW1sRSxZQUFBQSxHQUFHLEdBQUcsQ0FBRSxDQUFFTixNQUFNLENBQUNsa0UsS0FBUCxDQUFhNDRFLE9BQWIsQ0FBc0I4SCxTQUFTLENBQUNHLFFBQWhDLEtBQThDLEVBQWhELEVBQXFEdHlFLE1BQXJELElBQ1BteUUsU0FBUyxDQUFDL1UsT0FETCxFQUNlcm5FLEtBRGYsQ0FDc0I4ckUsT0FBTyxDQUFDekwsSUFEOUIsRUFDb0N2UCxJQURwQyxDQUFOOztBQUdBLGdCQUFLb1AsR0FBRyxLQUFLZSxTQUFiLEVBQXlCO0FBQ3hCLGtCQUFLLENBQUV2bEUsS0FBSyxDQUFDcUUsTUFBTixHQUFlbWdFLEdBQWpCLE1BQTJCLEtBQWhDLEVBQXdDO0FBQ3ZDeGtFLGdCQUFBQSxLQUFLLENBQUNDLGNBQU47QUFDQUQsZ0JBQUFBLEtBQUssQ0FBQ2dpRixlQUFOO0FBQ0E7QUFDRDtBQUNEO0FBQ0Q7QUFDRCxPQTFEZ0MsQ0E0RGpDOzs7QUFDQSxVQUFLcEosT0FBTyxDQUFDcUosWUFBYixFQUE0QjtBQUMzQnJKLFFBQUFBLE9BQU8sQ0FBQ3FKLFlBQVIsQ0FBcUJoN0UsSUFBckIsQ0FBMkIsSUFBM0IsRUFBaUNqSCxLQUFqQztBQUNBOztBQUVELGFBQU9BLEtBQUssQ0FBQ3FFLE1BQWI7QUFDQSxLQWxRYTtBQW9RZHM4RSxJQUFBQSxRQUFRLEVBQUUsa0JBQVUzZ0YsS0FBVixFQUFpQjJnRixTQUFqQixFQUE0QjtBQUNyQyxVQUFJM2lGLENBQUo7QUFBQSxVQUFPMGlGLFNBQVA7QUFBQSxVQUFrQnBTLEdBQWxCO0FBQUEsVUFBdUI0VCxlQUF2QjtBQUFBLFVBQXdDQyxnQkFBeEM7QUFBQSxVQUNDVixZQUFZLEdBQUcsRUFEaEI7QUFBQSxVQUVDUCxhQUFhLEdBQUdQLFNBQVEsQ0FBQ08sYUFGMUI7QUFBQSxVQUdDcFYsR0FBRyxHQUFHOXJFLEtBQUssQ0FBQ1MsTUFIYixDQURxQyxDQU1yQzs7QUFDQSxVQUFLeWdGLGFBQWEsSUFFakI7QUFDQTtBQUNBcFYsTUFBQUEsR0FBRyxDQUFDcnFFLFFBSkEsSUFNSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBR3pCLEtBQUssQ0FBQy9ELElBQU4sS0FBZSxPQUFmLElBQTBCK0QsS0FBSyxDQUFDb2lGLE1BQU4sSUFBZ0IsQ0FBN0MsQ0FYRCxFQVdvRDtBQUVuRCxlQUFRdFcsR0FBRyxLQUFLLElBQWhCLEVBQXNCQSxHQUFHLEdBQUdBLEdBQUcsQ0FBQ3ZxRSxVQUFKLElBQWtCLElBQTlDLEVBQXFEO0FBRXBEO0FBQ0E7QUFDQSxjQUFLdXFFLEdBQUcsQ0FBQ3JxRSxRQUFKLEtBQWlCLENBQWpCLElBQXNCLEVBQUd6QixLQUFLLENBQUMvRCxJQUFOLEtBQWUsT0FBZixJQUEwQjZ2RSxHQUFHLENBQUN4QixRQUFKLEtBQWlCLElBQTlDLENBQTNCLEVBQWtGO0FBQ2pGNFgsWUFBQUEsZUFBZSxHQUFHLEVBQWxCO0FBQ0FDLFlBQUFBLGdCQUFnQixHQUFHLEVBQW5COztBQUNBLGlCQUFNbmtGLENBQUMsR0FBRyxDQUFWLEVBQWFBLENBQUMsR0FBR2tqRixhQUFqQixFQUFnQ2xqRixDQUFDLEVBQWpDLEVBQXNDO0FBQ3JDMGlGLGNBQUFBLFNBQVMsR0FBR0MsU0FBUSxDQUFFM2lGLENBQUYsQ0FBcEIsQ0FEcUMsQ0FHckM7O0FBQ0Fzd0UsY0FBQUEsR0FBRyxHQUFHb1MsU0FBUyxDQUFDbmdDLFFBQVYsR0FBcUIsR0FBM0I7O0FBRUEsa0JBQUs0aEMsZ0JBQWdCLENBQUU3VCxHQUFGLENBQWhCLEtBQTRCL0ksU0FBakMsRUFBNkM7QUFDNUM0YyxnQkFBQUEsZ0JBQWdCLENBQUU3VCxHQUFGLENBQWhCLEdBQTBCb1MsU0FBUyxDQUFDekwsWUFBVixHQUN6Qi9RLE1BQU0sQ0FBRW9LLEdBQUYsRUFBTyxJQUFQLENBQU4sQ0FBb0J6dUQsS0FBcEIsQ0FBMkJpc0QsR0FBM0IsSUFBbUMsQ0FBQyxDQURYLEdBRXpCNUgsTUFBTSxDQUFDK0ksSUFBUCxDQUFhcUIsR0FBYixFQUFrQixJQUFsQixFQUF3QixJQUF4QixFQUE4QixDQUFFeEMsR0FBRixDQUE5QixFQUF3Qzd0RSxNQUZ6QztBQUdBOztBQUNELGtCQUFLa2tGLGdCQUFnQixDQUFFN1QsR0FBRixDQUFyQixFQUErQjtBQUM5QjRULGdCQUFBQSxlQUFlLENBQUN6akYsSUFBaEIsQ0FBc0JpaUYsU0FBdEI7QUFDQTtBQUNEOztBQUNELGdCQUFLd0IsZUFBZSxDQUFDamtGLE1BQXJCLEVBQThCO0FBQzdCd2pGLGNBQUFBLFlBQVksQ0FBQ2hqRixJQUFiLENBQW1CO0FBQUVrbUUsZ0JBQUFBLElBQUksRUFBRW1ILEdBQVI7QUFBYTZVLGdCQUFBQSxRQUFRLEVBQUV1QjtBQUF2QixlQUFuQjtBQUNBO0FBQ0Q7QUFDRDtBQUNELE9BL0NvQyxDQWlEckM7OztBQUNBcFcsTUFBQUEsR0FBRyxHQUFHLElBQU47O0FBQ0EsVUFBS29WLGFBQWEsR0FBR1AsU0FBUSxDQUFDMWlGLE1BQTlCLEVBQXVDO0FBQ3RDd2pGLFFBQUFBLFlBQVksQ0FBQ2hqRixJQUFiLENBQW1CO0FBQUVrbUUsVUFBQUEsSUFBSSxFQUFFbUgsR0FBUjtBQUFhNlUsVUFBQUEsUUFBUSxFQUFFQSxTQUFRLENBQUM5aEUsS0FBVCxDQUFnQnFpRSxhQUFoQjtBQUF2QixTQUFuQjtBQUNBOztBQUVELGFBQU9PLFlBQVA7QUFDQSxLQTVUYTtBQThUZFksSUFBQUEsT0FBTyxFQUFFLGlCQUFVemhFLElBQVYsRUFBZ0IwaEUsSUFBaEIsRUFBdUI7QUFDL0JocEYsTUFBQUEsTUFBTSxDQUFDZ1QsY0FBUCxDQUF1QjQzRCxNQUFNLENBQUNxZSxLQUFQLENBQWFscEYsU0FBcEMsRUFBK0N1bkIsSUFBL0MsRUFBcUQ7QUFDcERpUyxRQUFBQSxVQUFVLEVBQUUsSUFEd0M7QUFFcERDLFFBQUFBLFlBQVksRUFBRSxJQUZzQztBQUlwRHZtQixRQUFBQSxHQUFHLEVBQUU4MkQsVUFBVSxDQUFFaWYsSUFBRixDQUFWLEdBQ0osWUFBVztBQUNWLGNBQUssS0FBS2pyRSxhQUFWLEVBQTBCO0FBQ3pCLG1CQUFPaXJFLElBQUksQ0FBRSxLQUFLanJFLGFBQVAsQ0FBWDtBQUNBO0FBQ0QsU0FMRyxHQU1KLFlBQVc7QUFDVixjQUFLLEtBQUtBLGFBQVYsRUFBMEI7QUFDekIsbUJBQU8sS0FBS0EsYUFBTCxDQUFvQnVKLElBQXBCLENBQVA7QUFDQTtBQUNELFNBZGtEO0FBZ0JwRGhaLFFBQUFBLEdBQUcsRUFBRSxhQUFVeE0sS0FBVixFQUFrQjtBQUN0QjlCLFVBQUFBLE1BQU0sQ0FBQ2dULGNBQVAsQ0FBdUIsSUFBdkIsRUFBNkJzVSxJQUE3QixFQUFtQztBQUNsQ2lTLFlBQUFBLFVBQVUsRUFBRSxJQURzQjtBQUVsQ0MsWUFBQUEsWUFBWSxFQUFFLElBRm9CO0FBR2xDQyxZQUFBQSxRQUFRLEVBQUUsSUFId0I7QUFJbEMzM0IsWUFBQUEsS0FBSyxFQUFFQTtBQUoyQixXQUFuQztBQU1BO0FBdkJtRCxPQUFyRDtBQXlCQSxLQXhWYTtBQTBWZHNtRixJQUFBQSxHQUFHLEVBQUUsYUFBVXJxRSxhQUFWLEVBQTBCO0FBQzlCLGFBQU9BLGFBQWEsQ0FBRTZzRCxNQUFNLENBQUNzQixPQUFULENBQWIsR0FDTm51RCxhQURNLEdBRU4sSUFBSTZzRCxNQUFNLENBQUNxZSxLQUFYLENBQWtCbHJFLGFBQWxCLENBRkQ7QUFHQSxLQTlWYTtBQWdXZHVoRSxJQUFBQSxPQUFPLEVBQUU7QUFDUjRKLE1BQUFBLElBQUksRUFBRTtBQUVMO0FBQ0FDLFFBQUFBLFFBQVEsRUFBRTtBQUhMLE9BREU7QUFNUnBwRSxNQUFBQSxLQUFLLEVBQUU7QUFFTjtBQUNBOG5FLFFBQUFBLEtBQUssRUFBRSxlQUFVOWhGLElBQVYsRUFBaUI7QUFFdkI7QUFDQTtBQUNBLGNBQUlvMUIsRUFBRSxHQUFHLFFBQVFwMUIsSUFBakIsQ0FKdUIsQ0FNdkI7O0FBQ0EsY0FBSzArRSxjQUFjLENBQUN6MkUsSUFBZixDQUFxQm10QixFQUFFLENBQUN4NEIsSUFBeEIsS0FDSnc0QixFQUFFLENBQUNwYixLQURDLElBQ1E5UixRQUFRLENBQUVrdEIsRUFBRixFQUFNLE9BQU4sQ0FEckIsRUFDdUM7QUFFdEM7QUFDQWl1RCxZQUFBQSxjQUFjLENBQUVqdUQsRUFBRixFQUFNLE9BQU4sRUFBZXNyRCxVQUFmLENBQWQ7QUFDQSxXQVpzQixDQWN2Qjs7O0FBQ0EsaUJBQU8sS0FBUDtBQUNBLFNBbkJLO0FBb0JOenhFLFFBQUFBLE9BQU8sRUFBRSxpQkFBVWpQLElBQVYsRUFBaUI7QUFFekI7QUFDQTtBQUNBLGNBQUlvMUIsRUFBRSxHQUFHLFFBQVFwMUIsSUFBakIsQ0FKeUIsQ0FNekI7O0FBQ0EsY0FBSzArRSxjQUFjLENBQUN6MkUsSUFBZixDQUFxQm10QixFQUFFLENBQUN4NEIsSUFBeEIsS0FDSnc0QixFQUFFLENBQUNwYixLQURDLElBQ1E5UixRQUFRLENBQUVrdEIsRUFBRixFQUFNLE9BQU4sQ0FEckIsRUFDdUM7QUFFdENpdUQsWUFBQUEsY0FBYyxDQUFFanVELEVBQUYsRUFBTSxPQUFOLENBQWQ7QUFDQSxXQVh3QixDQWF6Qjs7O0FBQ0EsaUJBQU8sSUFBUDtBQUNBLFNBbkNLO0FBcUNOO0FBQ0E7QUFDQW9xRCxRQUFBQSxRQUFRLEVBQUUsa0JBQVU3K0UsS0FBVixFQUFrQjtBQUMzQixjQUFJUyxNQUFNLEdBQUdULEtBQUssQ0FBQ1MsTUFBbkI7QUFDQSxpQkFBT3M5RSxjQUFjLENBQUN6MkUsSUFBZixDQUFxQjdHLE1BQU0sQ0FBQ3hFLElBQTVCLEtBQ053RSxNQUFNLENBQUM0WSxLQURELElBQ1U5UixRQUFRLENBQUU5RyxNQUFGLEVBQVUsT0FBVixDQURsQixJQUVOKzZFLFFBQVEsQ0FBQ2p2RSxHQUFULENBQWM5TCxNQUFkLEVBQXNCLE9BQXRCLENBRk0sSUFHTjhHLFFBQVEsQ0FBRTlHLE1BQUYsRUFBVSxHQUFWLENBSFQ7QUFJQTtBQTdDSyxPQU5DO0FBc0RSa2lGLE1BQUFBLFlBQVksRUFBRTtBQUNiVixRQUFBQSxZQUFZLEVBQUUsc0JBQVVqaUYsS0FBVixFQUFrQjtBQUUvQjtBQUNBO0FBQ0EsY0FBS0EsS0FBSyxDQUFDcUUsTUFBTixLQUFpQmtoRSxTQUFqQixJQUE4QnZsRSxLQUFLLENBQUNxWCxhQUF6QyxFQUF5RDtBQUN4RHJYLFlBQUFBLEtBQUssQ0FBQ3FYLGFBQU4sQ0FBb0J1ckUsV0FBcEIsR0FBa0M1aUYsS0FBSyxDQUFDcUUsTUFBeEM7QUFDQTtBQUNEO0FBUlk7QUF0RE47QUFoV0ssR0FBZixDQTloS2lGLENBaThLakY7QUFDQTtBQUNBO0FBQ0E7O0FBQ0EsV0FBU3ErRSxjQUFULENBQXlCanVELEVBQXpCLEVBQTZCeDRCLElBQTdCLEVBQW1DZ2tGLFVBQW5DLEVBQWdEO0FBRS9DO0FBQ0EsUUFBSyxDQUFDQSxVQUFOLEVBQW1CO0FBQ2xCLFVBQUt6RSxRQUFRLENBQUNqdkUsR0FBVCxDQUFja29CLEVBQWQsRUFBa0J4NEIsSUFBbEIsTUFBNkJzcEUsU0FBbEMsRUFBOEM7QUFDN0NyQixRQUFBQSxNQUFNLENBQUNsa0UsS0FBUCxDQUFhckIsR0FBYixDQUFrQjgxQixFQUFsQixFQUFzQng0QixJQUF0QixFQUE0QjhqRixVQUE1QjtBQUNBOztBQUNEO0FBQ0EsS0FSOEMsQ0FVL0M7OztBQUNBdkUsSUFBQUEsUUFBUSxDQUFDNXpFLEdBQVQsQ0FBYzZzQixFQUFkLEVBQWtCeDRCLElBQWxCLEVBQXdCLEtBQXhCO0FBQ0Fpb0UsSUFBQUEsTUFBTSxDQUFDbGtFLEtBQVAsQ0FBYXJCLEdBQWIsQ0FBa0I4MUIsRUFBbEIsRUFBc0J4NEIsSUFBdEIsRUFBNEI7QUFDM0J1d0UsTUFBQUEsU0FBUyxFQUFFLEtBRGdCO0FBRTNCYixNQUFBQSxPQUFPLEVBQUUsaUJBQVUzckUsS0FBVixFQUFrQjtBQUMxQixZQUFJNmlGLFFBQUo7QUFBQSxZQUFjeCtFLE1BQWQ7QUFBQSxZQUNDeStFLEtBQUssR0FBR3RILFFBQVEsQ0FBQ2p2RSxHQUFULENBQWMsSUFBZCxFQUFvQnRRLElBQXBCLENBRFQ7O0FBR0EsWUFBTytELEtBQUssQ0FBQytpRixTQUFOLEdBQWtCLENBQXBCLElBQTJCLEtBQU05bUYsSUFBTixDQUFoQyxFQUErQztBQUU5QztBQUNBO0FBQ0E7QUFDQSxjQUFLLENBQUM2bUYsS0FBSyxDQUFDN2tGLE1BQVosRUFBcUI7QUFFcEI7QUFDQTtBQUNBO0FBQ0E2a0YsWUFBQUEsS0FBSyxHQUFHamtFLE1BQUssQ0FBQzVYLElBQU4sQ0FBWTBDLFNBQVosQ0FBUjtBQUNBNnhFLFlBQUFBLFFBQVEsQ0FBQzV6RSxHQUFULENBQWMsSUFBZCxFQUFvQjNMLElBQXBCLEVBQTBCNm1GLEtBQTFCLEVBTm9CLENBUXBCO0FBQ0E7QUFDQTs7QUFDQUQsWUFBQUEsUUFBUSxHQUFHNUMsVUFBVSxDQUFFLElBQUYsRUFBUWhrRixJQUFSLENBQXJCO0FBQ0EsaUJBQU1BLElBQU47QUFDQW9JLFlBQUFBLE1BQU0sR0FBR20zRSxRQUFRLENBQUNqdkUsR0FBVCxDQUFjLElBQWQsRUFBb0J0USxJQUFwQixDQUFUOztBQUNBLGdCQUFLNm1GLEtBQUssS0FBS3orRSxNQUFWLElBQW9CdytFLFFBQXpCLEVBQW9DO0FBQ25DckgsY0FBQUEsUUFBUSxDQUFDNXpFLEdBQVQsQ0FBYyxJQUFkLEVBQW9CM0wsSUFBcEIsRUFBMEIsS0FBMUI7QUFDQSxhQUZELE1BRU87QUFDTm9JLGNBQUFBLE1BQU0sR0FBRyxFQUFUO0FBQ0E7O0FBQ0QsZ0JBQUt5K0UsS0FBSyxLQUFLeitFLE1BQWYsRUFBd0I7QUFFdkI7QUFDQXJFLGNBQUFBLEtBQUssQ0FBQ3NSLHdCQUFOO0FBQ0F0UixjQUFBQSxLQUFLLENBQUNDLGNBQU4sR0FKdUIsQ0FNdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQSxxQkFBT29FLE1BQU0sSUFBSUEsTUFBTSxDQUFDakosS0FBeEI7QUFDQSxhQS9CbUIsQ0FpQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQyxXQXZDRCxNQXVDTyxJQUFLLENBQUU4b0UsTUFBTSxDQUFDbGtFLEtBQVAsQ0FBYTQ0RSxPQUFiLENBQXNCMzhFLElBQXRCLEtBQWdDLEVBQWxDLEVBQXVDK2tGLFlBQTVDLEVBQTJEO0FBQ2pFaGhGLFlBQUFBLEtBQUssQ0FBQ2dpRixlQUFOO0FBQ0EsV0E5QzZDLENBZ0QvQztBQUNBOztBQUNDLFNBbERELE1Ba0RPLElBQUtjLEtBQUssQ0FBQzdrRixNQUFYLEVBQW9CO0FBRTFCO0FBQ0F1OUUsVUFBQUEsUUFBUSxDQUFDNXpFLEdBQVQsQ0FBYyxJQUFkLEVBQW9CM0wsSUFBcEIsRUFBMEI7QUFDekJiLFlBQUFBLEtBQUssRUFBRThvRSxNQUFNLENBQUNsa0UsS0FBUCxDQUFhc08sT0FBYixFQUVOO0FBQ0E7QUFDQTQxRCxZQUFBQSxNQUFNLENBQUNnQixNQUFQLENBQWU0ZCxLQUFLLENBQUUsQ0FBRixDQUFwQixFQUEyQjVlLE1BQU0sQ0FBQ3FlLEtBQVAsQ0FBYWxwRixTQUF4QyxDQUpNLEVBS055cEYsS0FBSyxDQUFDamtFLEtBQU4sQ0FBYSxDQUFiLENBTE0sRUFNTixJQU5NO0FBRGtCLFdBQTFCLEVBSDBCLENBYzFCOztBQUNBN2UsVUFBQUEsS0FBSyxDQUFDc1Isd0JBQU47QUFDQTtBQUNEO0FBekUwQixLQUE1QjtBQTJFQTs7QUFFRDR5RCxFQUFBQSxNQUFNLENBQUNxZCxXQUFQLEdBQXFCLFVBQVU1YyxJQUFWLEVBQWdCMW9FLElBQWhCLEVBQXNCc1MsTUFBdEIsRUFBK0I7QUFFbkQ7QUFDQSxRQUFLbzJELElBQUksQ0FBQzdrRSxtQkFBVixFQUFnQztBQUMvQjZrRSxNQUFBQSxJQUFJLENBQUM3a0UsbUJBQUwsQ0FBMEI3RCxJQUExQixFQUFnQ3NTLE1BQWhDO0FBQ0E7QUFDRCxHQU5EOztBQVFBMjFELEVBQUFBLE1BQU0sQ0FBQ3FlLEtBQVAsR0FBZSxVQUFVOWUsR0FBVixFQUFlcGlELEtBQWYsRUFBdUI7QUFFckM7QUFDQSxRQUFLLEVBQUcsZ0JBQWdCNmlELE1BQU0sQ0FBQ3FlLEtBQTFCLENBQUwsRUFBeUM7QUFDeEMsYUFBTyxJQUFJcmUsTUFBTSxDQUFDcWUsS0FBWCxDQUFrQjllLEdBQWxCLEVBQXVCcGlELEtBQXZCLENBQVA7QUFDQSxLQUxvQyxDQU9yQzs7O0FBQ0EsUUFBS29pRCxHQUFHLElBQUlBLEdBQUcsQ0FBQ3huRSxJQUFoQixFQUF1QjtBQUN0QixXQUFLb2IsYUFBTCxHQUFxQm9zRCxHQUFyQjtBQUNBLFdBQUt4bkUsSUFBTCxHQUFZd25FLEdBQUcsQ0FBQ3huRSxJQUFoQixDQUZzQixDQUl0QjtBQUNBOztBQUNBLFdBQUsrbUYsa0JBQUwsR0FBMEJ2ZixHQUFHLENBQUNycUQsZ0JBQUosSUFDeEJxcUQsR0FBRyxDQUFDcnFELGdCQUFKLEtBQXlCbXNELFNBQXpCLElBRUE7QUFDQTlCLE1BQUFBLEdBQUcsQ0FBQ21mLFdBQUosS0FBb0IsS0FKSSxHQUt6QjdDLFVBTHlCLEdBTXpCQyxXQU5ELENBTnNCLENBY3RCO0FBQ0E7QUFDQTs7QUFDQSxXQUFLdi9FLE1BQUwsR0FBZ0JnakUsR0FBRyxDQUFDaGpFLE1BQUosSUFBY2dqRSxHQUFHLENBQUNoakUsTUFBSixDQUFXZ0IsUUFBWCxLQUF3QixDQUF4QyxHQUNiZ2lFLEdBQUcsQ0FBQ2hqRSxNQUFKLENBQVdjLFVBREUsR0FFYmtpRSxHQUFHLENBQUNoakUsTUFGTDtBQUlBLFdBQUs0VixhQUFMLEdBQXFCb3RELEdBQUcsQ0FBQ3B0RCxhQUF6QjtBQUNBLFdBQUs0c0UsYUFBTCxHQUFxQnhmLEdBQUcsQ0FBQ3dmLGFBQXpCLENBdEJzQixDQXdCdkI7QUFDQyxLQXpCRCxNQXlCTztBQUNOLFdBQUtobkYsSUFBTCxHQUFZd25FLEdBQVo7QUFDQSxLQW5Db0MsQ0FxQ3JDOzs7QUFDQSxRQUFLcGlELEtBQUwsRUFBYTtBQUNaNmlELE1BQUFBLE1BQU0sQ0FBQ2dCLE1BQVAsQ0FBZSxJQUFmLEVBQXFCN2pELEtBQXJCO0FBQ0EsS0F4Q29DLENBMENyQzs7O0FBQ0EsU0FBSzZoRSxTQUFMLEdBQWlCemYsR0FBRyxJQUFJQSxHQUFHLENBQUN5ZixTQUFYLElBQXdCcm1GLElBQUksQ0FBQ0MsR0FBTCxFQUF6QyxDQTNDcUMsQ0E2Q3JDOztBQUNBLFNBQU1vbkUsTUFBTSxDQUFDc0IsT0FBYixJQUF5QixJQUF6QjtBQUNBLEdBL0NELENBdGlMaUYsQ0F1bExqRjtBQUNBOzs7QUFDQXRCLEVBQUFBLE1BQU0sQ0FBQ3FlLEtBQVAsQ0FBYWxwRixTQUFiLEdBQXlCO0FBQ3hCRyxJQUFBQSxXQUFXLEVBQUUwcUUsTUFBTSxDQUFDcWUsS0FESTtBQUV4QlMsSUFBQUEsa0JBQWtCLEVBQUVoRCxXQUZJO0FBR3hCNkIsSUFBQUEsb0JBQW9CLEVBQUU3QixXQUhFO0FBSXhCOEIsSUFBQUEsNkJBQTZCLEVBQUU5QixXQUpQO0FBS3hCbUQsSUFBQUEsV0FBVyxFQUFFLEtBTFc7QUFPeEJsakYsSUFBQUEsY0FBYyxFQUFFLDBCQUFXO0FBQzFCLFVBQUk5RCxDQUFDLEdBQUcsS0FBS2tiLGFBQWI7QUFFQSxXQUFLMnJFLGtCQUFMLEdBQTBCakQsVUFBMUI7O0FBRUEsVUFBSzVqRixDQUFDLElBQUksQ0FBQyxLQUFLZ25GLFdBQWhCLEVBQThCO0FBQzdCaG5GLFFBQUFBLENBQUMsQ0FBQzhELGNBQUY7QUFDQTtBQUNELEtBZnVCO0FBZ0J4QitoRixJQUFBQSxlQUFlLEVBQUUsMkJBQVc7QUFDM0IsVUFBSTdsRixDQUFDLEdBQUcsS0FBS2tiLGFBQWI7QUFFQSxXQUFLd3FFLG9CQUFMLEdBQTRCOUIsVUFBNUI7O0FBRUEsVUFBSzVqRixDQUFDLElBQUksQ0FBQyxLQUFLZ25GLFdBQWhCLEVBQThCO0FBQzdCaG5GLFFBQUFBLENBQUMsQ0FBQzZsRixlQUFGO0FBQ0E7QUFDRCxLQXhCdUI7QUF5QnhCMXdFLElBQUFBLHdCQUF3QixFQUFFLG9DQUFXO0FBQ3BDLFVBQUluVixDQUFDLEdBQUcsS0FBS2tiLGFBQWI7QUFFQSxXQUFLeXFFLDZCQUFMLEdBQXFDL0IsVUFBckM7O0FBRUEsVUFBSzVqRixDQUFDLElBQUksQ0FBQyxLQUFLZ25GLFdBQWhCLEVBQThCO0FBQzdCaG5GLFFBQUFBLENBQUMsQ0FBQ21WLHdCQUFGO0FBQ0E7O0FBRUQsV0FBSzB3RSxlQUFMO0FBQ0E7QUFuQ3VCLEdBQXpCLENBemxMaUYsQ0ErbkxqRjs7QUFDQTlkLEVBQUFBLE1BQU0sQ0FBQ3ZqQixJQUFQLENBQWE7QUFDWnlpQyxJQUFBQSxNQUFNLEVBQUUsSUFESTtBQUVaQyxJQUFBQSxPQUFPLEVBQUUsSUFGRztBQUdaNXJFLElBQUFBLFVBQVUsRUFBRSxJQUhBO0FBSVpiLElBQUFBLGNBQWMsRUFBRSxJQUpKO0FBS1pGLElBQUFBLE9BQU8sRUFBRSxJQUxHO0FBTVowRCxJQUFBQSxNQUFNLEVBQUUsSUFOSTtBQU9aa3BFLElBQUFBLFVBQVUsRUFBRSxJQVBBO0FBUVpDLElBQUFBLE9BQU8sRUFBRSxJQVJHO0FBU1oxL0UsSUFBQUEsS0FBSyxFQUFFLElBVEs7QUFVWkMsSUFBQUEsS0FBSyxFQUFFLElBVks7QUFXWjAvRSxJQUFBQSxRQUFRLEVBQUUsSUFYRTtBQVlaQyxJQUFBQSxJQUFJLEVBQUUsSUFaTTtBQWFaLFlBQVEsSUFiSTtBQWNaNWYsSUFBQUEsSUFBSSxFQUFFLElBZE07QUFlWjZmLElBQUFBLFFBQVEsRUFBRSxJQWZFO0FBZ0JaMXdELElBQUFBLEdBQUcsRUFBRSxJQWhCTztBQWlCWjJ3RCxJQUFBQSxPQUFPLEVBQUUsSUFqQkc7QUFrQlp2QixJQUFBQSxNQUFNLEVBQUUsSUFsQkk7QUFtQlp3QixJQUFBQSxPQUFPLEVBQUUsSUFuQkc7QUFvQlozb0QsSUFBQUEsT0FBTyxFQUFFLElBcEJHO0FBcUJaQyxJQUFBQSxPQUFPLEVBQUUsSUFyQkc7QUFzQlp6bEIsSUFBQUEsT0FBTyxFQUFFLElBdEJHO0FBdUJaQyxJQUFBQSxPQUFPLEVBQUUsSUF2Qkc7QUF3QlptQixJQUFBQSxTQUFTLEVBQUUsSUF4QkM7QUF5Qlp5akIsSUFBQUEsV0FBVyxFQUFFLElBekJEO0FBMEJaOWdCLElBQUFBLE9BQU8sRUFBRSxJQTFCRztBQTJCWkMsSUFBQUEsT0FBTyxFQUFFLElBM0JHO0FBNEJab3FFLElBQUFBLGFBQWEsRUFBRSxJQTVCSDtBQTZCWmowRCxJQUFBQSxTQUFTLEVBQUUsSUE3QkM7QUE4QlpwdkIsSUFBQUEsT0FBTyxFQUFFLElBOUJHO0FBK0JabVcsSUFBQUEsS0FBSyxFQUFFO0FBL0JLLEdBQWIsRUFnQ0d1dEQsTUFBTSxDQUFDbGtFLEtBQVAsQ0FBYXFpRixPQWhDaEI7QUFrQ0FuZSxFQUFBQSxNQUFNLENBQUN2akIsSUFBUCxDQUFhO0FBQUVtakMsSUFBQUEsS0FBSyxFQUFFLFNBQVQ7QUFBb0JDLElBQUFBLElBQUksRUFBRTtBQUExQixHQUFiLEVBQXFELFVBQVU5bkYsSUFBVixFQUFnQitrRixZQUFoQixFQUErQjtBQUNuRjljLElBQUFBLE1BQU0sQ0FBQ2xrRSxLQUFQLENBQWE0NEUsT0FBYixDQUFzQjM4RSxJQUF0QixJQUErQjtBQUU5QjtBQUNBa2xGLE1BQUFBLEtBQUssRUFBRSxpQkFBVztBQUVqQjtBQUNBO0FBQ0E7QUFDQXVCLFFBQUFBLGNBQWMsQ0FBRSxJQUFGLEVBQVF6bUYsSUFBUixFQUFjZ2tGLFVBQWQsQ0FBZCxDQUxpQixDQU9qQjs7QUFDQSxlQUFPLEtBQVA7QUFDQSxPQVo2QjtBQWE5QjN4RSxNQUFBQSxPQUFPLEVBQUUsbUJBQVc7QUFFbkI7QUFDQW8wRSxRQUFBQSxjQUFjLENBQUUsSUFBRixFQUFRem1GLElBQVIsQ0FBZCxDQUhtQixDQUtuQjs7QUFDQSxlQUFPLElBQVA7QUFDQSxPQXBCNkI7QUFzQjlCO0FBQ0E7QUFDQTRpRixNQUFBQSxRQUFRLEVBQUUsb0JBQVc7QUFDcEIsZUFBTyxJQUFQO0FBQ0EsT0ExQjZCO0FBNEI5Qm1DLE1BQUFBLFlBQVksRUFBRUE7QUE1QmdCLEtBQS9CO0FBOEJBLEdBL0JELEVBbHFMaUYsQ0Ftc0xqRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBOWMsRUFBQUEsTUFBTSxDQUFDdmpCLElBQVAsQ0FBYTtBQUNacWpDLElBQUFBLFVBQVUsRUFBRSxXQURBO0FBRVpDLElBQUFBLFVBQVUsRUFBRSxVQUZBO0FBR1pDLElBQUFBLFlBQVksRUFBRSxhQUhGO0FBSVpDLElBQUFBLFlBQVksRUFBRTtBQUpGLEdBQWIsRUFLRyxVQUFVQyxJQUFWLEVBQWdCMUMsR0FBaEIsRUFBc0I7QUFDeEJ4ZCxJQUFBQSxNQUFNLENBQUNsa0UsS0FBUCxDQUFhNDRFLE9BQWIsQ0FBc0J3TCxJQUF0QixJQUErQjtBQUM5QnBELE1BQUFBLFlBQVksRUFBRVUsR0FEZ0I7QUFFOUJULE1BQUFBLFFBQVEsRUFBRVMsR0FGb0I7QUFJOUJuekUsTUFBQUEsTUFBTSxFQUFFLGdCQUFVdk8sS0FBVixFQUFrQjtBQUN6QixZQUFJd2tFLEdBQUo7QUFBQSxZQUNDL2pFLE1BQU0sR0FBRyxJQURWO0FBQUEsWUFFQzRqRixPQUFPLEdBQUdya0YsS0FBSyxDQUFDaWpGLGFBRmpCO0FBQUEsWUFHQ3ZDLFNBQVMsR0FBRzFnRixLQUFLLENBQUMwZ0YsU0FIbkIsQ0FEeUIsQ0FNekI7QUFDQTs7QUFDQSxZQUFLLENBQUMyRCxPQUFELElBQWNBLE9BQU8sS0FBSzVqRixNQUFaLElBQXNCLENBQUN5akUsTUFBTSxDQUFDeUQsUUFBUCxDQUFpQmxuRSxNQUFqQixFQUF5QjRqRixPQUF6QixDQUExQyxFQUFpRjtBQUNoRnJrRixVQUFBQSxLQUFLLENBQUMvRCxJQUFOLEdBQWF5a0YsU0FBUyxDQUFDRyxRQUF2QjtBQUNBcmMsVUFBQUEsR0FBRyxHQUFHa2MsU0FBUyxDQUFDL1UsT0FBVixDQUFrQnJuRSxLQUFsQixDQUF5QixJQUF6QixFQUErQnFGLFNBQS9CLENBQU47QUFDQTNKLFVBQUFBLEtBQUssQ0FBQy9ELElBQU4sR0FBYXlsRixHQUFiO0FBQ0E7O0FBQ0QsZUFBT2xkLEdBQVA7QUFDQTtBQWxCNkIsS0FBL0I7QUFvQkEsR0ExQkQ7QUE0QkFOLEVBQUFBLE1BQU0sQ0FBQ0MsRUFBUCxDQUFVZSxNQUFWLENBQWtCO0FBRWpCa2IsSUFBQUEsRUFBRSxFQUFFLFlBQVVsMEUsS0FBVixFQUFpQnEwQyxRQUFqQixFQUEyQmxoRCxJQUEzQixFQUFpQzhrRSxFQUFqQyxFQUFzQztBQUN6QyxhQUFPaWMsR0FBRSxDQUFFLElBQUYsRUFBUWwwRSxLQUFSLEVBQWVxMEMsUUFBZixFQUF5QmxoRCxJQUF6QixFQUErQjhrRSxFQUEvQixDQUFUO0FBQ0EsS0FKZ0I7QUFLakJrYyxJQUFBQSxHQUFHLEVBQUUsYUFBVW4wRSxLQUFWLEVBQWlCcTBDLFFBQWpCLEVBQTJCbGhELElBQTNCLEVBQWlDOGtFLEVBQWpDLEVBQXNDO0FBQzFDLGFBQU9pYyxHQUFFLENBQUUsSUFBRixFQUFRbDBFLEtBQVIsRUFBZXEwQyxRQUFmLEVBQXlCbGhELElBQXpCLEVBQStCOGtFLEVBQS9CLEVBQW1DLENBQW5DLENBQVQ7QUFDQSxLQVBnQjtBQVFqQm9jLElBQUFBLEdBQUcsRUFBRSxhQUFVcjBFLEtBQVYsRUFBaUJxMEMsUUFBakIsRUFBMkI0akIsRUFBM0IsRUFBZ0M7QUFDcEMsVUFBSXVjLFNBQUosRUFBZXprRixJQUFmOztBQUNBLFVBQUtpUSxLQUFLLElBQUlBLEtBQUssQ0FBQ2pNLGNBQWYsSUFBaUNpTSxLQUFLLENBQUN3MEUsU0FBNUMsRUFBd0Q7QUFFdkQ7QUFDQUEsUUFBQUEsU0FBUyxHQUFHeDBFLEtBQUssQ0FBQ3cwRSxTQUFsQjtBQUNBeGMsUUFBQUEsTUFBTSxDQUFFaDRELEtBQUssQ0FBQ3kxRSxjQUFSLENBQU4sQ0FBK0JwQixHQUEvQixDQUNDRyxTQUFTLENBQUNsVSxTQUFWLEdBQ0NrVSxTQUFTLENBQUNHLFFBQVYsR0FBcUIsR0FBckIsR0FBMkJILFNBQVMsQ0FBQ2xVLFNBRHRDLEdBRUNrVSxTQUFTLENBQUNHLFFBSFosRUFJQ0gsU0FBUyxDQUFDbmdDLFFBSlgsRUFLQ21nQyxTQUFTLENBQUMvVSxPQUxYO0FBT0EsZUFBTyxJQUFQO0FBQ0E7O0FBQ0QsVUFBSyxRQUFPei9ELEtBQVAsTUFBaUIsUUFBdEIsRUFBaUM7QUFFaEM7QUFDQSxhQUFNalEsSUFBTixJQUFjaVEsS0FBZCxFQUFzQjtBQUNyQixlQUFLcTBFLEdBQUwsQ0FBVXRrRixJQUFWLEVBQWdCc2tELFFBQWhCLEVBQTBCcjBDLEtBQUssQ0FBRWpRLElBQUYsQ0FBL0I7QUFDQTs7QUFDRCxlQUFPLElBQVA7QUFDQTs7QUFDRCxVQUFLc2tELFFBQVEsS0FBSyxLQUFiLElBQXNCLE9BQU9BLFFBQVAsS0FBb0IsVUFBL0MsRUFBNEQ7QUFFM0Q7QUFDQTRqQixRQUFBQSxFQUFFLEdBQUc1akIsUUFBTDtBQUNBQSxRQUFBQSxRQUFRLEdBQUdnbEIsU0FBWDtBQUNBOztBQUNELFVBQUtwQixFQUFFLEtBQUssS0FBWixFQUFvQjtBQUNuQkEsUUFBQUEsRUFBRSxHQUFHNmIsV0FBTDtBQUNBOztBQUNELGFBQU8sS0FBS3IvQixJQUFMLENBQVcsWUFBVztBQUM1QnVqQixRQUFBQSxNQUFNLENBQUNsa0UsS0FBUCxDQUFhbkIsTUFBYixDQUFxQixJQUFyQixFQUEyQnFOLEtBQTNCLEVBQWtDaTRELEVBQWxDLEVBQXNDNWpCLFFBQXRDO0FBQ0EsT0FGTSxDQUFQO0FBR0E7QUEzQ2dCLEdBQWxCO0FBK0NBLE1BRUM7QUFDQTtBQUNBO0FBQ0ErakMsRUFBQUEsWUFBWSxHQUFHLHVCQUxoQjtBQUFBLE1BT0M7QUFDQUMsRUFBQUEsUUFBUSxHQUFHLG1DQVJaO0FBQUEsTUFTQ0MsWUFBWSxHQUFHLDBDQVRoQixDQXR4TGlGLENBaXlMakY7O0FBQ0EsV0FBU0Msa0JBQVQsQ0FBNkI5ZixJQUE3QixFQUFtQ3I4RCxPQUFuQyxFQUE2QztBQUM1QyxRQUFLZixRQUFRLENBQUVvOUQsSUFBRixFQUFRLE9BQVIsQ0FBUixJQUNKcDlELFFBQVEsQ0FBRWUsT0FBTyxDQUFDN0csUUFBUixLQUFxQixFQUFyQixHQUEwQjZHLE9BQTFCLEdBQW9DQSxPQUFPLENBQUNHLFVBQTlDLEVBQTBELElBQTFELENBRFQsRUFDNEU7QUFFM0UsYUFBT3k3RCxNQUFNLENBQUVTLElBQUYsQ0FBTixDQUFlem1FLFFBQWYsQ0FBeUIsT0FBekIsRUFBb0MsQ0FBcEMsS0FBMkN5bUUsSUFBbEQ7QUFDQTs7QUFFRCxXQUFPQSxJQUFQO0FBQ0EsR0ExeUxnRixDQTR5TGpGOzs7QUFDQSxXQUFTK2YsYUFBVCxDQUF3Qi9mLElBQXhCLEVBQStCO0FBQzlCQSxJQUFBQSxJQUFJLENBQUMxb0UsSUFBTCxHQUFZLENBQUUwb0UsSUFBSSxDQUFDdjlELFlBQUwsQ0FBbUIsTUFBbkIsTUFBZ0MsSUFBbEMsSUFBMkMsR0FBM0MsR0FBaUR1OUQsSUFBSSxDQUFDMW9FLElBQWxFO0FBQ0EsV0FBTzBvRSxJQUFQO0FBQ0E7O0FBQ0QsV0FBU2dnQixhQUFULENBQXdCaGdCLElBQXhCLEVBQStCO0FBQzlCLFFBQUssQ0FBRUEsSUFBSSxDQUFDMW9FLElBQUwsSUFBYSxFQUFmLEVBQW9CNGlCLEtBQXBCLENBQTJCLENBQTNCLEVBQThCLENBQTlCLE1BQXNDLE9BQTNDLEVBQXFEO0FBQ3BEOGxELE1BQUFBLElBQUksQ0FBQzFvRSxJQUFMLEdBQVkwb0UsSUFBSSxDQUFDMW9FLElBQUwsQ0FBVTRpQixLQUFWLENBQWlCLENBQWpCLENBQVo7QUFDQSxLQUZELE1BRU87QUFDTjhsRCxNQUFBQSxJQUFJLENBQUN0SyxlQUFMLENBQXNCLE1BQXRCO0FBQ0E7O0FBRUQsV0FBT3NLLElBQVA7QUFDQTs7QUFFRCxXQUFTaWdCLGNBQVQsQ0FBeUJuaEIsR0FBekIsRUFBOEJvaEIsSUFBOUIsRUFBcUM7QUFDcEMsUUFBSTdtRixDQUFKLEVBQU8rSSxDQUFQLEVBQVU5SyxJQUFWLEVBQWdCNm9GLFFBQWhCLEVBQTBCQyxRQUExQixFQUFvQ0MsUUFBcEMsRUFBOEMxbUQsTUFBOUM7O0FBRUEsUUFBS3VtRCxJQUFJLENBQUNwakYsUUFBTCxLQUFrQixDQUF2QixFQUEyQjtBQUMxQjtBQUNBLEtBTG1DLENBT3BDOzs7QUFDQSxRQUFLKzVFLFFBQVEsQ0FBQ0QsT0FBVCxDQUFrQjlYLEdBQWxCLENBQUwsRUFBK0I7QUFDOUJxaEIsTUFBQUEsUUFBUSxHQUFHdEosUUFBUSxDQUFDanZFLEdBQVQsQ0FBY2szRCxHQUFkLENBQVg7QUFDQW5sQyxNQUFBQSxNQUFNLEdBQUd3bUQsUUFBUSxDQUFDeG1ELE1BQWxCOztBQUVBLFVBQUtBLE1BQUwsRUFBYztBQUNiazlDLFFBQUFBLFFBQVEsQ0FBQzM4RSxNQUFULENBQWlCZ21GLElBQWpCLEVBQXVCLGVBQXZCOztBQUVBLGFBQU01b0YsSUFBTixJQUFjcWlDLE1BQWQsRUFBdUI7QUFDdEIsZUFBTXRnQyxDQUFDLEdBQUcsQ0FBSixFQUFPK0ksQ0FBQyxHQUFHdTNCLE1BQU0sQ0FBRXJpQyxJQUFGLENBQU4sQ0FBZWdDLE1BQWhDLEVBQXdDRCxDQUFDLEdBQUcrSSxDQUE1QyxFQUErQy9JLENBQUMsRUFBaEQsRUFBcUQ7QUFDcERrbUUsWUFBQUEsTUFBTSxDQUFDbGtFLEtBQVAsQ0FBYXJCLEdBQWIsQ0FBa0JrbUYsSUFBbEIsRUFBd0I1b0YsSUFBeEIsRUFBOEJxaUMsTUFBTSxDQUFFcmlDLElBQUYsQ0FBTixDQUFnQitCLENBQWhCLENBQTlCO0FBQ0E7QUFDRDtBQUNEO0FBQ0QsS0FyQm1DLENBdUJwQzs7O0FBQ0EsUUFBS3k5RSxRQUFRLENBQUNGLE9BQVQsQ0FBa0I5WCxHQUFsQixDQUFMLEVBQStCO0FBQzlCc2hCLE1BQUFBLFFBQVEsR0FBR3RKLFFBQVEsQ0FBQ2pCLE1BQVQsQ0FBaUIvVyxHQUFqQixDQUFYO0FBQ0F1aEIsTUFBQUEsUUFBUSxHQUFHOWdCLE1BQU0sQ0FBQ2dCLE1BQVAsQ0FBZSxFQUFmLEVBQW1CNmYsUUFBbkIsQ0FBWDtBQUVBdEosTUFBQUEsUUFBUSxDQUFDN3pFLEdBQVQsQ0FBY2k5RSxJQUFkLEVBQW9CRyxRQUFwQjtBQUNBO0FBQ0QsR0F6MUxnRixDQTIxTGpGOzs7QUFDQSxXQUFTQyxRQUFULENBQW1CeGhCLEdBQW5CLEVBQXdCb2hCLElBQXhCLEVBQStCO0FBQzlCLFFBQUl0OUUsUUFBUSxHQUFHczlFLElBQUksQ0FBQ3Q5RSxRQUFMLENBQWM3RSxXQUFkLEVBQWYsQ0FEOEIsQ0FHOUI7O0FBQ0EsUUFBSzZFLFFBQVEsS0FBSyxPQUFiLElBQXdCdzJFLGNBQWMsQ0FBQ3oyRSxJQUFmLENBQXFCbThELEdBQUcsQ0FBQ3huRSxJQUF6QixDQUE3QixFQUErRDtBQUM5RDRvRixNQUFBQSxJQUFJLENBQUM5VCxPQUFMLEdBQWV0TixHQUFHLENBQUNzTixPQUFuQixDQUQ4RCxDQUcvRDtBQUNDLEtBSkQsTUFJTyxJQUFLeHBFLFFBQVEsS0FBSyxPQUFiLElBQXdCQSxRQUFRLEtBQUssVUFBMUMsRUFBdUQ7QUFDN0RzOUUsTUFBQUEsSUFBSSxDQUFDcFEsWUFBTCxHQUFvQmhSLEdBQUcsQ0FBQ2dSLFlBQXhCO0FBQ0E7QUFDRDs7QUFFRCxXQUFTeVEsUUFBVCxDQUFtQkMsVUFBbkIsRUFBK0IvdkIsSUFBL0IsRUFBcUMvekQsUUFBckMsRUFBK0NvK0UsT0FBL0MsRUFBeUQ7QUFFeEQ7QUFDQXJxQixJQUFBQSxJQUFJLEdBQUd3TixJQUFJLENBQUV4TixJQUFGLENBQVg7QUFFQSxRQUFJOG9CLFFBQUo7QUFBQSxRQUFjenhELEtBQWQ7QUFBQSxRQUFxQjh5RCxPQUFyQjtBQUFBLFFBQThCNkYsVUFBOUI7QUFBQSxRQUEwQzU4RSxJQUExQztBQUFBLFFBQWdENUgsR0FBaEQ7QUFBQSxRQUNDNUMsQ0FBQyxHQUFHLENBREw7QUFBQSxRQUVDK0ksQ0FBQyxHQUFHbytFLFVBQVUsQ0FBQ2xuRixNQUZoQjtBQUFBLFFBR0NvbkYsUUFBUSxHQUFHdCtFLENBQUMsR0FBRyxDQUhoQjtBQUFBLFFBSUMzTCxLQUFLLEdBQUdnNkQsSUFBSSxDQUFFLENBQUYsQ0FKYjtBQUFBLFFBS0Nrd0IsZUFBZSxHQUFHamlCLFVBQVUsQ0FBRWpvRSxLQUFGLENBTDdCLENBTHdELENBWXhEOztBQUNBLFFBQUtrcUYsZUFBZSxJQUNoQnYrRSxDQUFDLEdBQUcsQ0FBSixJQUFTLE9BQU8zTCxLQUFQLEtBQWlCLFFBQTFCLElBQ0QsQ0FBQ2dvRSxPQUFPLENBQUNnYixVQURSLElBQ3NCbUcsUUFBUSxDQUFDajlFLElBQVQsQ0FBZWxNLEtBQWYsQ0FGMUIsRUFFcUQ7QUFDcEQsYUFBTytwRixVQUFVLENBQUN4a0MsSUFBWCxDQUFpQixVQUFVOWdDLEtBQVYsRUFBa0I7QUFDekMsWUFBSTdtQixJQUFJLEdBQUdtc0YsVUFBVSxDQUFDdmdCLEVBQVgsQ0FBZS9rRCxLQUFmLENBQVg7O0FBQ0EsWUFBS3lsRSxlQUFMLEVBQXVCO0FBQ3RCbHdCLFVBQUFBLElBQUksQ0FBRSxDQUFGLENBQUosR0FBWWg2RCxLQUFLLENBQUM2TCxJQUFOLENBQVksSUFBWixFQUFrQjRZLEtBQWxCLEVBQXlCN21CLElBQUksQ0FBQ3VzRixJQUFMLEVBQXpCLENBQVo7QUFDQTs7QUFDREwsUUFBQUEsUUFBUSxDQUFFbHNGLElBQUYsRUFBUW84RCxJQUFSLEVBQWMvekQsUUFBZCxFQUF3Qm8rRSxPQUF4QixDQUFSO0FBQ0EsT0FOTSxDQUFQO0FBT0E7O0FBRUQsUUFBSzE0RSxDQUFMLEVBQVM7QUFDUm0zRSxNQUFBQSxRQUFRLEdBQUdvQixhQUFhLENBQUVscUIsSUFBRixFQUFRK3ZCLFVBQVUsQ0FBRSxDQUFGLENBQVYsQ0FBZ0J4aEYsYUFBeEIsRUFBdUMsS0FBdkMsRUFBOEN3aEYsVUFBOUMsRUFBMEQxRixPQUExRCxDQUF4QjtBQUNBaHpELE1BQUFBLEtBQUssR0FBR3l4RCxRQUFRLENBQUN6MUUsVUFBakI7O0FBRUEsVUFBS3kxRSxRQUFRLENBQUMxVCxVQUFULENBQW9CdnNFLE1BQXBCLEtBQStCLENBQXBDLEVBQXdDO0FBQ3ZDaWdGLFFBQUFBLFFBQVEsR0FBR3p4RCxLQUFYO0FBQ0EsT0FOTyxDQVFSOzs7QUFDQSxVQUFLQSxLQUFLLElBQUlnekQsT0FBZCxFQUF3QjtBQUN2QkYsUUFBQUEsT0FBTyxHQUFHcmIsTUFBTSxDQUFDM25ELEdBQVAsQ0FBWStmLE1BQU0sQ0FBRTRoRCxRQUFGLEVBQVksUUFBWixDQUFsQixFQUEwQ3dHLGFBQTFDLENBQVY7QUFDQVUsUUFBQUEsVUFBVSxHQUFHN0YsT0FBTyxDQUFDdGhGLE1BQXJCLENBRnVCLENBSXZCO0FBQ0E7QUFDQTs7QUFDQSxlQUFRRCxDQUFDLEdBQUcrSSxDQUFaLEVBQWUvSSxDQUFDLEVBQWhCLEVBQXFCO0FBQ3BCd0ssVUFBQUEsSUFBSSxHQUFHMDFFLFFBQVA7O0FBRUEsY0FBS2xnRixDQUFDLEtBQUtxbkYsUUFBWCxFQUFzQjtBQUNyQjc4RSxZQUFBQSxJQUFJLEdBQUcwN0QsTUFBTSxDQUFDbjBDLEtBQVAsQ0FBY3ZuQixJQUFkLEVBQW9CLElBQXBCLEVBQTBCLElBQTFCLENBQVAsQ0FEcUIsQ0FHckI7O0FBQ0EsZ0JBQUs0OEUsVUFBTCxFQUFrQjtBQUVqQjtBQUNBO0FBQ0FsaEIsY0FBQUEsTUFBTSxDQUFDTyxLQUFQLENBQWM4YSxPQUFkLEVBQXVCampELE1BQU0sQ0FBRTl6QixJQUFGLEVBQVEsUUFBUixDQUE3QjtBQUNBO0FBQ0Q7O0FBRURuSCxVQUFBQSxRQUFRLENBQUM0RixJQUFULENBQWVrK0UsVUFBVSxDQUFFbm5GLENBQUYsQ0FBekIsRUFBZ0N3SyxJQUFoQyxFQUFzQ3hLLENBQXRDO0FBQ0E7O0FBRUQsWUFBS29uRixVQUFMLEVBQWtCO0FBQ2pCeGtGLFVBQUFBLEdBQUcsR0FBRzIrRSxPQUFPLENBQUVBLE9BQU8sQ0FBQ3RoRixNQUFSLEdBQWlCLENBQW5CLENBQVAsQ0FBOEIwRixhQUFwQyxDQURpQixDQUdqQjs7QUFDQXVnRSxVQUFBQSxNQUFNLENBQUMzbkQsR0FBUCxDQUFZZ2pFLE9BQVosRUFBcUJvRixhQUFyQixFQUppQixDQU1qQjs7QUFDQSxlQUFNM21GLENBQUMsR0FBRyxDQUFWLEVBQWFBLENBQUMsR0FBR29uRixVQUFqQixFQUE2QnBuRixDQUFDLEVBQTlCLEVBQW1DO0FBQ2xDd0ssWUFBQUEsSUFBSSxHQUFHKzJFLE9BQU8sQ0FBRXZoRixDQUFGLENBQWQ7O0FBQ0EsZ0JBQUtpZ0YsV0FBVyxDQUFDMzJFLElBQVosQ0FBa0JrQixJQUFJLENBQUN2TSxJQUFMLElBQWEsRUFBL0IsS0FDSixDQUFDdS9FLFFBQVEsQ0FBQ2hCLE1BQVQsQ0FBaUJoeUUsSUFBakIsRUFBdUIsWUFBdkIsQ0FERyxJQUVKMDdELE1BQU0sQ0FBQ3lELFFBQVAsQ0FBaUIvbUUsR0FBakIsRUFBc0I0SCxJQUF0QixDQUZELEVBRWdDO0FBRS9CLGtCQUFLQSxJQUFJLENBQUNpN0QsR0FBTCxJQUFZLENBQUVqN0QsSUFBSSxDQUFDdk0sSUFBTCxJQUFhLEVBQWYsRUFBb0J5RyxXQUFwQixPQUF1QyxRQUF4RCxFQUFtRTtBQUVsRTtBQUNBLG9CQUFLd2hFLE1BQU0sQ0FBQ3NoQixRQUFQLElBQW1CLENBQUNoOUUsSUFBSSxDQUFDbTdELFFBQTlCLEVBQXlDO0FBQ3hDTyxrQkFBQUEsTUFBTSxDQUFDc2hCLFFBQVAsQ0FBaUJoOUUsSUFBSSxDQUFDaTdELEdBQXRCLEVBQTJCO0FBQzFCQyxvQkFBQUEsS0FBSyxFQUFFbDdELElBQUksQ0FBQ2s3RCxLQUFMLElBQWNsN0QsSUFBSSxDQUFDcEIsWUFBTCxDQUFtQixPQUFuQjtBQURLLG1CQUEzQixFQUVHeEcsR0FGSDtBQUdBO0FBQ0QsZUFSRCxNQVFPO0FBQ05nakUsZ0JBQUFBLE9BQU8sQ0FBRXA3RCxJQUFJLENBQUNtbUUsV0FBTCxDQUFpQnR5RSxPQUFqQixDQUEwQm1vRixZQUExQixFQUF3QyxFQUF4QyxDQUFGLEVBQWdEaDhFLElBQWhELEVBQXNENUgsR0FBdEQsQ0FBUDtBQUNBO0FBQ0Q7QUFDRDtBQUNEO0FBQ0Q7QUFDRDs7QUFFRCxXQUFPdWtGLFVBQVA7QUFDQTs7QUFFRCxXQUFTdG1GLE9BQVQsQ0FBaUI4bEUsSUFBakIsRUFBdUJwa0IsUUFBdkIsRUFBaUNrbEMsUUFBakMsRUFBNEM7QUFDM0MsUUFBSWo5RSxJQUFKO0FBQUEsUUFDQ20zRSxLQUFLLEdBQUdwL0IsUUFBUSxHQUFHMmpCLE1BQU0sQ0FBQzluQyxNQUFQLENBQWVta0IsUUFBZixFQUF5Qm9rQixJQUF6QixDQUFILEdBQXFDQSxJQUR0RDtBQUFBLFFBRUMzbUUsQ0FBQyxHQUFHLENBRkw7O0FBSUEsV0FBUSxDQUFFd0ssSUFBSSxHQUFHbTNFLEtBQUssQ0FBRTNoRixDQUFGLENBQWQsS0FBeUIsSUFBakMsRUFBdUNBLENBQUMsRUFBeEMsRUFBNkM7QUFDNUMsVUFBSyxDQUFDeW5GLFFBQUQsSUFBYWo5RSxJQUFJLENBQUMvRyxRQUFMLEtBQWtCLENBQXBDLEVBQXdDO0FBQ3ZDeWlFLFFBQUFBLE1BQU0sQ0FBQ3doQixTQUFQLENBQWtCcHBELE1BQU0sQ0FBRTl6QixJQUFGLENBQXhCO0FBQ0E7O0FBRUQsVUFBS0EsSUFBSSxDQUFDakgsVUFBVixFQUF1QjtBQUN0QixZQUFLa2tGLFFBQVEsSUFBSTNJLFVBQVUsQ0FBRXQwRSxJQUFGLENBQTNCLEVBQXNDO0FBQ3JDNDJFLFVBQUFBLGFBQWEsQ0FBRTlpRCxNQUFNLENBQUU5ekIsSUFBRixFQUFRLFFBQVIsQ0FBUixDQUFiO0FBQ0E7O0FBQ0RBLFFBQUFBLElBQUksQ0FBQ2pILFVBQUwsQ0FBZ0JnSixXQUFoQixDQUE2Qi9CLElBQTdCO0FBQ0E7QUFDRDs7QUFFRCxXQUFPbThELElBQVA7QUFDQTs7QUFFRFQsRUFBQUEsTUFBTSxDQUFDZ0IsTUFBUCxDQUFlO0FBQ2QyYSxJQUFBQSxhQUFhLEVBQUUsdUJBQVUwRixJQUFWLEVBQWlCO0FBQy9CLGFBQU9BLElBQVA7QUFDQSxLQUhhO0FBS2R4MUQsSUFBQUEsS0FBSyxFQUFFLGVBQVU0MEMsSUFBVixFQUFnQmdoQixhQUFoQixFQUErQkMsaUJBQS9CLEVBQW1EO0FBQ3pELFVBQUk1bkYsQ0FBSjtBQUFBLFVBQU8rSSxDQUFQO0FBQUEsVUFBVTgrRSxXQUFWO0FBQUEsVUFBdUJDLFlBQXZCO0FBQUEsVUFDQy8xRCxLQUFLLEdBQUc0MEMsSUFBSSxDQUFDMFosU0FBTCxDQUFnQixJQUFoQixDQURUO0FBQUEsVUFFQzBILE1BQU0sR0FBR2pKLFVBQVUsQ0FBRW5ZLElBQUYsQ0FGcEIsQ0FEeUQsQ0FLekQ7O0FBQ0EsVUFBSyxDQUFDdkIsT0FBTyxDQUFDa2IsY0FBVCxLQUE2QjNaLElBQUksQ0FBQ2xqRSxRQUFMLEtBQWtCLENBQWxCLElBQXVCa2pFLElBQUksQ0FBQ2xqRSxRQUFMLEtBQWtCLEVBQXRFLEtBQ0gsQ0FBQ3lpRSxNQUFNLENBQUN5USxRQUFQLENBQWlCaFEsSUFBakIsQ0FESCxFQUM2QjtBQUU1QjtBQUNBbWhCLFFBQUFBLFlBQVksR0FBR3hwRCxNQUFNLENBQUV2TSxLQUFGLENBQXJCO0FBQ0E4MUQsUUFBQUEsV0FBVyxHQUFHdnBELE1BQU0sQ0FBRXFvQyxJQUFGLENBQXBCOztBQUVBLGFBQU0zbUUsQ0FBQyxHQUFHLENBQUosRUFBTytJLENBQUMsR0FBRzgrRSxXQUFXLENBQUM1bkYsTUFBN0IsRUFBcUNELENBQUMsR0FBRytJLENBQXpDLEVBQTRDL0ksQ0FBQyxFQUE3QyxFQUFrRDtBQUNqRGluRixVQUFBQSxRQUFRLENBQUVZLFdBQVcsQ0FBRTduRixDQUFGLENBQWIsRUFBb0I4bkYsWUFBWSxDQUFFOW5GLENBQUYsQ0FBaEMsQ0FBUjtBQUNBO0FBQ0QsT0FoQndELENBa0J6RDs7O0FBQ0EsVUFBSzJuRixhQUFMLEVBQXFCO0FBQ3BCLFlBQUtDLGlCQUFMLEVBQXlCO0FBQ3hCQyxVQUFBQSxXQUFXLEdBQUdBLFdBQVcsSUFBSXZwRCxNQUFNLENBQUVxb0MsSUFBRixDQUFuQztBQUNBbWhCLFVBQUFBLFlBQVksR0FBR0EsWUFBWSxJQUFJeHBELE1BQU0sQ0FBRXZNLEtBQUYsQ0FBckM7O0FBRUEsZUFBTS94QixDQUFDLEdBQUcsQ0FBSixFQUFPK0ksQ0FBQyxHQUFHOCtFLFdBQVcsQ0FBQzVuRixNQUE3QixFQUFxQ0QsQ0FBQyxHQUFHK0ksQ0FBekMsRUFBNEMvSSxDQUFDLEVBQTdDLEVBQWtEO0FBQ2pENG1GLFlBQUFBLGNBQWMsQ0FBRWlCLFdBQVcsQ0FBRTduRixDQUFGLENBQWIsRUFBb0I4bkYsWUFBWSxDQUFFOW5GLENBQUYsQ0FBaEMsQ0FBZDtBQUNBO0FBQ0QsU0FQRCxNQU9PO0FBQ040bUYsVUFBQUEsY0FBYyxDQUFFamdCLElBQUYsRUFBUTUwQyxLQUFSLENBQWQ7QUFDQTtBQUNELE9BOUJ3RCxDQWdDekQ7OztBQUNBKzFELE1BQUFBLFlBQVksR0FBR3hwRCxNQUFNLENBQUV2TSxLQUFGLEVBQVMsUUFBVCxDQUFyQjs7QUFDQSxVQUFLKzFELFlBQVksQ0FBQzduRixNQUFiLEdBQXNCLENBQTNCLEVBQStCO0FBQzlCbWhGLFFBQUFBLGFBQWEsQ0FBRTBHLFlBQUYsRUFBZ0IsQ0FBQ0MsTUFBRCxJQUFXenBELE1BQU0sQ0FBRXFvQyxJQUFGLEVBQVEsUUFBUixDQUFqQyxDQUFiO0FBQ0EsT0FwQ3dELENBc0N6RDs7O0FBQ0EsYUFBTzUwQyxLQUFQO0FBQ0EsS0E3Q2E7QUErQ2QyMUQsSUFBQUEsU0FBUyxFQUFFLG1CQUFVbmhCLEtBQVYsRUFBa0I7QUFDNUIsVUFBSWxsRSxJQUFKO0FBQUEsVUFBVXNsRSxJQUFWO0FBQUEsVUFBZ0Ixb0UsSUFBaEI7QUFBQSxVQUNDMjhFLE9BQU8sR0FBRzFVLE1BQU0sQ0FBQ2xrRSxLQUFQLENBQWE0NEUsT0FEeEI7QUFBQSxVQUVDNTZFLENBQUMsR0FBRyxDQUZMOztBQUlBLGFBQVEsQ0FBRTJtRSxJQUFJLEdBQUdKLEtBQUssQ0FBRXZtRSxDQUFGLENBQWQsTUFBMEJ1bkUsU0FBbEMsRUFBNkN2bkUsQ0FBQyxFQUE5QyxFQUFtRDtBQUNsRCxZQUFLbTlFLFVBQVUsQ0FBRXhXLElBQUYsQ0FBZixFQUEwQjtBQUN6QixjQUFPdGxFLElBQUksR0FBR3NsRSxJQUFJLENBQUU2VyxRQUFRLENBQUNoVyxPQUFYLENBQWxCLEVBQTJDO0FBQzFDLGdCQUFLbm1FLElBQUksQ0FBQ2kvQixNQUFWLEVBQW1CO0FBQ2xCLG1CQUFNcmlDLElBQU4sSUFBY29ELElBQUksQ0FBQ2kvQixNQUFuQixFQUE0QjtBQUMzQixvQkFBS3M2QyxPQUFPLENBQUUzOEUsSUFBRixDQUFaLEVBQXVCO0FBQ3RCaW9FLGtCQUFBQSxNQUFNLENBQUNsa0UsS0FBUCxDQUFhbkIsTUFBYixDQUFxQjhsRSxJQUFyQixFQUEyQjFvRSxJQUEzQixFQURzQixDQUd2QjtBQUNDLGlCQUpELE1BSU87QUFDTmlvRSxrQkFBQUEsTUFBTSxDQUFDcWQsV0FBUCxDQUFvQjVjLElBQXBCLEVBQTBCMW9FLElBQTFCLEVBQWdDb0QsSUFBSSxDQUFDa1AsTUFBckM7QUFDQTtBQUNEO0FBQ0QsYUFYeUMsQ0FhMUM7QUFDQTs7O0FBQ0FvMkQsWUFBQUEsSUFBSSxDQUFFNlcsUUFBUSxDQUFDaFcsT0FBWCxDQUFKLEdBQTJCRCxTQUEzQjtBQUNBOztBQUNELGNBQUtaLElBQUksQ0FBRThXLFFBQVEsQ0FBQ2pXLE9BQVgsQ0FBVCxFQUFnQztBQUUvQjtBQUNBO0FBQ0FiLFlBQUFBLElBQUksQ0FBRThXLFFBQVEsQ0FBQ2pXLE9BQVgsQ0FBSixHQUEyQkQsU0FBM0I7QUFDQTtBQUNEO0FBQ0Q7QUFDRDtBQS9FYSxHQUFmO0FBa0ZBckIsRUFBQUEsTUFBTSxDQUFDQyxFQUFQLENBQVVlLE1BQVYsQ0FBa0I7QUFDakI4Z0IsSUFBQUEsTUFBTSxFQUFFLGdCQUFVemxDLFFBQVYsRUFBcUI7QUFDNUIsYUFBTzFoRCxPQUFNLENBQUUsSUFBRixFQUFRMGhELFFBQVIsRUFBa0IsSUFBbEIsQ0FBYjtBQUNBLEtBSGdCO0FBS2pCMWhELElBQUFBLE1BQU0sRUFBRSxnQkFBVTBoRCxRQUFWLEVBQXFCO0FBQzVCLGFBQU8xaEQsT0FBTSxDQUFFLElBQUYsRUFBUTBoRCxRQUFSLENBQWI7QUFDQSxLQVBnQjtBQVNqQndqQixJQUFBQSxJQUFJLEVBQUUsY0FBVTNvRSxLQUFWLEVBQWtCO0FBQ3ZCLGFBQU9vL0UsTUFBTSxDQUFFLElBQUYsRUFBUSxVQUFVcC9FLEtBQVYsRUFBa0I7QUFDdEMsZUFBT0EsS0FBSyxLQUFLbXFFLFNBQVYsR0FDTnJCLE1BQU0sQ0FBQ0gsSUFBUCxDQUFhLElBQWIsQ0FETSxHQUVOLEtBQUtxVCxLQUFMLEdBQWF6MkIsSUFBYixDQUFtQixZQUFXO0FBQzdCLGNBQUssS0FBS2wvQyxRQUFMLEtBQWtCLENBQWxCLElBQXVCLEtBQUtBLFFBQUwsS0FBa0IsRUFBekMsSUFBK0MsS0FBS0EsUUFBTCxLQUFrQixDQUF0RSxFQUEwRTtBQUN6RSxpQkFBS2t0RSxXQUFMLEdBQW1CdnpFLEtBQW5CO0FBQ0E7QUFDRCxTQUpELENBRkQ7QUFPQSxPQVJZLEVBUVYsSUFSVSxFQVFKQSxLQVJJLEVBUUd1TyxTQUFTLENBQUMxTCxNQVJiLENBQWI7QUFTQSxLQW5CZ0I7QUFxQmpCZ29GLElBQUFBLE1BQU0sRUFBRSxrQkFBVztBQUNsQixhQUFPZixRQUFRLENBQUUsSUFBRixFQUFRdjdFLFNBQVIsRUFBbUIsVUFBVWc3RCxJQUFWLEVBQWlCO0FBQ2xELFlBQUssS0FBS2xqRSxRQUFMLEtBQWtCLENBQWxCLElBQXVCLEtBQUtBLFFBQUwsS0FBa0IsRUFBekMsSUFBK0MsS0FBS0EsUUFBTCxLQUFrQixDQUF0RSxFQUEwRTtBQUN6RSxjQUFJaEIsTUFBTSxHQUFHZ2tGLGtCQUFrQixDQUFFLElBQUYsRUFBUTlmLElBQVIsQ0FBL0I7QUFDQWxrRSxVQUFBQSxNQUFNLENBQUM2SixXQUFQLENBQW9CcTZELElBQXBCO0FBQ0E7QUFDRCxPQUxjLENBQWY7QUFNQSxLQTVCZ0I7QUE4QmpCdWhCLElBQUFBLE9BQU8sRUFBRSxtQkFBVztBQUNuQixhQUFPaEIsUUFBUSxDQUFFLElBQUYsRUFBUXY3RSxTQUFSLEVBQW1CLFVBQVVnN0QsSUFBVixFQUFpQjtBQUNsRCxZQUFLLEtBQUtsakUsUUFBTCxLQUFrQixDQUFsQixJQUF1QixLQUFLQSxRQUFMLEtBQWtCLEVBQXpDLElBQStDLEtBQUtBLFFBQUwsS0FBa0IsQ0FBdEUsRUFBMEU7QUFDekUsY0FBSWhCLE1BQU0sR0FBR2drRixrQkFBa0IsQ0FBRSxJQUFGLEVBQVE5ZixJQUFSLENBQS9CO0FBQ0Fsa0UsVUFBQUEsTUFBTSxDQUFDMGlCLFlBQVAsQ0FBcUJ3aEQsSUFBckIsRUFBMkJsa0UsTUFBTSxDQUFDZ0ksVUFBbEM7QUFDQTtBQUNELE9BTGMsQ0FBZjtBQU1BLEtBckNnQjtBQXVDakIwOUUsSUFBQUEsTUFBTSxFQUFFLGtCQUFXO0FBQ2xCLGFBQU9qQixRQUFRLENBQUUsSUFBRixFQUFRdjdFLFNBQVIsRUFBbUIsVUFBVWc3RCxJQUFWLEVBQWlCO0FBQ2xELFlBQUssS0FBS3BqRSxVQUFWLEVBQXVCO0FBQ3RCLGVBQUtBLFVBQUwsQ0FBZ0I0aEIsWUFBaEIsQ0FBOEJ3aEQsSUFBOUIsRUFBb0MsSUFBcEM7QUFDQTtBQUNELE9BSmMsQ0FBZjtBQUtBLEtBN0NnQjtBQStDakJ5aEIsSUFBQUEsS0FBSyxFQUFFLGlCQUFXO0FBQ2pCLGFBQU9sQixRQUFRLENBQUUsSUFBRixFQUFRdjdFLFNBQVIsRUFBbUIsVUFBVWc3RCxJQUFWLEVBQWlCO0FBQ2xELFlBQUssS0FBS3BqRSxVQUFWLEVBQXVCO0FBQ3RCLGVBQUtBLFVBQUwsQ0FBZ0I0aEIsWUFBaEIsQ0FBOEJ3aEQsSUFBOUIsRUFBb0MsS0FBS3Q2RCxXQUF6QztBQUNBO0FBQ0QsT0FKYyxDQUFmO0FBS0EsS0FyRGdCO0FBdURqQitzRSxJQUFBQSxLQUFLLEVBQUUsaUJBQVc7QUFDakIsVUFBSXpTLElBQUo7QUFBQSxVQUNDM21FLENBQUMsR0FBRyxDQURMOztBQUdBLGFBQVEsQ0FBRTJtRSxJQUFJLEdBQUcsS0FBTTNtRSxDQUFOLENBQVQsS0FBd0IsSUFBaEMsRUFBc0NBLENBQUMsRUFBdkMsRUFBNEM7QUFDM0MsWUFBSzJtRSxJQUFJLENBQUNsakUsUUFBTCxLQUFrQixDQUF2QixFQUEyQjtBQUUxQjtBQUNBeWlFLFVBQUFBLE1BQU0sQ0FBQ3doQixTQUFQLENBQWtCcHBELE1BQU0sQ0FBRXFvQyxJQUFGLEVBQVEsS0FBUixDQUF4QixFQUgwQixDQUsxQjs7QUFDQUEsVUFBQUEsSUFBSSxDQUFDZ0ssV0FBTCxHQUFtQixFQUFuQjtBQUNBO0FBQ0Q7O0FBRUQsYUFBTyxJQUFQO0FBQ0EsS0F2RWdCO0FBeUVqQjUrQyxJQUFBQSxLQUFLLEVBQUUsZUFBVTQxRCxhQUFWLEVBQXlCQyxpQkFBekIsRUFBNkM7QUFDbkRELE1BQUFBLGFBQWEsR0FBR0EsYUFBYSxJQUFJLElBQWpCLEdBQXdCLEtBQXhCLEdBQWdDQSxhQUFoRDtBQUNBQyxNQUFBQSxpQkFBaUIsR0FBR0EsaUJBQWlCLElBQUksSUFBckIsR0FBNEJELGFBQTVCLEdBQTRDQyxpQkFBaEU7QUFFQSxhQUFPLEtBQUtycEUsR0FBTCxDQUFVLFlBQVc7QUFDM0IsZUFBTzJuRCxNQUFNLENBQUNuMEMsS0FBUCxDQUFjLElBQWQsRUFBb0I0MUQsYUFBcEIsRUFBbUNDLGlCQUFuQyxDQUFQO0FBQ0EsT0FGTSxDQUFQO0FBR0EsS0FoRmdCO0FBa0ZqQkwsSUFBQUEsSUFBSSxFQUFFLGNBQVVucUYsS0FBVixFQUFrQjtBQUN2QixhQUFPby9FLE1BQU0sQ0FBRSxJQUFGLEVBQVEsVUFBVXAvRSxLQUFWLEVBQWtCO0FBQ3RDLFlBQUl1cEUsSUFBSSxHQUFHLEtBQU0sQ0FBTixLQUFhLEVBQXhCO0FBQUEsWUFDQzNtRSxDQUFDLEdBQUcsQ0FETDtBQUFBLFlBRUMrSSxDQUFDLEdBQUcsS0FBSzlJLE1BRlY7O0FBSUEsWUFBSzdDLEtBQUssS0FBS21xRSxTQUFWLElBQXVCWixJQUFJLENBQUNsakUsUUFBTCxLQUFrQixDQUE5QyxFQUFrRDtBQUNqRCxpQkFBT2tqRSxJQUFJLENBQUMxNEQsU0FBWjtBQUNBLFNBUHFDLENBU3RDOzs7QUFDQSxZQUFLLE9BQU83USxLQUFQLEtBQWlCLFFBQWpCLElBQTZCLENBQUNrcEYsWUFBWSxDQUFDaDlFLElBQWIsQ0FBbUJsTSxLQUFuQixDQUE5QixJQUNKLENBQUNvakYsT0FBTyxDQUFFLENBQUVSLFFBQVEsQ0FBQ3ArQixJQUFULENBQWV4a0QsS0FBZixLQUEwQixDQUFFLEVBQUYsRUFBTSxFQUFOLENBQTVCLEVBQTBDLENBQTFDLEVBQThDc0gsV0FBOUMsRUFBRixDQURULEVBQzJFO0FBRTFFdEgsVUFBQUEsS0FBSyxHQUFHOG9FLE1BQU0sQ0FBQzJiLGFBQVAsQ0FBc0J6a0YsS0FBdEIsQ0FBUjs7QUFFQSxjQUFJO0FBQ0gsbUJBQVE0QyxDQUFDLEdBQUcrSSxDQUFaLEVBQWUvSSxDQUFDLEVBQWhCLEVBQXFCO0FBQ3BCMm1FLGNBQUFBLElBQUksR0FBRyxLQUFNM21FLENBQU4sS0FBYSxFQUFwQixDQURvQixDQUdwQjs7QUFDQSxrQkFBSzJtRSxJQUFJLENBQUNsakUsUUFBTCxLQUFrQixDQUF2QixFQUEyQjtBQUMxQnlpRSxnQkFBQUEsTUFBTSxDQUFDd2hCLFNBQVAsQ0FBa0JwcEQsTUFBTSxDQUFFcW9DLElBQUYsRUFBUSxLQUFSLENBQXhCO0FBQ0FBLGdCQUFBQSxJQUFJLENBQUMxNEQsU0FBTCxHQUFpQjdRLEtBQWpCO0FBQ0E7QUFDRDs7QUFFRHVwRSxZQUFBQSxJQUFJLEdBQUcsQ0FBUCxDQVhHLENBYUo7QUFDQyxXQWRELENBY0UsT0FBUXhvRSxDQUFSLEVBQVksQ0FBRTtBQUNoQjs7QUFFRCxZQUFLd29FLElBQUwsRUFBWTtBQUNYLGVBQUt5UyxLQUFMLEdBQWE2TyxNQUFiLENBQXFCN3FGLEtBQXJCO0FBQ0E7QUFDRCxPQW5DWSxFQW1DVixJQW5DVSxFQW1DSkEsS0FuQ0ksRUFtQ0d1TyxTQUFTLENBQUMxTCxNQW5DYixDQUFiO0FBb0NBLEtBdkhnQjtBQXlIakJvb0YsSUFBQUEsV0FBVyxFQUFFLHVCQUFXO0FBQ3ZCLFVBQUk1RyxPQUFPLEdBQUcsRUFBZCxDQUR1QixDQUd2Qjs7QUFDQSxhQUFPeUYsUUFBUSxDQUFFLElBQUYsRUFBUXY3RSxTQUFSLEVBQW1CLFVBQVVnN0QsSUFBVixFQUFpQjtBQUNsRCxZQUFJNTRELE1BQU0sR0FBRyxLQUFLeEssVUFBbEI7O0FBRUEsWUFBSzJpRSxNQUFNLENBQUNpQyxPQUFQLENBQWdCLElBQWhCLEVBQXNCc1osT0FBdEIsSUFBa0MsQ0FBdkMsRUFBMkM7QUFDMUN2YixVQUFBQSxNQUFNLENBQUN3aEIsU0FBUCxDQUFrQnBwRCxNQUFNLENBQUUsSUFBRixDQUF4Qjs7QUFDQSxjQUFLdndCLE1BQUwsRUFBYztBQUNiQSxZQUFBQSxNQUFNLENBQUN1NkUsWUFBUCxDQUFxQjNoQixJQUFyQixFQUEyQixJQUEzQjtBQUNBO0FBQ0QsU0FSaUQsQ0FVbkQ7O0FBQ0MsT0FYYyxFQVdaOGEsT0FYWSxDQUFmO0FBWUE7QUF6SWdCLEdBQWxCO0FBNElBdmIsRUFBQUEsTUFBTSxDQUFDdmpCLElBQVAsQ0FBYTtBQUNaNGxDLElBQUFBLFFBQVEsRUFBRSxRQURFO0FBRVpDLElBQUFBLFNBQVMsRUFBRSxTQUZDO0FBR1pyakUsSUFBQUEsWUFBWSxFQUFFLFFBSEY7QUFJWnNqRSxJQUFBQSxXQUFXLEVBQUUsT0FKRDtBQUtaQyxJQUFBQSxVQUFVLEVBQUU7QUFMQSxHQUFiLEVBTUcsVUFBVTlsRSxJQUFWLEVBQWdCK2xFLFFBQWhCLEVBQTJCO0FBQzdCemlCLElBQUFBLE1BQU0sQ0FBQ0MsRUFBUCxDQUFXdmpELElBQVgsSUFBb0IsVUFBVTIvQixRQUFWLEVBQXFCO0FBQ3hDLFVBQUlna0IsS0FBSjtBQUFBLFVBQ0NDLEdBQUcsR0FBRyxFQURQO0FBQUEsVUFFQ29pQixNQUFNLEdBQUcxaUIsTUFBTSxDQUFFM2pCLFFBQUYsQ0FGaEI7QUFBQSxVQUdDN3pCLElBQUksR0FBR2s2RCxNQUFNLENBQUMzb0YsTUFBUCxHQUFnQixDQUh4QjtBQUFBLFVBSUNELENBQUMsR0FBRyxDQUpMOztBQU1BLGFBQVFBLENBQUMsSUFBSTB1QixJQUFiLEVBQW1CMXVCLENBQUMsRUFBcEIsRUFBeUI7QUFDeEJ1bUUsUUFBQUEsS0FBSyxHQUFHdm1FLENBQUMsS0FBSzB1QixJQUFOLEdBQWEsSUFBYixHQUFvQixLQUFLcUQsS0FBTCxDQUFZLElBQVosQ0FBNUI7QUFDQW0wQyxRQUFBQSxNQUFNLENBQUUwaUIsTUFBTSxDQUFFNW9GLENBQUYsQ0FBUixDQUFOLENBQXVCMm9GLFFBQXZCLEVBQW1DcGlCLEtBQW5DLEVBRndCLENBSXhCO0FBQ0E7O0FBQ0E5bEUsUUFBQUEsSUFBSSxDQUFDNkYsS0FBTCxDQUFZa2dFLEdBQVosRUFBaUJELEtBQUssQ0FBQ2g0RCxHQUFOLEVBQWpCO0FBQ0E7O0FBRUQsYUFBTyxLQUFLKzNELFNBQUwsQ0FBZ0JFLEdBQWhCLENBQVA7QUFDQSxLQWpCRDtBQWtCQSxHQXpCRDtBQTBCQSxNQUFJcWlCLFNBQVMsR0FBRyxJQUFJNS9CLE1BQUosQ0FBWSxPQUFPMDFCLElBQVAsR0FBYyxpQkFBMUIsRUFBNkMsR0FBN0MsQ0FBaEI7O0FBRUEsTUFBSW1LLFNBQVMsR0FBRyxTQUFaQSxTQUFZLENBQVVuaUIsSUFBVixFQUFpQjtBQUUvQjtBQUNBO0FBQ0E7QUFDQSxRQUFJOGUsSUFBSSxHQUFHOWUsSUFBSSxDQUFDaGhFLGFBQUwsQ0FBbUJpcEUsV0FBOUI7O0FBRUEsUUFBSyxDQUFDNlcsSUFBRCxJQUFTLENBQUNBLElBQUksQ0FBQ3NELE1BQXBCLEVBQTZCO0FBQzVCdEQsTUFBQUEsSUFBSSxHQUFHem9GLE1BQVA7QUFDQTs7QUFFRCxXQUFPeW9GLElBQUksQ0FBQzdnRixnQkFBTCxDQUF1QitoRSxJQUF2QixDQUFQO0FBQ0EsR0FaRjs7QUFjQSxNQUFJcGpELElBQUksR0FBRyxTQUFQQSxJQUFPLENBQVVvakQsSUFBVixFQUFnQlEsT0FBaEIsRUFBeUI5akUsUUFBekIsRUFBb0M7QUFDOUMsUUFBSW1qRSxHQUFKO0FBQUEsUUFBUzVqRCxJQUFUO0FBQUEsUUFDQ3JRLEdBQUcsR0FBRyxFQURQLENBRDhDLENBSTlDOztBQUNBLFNBQU1xUSxJQUFOLElBQWN1a0QsT0FBZCxFQUF3QjtBQUN2QjUwRCxNQUFBQSxHQUFHLENBQUVxUSxJQUFGLENBQUgsR0FBYytqRCxJQUFJLENBQUNwb0UsS0FBTCxDQUFZcWtCLElBQVosQ0FBZDtBQUNBK2pELE1BQUFBLElBQUksQ0FBQ3BvRSxLQUFMLENBQVlxa0IsSUFBWixJQUFxQnVrRCxPQUFPLENBQUV2a0QsSUFBRixDQUE1QjtBQUNBOztBQUVENGpELElBQUFBLEdBQUcsR0FBR25qRSxRQUFRLENBQUM0RixJQUFULENBQWUwOUQsSUFBZixDQUFOLENBVjhDLENBWTlDOztBQUNBLFNBQU0vakQsSUFBTixJQUFjdWtELE9BQWQsRUFBd0I7QUFDdkJSLE1BQUFBLElBQUksQ0FBQ3BvRSxLQUFMLENBQVlxa0IsSUFBWixJQUFxQnJRLEdBQUcsQ0FBRXFRLElBQUYsQ0FBeEI7QUFDQTs7QUFFRCxXQUFPNGpELEdBQVA7QUFDQSxHQWxCRDs7QUFxQkEsTUFBSXdpQixTQUFTLEdBQUcsSUFBSS8vQixNQUFKLENBQVk0MUIsU0FBUyxDQUFDbjZELElBQVYsQ0FBZ0IsR0FBaEIsQ0FBWixFQUFtQyxHQUFuQyxDQUFoQjs7QUFJQSxHQUFFLFlBQVc7QUFFWjtBQUNBO0FBQ0EsYUFBU3VrRSxpQkFBVCxHQUE2QjtBQUU1QjtBQUNBLFVBQUssQ0FBQ3I3RSxHQUFOLEVBQVk7QUFDWDtBQUNBOztBQUVENjJCLE1BQUFBLFNBQVMsQ0FBQ2xtQyxLQUFWLENBQWdCK08sT0FBaEIsR0FBMEIsZ0RBQ3pCLG1DQUREO0FBRUFNLE1BQUFBLEdBQUcsQ0FBQ3JQLEtBQUosQ0FBVStPLE9BQVYsR0FDQywyRUFDQSxxQ0FEQSxHQUVBLGtCQUhEO0FBSUF2SyxNQUFBQSxlQUFlLENBQUN1SixXQUFoQixDQUE2Qm00QixTQUE3QixFQUF5Q240QixXQUF6QyxDQUFzRHNCLEdBQXREO0FBRUEsVUFBSXM3RSxRQUFRLEdBQUdsc0YsTUFBTSxDQUFDNEgsZ0JBQVAsQ0FBeUJnSixHQUF6QixDQUFmO0FBQ0F1N0UsTUFBQUEsZ0JBQWdCLEdBQUdELFFBQVEsQ0FBQ2hrRixHQUFULEtBQWlCLElBQXBDLENBaEI0QixDQWtCNUI7O0FBQ0Fra0YsTUFBQUEscUJBQXFCLEdBQUdDLGtCQUFrQixDQUFFSCxRQUFRLENBQUNJLFVBQVgsQ0FBbEIsS0FBOEMsRUFBdEUsQ0FuQjRCLENBcUI1QjtBQUNBOztBQUNBMTdFLE1BQUFBLEdBQUcsQ0FBQ3JQLEtBQUosQ0FBVTZHLEtBQVYsR0FBa0IsS0FBbEI7QUFDQW1rRixNQUFBQSxpQkFBaUIsR0FBR0Ysa0JBQWtCLENBQUVILFFBQVEsQ0FBQzlqRixLQUFYLENBQWxCLEtBQXlDLEVBQTdELENBeEI0QixDQTBCNUI7QUFDQTs7QUFDQW9rRixNQUFBQSxvQkFBb0IsR0FBR0gsa0JBQWtCLENBQUVILFFBQVEsQ0FBQy9qRixLQUFYLENBQWxCLEtBQXlDLEVBQWhFLENBNUI0QixDQThCNUI7QUFDQTtBQUNBO0FBQ0E7O0FBQ0F5SSxNQUFBQSxHQUFHLENBQUNyUCxLQUFKLENBQVV5TCxRQUFWLEdBQXFCLFVBQXJCO0FBQ0F5L0UsTUFBQUEsZ0JBQWdCLEdBQUdKLGtCQUFrQixDQUFFejdFLEdBQUcsQ0FBQzZqQixXQUFKLEdBQWtCLENBQXBCLENBQWxCLEtBQThDLEVBQWpFO0FBRUExdUIsTUFBQUEsZUFBZSxDQUFDd0osV0FBaEIsQ0FBNkJrNEIsU0FBN0IsRUFyQzRCLENBdUM1QjtBQUNBOztBQUNBNzJCLE1BQUFBLEdBQUcsR0FBRyxJQUFOO0FBQ0E7O0FBRUQsYUFBU3k3RSxrQkFBVCxDQUE2QkssT0FBN0IsRUFBdUM7QUFDdEMsYUFBTy9yRixJQUFJLENBQUNDLEtBQUwsQ0FBWXdLLFVBQVUsQ0FBRXNoRixPQUFGLENBQXRCLENBQVA7QUFDQTs7QUFFRCxRQUFJUCxnQkFBSjtBQUFBLFFBQXNCSyxvQkFBdEI7QUFBQSxRQUE0Q0MsZ0JBQTVDO0FBQUEsUUFBOERGLGlCQUE5RDtBQUFBLFFBQ0NJLHVCQUREO0FBQUEsUUFDMEJQLHFCQUQxQjtBQUFBLFFBRUMza0QsU0FBUyxHQUFHbDZCLFFBQVEsQ0FBQ2pNLGFBQVQsQ0FBd0IsS0FBeEIsQ0FGYjtBQUFBLFFBR0NzUCxHQUFHLEdBQUdyRCxRQUFRLENBQUNqTSxhQUFULENBQXdCLEtBQXhCLENBSFAsQ0FwRFksQ0F5RFo7O0FBQ0EsUUFBSyxDQUFDc1AsR0FBRyxDQUFDclAsS0FBVixFQUFrQjtBQUNqQjtBQUNBLEtBNURXLENBOERaO0FBQ0E7OztBQUNBcVAsSUFBQUEsR0FBRyxDQUFDclAsS0FBSixDQUFVcXJGLGNBQVYsR0FBMkIsYUFBM0I7QUFDQWg4RSxJQUFBQSxHQUFHLENBQUN5eUUsU0FBSixDQUFlLElBQWYsRUFBc0I5aEYsS0FBdEIsQ0FBNEJxckYsY0FBNUIsR0FBNkMsRUFBN0M7QUFDQXhrQixJQUFBQSxPQUFPLENBQUN5a0IsZUFBUixHQUEwQmo4RSxHQUFHLENBQUNyUCxLQUFKLENBQVVxckYsY0FBVixLQUE2QixhQUF2RDtBQUVBMWpCLElBQUFBLE1BQU0sQ0FBQ2dCLE1BQVAsQ0FBZTlCLE9BQWYsRUFBd0I7QUFDdkIwa0IsTUFBQUEsaUJBQWlCLEVBQUUsNkJBQVc7QUFDN0JiLFFBQUFBLGlCQUFpQjtBQUNqQixlQUFPTyxvQkFBUDtBQUNBLE9BSnNCO0FBS3ZCTyxNQUFBQSxjQUFjLEVBQUUsMEJBQVc7QUFDMUJkLFFBQUFBLGlCQUFpQjtBQUNqQixlQUFPTSxpQkFBUDtBQUNBLE9BUnNCO0FBU3ZCUyxNQUFBQSxhQUFhLEVBQUUseUJBQVc7QUFDekJmLFFBQUFBLGlCQUFpQjtBQUNqQixlQUFPRSxnQkFBUDtBQUNBLE9BWnNCO0FBYXZCYyxNQUFBQSxrQkFBa0IsRUFBRSw4QkFBVztBQUM5QmhCLFFBQUFBLGlCQUFpQjtBQUNqQixlQUFPRyxxQkFBUDtBQUNBLE9BaEJzQjtBQWlCdkJjLE1BQUFBLGFBQWEsRUFBRSx5QkFBVztBQUN6QmpCLFFBQUFBLGlCQUFpQjtBQUNqQixlQUFPUSxnQkFBUDtBQUNBLE9BcEJzQjtBQXNCdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0FVLE1BQUFBLG9CQUFvQixFQUFFLGdDQUFXO0FBQ2hDLFlBQUlDLEtBQUosRUFBV3pKLEVBQVgsRUFBZTBKLE9BQWYsRUFBd0JDLE9BQXhCOztBQUNBLFlBQUtYLHVCQUF1QixJQUFJLElBQWhDLEVBQXVDO0FBQ3RDUyxVQUFBQSxLQUFLLEdBQUc3L0UsUUFBUSxDQUFDak0sYUFBVCxDQUF3QixPQUF4QixDQUFSO0FBQ0FxaUYsVUFBQUEsRUFBRSxHQUFHcDJFLFFBQVEsQ0FBQ2pNLGFBQVQsQ0FBd0IsSUFBeEIsQ0FBTDtBQUNBK3JGLFVBQUFBLE9BQU8sR0FBRzkvRSxRQUFRLENBQUNqTSxhQUFULENBQXdCLEtBQXhCLENBQVY7QUFFQThyRixVQUFBQSxLQUFLLENBQUM3ckYsS0FBTixDQUFZK08sT0FBWixHQUFzQiwwREFBdEI7QUFDQXF6RSxVQUFBQSxFQUFFLENBQUNwaUYsS0FBSCxDQUFTK08sT0FBVCxHQUFtQixrQkFBbkIsQ0FOc0MsQ0FRdEM7QUFDQTtBQUNBOztBQUNBcXpFLFVBQUFBLEVBQUUsQ0FBQ3BpRixLQUFILENBQVNnSCxNQUFULEdBQWtCLEtBQWxCO0FBQ0E4a0YsVUFBQUEsT0FBTyxDQUFDOXJGLEtBQVIsQ0FBY2dILE1BQWQsR0FBdUIsS0FBdkIsQ0Fac0MsQ0FjdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBOGtGLFVBQUFBLE9BQU8sQ0FBQzlyRixLQUFSLENBQWNxTyxPQUFkLEdBQXdCLE9BQXhCO0FBRUE3SixVQUFBQSxlQUFlLENBQ2J1SixXQURGLENBQ2U4OUUsS0FEZixFQUVFOTlFLFdBRkYsQ0FFZXEwRSxFQUZmLEVBR0VyMEUsV0FIRixDQUdlKzlFLE9BSGY7QUFLQUMsVUFBQUEsT0FBTyxHQUFHdHRGLE1BQU0sQ0FBQzRILGdCQUFQLENBQXlCKzdFLEVBQXpCLENBQVY7QUFDQWdKLFVBQUFBLHVCQUF1QixHQUFLbGhDLFFBQVEsQ0FBRTZoQyxPQUFPLENBQUMva0YsTUFBVixFQUFrQixFQUFsQixDQUFSLEdBQzNCa2pELFFBQVEsQ0FBRTZoQyxPQUFPLENBQUMvaEYsY0FBVixFQUEwQixFQUExQixDQURtQixHQUUzQmtnRCxRQUFRLENBQUU2aEMsT0FBTyxDQUFDOWhGLGlCQUFWLEVBQTZCLEVBQTdCLENBRmlCLEtBRXVCbTRFLEVBQUUsQ0FBQ2gwRSxZQUZwRDtBQUlBNUosVUFBQUEsZUFBZSxDQUFDd0osV0FBaEIsQ0FBNkI2OUUsS0FBN0I7QUFDQTs7QUFDRCxlQUFPVCx1QkFBUDtBQUNBO0FBcEVzQixLQUF4QjtBQXNFQSxHQTFJRDs7QUE2SUEsV0FBU1ksTUFBVCxDQUFpQjVqQixJQUFqQixFQUF1Qi9qRCxJQUF2QixFQUE2QjRuRSxRQUE3QixFQUF3QztBQUN2QyxRQUFJcmxGLEtBQUo7QUFBQSxRQUFXc2xGLFFBQVg7QUFBQSxRQUFxQkMsUUFBckI7QUFBQSxRQUErQmxrQixHQUEvQjtBQUFBLFFBRUM7QUFDQTtBQUNBO0FBQ0E7QUFDQWpvRSxJQUFBQSxLQUFLLEdBQUdvb0UsSUFBSSxDQUFDcG9FLEtBTmQ7QUFRQWlzRixJQUFBQSxRQUFRLEdBQUdBLFFBQVEsSUFBSTFCLFNBQVMsQ0FBRW5pQixJQUFGLENBQWhDLENBVHVDLENBV3ZDO0FBQ0E7QUFDQTs7QUFDQSxRQUFLNmpCLFFBQUwsRUFBZ0I7QUFDZmhrQixNQUFBQSxHQUFHLEdBQUdna0IsUUFBUSxDQUFDcnZCLGdCQUFULENBQTJCdjRDLElBQTNCLEtBQXFDNG5FLFFBQVEsQ0FBRTVuRSxJQUFGLENBQW5EOztBQUVBLFVBQUs0akQsR0FBRyxLQUFLLEVBQVIsSUFBYyxDQUFDc1ksVUFBVSxDQUFFblksSUFBRixDQUE5QixFQUF5QztBQUN4Q0gsUUFBQUEsR0FBRyxHQUFHTixNQUFNLENBQUMzbkUsS0FBUCxDQUFjb29FLElBQWQsRUFBb0IvakQsSUFBcEIsQ0FBTjtBQUNBLE9BTGMsQ0FPZjtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQSxVQUFLLENBQUN3aUQsT0FBTyxDQUFDMmtCLGNBQVIsRUFBRCxJQUE2QmxCLFNBQVMsQ0FBQ3YvRSxJQUFWLENBQWdCazlELEdBQWhCLENBQTdCLElBQXNEd2lCLFNBQVMsQ0FBQzEvRSxJQUFWLENBQWdCc1osSUFBaEIsQ0FBM0QsRUFBb0Y7QUFFbkY7QUFDQXpkLFFBQUFBLEtBQUssR0FBRzVHLEtBQUssQ0FBQzRHLEtBQWQ7QUFDQXNsRixRQUFBQSxRQUFRLEdBQUdsc0YsS0FBSyxDQUFDa3NGLFFBQWpCO0FBQ0FDLFFBQUFBLFFBQVEsR0FBR25zRixLQUFLLENBQUNtc0YsUUFBakIsQ0FMbUYsQ0FPbkY7O0FBQ0Fuc0YsUUFBQUEsS0FBSyxDQUFDa3NGLFFBQU4sR0FBaUJsc0YsS0FBSyxDQUFDbXNGLFFBQU4sR0FBaUJuc0YsS0FBSyxDQUFDNEcsS0FBTixHQUFjcWhFLEdBQWhEO0FBQ0FBLFFBQUFBLEdBQUcsR0FBR2drQixRQUFRLENBQUNybEYsS0FBZixDQVRtRixDQVduRjs7QUFDQTVHLFFBQUFBLEtBQUssQ0FBQzRHLEtBQU4sR0FBY0EsS0FBZDtBQUNBNUcsUUFBQUEsS0FBSyxDQUFDa3NGLFFBQU4sR0FBaUJBLFFBQWpCO0FBQ0Fsc0YsUUFBQUEsS0FBSyxDQUFDbXNGLFFBQU4sR0FBaUJBLFFBQWpCO0FBQ0E7QUFDRDs7QUFFRCxXQUFPbGtCLEdBQUcsS0FBS2UsU0FBUixHQUVOO0FBQ0E7QUFDQWYsSUFBQUEsR0FBRyxHQUFHLEVBSkEsR0FLTkEsR0FMRDtBQU1BOztBQUdELFdBQVNta0IsWUFBVCxDQUF1QkMsV0FBdkIsRUFBb0NDLE1BQXBDLEVBQTZDO0FBRTVDO0FBQ0EsV0FBTztBQUNOdDhFLE1BQUFBLEdBQUcsRUFBRSxlQUFXO0FBQ2YsWUFBS3E4RSxXQUFXLEVBQWhCLEVBQXFCO0FBRXBCO0FBQ0E7QUFDQSxpQkFBTyxLQUFLcjhFLEdBQVo7QUFDQTtBQUNBLFNBUGMsQ0FTZjs7O0FBQ0EsZUFBTyxDQUFFLEtBQUtBLEdBQUwsR0FBV3M4RSxNQUFiLEVBQXNCdmtGLEtBQXRCLENBQTZCLElBQTdCLEVBQW1DcUYsU0FBbkMsQ0FBUDtBQUNBO0FBWkssS0FBUDtBQWNBOztBQUdELE1BQUltL0UsV0FBVyxHQUFHLENBQUUsUUFBRixFQUFZLEtBQVosRUFBbUIsSUFBbkIsQ0FBbEI7QUFBQSxNQUNDQyxVQUFVLEdBQUd4Z0YsUUFBUSxDQUFDak0sYUFBVCxDQUF3QixLQUF4QixFQUFnQ0MsS0FEOUM7QUFBQSxNQUVDeXNGLFdBQVcsR0FBRyxFQUZmLENBajlNaUYsQ0FxOU1qRjs7QUFDQSxXQUFTQyxjQUFULENBQXlCcm9FLElBQXpCLEVBQWdDO0FBRS9CO0FBQ0EsUUFBSXNvRSxPQUFPLEdBQUd0b0UsSUFBSSxDQUFFLENBQUYsQ0FBSixDQUFVc0osV0FBVixLQUEwQnRKLElBQUksQ0FBQy9CLEtBQUwsQ0FBWSxDQUFaLENBQXhDO0FBQUEsUUFDQzdnQixDQUFDLEdBQUc4cUYsV0FBVyxDQUFDN3FGLE1BRGpCOztBQUdBLFdBQVFELENBQUMsRUFBVCxFQUFjO0FBQ2I0aUIsTUFBQUEsSUFBSSxHQUFHa29FLFdBQVcsQ0FBRTlxRixDQUFGLENBQVgsR0FBbUJrckYsT0FBMUI7O0FBQ0EsVUFBS3RvRSxJQUFJLElBQUltb0UsVUFBYixFQUEwQjtBQUN6QixlQUFPbm9FLElBQVA7QUFDQTtBQUNEO0FBQ0QsR0FsK01nRixDQW8rTWpGOzs7QUFDQSxXQUFTdW9FLGFBQVQsQ0FBd0J2b0UsSUFBeEIsRUFBK0I7QUFDOUIsUUFBSXdvRSxNQUFLLEdBQUdsbEIsTUFBTSxDQUFDbWxCLFFBQVAsQ0FBaUJ6b0UsSUFBakIsS0FBMkJvb0UsV0FBVyxDQUFFcG9FLElBQUYsQ0FBbEQ7O0FBRUEsUUFBS3dvRSxNQUFMLEVBQWE7QUFDWixhQUFPQSxNQUFQO0FBQ0E7O0FBQ0QsUUFBS3hvRSxJQUFJLElBQUltb0UsVUFBYixFQUEwQjtBQUN6QixhQUFPbm9FLElBQVA7QUFDQTs7QUFDRCxXQUFPb29FLFdBQVcsQ0FBRXBvRSxJQUFGLENBQVgsR0FBc0Jxb0UsY0FBYyxDQUFFcm9FLElBQUYsQ0FBZCxJQUEwQkEsSUFBdkQ7QUFDQTs7QUFHRCxNQUVDO0FBQ0E7QUFDQTtBQUNBMG9FLEVBQUFBLFlBQVksR0FBRywyQkFMaEI7QUFBQSxNQU1DQyxXQUFXLEdBQUcsS0FOZjtBQUFBLE1BT0NDLE9BQU8sR0FBRztBQUFFeGhGLElBQUFBLFFBQVEsRUFBRSxVQUFaO0FBQXdCeWhGLElBQUFBLFVBQVUsRUFBRSxRQUFwQztBQUE4QzcrRSxJQUFBQSxPQUFPLEVBQUU7QUFBdkQsR0FQWDtBQUFBLE1BUUM4K0Usa0JBQWtCLEdBQUc7QUFDcEJDLElBQUFBLGFBQWEsRUFBRSxHQURLO0FBRXBCNW5ELElBQUFBLFVBQVUsRUFBRTtBQUZRLEdBUnRCOztBQWFBLFdBQVM2bkQsaUJBQVQsQ0FBNEI3a0IsS0FBNUIsRUFBbUMzcEUsS0FBbkMsRUFBMEN5dUYsUUFBMUMsRUFBcUQ7QUFFcEQ7QUFDQTtBQUNBLFFBQUl4eUQsT0FBTyxHQUFHdWxELE9BQU8sQ0FBQ2g5QixJQUFSLENBQWN4a0QsS0FBZCxDQUFkO0FBQ0EsV0FBT2k4QixPQUFPLEdBRWI7QUFDQTE3QixJQUFBQSxJQUFJLENBQUNvRyxHQUFMLENBQVUsQ0FBVixFQUFhczFCLE9BQU8sQ0FBRSxDQUFGLENBQVAsSUFBaUJ3eUQsUUFBUSxJQUFJLENBQTdCLENBQWIsS0FBb0R4eUQsT0FBTyxDQUFFLENBQUYsQ0FBUCxJQUFnQixJQUFwRSxDQUhhLEdBSWJqOEIsS0FKRDtBQUtBOztBQUVELFdBQVMwdUYsa0JBQVQsQ0FBNkJubEIsSUFBN0IsRUFBbUNvbEIsU0FBbkMsRUFBOENDLEdBQTlDLEVBQW1EQyxXQUFuRCxFQUFnRUMsTUFBaEUsRUFBd0VDLFdBQXhFLEVBQXNGO0FBQ3JGLFFBQUluc0YsQ0FBQyxHQUFHK3JGLFNBQVMsS0FBSyxPQUFkLEdBQXdCLENBQXhCLEdBQTRCLENBQXBDO0FBQUEsUUFDQ0ssS0FBSyxHQUFHLENBRFQ7QUFBQSxRQUVDQyxLQUFLLEdBQUcsQ0FGVCxDQURxRixDQUtyRjs7QUFDQSxRQUFLTCxHQUFHLE1BQU9DLFdBQVcsR0FBRyxRQUFILEdBQWMsU0FBaEMsQ0FBUixFQUFzRDtBQUNyRCxhQUFPLENBQVA7QUFDQTs7QUFFRCxXQUFRanNGLENBQUMsR0FBRyxDQUFaLEVBQWVBLENBQUMsSUFBSSxDQUFwQixFQUF3QjtBQUV2QjtBQUNBLFVBQUtnc0YsR0FBRyxLQUFLLFFBQWIsRUFBd0I7QUFDdkJLLFFBQUFBLEtBQUssSUFBSW5tQixNQUFNLENBQUNqaEMsR0FBUCxDQUFZMGhDLElBQVosRUFBa0JxbEIsR0FBRyxHQUFHbk4sU0FBUyxDQUFFNytFLENBQUYsQ0FBakMsRUFBd0MsSUFBeEMsRUFBOENrc0YsTUFBOUMsQ0FBVDtBQUNBLE9BTHNCLENBT3ZCOzs7QUFDQSxVQUFLLENBQUNELFdBQU4sRUFBb0I7QUFFbkI7QUFDQUksUUFBQUEsS0FBSyxJQUFJbm1CLE1BQU0sQ0FBQ2poQyxHQUFQLENBQVkwaEMsSUFBWixFQUFrQixZQUFZa1ksU0FBUyxDQUFFNytFLENBQUYsQ0FBdkMsRUFBOEMsSUFBOUMsRUFBb0Rrc0YsTUFBcEQsQ0FBVCxDQUhtQixDQUtuQjs7QUFDQSxZQUFLRixHQUFHLEtBQUssU0FBYixFQUF5QjtBQUN4QkssVUFBQUEsS0FBSyxJQUFJbm1CLE1BQU0sQ0FBQ2poQyxHQUFQLENBQVkwaEMsSUFBWixFQUFrQixXQUFXa1ksU0FBUyxDQUFFNytFLENBQUYsQ0FBcEIsR0FBNEIsT0FBOUMsRUFBdUQsSUFBdkQsRUFBNkRrc0YsTUFBN0QsQ0FBVCxDQUR3QixDQUd6QjtBQUNDLFNBSkQsTUFJTztBQUNORSxVQUFBQSxLQUFLLElBQUlsbUIsTUFBTSxDQUFDamhDLEdBQVAsQ0FBWTBoQyxJQUFaLEVBQWtCLFdBQVdrWSxTQUFTLENBQUU3K0UsQ0FBRixDQUFwQixHQUE0QixPQUE5QyxFQUF1RCxJQUF2RCxFQUE2RGtzRixNQUE3RCxDQUFUO0FBQ0EsU0Faa0IsQ0FjcEI7QUFDQTs7QUFDQyxPQWhCRCxNQWdCTztBQUVOO0FBQ0EsWUFBS0YsR0FBRyxLQUFLLFNBQWIsRUFBeUI7QUFDeEJLLFVBQUFBLEtBQUssSUFBSW5tQixNQUFNLENBQUNqaEMsR0FBUCxDQUFZMGhDLElBQVosRUFBa0IsWUFBWWtZLFNBQVMsQ0FBRTcrRSxDQUFGLENBQXZDLEVBQThDLElBQTlDLEVBQW9Ea3NGLE1BQXBELENBQVQ7QUFDQSxTQUxLLENBT047OztBQUNBLFlBQUtGLEdBQUcsS0FBSyxRQUFiLEVBQXdCO0FBQ3ZCSyxVQUFBQSxLQUFLLElBQUlubUIsTUFBTSxDQUFDamhDLEdBQVAsQ0FBWTBoQyxJQUFaLEVBQWtCLFdBQVdrWSxTQUFTLENBQUU3K0UsQ0FBRixDQUFwQixHQUE0QixPQUE5QyxFQUF1RCxJQUF2RCxFQUE2RGtzRixNQUE3RCxDQUFUO0FBQ0E7QUFDRDtBQUNELEtBOUNvRixDQWdEckY7OztBQUNBLFFBQUssQ0FBQ0QsV0FBRCxJQUFnQkUsV0FBVyxJQUFJLENBQXBDLEVBQXdDO0FBRXZDO0FBQ0E7QUFDQUUsTUFBQUEsS0FBSyxJQUFJMXVGLElBQUksQ0FBQ29HLEdBQUwsQ0FBVSxDQUFWLEVBQWFwRyxJQUFJLENBQUMrc0IsSUFBTCxDQUNyQmk4QyxJQUFJLENBQUUsV0FBV29sQixTQUFTLENBQUUsQ0FBRixDQUFULENBQWU3L0QsV0FBZixFQUFYLEdBQTBDNi9ELFNBQVMsQ0FBQ2xyRSxLQUFWLENBQWlCLENBQWpCLENBQTVDLENBQUosR0FDQXNyRSxXQURBLEdBRUFFLEtBRkEsR0FHQUQsS0FIQSxHQUlBLEdBTHFCLENBT3RCO0FBQ0E7QUFSc0IsT0FBYixLQVNGLENBVFA7QUFVQTs7QUFFRCxXQUFPQyxLQUFQO0FBQ0E7O0FBRUQsV0FBU0MsZ0JBQVQsQ0FBMkIzbEIsSUFBM0IsRUFBaUNvbEIsU0FBakMsRUFBNENLLEtBQTVDLEVBQW9EO0FBRW5EO0FBQ0EsUUFBSUYsTUFBTSxHQUFHcEQsU0FBUyxDQUFFbmlCLElBQUYsQ0FBdEI7QUFBQSxRQUVDO0FBQ0E7QUFDQTRsQixJQUFBQSxlQUFlLEdBQUcsQ0FBQ25uQixPQUFPLENBQUMwa0IsaUJBQVIsRUFBRCxJQUFnQ3NDLEtBSm5EO0FBQUEsUUFLQ0gsV0FBVyxHQUFHTSxlQUFlLElBQzVCcm1CLE1BQU0sQ0FBQ2poQyxHQUFQLENBQVkwaEMsSUFBWixFQUFrQixXQUFsQixFQUErQixLQUEvQixFQUFzQ3VsQixNQUF0QyxNQUFtRCxZQU5yRDtBQUFBLFFBT0NNLGdCQUFnQixHQUFHUCxXQVBwQjtBQUFBLFFBU0NqK0UsR0FBRyxHQUFHdThFLE1BQU0sQ0FBRTVqQixJQUFGLEVBQVFvbEIsU0FBUixFQUFtQkcsTUFBbkIsQ0FUYjtBQUFBLFFBVUNPLFVBQVUsR0FBRyxXQUFXVixTQUFTLENBQUUsQ0FBRixDQUFULENBQWU3L0QsV0FBZixFQUFYLEdBQTBDNi9ELFNBQVMsQ0FBQ2xyRSxLQUFWLENBQWlCLENBQWpCLENBVnhELENBSG1ELENBZW5EO0FBQ0E7O0FBQ0EsUUFBS2dvRSxTQUFTLENBQUN2L0UsSUFBVixDQUFnQjBFLEdBQWhCLENBQUwsRUFBNkI7QUFDNUIsVUFBSyxDQUFDbytFLEtBQU4sRUFBYztBQUNiLGVBQU9wK0UsR0FBUDtBQUNBOztBQUNEQSxNQUFBQSxHQUFHLEdBQUcsTUFBTjtBQUNBLEtBdEJrRCxDQXlCbkQ7QUFDQTtBQUNBOzs7QUFDQSxRQUFLLENBQUUsQ0FBQ28zRCxPQUFPLENBQUMwa0IsaUJBQVIsRUFBRCxJQUFnQ21DLFdBQWhDLElBRU47QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFDN21CLE9BQU8sQ0FBQytrQixvQkFBUixFQUFELElBQW1DNWdGLFFBQVEsQ0FBRW85RCxJQUFGLEVBQVEsSUFBUixDQU5yQyxJQVFOO0FBQ0E7QUFDQTM0RCxJQUFBQSxHQUFHLEtBQUssTUFWRixJQVlOO0FBQ0E7QUFDQSxLQUFDNUYsVUFBVSxDQUFFNEYsR0FBRixDQUFYLElBQXNCazRELE1BQU0sQ0FBQ2poQyxHQUFQLENBQVkwaEMsSUFBWixFQUFrQixTQUFsQixFQUE2QixLQUE3QixFQUFvQ3VsQixNQUFwQyxNQUFpRCxRQWRuRSxLQWdCSjtBQUNBdmxCLElBQUFBLElBQUksQ0FBQytsQixjQUFMLEdBQXNCenNGLE1BakJ2QixFQWlCZ0M7QUFFL0Jnc0YsTUFBQUEsV0FBVyxHQUFHL2xCLE1BQU0sQ0FBQ2poQyxHQUFQLENBQVkwaEMsSUFBWixFQUFrQixXQUFsQixFQUErQixLQUEvQixFQUFzQ3VsQixNQUF0QyxNQUFtRCxZQUFqRSxDQUYrQixDQUkvQjtBQUNBO0FBQ0E7O0FBQ0FNLE1BQUFBLGdCQUFnQixHQUFHQyxVQUFVLElBQUk5bEIsSUFBakM7O0FBQ0EsVUFBSzZsQixnQkFBTCxFQUF3QjtBQUN2QngrRSxRQUFBQSxHQUFHLEdBQUcyNEQsSUFBSSxDQUFFOGxCLFVBQUYsQ0FBVjtBQUNBO0FBQ0QsS0F4RGtELENBMERuRDs7O0FBQ0F6K0UsSUFBQUEsR0FBRyxHQUFHNUYsVUFBVSxDQUFFNEYsR0FBRixDQUFWLElBQXFCLENBQTNCLENBM0RtRCxDQTZEbkQ7O0FBQ0EsV0FBU0EsR0FBRyxHQUNYODlFLGtCQUFrQixDQUNqQm5sQixJQURpQixFQUVqQm9sQixTQUZpQixFQUdqQkssS0FBSyxLQUFNSCxXQUFXLEdBQUcsUUFBSCxHQUFjLFNBQS9CLENBSFksRUFJakJPLGdCQUppQixFQUtqQk4sTUFMaUIsRUFPakI7QUFDQWwrRSxJQUFBQSxHQVJpQixDQURaLEdBV0gsSUFYSjtBQVlBOztBQUVEazRELEVBQUFBLE1BQU0sQ0FBQ2dCLE1BQVAsQ0FBZTtBQUVkO0FBQ0E7QUFDQXlsQixJQUFBQSxRQUFRLEVBQUU7QUFDVEMsTUFBQUEsT0FBTyxFQUFFO0FBQ1JyK0UsUUFBQUEsR0FBRyxFQUFFLGFBQVVvNEQsSUFBVixFQUFnQjZqQixRQUFoQixFQUEyQjtBQUMvQixjQUFLQSxRQUFMLEVBQWdCO0FBRWY7QUFDQSxnQkFBSWhrQixHQUFHLEdBQUcrakIsTUFBTSxDQUFFNWpCLElBQUYsRUFBUSxTQUFSLENBQWhCO0FBQ0EsbUJBQU9ILEdBQUcsS0FBSyxFQUFSLEdBQWEsR0FBYixHQUFtQkEsR0FBMUI7QUFDQTtBQUNEO0FBUk87QUFEQSxLQUpJO0FBaUJkO0FBQ0ErWSxJQUFBQSxTQUFTLEVBQUU7QUFDVixpQ0FBMkIsSUFEakI7QUFFVixxQkFBZSxJQUZMO0FBR1YscUJBQWUsSUFITDtBQUlWLGtCQUFZLElBSkY7QUFLVixvQkFBYyxJQUxKO0FBTVYsb0JBQWMsSUFOSjtBQU9WLGtCQUFZLElBUEY7QUFRVixvQkFBYyxJQVJKO0FBU1YsdUJBQWlCLElBVFA7QUFVVix5QkFBbUIsSUFWVDtBQVdWLGlCQUFXLElBWEQ7QUFZVixvQkFBYyxJQVpKO0FBYVYsc0JBQWdCLElBYk47QUFjVixvQkFBYyxJQWRKO0FBZVYsaUJBQVcsSUFmRDtBQWdCVixlQUFTLElBaEJDO0FBaUJWLGlCQUFXLElBakJEO0FBa0JWLGdCQUFVLElBbEJBO0FBbUJWLGdCQUFVLElBbkJBO0FBb0JWLGNBQVE7QUFwQkUsS0FsQkc7QUF5Q2Q7QUFDQTtBQUNBOEwsSUFBQUEsUUFBUSxFQUFFLEVBM0NJO0FBNkNkO0FBQ0E5c0YsSUFBQUEsS0FBSyxFQUFFLGVBQVVvb0UsSUFBVixFQUFnQi9qRCxJQUFoQixFQUFzQnhsQixLQUF0QixFQUE2Qmd2RixLQUE3QixFQUFxQztBQUUzQztBQUNBLFVBQUssQ0FBQ3psQixJQUFELElBQVNBLElBQUksQ0FBQ2xqRSxRQUFMLEtBQWtCLENBQTNCLElBQWdDa2pFLElBQUksQ0FBQ2xqRSxRQUFMLEtBQWtCLENBQWxELElBQXVELENBQUNrakUsSUFBSSxDQUFDcG9FLEtBQWxFLEVBQTBFO0FBQ3pFO0FBQ0EsT0FMMEMsQ0FPM0M7OztBQUNBLFVBQUlpb0UsR0FBSjtBQUFBLFVBQVN2b0UsSUFBVDtBQUFBLFVBQWVvZ0YsS0FBZjtBQUFBLFVBQ0N3TyxRQUFRLEdBQUc1UCxTQUFTLENBQUVyNkQsSUFBRixDQURyQjtBQUFBLFVBRUNrcUUsWUFBWSxHQUFHdkIsV0FBVyxDQUFDamlGLElBQVosQ0FBa0JzWixJQUFsQixDQUZoQjtBQUFBLFVBR0Nya0IsS0FBSyxHQUFHb29FLElBQUksQ0FBQ3BvRSxLQUhkLENBUjJDLENBYTNDO0FBQ0E7QUFDQTs7QUFDQSxVQUFLLENBQUN1dUYsWUFBTixFQUFxQjtBQUNwQmxxRSxRQUFBQSxJQUFJLEdBQUd1b0UsYUFBYSxDQUFFMEIsUUFBRixDQUFwQjtBQUNBLE9BbEIwQyxDQW9CM0M7OztBQUNBeE8sTUFBQUEsS0FBSyxHQUFHblksTUFBTSxDQUFDeW1CLFFBQVAsQ0FBaUIvcEUsSUFBakIsS0FBMkJzakQsTUFBTSxDQUFDeW1CLFFBQVAsQ0FBaUJFLFFBQWpCLENBQW5DLENBckIyQyxDQXVCM0M7O0FBQ0EsVUFBS3p2RixLQUFLLEtBQUttcUUsU0FBZixFQUEyQjtBQUMxQnRwRSxRQUFBQSxJQUFJLFdBQVViLEtBQVYsQ0FBSixDQUQwQixDQUcxQjs7QUFDQSxZQUFLYSxJQUFJLEtBQUssUUFBVCxLQUF1QnVvRSxHQUFHLEdBQUdvWSxPQUFPLENBQUNoOUIsSUFBUixDQUFjeGtELEtBQWQsQ0FBN0IsS0FBd0RvcEUsR0FBRyxDQUFFLENBQUYsQ0FBaEUsRUFBd0U7QUFDdkVwcEUsVUFBQUEsS0FBSyxHQUFHOGhGLFNBQVMsQ0FBRXZZLElBQUYsRUFBUS9qRCxJQUFSLEVBQWM0akQsR0FBZCxDQUFqQixDQUR1RSxDQUd2RTs7QUFDQXZvRSxVQUFBQSxJQUFJLEdBQUcsUUFBUDtBQUNBLFNBVHlCLENBVzFCOzs7QUFDQSxZQUFLYixLQUFLLElBQUksSUFBVCxJQUFpQkEsS0FBSyxLQUFLQSxLQUFoQyxFQUF3QztBQUN2QztBQUNBLFNBZHlCLENBZ0IxQjtBQUNBO0FBQ0E7OztBQUNBLFlBQUthLElBQUksS0FBSyxRQUFULElBQXFCLENBQUM2dUYsWUFBM0IsRUFBMEM7QUFDekMxdkYsVUFBQUEsS0FBSyxJQUFJb3BFLEdBQUcsSUFBSUEsR0FBRyxDQUFFLENBQUYsQ0FBVixLQUFxQk4sTUFBTSxDQUFDcVosU0FBUCxDQUFrQnNOLFFBQWxCLElBQStCLEVBQS9CLEdBQW9DLElBQXpELENBQVQ7QUFDQSxTQXJCeUIsQ0F1QjFCOzs7QUFDQSxZQUFLLENBQUN6bkIsT0FBTyxDQUFDeWtCLGVBQVQsSUFBNEJ6c0YsS0FBSyxLQUFLLEVBQXRDLElBQTRDd2xCLElBQUksQ0FBQ25WLE9BQUwsQ0FBYyxZQUFkLE1BQWlDLENBQWxGLEVBQXNGO0FBQ3JGbFAsVUFBQUEsS0FBSyxDQUFFcWtCLElBQUYsQ0FBTCxHQUFnQixTQUFoQjtBQUNBLFNBMUJ5QixDQTRCMUI7OztBQUNBLFlBQUssQ0FBQ3k3RCxLQUFELElBQVUsRUFBRyxTQUFTQSxLQUFaLENBQVYsSUFDSixDQUFFamhGLEtBQUssR0FBR2loRixLQUFLLENBQUN6MEUsR0FBTixDQUFXKzhELElBQVgsRUFBaUJ2cEUsS0FBakIsRUFBd0JndkYsS0FBeEIsQ0FBVixNQUFnRDdrQixTQURqRCxFQUM2RDtBQUU1RCxjQUFLdWxCLFlBQUwsRUFBb0I7QUFDbkJ2dUYsWUFBQUEsS0FBSyxDQUFDbThELFdBQU4sQ0FBbUI5M0MsSUFBbkIsRUFBeUJ4bEIsS0FBekI7QUFDQSxXQUZELE1BRU87QUFDTm1CLFlBQUFBLEtBQUssQ0FBRXFrQixJQUFGLENBQUwsR0FBZ0J4bEIsS0FBaEI7QUFDQTtBQUNEO0FBRUQsT0F2Q0QsTUF1Q087QUFFTjtBQUNBLFlBQUtpaEYsS0FBSyxJQUFJLFNBQVNBLEtBQWxCLElBQ0osQ0FBRTdYLEdBQUcsR0FBRzZYLEtBQUssQ0FBQzl2RSxHQUFOLENBQVdvNEQsSUFBWCxFQUFpQixLQUFqQixFQUF3QnlsQixLQUF4QixDQUFSLE1BQThDN2tCLFNBRC9DLEVBQzJEO0FBRTFELGlCQUFPZixHQUFQO0FBQ0EsU0FQSyxDQVNOOzs7QUFDQSxlQUFPam9FLEtBQUssQ0FBRXFrQixJQUFGLENBQVo7QUFDQTtBQUNELEtBekhhO0FBMkhkcWlCLElBQUFBLEdBQUcsRUFBRSxhQUFVMGhDLElBQVYsRUFBZ0IvakQsSUFBaEIsRUFBc0J3cEUsS0FBdEIsRUFBNkJGLE1BQTdCLEVBQXNDO0FBQzFDLFVBQUlsK0UsR0FBSjtBQUFBLFVBQVNxNEQsR0FBVDtBQUFBLFVBQWNnWSxLQUFkO0FBQUEsVUFDQ3dPLFFBQVEsR0FBRzVQLFNBQVMsQ0FBRXI2RCxJQUFGLENBRHJCO0FBQUEsVUFFQ2txRSxZQUFZLEdBQUd2QixXQUFXLENBQUNqaUYsSUFBWixDQUFrQnNaLElBQWxCLENBRmhCLENBRDBDLENBSzFDO0FBQ0E7QUFDQTs7QUFDQSxVQUFLLENBQUNrcUUsWUFBTixFQUFxQjtBQUNwQmxxRSxRQUFBQSxJQUFJLEdBQUd1b0UsYUFBYSxDQUFFMEIsUUFBRixDQUFwQjtBQUNBLE9BVnlDLENBWTFDOzs7QUFDQXhPLE1BQUFBLEtBQUssR0FBR25ZLE1BQU0sQ0FBQ3ltQixRQUFQLENBQWlCL3BFLElBQWpCLEtBQTJCc2pELE1BQU0sQ0FBQ3ltQixRQUFQLENBQWlCRSxRQUFqQixDQUFuQyxDQWIwQyxDQWUxQzs7QUFDQSxVQUFLeE8sS0FBSyxJQUFJLFNBQVNBLEtBQXZCLEVBQStCO0FBQzlCcndFLFFBQUFBLEdBQUcsR0FBR3F3RSxLQUFLLENBQUM5dkUsR0FBTixDQUFXbzRELElBQVgsRUFBaUIsSUFBakIsRUFBdUJ5bEIsS0FBdkIsQ0FBTjtBQUNBLE9BbEJ5QyxDQW9CMUM7OztBQUNBLFVBQUtwK0UsR0FBRyxLQUFLdTVELFNBQWIsRUFBeUI7QUFDeEJ2NUQsUUFBQUEsR0FBRyxHQUFHdThFLE1BQU0sQ0FBRTVqQixJQUFGLEVBQVEvakQsSUFBUixFQUFjc3BFLE1BQWQsQ0FBWjtBQUNBLE9BdkJ5QyxDQXlCMUM7OztBQUNBLFVBQUtsK0UsR0FBRyxLQUFLLFFBQVIsSUFBb0I0VSxJQUFJLElBQUk4b0Usa0JBQWpDLEVBQXNEO0FBQ3JEMTlFLFFBQUFBLEdBQUcsR0FBRzA5RSxrQkFBa0IsQ0FBRTlvRSxJQUFGLENBQXhCO0FBQ0EsT0E1QnlDLENBOEIxQzs7O0FBQ0EsVUFBS3dwRSxLQUFLLEtBQUssRUFBVixJQUFnQkEsS0FBckIsRUFBNkI7QUFDNUIvbEIsUUFBQUEsR0FBRyxHQUFHaitELFVBQVUsQ0FBRTRGLEdBQUYsQ0FBaEI7QUFDQSxlQUFPbytFLEtBQUssS0FBSyxJQUFWLElBQWtCVyxRQUFRLENBQUUxbUIsR0FBRixDQUExQixHQUFvQ0EsR0FBRyxJQUFJLENBQTNDLEdBQStDcjRELEdBQXREO0FBQ0E7O0FBRUQsYUFBT0EsR0FBUDtBQUNBO0FBaEthLEdBQWY7QUFtS0FrNEQsRUFBQUEsTUFBTSxDQUFDdmpCLElBQVAsQ0FBYSxDQUFFLFFBQUYsRUFBWSxPQUFaLENBQWIsRUFBb0MsVUFBVTlqQixFQUFWLEVBQWNrdEQsU0FBZCxFQUEwQjtBQUM3RDdsQixJQUFBQSxNQUFNLENBQUN5bUIsUUFBUCxDQUFpQlosU0FBakIsSUFBK0I7QUFDOUJ4OUUsTUFBQUEsR0FBRyxFQUFFLGFBQVVvNEQsSUFBVixFQUFnQjZqQixRQUFoQixFQUEwQjRCLEtBQTFCLEVBQWtDO0FBQ3RDLFlBQUs1QixRQUFMLEVBQWdCO0FBRWY7QUFDQTtBQUNBLGlCQUFPYyxZQUFZLENBQUNoaUYsSUFBYixDQUFtQjQ4RCxNQUFNLENBQUNqaEMsR0FBUCxDQUFZMGhDLElBQVosRUFBa0IsU0FBbEIsQ0FBbkIsT0FFTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDRSxXQUFDQSxJQUFJLENBQUMrbEIsY0FBTCxHQUFzQnpzRixNQUF2QixJQUFpQyxDQUFDMG1FLElBQUksQ0FBQzVnRSxxQkFBTCxHQUE2QlosS0FSM0QsSUFTTm9lLElBQUksQ0FBRW9qRCxJQUFGLEVBQVE2a0IsT0FBUixFQUFpQixZQUFXO0FBQy9CLG1CQUFPYyxnQkFBZ0IsQ0FBRTNsQixJQUFGLEVBQVFvbEIsU0FBUixFQUFtQkssS0FBbkIsQ0FBdkI7QUFDQSxXQUZHLENBVEUsR0FZTkUsZ0JBQWdCLENBQUUzbEIsSUFBRixFQUFRb2xCLFNBQVIsRUFBbUJLLEtBQW5CLENBWmpCO0FBYUE7QUFDRCxPQXBCNkI7QUFzQjlCeGlGLE1BQUFBLEdBQUcsRUFBRSxhQUFVKzhELElBQVYsRUFBZ0J2cEUsS0FBaEIsRUFBdUJndkYsS0FBdkIsRUFBK0I7QUFDbkMsWUFBSS95RCxPQUFKO0FBQUEsWUFDQzZ5RCxNQUFNLEdBQUdwRCxTQUFTLENBQUVuaUIsSUFBRixDQURuQjtBQUFBLFlBR0M7QUFDQTtBQUNBcW1CLFFBQUFBLGtCQUFrQixHQUFHLENBQUM1bkIsT0FBTyxDQUFDOGtCLGFBQVIsRUFBRCxJQUNwQmdDLE1BQU0sQ0FBQ2xpRixRQUFQLEtBQW9CLFVBTnRCO0FBQUEsWUFRQztBQUNBdWlGLFFBQUFBLGVBQWUsR0FBR1Msa0JBQWtCLElBQUlaLEtBVHpDO0FBQUEsWUFVQ0gsV0FBVyxHQUFHTSxlQUFlLElBQzVCcm1CLE1BQU0sQ0FBQ2poQyxHQUFQLENBQVkwaEMsSUFBWixFQUFrQixXQUFsQixFQUErQixLQUEvQixFQUFzQ3VsQixNQUF0QyxNQUFtRCxZQVhyRDtBQUFBLFlBWUNMLFFBQVEsR0FBR08sS0FBSyxHQUNmTixrQkFBa0IsQ0FDakJubEIsSUFEaUIsRUFFakJvbEIsU0FGaUIsRUFHakJLLEtBSGlCLEVBSWpCSCxXQUppQixFQUtqQkMsTUFMaUIsQ0FESCxHQVFmLENBcEJGLENBRG1DLENBdUJuQztBQUNBOztBQUNBLFlBQUtELFdBQVcsSUFBSWUsa0JBQXBCLEVBQXlDO0FBQ3hDbkIsVUFBQUEsUUFBUSxJQUFJbHVGLElBQUksQ0FBQytzQixJQUFMLENBQ1hpOEMsSUFBSSxDQUFFLFdBQVdvbEIsU0FBUyxDQUFFLENBQUYsQ0FBVCxDQUFlNy9ELFdBQWYsRUFBWCxHQUEwQzYvRCxTQUFTLENBQUNsckUsS0FBVixDQUFpQixDQUFqQixDQUE1QyxDQUFKLEdBQ0F6WSxVQUFVLENBQUU4akYsTUFBTSxDQUFFSCxTQUFGLENBQVIsQ0FEVixHQUVBRCxrQkFBa0IsQ0FBRW5sQixJQUFGLEVBQVFvbEIsU0FBUixFQUFtQixRQUFuQixFQUE2QixLQUE3QixFQUFvQ0csTUFBcEMsQ0FGbEIsR0FHQSxHQUpXLENBQVo7QUFNQSxTQWhDa0MsQ0FrQ25DOzs7QUFDQSxZQUFLTCxRQUFRLEtBQU14eUQsT0FBTyxHQUFHdWxELE9BQU8sQ0FBQ2g5QixJQUFSLENBQWN4a0QsS0FBZCxDQUFoQixDQUFSLElBQ0osQ0FBRWk4QixPQUFPLENBQUUsQ0FBRixDQUFQLElBQWdCLElBQWxCLE1BQTZCLElBRDlCLEVBQ3FDO0FBRXBDc3RDLFVBQUFBLElBQUksQ0FBQ3BvRSxLQUFMLENBQVl3dEYsU0FBWixJQUEwQjN1RixLQUExQjtBQUNBQSxVQUFBQSxLQUFLLEdBQUc4b0UsTUFBTSxDQUFDamhDLEdBQVAsQ0FBWTBoQyxJQUFaLEVBQWtCb2xCLFNBQWxCLENBQVI7QUFDQTs7QUFFRCxlQUFPSCxpQkFBaUIsQ0FBRWpsQixJQUFGLEVBQVF2cEUsS0FBUixFQUFleXVGLFFBQWYsQ0FBeEI7QUFDQTtBQWpFNkIsS0FBL0I7QUFtRUEsR0FwRUQ7QUFzRUEzbEIsRUFBQUEsTUFBTSxDQUFDeW1CLFFBQVAsQ0FBZ0JyRCxVQUFoQixHQUE2QnFCLFlBQVksQ0FBRXZsQixPQUFPLENBQUM2a0Isa0JBQVYsRUFDeEMsVUFBVXRqQixJQUFWLEVBQWdCNmpCLFFBQWhCLEVBQTJCO0FBQzFCLFFBQUtBLFFBQUwsRUFBZ0I7QUFDZixhQUFPLENBQUVwaUYsVUFBVSxDQUFFbWlGLE1BQU0sQ0FBRTVqQixJQUFGLEVBQVEsWUFBUixDQUFSLENBQVYsSUFDUkEsSUFBSSxDQUFDNWdFLHFCQUFMLEdBQTZCZCxJQUE3QixHQUNDc2UsSUFBSSxDQUFFb2pELElBQUYsRUFBUTtBQUFFMmlCLFFBQUFBLFVBQVUsRUFBRTtBQUFkLE9BQVIsRUFBMkIsWUFBVztBQUN6QyxlQUFPM2lCLElBQUksQ0FBQzVnRSxxQkFBTCxHQUE2QmQsSUFBcEM7QUFDQSxPQUZHLENBRkMsSUFLSCxJQUxKO0FBTUE7QUFDRCxHQVZ1QyxDQUF6QyxDQXA0TmlGLENBaTVOakY7O0FBQ0FpaEUsRUFBQUEsTUFBTSxDQUFDdmpCLElBQVAsQ0FBYTtBQUNac3FDLElBQUFBLE1BQU0sRUFBRSxFQURJO0FBRVpDLElBQUFBLE9BQU8sRUFBRSxFQUZHO0FBR1ovNUMsSUFBQUEsTUFBTSxFQUFFO0FBSEksR0FBYixFQUlHLFVBQVVnNkMsTUFBVixFQUFrQkMsTUFBbEIsRUFBMkI7QUFDN0JsbkIsSUFBQUEsTUFBTSxDQUFDeW1CLFFBQVAsQ0FBaUJRLE1BQU0sR0FBR0MsTUFBMUIsSUFBcUM7QUFDcENDLE1BQUFBLE1BQU0sRUFBRSxnQkFBVWp3RixLQUFWLEVBQWtCO0FBQ3pCLFlBQUk0QyxDQUFDLEdBQUcsQ0FBUjtBQUFBLFlBQ0NzdEYsUUFBUSxHQUFHLEVBRFo7QUFBQSxZQUdDO0FBQ0FDLFFBQUFBLEtBQUssR0FBRyxPQUFPbndGLEtBQVAsS0FBaUIsUUFBakIsR0FBNEJBLEtBQUssQ0FBQ2dSLEtBQU4sQ0FBYSxHQUFiLENBQTVCLEdBQWlELENBQUVoUixLQUFGLENBSjFEOztBQU1BLGVBQVE0QyxDQUFDLEdBQUcsQ0FBWixFQUFlQSxDQUFDLEVBQWhCLEVBQXFCO0FBQ3BCc3RGLFVBQUFBLFFBQVEsQ0FBRUgsTUFBTSxHQUFHdE8sU0FBUyxDQUFFNytFLENBQUYsQ0FBbEIsR0FBMEJvdEYsTUFBNUIsQ0FBUixHQUNDRyxLQUFLLENBQUV2dEYsQ0FBRixDQUFMLElBQWN1dEYsS0FBSyxDQUFFdnRGLENBQUMsR0FBRyxDQUFOLENBQW5CLElBQWdDdXRGLEtBQUssQ0FBRSxDQUFGLENBRHRDO0FBRUE7O0FBRUQsZUFBT0QsUUFBUDtBQUNBO0FBZG1DLEtBQXJDOztBQWlCQSxRQUFLSCxNQUFNLEtBQUssUUFBaEIsRUFBMkI7QUFDMUJqbkIsTUFBQUEsTUFBTSxDQUFDeW1CLFFBQVAsQ0FBaUJRLE1BQU0sR0FBR0MsTUFBMUIsRUFBbUN4akYsR0FBbkMsR0FBeUNnaUYsaUJBQXpDO0FBQ0E7QUFDRCxHQXpCRDtBQTJCQTFsQixFQUFBQSxNQUFNLENBQUNDLEVBQVAsQ0FBVWUsTUFBVixDQUFrQjtBQUNqQmppQyxJQUFBQSxHQUFHLEVBQUUsYUFBVXJpQixJQUFWLEVBQWdCeGxCLEtBQWhCLEVBQXdCO0FBQzVCLGFBQU9vL0UsTUFBTSxDQUFFLElBQUYsRUFBUSxVQUFVN1YsSUFBVixFQUFnQi9qRCxJQUFoQixFQUFzQnhsQixLQUF0QixFQUE4QjtBQUNsRCxZQUFJOHVGLE1BQUo7QUFBQSxZQUFZamxCLEdBQVo7QUFBQSxZQUNDMW9ELEdBQUcsR0FBRyxFQURQO0FBQUEsWUFFQ3ZlLENBQUMsR0FBRyxDQUZMOztBQUlBLFlBQUtsQyxLQUFLLENBQUNDLE9BQU4sQ0FBZTZrQixJQUFmLENBQUwsRUFBNkI7QUFDNUJzcEUsVUFBQUEsTUFBTSxHQUFHcEQsU0FBUyxDQUFFbmlCLElBQUYsQ0FBbEI7QUFDQU0sVUFBQUEsR0FBRyxHQUFHcmtELElBQUksQ0FBQzNpQixNQUFYOztBQUVBLGlCQUFRRCxDQUFDLEdBQUdpbkUsR0FBWixFQUFpQmpuRSxDQUFDLEVBQWxCLEVBQXVCO0FBQ3RCdWUsWUFBQUEsR0FBRyxDQUFFcUUsSUFBSSxDQUFFNWlCLENBQUYsQ0FBTixDQUFILEdBQW1Ca21FLE1BQU0sQ0FBQ2poQyxHQUFQLENBQVkwaEMsSUFBWixFQUFrQi9qRCxJQUFJLENBQUU1aUIsQ0FBRixDQUF0QixFQUE2QixLQUE3QixFQUFvQ2tzRixNQUFwQyxDQUFuQjtBQUNBOztBQUVELGlCQUFPM3RFLEdBQVA7QUFDQTs7QUFFRCxlQUFPbmhCLEtBQUssS0FBS21xRSxTQUFWLEdBQ05yQixNQUFNLENBQUMzbkUsS0FBUCxDQUFjb29FLElBQWQsRUFBb0IvakQsSUFBcEIsRUFBMEJ4bEIsS0FBMUIsQ0FETSxHQUVOOG9FLE1BQU0sQ0FBQ2poQyxHQUFQLENBQVkwaEMsSUFBWixFQUFrQi9qRCxJQUFsQixDQUZEO0FBR0EsT0FuQlksRUFtQlZBLElBbkJVLEVBbUJKeGxCLEtBbkJJLEVBbUJHdU8sU0FBUyxDQUFDMUwsTUFBVixHQUFtQixDQW5CdEIsQ0FBYjtBQW9CQTtBQXRCZ0IsR0FBbEI7O0FBMEJBLFdBQVN5aEQsS0FBVCxDQUFnQmlsQixJQUFoQixFQUFzQlEsT0FBdEIsRUFBK0IzMkMsSUFBL0IsRUFBcUN4bkIsR0FBckMsRUFBMEN3a0YsTUFBMUMsRUFBbUQ7QUFDbEQsV0FBTyxJQUFJOXJDLEtBQUssQ0FBQ3JtRCxTQUFOLENBQWdCbzRCLElBQXBCLENBQTBCa3pDLElBQTFCLEVBQWdDUSxPQUFoQyxFQUF5QzMyQyxJQUF6QyxFQUErQ3huQixHQUEvQyxFQUFvRHdrRixNQUFwRCxDQUFQO0FBQ0E7O0FBQ0R0bkIsRUFBQUEsTUFBTSxDQUFDeGtCLEtBQVAsR0FBZUEsS0FBZjtBQUVBQSxFQUFBQSxLQUFLLENBQUNybUQsU0FBTixHQUFrQjtBQUNqQkcsSUFBQUEsV0FBVyxFQUFFa21ELEtBREk7QUFFakJqdUIsSUFBQUEsSUFBSSxFQUFFLGNBQVVrekMsSUFBVixFQUFnQlEsT0FBaEIsRUFBeUIzMkMsSUFBekIsRUFBK0J4bkIsR0FBL0IsRUFBb0N3a0YsTUFBcEMsRUFBNENoOEUsSUFBNUMsRUFBbUQ7QUFDeEQsV0FBS20xRCxJQUFMLEdBQVlBLElBQVo7QUFDQSxXQUFLbjJDLElBQUwsR0FBWUEsSUFBWjtBQUNBLFdBQUtnOUQsTUFBTCxHQUFjQSxNQUFNLElBQUl0bkIsTUFBTSxDQUFDc25CLE1BQVAsQ0FBYzNNLFFBQXRDO0FBQ0EsV0FBSzFaLE9BQUwsR0FBZUEsT0FBZjtBQUNBLFdBQUs5dkQsS0FBTCxHQUFhLEtBQUt2WSxHQUFMLEdBQVcsS0FBS2d2RSxHQUFMLEVBQXhCO0FBQ0EsV0FBSzlrRSxHQUFMLEdBQVdBLEdBQVg7QUFDQSxXQUFLd0ksSUFBTCxHQUFZQSxJQUFJLEtBQU0wMEQsTUFBTSxDQUFDcVosU0FBUCxDQUFrQi91RCxJQUFsQixJQUEyQixFQUEzQixHQUFnQyxJQUF0QyxDQUFoQjtBQUNBLEtBVmdCO0FBV2pCczlDLElBQUFBLEdBQUcsRUFBRSxlQUFXO0FBQ2YsVUFBSXVRLEtBQUssR0FBRzM4QixLQUFLLENBQUMrckMsU0FBTixDQUFpQixLQUFLajlELElBQXRCLENBQVo7QUFFQSxhQUFPNnRELEtBQUssSUFBSUEsS0FBSyxDQUFDOXZFLEdBQWYsR0FDTjh2RSxLQUFLLENBQUM5dkUsR0FBTixDQUFXLElBQVgsQ0FETSxHQUVObXpDLEtBQUssQ0FBQytyQyxTQUFOLENBQWdCNU0sUUFBaEIsQ0FBeUJ0eUUsR0FBekIsQ0FBOEIsSUFBOUIsQ0FGRDtBQUdBLEtBakJnQjtBQWtCakJtL0UsSUFBQUEsR0FBRyxFQUFFLGFBQVVDLE9BQVYsRUFBb0I7QUFDeEIsVUFBSUMsS0FBSjtBQUFBLFVBQ0N2UCxLQUFLLEdBQUczOEIsS0FBSyxDQUFDK3JDLFNBQU4sQ0FBaUIsS0FBS2o5RCxJQUF0QixDQURUOztBQUdBLFVBQUssS0FBSzIyQyxPQUFMLENBQWFobUUsUUFBbEIsRUFBNkI7QUFDNUIsYUFBSzBzRixHQUFMLEdBQVdELEtBQUssR0FBRzFuQixNQUFNLENBQUNzbkIsTUFBUCxDQUFlLEtBQUtBLE1BQXBCLEVBQ2xCRyxPQURrQixFQUNULEtBQUt4bUIsT0FBTCxDQUFhaG1FLFFBQWIsR0FBd0J3c0YsT0FEZixFQUN3QixDQUR4QixFQUMyQixDQUQzQixFQUM4QixLQUFLeG1CLE9BQUwsQ0FBYWhtRSxRQUQzQyxDQUFuQjtBQUdBLE9BSkQsTUFJTztBQUNOLGFBQUswc0YsR0FBTCxHQUFXRCxLQUFLLEdBQUdELE9BQW5CO0FBQ0E7O0FBQ0QsV0FBSzd1RixHQUFMLEdBQVcsQ0FBRSxLQUFLa0ssR0FBTCxHQUFXLEtBQUtxTyxLQUFsQixJQUE0QnUyRSxLQUE1QixHQUFvQyxLQUFLdjJFLEtBQXBEOztBQUVBLFVBQUssS0FBSzh2RCxPQUFMLENBQWEybUIsSUFBbEIsRUFBeUI7QUFDeEIsYUFBSzNtQixPQUFMLENBQWEybUIsSUFBYixDQUFrQjdrRixJQUFsQixDQUF3QixLQUFLMDlELElBQTdCLEVBQW1DLEtBQUs3bkUsR0FBeEMsRUFBNkMsSUFBN0M7QUFDQTs7QUFFRCxVQUFLdS9FLEtBQUssSUFBSUEsS0FBSyxDQUFDejBFLEdBQXBCLEVBQTBCO0FBQ3pCeTBFLFFBQUFBLEtBQUssQ0FBQ3owRSxHQUFOLENBQVcsSUFBWDtBQUNBLE9BRkQsTUFFTztBQUNOODNDLFFBQUFBLEtBQUssQ0FBQytyQyxTQUFOLENBQWdCNU0sUUFBaEIsQ0FBeUJqM0UsR0FBekIsQ0FBOEIsSUFBOUI7QUFDQTs7QUFDRCxhQUFPLElBQVA7QUFDQTtBQXpDZ0IsR0FBbEI7QUE0Q0E4M0MsRUFBQUEsS0FBSyxDQUFDcm1ELFNBQU4sQ0FBZ0JvNEIsSUFBaEIsQ0FBcUJwNEIsU0FBckIsR0FBaUNxbUQsS0FBSyxDQUFDcm1ELFNBQXZDO0FBRUFxbUQsRUFBQUEsS0FBSyxDQUFDK3JDLFNBQU4sR0FBa0I7QUFDakI1TSxJQUFBQSxRQUFRLEVBQUU7QUFDVHR5RSxNQUFBQSxHQUFHLEVBQUUsYUFBVTJILEtBQVYsRUFBa0I7QUFDdEIsWUFBSTdQLE1BQUosQ0FEc0IsQ0FHdEI7QUFDQTs7QUFDQSxZQUFLNlAsS0FBSyxDQUFDeXdELElBQU4sQ0FBV2xqRSxRQUFYLEtBQXdCLENBQXhCLElBQ0p5UyxLQUFLLENBQUN5d0QsSUFBTixDQUFZendELEtBQUssQ0FBQ3NhLElBQWxCLEtBQTRCLElBQTVCLElBQW9DdGEsS0FBSyxDQUFDeXdELElBQU4sQ0FBV3BvRSxLQUFYLENBQWtCMlgsS0FBSyxDQUFDc2EsSUFBeEIsS0FBa0MsSUFEdkUsRUFDOEU7QUFDN0UsaUJBQU90YSxLQUFLLENBQUN5d0QsSUFBTixDQUFZendELEtBQUssQ0FBQ3NhLElBQWxCLENBQVA7QUFDQSxTQVJxQixDQVV0QjtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0FucUIsUUFBQUEsTUFBTSxHQUFHNi9ELE1BQU0sQ0FBQ2poQyxHQUFQLENBQVkvdUIsS0FBSyxDQUFDeXdELElBQWxCLEVBQXdCendELEtBQUssQ0FBQ3NhLElBQTlCLEVBQW9DLEVBQXBDLENBQVQsQ0Fkc0IsQ0FnQnRCOztBQUNBLGVBQU8sQ0FBQ25xQixNQUFELElBQVdBLE1BQU0sS0FBSyxNQUF0QixHQUErQixDQUEvQixHQUFtQ0EsTUFBMUM7QUFDQSxPQW5CUTtBQW9CVHVELE1BQUFBLEdBQUcsRUFBRSxhQUFVc00sS0FBVixFQUFrQjtBQUV0QjtBQUNBO0FBQ0E7QUFDQSxZQUFLZ3dELE1BQU0sQ0FBQzZuQixFQUFQLENBQVVELElBQVYsQ0FBZ0I1M0UsS0FBSyxDQUFDc2EsSUFBdEIsQ0FBTCxFQUFvQztBQUNuQzAxQyxVQUFBQSxNQUFNLENBQUM2bkIsRUFBUCxDQUFVRCxJQUFWLENBQWdCNTNFLEtBQUssQ0FBQ3NhLElBQXRCLEVBQThCdGEsS0FBOUI7QUFDQSxTQUZELE1BRU8sSUFBS0EsS0FBSyxDQUFDeXdELElBQU4sQ0FBV2xqRSxRQUFYLEtBQXdCLENBQXhCLEtBQ1h5aUUsTUFBTSxDQUFDeW1CLFFBQVAsQ0FBaUJ6MkUsS0FBSyxDQUFDc2EsSUFBdkIsS0FDQ3RhLEtBQUssQ0FBQ3l3RCxJQUFOLENBQVdwb0UsS0FBWCxDQUFrQjRzRixhQUFhLENBQUVqMUUsS0FBSyxDQUFDc2EsSUFBUixDQUEvQixLQUFtRCxJQUZ6QyxDQUFMLEVBRXVEO0FBQzdEMDFDLFVBQUFBLE1BQU0sQ0FBQzNuRSxLQUFQLENBQWMyWCxLQUFLLENBQUN5d0QsSUFBcEIsRUFBMEJ6d0QsS0FBSyxDQUFDc2EsSUFBaEMsRUFBc0N0YSxLQUFLLENBQUNwWCxHQUFOLEdBQVlvWCxLQUFLLENBQUMxRSxJQUF4RDtBQUNBLFNBSk0sTUFJQTtBQUNOMEUsVUFBQUEsS0FBSyxDQUFDeXdELElBQU4sQ0FBWXp3RCxLQUFLLENBQUNzYSxJQUFsQixJQUEyQnRhLEtBQUssQ0FBQ3BYLEdBQWpDO0FBQ0E7QUFDRDtBQWxDUTtBQURPLEdBQWxCLENBMS9OaUYsQ0FpaU9qRjtBQUNBOztBQUNBNGlELEVBQUFBLEtBQUssQ0FBQytyQyxTQUFOLENBQWdCM3FGLFNBQWhCLEdBQTRCNCtDLEtBQUssQ0FBQytyQyxTQUFOLENBQWdCdHFGLFVBQWhCLEdBQTZCO0FBQ3hEeUcsSUFBQUEsR0FBRyxFQUFFLGFBQVVzTSxLQUFWLEVBQWtCO0FBQ3RCLFVBQUtBLEtBQUssQ0FBQ3l3RCxJQUFOLENBQVdsakUsUUFBWCxJQUF1QnlTLEtBQUssQ0FBQ3l3RCxJQUFOLENBQVdwakUsVUFBdkMsRUFBb0Q7QUFDbkQyUyxRQUFBQSxLQUFLLENBQUN5d0QsSUFBTixDQUFZendELEtBQUssQ0FBQ3NhLElBQWxCLElBQTJCdGEsS0FBSyxDQUFDcFgsR0FBakM7QUFDQTtBQUNEO0FBTHVELEdBQXpEO0FBUUFvbkUsRUFBQUEsTUFBTSxDQUFDc25CLE1BQVAsR0FBZ0I7QUFDZlEsSUFBQUEsTUFBTSxFQUFFLGdCQUFVcnVGLENBQVYsRUFBYztBQUNyQixhQUFPQSxDQUFQO0FBQ0EsS0FIYztBQUlmc3VGLElBQUFBLEtBQUssRUFBRSxlQUFVdHVGLENBQVYsRUFBYztBQUNwQixhQUFPLE1BQU1oQyxJQUFJLENBQUM2aEIsR0FBTCxDQUFVN2YsQ0FBQyxHQUFHaEMsSUFBSSxDQUFDYyxFQUFuQixJQUEwQixDQUF2QztBQUNBLEtBTmM7QUFPZm9pRixJQUFBQSxRQUFRLEVBQUU7QUFQSyxHQUFoQjtBQVVBM2EsRUFBQUEsTUFBTSxDQUFDNm5CLEVBQVAsR0FBWXJzQyxLQUFLLENBQUNybUQsU0FBTixDQUFnQm80QixJQUE1QixDQXJqT2lGLENBdWpPakY7O0FBQ0F5eUMsRUFBQUEsTUFBTSxDQUFDNm5CLEVBQVAsQ0FBVUQsSUFBVixHQUFpQixFQUFqQjtBQUtBLE1BQ0NJLEtBREQ7QUFBQSxNQUNRQyxVQURSO0FBQUEsTUFFQ0MsUUFBUSxHQUFHLHdCQUZaO0FBQUEsTUFHQ0MsSUFBSSxHQUFHLGFBSFI7O0FBS0EsV0FBU0MsUUFBVCxHQUFvQjtBQUNuQixRQUFLSCxVQUFMLEVBQWtCO0FBQ2pCLFVBQUs1akYsUUFBUSxDQUFDK29DLE1BQVQsS0FBb0IsS0FBcEIsSUFBNkJ0MkMsTUFBTSxDQUFDOC9CLHFCQUF6QyxFQUFpRTtBQUNoRTkvQixRQUFBQSxNQUFNLENBQUM4L0IscUJBQVAsQ0FBOEJ3eEQsUUFBOUI7QUFDQSxPQUZELE1BRU87QUFDTnR4RixRQUFBQSxNQUFNLENBQUN3OEIsVUFBUCxDQUFtQjgwRCxRQUFuQixFQUE2QnBvQixNQUFNLENBQUM2bkIsRUFBUCxDQUFVbDVDLFFBQXZDO0FBQ0E7O0FBRURxeEIsTUFBQUEsTUFBTSxDQUFDNm5CLEVBQVAsQ0FBVXJuRCxJQUFWO0FBQ0E7QUFDRCxHQTVrT2dGLENBOGtPakY7OztBQUNBLFdBQVM2bkQsV0FBVCxHQUF1QjtBQUN0QnZ4RixJQUFBQSxNQUFNLENBQUN3OEIsVUFBUCxDQUFtQixZQUFXO0FBQzdCMDBELE1BQUFBLEtBQUssR0FBRzNtQixTQUFSO0FBQ0EsS0FGRDtBQUdBLFdBQVMybUIsS0FBSyxHQUFHcnZGLElBQUksQ0FBQ0MsR0FBTCxFQUFqQjtBQUNBLEdBcGxPZ0YsQ0FzbE9qRjs7O0FBQ0EsV0FBUzB2RixLQUFULENBQWdCdndGLElBQWhCLEVBQXNCd3dGLFlBQXRCLEVBQXFDO0FBQ3BDLFFBQUk5MUUsS0FBSjtBQUFBLFFBQ0MzWSxDQUFDLEdBQUcsQ0FETDtBQUFBLFFBRUNvakIsS0FBSyxHQUFHO0FBQUU3ZCxNQUFBQSxNQUFNLEVBQUV0SDtBQUFWLEtBRlQsQ0FEb0MsQ0FLcEM7QUFDQTs7QUFDQXd3RixJQUFBQSxZQUFZLEdBQUdBLFlBQVksR0FBRyxDQUFILEdBQU8sQ0FBbEM7O0FBQ0EsV0FBUXp1RixDQUFDLEdBQUcsQ0FBWixFQUFlQSxDQUFDLElBQUksSUFBSXl1RixZQUF4QixFQUF1QztBQUN0QzkxRSxNQUFBQSxLQUFLLEdBQUdrbUUsU0FBUyxDQUFFNytFLENBQUYsQ0FBakI7QUFDQW9qQixNQUFBQSxLQUFLLENBQUUsV0FBV3pLLEtBQWIsQ0FBTCxHQUE0QnlLLEtBQUssQ0FBRSxZQUFZekssS0FBZCxDQUFMLEdBQTZCMWEsSUFBekQ7QUFDQTs7QUFFRCxRQUFLd3dGLFlBQUwsRUFBb0I7QUFDbkJyckUsTUFBQUEsS0FBSyxDQUFDd3BFLE9BQU4sR0FBZ0J4cEUsS0FBSyxDQUFDamUsS0FBTixHQUFjbEgsSUFBOUI7QUFDQTs7QUFFRCxXQUFPbWxCLEtBQVA7QUFDQTs7QUFFRCxXQUFTc3JFLFdBQVQsQ0FBc0J0eEYsS0FBdEIsRUFBNkJvekIsSUFBN0IsRUFBbUNzUSxTQUFuQyxFQUErQztBQUM5QyxRQUFJNXFCLEtBQUo7QUFBQSxRQUNDaXhFLFVBQVUsR0FBRyxDQUFFMTVCLFNBQVMsQ0FBQ2toQyxRQUFWLENBQW9CbitELElBQXBCLEtBQThCLEVBQWhDLEVBQXFDek8sTUFBckMsQ0FBNkMwckMsU0FBUyxDQUFDa2hDLFFBQVYsQ0FBb0IsR0FBcEIsQ0FBN0MsQ0FEZDtBQUFBLFFBRUM5c0UsS0FBSyxHQUFHLENBRlQ7QUFBQSxRQUdDNWhCLE1BQU0sR0FBR2tuRixVQUFVLENBQUNsbkYsTUFIckI7O0FBSUEsV0FBUTRoQixLQUFLLEdBQUc1aEIsTUFBaEIsRUFBd0I0aEIsS0FBSyxFQUE3QixFQUFrQztBQUNqQyxVQUFPM0wsS0FBSyxHQUFHaXhFLFVBQVUsQ0FBRXRsRSxLQUFGLENBQVYsQ0FBb0I1WSxJQUFwQixDQUEwQjYzQixTQUExQixFQUFxQ3RRLElBQXJDLEVBQTJDcHpCLEtBQTNDLENBQWYsRUFBc0U7QUFFckU7QUFDQSxlQUFPOFksS0FBUDtBQUNBO0FBQ0Q7QUFDRDs7QUFFRCxXQUFTMDRFLGdCQUFULENBQTJCam9CLElBQTNCLEVBQWlDdGpELEtBQWpDLEVBQXdDd3JFLElBQXhDLEVBQStDO0FBQzlDLFFBQUlyK0QsSUFBSjtBQUFBLFFBQVVwekIsS0FBVjtBQUFBLFFBQWlCMGlGLE1BQWpCO0FBQUEsUUFBeUJ6QixLQUF6QjtBQUFBLFFBQWdDeVEsT0FBaEM7QUFBQSxRQUF5Q3Y3RCxTQUF6QztBQUFBLFFBQW9EdzdELGNBQXBEO0FBQUEsUUFBb0VuaUYsT0FBcEU7QUFBQSxRQUNDb2lGLEtBQUssR0FBRyxXQUFXM3JFLEtBQVgsSUFBb0IsWUFBWUEsS0FEekM7QUFBQSxRQUVDNHJFLElBQUksR0FBRyxJQUZSO0FBQUEsUUFHQzdJLElBQUksR0FBRyxFQUhSO0FBQUEsUUFJQzduRixLQUFLLEdBQUdvb0UsSUFBSSxDQUFDcG9FLEtBSmQ7QUFBQSxRQUtDKzBDLE1BQU0sR0FBR3F6QixJQUFJLENBQUNsakUsUUFBTCxJQUFpQnc3RSxrQkFBa0IsQ0FBRXRZLElBQUYsQ0FMN0M7QUFBQSxRQU1DdW9CLFFBQVEsR0FBRzFSLFFBQVEsQ0FBQ2p2RSxHQUFULENBQWNvNEQsSUFBZCxFQUFvQixRQUFwQixDQU5aLENBRDhDLENBUzlDOztBQUNBLFFBQUssQ0FBQ2tvQixJQUFJLENBQUM3VixLQUFYLEVBQW1CO0FBQ2xCcUYsTUFBQUEsS0FBSyxHQUFHblksTUFBTSxDQUFDb1ksV0FBUCxDQUFvQjNYLElBQXBCLEVBQTBCLElBQTFCLENBQVI7O0FBQ0EsVUFBSzBYLEtBQUssQ0FBQzhRLFFBQU4sSUFBa0IsSUFBdkIsRUFBOEI7QUFDN0I5USxRQUFBQSxLQUFLLENBQUM4USxRQUFOLEdBQWlCLENBQWpCO0FBQ0FMLFFBQUFBLE9BQU8sR0FBR3pRLEtBQUssQ0FBQ2pGLEtBQU4sQ0FBWUYsSUFBdEI7O0FBQ0FtRixRQUFBQSxLQUFLLENBQUNqRixLQUFOLENBQVlGLElBQVosR0FBbUIsWUFBVztBQUM3QixjQUFLLENBQUNtRixLQUFLLENBQUM4USxRQUFaLEVBQXVCO0FBQ3RCTCxZQUFBQSxPQUFPO0FBQ1A7QUFDRCxTQUpEO0FBS0E7O0FBQ0R6USxNQUFBQSxLQUFLLENBQUM4USxRQUFOO0FBRUFGLE1BQUFBLElBQUksQ0FBQ2hWLE1BQUwsQ0FBYSxZQUFXO0FBRXZCO0FBQ0FnVixRQUFBQSxJQUFJLENBQUNoVixNQUFMLENBQWEsWUFBVztBQUN2Qm9FLFVBQUFBLEtBQUssQ0FBQzhRLFFBQU47O0FBQ0EsY0FBSyxDQUFDanBCLE1BQU0sQ0FBQzhTLEtBQVAsQ0FBY3JTLElBQWQsRUFBb0IsSUFBcEIsRUFBMkIxbUUsTUFBakMsRUFBMEM7QUFDekNvK0UsWUFBQUEsS0FBSyxDQUFDakYsS0FBTixDQUFZRixJQUFaO0FBQ0E7QUFDRCxTQUxEO0FBTUEsT0FURDtBQVVBLEtBakM2QyxDQW1DOUM7OztBQUNBLFNBQU0xb0QsSUFBTixJQUFjbk4sS0FBZCxFQUFzQjtBQUNyQmptQixNQUFBQSxLQUFLLEdBQUdpbUIsS0FBSyxDQUFFbU4sSUFBRixDQUFiOztBQUNBLFVBQUs0OUQsUUFBUSxDQUFDOWtGLElBQVQsQ0FBZWxNLEtBQWYsQ0FBTCxFQUE4QjtBQUM3QixlQUFPaW1CLEtBQUssQ0FBRW1OLElBQUYsQ0FBWjtBQUNBc3ZELFFBQUFBLE1BQU0sR0FBR0EsTUFBTSxJQUFJMWlGLEtBQUssS0FBSyxRQUE3Qjs7QUFDQSxZQUFLQSxLQUFLLE1BQU9rMkMsTUFBTSxHQUFHLE1BQUgsR0FBWSxNQUF6QixDQUFWLEVBQThDO0FBRTdDO0FBQ0E7QUFDQSxjQUFLbDJDLEtBQUssS0FBSyxNQUFWLElBQW9COHhGLFFBQXBCLElBQWdDQSxRQUFRLENBQUUxK0QsSUFBRixDQUFSLEtBQXFCKzJDLFNBQTFELEVBQXNFO0FBQ3JFajBCLFlBQUFBLE1BQU0sR0FBRyxJQUFULENBRHFFLENBR3RFO0FBQ0MsV0FKRCxNQUlPO0FBQ047QUFDQTtBQUNEOztBQUNEOHlDLFFBQUFBLElBQUksQ0FBRTUxRCxJQUFGLENBQUosR0FBZTArRCxRQUFRLElBQUlBLFFBQVEsQ0FBRTErRCxJQUFGLENBQXBCLElBQWdDMDFDLE1BQU0sQ0FBQzNuRSxLQUFQLENBQWNvb0UsSUFBZCxFQUFvQm4yQyxJQUFwQixDQUEvQztBQUNBO0FBQ0QsS0F2RDZDLENBeUQ5Qzs7O0FBQ0ErQyxJQUFBQSxTQUFTLEdBQUcsQ0FBQzJ5QyxNQUFNLENBQUM0QixhQUFQLENBQXNCemtELEtBQXRCLENBQWI7O0FBQ0EsUUFBSyxDQUFDa1EsU0FBRCxJQUFjMnlDLE1BQU0sQ0FBQzRCLGFBQVAsQ0FBc0JzZSxJQUF0QixDQUFuQixFQUFrRDtBQUNqRDtBQUNBLEtBN0Q2QyxDQStEOUM7OztBQUNBLFFBQUs0SSxLQUFLLElBQUlyb0IsSUFBSSxDQUFDbGpFLFFBQUwsS0FBa0IsQ0FBaEMsRUFBb0M7QUFFbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQW9yRixNQUFBQSxJQUFJLENBQUMvaEYsUUFBTCxHQUFnQixDQUFFdk8sS0FBSyxDQUFDdU8sUUFBUixFQUFrQnZPLEtBQUssQ0FBQzZmLFNBQXhCLEVBQW1DN2YsS0FBSyxDQUFDNGYsU0FBekMsQ0FBaEIsQ0FObUMsQ0FRbkM7O0FBQ0E0d0UsTUFBQUEsY0FBYyxHQUFHRyxRQUFRLElBQUlBLFFBQVEsQ0FBQ3RpRixPQUF0Qzs7QUFDQSxVQUFLbWlGLGNBQWMsSUFBSSxJQUF2QixFQUE4QjtBQUM3QkEsUUFBQUEsY0FBYyxHQUFHdlIsUUFBUSxDQUFDanZFLEdBQVQsQ0FBY280RCxJQUFkLEVBQW9CLFNBQXBCLENBQWpCO0FBQ0E7O0FBQ0QvNUQsTUFBQUEsT0FBTyxHQUFHczVELE1BQU0sQ0FBQ2poQyxHQUFQLENBQVkwaEMsSUFBWixFQUFrQixTQUFsQixDQUFWOztBQUNBLFVBQUsvNUQsT0FBTyxLQUFLLE1BQWpCLEVBQTBCO0FBQ3pCLFlBQUttaUYsY0FBTCxFQUFzQjtBQUNyQm5pRixVQUFBQSxPQUFPLEdBQUdtaUYsY0FBVjtBQUNBLFNBRkQsTUFFTztBQUVOO0FBQ0FwUCxVQUFBQSxRQUFRLENBQUUsQ0FBRWhaLElBQUYsQ0FBRixFQUFZLElBQVosQ0FBUjtBQUNBb29CLFVBQUFBLGNBQWMsR0FBR3BvQixJQUFJLENBQUNwb0UsS0FBTCxDQUFXcU8sT0FBWCxJQUFzQm1pRixjQUF2QztBQUNBbmlGLFVBQUFBLE9BQU8sR0FBR3M1RCxNQUFNLENBQUNqaEMsR0FBUCxDQUFZMGhDLElBQVosRUFBa0IsU0FBbEIsQ0FBVjtBQUNBZ1osVUFBQUEsUUFBUSxDQUFFLENBQUVoWixJQUFGLENBQUYsQ0FBUjtBQUNBO0FBQ0QsT0F6QmtDLENBMkJuQzs7O0FBQ0EsVUFBSy81RCxPQUFPLEtBQUssUUFBWixJQUF3QkEsT0FBTyxLQUFLLGNBQVosSUFBOEJtaUYsY0FBYyxJQUFJLElBQTdFLEVBQW9GO0FBQ25GLFlBQUs3b0IsTUFBTSxDQUFDamhDLEdBQVAsQ0FBWTBoQyxJQUFaLEVBQWtCLE9BQWxCLE1BQWdDLE1BQXJDLEVBQThDO0FBRTdDO0FBQ0EsY0FBSyxDQUFDcHpDLFNBQU4sRUFBa0I7QUFDakIwN0QsWUFBQUEsSUFBSSxDQUFDbmxCLElBQUwsQ0FBVyxZQUFXO0FBQ3JCdnJFLGNBQUFBLEtBQUssQ0FBQ3FPLE9BQU4sR0FBZ0JtaUYsY0FBaEI7QUFDQSxhQUZEOztBQUdBLGdCQUFLQSxjQUFjLElBQUksSUFBdkIsRUFBOEI7QUFDN0JuaUYsY0FBQUEsT0FBTyxHQUFHck8sS0FBSyxDQUFDcU8sT0FBaEI7QUFDQW1pRixjQUFBQSxjQUFjLEdBQUduaUYsT0FBTyxLQUFLLE1BQVosR0FBcUIsRUFBckIsR0FBMEJBLE9BQTNDO0FBQ0E7QUFDRDs7QUFDRHJPLFVBQUFBLEtBQUssQ0FBQ3FPLE9BQU4sR0FBZ0IsY0FBaEI7QUFDQTtBQUNEO0FBQ0Q7O0FBRUQsUUFBS2lpRixJQUFJLENBQUMvaEYsUUFBVixFQUFxQjtBQUNwQnZPLE1BQUFBLEtBQUssQ0FBQ3VPLFFBQU4sR0FBaUIsUUFBakI7QUFDQW1pRixNQUFBQSxJQUFJLENBQUNoVixNQUFMLENBQWEsWUFBVztBQUN2QjE3RSxRQUFBQSxLQUFLLENBQUN1TyxRQUFOLEdBQWlCK2hGLElBQUksQ0FBQy9oRixRQUFMLENBQWUsQ0FBZixDQUFqQjtBQUNBdk8sUUFBQUEsS0FBSyxDQUFDNmYsU0FBTixHQUFrQnl3RSxJQUFJLENBQUMvaEYsUUFBTCxDQUFlLENBQWYsQ0FBbEI7QUFDQXZPLFFBQUFBLEtBQUssQ0FBQzRmLFNBQU4sR0FBa0Iwd0UsSUFBSSxDQUFDL2hGLFFBQUwsQ0FBZSxDQUFmLENBQWxCO0FBQ0EsT0FKRDtBQUtBLEtBckg2QyxDQXVIOUM7OztBQUNBeW1CLElBQUFBLFNBQVMsR0FBRyxLQUFaOztBQUNBLFNBQU0vQyxJQUFOLElBQWM0MUQsSUFBZCxFQUFxQjtBQUVwQjtBQUNBLFVBQUssQ0FBQzd5RCxTQUFOLEVBQWtCO0FBQ2pCLFlBQUsyN0QsUUFBTCxFQUFnQjtBQUNmLGNBQUssWUFBWUEsUUFBakIsRUFBNEI7QUFDM0I1N0MsWUFBQUEsTUFBTSxHQUFHNDdDLFFBQVEsQ0FBQzU3QyxNQUFsQjtBQUNBO0FBQ0QsU0FKRCxNQUlPO0FBQ040N0MsVUFBQUEsUUFBUSxHQUFHMVIsUUFBUSxDQUFDaEIsTUFBVCxDQUFpQjdWLElBQWpCLEVBQXVCLFFBQXZCLEVBQWlDO0FBQUUvNUQsWUFBQUEsT0FBTyxFQUFFbWlGO0FBQVgsV0FBakMsQ0FBWDtBQUNBLFNBUGdCLENBU2pCOzs7QUFDQSxZQUFLalAsTUFBTCxFQUFjO0FBQ2JvUCxVQUFBQSxRQUFRLENBQUM1N0MsTUFBVCxHQUFrQixDQUFDQSxNQUFuQjtBQUNBLFNBWmdCLENBY2pCOzs7QUFDQSxZQUFLQSxNQUFMLEVBQWM7QUFDYnFzQyxVQUFBQSxRQUFRLENBQUUsQ0FBRWhaLElBQUYsQ0FBRixFQUFZLElBQVosQ0FBUjtBQUNBO0FBRUQ7OztBQUVBc29CLFFBQUFBLElBQUksQ0FBQ25sQixJQUFMLENBQVcsWUFBVztBQUVyQjtBQUVBO0FBQ0EsY0FBSyxDQUFDeDJCLE1BQU4sRUFBZTtBQUNkcXNDLFlBQUFBLFFBQVEsQ0FBRSxDQUFFaFosSUFBRixDQUFGLENBQVI7QUFDQTs7QUFDRDZXLFVBQUFBLFFBQVEsQ0FBQzM4RSxNQUFULENBQWlCOGxFLElBQWpCLEVBQXVCLFFBQXZCOztBQUNBLGVBQU1uMkMsSUFBTixJQUFjNDFELElBQWQsRUFBcUI7QUFDcEJsZ0IsWUFBQUEsTUFBTSxDQUFDM25FLEtBQVAsQ0FBY29vRSxJQUFkLEVBQW9CbjJDLElBQXBCLEVBQTBCNDFELElBQUksQ0FBRTUxRCxJQUFGLENBQTlCO0FBQ0E7QUFDRCxTQVpEO0FBYUEsT0FyQ21CLENBdUNwQjs7O0FBQ0ErQyxNQUFBQSxTQUFTLEdBQUdtN0QsV0FBVyxDQUFFcDdDLE1BQU0sR0FBRzQ3QyxRQUFRLENBQUUxK0QsSUFBRixDQUFYLEdBQXNCLENBQTlCLEVBQWlDQSxJQUFqQyxFQUF1Q3krRCxJQUF2QyxDQUF2Qjs7QUFDQSxVQUFLLEVBQUd6K0QsSUFBSSxJQUFJMCtELFFBQVgsQ0FBTCxFQUE2QjtBQUM1QkEsUUFBQUEsUUFBUSxDQUFFMStELElBQUYsQ0FBUixHQUFtQitDLFNBQVMsQ0FBQ2xjLEtBQTdCOztBQUNBLFlBQUtpOEIsTUFBTCxFQUFjO0FBQ2IvZixVQUFBQSxTQUFTLENBQUN2cUIsR0FBVixHQUFnQnVxQixTQUFTLENBQUNsYyxLQUExQjtBQUNBa2MsVUFBQUEsU0FBUyxDQUFDbGMsS0FBVixHQUFrQixDQUFsQjtBQUNBO0FBQ0Q7QUFDRDtBQUNEOztBQUVELFdBQVMrM0UsVUFBVCxDQUFxQi9yRSxLQUFyQixFQUE0QmdzRSxhQUE1QixFQUE0QztBQUMzQyxRQUFJeHRFLEtBQUosRUFBV2UsSUFBWCxFQUFpQjRxRSxNQUFqQixFQUF5QnB3RixLQUF6QixFQUFnQ2loRixLQUFoQyxDQUQyQyxDQUczQzs7QUFDQSxTQUFNeDhELEtBQU4sSUFBZXdCLEtBQWYsRUFBdUI7QUFDdEJULE1BQUFBLElBQUksR0FBR3E2RCxTQUFTLENBQUVwN0QsS0FBRixDQUFoQjtBQUNBMnJFLE1BQUFBLE1BQU0sR0FBRzZCLGFBQWEsQ0FBRXpzRSxJQUFGLENBQXRCO0FBQ0F4bEIsTUFBQUEsS0FBSyxHQUFHaW1CLEtBQUssQ0FBRXhCLEtBQUYsQ0FBYjs7QUFDQSxVQUFLL2pCLEtBQUssQ0FBQ0MsT0FBTixDQUFlWCxLQUFmLENBQUwsRUFBOEI7QUFDN0Jvd0YsUUFBQUEsTUFBTSxHQUFHcHdGLEtBQUssQ0FBRSxDQUFGLENBQWQ7QUFDQUEsUUFBQUEsS0FBSyxHQUFHaW1CLEtBQUssQ0FBRXhCLEtBQUYsQ0FBTCxHQUFpQnprQixLQUFLLENBQUUsQ0FBRixDQUE5QjtBQUNBOztBQUVELFVBQUt5a0IsS0FBSyxLQUFLZSxJQUFmLEVBQXNCO0FBQ3JCUyxRQUFBQSxLQUFLLENBQUVULElBQUYsQ0FBTCxHQUFnQnhsQixLQUFoQjtBQUNBLGVBQU9pbUIsS0FBSyxDQUFFeEIsS0FBRixDQUFaO0FBQ0E7O0FBRUR3OEQsTUFBQUEsS0FBSyxHQUFHblksTUFBTSxDQUFDeW1CLFFBQVAsQ0FBaUIvcEUsSUFBakIsQ0FBUjs7QUFDQSxVQUFLeTdELEtBQUssSUFBSSxZQUFZQSxLQUExQixFQUFrQztBQUNqQ2poRixRQUFBQSxLQUFLLEdBQUdpaEYsS0FBSyxDQUFDZ1AsTUFBTixDQUFjandGLEtBQWQsQ0FBUjtBQUNBLGVBQU9pbUIsS0FBSyxDQUFFVCxJQUFGLENBQVosQ0FGaUMsQ0FJakM7QUFDQTs7QUFDQSxhQUFNZixLQUFOLElBQWV6a0IsS0FBZixFQUF1QjtBQUN0QixjQUFLLEVBQUd5a0IsS0FBSyxJQUFJd0IsS0FBWixDQUFMLEVBQTJCO0FBQzFCQSxZQUFBQSxLQUFLLENBQUV4QixLQUFGLENBQUwsR0FBaUJ6a0IsS0FBSyxDQUFFeWtCLEtBQUYsQ0FBdEI7QUFDQXd0RSxZQUFBQSxhQUFhLENBQUV4dEUsS0FBRixDQUFiLEdBQXlCMnJFLE1BQXpCO0FBQ0E7QUFDRDtBQUNELE9BWkQsTUFZTztBQUNONkIsUUFBQUEsYUFBYSxDQUFFenNFLElBQUYsQ0FBYixHQUF3QjRxRSxNQUF4QjtBQUNBO0FBQ0Q7QUFDRDs7QUFFRCxXQUFTLy9CLFNBQVQsQ0FBb0JrWixJQUFwQixFQUEwQjJvQixVQUExQixFQUFzQ25vQixPQUF0QyxFQUFnRDtBQUMvQyxRQUFJOWdFLE1BQUo7QUFBQSxRQUNDa3BGLE9BREQ7QUFBQSxRQUVDMXRFLEtBQUssR0FBRyxDQUZUO0FBQUEsUUFHQzVoQixNQUFNLEdBQUd3dEQsU0FBUyxDQUFDK2hDLFVBQVYsQ0FBcUJ2dkYsTUFIL0I7QUFBQSxRQUlDaTZFLFFBQVEsR0FBR2hVLE1BQU0sQ0FBQzZULFFBQVAsR0FBa0JFLE1BQWxCLENBQTBCLFlBQVc7QUFFL0M7QUFDQSxhQUFPdnpDLElBQUksQ0FBQ2lnQyxJQUFaO0FBQ0EsS0FKVSxDQUpaO0FBQUEsUUFTQ2pnQyxJQUFJLEdBQUcsU0FBUEEsSUFBTyxHQUFXO0FBQ2pCLFVBQUs2b0QsT0FBTCxFQUFlO0FBQ2QsZUFBTyxLQUFQO0FBQ0E7O0FBQ0QsVUFBSUUsV0FBVyxHQUFHdkIsS0FBSyxJQUFJSyxXQUFXLEVBQXRDO0FBQUEsVUFDQzdTLFNBQVMsR0FBRy85RSxJQUFJLENBQUNvRyxHQUFMLENBQVUsQ0FBVixFQUFhKzhCLFNBQVMsQ0FBQzhzQixTQUFWLEdBQXNCOXNCLFNBQVMsQ0FBQzMvQixRQUFoQyxHQUEyQ3N1RixXQUF4RCxDQURiO0FBQUEsVUFHQztBQUNBO0FBQ0FsMUUsTUFBQUEsSUFBSSxHQUFHbWhFLFNBQVMsR0FBRzU2QyxTQUFTLENBQUMzL0IsUUFBdEIsSUFBa0MsQ0FMMUM7QUFBQSxVQU1Dd3NGLE9BQU8sR0FBRyxJQUFJcHpFLElBTmY7QUFBQSxVQU9Dc0gsS0FBSyxHQUFHLENBUFQ7QUFBQSxVQVFDNWhCLE1BQU0sR0FBRzZnQyxTQUFTLENBQUN5dkIsTUFBVixDQUFpQnR3RCxNQVIzQjs7QUFVQSxhQUFRNGhCLEtBQUssR0FBRzVoQixNQUFoQixFQUF3QjRoQixLQUFLLEVBQTdCLEVBQWtDO0FBQ2pDaWYsUUFBQUEsU0FBUyxDQUFDeXZCLE1BQVYsQ0FBa0IxdUMsS0FBbEIsRUFBMEI2ckUsR0FBMUIsQ0FBK0JDLE9BQS9CO0FBQ0E7O0FBRUR6VCxNQUFBQSxRQUFRLENBQUNjLFVBQVQsQ0FBcUJyVSxJQUFyQixFQUEyQixDQUFFN2xDLFNBQUYsRUFBYTZzRCxPQUFiLEVBQXNCalMsU0FBdEIsQ0FBM0IsRUFsQmlCLENBb0JqQjs7QUFDQSxVQUFLaVMsT0FBTyxHQUFHLENBQVYsSUFBZTF0RixNQUFwQixFQUE2QjtBQUM1QixlQUFPeTdFLFNBQVA7QUFDQSxPQXZCZ0IsQ0F5QmpCOzs7QUFDQSxVQUFLLENBQUN6N0UsTUFBTixFQUFlO0FBQ2RpNkUsUUFBQUEsUUFBUSxDQUFDYyxVQUFULENBQXFCclUsSUFBckIsRUFBMkIsQ0FBRTdsQyxTQUFGLEVBQWEsQ0FBYixFQUFnQixDQUFoQixDQUEzQjtBQUNBLE9BNUJnQixDQThCakI7OztBQUNBbzVDLE1BQUFBLFFBQVEsQ0FBQ2UsV0FBVCxDQUFzQnRVLElBQXRCLEVBQTRCLENBQUU3bEMsU0FBRixDQUE1QjtBQUNBLGFBQU8sS0FBUDtBQUNBLEtBMUNGO0FBQUEsUUEyQ0NBLFNBQVMsR0FBR281QyxRQUFRLENBQUNMLE9BQVQsQ0FBa0I7QUFDN0JsVCxNQUFBQSxJQUFJLEVBQUVBLElBRHVCO0FBRTdCdGpELE1BQUFBLEtBQUssRUFBRTZpRCxNQUFNLENBQUNnQixNQUFQLENBQWUsRUFBZixFQUFtQm9vQixVQUFuQixDQUZzQjtBQUc3QlQsTUFBQUEsSUFBSSxFQUFFM29CLE1BQU0sQ0FBQ2dCLE1BQVAsQ0FBZSxJQUFmLEVBQXFCO0FBQzFCbW9CLFFBQUFBLGFBQWEsRUFBRSxFQURXO0FBRTFCN0IsUUFBQUEsTUFBTSxFQUFFdG5CLE1BQU0sQ0FBQ3NuQixNQUFQLENBQWMzTTtBQUZJLE9BQXJCLEVBR0gxWixPQUhHLENBSHVCO0FBTzdCdW9CLE1BQUFBLGtCQUFrQixFQUFFSixVQVBTO0FBUTdCSyxNQUFBQSxlQUFlLEVBQUV4b0IsT0FSWTtBQVM3QnZaLE1BQUFBLFNBQVMsRUFBRXNnQyxLQUFLLElBQUlLLFdBQVcsRUFURjtBQVU3QnB0RixNQUFBQSxRQUFRLEVBQUVnbUUsT0FBTyxDQUFDaG1FLFFBVlc7QUFXN0JvdkQsTUFBQUEsTUFBTSxFQUFFLEVBWHFCO0FBWTdCbStCLE1BQUFBLFdBQVcsRUFBRSxxQkFBVWwrRCxJQUFWLEVBQWdCeG5CLEdBQWhCLEVBQXNCO0FBQ2xDLFlBQUlrTixLQUFLLEdBQUdnd0QsTUFBTSxDQUFDeGtCLEtBQVAsQ0FBY2lsQixJQUFkLEVBQW9CN2xDLFNBQVMsQ0FBQyt0RCxJQUE5QixFQUFvQ3IrRCxJQUFwQyxFQUEwQ3huQixHQUExQyxFQUNYODNCLFNBQVMsQ0FBQyt0RCxJQUFWLENBQWVRLGFBQWYsQ0FBOEI3K0QsSUFBOUIsS0FBd0NzUSxTQUFTLENBQUMrdEQsSUFBVixDQUFlckIsTUFENUMsQ0FBWjtBQUVBMXNELFFBQUFBLFNBQVMsQ0FBQ3l2QixNQUFWLENBQWlCOXZELElBQWpCLENBQXVCeVYsS0FBdkI7QUFDQSxlQUFPQSxLQUFQO0FBQ0EsT0FqQjRCO0FBa0I3QnFvRSxNQUFBQSxJQUFJLEVBQUUsY0FBVXFSLE9BQVYsRUFBb0I7QUFDekIsWUFBSS90RSxLQUFLLEdBQUcsQ0FBWjtBQUFBLFlBRUM7QUFDQTtBQUNBNWhCLFFBQUFBLE1BQU0sR0FBRzJ2RixPQUFPLEdBQUc5dUQsU0FBUyxDQUFDeXZCLE1BQVYsQ0FBaUJ0d0QsTUFBcEIsR0FBNkIsQ0FKOUM7O0FBS0EsWUFBS3N2RixPQUFMLEVBQWU7QUFDZCxpQkFBTyxJQUFQO0FBQ0E7O0FBQ0RBLFFBQUFBLE9BQU8sR0FBRyxJQUFWOztBQUNBLGVBQVExdEUsS0FBSyxHQUFHNWhCLE1BQWhCLEVBQXdCNGhCLEtBQUssRUFBN0IsRUFBa0M7QUFDakNpZixVQUFBQSxTQUFTLENBQUN5dkIsTUFBVixDQUFrQjF1QyxLQUFsQixFQUEwQjZyRSxHQUExQixDQUErQixDQUEvQjtBQUNBLFNBWndCLENBY3pCOzs7QUFDQSxZQUFLa0MsT0FBTCxFQUFlO0FBQ2QxVixVQUFBQSxRQUFRLENBQUNjLFVBQVQsQ0FBcUJyVSxJQUFyQixFQUEyQixDQUFFN2xDLFNBQUYsRUFBYSxDQUFiLEVBQWdCLENBQWhCLENBQTNCO0FBQ0FvNUMsVUFBQUEsUUFBUSxDQUFDZSxXQUFULENBQXNCdFUsSUFBdEIsRUFBNEIsQ0FBRTdsQyxTQUFGLEVBQWE4dUQsT0FBYixDQUE1QjtBQUNBLFNBSEQsTUFHTztBQUNOMVYsVUFBQUEsUUFBUSxDQUFDbUIsVUFBVCxDQUFxQjFVLElBQXJCLEVBQTJCLENBQUU3bEMsU0FBRixFQUFhOHVELE9BQWIsQ0FBM0I7QUFDQTs7QUFDRCxlQUFPLElBQVA7QUFDQTtBQXhDNEIsS0FBbEIsQ0EzQ2I7QUFBQSxRQXFGQ3ZzRSxLQUFLLEdBQUd5ZCxTQUFTLENBQUN6ZCxLQXJGbkI7O0FBdUZBK3JFLElBQUFBLFVBQVUsQ0FBRS9yRSxLQUFGLEVBQVN5ZCxTQUFTLENBQUMrdEQsSUFBVixDQUFlUSxhQUF4QixDQUFWOztBQUVBLFdBQVF4dEUsS0FBSyxHQUFHNWhCLE1BQWhCLEVBQXdCNGhCLEtBQUssRUFBN0IsRUFBa0M7QUFDakN4YixNQUFBQSxNQUFNLEdBQUdvbkQsU0FBUyxDQUFDK2hDLFVBQVYsQ0FBc0IzdEUsS0FBdEIsRUFBOEI1WSxJQUE5QixDQUFvQzYzQixTQUFwQyxFQUErQzZsQyxJQUEvQyxFQUFxRHRqRCxLQUFyRCxFQUE0RHlkLFNBQVMsQ0FBQyt0RCxJQUF0RSxDQUFUOztBQUNBLFVBQUt4b0YsTUFBTCxFQUFjO0FBQ2IsWUFBS2cvRCxVQUFVLENBQUVoL0QsTUFBTSxDQUFDazRFLElBQVQsQ0FBZixFQUFpQztBQUNoQ3JZLFVBQUFBLE1BQU0sQ0FBQ29ZLFdBQVAsQ0FBb0J4OUMsU0FBUyxDQUFDNmxDLElBQTlCLEVBQW9DN2xDLFNBQVMsQ0FBQyt0RCxJQUFWLENBQWU3VixLQUFuRCxFQUEyRHVGLElBQTNELEdBQ0NsNEUsTUFBTSxDQUFDazRFLElBQVAsQ0FBWWp3QyxJQUFaLENBQWtCam9DLE1BQWxCLENBREQ7QUFFQTs7QUFDRCxlQUFPQSxNQUFQO0FBQ0E7QUFDRDs7QUFFRDYvRCxJQUFBQSxNQUFNLENBQUMzbkQsR0FBUCxDQUFZOEUsS0FBWixFQUFtQnFyRSxXQUFuQixFQUFnQzV0RCxTQUFoQzs7QUFFQSxRQUFLdWtDLFVBQVUsQ0FBRXZrQyxTQUFTLENBQUMrdEQsSUFBVixDQUFleDNFLEtBQWpCLENBQWYsRUFBMEM7QUFDekN5cEIsTUFBQUEsU0FBUyxDQUFDK3RELElBQVYsQ0FBZXgzRSxLQUFmLENBQXFCcE8sSUFBckIsQ0FBMkIwOUQsSUFBM0IsRUFBaUM3bEMsU0FBakM7QUFDQSxLQXpHOEMsQ0EyRy9DOzs7QUFDQUEsSUFBQUEsU0FBUyxDQUNQMWdCLFFBREYsQ0FDWTBnQixTQUFTLENBQUMrdEQsSUFBVixDQUFlenVFLFFBRDNCLEVBRUUwcEQsSUFGRixDQUVRaHBDLFNBQVMsQ0FBQyt0RCxJQUFWLENBQWUva0IsSUFGdkIsRUFFNkJocEMsU0FBUyxDQUFDK3RELElBQVYsQ0FBZWdCLFFBRjVDLEVBR0UvVixJQUhGLENBR1FoNUMsU0FBUyxDQUFDK3RELElBQVYsQ0FBZS9VLElBSHZCLEVBSUVHLE1BSkYsQ0FJVW41QyxTQUFTLENBQUMrdEQsSUFBVixDQUFlNVUsTUFKekI7QUFNQS9ULElBQUFBLE1BQU0sQ0FBQzZuQixFQUFQLENBQVUrQixLQUFWLENBQ0M1cEIsTUFBTSxDQUFDZ0IsTUFBUCxDQUFleGdDLElBQWYsRUFBcUI7QUFDcEJpZ0MsTUFBQUEsSUFBSSxFQUFFQSxJQURjO0FBRXBCc29CLE1BQUFBLElBQUksRUFBRW51RCxTQUZjO0FBR3BCazRDLE1BQUFBLEtBQUssRUFBRWw0QyxTQUFTLENBQUMrdEQsSUFBVixDQUFlN1Y7QUFIRixLQUFyQixDQUREO0FBUUEsV0FBT2w0QyxTQUFQO0FBQ0E7O0FBRURvbEMsRUFBQUEsTUFBTSxDQUFDelksU0FBUCxHQUFtQnlZLE1BQU0sQ0FBQ2dCLE1BQVAsQ0FBZXpaLFNBQWYsRUFBMEI7QUFFNUNraEMsSUFBQUEsUUFBUSxFQUFFO0FBQ1QsV0FBSyxDQUFFLFVBQVVuK0QsSUFBVixFQUFnQnB6QixLQUFoQixFQUF3QjtBQUM5QixZQUFJOFksS0FBSyxHQUFHLEtBQUt3NEUsV0FBTCxDQUFrQmwrRCxJQUFsQixFQUF3QnB6QixLQUF4QixDQUFaO0FBQ0E4aEYsUUFBQUEsU0FBUyxDQUFFaHBFLEtBQUssQ0FBQ3l3RCxJQUFSLEVBQWNuMkMsSUFBZCxFQUFvQm91RCxPQUFPLENBQUNoOUIsSUFBUixDQUFjeGtELEtBQWQsQ0FBcEIsRUFBMkM4WSxLQUEzQyxDQUFUO0FBQ0EsZUFBT0EsS0FBUDtBQUNBLE9BSkk7QUFESSxLQUZrQztBQVU1QzY1RSxJQUFBQSxPQUFPLEVBQUUsaUJBQVUxc0UsS0FBVixFQUFpQmhnQixRQUFqQixFQUE0QjtBQUNwQyxVQUFLZ2lFLFVBQVUsQ0FBRWhpRCxLQUFGLENBQWYsRUFBMkI7QUFDMUJoZ0IsUUFBQUEsUUFBUSxHQUFHZ2dCLEtBQVg7QUFDQUEsUUFBQUEsS0FBSyxHQUFHLENBQUUsR0FBRixDQUFSO0FBQ0EsT0FIRCxNQUdPO0FBQ05BLFFBQUFBLEtBQUssR0FBR0EsS0FBSyxDQUFDMEIsS0FBTixDQUFhd3pELGFBQWIsQ0FBUjtBQUNBOztBQUVELFVBQUkvbkQsSUFBSjtBQUFBLFVBQ0MzTyxLQUFLLEdBQUcsQ0FEVDtBQUFBLFVBRUM1aEIsTUFBTSxHQUFHb2pCLEtBQUssQ0FBQ3BqQixNQUZoQjs7QUFJQSxhQUFRNGhCLEtBQUssR0FBRzVoQixNQUFoQixFQUF3QjRoQixLQUFLLEVBQTdCLEVBQWtDO0FBQ2pDMk8sUUFBQUEsSUFBSSxHQUFHbk4sS0FBSyxDQUFFeEIsS0FBRixDQUFaO0FBQ0E0ckMsUUFBQUEsU0FBUyxDQUFDa2hDLFFBQVYsQ0FBb0JuK0QsSUFBcEIsSUFBNkJpOUIsU0FBUyxDQUFDa2hDLFFBQVYsQ0FBb0JuK0QsSUFBcEIsS0FBOEIsRUFBM0Q7QUFDQWk5QixRQUFBQSxTQUFTLENBQUNraEMsUUFBVixDQUFvQm4rRCxJQUFwQixFQUEyQm5DLE9BQTNCLENBQW9DaHJCLFFBQXBDO0FBQ0E7QUFDRCxLQTNCMkM7QUE2QjVDbXNGLElBQUFBLFVBQVUsRUFBRSxDQUFFWixnQkFBRixDQTdCZ0M7QUErQjVDb0IsSUFBQUEsU0FBUyxFQUFFLG1CQUFVM3NGLFFBQVYsRUFBb0I2a0YsT0FBcEIsRUFBOEI7QUFDeEMsVUFBS0EsT0FBTCxFQUFlO0FBQ2R6NkIsUUFBQUEsU0FBUyxDQUFDK2hDLFVBQVYsQ0FBcUJuaEUsT0FBckIsQ0FBOEJockIsUUFBOUI7QUFDQSxPQUZELE1BRU87QUFDTm9xRCxRQUFBQSxTQUFTLENBQUMraEMsVUFBVixDQUFxQi91RixJQUFyQixDQUEyQjRDLFFBQTNCO0FBQ0E7QUFDRDtBQXJDMkMsR0FBMUIsQ0FBbkI7O0FBd0NBNmlFLEVBQUFBLE1BQU0sQ0FBQytwQixLQUFQLEdBQWUsVUFBVUEsS0FBVixFQUFpQnpDLE1BQWpCLEVBQXlCcm5CLEVBQXpCLEVBQThCO0FBQzVDLFFBQUkrcEIsR0FBRyxHQUFHRCxLQUFLLElBQUksUUFBT0EsS0FBUCxNQUFpQixRQUExQixHQUFxQy9wQixNQUFNLENBQUNnQixNQUFQLENBQWUsRUFBZixFQUFtQitvQixLQUFuQixDQUFyQyxHQUFrRTtBQUMzRUosTUFBQUEsUUFBUSxFQUFFMXBCLEVBQUUsSUFBSSxDQUFDQSxFQUFELElBQU9xbkIsTUFBYixJQUNUbm9CLFVBQVUsQ0FBRTRxQixLQUFGLENBQVYsSUFBdUJBLEtBRm1EO0FBRzNFOXVGLE1BQUFBLFFBQVEsRUFBRTh1RixLQUhpRTtBQUkzRXpDLE1BQUFBLE1BQU0sRUFBRXJuQixFQUFFLElBQUlxbkIsTUFBTixJQUFnQkEsTUFBTSxJQUFJLENBQUNub0IsVUFBVSxDQUFFbW9CLE1BQUYsQ0FBckIsSUFBbUNBO0FBSmdCLEtBQTVFLENBRDRDLENBUTVDOztBQUNBLFFBQUt0bkIsTUFBTSxDQUFDNm5CLEVBQVAsQ0FBVXhMLEdBQWYsRUFBcUI7QUFDcEIyTixNQUFBQSxHQUFHLENBQUMvdUYsUUFBSixHQUFlLENBQWY7QUFFQSxLQUhELE1BR087QUFDTixVQUFLLE9BQU8rdUYsR0FBRyxDQUFDL3VGLFFBQVgsS0FBd0IsUUFBN0IsRUFBd0M7QUFDdkMsWUFBSyt1RixHQUFHLENBQUMvdUYsUUFBSixJQUFnQitrRSxNQUFNLENBQUM2bkIsRUFBUCxDQUFVb0MsTUFBL0IsRUFBd0M7QUFDdkNELFVBQUFBLEdBQUcsQ0FBQy91RixRQUFKLEdBQWUra0UsTUFBTSxDQUFDNm5CLEVBQVAsQ0FBVW9DLE1BQVYsQ0FBa0JELEdBQUcsQ0FBQy91RixRQUF0QixDQUFmO0FBRUEsU0FIRCxNQUdPO0FBQ04rdUYsVUFBQUEsR0FBRyxDQUFDL3VGLFFBQUosR0FBZStrRSxNQUFNLENBQUM2bkIsRUFBUCxDQUFVb0MsTUFBVixDQUFpQnRQLFFBQWhDO0FBQ0E7QUFDRDtBQUNELEtBckIyQyxDQXVCNUM7OztBQUNBLFFBQUtxUCxHQUFHLENBQUNsWCxLQUFKLElBQWEsSUFBYixJQUFxQmtYLEdBQUcsQ0FBQ2xYLEtBQUosS0FBYyxJQUF4QyxFQUErQztBQUM5Q2tYLE1BQUFBLEdBQUcsQ0FBQ2xYLEtBQUosR0FBWSxJQUFaO0FBQ0EsS0ExQjJDLENBNEI1Qzs7O0FBQ0FrWCxJQUFBQSxHQUFHLENBQUMzOUUsR0FBSixHQUFVMjlFLEdBQUcsQ0FBQ0wsUUFBZDs7QUFFQUssSUFBQUEsR0FBRyxDQUFDTCxRQUFKLEdBQWUsWUFBVztBQUN6QixVQUFLeHFCLFVBQVUsQ0FBRTZxQixHQUFHLENBQUMzOUUsR0FBTixDQUFmLEVBQTZCO0FBQzVCMjlFLFFBQUFBLEdBQUcsQ0FBQzM5RSxHQUFKLENBQVF0SixJQUFSLENBQWMsSUFBZDtBQUNBOztBQUVELFVBQUtpbkYsR0FBRyxDQUFDbFgsS0FBVCxFQUFpQjtBQUNoQjlTLFFBQUFBLE1BQU0sQ0FBQ2lZLE9BQVAsQ0FBZ0IsSUFBaEIsRUFBc0IrUixHQUFHLENBQUNsWCxLQUExQjtBQUNBO0FBQ0QsS0FSRDs7QUFVQSxXQUFPa1gsR0FBUDtBQUNBLEdBMUNEOztBQTRDQWhxQixFQUFBQSxNQUFNLENBQUNDLEVBQVAsQ0FBVWUsTUFBVixDQUFrQjtBQUNqQmtwQixJQUFBQSxNQUFNLEVBQUUsZ0JBQVVILEtBQVYsRUFBaUJqdkYsRUFBakIsRUFBcUJ3c0YsTUFBckIsRUFBNkJucUYsUUFBN0IsRUFBd0M7QUFFL0M7QUFDQSxhQUFPLEtBQUsrNkIsTUFBTCxDQUFhNmdELGtCQUFiLEVBQWtDaDZDLEdBQWxDLENBQXVDLFNBQXZDLEVBQWtELENBQWxELEVBQXNEMjZDLElBQXRELEdBRU47QUFGTSxPQUdMNTJFLEdBSEssR0FHQ2lOLE9BSEQsQ0FHVTtBQUFFMjJFLFFBQUFBLE9BQU8sRUFBRTVyRjtBQUFYLE9BSFYsRUFHMkJpdkYsS0FIM0IsRUFHa0N6QyxNQUhsQyxFQUcwQ25xRixRQUgxQyxDQUFQO0FBSUEsS0FSZ0I7QUFTakI0UyxJQUFBQSxPQUFPLEVBQUUsaUJBQVV1YSxJQUFWLEVBQWdCeS9ELEtBQWhCLEVBQXVCekMsTUFBdkIsRUFBK0JucUYsUUFBL0IsRUFBMEM7QUFDbEQsVUFBSSsxRSxLQUFLLEdBQUdsVCxNQUFNLENBQUM0QixhQUFQLENBQXNCdDNDLElBQXRCLENBQVo7QUFBQSxVQUNDNi9ELE1BQU0sR0FBR25xQixNQUFNLENBQUMrcEIsS0FBUCxDQUFjQSxLQUFkLEVBQXFCekMsTUFBckIsRUFBNkJucUYsUUFBN0IsQ0FEVjtBQUFBLFVBRUNpdEYsV0FBVyxHQUFHLFNBQWRBLFdBQWMsR0FBVztBQUV4QjtBQUNBLFlBQUlyQixJQUFJLEdBQUd4aEMsU0FBUyxDQUFFLElBQUYsRUFBUXlZLE1BQU0sQ0FBQ2dCLE1BQVAsQ0FBZSxFQUFmLEVBQW1CMTJDLElBQW5CLENBQVIsRUFBbUM2L0QsTUFBbkMsQ0FBcEIsQ0FId0IsQ0FLeEI7O0FBQ0EsWUFBS2pYLEtBQUssSUFBSW9FLFFBQVEsQ0FBQ2p2RSxHQUFULENBQWMsSUFBZCxFQUFvQixRQUFwQixDQUFkLEVBQStDO0FBQzlDMGdGLFVBQUFBLElBQUksQ0FBQzFRLElBQUwsQ0FBVyxJQUFYO0FBQ0E7QUFDRCxPQVhGOztBQWFBK1IsTUFBQUEsV0FBVyxDQUFDQyxNQUFaLEdBQXFCRCxXQUFyQjtBQUVBLGFBQU9sWCxLQUFLLElBQUlpWCxNQUFNLENBQUNyWCxLQUFQLEtBQWlCLEtBQTFCLEdBQ04sS0FBS3IyQixJQUFMLENBQVcydEMsV0FBWCxDQURNLEdBRU4sS0FBS3RYLEtBQUwsQ0FBWXFYLE1BQU0sQ0FBQ3JYLEtBQW5CLEVBQTBCc1gsV0FBMUIsQ0FGRDtBQUdBLEtBNUJnQjtBQTZCakIvUixJQUFBQSxJQUFJLEVBQUUsY0FBVXRnRixJQUFWLEVBQWdCdWdGLFVBQWhCLEVBQTRCb1IsT0FBNUIsRUFBc0M7QUFDM0MsVUFBSVksU0FBUyxHQUFHLFNBQVpBLFNBQVksQ0FBVW5TLEtBQVYsRUFBa0I7QUFDakMsWUFBSUUsSUFBSSxHQUFHRixLQUFLLENBQUNFLElBQWpCO0FBQ0EsZUFBT0YsS0FBSyxDQUFDRSxJQUFiO0FBQ0FBLFFBQUFBLElBQUksQ0FBRXFSLE9BQUYsQ0FBSjtBQUNBLE9BSkQ7O0FBTUEsVUFBSyxPQUFPM3hGLElBQVAsS0FBZ0IsUUFBckIsRUFBZ0M7QUFDL0IyeEYsUUFBQUEsT0FBTyxHQUFHcFIsVUFBVjtBQUNBQSxRQUFBQSxVQUFVLEdBQUd2Z0YsSUFBYjtBQUNBQSxRQUFBQSxJQUFJLEdBQUdzcEUsU0FBUDtBQUNBOztBQUNELFVBQUtpWCxVQUFMLEVBQWtCO0FBQ2pCLGFBQUt4RixLQUFMLENBQVkvNkUsSUFBSSxJQUFJLElBQXBCLEVBQTBCLEVBQTFCO0FBQ0E7O0FBRUQsYUFBTyxLQUFLMGtELElBQUwsQ0FBVyxZQUFXO0FBQzVCLFlBQUl3N0IsT0FBTyxHQUFHLElBQWQ7QUFBQSxZQUNDdDhELEtBQUssR0FBRzVqQixJQUFJLElBQUksSUFBUixJQUFnQkEsSUFBSSxHQUFHLFlBRGhDO0FBQUEsWUFFQ3d5RixNQUFNLEdBQUd2cUIsTUFBTSxDQUFDdXFCLE1BRmpCO0FBQUEsWUFHQ3B2RixJQUFJLEdBQUdtOEUsUUFBUSxDQUFDanZFLEdBQVQsQ0FBYyxJQUFkLENBSFI7O0FBS0EsWUFBS3NULEtBQUwsRUFBYTtBQUNaLGNBQUt4Z0IsSUFBSSxDQUFFd2dCLEtBQUYsQ0FBSixJQUFpQnhnQixJQUFJLENBQUV3Z0IsS0FBRixDQUFKLENBQWMwOEQsSUFBcEMsRUFBMkM7QUFDMUNpUyxZQUFBQSxTQUFTLENBQUVudkYsSUFBSSxDQUFFd2dCLEtBQUYsQ0FBTixDQUFUO0FBQ0E7QUFDRCxTQUpELE1BSU87QUFDTixlQUFNQSxLQUFOLElBQWV4Z0IsSUFBZixFQUFzQjtBQUNyQixnQkFBS0EsSUFBSSxDQUFFd2dCLEtBQUYsQ0FBSixJQUFpQnhnQixJQUFJLENBQUV3Z0IsS0FBRixDQUFKLENBQWMwOEQsSUFBL0IsSUFBdUM4UCxJQUFJLENBQUMva0YsSUFBTCxDQUFXdVksS0FBWCxDQUE1QyxFQUFpRTtBQUNoRTJ1RSxjQUFBQSxTQUFTLENBQUVudkYsSUFBSSxDQUFFd2dCLEtBQUYsQ0FBTixDQUFUO0FBQ0E7QUFDRDtBQUNEOztBQUVELGFBQU1BLEtBQUssR0FBRzR1RSxNQUFNLENBQUN4d0YsTUFBckIsRUFBNkI0aEIsS0FBSyxFQUFsQyxHQUF3QztBQUN2QyxjQUFLNHVFLE1BQU0sQ0FBRTV1RSxLQUFGLENBQU4sQ0FBZ0I4a0QsSUFBaEIsS0FBeUIsSUFBekIsS0FDRjFvRSxJQUFJLElBQUksSUFBUixJQUFnQnd5RixNQUFNLENBQUU1dUUsS0FBRixDQUFOLENBQWdCbTNELEtBQWhCLEtBQTBCLzZFLElBRHhDLENBQUwsRUFDc0Q7QUFFckR3eUYsWUFBQUEsTUFBTSxDQUFFNXVFLEtBQUYsQ0FBTixDQUFnQm90RSxJQUFoQixDQUFxQjFRLElBQXJCLENBQTJCcVIsT0FBM0I7QUFDQXpSLFlBQUFBLE9BQU8sR0FBRyxLQUFWO0FBQ0FzUyxZQUFBQSxNQUFNLENBQUMxdkYsTUFBUCxDQUFlOGdCLEtBQWYsRUFBc0IsQ0FBdEI7QUFDQTtBQUNELFNBMUIyQixDQTRCNUI7QUFDQTtBQUNBOzs7QUFDQSxZQUFLczhELE9BQU8sSUFBSSxDQUFDeVIsT0FBakIsRUFBMkI7QUFDMUIxcEIsVUFBQUEsTUFBTSxDQUFDaVksT0FBUCxDQUFnQixJQUFoQixFQUFzQmxnRixJQUF0QjtBQUNBO0FBQ0QsT0FsQ00sQ0FBUDtBQW1DQSxLQWhGZ0I7QUFpRmpCc3lGLElBQUFBLE1BQU0sRUFBRSxnQkFBVXR5RixJQUFWLEVBQWlCO0FBQ3hCLFVBQUtBLElBQUksS0FBSyxLQUFkLEVBQXNCO0FBQ3JCQSxRQUFBQSxJQUFJLEdBQUdBLElBQUksSUFBSSxJQUFmO0FBQ0E7O0FBQ0QsYUFBTyxLQUFLMGtELElBQUwsQ0FBVyxZQUFXO0FBQzVCLFlBQUk5Z0MsS0FBSjtBQUFBLFlBQ0N4Z0IsSUFBSSxHQUFHbThFLFFBQVEsQ0FBQ2p2RSxHQUFULENBQWMsSUFBZCxDQURSO0FBQUEsWUFFQ3lxRSxLQUFLLEdBQUczM0UsSUFBSSxDQUFFcEQsSUFBSSxHQUFHLE9BQVQsQ0FGYjtBQUFBLFlBR0NvZ0YsS0FBSyxHQUFHaDlFLElBQUksQ0FBRXBELElBQUksR0FBRyxZQUFULENBSGI7QUFBQSxZQUlDd3lGLE1BQU0sR0FBR3ZxQixNQUFNLENBQUN1cUIsTUFKakI7QUFBQSxZQUtDeHdGLE1BQU0sR0FBRys0RSxLQUFLLEdBQUdBLEtBQUssQ0FBQy80RSxNQUFULEdBQWtCLENBTGpDLENBRDRCLENBUTVCOztBQUNBb0IsUUFBQUEsSUFBSSxDQUFDa3ZGLE1BQUwsR0FBYyxJQUFkLENBVDRCLENBVzVCOztBQUNBcnFCLFFBQUFBLE1BQU0sQ0FBQzhTLEtBQVAsQ0FBYyxJQUFkLEVBQW9CLzZFLElBQXBCLEVBQTBCLEVBQTFCOztBQUVBLFlBQUtvZ0YsS0FBSyxJQUFJQSxLQUFLLENBQUNFLElBQXBCLEVBQTJCO0FBQzFCRixVQUFBQSxLQUFLLENBQUNFLElBQU4sQ0FBV3QxRSxJQUFYLENBQWlCLElBQWpCLEVBQXVCLElBQXZCO0FBQ0EsU0FoQjJCLENBa0I1Qjs7O0FBQ0EsYUFBTTRZLEtBQUssR0FBRzR1RSxNQUFNLENBQUN4d0YsTUFBckIsRUFBNkI0aEIsS0FBSyxFQUFsQyxHQUF3QztBQUN2QyxjQUFLNHVFLE1BQU0sQ0FBRTV1RSxLQUFGLENBQU4sQ0FBZ0I4a0QsSUFBaEIsS0FBeUIsSUFBekIsSUFBaUM4cEIsTUFBTSxDQUFFNXVFLEtBQUYsQ0FBTixDQUFnQm0zRCxLQUFoQixLQUEwQi82RSxJQUFoRSxFQUF1RTtBQUN0RXd5RixZQUFBQSxNQUFNLENBQUU1dUUsS0FBRixDQUFOLENBQWdCb3RFLElBQWhCLENBQXFCMVEsSUFBckIsQ0FBMkIsSUFBM0I7QUFDQWtTLFlBQUFBLE1BQU0sQ0FBQzF2RixNQUFQLENBQWU4Z0IsS0FBZixFQUFzQixDQUF0QjtBQUNBO0FBQ0QsU0F4QjJCLENBMEI1Qjs7O0FBQ0EsYUFBTUEsS0FBSyxHQUFHLENBQWQsRUFBaUJBLEtBQUssR0FBRzVoQixNQUF6QixFQUFpQzRoQixLQUFLLEVBQXRDLEVBQTJDO0FBQzFDLGNBQUttM0QsS0FBSyxDQUFFbjNELEtBQUYsQ0FBTCxJQUFrQm0zRCxLQUFLLENBQUVuM0QsS0FBRixDQUFMLENBQWUwdUUsTUFBdEMsRUFBK0M7QUFDOUN2WCxZQUFBQSxLQUFLLENBQUVuM0QsS0FBRixDQUFMLENBQWUwdUUsTUFBZixDQUFzQnRuRixJQUF0QixDQUE0QixJQUE1QjtBQUNBO0FBQ0QsU0EvQjJCLENBaUM1Qjs7O0FBQ0EsZUFBTzVILElBQUksQ0FBQ2t2RixNQUFaO0FBQ0EsT0FuQ00sQ0FBUDtBQW9DQTtBQXpIZ0IsR0FBbEI7QUE0SEFycUIsRUFBQUEsTUFBTSxDQUFDdmpCLElBQVAsQ0FBYSxDQUFFLFFBQUYsRUFBWSxNQUFaLEVBQW9CLE1BQXBCLENBQWIsRUFBMkMsVUFBVTlqQixFQUFWLEVBQWNqYyxJQUFkLEVBQXFCO0FBQy9ELFFBQUk4dEUsS0FBSyxHQUFHeHFCLE1BQU0sQ0FBQ0MsRUFBUCxDQUFXdmpELElBQVgsQ0FBWjs7QUFDQXNqRCxJQUFBQSxNQUFNLENBQUNDLEVBQVAsQ0FBV3ZqRCxJQUFYLElBQW9CLFVBQVVxdEUsS0FBVixFQUFpQnpDLE1BQWpCLEVBQXlCbnFGLFFBQXpCLEVBQW9DO0FBQ3ZELGFBQU80c0YsS0FBSyxJQUFJLElBQVQsSUFBaUIsT0FBT0EsS0FBUCxLQUFpQixTQUFsQyxHQUNOUyxLQUFLLENBQUNwcUYsS0FBTixDQUFhLElBQWIsRUFBbUJxRixTQUFuQixDQURNLEdBRU4sS0FBS3NLLE9BQUwsQ0FBY3U0RSxLQUFLLENBQUU1ckUsSUFBRixFQUFRLElBQVIsQ0FBbkIsRUFBbUNxdEUsS0FBbkMsRUFBMEN6QyxNQUExQyxFQUFrRG5xRixRQUFsRCxDQUZEO0FBR0EsS0FKRDtBQUtBLEdBUEQsRUF2cFBpRixDQWdxUGpGOztBQUNBNmlFLEVBQUFBLE1BQU0sQ0FBQ3ZqQixJQUFQLENBQWE7QUFDWmd1QyxJQUFBQSxTQUFTLEVBQUVuQyxLQUFLLENBQUUsTUFBRixDQURKO0FBRVpvQyxJQUFBQSxPQUFPLEVBQUVwQyxLQUFLLENBQUUsTUFBRixDQUZGO0FBR1pxQyxJQUFBQSxXQUFXLEVBQUVyQyxLQUFLLENBQUUsUUFBRixDQUhOO0FBSVpzQyxJQUFBQSxNQUFNLEVBQUU7QUFBRWxFLE1BQUFBLE9BQU8sRUFBRTtBQUFYLEtBSkk7QUFLWm1FLElBQUFBLE9BQU8sRUFBRTtBQUFFbkUsTUFBQUEsT0FBTyxFQUFFO0FBQVgsS0FMRztBQU1ab0UsSUFBQUEsVUFBVSxFQUFFO0FBQUVwRSxNQUFBQSxPQUFPLEVBQUU7QUFBWDtBQU5BLEdBQWIsRUFPRyxVQUFVaHFFLElBQVYsRUFBZ0JTLEtBQWhCLEVBQXdCO0FBQzFCNmlELElBQUFBLE1BQU0sQ0FBQ0MsRUFBUCxDQUFXdmpELElBQVgsSUFBb0IsVUFBVXF0RSxLQUFWLEVBQWlCekMsTUFBakIsRUFBeUJucUYsUUFBekIsRUFBb0M7QUFDdkQsYUFBTyxLQUFLNFMsT0FBTCxDQUFjb04sS0FBZCxFQUFxQjRzRSxLQUFyQixFQUE0QnpDLE1BQTVCLEVBQW9DbnFGLFFBQXBDLENBQVA7QUFDQSxLQUZEO0FBR0EsR0FYRDtBQWFBNmlFLEVBQUFBLE1BQU0sQ0FBQ3VxQixNQUFQLEdBQWdCLEVBQWhCOztBQUNBdnFCLEVBQUFBLE1BQU0sQ0FBQzZuQixFQUFQLENBQVVybkQsSUFBVixHQUFpQixZQUFXO0FBQzNCLFFBQUlvcEQsS0FBSjtBQUFBLFFBQ0M5dkYsQ0FBQyxHQUFHLENBREw7QUFBQSxRQUVDeXdGLE1BQU0sR0FBR3ZxQixNQUFNLENBQUN1cUIsTUFGakI7QUFJQXZDLElBQUFBLEtBQUssR0FBR3J2RixJQUFJLENBQUNDLEdBQUwsRUFBUjs7QUFFQSxXQUFRa0IsQ0FBQyxHQUFHeXdGLE1BQU0sQ0FBQ3h3RixNQUFuQixFQUEyQkQsQ0FBQyxFQUE1QixFQUFpQztBQUNoQzh2RixNQUFBQSxLQUFLLEdBQUdXLE1BQU0sQ0FBRXp3RixDQUFGLENBQWQsQ0FEZ0MsQ0FHaEM7O0FBQ0EsVUFBSyxDQUFDOHZGLEtBQUssRUFBTixJQUFZVyxNQUFNLENBQUV6d0YsQ0FBRixDQUFOLEtBQWdCOHZGLEtBQWpDLEVBQXlDO0FBQ3hDVyxRQUFBQSxNQUFNLENBQUMxdkYsTUFBUCxDQUFlZixDQUFDLEVBQWhCLEVBQW9CLENBQXBCO0FBQ0E7QUFDRDs7QUFFRCxRQUFLLENBQUN5d0YsTUFBTSxDQUFDeHdGLE1BQWIsRUFBc0I7QUFDckJpbUUsTUFBQUEsTUFBTSxDQUFDNm5CLEVBQVAsQ0FBVXhQLElBQVY7QUFDQTs7QUFDRDJQLElBQUFBLEtBQUssR0FBRzNtQixTQUFSO0FBQ0EsR0FwQkQ7O0FBc0JBckIsRUFBQUEsTUFBTSxDQUFDNm5CLEVBQVAsQ0FBVStCLEtBQVYsR0FBa0IsVUFBVUEsS0FBVixFQUFrQjtBQUNuQzVwQixJQUFBQSxNQUFNLENBQUN1cUIsTUFBUCxDQUFjaHdGLElBQWQsQ0FBb0JxdkYsS0FBcEI7QUFDQTVwQixJQUFBQSxNQUFNLENBQUM2bkIsRUFBUCxDQUFVMTJFLEtBQVY7QUFDQSxHQUhEOztBQUtBNnVELEVBQUFBLE1BQU0sQ0FBQzZuQixFQUFQLENBQVVsNUMsUUFBVixHQUFxQixFQUFyQjs7QUFDQXF4QixFQUFBQSxNQUFNLENBQUM2bkIsRUFBUCxDQUFVMTJFLEtBQVYsR0FBa0IsWUFBVztBQUM1QixRQUFLODJFLFVBQUwsRUFBa0I7QUFDakI7QUFDQTs7QUFFREEsSUFBQUEsVUFBVSxHQUFHLElBQWI7QUFDQUcsSUFBQUEsUUFBUTtBQUNSLEdBUEQ7O0FBU0Fwb0IsRUFBQUEsTUFBTSxDQUFDNm5CLEVBQVAsQ0FBVXhQLElBQVYsR0FBaUIsWUFBVztBQUMzQjRQLElBQUFBLFVBQVUsR0FBRyxJQUFiO0FBQ0EsR0FGRDs7QUFJQWpvQixFQUFBQSxNQUFNLENBQUM2bkIsRUFBUCxDQUFVb0MsTUFBVixHQUFtQjtBQUNsQmMsSUFBQUEsSUFBSSxFQUFFLEdBRFk7QUFFbEJDLElBQUFBLElBQUksRUFBRSxHQUZZO0FBSWxCO0FBQ0FyUSxJQUFBQSxRQUFRLEVBQUU7QUFMUSxHQUFuQixDQXh0UGlGLENBaXVQakY7QUFDQTs7QUFDQTNhLEVBQUFBLE1BQU0sQ0FBQ0MsRUFBUCxDQUFVamxFLEtBQVYsR0FBa0IsVUFBVTBhLElBQVYsRUFBZ0IzZCxJQUFoQixFQUF1QjtBQUN4QzJkLElBQUFBLElBQUksR0FBR3NxRCxNQUFNLENBQUM2bkIsRUFBUCxHQUFZN25CLE1BQU0sQ0FBQzZuQixFQUFQLENBQVVvQyxNQUFWLENBQWtCdjBFLElBQWxCLEtBQTRCQSxJQUF4QyxHQUErQ0EsSUFBdEQ7QUFDQTNkLElBQUFBLElBQUksR0FBR0EsSUFBSSxJQUFJLElBQWY7QUFFQSxXQUFPLEtBQUsrNkUsS0FBTCxDQUFZLzZFLElBQVosRUFBa0IsVUFBVW95QyxJQUFWLEVBQWdCZ3VDLEtBQWhCLEVBQXdCO0FBQ2hELFVBQUk4UyxPQUFPLEdBQUduMEYsTUFBTSxDQUFDdzhCLFVBQVAsQ0FBbUI2VyxJQUFuQixFQUF5QnowQixJQUF6QixDQUFkOztBQUNBeWlFLE1BQUFBLEtBQUssQ0FBQ0UsSUFBTixHQUFhLFlBQVc7QUFDdkJ2aEYsUUFBQUEsTUFBTSxDQUFDNnRELFlBQVAsQ0FBcUJzbUMsT0FBckI7QUFDQSxPQUZEO0FBR0EsS0FMTSxDQUFQO0FBTUEsR0FWRDs7QUFhQSxHQUFFLFlBQVc7QUFDWixRQUFJOWhCLEtBQUssR0FBRzlrRSxRQUFRLENBQUNqTSxhQUFULENBQXdCLE9BQXhCLENBQVo7QUFBQSxRQUNDNHFFLE1BQU0sR0FBRzMrRCxRQUFRLENBQUNqTSxhQUFULENBQXdCLFFBQXhCLENBRFY7QUFBQSxRQUVDNHhGLEdBQUcsR0FBR2huQixNQUFNLENBQUM1OEQsV0FBUCxDQUFvQi9CLFFBQVEsQ0FBQ2pNLGFBQVQsQ0FBd0IsUUFBeEIsQ0FBcEIsQ0FGUDtBQUlBK3dFLElBQUFBLEtBQUssQ0FBQ3B4RSxJQUFOLEdBQWEsVUFBYixDQUxZLENBT1o7QUFDQTs7QUFDQW1uRSxJQUFBQSxPQUFPLENBQUNnc0IsT0FBUixHQUFrQi9oQixLQUFLLENBQUNqeUUsS0FBTixLQUFnQixFQUFsQyxDQVRZLENBV1o7QUFDQTs7QUFDQWdvRSxJQUFBQSxPQUFPLENBQUNpc0IsV0FBUixHQUFzQm5CLEdBQUcsQ0FBQ2xkLFFBQTFCLENBYlksQ0FlWjtBQUNBOztBQUNBM0QsSUFBQUEsS0FBSyxHQUFHOWtFLFFBQVEsQ0FBQ2pNLGFBQVQsQ0FBd0IsT0FBeEIsQ0FBUjtBQUNBK3dFLElBQUFBLEtBQUssQ0FBQ2p5RSxLQUFOLEdBQWMsR0FBZDtBQUNBaXlFLElBQUFBLEtBQUssQ0FBQ3B4RSxJQUFOLEdBQWEsT0FBYjtBQUNBbW5FLElBQUFBLE9BQU8sQ0FBQ2tzQixVQUFSLEdBQXFCamlCLEtBQUssQ0FBQ2p5RSxLQUFOLEtBQWdCLEdBQXJDO0FBQ0EsR0FyQkQ7O0FBd0JBLE1BQUltMEYsUUFBSjtBQUFBLE1BQ0MzakIsVUFBVSxHQUFHMUgsTUFBTSxDQUFDa0ssSUFBUCxDQUFZeEMsVUFEMUI7QUFHQTFILEVBQUFBLE1BQU0sQ0FBQ0MsRUFBUCxDQUFVZSxNQUFWLENBQWtCO0FBQ2pCeGtELElBQUFBLElBQUksRUFBRSxjQUFVRSxJQUFWLEVBQWdCeGxCLEtBQWhCLEVBQXdCO0FBQzdCLGFBQU9vL0UsTUFBTSxDQUFFLElBQUYsRUFBUXRXLE1BQU0sQ0FBQ3hqRCxJQUFmLEVBQXFCRSxJQUFyQixFQUEyQnhsQixLQUEzQixFQUFrQ3VPLFNBQVMsQ0FBQzFMLE1BQVYsR0FBbUIsQ0FBckQsQ0FBYjtBQUNBLEtBSGdCO0FBS2pCdXhGLElBQUFBLFVBQVUsRUFBRSxvQkFBVTV1RSxJQUFWLEVBQWlCO0FBQzVCLGFBQU8sS0FBSysvQixJQUFMLENBQVcsWUFBVztBQUM1QnVqQixRQUFBQSxNQUFNLENBQUNzckIsVUFBUCxDQUFtQixJQUFuQixFQUF5QjV1RSxJQUF6QjtBQUNBLE9BRk0sQ0FBUDtBQUdBO0FBVGdCLEdBQWxCO0FBWUFzakQsRUFBQUEsTUFBTSxDQUFDZ0IsTUFBUCxDQUFlO0FBQ2R4a0QsSUFBQUEsSUFBSSxFQUFFLGNBQVVpa0QsSUFBVixFQUFnQi9qRCxJQUFoQixFQUFzQnhsQixLQUF0QixFQUE4QjtBQUNuQyxVQUFJb3BFLEdBQUo7QUFBQSxVQUFTNlgsS0FBVDtBQUFBLFVBQ0NvVCxLQUFLLEdBQUc5cUIsSUFBSSxDQUFDbGpFLFFBRGQsQ0FEbUMsQ0FJbkM7O0FBQ0EsVUFBS2d1RixLQUFLLEtBQUssQ0FBVixJQUFlQSxLQUFLLEtBQUssQ0FBekIsSUFBOEJBLEtBQUssS0FBSyxDQUE3QyxFQUFpRDtBQUNoRDtBQUNBLE9BUGtDLENBU25DOzs7QUFDQSxVQUFLLE9BQU85cUIsSUFBSSxDQUFDdjlELFlBQVosS0FBNkIsV0FBbEMsRUFBZ0Q7QUFDL0MsZUFBTzg4RCxNQUFNLENBQUMxMUMsSUFBUCxDQUFhbTJDLElBQWIsRUFBbUIvakQsSUFBbkIsRUFBeUJ4bEIsS0FBekIsQ0FBUDtBQUNBLE9BWmtDLENBY25DO0FBQ0E7OztBQUNBLFVBQUtxMEYsS0FBSyxLQUFLLENBQVYsSUFBZSxDQUFDdnJCLE1BQU0sQ0FBQ3lRLFFBQVAsQ0FBaUJoUSxJQUFqQixDQUFyQixFQUErQztBQUM5QzBYLFFBQUFBLEtBQUssR0FBR25ZLE1BQU0sQ0FBQ3dyQixTQUFQLENBQWtCOXVFLElBQUksQ0FBQ2xlLFdBQUwsRUFBbEIsTUFDTHdoRSxNQUFNLENBQUNrSyxJQUFQLENBQVlyckQsS0FBWixDQUFrQjRzRSxJQUFsQixDQUF1QnJvRixJQUF2QixDQUE2QnNaLElBQTdCLElBQXNDMnVFLFFBQXRDLEdBQWlEaHFCLFNBRDVDLENBQVI7QUFFQTs7QUFFRCxVQUFLbnFFLEtBQUssS0FBS21xRSxTQUFmLEVBQTJCO0FBQzFCLFlBQUtucUUsS0FBSyxLQUFLLElBQWYsRUFBc0I7QUFDckI4b0UsVUFBQUEsTUFBTSxDQUFDc3JCLFVBQVAsQ0FBbUI3cUIsSUFBbkIsRUFBeUIvakQsSUFBekI7QUFDQTtBQUNBOztBQUVELFlBQUt5N0QsS0FBSyxJQUFJLFNBQVNBLEtBQWxCLElBQ0osQ0FBRTdYLEdBQUcsR0FBRzZYLEtBQUssQ0FBQ3owRSxHQUFOLENBQVcrOEQsSUFBWCxFQUFpQnZwRSxLQUFqQixFQUF3QndsQixJQUF4QixDQUFSLE1BQTZDMmtELFNBRDlDLEVBQzBEO0FBQ3pELGlCQUFPZixHQUFQO0FBQ0E7O0FBRURHLFFBQUFBLElBQUksQ0FBQzNoRCxZQUFMLENBQW1CcEMsSUFBbkIsRUFBeUJ4bEIsS0FBSyxHQUFHLEVBQWpDO0FBQ0EsZUFBT0EsS0FBUDtBQUNBOztBQUVELFVBQUtpaEYsS0FBSyxJQUFJLFNBQVNBLEtBQWxCLElBQTJCLENBQUU3WCxHQUFHLEdBQUc2WCxLQUFLLENBQUM5dkUsR0FBTixDQUFXbzRELElBQVgsRUFBaUIvakQsSUFBakIsQ0FBUixNQUFzQyxJQUF0RSxFQUE2RTtBQUM1RSxlQUFPNGpELEdBQVA7QUFDQTs7QUFFREEsTUFBQUEsR0FBRyxHQUFHTixNQUFNLENBQUMrSSxJQUFQLENBQVl2c0QsSUFBWixDQUFrQmlrRCxJQUFsQixFQUF3Qi9qRCxJQUF4QixDQUFOLENBeENtQyxDQTBDbkM7O0FBQ0EsYUFBTzRqRCxHQUFHLElBQUksSUFBUCxHQUFjZSxTQUFkLEdBQTBCZixHQUFqQztBQUNBLEtBN0NhO0FBK0Nka3JCLElBQUFBLFNBQVMsRUFBRTtBQUNWenpGLE1BQUFBLElBQUksRUFBRTtBQUNMMkwsUUFBQUEsR0FBRyxFQUFFLGFBQVUrOEQsSUFBVixFQUFnQnZwRSxLQUFoQixFQUF3QjtBQUM1QixjQUFLLENBQUNnb0UsT0FBTyxDQUFDa3NCLFVBQVQsSUFBdUJsMEYsS0FBSyxLQUFLLE9BQWpDLElBQ0ptTSxRQUFRLENBQUVvOUQsSUFBRixFQUFRLE9BQVIsQ0FEVCxFQUM2QjtBQUM1QixnQkFBSTM0RCxHQUFHLEdBQUcyNEQsSUFBSSxDQUFDdnBFLEtBQWY7QUFDQXVwRSxZQUFBQSxJQUFJLENBQUMzaEQsWUFBTCxDQUFtQixNQUFuQixFQUEyQjVuQixLQUEzQjs7QUFDQSxnQkFBSzRRLEdBQUwsRUFBVztBQUNWMjRELGNBQUFBLElBQUksQ0FBQ3ZwRSxLQUFMLEdBQWE0USxHQUFiO0FBQ0E7O0FBQ0QsbUJBQU81USxLQUFQO0FBQ0E7QUFDRDtBQVhJO0FBREksS0EvQ0c7QUErRGRvMEYsSUFBQUEsVUFBVSxFQUFFLG9CQUFVN3FCLElBQVYsRUFBZ0J2cEUsS0FBaEIsRUFBd0I7QUFDbkMsVUFBSXdsQixJQUFKO0FBQUEsVUFDQzVpQixDQUFDLEdBQUcsQ0FETDtBQUFBLFVBR0M7QUFDQTtBQUNBNHhGLE1BQUFBLFNBQVMsR0FBR3gwRixLQUFLLElBQUlBLEtBQUssQ0FBQzJuQixLQUFOLENBQWF3ekQsYUFBYixDQUx0Qjs7QUFPQSxVQUFLcVosU0FBUyxJQUFJanJCLElBQUksQ0FBQ2xqRSxRQUFMLEtBQWtCLENBQXBDLEVBQXdDO0FBQ3ZDLGVBQVVtZixJQUFJLEdBQUdndkUsU0FBUyxDQUFFNXhGLENBQUMsRUFBSCxDQUExQixFQUFzQztBQUNyQzJtRSxVQUFBQSxJQUFJLENBQUN0SyxlQUFMLENBQXNCejVDLElBQXRCO0FBQ0E7QUFDRDtBQUNEO0FBNUVhLEdBQWYsRUF2eFBpRixDQXMyUGpGOztBQUNBMnVFLEVBQUFBLFFBQVEsR0FBRztBQUNWM25GLElBQUFBLEdBQUcsRUFBRSxhQUFVKzhELElBQVYsRUFBZ0J2cEUsS0FBaEIsRUFBdUJ3bEIsSUFBdkIsRUFBOEI7QUFDbEMsVUFBS3hsQixLQUFLLEtBQUssS0FBZixFQUF1QjtBQUV0QjtBQUNBOG9FLFFBQUFBLE1BQU0sQ0FBQ3NyQixVQUFQLENBQW1CN3FCLElBQW5CLEVBQXlCL2pELElBQXpCO0FBQ0EsT0FKRCxNQUlPO0FBQ04rakQsUUFBQUEsSUFBSSxDQUFDM2hELFlBQUwsQ0FBbUJwQyxJQUFuQixFQUF5QkEsSUFBekI7QUFDQTs7QUFDRCxhQUFPQSxJQUFQO0FBQ0E7QUFWUyxHQUFYO0FBYUFzakQsRUFBQUEsTUFBTSxDQUFDdmpCLElBQVAsQ0FBYXVqQixNQUFNLENBQUNrSyxJQUFQLENBQVlyckQsS0FBWixDQUFrQjRzRSxJQUFsQixDQUF1QnJ3RSxNQUF2QixDQUE4QnlELEtBQTlCLENBQXFDLE1BQXJDLENBQWIsRUFBNEQsVUFBVThaLEVBQVYsRUFBY2pjLElBQWQsRUFBcUI7QUFDaEYsUUFBSTAwQyxNQUFNLEdBQUdzVyxVQUFVLENBQUVockQsSUFBRixDQUFWLElBQXNCc2pELE1BQU0sQ0FBQytJLElBQVAsQ0FBWXZzRCxJQUEvQzs7QUFFQWtyRCxJQUFBQSxVQUFVLENBQUVockQsSUFBRixDQUFWLEdBQXFCLFVBQVUrakQsSUFBVixFQUFnQi9qRCxJQUFoQixFQUFzQm1tRCxLQUF0QixFQUE4QjtBQUNsRCxVQUFJdkMsR0FBSjtBQUFBLFVBQVNqMkQsTUFBVDtBQUFBLFVBQ0NpOEMsYUFBYSxHQUFHNXBDLElBQUksQ0FBQ2xlLFdBQUwsRUFEakI7O0FBR0EsVUFBSyxDQUFDcWtFLEtBQU4sRUFBYztBQUViO0FBQ0F4NEQsUUFBQUEsTUFBTSxHQUFHcTlELFVBQVUsQ0FBRXBoQixhQUFGLENBQW5CO0FBQ0FvaEIsUUFBQUEsVUFBVSxDQUFFcGhCLGFBQUYsQ0FBVixHQUE4QmdhLEdBQTlCO0FBQ0FBLFFBQUFBLEdBQUcsR0FBR2xQLE1BQU0sQ0FBRXFQLElBQUYsRUFBUS9qRCxJQUFSLEVBQWNtbUQsS0FBZCxDQUFOLElBQStCLElBQS9CLEdBQ0x2YyxhQURLLEdBRUwsSUFGRDtBQUdBb2hCLFFBQUFBLFVBQVUsQ0FBRXBoQixhQUFGLENBQVYsR0FBOEJqOEMsTUFBOUI7QUFDQTs7QUFDRCxhQUFPaTJELEdBQVA7QUFDQSxLQWZEO0FBZ0JBLEdBbkJEO0FBd0JBLE1BQUlxckIsVUFBVSxHQUFHLHFDQUFqQjtBQUFBLE1BQ0NDLFVBQVUsR0FBRyxlQURkO0FBR0E1ckIsRUFBQUEsTUFBTSxDQUFDQyxFQUFQLENBQVVlLE1BQVYsQ0FBa0I7QUFDakIxMkMsSUFBQUEsSUFBSSxFQUFFLGNBQVU1TixJQUFWLEVBQWdCeGxCLEtBQWhCLEVBQXdCO0FBQzdCLGFBQU9vL0UsTUFBTSxDQUFFLElBQUYsRUFBUXRXLE1BQU0sQ0FBQzExQyxJQUFmLEVBQXFCNU4sSUFBckIsRUFBMkJ4bEIsS0FBM0IsRUFBa0N1TyxTQUFTLENBQUMxTCxNQUFWLEdBQW1CLENBQXJELENBQWI7QUFDQSxLQUhnQjtBQUtqQjh4RixJQUFBQSxVQUFVLEVBQUUsb0JBQVVudkUsSUFBVixFQUFpQjtBQUM1QixhQUFPLEtBQUsrL0IsSUFBTCxDQUFXLFlBQVc7QUFDNUIsZUFBTyxLQUFNdWpCLE1BQU0sQ0FBQzhyQixPQUFQLENBQWdCcHZFLElBQWhCLEtBQTBCQSxJQUFoQyxDQUFQO0FBQ0EsT0FGTSxDQUFQO0FBR0E7QUFUZ0IsR0FBbEI7QUFZQXNqRCxFQUFBQSxNQUFNLENBQUNnQixNQUFQLENBQWU7QUFDZDEyQyxJQUFBQSxJQUFJLEVBQUUsY0FBVW0yQyxJQUFWLEVBQWdCL2pELElBQWhCLEVBQXNCeGxCLEtBQXRCLEVBQThCO0FBQ25DLFVBQUlvcEUsR0FBSjtBQUFBLFVBQVM2WCxLQUFUO0FBQUEsVUFDQ29ULEtBQUssR0FBRzlxQixJQUFJLENBQUNsakUsUUFEZCxDQURtQyxDQUluQzs7QUFDQSxVQUFLZ3VGLEtBQUssS0FBSyxDQUFWLElBQWVBLEtBQUssS0FBSyxDQUF6QixJQUE4QkEsS0FBSyxLQUFLLENBQTdDLEVBQWlEO0FBQ2hEO0FBQ0E7O0FBRUQsVUFBS0EsS0FBSyxLQUFLLENBQVYsSUFBZSxDQUFDdnJCLE1BQU0sQ0FBQ3lRLFFBQVAsQ0FBaUJoUSxJQUFqQixDQUFyQixFQUErQztBQUU5QztBQUNBL2pELFFBQUFBLElBQUksR0FBR3NqRCxNQUFNLENBQUM4ckIsT0FBUCxDQUFnQnB2RSxJQUFoQixLQUEwQkEsSUFBakM7QUFDQXk3RCxRQUFBQSxLQUFLLEdBQUduWSxNQUFNLENBQUN1bkIsU0FBUCxDQUFrQjdxRSxJQUFsQixDQUFSO0FBQ0E7O0FBRUQsVUFBS3hsQixLQUFLLEtBQUttcUUsU0FBZixFQUEyQjtBQUMxQixZQUFLOFcsS0FBSyxJQUFJLFNBQVNBLEtBQWxCLElBQ0osQ0FBRTdYLEdBQUcsR0FBRzZYLEtBQUssQ0FBQ3owRSxHQUFOLENBQVcrOEQsSUFBWCxFQUFpQnZwRSxLQUFqQixFQUF3QndsQixJQUF4QixDQUFSLE1BQTZDMmtELFNBRDlDLEVBQzBEO0FBQ3pELGlCQUFPZixHQUFQO0FBQ0E7O0FBRUQsZUFBU0csSUFBSSxDQUFFL2pELElBQUYsQ0FBSixHQUFleGxCLEtBQXhCO0FBQ0E7O0FBRUQsVUFBS2loRixLQUFLLElBQUksU0FBU0EsS0FBbEIsSUFBMkIsQ0FBRTdYLEdBQUcsR0FBRzZYLEtBQUssQ0FBQzl2RSxHQUFOLENBQVdvNEQsSUFBWCxFQUFpQi9qRCxJQUFqQixDQUFSLE1BQXNDLElBQXRFLEVBQTZFO0FBQzVFLGVBQU80akQsR0FBUDtBQUNBOztBQUVELGFBQU9HLElBQUksQ0FBRS9qRCxJQUFGLENBQVg7QUFDQSxLQS9CYTtBQWlDZDZxRSxJQUFBQSxTQUFTLEVBQUU7QUFDVjNhLE1BQUFBLFFBQVEsRUFBRTtBQUNUdmtFLFFBQUFBLEdBQUcsRUFBRSxhQUFVbzRELElBQVYsRUFBaUI7QUFFckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQUlzckIsUUFBUSxHQUFHL3JCLE1BQU0sQ0FBQytJLElBQVAsQ0FBWXZzRCxJQUFaLENBQWtCaWtELElBQWxCLEVBQXdCLFVBQXhCLENBQWY7O0FBRUEsY0FBS3NyQixRQUFMLEVBQWdCO0FBQ2YsbUJBQU94cEMsUUFBUSxDQUFFd3BDLFFBQUYsRUFBWSxFQUFaLENBQWY7QUFDQTs7QUFFRCxjQUNDSixVQUFVLENBQUN2b0YsSUFBWCxDQUFpQnE5RCxJQUFJLENBQUNwOUQsUUFBdEIsS0FDQXVvRixVQUFVLENBQUN4b0YsSUFBWCxDQUFpQnE5RCxJQUFJLENBQUNwOUQsUUFBdEIsS0FDQW85RCxJQUFJLENBQUNrTSxJQUhOLEVBSUU7QUFDRCxtQkFBTyxDQUFQO0FBQ0E7O0FBRUQsaUJBQU8sQ0FBQyxDQUFSO0FBQ0E7QUF2QlE7QUFEQSxLQWpDRztBQTZEZG1mLElBQUFBLE9BQU8sRUFBRTtBQUNSLGFBQU8sU0FEQztBQUVSLGVBQVM7QUFGRDtBQTdESyxHQUFmLEVBMzVQaUYsQ0E4OVBqRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBLE1BQUssQ0FBQzVzQixPQUFPLENBQUNpc0IsV0FBZCxFQUE0QjtBQUMzQm5yQixJQUFBQSxNQUFNLENBQUN1bkIsU0FBUCxDQUFpQnphLFFBQWpCLEdBQTRCO0FBQzNCemtFLE1BQUFBLEdBQUcsRUFBRSxhQUFVbzRELElBQVYsRUFBaUI7QUFFckI7QUFFQSxZQUFJNTRELE1BQU0sR0FBRzQ0RCxJQUFJLENBQUNwakUsVUFBbEI7O0FBQ0EsWUFBS3dLLE1BQU0sSUFBSUEsTUFBTSxDQUFDeEssVUFBdEIsRUFBbUM7QUFDbEN3SyxVQUFBQSxNQUFNLENBQUN4SyxVQUFQLENBQWtCMHZFLGFBQWxCO0FBQ0E7O0FBQ0QsZUFBTyxJQUFQO0FBQ0EsT0FWMEI7QUFXM0JycEUsTUFBQUEsR0FBRyxFQUFFLGFBQVUrOEQsSUFBVixFQUFpQjtBQUVyQjtBQUVBLFlBQUk1NEQsTUFBTSxHQUFHNDRELElBQUksQ0FBQ3BqRSxVQUFsQjs7QUFDQSxZQUFLd0ssTUFBTCxFQUFjO0FBQ2JBLFVBQUFBLE1BQU0sQ0FBQ2tsRSxhQUFQOztBQUVBLGNBQUtsbEUsTUFBTSxDQUFDeEssVUFBWixFQUF5QjtBQUN4QndLLFlBQUFBLE1BQU0sQ0FBQ3hLLFVBQVAsQ0FBa0IwdkUsYUFBbEI7QUFDQTtBQUNEO0FBQ0Q7QUF2QjBCLEtBQTVCO0FBeUJBOztBQUVEL00sRUFBQUEsTUFBTSxDQUFDdmpCLElBQVAsQ0FBYSxDQUNaLFVBRFksRUFFWixVQUZZLEVBR1osV0FIWSxFQUlaLGFBSlksRUFLWixhQUxZLEVBTVosU0FOWSxFQU9aLFNBUFksRUFRWixRQVJZLEVBU1osYUFUWSxFQVVaLGlCQVZZLENBQWIsRUFXRyxZQUFXO0FBQ2J1akIsSUFBQUEsTUFBTSxDQUFDOHJCLE9BQVAsQ0FBZ0IsS0FBS3R0RixXQUFMLEVBQWhCLElBQXVDLElBQXZDO0FBQ0EsR0FiRCxFQWxnUWlGLENBb2hRaEY7QUFDQTs7QUFDQSxXQUFTd3RGLGdCQUFULENBQTJCOTBGLEtBQTNCLEVBQW1DO0FBQ2xDLFFBQUl1MkUsTUFBTSxHQUFHdjJFLEtBQUssQ0FBQzJuQixLQUFOLENBQWF3ekQsYUFBYixLQUFnQyxFQUE3QztBQUNBLFdBQU81RSxNQUFNLENBQUNqdkQsSUFBUCxDQUFhLEdBQWIsQ0FBUDtBQUNBOztBQUdGLFdBQVN5dEUsUUFBVCxDQUFtQnhyQixJQUFuQixFQUEwQjtBQUN6QixXQUFPQSxJQUFJLENBQUN2OUQsWUFBTCxJQUFxQnU5RCxJQUFJLENBQUN2OUQsWUFBTCxDQUFtQixPQUFuQixDQUFyQixJQUFxRCxFQUE1RDtBQUNBOztBQUVELFdBQVNncEYsY0FBVCxDQUF5QmgxRixLQUF6QixFQUFpQztBQUNoQyxRQUFLVSxLQUFLLENBQUNDLE9BQU4sQ0FBZVgsS0FBZixDQUFMLEVBQThCO0FBQzdCLGFBQU9BLEtBQVA7QUFDQTs7QUFDRCxRQUFLLE9BQU9BLEtBQVAsS0FBaUIsUUFBdEIsRUFBaUM7QUFDaEMsYUFBT0EsS0FBSyxDQUFDMm5CLEtBQU4sQ0FBYXd6RCxhQUFiLEtBQWdDLEVBQXZDO0FBQ0E7O0FBQ0QsV0FBTyxFQUFQO0FBQ0E7O0FBRURyUyxFQUFBQSxNQUFNLENBQUNDLEVBQVAsQ0FBVWUsTUFBVixDQUFrQjtBQUNqQm1yQixJQUFBQSxRQUFRLEVBQUUsa0JBQVVqMUYsS0FBVixFQUFrQjtBQUMzQixVQUFJazFGLE9BQUo7QUFBQSxVQUFhM3JCLElBQWI7QUFBQSxVQUFtQm1ILEdBQW5CO0FBQUEsVUFBd0JoUixRQUF4QjtBQUFBLFVBQWtDeTFCLEtBQWxDO0FBQUEsVUFBeUMvckUsQ0FBekM7QUFBQSxVQUE0Qzg2QyxVQUE1QztBQUFBLFVBQ0N0aEUsQ0FBQyxHQUFHLENBREw7O0FBR0EsVUFBS3FsRSxVQUFVLENBQUVqb0UsS0FBRixDQUFmLEVBQTJCO0FBQzFCLGVBQU8sS0FBS3VsRCxJQUFMLENBQVcsVUFBVW44QixDQUFWLEVBQWM7QUFDL0IwL0MsVUFBQUEsTUFBTSxDQUFFLElBQUYsQ0FBTixDQUFlbXNCLFFBQWYsQ0FBeUJqMUYsS0FBSyxDQUFDNkwsSUFBTixDQUFZLElBQVosRUFBa0J1ZCxDQUFsQixFQUFxQjJyRSxRQUFRLENBQUUsSUFBRixDQUE3QixDQUF6QjtBQUNBLFNBRk0sQ0FBUDtBQUdBOztBQUVERyxNQUFBQSxPQUFPLEdBQUdGLGNBQWMsQ0FBRWgxRixLQUFGLENBQXhCOztBQUVBLFVBQUtrMUYsT0FBTyxDQUFDcnlGLE1BQWIsRUFBc0I7QUFDckIsZUFBVTBtRSxJQUFJLEdBQUcsS0FBTTNtRSxDQUFDLEVBQVAsQ0FBakIsRUFBaUM7QUFDaEM4OEQsVUFBQUEsUUFBUSxHQUFHcTFCLFFBQVEsQ0FBRXhyQixJQUFGLENBQW5CO0FBQ0FtSCxVQUFBQSxHQUFHLEdBQUduSCxJQUFJLENBQUNsakUsUUFBTCxLQUFrQixDQUFsQixJQUF5QixNQUFNeXVGLGdCQUFnQixDQUFFcDFCLFFBQUYsQ0FBdEIsR0FBcUMsR0FBcEU7O0FBRUEsY0FBS2dSLEdBQUwsRUFBVztBQUNWdG5ELFlBQUFBLENBQUMsR0FBRyxDQUFKOztBQUNBLG1CQUFVK3JFLEtBQUssR0FBR0QsT0FBTyxDQUFFOXJFLENBQUMsRUFBSCxDQUF6QixFQUFxQztBQUNwQyxrQkFBS3NuRCxHQUFHLENBQUNyZ0UsT0FBSixDQUFhLE1BQU04a0YsS0FBTixHQUFjLEdBQTNCLElBQW1DLENBQXhDLEVBQTRDO0FBQzNDemtCLGdCQUFBQSxHQUFHLElBQUl5a0IsS0FBSyxHQUFHLEdBQWY7QUFDQTtBQUNELGFBTlMsQ0FRVjs7O0FBQ0FqeEIsWUFBQUEsVUFBVSxHQUFHNHdCLGdCQUFnQixDQUFFcGtCLEdBQUYsQ0FBN0I7O0FBQ0EsZ0JBQUtoUixRQUFRLEtBQUt3RSxVQUFsQixFQUErQjtBQUM5QnFGLGNBQUFBLElBQUksQ0FBQzNoRCxZQUFMLENBQW1CLE9BQW5CLEVBQTRCczhDLFVBQTVCO0FBQ0E7QUFDRDtBQUNEO0FBQ0Q7O0FBRUQsYUFBTyxJQUFQO0FBQ0EsS0FwQ2dCO0FBc0NqQmt4QixJQUFBQSxXQUFXLEVBQUUscUJBQVVwMUYsS0FBVixFQUFrQjtBQUM5QixVQUFJazFGLE9BQUo7QUFBQSxVQUFhM3JCLElBQWI7QUFBQSxVQUFtQm1ILEdBQW5CO0FBQUEsVUFBd0JoUixRQUF4QjtBQUFBLFVBQWtDeTFCLEtBQWxDO0FBQUEsVUFBeUMvckUsQ0FBekM7QUFBQSxVQUE0Qzg2QyxVQUE1QztBQUFBLFVBQ0N0aEUsQ0FBQyxHQUFHLENBREw7O0FBR0EsVUFBS3FsRSxVQUFVLENBQUVqb0UsS0FBRixDQUFmLEVBQTJCO0FBQzFCLGVBQU8sS0FBS3VsRCxJQUFMLENBQVcsVUFBVW44QixDQUFWLEVBQWM7QUFDL0IwL0MsVUFBQUEsTUFBTSxDQUFFLElBQUYsQ0FBTixDQUFlc3NCLFdBQWYsQ0FBNEJwMUYsS0FBSyxDQUFDNkwsSUFBTixDQUFZLElBQVosRUFBa0J1ZCxDQUFsQixFQUFxQjJyRSxRQUFRLENBQUUsSUFBRixDQUE3QixDQUE1QjtBQUNBLFNBRk0sQ0FBUDtBQUdBOztBQUVELFVBQUssQ0FBQ3htRixTQUFTLENBQUMxTCxNQUFoQixFQUF5QjtBQUN4QixlQUFPLEtBQUt5aUIsSUFBTCxDQUFXLE9BQVgsRUFBb0IsRUFBcEIsQ0FBUDtBQUNBOztBQUVENHZFLE1BQUFBLE9BQU8sR0FBR0YsY0FBYyxDQUFFaDFGLEtBQUYsQ0FBeEI7O0FBRUEsVUFBS2sxRixPQUFPLENBQUNyeUYsTUFBYixFQUFzQjtBQUNyQixlQUFVMG1FLElBQUksR0FBRyxLQUFNM21FLENBQUMsRUFBUCxDQUFqQixFQUFpQztBQUNoQzg4RCxVQUFBQSxRQUFRLEdBQUdxMUIsUUFBUSxDQUFFeHJCLElBQUYsQ0FBbkIsQ0FEZ0MsQ0FHaEM7O0FBQ0FtSCxVQUFBQSxHQUFHLEdBQUduSCxJQUFJLENBQUNsakUsUUFBTCxLQUFrQixDQUFsQixJQUF5QixNQUFNeXVGLGdCQUFnQixDQUFFcDFCLFFBQUYsQ0FBdEIsR0FBcUMsR0FBcEU7O0FBRUEsY0FBS2dSLEdBQUwsRUFBVztBQUNWdG5ELFlBQUFBLENBQUMsR0FBRyxDQUFKOztBQUNBLG1CQUFVK3JFLEtBQUssR0FBR0QsT0FBTyxDQUFFOXJFLENBQUMsRUFBSCxDQUF6QixFQUFxQztBQUVwQztBQUNBLHFCQUFRc25ELEdBQUcsQ0FBQ3JnRSxPQUFKLENBQWEsTUFBTThrRixLQUFOLEdBQWMsR0FBM0IsSUFBbUMsQ0FBQyxDQUE1QyxFQUFnRDtBQUMvQ3prQixnQkFBQUEsR0FBRyxHQUFHQSxHQUFHLENBQUN6dkUsT0FBSixDQUFhLE1BQU1rMEYsS0FBTixHQUFjLEdBQTNCLEVBQWdDLEdBQWhDLENBQU47QUFDQTtBQUNELGFBUlMsQ0FVVjs7O0FBQ0FqeEIsWUFBQUEsVUFBVSxHQUFHNHdCLGdCQUFnQixDQUFFcGtCLEdBQUYsQ0FBN0I7O0FBQ0EsZ0JBQUtoUixRQUFRLEtBQUt3RSxVQUFsQixFQUErQjtBQUM5QnFGLGNBQUFBLElBQUksQ0FBQzNoRCxZQUFMLENBQW1CLE9BQW5CLEVBQTRCczhDLFVBQTVCO0FBQ0E7QUFDRDtBQUNEO0FBQ0Q7O0FBRUQsYUFBTyxJQUFQO0FBQ0EsS0FqRmdCO0FBbUZqQjUyQixJQUFBQSxXQUFXLEVBQUUscUJBQVV0dEMsS0FBVixFQUFpQnExRixRQUFqQixFQUE0QjtBQUN4QyxVQUFJeDBGLElBQUksV0FBVWIsS0FBVixDQUFSO0FBQUEsVUFDQ3MxRixZQUFZLEdBQUd6MEYsSUFBSSxLQUFLLFFBQVQsSUFBcUJILEtBQUssQ0FBQ0MsT0FBTixDQUFlWCxLQUFmLENBRHJDOztBQUdBLFVBQUssT0FBT3ExRixRQUFQLEtBQW9CLFNBQXBCLElBQWlDQyxZQUF0QyxFQUFxRDtBQUNwRCxlQUFPRCxRQUFRLEdBQUcsS0FBS0osUUFBTCxDQUFlajFGLEtBQWYsQ0FBSCxHQUE0QixLQUFLbzFGLFdBQUwsQ0FBa0JwMUYsS0FBbEIsQ0FBM0M7QUFDQTs7QUFFRCxVQUFLaW9FLFVBQVUsQ0FBRWpvRSxLQUFGLENBQWYsRUFBMkI7QUFDMUIsZUFBTyxLQUFLdWxELElBQUwsQ0FBVyxVQUFVM2lELENBQVYsRUFBYztBQUMvQmttRSxVQUFBQSxNQUFNLENBQUUsSUFBRixDQUFOLENBQWV4N0IsV0FBZixDQUNDdHRDLEtBQUssQ0FBQzZMLElBQU4sQ0FBWSxJQUFaLEVBQWtCakosQ0FBbEIsRUFBcUJteUYsUUFBUSxDQUFFLElBQUYsQ0FBN0IsRUFBdUNNLFFBQXZDLENBREQsRUFFQ0EsUUFGRDtBQUlBLFNBTE0sQ0FBUDtBQU1BOztBQUVELGFBQU8sS0FBSzl2QyxJQUFMLENBQVcsWUFBVztBQUM1QixZQUFJL1MsU0FBSixFQUFlNXZDLENBQWYsRUFBa0JoRixJQUFsQixFQUF3QjIzRixVQUF4Qjs7QUFFQSxZQUFLRCxZQUFMLEVBQW9CO0FBRW5CO0FBQ0ExeUYsVUFBQUEsQ0FBQyxHQUFHLENBQUo7QUFDQWhGLFVBQUFBLElBQUksR0FBR2tyRSxNQUFNLENBQUUsSUFBRixDQUFiO0FBQ0F5c0IsVUFBQUEsVUFBVSxHQUFHUCxjQUFjLENBQUVoMUYsS0FBRixDQUEzQjs7QUFFQSxpQkFBVXd5QyxTQUFTLEdBQUcraUQsVUFBVSxDQUFFM3lGLENBQUMsRUFBSCxDQUFoQyxFQUE0QztBQUUzQztBQUNBLGdCQUFLaEYsSUFBSSxDQUFDNDNGLFFBQUwsQ0FBZWhqRCxTQUFmLENBQUwsRUFBa0M7QUFDakM1MEMsY0FBQUEsSUFBSSxDQUFDdzNGLFdBQUwsQ0FBa0I1aUQsU0FBbEI7QUFDQSxhQUZELE1BRU87QUFDTjUwQyxjQUFBQSxJQUFJLENBQUNxM0YsUUFBTCxDQUFlemlELFNBQWY7QUFDQTtBQUNELFdBZmtCLENBaUJwQjs7QUFDQyxTQWxCRCxNQWtCTyxJQUFLeHlDLEtBQUssS0FBS21xRSxTQUFWLElBQXVCdHBFLElBQUksS0FBSyxTQUFyQyxFQUFpRDtBQUN2RDJ4QyxVQUFBQSxTQUFTLEdBQUd1aUQsUUFBUSxDQUFFLElBQUYsQ0FBcEI7O0FBQ0EsY0FBS3ZpRCxTQUFMLEVBQWlCO0FBRWhCO0FBQ0E0dEMsWUFBQUEsUUFBUSxDQUFDNXpFLEdBQVQsQ0FBYyxJQUFkLEVBQW9CLGVBQXBCLEVBQXFDZ21DLFNBQXJDO0FBQ0EsV0FOc0QsQ0FRdkQ7QUFDQTtBQUNBO0FBQ0E7OztBQUNBLGNBQUssS0FBSzVxQixZQUFWLEVBQXlCO0FBQ3hCLGlCQUFLQSxZQUFMLENBQW1CLE9BQW5CLEVBQ0M0cUIsU0FBUyxJQUFJeHlDLEtBQUssS0FBSyxLQUF2QixHQUNDLEVBREQsR0FFQ29nRixRQUFRLENBQUNqdkUsR0FBVCxDQUFjLElBQWQsRUFBb0IsZUFBcEIsS0FBeUMsRUFIM0M7QUFLQTtBQUNEO0FBQ0QsT0F6Q00sQ0FBUDtBQTBDQSxLQTlJZ0I7QUFnSmpCcWtGLElBQUFBLFFBQVEsRUFBRSxrQkFBVXJ3QyxRQUFWLEVBQXFCO0FBQzlCLFVBQUkzUyxTQUFKO0FBQUEsVUFBZSsyQixJQUFmO0FBQUEsVUFDQzNtRSxDQUFDLEdBQUcsQ0FETDtBQUdBNHZDLE1BQUFBLFNBQVMsR0FBRyxNQUFNMlMsUUFBTixHQUFpQixHQUE3Qjs7QUFDQSxhQUFVb2tCLElBQUksR0FBRyxLQUFNM21FLENBQUMsRUFBUCxDQUFqQixFQUFpQztBQUNoQyxZQUFLMm1FLElBQUksQ0FBQ2xqRSxRQUFMLEtBQWtCLENBQWxCLElBQ0osQ0FBRSxNQUFNeXVGLGdCQUFnQixDQUFFQyxRQUFRLENBQUV4ckIsSUFBRixDQUFWLENBQXRCLEdBQTZDLEdBQS9DLEVBQXFEbDVELE9BQXJELENBQThEbWlDLFNBQTlELElBQTRFLENBQUMsQ0FEOUUsRUFDa0Y7QUFDakYsaUJBQU8sSUFBUDtBQUNBO0FBQ0Q7O0FBRUQsYUFBTyxLQUFQO0FBQ0E7QUE3SmdCLEdBQWxCO0FBbUtBLE1BQUlpakQsT0FBTyxHQUFHLEtBQWQ7QUFFQTNzQixFQUFBQSxNQUFNLENBQUNDLEVBQVAsQ0FBVWUsTUFBVixDQUFrQjtBQUNqQmw1RCxJQUFBQSxHQUFHLEVBQUUsYUFBVTVRLEtBQVYsRUFBa0I7QUFDdEIsVUFBSWloRixLQUFKO0FBQUEsVUFBVzdYLEdBQVg7QUFBQSxVQUFnQjhnQixlQUFoQjtBQUFBLFVBQ0MzZ0IsSUFBSSxHQUFHLEtBQU0sQ0FBTixDQURSOztBQUdBLFVBQUssQ0FBQ2g3RCxTQUFTLENBQUMxTCxNQUFoQixFQUF5QjtBQUN4QixZQUFLMG1FLElBQUwsRUFBWTtBQUNYMFgsVUFBQUEsS0FBSyxHQUFHblksTUFBTSxDQUFDNHNCLFFBQVAsQ0FBaUJuc0IsSUFBSSxDQUFDMW9FLElBQXRCLEtBQ1Bpb0UsTUFBTSxDQUFDNHNCLFFBQVAsQ0FBaUJuc0IsSUFBSSxDQUFDcDlELFFBQUwsQ0FBYzdFLFdBQWQsRUFBakIsQ0FERDs7QUFHQSxjQUFLMjVFLEtBQUssSUFDVCxTQUFTQSxLQURMLElBRUosQ0FBRTdYLEdBQUcsR0FBRzZYLEtBQUssQ0FBQzl2RSxHQUFOLENBQVdvNEQsSUFBWCxFQUFpQixPQUFqQixDQUFSLE1BQXlDWSxTQUYxQyxFQUdFO0FBQ0QsbUJBQU9mLEdBQVA7QUFDQTs7QUFFREEsVUFBQUEsR0FBRyxHQUFHRyxJQUFJLENBQUN2cEUsS0FBWCxDQVhXLENBYVg7O0FBQ0EsY0FBSyxPQUFPb3BFLEdBQVAsS0FBZSxRQUFwQixFQUErQjtBQUM5QixtQkFBT0EsR0FBRyxDQUFDbm9FLE9BQUosQ0FBYXcwRixPQUFiLEVBQXNCLEVBQXRCLENBQVA7QUFDQSxXQWhCVSxDQWtCWDs7O0FBQ0EsaUJBQU9yc0IsR0FBRyxJQUFJLElBQVAsR0FBYyxFQUFkLEdBQW1CQSxHQUExQjtBQUNBOztBQUVEO0FBQ0E7O0FBRUQ4Z0IsTUFBQUEsZUFBZSxHQUFHamlCLFVBQVUsQ0FBRWpvRSxLQUFGLENBQTVCO0FBRUEsYUFBTyxLQUFLdWxELElBQUwsQ0FBVyxVQUFVM2lELENBQVYsRUFBYztBQUMvQixZQUFJZ08sR0FBSjs7QUFFQSxZQUFLLEtBQUt2SyxRQUFMLEtBQWtCLENBQXZCLEVBQTJCO0FBQzFCO0FBQ0E7O0FBRUQsWUFBSzZqRixlQUFMLEVBQXVCO0FBQ3RCdDVFLFVBQUFBLEdBQUcsR0FBRzVRLEtBQUssQ0FBQzZMLElBQU4sQ0FBWSxJQUFaLEVBQWtCakosQ0FBbEIsRUFBcUJrbUUsTUFBTSxDQUFFLElBQUYsQ0FBTixDQUFlbDRELEdBQWYsRUFBckIsQ0FBTjtBQUNBLFNBRkQsTUFFTztBQUNOQSxVQUFBQSxHQUFHLEdBQUc1USxLQUFOO0FBQ0EsU0FYOEIsQ0FhL0I7OztBQUNBLFlBQUs0USxHQUFHLElBQUksSUFBWixFQUFtQjtBQUNsQkEsVUFBQUEsR0FBRyxHQUFHLEVBQU47QUFFQSxTQUhELE1BR08sSUFBSyxPQUFPQSxHQUFQLEtBQWUsUUFBcEIsRUFBK0I7QUFDckNBLFVBQUFBLEdBQUcsSUFBSSxFQUFQO0FBRUEsU0FITSxNQUdBLElBQUtsUSxLQUFLLENBQUNDLE9BQU4sQ0FBZWlRLEdBQWYsQ0FBTCxFQUE0QjtBQUNsQ0EsVUFBQUEsR0FBRyxHQUFHazRELE1BQU0sQ0FBQzNuRCxHQUFQLENBQVl2USxHQUFaLEVBQWlCLFVBQVU1USxLQUFWLEVBQWtCO0FBQ3hDLG1CQUFPQSxLQUFLLElBQUksSUFBVCxHQUFnQixFQUFoQixHQUFxQkEsS0FBSyxHQUFHLEVBQXBDO0FBQ0EsV0FGSyxDQUFOO0FBR0E7O0FBRURpaEYsUUFBQUEsS0FBSyxHQUFHblksTUFBTSxDQUFDNHNCLFFBQVAsQ0FBaUIsS0FBSzcwRixJQUF0QixLQUFnQ2lvRSxNQUFNLENBQUM0c0IsUUFBUCxDQUFpQixLQUFLdnBGLFFBQUwsQ0FBYzdFLFdBQWQsRUFBakIsQ0FBeEMsQ0ExQitCLENBNEIvQjs7QUFDQSxZQUFLLENBQUMyNUUsS0FBRCxJQUFVLEVBQUcsU0FBU0EsS0FBWixDQUFWLElBQWlDQSxLQUFLLENBQUN6MEUsR0FBTixDQUFXLElBQVgsRUFBaUJvRSxHQUFqQixFQUFzQixPQUF0QixNQUFvQ3U1RCxTQUExRSxFQUFzRjtBQUNyRixlQUFLbnFFLEtBQUwsR0FBYTRRLEdBQWI7QUFDQTtBQUNELE9BaENNLENBQVA7QUFpQ0E7QUFsRWdCLEdBQWxCO0FBcUVBazRELEVBQUFBLE1BQU0sQ0FBQ2dCLE1BQVAsQ0FBZTtBQUNkNHJCLElBQUFBLFFBQVEsRUFBRTtBQUNUdlMsTUFBQUEsTUFBTSxFQUFFO0FBQ1BoeUUsUUFBQUEsR0FBRyxFQUFFLGFBQVVvNEQsSUFBVixFQUFpQjtBQUVyQixjQUFJMzRELEdBQUcsR0FBR2s0RCxNQUFNLENBQUMrSSxJQUFQLENBQVl2c0QsSUFBWixDQUFrQmlrRCxJQUFsQixFQUF3QixPQUF4QixDQUFWO0FBQ0EsaUJBQU8zNEQsR0FBRyxJQUFJLElBQVAsR0FDTkEsR0FETSxHQUdOO0FBQ0E7QUFDQTtBQUNBO0FBQ0Fra0YsVUFBQUEsZ0JBQWdCLENBQUVoc0IsTUFBTSxDQUFDSCxJQUFQLENBQWFZLElBQWIsQ0FBRixDQVBqQjtBQVFBO0FBWk0sT0FEQztBQWVUdUMsTUFBQUEsTUFBTSxFQUFFO0FBQ1AzNkQsUUFBQUEsR0FBRyxFQUFFLGFBQVVvNEQsSUFBVixFQUFpQjtBQUNyQixjQUFJdnBFLEtBQUo7QUFBQSxjQUFXbWpGLE1BQVg7QUFBQSxjQUFtQnZnRixDQUFuQjtBQUFBLGNBQ0NtbkUsT0FBTyxHQUFHUixJQUFJLENBQUNRLE9BRGhCO0FBQUEsY0FFQ3RsRCxLQUFLLEdBQUc4a0QsSUFBSSxDQUFDc00sYUFGZDtBQUFBLGNBR0NvUCxHQUFHLEdBQUcxYixJQUFJLENBQUMxb0UsSUFBTCxLQUFjLFlBSHJCO0FBQUEsY0FJQ295QixNQUFNLEdBQUdneUQsR0FBRyxHQUFHLElBQUgsR0FBVSxFQUp2QjtBQUFBLGNBS0N0K0UsR0FBRyxHQUFHcytFLEdBQUcsR0FBR3hnRSxLQUFLLEdBQUcsQ0FBWCxHQUFlc2xELE9BQU8sQ0FBQ2xuRSxNQUxqQzs7QUFPQSxjQUFLNGhCLEtBQUssR0FBRyxDQUFiLEVBQWlCO0FBQ2hCN2hCLFlBQUFBLENBQUMsR0FBRytELEdBQUo7QUFFQSxXQUhELE1BR087QUFDTi9ELFlBQUFBLENBQUMsR0FBR3FpRixHQUFHLEdBQUd4Z0UsS0FBSCxHQUFXLENBQWxCO0FBQ0EsV0Fib0IsQ0FlckI7OztBQUNBLGlCQUFRN2hCLENBQUMsR0FBRytELEdBQVosRUFBaUIvRCxDQUFDLEVBQWxCLEVBQXVCO0FBQ3RCdWdGLFlBQUFBLE1BQU0sR0FBR3BaLE9BQU8sQ0FBRW5uRSxDQUFGLENBQWhCLENBRHNCLENBR3RCO0FBQ0E7O0FBQ0EsZ0JBQUssQ0FBRXVnRixNQUFNLENBQUN2TixRQUFQLElBQW1CaHpFLENBQUMsS0FBSzZoQixLQUEzQixLQUVIO0FBQ0EsYUFBQzArRCxNQUFNLENBQUNqVSxRQUhMLEtBSUQsQ0FBQ2lVLE1BQU0sQ0FBQ2g5RSxVQUFQLENBQWtCK29FLFFBQW5CLElBQ0QsQ0FBQy9pRSxRQUFRLENBQUVnM0UsTUFBTSxDQUFDaDlFLFVBQVQsRUFBcUIsVUFBckIsQ0FMUCxDQUFMLEVBS2tEO0FBRWpEO0FBQ0FuRyxjQUFBQSxLQUFLLEdBQUc4b0UsTUFBTSxDQUFFcWEsTUFBRixDQUFOLENBQWlCdnlFLEdBQWpCLEVBQVIsQ0FIaUQsQ0FLakQ7O0FBQ0Esa0JBQUtxMEUsR0FBTCxFQUFXO0FBQ1YsdUJBQU9qbEYsS0FBUDtBQUNBLGVBUmdELENBVWpEOzs7QUFDQWl6QixjQUFBQSxNQUFNLENBQUM1dkIsSUFBUCxDQUFhckQsS0FBYjtBQUNBO0FBQ0Q7O0FBRUQsaUJBQU9pekIsTUFBUDtBQUNBLFNBM0NNO0FBNkNQem1CLFFBQUFBLEdBQUcsRUFBRSxhQUFVKzhELElBQVYsRUFBZ0J2cEUsS0FBaEIsRUFBd0I7QUFDNUIsY0FBSTIxRixTQUFKO0FBQUEsY0FBZXhTLE1BQWY7QUFBQSxjQUNDcFosT0FBTyxHQUFHUixJQUFJLENBQUNRLE9BRGhCO0FBQUEsY0FFQzkyQyxNQUFNLEdBQUc2MUMsTUFBTSxDQUFDK0IsU0FBUCxDQUFrQjdxRSxLQUFsQixDQUZWO0FBQUEsY0FHQzRDLENBQUMsR0FBR21uRSxPQUFPLENBQUNsbkUsTUFIYjs7QUFLQSxpQkFBUUQsQ0FBQyxFQUFULEVBQWM7QUFDYnVnRixZQUFBQSxNQUFNLEdBQUdwWixPQUFPLENBQUVubkUsQ0FBRixDQUFoQjtBQUVBOztBQUVBLGdCQUFLdWdGLE1BQU0sQ0FBQ3ZOLFFBQVAsR0FDSjlNLE1BQU0sQ0FBQ2lDLE9BQVAsQ0FBZ0JqQyxNQUFNLENBQUM0c0IsUUFBUCxDQUFnQnZTLE1BQWhCLENBQXVCaHlFLEdBQXZCLENBQTRCZ3lFLE1BQTVCLENBQWhCLEVBQXNEbHdELE1BQXRELElBQWlFLENBQUMsQ0FEbkUsRUFFRTtBQUNEMGlFLGNBQUFBLFNBQVMsR0FBRyxJQUFaO0FBQ0E7QUFFRDs7QUFDQSxXQWxCMkIsQ0FvQjVCOzs7QUFDQSxjQUFLLENBQUNBLFNBQU4sRUFBa0I7QUFDakJwc0IsWUFBQUEsSUFBSSxDQUFDc00sYUFBTCxHQUFxQixDQUFDLENBQXRCO0FBQ0E7O0FBQ0QsaUJBQU81aUQsTUFBUDtBQUNBO0FBdEVNO0FBZkM7QUFESSxHQUFmLEVBcHhRaUYsQ0ErMlFqRjs7QUFDQTYxQyxFQUFBQSxNQUFNLENBQUN2akIsSUFBUCxDQUFhLENBQUUsT0FBRixFQUFXLFVBQVgsQ0FBYixFQUFzQyxZQUFXO0FBQ2hEdWpCLElBQUFBLE1BQU0sQ0FBQzRzQixRQUFQLENBQWlCLElBQWpCLElBQTBCO0FBQ3pCbHBGLE1BQUFBLEdBQUcsRUFBRSxhQUFVKzhELElBQVYsRUFBZ0J2cEUsS0FBaEIsRUFBd0I7QUFDNUIsWUFBS1UsS0FBSyxDQUFDQyxPQUFOLENBQWVYLEtBQWYsQ0FBTCxFQUE4QjtBQUM3QixpQkFBU3VwRSxJQUFJLENBQUNvTSxPQUFMLEdBQWU3TSxNQUFNLENBQUNpQyxPQUFQLENBQWdCakMsTUFBTSxDQUFFUyxJQUFGLENBQU4sQ0FBZTM0RCxHQUFmLEVBQWhCLEVBQXNDNVEsS0FBdEMsSUFBZ0QsQ0FBQyxDQUF6RTtBQUNBO0FBQ0Q7QUFMd0IsS0FBMUI7O0FBT0EsUUFBSyxDQUFDZ29FLE9BQU8sQ0FBQ2dzQixPQUFkLEVBQXdCO0FBQ3ZCbHJCLE1BQUFBLE1BQU0sQ0FBQzRzQixRQUFQLENBQWlCLElBQWpCLEVBQXdCdmtGLEdBQXhCLEdBQThCLFVBQVVvNEQsSUFBVixFQUFpQjtBQUM5QyxlQUFPQSxJQUFJLENBQUN2OUQsWUFBTCxDQUFtQixPQUFuQixNQUFpQyxJQUFqQyxHQUF3QyxJQUF4QyxHQUErQ3U5RCxJQUFJLENBQUN2cEUsS0FBM0Q7QUFDQSxPQUZEO0FBR0E7QUFDRCxHQWJELEVBaDNRaUYsQ0FrNFFqRjs7QUFHQWdvRSxFQUFBQSxPQUFPLENBQUM0dEIsT0FBUixHQUFrQixlQUFlaDJGLE1BQWpDOztBQUdBLE1BQUlpMkYsV0FBVyxHQUFHLGlDQUFsQjtBQUFBLE1BQ0NDLHVCQUF1QixHQUFHLFNBQTFCQSx1QkFBMEIsQ0FBVS8wRixDQUFWLEVBQWM7QUFDdkNBLElBQUFBLENBQUMsQ0FBQzZsRixlQUFGO0FBQ0EsR0FIRjs7QUFLQTlkLEVBQUFBLE1BQU0sQ0FBQ2dCLE1BQVAsQ0FBZWhCLE1BQU0sQ0FBQ2xrRSxLQUF0QixFQUE2QjtBQUU1QnNPLElBQUFBLE9BQU8sRUFBRSxpQkFBVXRPLEtBQVYsRUFBaUJYLElBQWpCLEVBQXVCc2xFLElBQXZCLEVBQTZCd3NCLFlBQTdCLEVBQTRDO0FBRXBELFVBQUluekYsQ0FBSjtBQUFBLFVBQU84dEUsR0FBUDtBQUFBLFVBQVlzQixHQUFaO0FBQUEsVUFBaUJna0IsVUFBakI7QUFBQSxVQUE2QkMsTUFBN0I7QUFBQSxVQUFxQzlpRixNQUFyQztBQUFBLFVBQTZDcXFFLE9BQTdDO0FBQUEsVUFBc0QwWSxXQUF0RDtBQUFBLFVBQ0NDLFNBQVMsR0FBRyxDQUFFNXNCLElBQUksSUFBSXA4RCxRQUFWLENBRGI7QUFBQSxVQUVDdE0sSUFBSSxHQUFHK21FLE1BQU0sQ0FBQy83RCxJQUFQLENBQWFqSCxLQUFiLEVBQW9CLE1BQXBCLElBQStCQSxLQUFLLENBQUMvRCxJQUFyQyxHQUE0QytELEtBRnBEO0FBQUEsVUFHQzRnRixVQUFVLEdBQUc1ZCxNQUFNLENBQUMvN0QsSUFBUCxDQUFhakgsS0FBYixFQUFvQixXQUFwQixJQUFvQ0EsS0FBSyxDQUFDd3NFLFNBQU4sQ0FBZ0JwZ0UsS0FBaEIsQ0FBdUIsR0FBdkIsQ0FBcEMsR0FBbUUsRUFIakY7QUFLQTAvRCxNQUFBQSxHQUFHLEdBQUd3bEIsV0FBVyxHQUFHbGtCLEdBQUcsR0FBR3pJLElBQUksR0FBR0EsSUFBSSxJQUFJcDhELFFBQXpDLENBUG9ELENBU3BEOztBQUNBLFVBQUtvOEQsSUFBSSxDQUFDbGpFLFFBQUwsS0FBa0IsQ0FBbEIsSUFBdUJrakUsSUFBSSxDQUFDbGpFLFFBQUwsS0FBa0IsQ0FBOUMsRUFBa0Q7QUFDakQ7QUFDQSxPQVptRCxDQWNwRDs7O0FBQ0EsVUFBS3d2RixXQUFXLENBQUMzcEYsSUFBWixDQUFrQnJMLElBQUksR0FBR2lvRSxNQUFNLENBQUNsa0UsS0FBUCxDQUFhK2dGLFNBQXRDLENBQUwsRUFBeUQ7QUFDeEQ7QUFDQTs7QUFFRCxVQUFLOWtGLElBQUksQ0FBQ3dQLE9BQUwsQ0FBYyxHQUFkLElBQXNCLENBQUMsQ0FBNUIsRUFBZ0M7QUFFL0I7QUFDQW0xRSxRQUFBQSxVQUFVLEdBQUcza0YsSUFBSSxDQUFDbVEsS0FBTCxDQUFZLEdBQVosQ0FBYjtBQUNBblEsUUFBQUEsSUFBSSxHQUFHMmtGLFVBQVUsQ0FBQ2ppRSxLQUFYLEVBQVA7QUFDQWlpRSxRQUFBQSxVQUFVLENBQUMxL0MsSUFBWDtBQUNBOztBQUNEbXdELE1BQUFBLE1BQU0sR0FBR3AxRixJQUFJLENBQUN3UCxPQUFMLENBQWMsR0FBZCxJQUFzQixDQUF0QixJQUEyQixPQUFPeFAsSUFBM0MsQ0ExQm9ELENBNEJwRDs7QUFDQStELE1BQUFBLEtBQUssR0FBR0EsS0FBSyxDQUFFa2tFLE1BQU0sQ0FBQ3NCLE9BQVQsQ0FBTCxHQUNQeGxFLEtBRE8sR0FFUCxJQUFJa2tFLE1BQU0sQ0FBQ3FlLEtBQVgsQ0FBa0J0bUYsSUFBbEIsRUFBd0IsUUFBTytELEtBQVAsTUFBaUIsUUFBakIsSUFBNkJBLEtBQXJELENBRkQsQ0E3Qm9ELENBaUNwRDs7QUFDQUEsTUFBQUEsS0FBSyxDQUFDK2lGLFNBQU4sR0FBa0JvTyxZQUFZLEdBQUcsQ0FBSCxHQUFPLENBQXJDO0FBQ0FueEYsTUFBQUEsS0FBSyxDQUFDd3NFLFNBQU4sR0FBa0JvVSxVQUFVLENBQUNsK0QsSUFBWCxDQUFpQixHQUFqQixDQUFsQjtBQUNBMWlCLE1BQUFBLEtBQUssQ0FBQytoRixVQUFOLEdBQW1CL2hGLEtBQUssQ0FBQ3dzRSxTQUFOLEdBQ2xCLElBQUl2bEIsTUFBSixDQUFZLFlBQVkyNUIsVUFBVSxDQUFDbCtELElBQVgsQ0FBaUIsZUFBakIsQ0FBWixHQUFpRCxTQUE3RCxDQURrQixHQUVsQixJQUZELENBcENvRCxDQXdDcEQ7O0FBQ0ExaUIsTUFBQUEsS0FBSyxDQUFDcUUsTUFBTixHQUFla2hFLFNBQWY7O0FBQ0EsVUFBSyxDQUFDdmxFLEtBQUssQ0FBQ1MsTUFBWixFQUFxQjtBQUNwQlQsUUFBQUEsS0FBSyxDQUFDUyxNQUFOLEdBQWVra0UsSUFBZjtBQUNBLE9BNUNtRCxDQThDcEQ7OztBQUNBdGxFLE1BQUFBLElBQUksR0FBR0EsSUFBSSxJQUFJLElBQVIsR0FDTixDQUFFVyxLQUFGLENBRE0sR0FFTmtrRSxNQUFNLENBQUMrQixTQUFQLENBQWtCNW1FLElBQWxCLEVBQXdCLENBQUVXLEtBQUYsQ0FBeEIsQ0FGRCxDQS9Db0QsQ0FtRHBEOztBQUNBNDRFLE1BQUFBLE9BQU8sR0FBRzFVLE1BQU0sQ0FBQ2xrRSxLQUFQLENBQWE0NEUsT0FBYixDQUFzQjM4RSxJQUF0QixLQUFnQyxFQUExQzs7QUFDQSxVQUFLLENBQUNrMUYsWUFBRCxJQUFpQnZZLE9BQU8sQ0FBQ3RxRSxPQUF6QixJQUFvQ3NxRSxPQUFPLENBQUN0cUUsT0FBUixDQUFnQmhLLEtBQWhCLENBQXVCcWdFLElBQXZCLEVBQTZCdGxFLElBQTdCLE1BQXdDLEtBQWpGLEVBQXlGO0FBQ3hGO0FBQ0EsT0F2RG1ELENBeURwRDtBQUNBOzs7QUFDQSxVQUFLLENBQUM4eEYsWUFBRCxJQUFpQixDQUFDdlksT0FBTyxDQUFDNkosUUFBMUIsSUFBc0MsQ0FBQ2xmLFFBQVEsQ0FBRW9CLElBQUYsQ0FBcEQsRUFBK0Q7QUFFOUR5c0IsUUFBQUEsVUFBVSxHQUFHeFksT0FBTyxDQUFDb0ksWUFBUixJQUF3Qi9rRixJQUFyQzs7QUFDQSxZQUFLLENBQUNnMUYsV0FBVyxDQUFDM3BGLElBQVosQ0FBa0I4cEYsVUFBVSxHQUFHbjFGLElBQS9CLENBQU4sRUFBOEM7QUFDN0M2dkUsVUFBQUEsR0FBRyxHQUFHQSxHQUFHLENBQUN2cUUsVUFBVjtBQUNBOztBQUNELGVBQVF1cUUsR0FBUixFQUFhQSxHQUFHLEdBQUdBLEdBQUcsQ0FBQ3ZxRSxVQUF2QixFQUFvQztBQUNuQ2d3RixVQUFBQSxTQUFTLENBQUM5eUYsSUFBVixDQUFnQnF0RSxHQUFoQjtBQUNBc0IsVUFBQUEsR0FBRyxHQUFHdEIsR0FBTjtBQUNBLFNBVDZELENBVzlEOzs7QUFDQSxZQUFLc0IsR0FBRyxNQUFPekksSUFBSSxDQUFDaGhFLGFBQUwsSUFBc0I0RSxRQUE3QixDQUFSLEVBQWtEO0FBQ2pEZ3BGLFVBQUFBLFNBQVMsQ0FBQzl5RixJQUFWLENBQWdCMnVFLEdBQUcsQ0FBQ1IsV0FBSixJQUFtQlEsR0FBRyxDQUFDb2tCLFlBQXZCLElBQXVDeDJGLE1BQXZEO0FBQ0E7QUFDRCxPQTFFbUQsQ0E0RXBEOzs7QUFDQWdELE1BQUFBLENBQUMsR0FBRyxDQUFKOztBQUNBLGFBQVEsQ0FBRTh0RSxHQUFHLEdBQUd5bEIsU0FBUyxDQUFFdnpGLENBQUMsRUFBSCxDQUFqQixLQUE4QixDQUFDZ0MsS0FBSyxDQUFDNmhGLG9CQUFOLEVBQXZDLEVBQXNFO0FBQ3JFeVAsUUFBQUEsV0FBVyxHQUFHeGxCLEdBQWQ7QUFDQTlyRSxRQUFBQSxLQUFLLENBQUMvRCxJQUFOLEdBQWErQixDQUFDLEdBQUcsQ0FBSixHQUNab3pGLFVBRFksR0FFWnhZLE9BQU8sQ0FBQ3FJLFFBQVIsSUFBb0JobEYsSUFGckIsQ0FGcUUsQ0FNckU7O0FBQ0FzUyxRQUFBQSxNQUFNLEdBQUcsQ0FBRWl0RSxRQUFRLENBQUNqdkUsR0FBVCxDQUFjdS9ELEdBQWQsRUFBbUIsUUFBbkIsS0FBaUN4eUUsTUFBTSxDQUFDQyxNQUFQLENBQWUsSUFBZixDQUFuQyxFQUE0RHlHLEtBQUssQ0FBQy9ELElBQWxFLEtBQ1J1L0UsUUFBUSxDQUFDanZFLEdBQVQsQ0FBY3UvRCxHQUFkLEVBQW1CLFFBQW5CLENBREQ7O0FBRUEsWUFBS3Y5RCxNQUFMLEVBQWM7QUFDYkEsVUFBQUEsTUFBTSxDQUFDakssS0FBUCxDQUFjd25FLEdBQWQsRUFBbUJ6c0UsSUFBbkI7QUFDQSxTQVhvRSxDQWFyRTs7O0FBQ0FrUCxRQUFBQSxNQUFNLEdBQUc4aUYsTUFBTSxJQUFJdmxCLEdBQUcsQ0FBRXVsQixNQUFGLENBQXRCOztBQUNBLFlBQUs5aUYsTUFBTSxJQUFJQSxNQUFNLENBQUNqSyxLQUFqQixJQUEwQjYyRSxVQUFVLENBQUVyUCxHQUFGLENBQXpDLEVBQW1EO0FBQ2xEOXJFLFVBQUFBLEtBQUssQ0FBQ3FFLE1BQU4sR0FBZWtLLE1BQU0sQ0FBQ2pLLEtBQVAsQ0FBY3duRSxHQUFkLEVBQW1CenNFLElBQW5CLENBQWY7O0FBQ0EsY0FBS1csS0FBSyxDQUFDcUUsTUFBTixLQUFpQixLQUF0QixFQUE4QjtBQUM3QnJFLFlBQUFBLEtBQUssQ0FBQ0MsY0FBTjtBQUNBO0FBQ0Q7QUFDRDs7QUFDREQsTUFBQUEsS0FBSyxDQUFDL0QsSUFBTixHQUFhQSxJQUFiLENBcEdvRCxDQXNHcEQ7O0FBQ0EsVUFBSyxDQUFDazFGLFlBQUQsSUFBaUIsQ0FBQ254RixLQUFLLENBQUNnakYsa0JBQU4sRUFBdkIsRUFBb0Q7QUFFbkQsWUFBSyxDQUFFLENBQUNwSyxPQUFPLENBQUNpRyxRQUFULElBQ05qRyxPQUFPLENBQUNpRyxRQUFSLENBQWlCdjZFLEtBQWpCLENBQXdCaXRGLFNBQVMsQ0FBQ2puRSxHQUFWLEVBQXhCLEVBQXlDanJCLElBQXpDLE1BQW9ELEtBRGhELEtBRUo4N0UsVUFBVSxDQUFFeFcsSUFBRixDQUZYLEVBRXNCO0FBRXJCO0FBQ0E7QUFDQSxjQUFLMHNCLE1BQU0sSUFBSWh1QixVQUFVLENBQUVzQixJQUFJLENBQUUxb0UsSUFBRixDQUFOLENBQXBCLElBQXdDLENBQUNzbkUsUUFBUSxDQUFFb0IsSUFBRixDQUF0RCxFQUFpRTtBQUVoRTtBQUNBeUksWUFBQUEsR0FBRyxHQUFHekksSUFBSSxDQUFFMHNCLE1BQUYsQ0FBVjs7QUFFQSxnQkFBS2prQixHQUFMLEVBQVc7QUFDVnpJLGNBQUFBLElBQUksQ0FBRTBzQixNQUFGLENBQUosR0FBaUIsSUFBakI7QUFDQSxhQVArRCxDQVNoRTs7O0FBQ0FudEIsWUFBQUEsTUFBTSxDQUFDbGtFLEtBQVAsQ0FBYStnRixTQUFiLEdBQXlCOWtGLElBQXpCOztBQUVBLGdCQUFLK0QsS0FBSyxDQUFDNmhGLG9CQUFOLEVBQUwsRUFBb0M7QUFDbkN5UCxjQUFBQSxXQUFXLENBQUM1eEYsZ0JBQVosQ0FBOEJ6RCxJQUE5QixFQUFvQ2kxRix1QkFBcEM7QUFDQTs7QUFFRHZzQixZQUFBQSxJQUFJLENBQUUxb0UsSUFBRixDQUFKOztBQUVBLGdCQUFLK0QsS0FBSyxDQUFDNmhGLG9CQUFOLEVBQUwsRUFBb0M7QUFDbkN5UCxjQUFBQSxXQUFXLENBQUN4eEYsbUJBQVosQ0FBaUM3RCxJQUFqQyxFQUF1Q2kxRix1QkFBdkM7QUFDQTs7QUFFRGh0QixZQUFBQSxNQUFNLENBQUNsa0UsS0FBUCxDQUFhK2dGLFNBQWIsR0FBeUJ4YixTQUF6Qjs7QUFFQSxnQkFBSzZILEdBQUwsRUFBVztBQUNWekksY0FBQUEsSUFBSSxDQUFFMHNCLE1BQUYsQ0FBSixHQUFpQmprQixHQUFqQjtBQUNBO0FBQ0Q7QUFDRDtBQUNEOztBQUVELGFBQU9wdEUsS0FBSyxDQUFDcUUsTUFBYjtBQUNBLEtBakoyQjtBQW1KNUI7QUFDQTtBQUNBb3RGLElBQUFBLFFBQVEsRUFBRSxrQkFBVXgxRixJQUFWLEVBQWdCMG9FLElBQWhCLEVBQXNCM2tFLEtBQXRCLEVBQThCO0FBQ3ZDLFVBQUk3RCxDQUFDLEdBQUcrbkUsTUFBTSxDQUFDZ0IsTUFBUCxDQUNQLElBQUloQixNQUFNLENBQUNxZSxLQUFYLEVBRE8sRUFFUHZpRixLQUZPLEVBR1A7QUFDQy9ELFFBQUFBLElBQUksRUFBRUEsSUFEUDtBQUVDa25GLFFBQUFBLFdBQVcsRUFBRTtBQUZkLE9BSE8sQ0FBUjtBQVNBamYsTUFBQUEsTUFBTSxDQUFDbGtFLEtBQVAsQ0FBYXNPLE9BQWIsQ0FBc0JuUyxDQUF0QixFQUF5QixJQUF6QixFQUErQndvRSxJQUEvQjtBQUNBO0FBaEsyQixHQUE3QjtBQW9LQVQsRUFBQUEsTUFBTSxDQUFDQyxFQUFQLENBQVVlLE1BQVYsQ0FBa0I7QUFFakI1MkQsSUFBQUEsT0FBTyxFQUFFLGlCQUFVclMsSUFBVixFQUFnQm9ELElBQWhCLEVBQXVCO0FBQy9CLGFBQU8sS0FBS3NoRCxJQUFMLENBQVcsWUFBVztBQUM1QnVqQixRQUFBQSxNQUFNLENBQUNsa0UsS0FBUCxDQUFhc08sT0FBYixDQUFzQnJTLElBQXRCLEVBQTRCb0QsSUFBNUIsRUFBa0MsSUFBbEM7QUFDQSxPQUZNLENBQVA7QUFHQSxLQU5nQjtBQU9qQnF5RixJQUFBQSxjQUFjLEVBQUUsd0JBQVV6MUYsSUFBVixFQUFnQm9ELElBQWhCLEVBQXVCO0FBQ3RDLFVBQUlzbEUsSUFBSSxHQUFHLEtBQU0sQ0FBTixDQUFYOztBQUNBLFVBQUtBLElBQUwsRUFBWTtBQUNYLGVBQU9ULE1BQU0sQ0FBQ2xrRSxLQUFQLENBQWFzTyxPQUFiLENBQXNCclMsSUFBdEIsRUFBNEJvRCxJQUE1QixFQUFrQ3NsRSxJQUFsQyxFQUF3QyxJQUF4QyxDQUFQO0FBQ0E7QUFDRDtBQVpnQixHQUFsQixFQWpqUmlGLENBaWtSakY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQSxNQUFLLENBQUN2QixPQUFPLENBQUM0dEIsT0FBZCxFQUF3QjtBQUN2QjlzQixJQUFBQSxNQUFNLENBQUN2akIsSUFBUCxDQUFhO0FBQUVtakMsTUFBQUEsS0FBSyxFQUFFLFNBQVQ7QUFBb0JDLE1BQUFBLElBQUksRUFBRTtBQUExQixLQUFiLEVBQXFELFVBQVVLLElBQVYsRUFBZ0IxQyxHQUFoQixFQUFzQjtBQUUxRTtBQUNBLFVBQUkvVixPQUFPLEdBQUcsU0FBVkEsT0FBVSxDQUFVM3JFLEtBQVYsRUFBa0I7QUFDL0Jra0UsUUFBQUEsTUFBTSxDQUFDbGtFLEtBQVAsQ0FBYXl4RixRQUFiLENBQXVCL1AsR0FBdkIsRUFBNEIxaEYsS0FBSyxDQUFDUyxNQUFsQyxFQUEwQ3lqRSxNQUFNLENBQUNsa0UsS0FBUCxDQUFhMGhGLEdBQWIsQ0FBa0IxaEYsS0FBbEIsQ0FBMUM7QUFDQSxPQUZEOztBQUlBa2tFLE1BQUFBLE1BQU0sQ0FBQ2xrRSxLQUFQLENBQWE0NEUsT0FBYixDQUFzQjhJLEdBQXRCLElBQThCO0FBQzdCUCxRQUFBQSxLQUFLLEVBQUUsaUJBQVc7QUFFakI7QUFDQTtBQUNBLGNBQUl2Z0YsR0FBRyxHQUFHLEtBQUsrQyxhQUFMLElBQXNCLEtBQUs0RSxRQUEzQixJQUF1QyxJQUFqRDtBQUFBLGNBQ0NvcEYsUUFBUSxHQUFHblcsUUFBUSxDQUFDaEIsTUFBVCxDQUFpQjU1RSxHQUFqQixFQUFzQjhnRixHQUF0QixDQURaOztBQUdBLGNBQUssQ0FBQ2lRLFFBQU4sRUFBaUI7QUFDaEIvd0YsWUFBQUEsR0FBRyxDQUFDbEIsZ0JBQUosQ0FBc0Iwa0YsSUFBdEIsRUFBNEJ6WSxPQUE1QixFQUFxQyxJQUFyQztBQUNBOztBQUNENlAsVUFBQUEsUUFBUSxDQUFDaEIsTUFBVCxDQUFpQjU1RSxHQUFqQixFQUFzQjhnRixHQUF0QixFQUEyQixDQUFFaVEsUUFBUSxJQUFJLENBQWQsSUFBb0IsQ0FBL0M7QUFDQSxTQVo0QjtBQWE3QnJRLFFBQUFBLFFBQVEsRUFBRSxvQkFBVztBQUNwQixjQUFJMWdGLEdBQUcsR0FBRyxLQUFLK0MsYUFBTCxJQUFzQixLQUFLNEUsUUFBM0IsSUFBdUMsSUFBakQ7QUFBQSxjQUNDb3BGLFFBQVEsR0FBR25XLFFBQVEsQ0FBQ2hCLE1BQVQsQ0FBaUI1NUUsR0FBakIsRUFBc0I4Z0YsR0FBdEIsSUFBOEIsQ0FEMUM7O0FBR0EsY0FBSyxDQUFDaVEsUUFBTixFQUFpQjtBQUNoQi93RixZQUFBQSxHQUFHLENBQUNkLG1CQUFKLENBQXlCc2tGLElBQXpCLEVBQStCelksT0FBL0IsRUFBd0MsSUFBeEM7QUFDQTZQLFlBQUFBLFFBQVEsQ0FBQzM4RSxNQUFULENBQWlCK0IsR0FBakIsRUFBc0I4Z0YsR0FBdEI7QUFFQSxXQUpELE1BSU87QUFDTmxHLFlBQUFBLFFBQVEsQ0FBQ2hCLE1BQVQsQ0FBaUI1NUUsR0FBakIsRUFBc0I4Z0YsR0FBdEIsRUFBMkJpUSxRQUEzQjtBQUNBO0FBQ0Q7QUF4QjRCLE9BQTlCO0FBMEJBLEtBakNEO0FBa0NBOztBQUNELE1BQUlqaEIsUUFBUSxHQUFHMTFFLE1BQU0sQ0FBQzAxRSxRQUF0QjtBQUVBLE1BQUloTixLQUFLLEdBQUc7QUFBRStDLElBQUFBLElBQUksRUFBRTVwRSxJQUFJLENBQUNDLEdBQUw7QUFBUixHQUFaO0FBRUEsTUFBSTgwRixNQUFNLEdBQUssSUFBZixDQWpuUmlGLENBcW5SakY7O0FBQ0ExdEIsRUFBQUEsTUFBTSxDQUFDMnRCLFFBQVAsR0FBa0IsVUFBVXh5RixJQUFWLEVBQWlCO0FBQ2xDLFFBQUlxd0UsR0FBSixFQUFTb2lCLGVBQVQ7O0FBQ0EsUUFBSyxDQUFDenlGLElBQUQsSUFBUyxPQUFPQSxJQUFQLEtBQWdCLFFBQTlCLEVBQXlDO0FBQ3hDLGFBQU8sSUFBUDtBQUNBLEtBSmlDLENBTWxDO0FBQ0E7OztBQUNBLFFBQUk7QUFDSHF3RSxNQUFBQSxHQUFHLEdBQUssSUFBSTEwRSxNQUFNLENBQUMrMkYsU0FBWCxFQUFGLENBQTJCQyxlQUEzQixDQUE0QzN5RixJQUE1QyxFQUFrRCxVQUFsRCxDQUFOO0FBQ0EsS0FGRCxDQUVFLE9BQVFsRCxDQUFSLEVBQVksQ0FBRTs7QUFFaEIyMUYsSUFBQUEsZUFBZSxHQUFHcGlCLEdBQUcsSUFBSUEsR0FBRyxDQUFDMUUsb0JBQUosQ0FBMEIsYUFBMUIsRUFBMkMsQ0FBM0MsQ0FBekI7O0FBQ0EsUUFBSyxDQUFDMEUsR0FBRCxJQUFRb2lCLGVBQWIsRUFBK0I7QUFDOUI1dEIsTUFBQUEsTUFBTSxDQUFDakssS0FBUCxDQUFjLG1CQUNiNjNCLGVBQWUsR0FDZDV0QixNQUFNLENBQUMzbkQsR0FBUCxDQUFZdTFFLGVBQWUsQ0FBQ3RuQixVQUE1QixFQUF3QyxVQUFVLzFDLEVBQVYsRUFBZTtBQUN0RCxlQUFPQSxFQUFFLENBQUNrNkMsV0FBVjtBQUNBLE9BRkQsRUFFSWpzRCxJQUZKLENBRVUsSUFGVixDQURjLEdBSWRyakIsSUFMWSxDQUFkO0FBT0E7O0FBQ0QsV0FBT3F3RSxHQUFQO0FBQ0EsR0F2QkQ7O0FBMEJBLE1BQ0N1aUIsUUFBUSxHQUFHLE9BRFo7QUFBQSxNQUVDQyxLQUFLLEdBQUcsUUFGVDtBQUFBLE1BR0NDLGVBQWUsR0FBRyx1Q0FIbkI7QUFBQSxNQUlDQyxZQUFZLEdBQUcsb0NBSmhCOztBQU1BLFdBQVNDLFdBQVQsQ0FBc0JsSCxNQUF0QixFQUE4QjN0RixHQUE5QixFQUFtQzgwRixXQUFuQyxFQUFnRDN6RixHQUFoRCxFQUFzRDtBQUNyRCxRQUFJaWlCLElBQUo7O0FBRUEsUUFBSzlrQixLQUFLLENBQUNDLE9BQU4sQ0FBZXlCLEdBQWYsQ0FBTCxFQUE0QjtBQUUzQjtBQUNBMG1FLE1BQUFBLE1BQU0sQ0FBQ3ZqQixJQUFQLENBQWFuakQsR0FBYixFQUFrQixVQUFVUSxDQUFWLEVBQWFzd0IsQ0FBYixFQUFpQjtBQUNsQyxZQUFLZ2tFLFdBQVcsSUFBSUwsUUFBUSxDQUFDM3FGLElBQVQsQ0FBZTZqRixNQUFmLENBQXBCLEVBQThDO0FBRTdDO0FBQ0F4c0YsVUFBQUEsR0FBRyxDQUFFd3NGLE1BQUYsRUFBVTc4RCxDQUFWLENBQUg7QUFFQSxTQUxELE1BS087QUFFTjtBQUNBK2pFLFVBQUFBLFdBQVcsQ0FDVmxILE1BQU0sR0FBRyxHQUFULElBQWlCLFFBQU83OEQsQ0FBUCxNQUFhLFFBQWIsSUFBeUJBLENBQUMsSUFBSSxJQUE5QixHQUFxQ3R3QixDQUFyQyxHQUF5QyxFQUExRCxJQUFpRSxHQUR2RCxFQUVWc3dCLENBRlUsRUFHVmdrRSxXQUhVLEVBSVYzekYsR0FKVSxDQUFYO0FBTUE7QUFDRCxPQWhCRDtBQWtCQSxLQXJCRCxNQXFCTyxJQUFLLENBQUMyekYsV0FBRCxJQUFnQnJ1QixNQUFNLENBQUV6bUUsR0FBRixDQUFOLEtBQWtCLFFBQXZDLEVBQWtEO0FBRXhEO0FBQ0EsV0FBTW9qQixJQUFOLElBQWNwakIsR0FBZCxFQUFvQjtBQUNuQjYwRixRQUFBQSxXQUFXLENBQUVsSCxNQUFNLEdBQUcsR0FBVCxHQUFldnFFLElBQWYsR0FBc0IsR0FBeEIsRUFBNkJwakIsR0FBRyxDQUFFb2pCLElBQUYsQ0FBaEMsRUFBMEMweEUsV0FBMUMsRUFBdUQzekYsR0FBdkQsQ0FBWDtBQUNBO0FBRUQsS0FQTSxNQU9BO0FBRU47QUFDQUEsTUFBQUEsR0FBRyxDQUFFd3NGLE1BQUYsRUFBVTN0RixHQUFWLENBQUg7QUFDQTtBQUNELEdBMXJSZ0YsQ0E0clJqRjtBQUNBOzs7QUFDQTBtRSxFQUFBQSxNQUFNLENBQUNxdUIsS0FBUCxHQUFlLFVBQVV6ckYsQ0FBVixFQUFhd3JGLFdBQWIsRUFBMkI7QUFDekMsUUFBSW5ILE1BQUo7QUFBQSxRQUNDeG5FLENBQUMsR0FBRyxFQURMO0FBQUEsUUFFQ2hsQixHQUFHLEdBQUcsU0FBTkEsR0FBTSxDQUFVcTBCLEdBQVYsRUFBZXcvRCxlQUFmLEVBQWlDO0FBRXRDO0FBQ0EsVUFBSXAzRixLQUFLLEdBQUdpb0UsVUFBVSxDQUFFbXZCLGVBQUYsQ0FBVixHQUNYQSxlQUFlLEVBREosR0FFWEEsZUFGRDtBQUlBN3VFLE1BQUFBLENBQUMsQ0FBRUEsQ0FBQyxDQUFDMWxCLE1BQUosQ0FBRCxHQUFnQncwRixrQkFBa0IsQ0FBRXovRCxHQUFGLENBQWxCLEdBQTRCLEdBQTVCLEdBQ2Z5L0Qsa0JBQWtCLENBQUVyM0YsS0FBSyxJQUFJLElBQVQsR0FBZ0IsRUFBaEIsR0FBcUJBLEtBQXZCLENBRG5CO0FBRUEsS0FYRjs7QUFhQSxRQUFLMEwsQ0FBQyxJQUFJLElBQVYsRUFBaUI7QUFDaEIsYUFBTyxFQUFQO0FBQ0EsS0FoQndDLENBa0J6Qzs7O0FBQ0EsUUFBS2hMLEtBQUssQ0FBQ0MsT0FBTixDQUFlK0ssQ0FBZixLQUF3QkEsQ0FBQyxDQUFDczlELE1BQUYsSUFBWSxDQUFDRixNQUFNLENBQUNvQixhQUFQLENBQXNCeCtELENBQXRCLENBQTFDLEVBQXdFO0FBRXZFO0FBQ0FvOUQsTUFBQUEsTUFBTSxDQUFDdmpCLElBQVAsQ0FBYTc1QyxDQUFiLEVBQWdCLFlBQVc7QUFDMUJuSSxRQUFBQSxHQUFHLENBQUUsS0FBS2lpQixJQUFQLEVBQWEsS0FBS3hsQixLQUFsQixDQUFIO0FBQ0EsT0FGRDtBQUlBLEtBUEQsTUFPTztBQUVOO0FBQ0E7QUFDQSxXQUFNK3ZGLE1BQU4sSUFBZ0Jya0YsQ0FBaEIsRUFBb0I7QUFDbkJ1ckYsUUFBQUEsV0FBVyxDQUFFbEgsTUFBRixFQUFVcmtGLENBQUMsQ0FBRXFrRixNQUFGLENBQVgsRUFBdUJtSCxXQUF2QixFQUFvQzN6RixHQUFwQyxDQUFYO0FBQ0E7QUFDRCxLQWpDd0MsQ0FtQ3pDOzs7QUFDQSxXQUFPZ2xCLENBQUMsQ0FBQ2pCLElBQUYsQ0FBUSxHQUFSLENBQVA7QUFDQSxHQXJDRDs7QUF1Q0F3aEQsRUFBQUEsTUFBTSxDQUFDQyxFQUFQLENBQVVlLE1BQVYsQ0FBa0I7QUFDakJ3dEIsSUFBQUEsU0FBUyxFQUFFLHFCQUFXO0FBQ3JCLGFBQU94dUIsTUFBTSxDQUFDcXVCLEtBQVAsQ0FBYyxLQUFLSSxjQUFMLEVBQWQsQ0FBUDtBQUNBLEtBSGdCO0FBSWpCQSxJQUFBQSxjQUFjLEVBQUUsMEJBQVc7QUFDMUIsYUFBTyxLQUFLcDJFLEdBQUwsQ0FBVSxZQUFXO0FBRTNCO0FBQ0EsWUFBSXhlLFFBQVEsR0FBR21tRSxNQUFNLENBQUMxMUMsSUFBUCxDQUFhLElBQWIsRUFBbUIsVUFBbkIsQ0FBZjtBQUNBLGVBQU96d0IsUUFBUSxHQUFHbW1FLE1BQU0sQ0FBQytCLFNBQVAsQ0FBa0Jsb0UsUUFBbEIsQ0FBSCxHQUFrQyxJQUFqRDtBQUNBLE9BTE0sRUFLSHErQixNQUxHLENBS0ssWUFBVztBQUN0QixZQUFJbmdDLElBQUksR0FBRyxLQUFLQSxJQUFoQixDQURzQixDQUd0Qjs7QUFDQSxlQUFPLEtBQUsya0IsSUFBTCxJQUFhLENBQUNzakQsTUFBTSxDQUFFLElBQUYsQ0FBTixDQUFlNlEsRUFBZixDQUFtQixXQUFuQixDQUFkLElBQ05xZCxZQUFZLENBQUM5cUYsSUFBYixDQUFtQixLQUFLQyxRQUF4QixDQURNLElBQ2dDLENBQUM0cUYsZUFBZSxDQUFDN3FGLElBQWhCLENBQXNCckwsSUFBdEIsQ0FEakMsS0FFSixLQUFLODBFLE9BQUwsSUFBZ0IsQ0FBQ2dOLGNBQWMsQ0FBQ3oyRSxJQUFmLENBQXFCckwsSUFBckIsQ0FGYixDQUFQO0FBR0EsT0FaTSxFQVlIc2dCLEdBWkcsQ0FZRSxVQUFVc2dCLEVBQVYsRUFBYzhuQyxJQUFkLEVBQXFCO0FBQzdCLFlBQUkzNEQsR0FBRyxHQUFHazRELE1BQU0sQ0FBRSxJQUFGLENBQU4sQ0FBZWw0RCxHQUFmLEVBQVY7O0FBRUEsWUFBS0EsR0FBRyxJQUFJLElBQVosRUFBbUI7QUFDbEIsaUJBQU8sSUFBUDtBQUNBOztBQUVELFlBQUtsUSxLQUFLLENBQUNDLE9BQU4sQ0FBZWlRLEdBQWYsQ0FBTCxFQUE0QjtBQUMzQixpQkFBT2s0RCxNQUFNLENBQUMzbkQsR0FBUCxDQUFZdlEsR0FBWixFQUFpQixVQUFVQSxHQUFWLEVBQWdCO0FBQ3ZDLG1CQUFPO0FBQUU0VSxjQUFBQSxJQUFJLEVBQUUrakQsSUFBSSxDQUFDL2pELElBQWI7QUFBbUJ4bEIsY0FBQUEsS0FBSyxFQUFFNFEsR0FBRyxDQUFDM1AsT0FBSixDQUFhNjFGLEtBQWIsRUFBb0IsTUFBcEI7QUFBMUIsYUFBUDtBQUNBLFdBRk0sQ0FBUDtBQUdBOztBQUVELGVBQU87QUFBRXR4RSxVQUFBQSxJQUFJLEVBQUUrakQsSUFBSSxDQUFDL2pELElBQWI7QUFBbUJ4bEIsVUFBQUEsS0FBSyxFQUFFNFEsR0FBRyxDQUFDM1AsT0FBSixDQUFhNjFGLEtBQWIsRUFBb0IsTUFBcEI7QUFBMUIsU0FBUDtBQUNBLE9BMUJNLEVBMEJIM2xGLEdBMUJHLEVBQVA7QUEyQkE7QUFoQ2dCLEdBQWxCO0FBb0NBLE1BQ0NxbUYsR0FBRyxHQUFHLE1BRFA7QUFBQSxNQUVDQyxLQUFLLEdBQUcsTUFGVDtBQUFBLE1BR0NDLFVBQVUsR0FBRyxlQUhkO0FBQUEsTUFJQ0MsUUFBUSxHQUFHLDRCQUpaO0FBQUEsTUFNQztBQUNBQyxFQUFBQSxjQUFjLEdBQUcsMkRBUGxCO0FBQUEsTUFRQ0MsVUFBVSxHQUFHLGdCQVJkO0FBQUEsTUFTQ0MsU0FBUyxHQUFHLE9BVGI7O0FBV0M7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0MxRixFQUFBQSxVQUFVLEdBQUcsRUFwQmQ7O0FBc0JDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQzJGLEVBQUFBLFVBQVUsR0FBRyxFQTNCZDtBQUFBLE1BNkJDO0FBQ0FDLEVBQUFBLFFBQVEsR0FBRyxLQUFLcnpFLE1BQUwsQ0FBYSxHQUFiLENBOUJaO0FBQUEsTUFnQ0M7QUFDQXN6RSxFQUFBQSxZQUFZLEdBQUc5cUYsUUFBUSxDQUFDak0sYUFBVCxDQUF3QixHQUF4QixDQWpDaEI7QUFtQ0ErMkYsRUFBQUEsWUFBWSxDQUFDeGlCLElBQWIsR0FBb0JILFFBQVEsQ0FBQ0csSUFBN0IsQ0E1eVJpRixDQTh5UmpGOztBQUNBLFdBQVN5aUIsMkJBQVQsQ0FBc0NDLFNBQXRDLEVBQWtEO0FBRWpEO0FBQ0EsV0FBTyxVQUFVQyxrQkFBVixFQUE4QmoxRixJQUE5QixFQUFxQztBQUUzQyxVQUFLLE9BQU9pMUYsa0JBQVAsS0FBOEIsUUFBbkMsRUFBOEM7QUFDN0NqMUYsUUFBQUEsSUFBSSxHQUFHaTFGLGtCQUFQO0FBQ0FBLFFBQUFBLGtCQUFrQixHQUFHLEdBQXJCO0FBQ0E7O0FBRUQsVUFBSUMsUUFBSjtBQUFBLFVBQ0N6MUYsQ0FBQyxHQUFHLENBREw7QUFBQSxVQUVDMDFGLFNBQVMsR0FBR0Ysa0JBQWtCLENBQUM5d0YsV0FBbkIsR0FBaUNxZ0IsS0FBakMsQ0FBd0N3ekQsYUFBeEMsS0FBMkQsRUFGeEU7O0FBSUEsVUFBS2xULFVBQVUsQ0FBRTlrRSxJQUFGLENBQWYsRUFBMEI7QUFFekI7QUFDQSxlQUFVazFGLFFBQVEsR0FBR0MsU0FBUyxDQUFFMTFGLENBQUMsRUFBSCxDQUE5QixFQUEwQztBQUV6QztBQUNBLGNBQUt5MUYsUUFBUSxDQUFFLENBQUYsQ0FBUixLQUFrQixHQUF2QixFQUE2QjtBQUM1QkEsWUFBQUEsUUFBUSxHQUFHQSxRQUFRLENBQUM1MEUsS0FBVCxDQUFnQixDQUFoQixLQUF1QixHQUFsQztBQUNBLGFBQUUwMEUsU0FBUyxDQUFFRSxRQUFGLENBQVQsR0FBd0JGLFNBQVMsQ0FBRUUsUUFBRixDQUFULElBQXlCLEVBQW5ELEVBQXdEcG5FLE9BQXhELENBQWlFOXRCLElBQWpFLEVBRjRCLENBSTdCO0FBQ0MsV0FMRCxNQUtPO0FBQ04sYUFBRWcxRixTQUFTLENBQUVFLFFBQUYsQ0FBVCxHQUF3QkYsU0FBUyxDQUFFRSxRQUFGLENBQVQsSUFBeUIsRUFBbkQsRUFBd0RoMUYsSUFBeEQsQ0FBOERGLElBQTlEO0FBQ0E7QUFDRDtBQUNEO0FBQ0QsS0EzQkQ7QUE0QkEsR0E5MFJnRixDQWcxUmpGOzs7QUFDQSxXQUFTbzFGLDZCQUFULENBQXdDSixTQUF4QyxFQUFtRHB1QixPQUFuRCxFQUE0RHdvQixlQUE1RCxFQUE2RWlHLEtBQTdFLEVBQXFGO0FBRXBGLFFBQUlDLFNBQVMsR0FBRyxFQUFoQjtBQUFBLFFBQ0NDLGdCQUFnQixHQUFLUCxTQUFTLEtBQUtKLFVBRHBDOztBQUdBLGFBQVNZLE9BQVQsQ0FBa0JOLFFBQWxCLEVBQTZCO0FBQzVCLFVBQUl6aUIsUUFBSjtBQUNBNmlCLE1BQUFBLFNBQVMsQ0FBRUosUUFBRixDQUFULEdBQXdCLElBQXhCO0FBQ0F2dkIsTUFBQUEsTUFBTSxDQUFDdmpCLElBQVAsQ0FBYTR5QyxTQUFTLENBQUVFLFFBQUYsQ0FBVCxJQUF5QixFQUF0QyxFQUEwQyxVQUFVL2MsQ0FBVixFQUFhc2Qsa0JBQWIsRUFBa0M7QUFDM0UsWUFBSUMsbUJBQW1CLEdBQUdELGtCQUFrQixDQUFFN3VCLE9BQUYsRUFBV3dvQixlQUFYLEVBQTRCaUcsS0FBNUIsQ0FBNUM7O0FBQ0EsWUFBSyxPQUFPSyxtQkFBUCxLQUErQixRQUEvQixJQUNKLENBQUNILGdCQURHLElBQ2lCLENBQUNELFNBQVMsQ0FBRUksbUJBQUYsQ0FEaEMsRUFDMEQ7QUFFekQ5dUIsVUFBQUEsT0FBTyxDQUFDdXVCLFNBQVIsQ0FBa0JybkUsT0FBbEIsQ0FBMkI0bkUsbUJBQTNCO0FBQ0FGLFVBQUFBLE9BQU8sQ0FBRUUsbUJBQUYsQ0FBUDtBQUNBLGlCQUFPLEtBQVA7QUFDQSxTQU5ELE1BTU8sSUFBS0gsZ0JBQUwsRUFBd0I7QUFDOUIsaUJBQU8sRUFBRzlpQixRQUFRLEdBQUdpakIsbUJBQWQsQ0FBUDtBQUNBO0FBQ0QsT0FYRDtBQVlBLGFBQU9qakIsUUFBUDtBQUNBOztBQUVELFdBQU8raUIsT0FBTyxDQUFFNXVCLE9BQU8sQ0FBQ3V1QixTQUFSLENBQW1CLENBQW5CLENBQUYsQ0FBUCxJQUFxQyxDQUFDRyxTQUFTLENBQUUsR0FBRixDQUFWLElBQXFCRSxPQUFPLENBQUUsR0FBRixDQUF4RTtBQUNBLEdBejJSZ0YsQ0EyMlJqRjtBQUNBO0FBQ0E7OztBQUNBLFdBQVNHLFVBQVQsQ0FBcUJ6ekYsTUFBckIsRUFBNkJnakUsR0FBN0IsRUFBbUM7QUFDbEMsUUFBSXp3QyxHQUFKO0FBQUEsUUFBU3F5QyxJQUFUO0FBQUEsUUFDQzh1QixXQUFXLEdBQUdqd0IsTUFBTSxDQUFDa3dCLFlBQVAsQ0FBb0JELFdBQXBCLElBQW1DLEVBRGxEOztBQUdBLFNBQU1uaEUsR0FBTixJQUFheXdDLEdBQWIsRUFBbUI7QUFDbEIsVUFBS0EsR0FBRyxDQUFFendDLEdBQUYsQ0FBSCxLQUFldXlDLFNBQXBCLEVBQWdDO0FBQy9CLFNBQUU0dUIsV0FBVyxDQUFFbmhFLEdBQUYsQ0FBWCxHQUFxQnZ5QixNQUFyQixHQUFnQzRrRSxJQUFJLEtBQU1BLElBQUksR0FBRyxFQUFiLENBQXRDLEVBQTZEcnlDLEdBQTdELElBQXFFeXdDLEdBQUcsQ0FBRXp3QyxHQUFGLENBQXhFO0FBQ0E7QUFDRDs7QUFDRCxRQUFLcXlDLElBQUwsRUFBWTtBQUNYbkIsTUFBQUEsTUFBTSxDQUFDZ0IsTUFBUCxDQUFlLElBQWYsRUFBcUJ6a0UsTUFBckIsRUFBNkI0a0UsSUFBN0I7QUFDQTs7QUFFRCxXQUFPNWtFLE1BQVA7QUFDQTtBQUVEO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQSxXQUFTNHpGLG1CQUFULENBQThCMXdFLENBQTlCLEVBQWlDaXdFLEtBQWpDLEVBQXdDVSxTQUF4QyxFQUFvRDtBQUVuRCxRQUFJQyxFQUFKO0FBQUEsUUFBUXQ0RixJQUFSO0FBQUEsUUFBY3U0RixhQUFkO0FBQUEsUUFBNkJDLGFBQTdCO0FBQUEsUUFDQzdlLFFBQVEsR0FBR2p5RCxDQUFDLENBQUNpeUQsUUFEZDtBQUFBLFFBRUM4ZCxTQUFTLEdBQUcvdkUsQ0FBQyxDQUFDK3ZFLFNBRmYsQ0FGbUQsQ0FNbkQ7O0FBQ0EsV0FBUUEsU0FBUyxDQUFFLENBQUYsQ0FBVCxLQUFtQixHQUEzQixFQUFpQztBQUNoQ0EsTUFBQUEsU0FBUyxDQUFDLzBFLEtBQVY7O0FBQ0EsVUFBSzQxRSxFQUFFLEtBQUtodkIsU0FBWixFQUF3QjtBQUN2Qmd2QixRQUFBQSxFQUFFLEdBQUc1d0UsQ0FBQyxDQUFDK3dFLFFBQUYsSUFBY2QsS0FBSyxDQUFDZSxpQkFBTixDQUF5QixjQUF6QixDQUFuQjtBQUNBO0FBQ0QsS0Faa0QsQ0FjbkQ7OztBQUNBLFFBQUtKLEVBQUwsRUFBVTtBQUNULFdBQU10NEYsSUFBTixJQUFjMjVFLFFBQWQsRUFBeUI7QUFDeEIsWUFBS0EsUUFBUSxDQUFFMzVFLElBQUYsQ0FBUixJQUFvQjI1RSxRQUFRLENBQUUzNUUsSUFBRixDQUFSLENBQWlCcUwsSUFBakIsQ0FBdUJpdEYsRUFBdkIsQ0FBekIsRUFBdUQ7QUFDdERiLFVBQUFBLFNBQVMsQ0FBQ3JuRSxPQUFWLENBQW1CcHdCLElBQW5CO0FBQ0E7QUFDQTtBQUNEO0FBQ0QsS0F0QmtELENBd0JuRDs7O0FBQ0EsUUFBS3kzRixTQUFTLENBQUUsQ0FBRixDQUFULElBQWtCWSxTQUF2QixFQUFtQztBQUNsQ0UsTUFBQUEsYUFBYSxHQUFHZCxTQUFTLENBQUUsQ0FBRixDQUF6QjtBQUNBLEtBRkQsTUFFTztBQUVOO0FBQ0EsV0FBTXozRixJQUFOLElBQWNxNEYsU0FBZCxFQUEwQjtBQUN6QixZQUFLLENBQUNaLFNBQVMsQ0FBRSxDQUFGLENBQVYsSUFBbUIvdkUsQ0FBQyxDQUFDaXhFLFVBQUYsQ0FBYzM0RixJQUFJLEdBQUcsR0FBUCxHQUFheTNGLFNBQVMsQ0FBRSxDQUFGLENBQXBDLENBQXhCLEVBQXNFO0FBQ3JFYyxVQUFBQSxhQUFhLEdBQUd2NEYsSUFBaEI7QUFDQTtBQUNBOztBQUNELFlBQUssQ0FBQ3c0RixhQUFOLEVBQXNCO0FBQ3JCQSxVQUFBQSxhQUFhLEdBQUd4NEYsSUFBaEI7QUFDQTtBQUNELE9BWEssQ0FhTjs7O0FBQ0F1NEYsTUFBQUEsYUFBYSxHQUFHQSxhQUFhLElBQUlDLGFBQWpDO0FBQ0EsS0ExQ2tELENBNENuRDtBQUNBO0FBQ0E7OztBQUNBLFFBQUtELGFBQUwsRUFBcUI7QUFDcEIsVUFBS0EsYUFBYSxLQUFLZCxTQUFTLENBQUUsQ0FBRixDQUFoQyxFQUF3QztBQUN2Q0EsUUFBQUEsU0FBUyxDQUFDcm5FLE9BQVYsQ0FBbUJtb0UsYUFBbkI7QUFDQTs7QUFDRCxhQUFPRixTQUFTLENBQUVFLGFBQUYsQ0FBaEI7QUFDQTtBQUNEO0FBRUQ7QUFDQTtBQUNBOzs7QUFDQSxXQUFTSyxXQUFULENBQXNCbHhFLENBQXRCLEVBQXlCbXhFLFFBQXpCLEVBQW1DbEIsS0FBbkMsRUFBMENtQixTQUExQyxFQUFzRDtBQUNyRCxRQUFJQyxLQUFKO0FBQUEsUUFBV25uRCxPQUFYO0FBQUEsUUFBb0JvbkQsSUFBcEI7QUFBQSxRQUEwQjduQixHQUExQjtBQUFBLFFBQStCdHlCLElBQS9CO0FBQUEsUUFDQzg1QyxVQUFVLEdBQUcsRUFEZDtBQUFBLFFBR0M7QUFDQWxCLElBQUFBLFNBQVMsR0FBRy92RSxDQUFDLENBQUMrdkUsU0FBRixDQUFZNzBFLEtBQVosRUFKYixDQURxRCxDQU9yRDs7QUFDQSxRQUFLNjBFLFNBQVMsQ0FBRSxDQUFGLENBQWQsRUFBc0I7QUFDckIsV0FBTXVCLElBQU4sSUFBY3R4RSxDQUFDLENBQUNpeEUsVUFBaEIsRUFBNkI7QUFDNUJBLFFBQUFBLFVBQVUsQ0FBRUssSUFBSSxDQUFDdnlGLFdBQUwsRUFBRixDQUFWLEdBQW1DaWhCLENBQUMsQ0FBQ2l4RSxVQUFGLENBQWNLLElBQWQsQ0FBbkM7QUFDQTtBQUNEOztBQUVEcG5ELElBQUFBLE9BQU8sR0FBRzZsRCxTQUFTLENBQUMvMEUsS0FBVixFQUFWLENBZHFELENBZ0JyRDs7QUFDQSxXQUFRa3ZCLE9BQVIsRUFBa0I7QUFFakIsVUFBS2xxQixDQUFDLENBQUN1eEUsY0FBRixDQUFrQnJuRCxPQUFsQixDQUFMLEVBQW1DO0FBQ2xDK2xELFFBQUFBLEtBQUssQ0FBRWp3RSxDQUFDLENBQUN1eEUsY0FBRixDQUFrQnJuRCxPQUFsQixDQUFGLENBQUwsR0FBdUNpbkQsUUFBdkM7QUFDQSxPQUpnQixDQU1qQjs7O0FBQ0EsVUFBSyxDQUFDaDZDLElBQUQsSUFBU2k2QyxTQUFULElBQXNCcHhFLENBQUMsQ0FBQ3d4RSxVQUE3QixFQUEwQztBQUN6Q0wsUUFBQUEsUUFBUSxHQUFHbnhFLENBQUMsQ0FBQ3d4RSxVQUFGLENBQWNMLFFBQWQsRUFBd0JueEUsQ0FBQyxDQUFDOHZFLFFBQTFCLENBQVg7QUFDQTs7QUFFRDM0QyxNQUFBQSxJQUFJLEdBQUdqTixPQUFQO0FBQ0FBLE1BQUFBLE9BQU8sR0FBRzZsRCxTQUFTLENBQUMvMEUsS0FBVixFQUFWOztBQUVBLFVBQUtrdkIsT0FBTCxFQUFlO0FBRWQ7QUFDQSxZQUFLQSxPQUFPLEtBQUssR0FBakIsRUFBdUI7QUFFdEJBLFVBQUFBLE9BQU8sR0FBR2lOLElBQVYsQ0FGc0IsQ0FJdkI7QUFDQyxTQUxELE1BS08sSUFBS0EsSUFBSSxLQUFLLEdBQVQsSUFBZ0JBLElBQUksS0FBS2pOLE9BQTlCLEVBQXdDO0FBRTlDO0FBQ0FvbkQsVUFBQUEsSUFBSSxHQUFHTCxVQUFVLENBQUU5NUMsSUFBSSxHQUFHLEdBQVAsR0FBYWpOLE9BQWYsQ0FBVixJQUFzQyttRCxVQUFVLENBQUUsT0FBTy9tRCxPQUFULENBQXZELENBSDhDLENBSzlDOztBQUNBLGNBQUssQ0FBQ29uRCxJQUFOLEVBQWE7QUFDWixpQkFBTUQsS0FBTixJQUFlSixVQUFmLEVBQTRCO0FBRTNCO0FBQ0F4bkIsY0FBQUEsR0FBRyxHQUFHNG5CLEtBQUssQ0FBQzVvRixLQUFOLENBQWEsR0FBYixDQUFOOztBQUNBLGtCQUFLZ2hFLEdBQUcsQ0FBRSxDQUFGLENBQUgsS0FBYXYvQixPQUFsQixFQUE0QjtBQUUzQjtBQUNBb25ELGdCQUFBQSxJQUFJLEdBQUdMLFVBQVUsQ0FBRTk1QyxJQUFJLEdBQUcsR0FBUCxHQUFhc3lCLEdBQUcsQ0FBRSxDQUFGLENBQWxCLENBQVYsSUFDTnduQixVQUFVLENBQUUsT0FBT3huQixHQUFHLENBQUUsQ0FBRixDQUFaLENBRFg7O0FBRUEsb0JBQUs2bkIsSUFBTCxFQUFZO0FBRVg7QUFDQSxzQkFBS0EsSUFBSSxLQUFLLElBQWQsRUFBcUI7QUFDcEJBLG9CQUFBQSxJQUFJLEdBQUdMLFVBQVUsQ0FBRUksS0FBRixDQUFqQixDQURvQixDQUdyQjtBQUNDLG1CQUpELE1BSU8sSUFBS0osVUFBVSxDQUFFSSxLQUFGLENBQVYsS0FBd0IsSUFBN0IsRUFBb0M7QUFDMUNubkQsb0JBQUFBLE9BQU8sR0FBR3UvQixHQUFHLENBQUUsQ0FBRixDQUFiO0FBQ0FzbUIsb0JBQUFBLFNBQVMsQ0FBQ3JuRSxPQUFWLENBQW1CK2dELEdBQUcsQ0FBRSxDQUFGLENBQXRCO0FBQ0E7O0FBQ0Q7QUFDQTtBQUNEO0FBQ0Q7QUFDRCxXQS9CNkMsQ0FpQzlDOzs7QUFDQSxjQUFLNm5CLElBQUksS0FBSyxJQUFkLEVBQXFCO0FBRXBCO0FBQ0EsZ0JBQUtBLElBQUksSUFBSXR4RSxDQUFDLFVBQWQsRUFBd0I7QUFDdkJteEUsY0FBQUEsUUFBUSxHQUFHRyxJQUFJLENBQUVILFFBQUYsQ0FBZjtBQUNBLGFBRkQsTUFFTztBQUNOLGtCQUFJO0FBQ0hBLGdCQUFBQSxRQUFRLEdBQUdHLElBQUksQ0FBRUgsUUFBRixDQUFmO0FBQ0EsZUFGRCxDQUVFLE9BQVEzNEYsQ0FBUixFQUFZO0FBQ2IsdUJBQU87QUFDTm1xQyxrQkFBQUEsS0FBSyxFQUFFLGFBREQ7QUFFTjJ6QixrQkFBQUEsS0FBSyxFQUFFZzdCLElBQUksR0FBRzk0RixDQUFILEdBQU8sd0JBQXdCMitDLElBQXhCLEdBQStCLE1BQS9CLEdBQXdDak47QUFGcEQsaUJBQVA7QUFJQTtBQUNEO0FBQ0Q7QUFDRDtBQUNEO0FBQ0Q7O0FBRUQsV0FBTztBQUFFdkgsTUFBQUEsS0FBSyxFQUFFLFNBQVQ7QUFBb0JqbkMsTUFBQUEsSUFBSSxFQUFFeTFGO0FBQTFCLEtBQVA7QUFDQTs7QUFFRDV3QixFQUFBQSxNQUFNLENBQUNnQixNQUFQLENBQWU7QUFFZDtBQUNBa3dCLElBQUFBLE1BQU0sRUFBRSxDQUhNO0FBS2Q7QUFDQUMsSUFBQUEsWUFBWSxFQUFFLEVBTkE7QUFPZEMsSUFBQUEsSUFBSSxFQUFFLEVBUFE7QUFTZGxCLElBQUFBLFlBQVksRUFBRTtBQUNibUIsTUFBQUEsR0FBRyxFQUFFN2tCLFFBQVEsQ0FBQ0csSUFERDtBQUViNTBFLE1BQUFBLElBQUksRUFBRSxLQUZPO0FBR2J1NUYsTUFBQUEsT0FBTyxFQUFFeEMsY0FBYyxDQUFDMXJGLElBQWYsQ0FBcUJvcEUsUUFBUSxDQUFDK2tCLFFBQTlCLENBSEk7QUFJYnR6QixNQUFBQSxNQUFNLEVBQUUsSUFKSztBQUtidXpCLE1BQUFBLFdBQVcsRUFBRSxJQUxBO0FBTWJDLE1BQUFBLEtBQUssRUFBRSxJQU5NO0FBT2JDLE1BQUFBLFdBQVcsRUFBRSxrREFQQTs7QUFTYjtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUVDLE1BQUFBLE9BQU8sRUFBRTtBQUNSLGFBQUt6QyxRQURHO0FBRVJydkIsUUFBQUEsSUFBSSxFQUFFLFlBRkU7QUFHUndoQixRQUFBQSxJQUFJLEVBQUUsV0FIRTtBQUlSN1YsUUFBQUEsR0FBRyxFQUFFLDJCQUpHO0FBS1JvbUIsUUFBQUEsSUFBSSxFQUFFO0FBTEUsT0FyQkk7QUE2QmJsZ0IsTUFBQUEsUUFBUSxFQUFFO0FBQ1RsRyxRQUFBQSxHQUFHLEVBQUUsU0FESTtBQUVUNlYsUUFBQUEsSUFBSSxFQUFFLFFBRkc7QUFHVHVRLFFBQUFBLElBQUksRUFBRTtBQUhHLE9BN0JHO0FBbUNiWixNQUFBQSxjQUFjLEVBQUU7QUFDZnhsQixRQUFBQSxHQUFHLEVBQUUsYUFEVTtBQUVmM0wsUUFBQUEsSUFBSSxFQUFFLGNBRlM7QUFHZit4QixRQUFBQSxJQUFJLEVBQUU7QUFIUyxPQW5DSDtBQXlDYjtBQUNBO0FBQ0FsQixNQUFBQSxVQUFVLEVBQUU7QUFFWDtBQUNBLGtCQUFVaHJCLE1BSEM7QUFLWDtBQUNBLHFCQUFhLElBTkY7QUFRWDtBQUNBLHFCQUFhaVMsSUFBSSxDQUFDQyxLQVRQO0FBV1g7QUFDQSxvQkFBWTVYLE1BQU0sQ0FBQzJ0QjtBQVpSLE9BM0NDO0FBMERiO0FBQ0E7QUFDQTtBQUNBO0FBQ0FzQyxNQUFBQSxXQUFXLEVBQUU7QUFDWm9CLFFBQUFBLEdBQUcsRUFBRSxJQURPO0FBRVo1d0YsUUFBQUEsT0FBTyxFQUFFO0FBRkc7QUE5REEsS0FUQTtBQTZFZDtBQUNBO0FBQ0E7QUFDQW94RixJQUFBQSxTQUFTLEVBQUUsbUJBQVV0MUYsTUFBVixFQUFrQnUxRixRQUFsQixFQUE2QjtBQUN2QyxhQUFPQSxRQUFRLEdBRWQ7QUFDQTlCLE1BQUFBLFVBQVUsQ0FBRUEsVUFBVSxDQUFFenpGLE1BQUYsRUFBVXlqRSxNQUFNLENBQUNrd0IsWUFBakIsQ0FBWixFQUE2QzRCLFFBQTdDLENBSEksR0FLZDtBQUNBOUIsTUFBQUEsVUFBVSxDQUFFaHdCLE1BQU0sQ0FBQ2t3QixZQUFULEVBQXVCM3pGLE1BQXZCLENBTlg7QUFPQSxLQXhGYTtBQTBGZHcxRixJQUFBQSxhQUFhLEVBQUUzQywyQkFBMkIsQ0FBRTlGLFVBQUYsQ0ExRjVCO0FBMkZkMEksSUFBQUEsYUFBYSxFQUFFNUMsMkJBQTJCLENBQUVILFVBQUYsQ0EzRjVCO0FBNkZkO0FBQ0FnRCxJQUFBQSxJQUFJLEVBQUUsY0FBVVosR0FBVixFQUFlcHdCLE9BQWYsRUFBeUI7QUFFOUI7QUFDQSxVQUFLLFFBQU9vd0IsR0FBUCxNQUFlLFFBQXBCLEVBQStCO0FBQzlCcHdCLFFBQUFBLE9BQU8sR0FBR293QixHQUFWO0FBQ0FBLFFBQUFBLEdBQUcsR0FBR2h3QixTQUFOO0FBQ0EsT0FONkIsQ0FROUI7OztBQUNBSixNQUFBQSxPQUFPLEdBQUdBLE9BQU8sSUFBSSxFQUFyQjs7QUFFQSxVQUFJaXhCLFNBQUo7QUFBQSxVQUVDO0FBQ0FDLE1BQUFBLFFBSEQ7QUFBQSxVQUtDO0FBQ0FDLE1BQUFBLHFCQU5EO0FBQUEsVUFPQ0MsZUFQRDtBQUFBLFVBU0M7QUFDQUMsTUFBQUEsWUFWRDtBQUFBLFVBWUM7QUFDQUMsTUFBQUEsU0FiRDtBQUFBLFVBZUM7QUFDQXBjLE1BQUFBLFNBaEJEO0FBQUEsVUFrQkM7QUFDQXFjLE1BQUFBLFdBbkJEO0FBQUEsVUFxQkM7QUFDQTE0RixNQUFBQSxDQXRCRDtBQUFBLFVBd0JDO0FBQ0EyNEYsTUFBQUEsUUF6QkQ7QUFBQSxVQTJCQztBQUNBaHpFLE1BQUFBLENBQUMsR0FBR3VnRCxNQUFNLENBQUM2eEIsU0FBUCxDQUFrQixFQUFsQixFQUFzQjV3QixPQUF0QixDQTVCTDtBQUFBLFVBOEJDO0FBQ0F5eEIsTUFBQUEsZUFBZSxHQUFHanpFLENBQUMsQ0FBQ2hmLE9BQUYsSUFBYWdmLENBL0JoQztBQUFBLFVBaUNDO0FBQ0FrekUsTUFBQUEsa0JBQWtCLEdBQUdsekUsQ0FBQyxDQUFDaGYsT0FBRixLQUNsQml5RixlQUFlLENBQUNuMUYsUUFBaEIsSUFBNEJtMUYsZUFBZSxDQUFDeHlCLE1BRDFCLElBRXBCRixNQUFNLENBQUUweUIsZUFBRixDQUZjLEdBR3BCMXlCLE1BQU0sQ0FBQ2xrRSxLQXJDVDtBQUFBLFVBdUNDO0FBQ0FrNEUsTUFBQUEsUUFBUSxHQUFHaFUsTUFBTSxDQUFDNlQsUUFBUCxFQXhDWjtBQUFBLFVBeUNDK2UsZ0JBQWdCLEdBQUc1eUIsTUFBTSxDQUFDMFMsU0FBUCxDQUFrQixhQUFsQixDQXpDcEI7QUFBQSxVQTJDQztBQUNBbWdCLE1BQUFBLFdBQVUsR0FBR3B6RSxDQUFDLENBQUNvekUsVUFBRixJQUFnQixFQTVDOUI7QUFBQSxVQThDQztBQUNBQyxNQUFBQSxjQUFjLEdBQUcsRUEvQ2xCO0FBQUEsVUFnRENDLG1CQUFtQixHQUFHLEVBaER2QjtBQUFBLFVBa0RDO0FBQ0FDLE1BQUFBLFFBQVEsR0FBRyxVQW5EWjtBQUFBLFVBcURDO0FBQ0F0RCxNQUFBQSxLQUFLLEdBQUc7QUFDUHRaLFFBQUFBLFVBQVUsRUFBRSxDQURMO0FBR1A7QUFDQXFhLFFBQUFBLGlCQUFpQixFQUFFLDJCQUFVM2hFLEdBQVYsRUFBZ0I7QUFDbEMsY0FBSWpRLEtBQUo7O0FBQ0EsY0FBS3MzRCxTQUFMLEVBQWlCO0FBQ2hCLGdCQUFLLENBQUNrYyxlQUFOLEVBQXdCO0FBQ3ZCQSxjQUFBQSxlQUFlLEdBQUcsRUFBbEI7O0FBQ0EscUJBQVV4ekUsS0FBSyxHQUFHZ3dFLFFBQVEsQ0FBQ256QyxJQUFULENBQWUwMkMscUJBQWYsQ0FBbEIsRUFBNkQ7QUFDNURDLGdCQUFBQSxlQUFlLENBQUV4ekUsS0FBSyxDQUFFLENBQUYsQ0FBTCxDQUFXcmdCLFdBQVgsS0FBMkIsR0FBN0IsQ0FBZixHQUNDLENBQUU2ekYsZUFBZSxDQUFFeHpFLEtBQUssQ0FBRSxDQUFGLENBQUwsQ0FBV3JnQixXQUFYLEtBQTJCLEdBQTdCLENBQWYsSUFBcUQsRUFBdkQsRUFDRXFkLE1BREYsQ0FDVWdELEtBQUssQ0FBRSxDQUFGLENBRGYsQ0FERDtBQUdBO0FBQ0Q7O0FBQ0RBLFlBQUFBLEtBQUssR0FBR3d6RSxlQUFlLENBQUV2akUsR0FBRyxDQUFDdHdCLFdBQUosS0FBb0IsR0FBdEIsQ0FBdkI7QUFDQTs7QUFDRCxpQkFBT3FnQixLQUFLLElBQUksSUFBVCxHQUFnQixJQUFoQixHQUF1QkEsS0FBSyxDQUFDTCxJQUFOLENBQVksSUFBWixDQUE5QjtBQUNBLFNBbEJNO0FBb0JQO0FBQ0F5MEUsUUFBQUEscUJBQXFCLEVBQUUsaUNBQVc7QUFDakMsaUJBQU85YyxTQUFTLEdBQUdpYyxxQkFBSCxHQUEyQixJQUEzQztBQUNBLFNBdkJNO0FBeUJQO0FBQ0FjLFFBQUFBLGdCQUFnQixFQUFFLDBCQUFVeDJFLElBQVYsRUFBZ0J4bEIsS0FBaEIsRUFBd0I7QUFDekMsY0FBS2kvRSxTQUFTLElBQUksSUFBbEIsRUFBeUI7QUFDeEJ6NUQsWUFBQUEsSUFBSSxHQUFHcTJFLG1CQUFtQixDQUFFcjJFLElBQUksQ0FBQ2xlLFdBQUwsRUFBRixDQUFuQixHQUNOdTBGLG1CQUFtQixDQUFFcjJFLElBQUksQ0FBQ2xlLFdBQUwsRUFBRixDQUFuQixJQUE2Q2tlLElBRDlDO0FBRUFvMkUsWUFBQUEsY0FBYyxDQUFFcDJFLElBQUYsQ0FBZCxHQUF5QnhsQixLQUF6QjtBQUNBOztBQUNELGlCQUFPLElBQVA7QUFDQSxTQWpDTTtBQW1DUDtBQUNBaThGLFFBQUFBLGdCQUFnQixFQUFFLDBCQUFVcDdGLElBQVYsRUFBaUI7QUFDbEMsY0FBS28rRSxTQUFTLElBQUksSUFBbEIsRUFBeUI7QUFDeEIxMkQsWUFBQUEsQ0FBQyxDQUFDK3dFLFFBQUYsR0FBYXo0RixJQUFiO0FBQ0E7O0FBQ0QsaUJBQU8sSUFBUDtBQUNBLFNBekNNO0FBMkNQO0FBQ0E4NkYsUUFBQUEsVUFBVSxFQUFFLG9CQUFVeDZFLEdBQVYsRUFBZ0I7QUFDM0IsY0FBSXNuRCxJQUFKOztBQUNBLGNBQUt0bkQsR0FBTCxFQUFXO0FBQ1YsZ0JBQUs4OUQsU0FBTCxFQUFpQjtBQUVoQjtBQUNBdVosY0FBQUEsS0FBSyxDQUFDM2IsTUFBTixDQUFjMTdELEdBQUcsQ0FBRXEzRSxLQUFLLENBQUMwRCxNQUFSLENBQWpCO0FBQ0EsYUFKRCxNQUlPO0FBRU47QUFDQSxtQkFBTXp6QixJQUFOLElBQWN0bkQsR0FBZCxFQUFvQjtBQUNuQnc2RSxnQkFBQUEsV0FBVSxDQUFFbHpCLElBQUYsQ0FBVixHQUFxQixDQUFFa3pCLFdBQVUsQ0FBRWx6QixJQUFGLENBQVosRUFBc0J0bkQsR0FBRyxDQUFFc25ELElBQUYsQ0FBekIsQ0FBckI7QUFDQTtBQUNEO0FBQ0Q7O0FBQ0QsaUJBQU8sSUFBUDtBQUNBLFNBNURNO0FBOERQO0FBQ0EwekIsUUFBQUEsS0FBSyxFQUFFLGVBQVVDLFVBQVYsRUFBdUI7QUFDN0IsY0FBSUMsU0FBUyxHQUFHRCxVQUFVLElBQUlOLFFBQTlCOztBQUNBLGNBQUtkLFNBQUwsRUFBaUI7QUFDaEJBLFlBQUFBLFNBQVMsQ0FBQ21CLEtBQVYsQ0FBaUJFLFNBQWpCO0FBQ0E7O0FBQ0QzdkIsVUFBQUEsSUFBSSxDQUFFLENBQUYsRUFBSzJ2QixTQUFMLENBQUo7QUFDQSxpQkFBTyxJQUFQO0FBQ0E7QUF0RU0sT0F0RFQsQ0FYOEIsQ0EwSTlCOzs7QUFDQXZmLE1BQUFBLFFBQVEsQ0FBQ0wsT0FBVCxDQUFrQitiLEtBQWxCLEVBM0k4QixDQTZJOUI7QUFDQTtBQUNBOztBQUNBandFLE1BQUFBLENBQUMsQ0FBQzR4RSxHQUFGLEdBQVEsQ0FBRSxDQUFFQSxHQUFHLElBQUk1eEUsQ0FBQyxDQUFDNHhFLEdBQVQsSUFBZ0I3a0IsUUFBUSxDQUFDRyxJQUEzQixJQUFvQyxFQUF0QyxFQUNOeDBFLE9BRE0sQ0FDRzYyRixTQURILEVBQ2N4aUIsUUFBUSxDQUFDK2tCLFFBQVQsR0FBb0IsSUFEbEMsQ0FBUixDQWhKOEIsQ0FtSjlCOztBQUNBOXhFLE1BQUFBLENBQUMsQ0FBQzFuQixJQUFGLEdBQVNrcEUsT0FBTyxDQUFDeVMsTUFBUixJQUFrQnpTLE9BQU8sQ0FBQ2xwRSxJQUExQixJQUFrQzBuQixDQUFDLENBQUNpMEQsTUFBcEMsSUFBOENqMEQsQ0FBQyxDQUFDMW5CLElBQXpELENBcEo4QixDQXNKOUI7O0FBQ0EwbkIsTUFBQUEsQ0FBQyxDQUFDK3ZFLFNBQUYsR0FBYyxDQUFFL3ZFLENBQUMsQ0FBQzh2RSxRQUFGLElBQWMsR0FBaEIsRUFBc0Ivd0YsV0FBdEIsR0FBb0NxZ0IsS0FBcEMsQ0FBMkN3ekQsYUFBM0MsS0FBOEQsQ0FBRSxFQUFGLENBQTVFLENBdko4QixDQXlKOUI7O0FBQ0EsVUFBSzV5RCxDQUFDLENBQUMrekUsV0FBRixJQUFpQixJQUF0QixFQUE2QjtBQUM1QmpCLFFBQUFBLFNBQVMsR0FBR2x1RixRQUFRLENBQUNqTSxhQUFULENBQXdCLEdBQXhCLENBQVosQ0FENEIsQ0FHNUI7QUFDQTtBQUNBOztBQUNBLFlBQUk7QUFDSG02RixVQUFBQSxTQUFTLENBQUM1bEIsSUFBVixHQUFpQmx0RCxDQUFDLENBQUM0eEUsR0FBbkIsQ0FERyxDQUdIO0FBQ0E7O0FBQ0FrQixVQUFBQSxTQUFTLENBQUM1bEIsSUFBVixHQUFpQjRsQixTQUFTLENBQUM1bEIsSUFBM0I7QUFDQWx0RCxVQUFBQSxDQUFDLENBQUMrekUsV0FBRixHQUFnQnJFLFlBQVksQ0FBQ29DLFFBQWIsR0FBd0IsSUFBeEIsR0FBK0JwQyxZQUFZLENBQUN2d0YsSUFBNUMsS0FDZjJ6RixTQUFTLENBQUNoQixRQUFWLEdBQXFCLElBQXJCLEdBQTRCZ0IsU0FBUyxDQUFDM3pGLElBRHZDO0FBRUEsU0FSRCxDQVFFLE9BQVEzRyxDQUFSLEVBQVk7QUFFYjtBQUNBO0FBQ0F3bkIsVUFBQUEsQ0FBQyxDQUFDK3pFLFdBQUYsR0FBZ0IsSUFBaEI7QUFDQTtBQUNELE9BOUs2QixDQWdMOUI7OztBQUNBLFVBQUsvekUsQ0FBQyxDQUFDdGtCLElBQUYsSUFBVXNrQixDQUFDLENBQUMreEUsV0FBWixJQUEyQixPQUFPL3hFLENBQUMsQ0FBQ3RrQixJQUFULEtBQWtCLFFBQWxELEVBQTZEO0FBQzVEc2tCLFFBQUFBLENBQUMsQ0FBQ3RrQixJQUFGLEdBQVM2a0UsTUFBTSxDQUFDcXVCLEtBQVAsQ0FBYzV1RSxDQUFDLENBQUN0a0IsSUFBaEIsRUFBc0Jza0IsQ0FBQyxDQUFDMnVFLFdBQXhCLENBQVQ7QUFDQSxPQW5MNkIsQ0FxTDlCOzs7QUFDQXFCLE1BQUFBLDZCQUE2QixDQUFFbkcsVUFBRixFQUFjN3BFLENBQWQsRUFBaUJ3aEQsT0FBakIsRUFBMEJ5dUIsS0FBMUIsQ0FBN0IsQ0F0TDhCLENBd0w5Qjs7QUFDQSxVQUFLdlosU0FBTCxFQUFpQjtBQUNoQixlQUFPdVosS0FBUDtBQUNBLE9BM0w2QixDQTZMOUI7QUFDQTs7O0FBQ0E4QyxNQUFBQSxXQUFXLEdBQUd4eUIsTUFBTSxDQUFDbGtFLEtBQVAsSUFBZ0IyakIsQ0FBQyxDQUFDdytDLE1BQWhDLENBL0w4QixDQWlNOUI7O0FBQ0EsVUFBS3UwQixXQUFXLElBQUl4eUIsTUFBTSxDQUFDa3hCLE1BQVAsT0FBb0IsQ0FBeEMsRUFBNEM7QUFDM0NseEIsUUFBQUEsTUFBTSxDQUFDbGtFLEtBQVAsQ0FBYXNPLE9BQWIsQ0FBc0IsV0FBdEI7QUFDQSxPQXBNNkIsQ0FzTTlCOzs7QUFDQXFWLE1BQUFBLENBQUMsQ0FBQzFuQixJQUFGLEdBQVMwbkIsQ0FBQyxDQUFDMW5CLElBQUYsQ0FBT2l1QixXQUFQLEVBQVQsQ0F2TThCLENBeU05Qjs7QUFDQXZHLE1BQUFBLENBQUMsQ0FBQ2cwRSxVQUFGLEdBQWUsQ0FBQzFFLFVBQVUsQ0FBQzNyRixJQUFYLENBQWlCcWMsQ0FBQyxDQUFDMW5CLElBQW5CLENBQWhCLENBMU04QixDQTRNOUI7QUFDQTtBQUNBOztBQUNBbzZGLE1BQUFBLFFBQVEsR0FBRzF5RSxDQUFDLENBQUM0eEUsR0FBRixDQUFNbDVGLE9BQU4sQ0FBZXcyRixLQUFmLEVBQXNCLEVBQXRCLENBQVgsQ0EvTThCLENBaU45Qjs7QUFDQSxVQUFLLENBQUNsdkUsQ0FBQyxDQUFDZzBFLFVBQVIsRUFBcUI7QUFFcEI7QUFDQWhCLFFBQUFBLFFBQVEsR0FBR2h6RSxDQUFDLENBQUM0eEUsR0FBRixDQUFNMTJFLEtBQU4sQ0FBYXczRSxRQUFRLENBQUNwNEYsTUFBdEIsQ0FBWCxDQUhvQixDQUtwQjs7QUFDQSxZQUFLMGxCLENBQUMsQ0FBQ3RrQixJQUFGLEtBQVlza0IsQ0FBQyxDQUFDK3hFLFdBQUYsSUFBaUIsT0FBTy94RSxDQUFDLENBQUN0a0IsSUFBVCxLQUFrQixRQUEvQyxDQUFMLEVBQWlFO0FBQ2hFZzNGLFVBQUFBLFFBQVEsSUFBSSxDQUFFekUsTUFBTSxDQUFDdHFGLElBQVAsQ0FBYSt1RixRQUFiLElBQTBCLEdBQTFCLEdBQWdDLEdBQWxDLElBQTBDMXlFLENBQUMsQ0FBQ3RrQixJQUF4RCxDQURnRSxDQUdoRTs7QUFDQSxpQkFBT3NrQixDQUFDLENBQUN0a0IsSUFBVDtBQUNBLFNBWG1CLENBYXBCOzs7QUFDQSxZQUFLc2tCLENBQUMsQ0FBQ2dOLEtBQUYsS0FBWSxLQUFqQixFQUF5QjtBQUN4QjBsRSxVQUFBQSxRQUFRLEdBQUdBLFFBQVEsQ0FBQ2g2RixPQUFULENBQWtCeTJGLFVBQWxCLEVBQThCLElBQTlCLENBQVg7QUFDQTZELFVBQUFBLFFBQVEsR0FBRyxDQUFFL0UsTUFBTSxDQUFDdHFGLElBQVAsQ0FBYSt1RixRQUFiLElBQTBCLEdBQTFCLEdBQWdDLEdBQWxDLElBQTBDLElBQTFDLEdBQW1EM3lCLEtBQUssQ0FBQytDLElBQU4sRUFBbkQsR0FDVmt3QixRQUREO0FBRUEsU0FsQm1CLENBb0JwQjs7O0FBQ0FoekUsUUFBQUEsQ0FBQyxDQUFDNHhFLEdBQUYsR0FBUWMsUUFBUSxHQUFHTSxRQUFuQixDQXJCb0IsQ0F1QnJCO0FBQ0MsT0F4QkQsTUF3Qk8sSUFBS2h6RSxDQUFDLENBQUN0a0IsSUFBRixJQUFVc2tCLENBQUMsQ0FBQyt4RSxXQUFaLElBQ1gsQ0FBRS94RSxDQUFDLENBQUNpeUUsV0FBRixJQUFpQixFQUFuQixFQUF3Qm5xRixPQUF4QixDQUFpQyxtQ0FBakMsTUFBMkUsQ0FEckUsRUFDeUU7QUFDL0VrWSxRQUFBQSxDQUFDLENBQUN0a0IsSUFBRixHQUFTc2tCLENBQUMsQ0FBQ3RrQixJQUFGLENBQU9oRCxPQUFQLENBQWdCdTJGLEdBQWhCLEVBQXFCLEdBQXJCLENBQVQ7QUFDQSxPQTdPNkIsQ0ErTzlCOzs7QUFDQSxVQUFLanZFLENBQUMsQ0FBQ2kwRSxVQUFQLEVBQW9CO0FBQ25CLFlBQUsxekIsTUFBTSxDQUFDbXhCLFlBQVAsQ0FBcUJnQixRQUFyQixDQUFMLEVBQXVDO0FBQ3RDekMsVUFBQUEsS0FBSyxDQUFDd0QsZ0JBQU4sQ0FBd0IsbUJBQXhCLEVBQTZDbHpCLE1BQU0sQ0FBQ214QixZQUFQLENBQXFCZ0IsUUFBckIsQ0FBN0M7QUFDQTs7QUFDRCxZQUFLbnlCLE1BQU0sQ0FBQ294QixJQUFQLENBQWFlLFFBQWIsQ0FBTCxFQUErQjtBQUM5QnpDLFVBQUFBLEtBQUssQ0FBQ3dELGdCQUFOLENBQXdCLGVBQXhCLEVBQXlDbHpCLE1BQU0sQ0FBQ294QixJQUFQLENBQWFlLFFBQWIsQ0FBekM7QUFDQTtBQUNELE9BdlA2QixDQXlQOUI7OztBQUNBLFVBQUsxeUUsQ0FBQyxDQUFDdGtCLElBQUYsSUFBVXNrQixDQUFDLENBQUNnMEUsVUFBWixJQUEwQmgwRSxDQUFDLENBQUNpeUUsV0FBRixLQUFrQixLQUE1QyxJQUFxRHp3QixPQUFPLENBQUN5d0IsV0FBbEUsRUFBZ0Y7QUFDL0VoQyxRQUFBQSxLQUFLLENBQUN3RCxnQkFBTixDQUF3QixjQUF4QixFQUF3Q3p6RSxDQUFDLENBQUNpeUUsV0FBMUM7QUFDQSxPQTVQNkIsQ0E4UDlCOzs7QUFDQWhDLE1BQUFBLEtBQUssQ0FBQ3dELGdCQUFOLENBQ0MsUUFERCxFQUVDenpFLENBQUMsQ0FBQyt2RSxTQUFGLENBQWEsQ0FBYixLQUFvQi92RSxDQUFDLENBQUNreUUsT0FBRixDQUFXbHlFLENBQUMsQ0FBQyt2RSxTQUFGLENBQWEsQ0FBYixDQUFYLENBQXBCLEdBQ0MvdkUsQ0FBQyxDQUFDa3lFLE9BQUYsQ0FBV2x5RSxDQUFDLENBQUMrdkUsU0FBRixDQUFhLENBQWIsQ0FBWCxLQUNHL3ZFLENBQUMsQ0FBQyt2RSxTQUFGLENBQWEsQ0FBYixNQUFxQixHQUFyQixHQUEyQixPQUFPTixRQUFQLEdBQWtCLFVBQTdDLEdBQTBELEVBRDdELENBREQsR0FHQ3p2RSxDQUFDLENBQUNreUUsT0FBRixDQUFXLEdBQVgsQ0FMRixFQS9QOEIsQ0F1UTlCOztBQUNBLFdBQU03M0YsQ0FBTixJQUFXMmxCLENBQUMsQ0FBQ2swRSxPQUFiLEVBQXVCO0FBQ3RCakUsUUFBQUEsS0FBSyxDQUFDd0QsZ0JBQU4sQ0FBd0JwNUYsQ0FBeEIsRUFBMkIybEIsQ0FBQyxDQUFDazBFLE9BQUYsQ0FBVzc1RixDQUFYLENBQTNCO0FBQ0EsT0ExUTZCLENBNFE5Qjs7O0FBQ0EsVUFBSzJsQixDQUFDLENBQUNtMEUsVUFBRixLQUNGbjBFLENBQUMsQ0FBQ20wRSxVQUFGLENBQWE3d0YsSUFBYixDQUFtQjJ2RixlQUFuQixFQUFvQ2hELEtBQXBDLEVBQTJDandFLENBQTNDLE1BQW1ELEtBQW5ELElBQTREMDJELFNBRDFELENBQUwsRUFDNkU7QUFFNUU7QUFDQSxlQUFPdVosS0FBSyxDQUFDMkQsS0FBTixFQUFQO0FBQ0EsT0FsUjZCLENBb1I5Qjs7O0FBQ0FMLE1BQUFBLFFBQVEsR0FBRyxPQUFYLENBclI4QixDQXVSOUI7O0FBQ0FKLE1BQUFBLGdCQUFnQixDQUFDbjRGLEdBQWpCLENBQXNCZ2xCLENBQUMsQ0FBQ2txRSxRQUF4QjtBQUNBK0YsTUFBQUEsS0FBSyxDQUFDOXJCLElBQU4sQ0FBWW5rRCxDQUFDLENBQUNvMEUsT0FBZDtBQUNBbkUsTUFBQUEsS0FBSyxDQUFDOWIsSUFBTixDQUFZbjBELENBQUMsQ0FBQ3MyQyxLQUFkLEVBMVI4QixDQTRSOUI7O0FBQ0FtOEIsTUFBQUEsU0FBUyxHQUFHekMsNkJBQTZCLENBQUVSLFVBQUYsRUFBY3h2RSxDQUFkLEVBQWlCd2hELE9BQWpCLEVBQTBCeXVCLEtBQTFCLENBQXpDLENBN1I4QixDQStSOUI7O0FBQ0EsVUFBSyxDQUFDd0MsU0FBTixFQUFrQjtBQUNqQnR1QixRQUFBQSxJQUFJLENBQUUsQ0FBQyxDQUFILEVBQU0sY0FBTixDQUFKO0FBQ0EsT0FGRCxNQUVPO0FBQ044ckIsUUFBQUEsS0FBSyxDQUFDdFosVUFBTixHQUFtQixDQUFuQixDQURNLENBR047O0FBQ0EsWUFBS29jLFdBQUwsRUFBbUI7QUFDbEJHLFVBQUFBLGtCQUFrQixDQUFDdm9GLE9BQW5CLENBQTRCLFVBQTVCLEVBQXdDLENBQUVzbEYsS0FBRixFQUFTandFLENBQVQsQ0FBeEM7QUFDQSxTQU5LLENBUU47OztBQUNBLFlBQUswMkQsU0FBTCxFQUFpQjtBQUNoQixpQkFBT3VaLEtBQVA7QUFDQSxTQVhLLENBYU47OztBQUNBLFlBQUtqd0UsQ0FBQyxDQUFDZ3lFLEtBQUYsSUFBV2h5RSxDQUFDLENBQUN3ckUsT0FBRixHQUFZLENBQTVCLEVBQWdDO0FBQy9CcUgsVUFBQUEsWUFBWSxHQUFHeDdGLE1BQU0sQ0FBQ3c4QixVQUFQLENBQW1CLFlBQVc7QUFDNUNvOEQsWUFBQUEsS0FBSyxDQUFDMkQsS0FBTixDQUFhLFNBQWI7QUFDQSxXQUZjLEVBRVo1ekUsQ0FBQyxDQUFDd3JFLE9BRlUsQ0FBZjtBQUdBOztBQUVELFlBQUk7QUFDSDlVLFVBQUFBLFNBQVMsR0FBRyxLQUFaO0FBQ0ErYixVQUFBQSxTQUFTLENBQUM0QixJQUFWLENBQWdCaEIsY0FBaEIsRUFBZ0NsdkIsSUFBaEM7QUFDQSxTQUhELENBR0UsT0FBUTNyRSxDQUFSLEVBQVk7QUFFYjtBQUNBLGNBQUtrK0UsU0FBTCxFQUFpQjtBQUNoQixrQkFBTWwrRSxDQUFOO0FBQ0EsV0FMWSxDQU9iOzs7QUFDQTJyRSxVQUFBQSxJQUFJLENBQUUsQ0FBQyxDQUFILEVBQU0zckUsQ0FBTixDQUFKO0FBQ0E7QUFDRCxPQW5VNkIsQ0FxVTlCOzs7QUFDQSxlQUFTMnJFLElBQVQsQ0FBZXd2QixNQUFmLEVBQXVCVyxnQkFBdkIsRUFBeUMzRCxTQUF6QyxFQUFvRHVELE9BQXBELEVBQThEO0FBQzdELFlBQUk5QyxTQUFKO0FBQUEsWUFBZWdELE9BQWY7QUFBQSxZQUF3Qjk5QixLQUF4QjtBQUFBLFlBQStCNjZCLFFBQS9CO0FBQUEsWUFBeUNvRCxRQUF6QztBQUFBLFlBQ0NWLFVBQVUsR0FBR1MsZ0JBRGQsQ0FENkQsQ0FJN0Q7O0FBQ0EsWUFBSzVkLFNBQUwsRUFBaUI7QUFDaEI7QUFDQTs7QUFFREEsUUFBQUEsU0FBUyxHQUFHLElBQVosQ0FUNkQsQ0FXN0Q7O0FBQ0EsWUFBS21jLFlBQUwsRUFBb0I7QUFDbkJ4N0YsVUFBQUEsTUFBTSxDQUFDNnRELFlBQVAsQ0FBcUIydEMsWUFBckI7QUFDQSxTQWQ0RCxDQWdCN0Q7QUFDQTs7O0FBQ0FKLFFBQUFBLFNBQVMsR0FBRzd3QixTQUFaLENBbEI2RCxDQW9CN0Q7O0FBQ0Erd0IsUUFBQUEscUJBQXFCLEdBQUd1QixPQUFPLElBQUksRUFBbkMsQ0FyQjZELENBdUI3RDs7QUFDQWpFLFFBQUFBLEtBQUssQ0FBQ3RaLFVBQU4sR0FBbUJnZCxNQUFNLEdBQUcsQ0FBVCxHQUFhLENBQWIsR0FBaUIsQ0FBcEMsQ0F4QjZELENBMEI3RDs7QUFDQXZDLFFBQUFBLFNBQVMsR0FBR3VDLE1BQU0sSUFBSSxHQUFWLElBQWlCQSxNQUFNLEdBQUcsR0FBMUIsSUFBaUNBLE1BQU0sS0FBSyxHQUF4RCxDQTNCNkQsQ0E2QjdEOztBQUNBLFlBQUtoRCxTQUFMLEVBQWlCO0FBQ2hCUSxVQUFBQSxRQUFRLEdBQUdULG1CQUFtQixDQUFFMXdFLENBQUYsRUFBS2l3RSxLQUFMLEVBQVlVLFNBQVosQ0FBOUI7QUFDQSxTQWhDNEQsQ0FrQzdEOzs7QUFDQSxZQUFLLENBQUNTLFNBQUQsSUFDSjd3QixNQUFNLENBQUNpQyxPQUFQLENBQWdCLFFBQWhCLEVBQTBCeGlELENBQUMsQ0FBQyt2RSxTQUE1QixJQUEwQyxDQUFDLENBRHZDLElBRUp4dkIsTUFBTSxDQUFDaUMsT0FBUCxDQUFnQixNQUFoQixFQUF3QnhpRCxDQUFDLENBQUMrdkUsU0FBMUIsSUFBd0MsQ0FGekMsRUFFNkM7QUFDNUMvdkUsVUFBQUEsQ0FBQyxDQUFDaXhFLFVBQUYsQ0FBYyxhQUFkLElBQWdDLFlBQVcsQ0FBRSxDQUE3QztBQUNBLFNBdkM0RCxDQXlDN0Q7OztBQUNBRSxRQUFBQSxRQUFRLEdBQUdELFdBQVcsQ0FBRWx4RSxDQUFGLEVBQUtteEUsUUFBTCxFQUFlbEIsS0FBZixFQUFzQm1CLFNBQXRCLENBQXRCLENBMUM2RCxDQTRDN0Q7O0FBQ0EsWUFBS0EsU0FBTCxFQUFpQjtBQUVoQjtBQUNBLGNBQUtweEUsQ0FBQyxDQUFDaTBFLFVBQVAsRUFBb0I7QUFDbkJNLFlBQUFBLFFBQVEsR0FBR3RFLEtBQUssQ0FBQ2UsaUJBQU4sQ0FBeUIsZUFBekIsQ0FBWDs7QUFDQSxnQkFBS3VELFFBQUwsRUFBZ0I7QUFDZmgwQixjQUFBQSxNQUFNLENBQUNteEIsWUFBUCxDQUFxQmdCLFFBQXJCLElBQWtDNkIsUUFBbEM7QUFDQTs7QUFDREEsWUFBQUEsUUFBUSxHQUFHdEUsS0FBSyxDQUFDZSxpQkFBTixDQUF5QixNQUF6QixDQUFYOztBQUNBLGdCQUFLdUQsUUFBTCxFQUFnQjtBQUNmaDBCLGNBQUFBLE1BQU0sQ0FBQ294QixJQUFQLENBQWFlLFFBQWIsSUFBMEI2QixRQUExQjtBQUNBO0FBQ0QsV0FaZSxDQWNoQjs7O0FBQ0EsY0FBS1osTUFBTSxLQUFLLEdBQVgsSUFBa0IzekUsQ0FBQyxDQUFDMW5CLElBQUYsS0FBVyxNQUFsQyxFQUEyQztBQUMxQ3U3RixZQUFBQSxVQUFVLEdBQUcsV0FBYixDQUQwQyxDQUczQztBQUNDLFdBSkQsTUFJTyxJQUFLRixNQUFNLEtBQUssR0FBaEIsRUFBc0I7QUFDNUJFLFlBQUFBLFVBQVUsR0FBRyxhQUFiLENBRDRCLENBRzdCO0FBQ0MsV0FKTSxNQUlBO0FBQ05BLFlBQUFBLFVBQVUsR0FBRzFDLFFBQVEsQ0FBQ3h1RCxLQUF0QjtBQUNBeXhELFlBQUFBLE9BQU8sR0FBR2pELFFBQVEsQ0FBQ3oxRixJQUFuQjtBQUNBNDZELFlBQUFBLEtBQUssR0FBRzY2QixRQUFRLENBQUM3NkIsS0FBakI7QUFDQTg2QixZQUFBQSxTQUFTLEdBQUcsQ0FBQzk2QixLQUFiO0FBQ0E7QUFDRCxTQTdCRCxNQTZCTztBQUVOO0FBQ0FBLFVBQUFBLEtBQUssR0FBR3U5QixVQUFSOztBQUNBLGNBQUtGLE1BQU0sSUFBSSxDQUFDRSxVQUFoQixFQUE2QjtBQUM1QkEsWUFBQUEsVUFBVSxHQUFHLE9BQWI7O0FBQ0EsZ0JBQUtGLE1BQU0sR0FBRyxDQUFkLEVBQWtCO0FBQ2pCQSxjQUFBQSxNQUFNLEdBQUcsQ0FBVDtBQUNBO0FBQ0Q7QUFDRCxTQXBGNEQsQ0FzRjdEOzs7QUFDQTFELFFBQUFBLEtBQUssQ0FBQzBELE1BQU4sR0FBZUEsTUFBZjtBQUNBMUQsUUFBQUEsS0FBSyxDQUFDNEQsVUFBTixHQUFtQixDQUFFUyxnQkFBZ0IsSUFBSVQsVUFBdEIsSUFBcUMsRUFBeEQsQ0F4RjZELENBMEY3RDs7QUFDQSxZQUFLekMsU0FBTCxFQUFpQjtBQUNoQjdjLFVBQUFBLFFBQVEsQ0FBQ2UsV0FBVCxDQUFzQjJkLGVBQXRCLEVBQXVDLENBQUVtQixPQUFGLEVBQVdQLFVBQVgsRUFBdUI1RCxLQUF2QixDQUF2QztBQUNBLFNBRkQsTUFFTztBQUNOMWIsVUFBQUEsUUFBUSxDQUFDbUIsVUFBVCxDQUFxQnVkLGVBQXJCLEVBQXNDLENBQUVoRCxLQUFGLEVBQVM0RCxVQUFULEVBQXFCdjlCLEtBQXJCLENBQXRDO0FBQ0EsU0EvRjRELENBaUc3RDs7O0FBQ0EyNUIsUUFBQUEsS0FBSyxDQUFDbUQsVUFBTixDQUFrQkEsV0FBbEI7QUFDQUEsUUFBQUEsV0FBVSxHQUFHeHhCLFNBQWI7O0FBRUEsWUFBS214QixXQUFMLEVBQW1CO0FBQ2xCRyxVQUFBQSxrQkFBa0IsQ0FBQ3ZvRixPQUFuQixDQUE0QnltRixTQUFTLEdBQUcsYUFBSCxHQUFtQixXQUF4RCxFQUNDLENBQUVuQixLQUFGLEVBQVNqd0UsQ0FBVCxFQUFZb3hFLFNBQVMsR0FBR2dELE9BQUgsR0FBYTk5QixLQUFsQyxDQUREO0FBRUEsU0F4RzRELENBMEc3RDs7O0FBQ0E2OEIsUUFBQUEsZ0JBQWdCLENBQUN4ZixRQUFqQixDQUEyQnNmLGVBQTNCLEVBQTRDLENBQUVoRCxLQUFGLEVBQVM0RCxVQUFULENBQTVDOztBQUVBLFlBQUtkLFdBQUwsRUFBbUI7QUFDbEJHLFVBQUFBLGtCQUFrQixDQUFDdm9GLE9BQW5CLENBQTRCLGNBQTVCLEVBQTRDLENBQUVzbEYsS0FBRixFQUFTandFLENBQVQsQ0FBNUMsRUFEa0IsQ0FHbEI7O0FBQ0EsY0FBSyxDQUFHLEdBQUV1Z0QsTUFBTSxDQUFDa3hCLE1BQWpCLEVBQTRCO0FBQzNCbHhCLFlBQUFBLE1BQU0sQ0FBQ2xrRSxLQUFQLENBQWFzTyxPQUFiLENBQXNCLFVBQXRCO0FBQ0E7QUFDRDtBQUNEOztBQUVELGFBQU9zbEYsS0FBUDtBQUNBLEtBNWhCYTtBQThoQmR1RSxJQUFBQSxPQUFPLEVBQUUsaUJBQVU1QyxHQUFWLEVBQWVsMkYsSUFBZixFQUFxQmdDLFFBQXJCLEVBQWdDO0FBQ3hDLGFBQU82aUUsTUFBTSxDQUFDMzNELEdBQVAsQ0FBWWdwRixHQUFaLEVBQWlCbDJGLElBQWpCLEVBQXVCZ0MsUUFBdkIsRUFBaUMsTUFBakMsQ0FBUDtBQUNBLEtBaGlCYTtBQWtpQmQrMkYsSUFBQUEsU0FBUyxFQUFFLG1CQUFVN0MsR0FBVixFQUFlbDBGLFFBQWYsRUFBMEI7QUFDcEMsYUFBTzZpRSxNQUFNLENBQUMzM0QsR0FBUCxDQUFZZ3BGLEdBQVosRUFBaUJod0IsU0FBakIsRUFBNEJsa0UsUUFBNUIsRUFBc0MsUUFBdEMsQ0FBUDtBQUNBO0FBcGlCYSxHQUFmO0FBdWlCQTZpRSxFQUFBQSxNQUFNLENBQUN2akIsSUFBUCxDQUFhLENBQUUsS0FBRixFQUFTLE1BQVQsQ0FBYixFQUFnQyxVQUFVOWpCLEVBQVYsRUFBYys2QyxNQUFkLEVBQXVCO0FBQ3REMVQsSUFBQUEsTUFBTSxDQUFFMFQsTUFBRixDQUFOLEdBQW1CLFVBQVUyZCxHQUFWLEVBQWVsMkYsSUFBZixFQUFxQmdDLFFBQXJCLEVBQStCcEYsSUFBL0IsRUFBc0M7QUFFeEQ7QUFDQSxVQUFLb25FLFVBQVUsQ0FBRWhrRSxJQUFGLENBQWYsRUFBMEI7QUFDekJwRCxRQUFBQSxJQUFJLEdBQUdBLElBQUksSUFBSW9GLFFBQWY7QUFDQUEsUUFBQUEsUUFBUSxHQUFHaEMsSUFBWDtBQUNBQSxRQUFBQSxJQUFJLEdBQUdrbUUsU0FBUDtBQUNBLE9BUHVELENBU3hEOzs7QUFDQSxhQUFPckIsTUFBTSxDQUFDaXlCLElBQVAsQ0FBYWp5QixNQUFNLENBQUNnQixNQUFQLENBQWU7QUFDbENxd0IsUUFBQUEsR0FBRyxFQUFFQSxHQUQ2QjtBQUVsQ3Q1RixRQUFBQSxJQUFJLEVBQUUyN0UsTUFGNEI7QUFHbEM2YixRQUFBQSxRQUFRLEVBQUV4M0YsSUFId0I7QUFJbENvRCxRQUFBQSxJQUFJLEVBQUVBLElBSjRCO0FBS2xDMDRGLFFBQUFBLE9BQU8sRUFBRTEyRjtBQUx5QixPQUFmLEVBTWpCNmlFLE1BQU0sQ0FBQ29CLGFBQVAsQ0FBc0Jpd0IsR0FBdEIsS0FBK0JBLEdBTmQsQ0FBYixDQUFQO0FBT0EsS0FqQkQ7QUFrQkEsR0FuQkQ7QUFxQkFyeEIsRUFBQUEsTUFBTSxDQUFDK3hCLGFBQVAsQ0FBc0IsVUFBVXR5RSxDQUFWLEVBQWM7QUFDbkMsUUFBSTNsQixDQUFKOztBQUNBLFNBQU1BLENBQU4sSUFBVzJsQixDQUFDLENBQUNrMEUsT0FBYixFQUF1QjtBQUN0QixVQUFLNzVGLENBQUMsQ0FBQzBFLFdBQUYsT0FBb0IsY0FBekIsRUFBMEM7QUFDekNpaEIsUUFBQUEsQ0FBQyxDQUFDaXlFLFdBQUYsR0FBZ0JqeUUsQ0FBQyxDQUFDazBFLE9BQUYsQ0FBVzc1RixDQUFYLEtBQWtCLEVBQWxDO0FBQ0E7QUFDRDtBQUNELEdBUEQ7O0FBVUFrbUUsRUFBQUEsTUFBTSxDQUFDc2hCLFFBQVAsR0FBa0IsVUFBVStQLEdBQVYsRUFBZXB3QixPQUFmLEVBQXdCdmtFLEdBQXhCLEVBQThCO0FBQy9DLFdBQU9zakUsTUFBTSxDQUFDaXlCLElBQVAsQ0FBYTtBQUNuQlosTUFBQUEsR0FBRyxFQUFFQSxHQURjO0FBR25CO0FBQ0F0NUYsTUFBQUEsSUFBSSxFQUFFLEtBSmE7QUFLbkJ3M0YsTUFBQUEsUUFBUSxFQUFFLFFBTFM7QUFNbkI5aUUsTUFBQUEsS0FBSyxFQUFFLElBTlk7QUFPbkJnbEUsTUFBQUEsS0FBSyxFQUFFLEtBUFk7QUFRbkJ4ekIsTUFBQUEsTUFBTSxFQUFFLEtBUlc7QUFVbkI7QUFDQTtBQUNBO0FBQ0F5eUIsTUFBQUEsVUFBVSxFQUFFO0FBQ1gsdUJBQWUsc0JBQVcsQ0FBRTtBQURqQixPQWJPO0FBZ0JuQk8sTUFBQUEsVUFBVSxFQUFFLG9CQUFVTCxRQUFWLEVBQXFCO0FBQ2hDNXdCLFFBQUFBLE1BQU0sQ0FBQzZCLFVBQVAsQ0FBbUIrdUIsUUFBbkIsRUFBNkIzdkIsT0FBN0IsRUFBc0N2a0UsR0FBdEM7QUFDQTtBQWxCa0IsS0FBYixDQUFQO0FBb0JBLEdBckJEOztBQXdCQXNqRSxFQUFBQSxNQUFNLENBQUNDLEVBQVAsQ0FBVWUsTUFBVixDQUFrQjtBQUNqQm16QixJQUFBQSxPQUFPLEVBQUUsaUJBQVU5UyxJQUFWLEVBQWlCO0FBQ3pCLFVBQUk3aEUsSUFBSjs7QUFFQSxVQUFLLEtBQU0sQ0FBTixDQUFMLEVBQWlCO0FBQ2hCLFlBQUsyL0MsVUFBVSxDQUFFa2lCLElBQUYsQ0FBZixFQUEwQjtBQUN6QkEsVUFBQUEsSUFBSSxHQUFHQSxJQUFJLENBQUN0K0UsSUFBTCxDQUFXLEtBQU0sQ0FBTixDQUFYLENBQVA7QUFDQSxTQUhlLENBS2hCOzs7QUFDQXljLFFBQUFBLElBQUksR0FBR3dnRCxNQUFNLENBQUVxaEIsSUFBRixFQUFRLEtBQU0sQ0FBTixFQUFVNWhGLGFBQWxCLENBQU4sQ0FBd0NpaEUsRUFBeEMsQ0FBNEMsQ0FBNUMsRUFBZ0Q3MEMsS0FBaEQsQ0FBdUQsSUFBdkQsQ0FBUDs7QUFFQSxZQUFLLEtBQU0sQ0FBTixFQUFVeHVCLFVBQWYsRUFBNEI7QUFDM0JtaUIsVUFBQUEsSUFBSSxDQUFDUCxZQUFMLENBQW1CLEtBQU0sQ0FBTixDQUFuQjtBQUNBOztBQUVETyxRQUFBQSxJQUFJLENBQUNuSCxHQUFMLENBQVUsWUFBVztBQUNwQixjQUFJb29ELElBQUksR0FBRyxJQUFYOztBQUVBLGlCQUFRQSxJQUFJLENBQUMyekIsaUJBQWIsRUFBaUM7QUFDaEMzekIsWUFBQUEsSUFBSSxHQUFHQSxJQUFJLENBQUMyekIsaUJBQVo7QUFDQTs7QUFFRCxpQkFBTzN6QixJQUFQO0FBQ0EsU0FSRCxFQVFJc2hCLE1BUkosQ0FRWSxJQVJaO0FBU0E7O0FBRUQsYUFBTyxJQUFQO0FBQ0EsS0E1QmdCO0FBOEJqQnNTLElBQUFBLFNBQVMsRUFBRSxtQkFBVWhULElBQVYsRUFBaUI7QUFDM0IsVUFBS2xpQixVQUFVLENBQUVraUIsSUFBRixDQUFmLEVBQTBCO0FBQ3pCLGVBQU8sS0FBSzVrQyxJQUFMLENBQVcsVUFBVTNpRCxDQUFWLEVBQWM7QUFDL0JrbUUsVUFBQUEsTUFBTSxDQUFFLElBQUYsQ0FBTixDQUFlcTBCLFNBQWYsQ0FBMEJoVCxJQUFJLENBQUN0K0UsSUFBTCxDQUFXLElBQVgsRUFBaUJqSixDQUFqQixDQUExQjtBQUNBLFNBRk0sQ0FBUDtBQUdBOztBQUVELGFBQU8sS0FBSzJpRCxJQUFMLENBQVcsWUFBVztBQUM1QixZQUFJM25ELElBQUksR0FBR2tyRSxNQUFNLENBQUUsSUFBRixDQUFqQjtBQUFBLFlBQ0MwUixRQUFRLEdBQUc1OEUsSUFBSSxDQUFDNDhFLFFBQUwsRUFEWjs7QUFHQSxZQUFLQSxRQUFRLENBQUMzM0UsTUFBZCxFQUF1QjtBQUN0QjIzRSxVQUFBQSxRQUFRLENBQUN5aUIsT0FBVCxDQUFrQjlTLElBQWxCO0FBRUEsU0FIRCxNQUdPO0FBQ052c0YsVUFBQUEsSUFBSSxDQUFDaXRGLE1BQUwsQ0FBYVYsSUFBYjtBQUNBO0FBQ0QsT0FWTSxDQUFQO0FBV0EsS0FoRGdCO0FBa0RqQjdoRSxJQUFBQSxJQUFJLEVBQUUsY0FBVTZoRSxJQUFWLEVBQWlCO0FBQ3RCLFVBQUlpVCxjQUFjLEdBQUduMUIsVUFBVSxDQUFFa2lCLElBQUYsQ0FBL0I7QUFFQSxhQUFPLEtBQUs1a0MsSUFBTCxDQUFXLFVBQVUzaUQsQ0FBVixFQUFjO0FBQy9Ca21FLFFBQUFBLE1BQU0sQ0FBRSxJQUFGLENBQU4sQ0FBZW0wQixPQUFmLENBQXdCRyxjQUFjLEdBQUdqVCxJQUFJLENBQUN0K0UsSUFBTCxDQUFXLElBQVgsRUFBaUJqSixDQUFqQixDQUFILEdBQTBCdW5GLElBQWhFO0FBQ0EsT0FGTSxDQUFQO0FBR0EsS0F4RGdCO0FBMERqQmtULElBQUFBLE1BQU0sRUFBRSxnQkFBVWw0QyxRQUFWLEVBQXFCO0FBQzVCLFdBQUt4MEMsTUFBTCxDQUFhdzBDLFFBQWIsRUFBd0I4MEIsR0FBeEIsQ0FBNkIsTUFBN0IsRUFBc0MxMEIsSUFBdEMsQ0FBNEMsWUFBVztBQUN0RHVqQixRQUFBQSxNQUFNLENBQUUsSUFBRixDQUFOLENBQWVtaUIsV0FBZixDQUE0QixLQUFLN2IsVUFBakM7QUFDQSxPQUZEO0FBR0EsYUFBTyxJQUFQO0FBQ0E7QUEvRGdCLEdBQWxCOztBQW1FQXRHLEVBQUFBLE1BQU0sQ0FBQ2tLLElBQVAsQ0FBWTVGLE9BQVosQ0FBb0JsM0IsTUFBcEIsR0FBNkIsVUFBVXF6QixJQUFWLEVBQWlCO0FBQzdDLFdBQU8sQ0FBQ1QsTUFBTSxDQUFDa0ssSUFBUCxDQUFZNUYsT0FBWixDQUFvQmt3QixPQUFwQixDQUE2Qi96QixJQUE3QixDQUFSO0FBQ0EsR0FGRDs7QUFHQVQsRUFBQUEsTUFBTSxDQUFDa0ssSUFBUCxDQUFZNUYsT0FBWixDQUFvQmt3QixPQUFwQixHQUE4QixVQUFVL3pCLElBQVYsRUFBaUI7QUFDOUMsV0FBTyxDQUFDLEVBQUdBLElBQUksQ0FBQ2wxQyxXQUFMLElBQW9CazFDLElBQUksQ0FBQ2g2RCxZQUF6QixJQUF5Q2c2RCxJQUFJLENBQUMrbEIsY0FBTCxHQUFzQnpzRixNQUFsRSxDQUFSO0FBQ0EsR0FGRDs7QUFPQWltRSxFQUFBQSxNQUFNLENBQUNrd0IsWUFBUCxDQUFvQnVFLEdBQXBCLEdBQTBCLFlBQVc7QUFDcEMsUUFBSTtBQUNILGFBQU8sSUFBSTM5RixNQUFNLENBQUM0OUYsY0FBWCxFQUFQO0FBQ0EsS0FGRCxDQUVFLE9BQVF6OEYsQ0FBUixFQUFZLENBQUU7QUFDaEIsR0FKRDs7QUFNQSxNQUFJMDhGLGdCQUFnQixHQUFHO0FBRXJCO0FBQ0EsT0FBRyxHQUhrQjtBQUtyQjtBQUNBO0FBQ0EsVUFBTTtBQVBlLEdBQXZCO0FBQUEsTUFTQ0MsWUFBWSxHQUFHNTBCLE1BQU0sQ0FBQ2t3QixZQUFQLENBQW9CdUUsR0FBcEIsRUFUaEI7QUFXQXYxQixFQUFBQSxPQUFPLENBQUMyMUIsSUFBUixHQUFlLENBQUMsQ0FBQ0QsWUFBRixJQUFvQixxQkFBcUJBLFlBQXhEO0FBQ0ExMUIsRUFBQUEsT0FBTyxDQUFDK3lCLElBQVIsR0FBZTJDLFlBQVksR0FBRyxDQUFDLENBQUNBLFlBQWhDO0FBRUE1MEIsRUFBQUEsTUFBTSxDQUFDZ3lCLGFBQVAsQ0FBc0IsVUFBVS93QixPQUFWLEVBQW9CO0FBQ3pDLFFBQUk5akUsU0FBSixFQUFjMjNGLGFBQWQsQ0FEeUMsQ0FHekM7OztBQUNBLFFBQUs1MUIsT0FBTyxDQUFDMjFCLElBQVIsSUFBZ0JELFlBQVksSUFBSSxDQUFDM3pCLE9BQU8sQ0FBQ3V5QixXQUE5QyxFQUE0RDtBQUMzRCxhQUFPO0FBQ05NLFFBQUFBLElBQUksRUFBRSxjQUFVSCxPQUFWLEVBQW1CaEssUUFBbkIsRUFBOEI7QUFDbkMsY0FBSTd2RixDQUFKO0FBQUEsY0FDQzI2RixHQUFHLEdBQUd4ekIsT0FBTyxDQUFDd3pCLEdBQVIsRUFEUDtBQUdBQSxVQUFBQSxHQUFHLENBQUNsdkMsSUFBSixDQUNDMGIsT0FBTyxDQUFDbHBFLElBRFQsRUFFQ2twRSxPQUFPLENBQUNvd0IsR0FGVCxFQUdDcHdCLE9BQU8sQ0FBQ3d3QixLQUhULEVBSUN4d0IsT0FBTyxDQUFDOHpCLFFBSlQsRUFLQzl6QixPQUFPLENBQUNtTSxRQUxULEVBSm1DLENBWW5DOztBQUNBLGNBQUtuTSxPQUFPLENBQUMrekIsU0FBYixFQUF5QjtBQUN4QixpQkFBTWw3RixDQUFOLElBQVdtbkUsT0FBTyxDQUFDK3pCLFNBQW5CLEVBQStCO0FBQzlCUCxjQUFBQSxHQUFHLENBQUUzNkYsQ0FBRixDQUFILEdBQVdtbkUsT0FBTyxDQUFDK3pCLFNBQVIsQ0FBbUJsN0YsQ0FBbkIsQ0FBWDtBQUNBO0FBQ0QsV0FqQmtDLENBbUJuQzs7O0FBQ0EsY0FBS21uRSxPQUFPLENBQUN1dkIsUUFBUixJQUFvQmlFLEdBQUcsQ0FBQ3RCLGdCQUE3QixFQUFnRDtBQUMvQ3NCLFlBQUFBLEdBQUcsQ0FBQ3RCLGdCQUFKLENBQXNCbHlCLE9BQU8sQ0FBQ3V2QixRQUE5QjtBQUNBLFdBdEJrQyxDQXdCbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0EsY0FBSyxDQUFDdnZCLE9BQU8sQ0FBQ3V5QixXQUFULElBQXdCLENBQUNHLE9BQU8sQ0FBRSxrQkFBRixDQUFyQyxFQUE4RDtBQUM3REEsWUFBQUEsT0FBTyxDQUFFLGtCQUFGLENBQVAsR0FBZ0MsZ0JBQWhDO0FBQ0EsV0EvQmtDLENBaUNuQzs7O0FBQ0EsZUFBTTc1RixDQUFOLElBQVc2NUYsT0FBWCxFQUFxQjtBQUNwQmMsWUFBQUEsR0FBRyxDQUFDdkIsZ0JBQUosQ0FBc0JwNUYsQ0FBdEIsRUFBeUI2NUYsT0FBTyxDQUFFNzVGLENBQUYsQ0FBaEM7QUFDQSxXQXBDa0MsQ0FzQ25DOzs7QUFDQXFELFVBQUFBLFNBQVEsR0FBRyxrQkFBVXBGLElBQVYsRUFBaUI7QUFDM0IsbUJBQU8sWUFBVztBQUNqQixrQkFBS29GLFNBQUwsRUFBZ0I7QUFDZkEsZ0JBQUFBLFNBQVEsR0FBRzIzRixhQUFhLEdBQUdMLEdBQUcsQ0FBQ1EsTUFBSixHQUMxQlIsR0FBRyxDQUFDUyxPQUFKLEdBQWNULEdBQUcsQ0FBQ1UsT0FBSixHQUFjVixHQUFHLENBQUNXLFNBQUosR0FDM0JYLEdBQUcsQ0FBQ1ksa0JBQUosR0FBeUIsSUFGM0I7O0FBSUEsb0JBQUt0OUYsSUFBSSxLQUFLLE9BQWQsRUFBd0I7QUFDdkIwOEYsa0JBQUFBLEdBQUcsQ0FBQ3BCLEtBQUo7QUFDQSxpQkFGRCxNQUVPLElBQUt0N0YsSUFBSSxLQUFLLE9BQWQsRUFBd0I7QUFFOUI7QUFDQTtBQUNBO0FBQ0Esc0JBQUssT0FBTzA4RixHQUFHLENBQUNyQixNQUFYLEtBQXNCLFFBQTNCLEVBQXNDO0FBQ3JDekosb0JBQUFBLFFBQVEsQ0FBRSxDQUFGLEVBQUssT0FBTCxDQUFSO0FBQ0EsbUJBRkQsTUFFTztBQUNOQSxvQkFBQUEsUUFBUSxFQUVQO0FBQ0E4SyxvQkFBQUEsR0FBRyxDQUFDckIsTUFIRyxFQUlQcUIsR0FBRyxDQUFDbkIsVUFKRyxDQUFSO0FBTUE7QUFDRCxpQkFmTSxNQWVBO0FBQ04zSixrQkFBQUEsUUFBUSxDQUNQZ0wsZ0JBQWdCLENBQUVGLEdBQUcsQ0FBQ3JCLE1BQU4sQ0FBaEIsSUFBa0NxQixHQUFHLENBQUNyQixNQUQvQixFQUVQcUIsR0FBRyxDQUFDbkIsVUFGRyxFQUlQO0FBQ0E7QUFDQTtBQUNBLG1CQUFFbUIsR0FBRyxDQUFDYSxZQUFKLElBQW9CLE1BQXRCLE1BQW1DLE1BQW5DLElBQ0EsT0FBT2IsR0FBRyxDQUFDYyxZQUFYLEtBQTRCLFFBRDVCLEdBRUM7QUFBRUMsb0JBQUFBLE1BQU0sRUFBRWYsR0FBRyxDQUFDN0Q7QUFBZCxtQkFGRCxHQUdDO0FBQUUvd0Isb0JBQUFBLElBQUksRUFBRTQwQixHQUFHLENBQUNjO0FBQVosbUJBVk0sRUFXUGQsR0FBRyxDQUFDeEIscUJBQUosRUFYTyxDQUFSO0FBYUE7QUFDRDtBQUNELGFBdkNEO0FBd0NBLFdBekNELENBdkNtQyxDQWtGbkM7OztBQUNBd0IsVUFBQUEsR0FBRyxDQUFDUSxNQUFKLEdBQWE5M0YsU0FBUSxFQUFyQjtBQUNBMjNGLFVBQUFBLGFBQWEsR0FBR0wsR0FBRyxDQUFDUyxPQUFKLEdBQWNULEdBQUcsQ0FBQ1csU0FBSixHQUFnQmo0RixTQUFRLENBQUUsT0FBRixDQUF0RCxDQXBGbUMsQ0FzRm5DO0FBQ0E7QUFDQTs7QUFDQSxjQUFLczNGLEdBQUcsQ0FBQ1UsT0FBSixLQUFnQjl6QixTQUFyQixFQUFpQztBQUNoQ296QixZQUFBQSxHQUFHLENBQUNVLE9BQUosR0FBY0wsYUFBZDtBQUNBLFdBRkQsTUFFTztBQUNOTCxZQUFBQSxHQUFHLENBQUNZLGtCQUFKLEdBQXlCLFlBQVc7QUFFbkM7QUFDQSxrQkFBS1osR0FBRyxDQUFDcmUsVUFBSixLQUFtQixDQUF4QixFQUE0QjtBQUUzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBdC9FLGdCQUFBQSxNQUFNLENBQUN3OEIsVUFBUCxDQUFtQixZQUFXO0FBQzdCLHNCQUFLbjJCLFNBQUwsRUFBZ0I7QUFDZjIzRixvQkFBQUEsYUFBYTtBQUNiO0FBQ0QsaUJBSkQ7QUFLQTtBQUNELGFBZkQ7QUFnQkEsV0E1R2tDLENBOEduQzs7O0FBQ0EzM0YsVUFBQUEsU0FBUSxHQUFHQSxTQUFRLENBQUUsT0FBRixDQUFuQjs7QUFFQSxjQUFJO0FBRUg7QUFDQXMzRixZQUFBQSxHQUFHLENBQUNYLElBQUosQ0FBVTd5QixPQUFPLENBQUN3eUIsVUFBUixJQUFzQnh5QixPQUFPLENBQUM5bEUsSUFBOUIsSUFBc0MsSUFBaEQ7QUFDQSxXQUpELENBSUUsT0FBUWxELENBQVIsRUFBWTtBQUViO0FBQ0EsZ0JBQUtrRixTQUFMLEVBQWdCO0FBQ2Ysb0JBQU1sRixDQUFOO0FBQ0E7QUFDRDtBQUNELFNBN0hLO0FBK0hObzdGLFFBQUFBLEtBQUssRUFBRSxpQkFBVztBQUNqQixjQUFLbDJGLFNBQUwsRUFBZ0I7QUFDZkEsWUFBQUEsU0FBUTtBQUNSO0FBQ0Q7QUFuSUssT0FBUDtBQXFJQTtBQUNELEdBM0lELEVBM3RUaUYsQ0EyMlRqRjs7QUFDQTZpRSxFQUFBQSxNQUFNLENBQUMreEIsYUFBUCxDQUFzQixVQUFVdHlFLENBQVYsRUFBYztBQUNuQyxRQUFLQSxDQUFDLENBQUMrekUsV0FBUCxFQUFxQjtBQUNwQi96RSxNQUFBQSxDQUFDLENBQUNpeUQsUUFBRixDQUFXOVIsTUFBWCxHQUFvQixLQUFwQjtBQUNBO0FBQ0QsR0FKRCxFQTUyVGlGLENBazNUakY7O0FBQ0FJLEVBQUFBLE1BQU0sQ0FBQzZ4QixTQUFQLENBQWtCO0FBQ2pCRixJQUFBQSxPQUFPLEVBQUU7QUFDUi94QixNQUFBQSxNQUFNLEVBQUUsOENBQ1A7QUFGTyxLQURRO0FBS2pCOFIsSUFBQUEsUUFBUSxFQUFFO0FBQ1Q5UixNQUFBQSxNQUFNLEVBQUU7QUFEQyxLQUxPO0FBUWpCOHdCLElBQUFBLFVBQVUsRUFBRTtBQUNYLHFCQUFlLG9CQUFVN3dCLElBQVYsRUFBaUI7QUFDL0JHLFFBQUFBLE1BQU0sQ0FBQzZCLFVBQVAsQ0FBbUJoQyxJQUFuQjtBQUNBLGVBQU9BLElBQVA7QUFDQTtBQUpVO0FBUkssR0FBbEIsRUFuM1RpRixDQW00VGpGOztBQUNBRyxFQUFBQSxNQUFNLENBQUMreEIsYUFBUCxDQUFzQixRQUF0QixFQUFnQyxVQUFVdHlFLENBQVYsRUFBYztBQUM3QyxRQUFLQSxDQUFDLENBQUNnTixLQUFGLEtBQVk0MEMsU0FBakIsRUFBNkI7QUFDNUI1aEQsTUFBQUEsQ0FBQyxDQUFDZ04sS0FBRixHQUFVLEtBQVY7QUFDQTs7QUFDRCxRQUFLaE4sQ0FBQyxDQUFDK3pFLFdBQVAsRUFBcUI7QUFDcEIvekUsTUFBQUEsQ0FBQyxDQUFDMW5CLElBQUYsR0FBUyxLQUFUO0FBQ0E7QUFDRCxHQVBELEVBcDRUaUYsQ0E2NFRqRjs7QUFDQWlvRSxFQUFBQSxNQUFNLENBQUNneUIsYUFBUCxDQUFzQixRQUF0QixFQUFnQyxVQUFVdnlFLENBQVYsRUFBYztBQUU3QztBQUNBLFFBQUtBLENBQUMsQ0FBQyt6RSxXQUFGLElBQWlCL3pFLENBQUMsQ0FBQ2cyRSxXQUF4QixFQUFzQztBQUNyQyxVQUFJNzFCLE1BQUosRUFBWXppRSxVQUFaOztBQUNBLGFBQU87QUFDTjIyRixRQUFBQSxJQUFJLEVBQUUsY0FBVXRoQixDQUFWLEVBQWFtWCxRQUFiLEVBQXdCO0FBQzdCL3BCLFVBQUFBLE1BQU0sR0FBR0ksTUFBTSxDQUFFLFVBQUYsQ0FBTixDQUNQeGpELElBRE8sQ0FDRGlELENBQUMsQ0FBQ2cyRSxXQUFGLElBQWlCLEVBRGhCLEVBRVBuckUsSUFGTyxDQUVEO0FBQUVvckUsWUFBQUEsT0FBTyxFQUFFajJFLENBQUMsQ0FBQ2syRSxhQUFiO0FBQTRCcDJCLFlBQUFBLEdBQUcsRUFBRTkvQyxDQUFDLENBQUM0eEU7QUFBbkMsV0FGQyxFQUdQblYsRUFITyxDQUdILFlBSEcsRUFHVy8rRSxVQUFRLEdBQUcsa0JBQVV5NEYsR0FBVixFQUFnQjtBQUM3Q2gyQixZQUFBQSxNQUFNLENBQUNqbEUsTUFBUDtBQUNBd0MsWUFBQUEsVUFBUSxHQUFHLElBQVg7O0FBQ0EsZ0JBQUt5NEYsR0FBTCxFQUFXO0FBQ1ZqTSxjQUFBQSxRQUFRLENBQUVpTSxHQUFHLENBQUM3OUYsSUFBSixLQUFhLE9BQWIsR0FBdUIsR0FBdkIsR0FBNkIsR0FBL0IsRUFBb0M2OUYsR0FBRyxDQUFDNzlGLElBQXhDLENBQVI7QUFDQTtBQUNELFdBVE8sQ0FBVCxDQUQ2QixDQVk3Qjs7QUFDQXNNLFVBQUFBLFFBQVEsQ0FBQ3k3RCxJQUFULENBQWMxNUQsV0FBZCxDQUEyQnc1RCxNQUFNLENBQUUsQ0FBRixDQUFqQztBQUNBLFNBZks7QUFnQk55ekIsUUFBQUEsS0FBSyxFQUFFLGlCQUFXO0FBQ2pCLGNBQUtsMkYsVUFBTCxFQUFnQjtBQUNmQSxZQUFBQSxVQUFRO0FBQ1I7QUFDRDtBQXBCSyxPQUFQO0FBc0JBO0FBQ0QsR0E1QkQ7QUFpQ0EsTUFBSTA0RixZQUFZLEdBQUcsRUFBbkI7QUFBQSxNQUNDQyxNQUFNLEdBQUcsbUJBRFYsQ0EvNlRpRixDQWs3VGpGOztBQUNBOTFCLEVBQUFBLE1BQU0sQ0FBQzZ4QixTQUFQLENBQWtCO0FBQ2pCa0UsSUFBQUEsS0FBSyxFQUFFLFVBRFU7QUFFakJDLElBQUFBLGFBQWEsRUFBRSx5QkFBVztBQUN6QixVQUFJNzRGLFFBQVEsR0FBRzA0RixZQUFZLENBQUN6dkUsR0FBYixNQUF3QjQ1QyxNQUFNLENBQUNzQixPQUFQLEdBQWlCLEdBQWpCLEdBQXlCOUIsS0FBSyxDQUFDK0MsSUFBTixFQUFoRTtBQUNBLFdBQU1wbEUsUUFBTixJQUFtQixJQUFuQjtBQUNBLGFBQU9BLFFBQVA7QUFDQTtBQU5nQixHQUFsQixFQW43VGlGLENBNDdUakY7O0FBQ0E2aUUsRUFBQUEsTUFBTSxDQUFDK3hCLGFBQVAsQ0FBc0IsWUFBdEIsRUFBb0MsVUFBVXR5RSxDQUFWLEVBQWF3MkUsZ0JBQWIsRUFBK0J2RyxLQUEvQixFQUF1QztBQUUxRSxRQUFJM3ZGLFlBQUo7QUFBQSxRQUFrQm91RCxXQUFsQjtBQUFBLFFBQStCK25DLGlCQUEvQjtBQUFBLFFBQ0NDLFFBQVEsR0FBRzEyRSxDQUFDLENBQUNzMkUsS0FBRixLQUFZLEtBQVosS0FBdUJELE1BQU0sQ0FBQzF5RixJQUFQLENBQWFxYyxDQUFDLENBQUM0eEUsR0FBZixJQUNqQyxLQURpQyxHQUVqQyxPQUFPNXhFLENBQUMsQ0FBQ3RrQixJQUFULEtBQWtCLFFBQWxCLElBQ0MsQ0FBRXNrQixDQUFDLENBQUNpeUUsV0FBRixJQUFpQixFQUFuQixFQUNFbnFGLE9BREYsQ0FDVyxtQ0FEWCxNQUNxRCxDQUZ0RCxJQUdDdXVGLE1BQU0sQ0FBQzF5RixJQUFQLENBQWFxYyxDQUFDLENBQUN0a0IsSUFBZixDQUhELElBRzBCLE1BTGhCLENBRFosQ0FGMEUsQ0FXMUU7O0FBQ0EsUUFBS2c3RixRQUFRLElBQUkxMkUsQ0FBQyxDQUFDK3ZFLFNBQUYsQ0FBYSxDQUFiLE1BQXFCLE9BQXRDLEVBQWdEO0FBRS9DO0FBQ0F6dkYsTUFBQUEsWUFBWSxHQUFHMGYsQ0FBQyxDQUFDdTJFLGFBQUYsR0FBa0I3MkIsVUFBVSxDQUFFMS9DLENBQUMsQ0FBQ3UyRSxhQUFKLENBQVYsR0FDaEN2MkUsQ0FBQyxDQUFDdTJFLGFBQUYsRUFEZ0MsR0FFaEN2MkUsQ0FBQyxDQUFDdTJFLGFBRkgsQ0FIK0MsQ0FPL0M7O0FBQ0EsVUFBS0csUUFBTCxFQUFnQjtBQUNmMTJFLFFBQUFBLENBQUMsQ0FBRTAyRSxRQUFGLENBQUQsR0FBZ0IxMkUsQ0FBQyxDQUFFMDJFLFFBQUYsQ0FBRCxDQUFjaCtGLE9BQWQsQ0FBdUIyOUYsTUFBdkIsRUFBK0IsT0FBTy8xRixZQUF0QyxDQUFoQjtBQUNBLE9BRkQsTUFFTyxJQUFLMGYsQ0FBQyxDQUFDczJFLEtBQUYsS0FBWSxLQUFqQixFQUF5QjtBQUMvQnQyRSxRQUFBQSxDQUFDLENBQUM0eEUsR0FBRixJQUFTLENBQUUzRCxNQUFNLENBQUN0cUYsSUFBUCxDQUFhcWMsQ0FBQyxDQUFDNHhFLEdBQWYsSUFBdUIsR0FBdkIsR0FBNkIsR0FBL0IsSUFBdUM1eEUsQ0FBQyxDQUFDczJFLEtBQXpDLEdBQWlELEdBQWpELEdBQXVEaDJGLFlBQWhFO0FBQ0EsT0FaOEMsQ0FjL0M7OztBQUNBMGYsTUFBQUEsQ0FBQyxDQUFDaXhFLFVBQUYsQ0FBYyxhQUFkLElBQWdDLFlBQVc7QUFDMUMsWUFBSyxDQUFDd0YsaUJBQU4sRUFBMEI7QUFDekJsMkIsVUFBQUEsTUFBTSxDQUFDakssS0FBUCxDQUFjaDJELFlBQVksR0FBRyxpQkFBN0I7QUFDQTs7QUFDRCxlQUFPbTJGLGlCQUFpQixDQUFFLENBQUYsQ0FBeEI7QUFDQSxPQUxELENBZitDLENBc0IvQzs7O0FBQ0F6MkUsTUFBQUEsQ0FBQyxDQUFDK3ZFLFNBQUYsQ0FBYSxDQUFiLElBQW1CLE1BQW5CLENBdkIrQyxDQXlCL0M7O0FBQ0FyaEMsTUFBQUEsV0FBVyxHQUFHcjNELE1BQU0sQ0FBRWlKLFlBQUYsQ0FBcEI7O0FBQ0FqSixNQUFBQSxNQUFNLENBQUVpSixZQUFGLENBQU4sR0FBeUIsWUFBVztBQUNuQ20yRixRQUFBQSxpQkFBaUIsR0FBR3p3RixTQUFwQjtBQUNBLE9BRkQsQ0EzQitDLENBK0IvQzs7O0FBQ0FpcUYsTUFBQUEsS0FBSyxDQUFDM2IsTUFBTixDQUFjLFlBQVc7QUFFeEI7QUFDQSxZQUFLNWxCLFdBQVcsS0FBS2tULFNBQXJCLEVBQWlDO0FBQ2hDckIsVUFBQUEsTUFBTSxDQUFFbHBFLE1BQUYsQ0FBTixDQUFpQiswRixVQUFqQixDQUE2QjlyRixZQUE3QixFQURnQyxDQUdqQztBQUNDLFNBSkQsTUFJTztBQUNOakosVUFBQUEsTUFBTSxDQUFFaUosWUFBRixDQUFOLEdBQXlCb3VELFdBQXpCO0FBQ0EsU0FUdUIsQ0FXeEI7OztBQUNBLFlBQUsxdUMsQ0FBQyxDQUFFMWYsWUFBRixDQUFOLEVBQXlCO0FBRXhCO0FBQ0EwZixVQUFBQSxDQUFDLENBQUN1MkUsYUFBRixHQUFrQkMsZ0JBQWdCLENBQUNELGFBQW5DLENBSHdCLENBS3hCOztBQUNBSCxVQUFBQSxZQUFZLENBQUN0N0YsSUFBYixDQUFtQndGLFlBQW5CO0FBQ0EsU0FuQnVCLENBcUJ4Qjs7O0FBQ0EsWUFBS20yRixpQkFBaUIsSUFBSS8yQixVQUFVLENBQUVoUixXQUFGLENBQXBDLEVBQXNEO0FBQ3JEQSxVQUFBQSxXQUFXLENBQUUrbkMsaUJBQWlCLENBQUUsQ0FBRixDQUFuQixDQUFYO0FBQ0E7O0FBRURBLFFBQUFBLGlCQUFpQixHQUFHL25DLFdBQVcsR0FBR2tULFNBQWxDO0FBQ0EsT0EzQkQsRUFoQytDLENBNkQvQzs7QUFDQSxhQUFPLFFBQVA7QUFDQTtBQUNELEdBNUVELEVBNzdUaUYsQ0E4Z1VqRjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBbkMsRUFBQUEsT0FBTyxDQUFDazNCLGtCQUFSLEdBQStCLFlBQVc7QUFDekMsUUFBSXQ1RixJQUFJLEdBQUd1SCxRQUFRLENBQUNneUYsY0FBVCxDQUF3QkQsa0JBQXhCLENBQTRDLEVBQTVDLEVBQWlEdDVGLElBQTVEO0FBQ0FBLElBQUFBLElBQUksQ0FBQ2lMLFNBQUwsR0FBaUIsNEJBQWpCO0FBQ0EsV0FBT2pMLElBQUksQ0FBQ3dwRSxVQUFMLENBQWdCdnNFLE1BQWhCLEtBQTJCLENBQWxDO0FBQ0EsR0FKNEIsRUFBN0IsQ0FuaFVpRixDQTBoVWpGO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQWltRSxFQUFBQSxNQUFNLENBQUNzUixTQUFQLEdBQW1CLFVBQVVuMkUsSUFBVixFQUFnQnNGLE9BQWhCLEVBQXlCNjFGLFdBQXpCLEVBQXVDO0FBQ3pELFFBQUssT0FBT243RixJQUFQLEtBQWdCLFFBQXJCLEVBQWdDO0FBQy9CLGFBQU8sRUFBUDtBQUNBOztBQUNELFFBQUssT0FBT3NGLE9BQVAsS0FBbUIsU0FBeEIsRUFBb0M7QUFDbkM2MUYsTUFBQUEsV0FBVyxHQUFHNzFGLE9BQWQ7QUFDQUEsTUFBQUEsT0FBTyxHQUFHLEtBQVY7QUFDQTs7QUFFRCxRQUFJbzFDLElBQUosRUFBVTBnRCxNQUFWLEVBQWtCbGIsT0FBbEI7O0FBRUEsUUFBSyxDQUFDNTZFLE9BQU4sRUFBZ0I7QUFFZjtBQUNBO0FBQ0EsVUFBS3krRCxPQUFPLENBQUNrM0Isa0JBQWIsRUFBa0M7QUFDakMzMUYsUUFBQUEsT0FBTyxHQUFHNEQsUUFBUSxDQUFDZ3lGLGNBQVQsQ0FBd0JELGtCQUF4QixDQUE0QyxFQUE1QyxDQUFWLENBRGlDLENBR2pDO0FBQ0E7QUFDQTs7QUFDQXZnRCxRQUFBQSxJQUFJLEdBQUdwMUMsT0FBTyxDQUFDckksYUFBUixDQUF1QixNQUF2QixDQUFQO0FBQ0F5OUMsUUFBQUEsSUFBSSxDQUFDODJCLElBQUwsR0FBWXRvRSxRQUFRLENBQUNtb0UsUUFBVCxDQUFrQkcsSUFBOUI7QUFDQWxzRSxRQUFBQSxPQUFPLENBQUNxL0QsSUFBUixDQUFhMTVELFdBQWIsQ0FBMEJ5dkMsSUFBMUI7QUFDQSxPQVRELE1BU087QUFDTnAxQyxRQUFBQSxPQUFPLEdBQUc0RCxRQUFWO0FBQ0E7QUFDRDs7QUFFRGt5RixJQUFBQSxNQUFNLEdBQUd2bEIsVUFBVSxDQUFDdDFCLElBQVgsQ0FBaUJ2Z0QsSUFBakIsQ0FBVDtBQUNBa2dGLElBQUFBLE9BQU8sR0FBRyxDQUFDaWIsV0FBRCxJQUFnQixFQUExQixDQTlCeUQsQ0FnQ3pEOztBQUNBLFFBQUtDLE1BQUwsRUFBYztBQUNiLGFBQU8sQ0FBRTkxRixPQUFPLENBQUNySSxhQUFSLENBQXVCbStGLE1BQU0sQ0FBRSxDQUFGLENBQTdCLENBQUYsQ0FBUDtBQUNBOztBQUVEQSxJQUFBQSxNQUFNLEdBQUduYixhQUFhLENBQUUsQ0FBRWpnRixJQUFGLENBQUYsRUFBWXNGLE9BQVosRUFBcUI0NkUsT0FBckIsQ0FBdEI7O0FBRUEsUUFBS0EsT0FBTyxJQUFJQSxPQUFPLENBQUN0aEYsTUFBeEIsRUFBaUM7QUFDaENpbUUsTUFBQUEsTUFBTSxDQUFFcWIsT0FBRixDQUFOLENBQWtCMWdGLE1BQWxCO0FBQ0E7O0FBRUQsV0FBT3FsRSxNQUFNLENBQUNPLEtBQVAsQ0FBYyxFQUFkLEVBQWtCZzJCLE1BQU0sQ0FBQ2p3QixVQUF6QixDQUFQO0FBQ0EsR0E1Q0Q7QUErQ0E7QUFDQTtBQUNBOzs7QUFDQXRHLEVBQUFBLE1BQU0sQ0FBQ0MsRUFBUCxDQUFVcWUsSUFBVixHQUFpQixVQUFVK1MsR0FBVixFQUFlbjJDLE1BQWYsRUFBdUIvOUMsUUFBdkIsRUFBa0M7QUFDbEQsUUFBSWsvQyxRQUFKO0FBQUEsUUFBY3RrRCxJQUFkO0FBQUEsUUFBb0I2NEYsUUFBcEI7QUFBQSxRQUNDOTdGLElBQUksR0FBRyxJQURSO0FBQUEsUUFFQ3VuRixHQUFHLEdBQUdnVixHQUFHLENBQUM5cEYsT0FBSixDQUFhLEdBQWIsQ0FGUDs7QUFJQSxRQUFLODBFLEdBQUcsR0FBRyxDQUFDLENBQVosRUFBZ0I7QUFDZmhnQyxNQUFBQSxRQUFRLEdBQUcydkMsZ0JBQWdCLENBQUVxRixHQUFHLENBQUMxMkUsS0FBSixDQUFXMGhFLEdBQVgsQ0FBRixDQUEzQjtBQUNBZ1YsTUFBQUEsR0FBRyxHQUFHQSxHQUFHLENBQUMxMkUsS0FBSixDQUFXLENBQVgsRUFBYzBoRSxHQUFkLENBQU47QUFDQSxLQVJpRCxDQVVsRDs7O0FBQ0EsUUFBS2xkLFVBQVUsQ0FBRWprQixNQUFGLENBQWYsRUFBNEI7QUFFM0I7QUFDQS85QyxNQUFBQSxRQUFRLEdBQUcrOUMsTUFBWDtBQUNBQSxNQUFBQSxNQUFNLEdBQUdtbUIsU0FBVCxDQUoyQixDQU01QjtBQUNDLEtBUEQsTUFPTyxJQUFLbm1CLE1BQU0sSUFBSSxRQUFPQSxNQUFQLE1BQWtCLFFBQWpDLEVBQTRDO0FBQ2xEbmpELE1BQUFBLElBQUksR0FBRyxNQUFQO0FBQ0EsS0FwQmlELENBc0JsRDs7O0FBQ0EsUUFBS2pELElBQUksQ0FBQ2lGLE1BQUwsR0FBYyxDQUFuQixFQUF1QjtBQUN0QmltRSxNQUFBQSxNQUFNLENBQUNpeUIsSUFBUCxDQUFhO0FBQ1paLFFBQUFBLEdBQUcsRUFBRUEsR0FETztBQUdaO0FBQ0E7QUFDQTtBQUNBdDVGLFFBQUFBLElBQUksRUFBRUEsSUFBSSxJQUFJLEtBTkY7QUFPWnczRixRQUFBQSxRQUFRLEVBQUUsTUFQRTtBQVFacDBGLFFBQUFBLElBQUksRUFBRSsvQztBQVJNLE9BQWIsRUFTSTBvQixJQVRKLENBU1UsVUFBVTJ4QixZQUFWLEVBQXlCO0FBRWxDO0FBQ0EzRSxRQUFBQSxRQUFRLEdBQUduckYsU0FBWDtBQUVBM1EsUUFBQUEsSUFBSSxDQUFDdXNGLElBQUwsQ0FBV2hsQyxRQUFRLEdBRWxCO0FBQ0E7QUFDQTJqQixRQUFBQSxNQUFNLENBQUUsT0FBRixDQUFOLENBQWtCK2hCLE1BQWxCLENBQTBCL2hCLE1BQU0sQ0FBQ3NSLFNBQVAsQ0FBa0Jpa0IsWUFBbEIsQ0FBMUIsRUFBNkR4c0IsSUFBN0QsQ0FBbUUxc0IsUUFBbkUsQ0FKa0IsR0FNbEI7QUFDQWs1QyxRQUFBQSxZQVBELEVBTGtDLENBY25DO0FBQ0E7QUFDQTtBQUNDLE9BMUJELEVBMEJJeGhCLE1BMUJKLENBMEJZNTJFLFFBQVEsSUFBSSxVQUFVdXlGLEtBQVYsRUFBaUIwRCxNQUFqQixFQUEwQjtBQUNqRHQrRixRQUFBQSxJQUFJLENBQUMybkQsSUFBTCxDQUFXLFlBQVc7QUFDckJ0L0MsVUFBQUEsUUFBUSxDQUFDaUQsS0FBVCxDQUFnQixJQUFoQixFQUFzQnd3RixRQUFRLElBQUksQ0FBRWxCLEtBQUssQ0FBQzZGLFlBQVIsRUFBc0JuQyxNQUF0QixFQUE4QjFELEtBQTlCLENBQWxDO0FBQ0EsU0FGRDtBQUdBLE9BOUJEO0FBK0JBOztBQUVELFdBQU8sSUFBUDtBQUNBLEdBMUREOztBQStEQTF2QixFQUFBQSxNQUFNLENBQUNrSyxJQUFQLENBQVk1RixPQUFaLENBQW9Ca3lCLFFBQXBCLEdBQStCLFVBQVUvMUIsSUFBVixFQUFpQjtBQUMvQyxXQUFPVCxNQUFNLENBQUNZLElBQVAsQ0FBYVosTUFBTSxDQUFDdXFCLE1BQXBCLEVBQTRCLFVBQVV0cUIsRUFBVixFQUFlO0FBQ2pELGFBQU9RLElBQUksS0FBS1IsRUFBRSxDQUFDUSxJQUFuQjtBQUNBLEtBRk0sRUFFSDFtRSxNQUZKO0FBR0EsR0FKRDs7QUFTQWltRSxFQUFBQSxNQUFNLENBQUN0L0QsTUFBUCxHQUFnQjtBQUNmKzFGLElBQUFBLFNBQVMsRUFBRSxtQkFBVWgyQixJQUFWLEVBQWdCUSxPQUFoQixFQUF5Qm5uRSxDQUF6QixFQUE2QjtBQUN2QyxVQUFJNDhGLFdBQUo7QUFBQSxVQUFpQkMsT0FBakI7QUFBQSxVQUEwQkMsU0FBMUI7QUFBQSxVQUFxQ0MsTUFBckM7QUFBQSxVQUE2Q0MsU0FBN0M7QUFBQSxVQUF3REMsVUFBeEQ7QUFBQSxVQUFvRUMsaUJBQXBFO0FBQUEsVUFDQ2x6RixRQUFRLEdBQUdrOEQsTUFBTSxDQUFDamhDLEdBQVAsQ0FBWTBoQyxJQUFaLEVBQWtCLFVBQWxCLENBRFo7QUFBQSxVQUVDdzJCLE9BQU8sR0FBR2ozQixNQUFNLENBQUVTLElBQUYsQ0FGakI7QUFBQSxVQUdDdGpELEtBQUssR0FBRyxFQUhULENBRHVDLENBTXZDOztBQUNBLFVBQUtyWixRQUFRLEtBQUssUUFBbEIsRUFBNkI7QUFDNUIyOEQsUUFBQUEsSUFBSSxDQUFDcG9FLEtBQUwsQ0FBV3lMLFFBQVgsR0FBc0IsVUFBdEI7QUFDQTs7QUFFRGd6RixNQUFBQSxTQUFTLEdBQUdHLE9BQU8sQ0FBQ3YyRixNQUFSLEVBQVo7QUFDQWsyRixNQUFBQSxTQUFTLEdBQUc1MkIsTUFBTSxDQUFDamhDLEdBQVAsQ0FBWTBoQyxJQUFaLEVBQWtCLEtBQWxCLENBQVo7QUFDQXMyQixNQUFBQSxVQUFVLEdBQUcvMkIsTUFBTSxDQUFDamhDLEdBQVAsQ0FBWTBoQyxJQUFaLEVBQWtCLE1BQWxCLENBQWI7QUFDQXUyQixNQUFBQSxpQkFBaUIsR0FBRyxDQUFFbHpGLFFBQVEsS0FBSyxVQUFiLElBQTJCQSxRQUFRLEtBQUssT0FBMUMsS0FDbkIsQ0FBRTh5RixTQUFTLEdBQUdHLFVBQWQsRUFBMkJ4dkYsT0FBM0IsQ0FBb0MsTUFBcEMsSUFBK0MsQ0FBQyxDQURqRCxDQWR1QyxDQWlCdkM7QUFDQTs7QUFDQSxVQUFLeXZGLGlCQUFMLEVBQXlCO0FBQ3hCTixRQUFBQSxXQUFXLEdBQUdPLE9BQU8sQ0FBQ256RixRQUFSLEVBQWQ7QUFDQSt5RixRQUFBQSxNQUFNLEdBQUdILFdBQVcsQ0FBQzEzRixHQUFyQjtBQUNBMjNGLFFBQUFBLE9BQU8sR0FBR0QsV0FBVyxDQUFDMzNGLElBQXRCO0FBRUEsT0FMRCxNQUtPO0FBQ044M0YsUUFBQUEsTUFBTSxHQUFHMzBGLFVBQVUsQ0FBRTAwRixTQUFGLENBQVYsSUFBMkIsQ0FBcEM7QUFDQUQsUUFBQUEsT0FBTyxHQUFHejBGLFVBQVUsQ0FBRTYwRixVQUFGLENBQVYsSUFBNEIsQ0FBdEM7QUFDQTs7QUFFRCxVQUFLNTNCLFVBQVUsQ0FBRThCLE9BQUYsQ0FBZixFQUE2QjtBQUU1QjtBQUNBQSxRQUFBQSxPQUFPLEdBQUdBLE9BQU8sQ0FBQ2wrRCxJQUFSLENBQWMwOUQsSUFBZCxFQUFvQjNtRSxDQUFwQixFQUF1QmttRSxNQUFNLENBQUNnQixNQUFQLENBQWUsRUFBZixFQUFtQjgxQixTQUFuQixDQUF2QixDQUFWO0FBQ0E7O0FBRUQsVUFBSzcxQixPQUFPLENBQUNqaUUsR0FBUixJQUFlLElBQXBCLEVBQTJCO0FBQzFCbWUsUUFBQUEsS0FBSyxDQUFDbmUsR0FBTixHQUFjaWlFLE9BQU8sQ0FBQ2ppRSxHQUFSLEdBQWM4M0YsU0FBUyxDQUFDOTNGLEdBQTFCLEdBQWtDNjNGLE1BQTlDO0FBQ0E7O0FBQ0QsVUFBSzUxQixPQUFPLENBQUNsaUUsSUFBUixJQUFnQixJQUFyQixFQUE0QjtBQUMzQm9lLFFBQUFBLEtBQUssQ0FBQ3BlLElBQU4sR0FBZWtpRSxPQUFPLENBQUNsaUUsSUFBUixHQUFlKzNGLFNBQVMsQ0FBQy8zRixJQUEzQixHQUFvQzQzRixPQUFqRDtBQUNBOztBQUVELFVBQUssV0FBVzExQixPQUFoQixFQUEwQjtBQUN6QkEsUUFBQUEsT0FBTyxDQUFDaTJCLEtBQVIsQ0FBY24wRixJQUFkLENBQW9CMDlELElBQXBCLEVBQTBCdGpELEtBQTFCO0FBRUEsT0FIRCxNQUdPO0FBQ044NUUsUUFBQUEsT0FBTyxDQUFDbDRELEdBQVIsQ0FBYTVoQixLQUFiO0FBQ0E7QUFDRDtBQWpEYyxHQUFoQjtBQW9EQTZpRCxFQUFBQSxNQUFNLENBQUNDLEVBQVAsQ0FBVWUsTUFBVixDQUFrQjtBQUVqQjtBQUNBdGdFLElBQUFBLE1BQU0sRUFBRSxnQkFBVXVnRSxPQUFWLEVBQW9CO0FBRTNCO0FBQ0EsVUFBS3g3RCxTQUFTLENBQUMxTCxNQUFmLEVBQXdCO0FBQ3ZCLGVBQU9rbkUsT0FBTyxLQUFLSSxTQUFaLEdBQ04sSUFETSxHQUVOLEtBQUs1a0IsSUFBTCxDQUFXLFVBQVUzaUQsQ0FBVixFQUFjO0FBQ3hCa21FLFVBQUFBLE1BQU0sQ0FBQ3QvRCxNQUFQLENBQWMrMUYsU0FBZCxDQUF5QixJQUF6QixFQUErQngxQixPQUEvQixFQUF3Q25uRSxDQUF4QztBQUNBLFNBRkQsQ0FGRDtBQUtBOztBQUVELFVBQUk0VCxJQUFKO0FBQUEsVUFBVXlwRixHQUFWO0FBQUEsVUFDQzEyQixJQUFJLEdBQUcsS0FBTSxDQUFOLENBRFI7O0FBR0EsVUFBSyxDQUFDQSxJQUFOLEVBQWE7QUFDWjtBQUNBLE9BaEIwQixDQWtCM0I7QUFDQTtBQUNBO0FBQ0E7OztBQUNBLFVBQUssQ0FBQ0EsSUFBSSxDQUFDK2xCLGNBQUwsR0FBc0J6c0YsTUFBNUIsRUFBcUM7QUFDcEMsZUFBTztBQUFFaUYsVUFBQUEsR0FBRyxFQUFFLENBQVA7QUFBVUQsVUFBQUEsSUFBSSxFQUFFO0FBQWhCLFNBQVA7QUFDQSxPQXhCMEIsQ0EwQjNCOzs7QUFDQTJPLE1BQUFBLElBQUksR0FBRyt5RCxJQUFJLENBQUM1Z0UscUJBQUwsRUFBUDtBQUNBczNGLE1BQUFBLEdBQUcsR0FBRzEyQixJQUFJLENBQUNoaEUsYUFBTCxDQUFtQmlwRSxXQUF6QjtBQUNBLGFBQU87QUFDTjFwRSxRQUFBQSxHQUFHLEVBQUUwTyxJQUFJLENBQUMxTyxHQUFMLEdBQVdtNEYsR0FBRyxDQUFDeDZGLFdBRGQ7QUFFTm9DLFFBQUFBLElBQUksRUFBRTJPLElBQUksQ0FBQzNPLElBQUwsR0FBWW80RixHQUFHLENBQUNuNkY7QUFGaEIsT0FBUDtBQUlBLEtBcENnQjtBQXNDakI7QUFDQTtBQUNBOEcsSUFBQUEsUUFBUSxFQUFFLG9CQUFXO0FBQ3BCLFVBQUssQ0FBQyxLQUFNLENBQU4sQ0FBTixFQUFrQjtBQUNqQjtBQUNBOztBQUVELFVBQUk0MEQsWUFBSjtBQUFBLFVBQWtCaDRELE1BQWxCO0FBQUEsVUFBMEJoRSxHQUExQjtBQUFBLFVBQ0MrakUsSUFBSSxHQUFHLEtBQU0sQ0FBTixDQURSO0FBQUEsVUFFQzIyQixZQUFZLEdBQUc7QUFBRXA0RixRQUFBQSxHQUFHLEVBQUUsQ0FBUDtBQUFVRCxRQUFBQSxJQUFJLEVBQUU7QUFBaEIsT0FGaEIsQ0FMb0IsQ0FTcEI7O0FBQ0EsVUFBS2loRSxNQUFNLENBQUNqaEMsR0FBUCxDQUFZMGhDLElBQVosRUFBa0IsVUFBbEIsTUFBbUMsT0FBeEMsRUFBa0Q7QUFFakQ7QUFDQS8vRCxRQUFBQSxNQUFNLEdBQUcrL0QsSUFBSSxDQUFDNWdFLHFCQUFMLEVBQVQ7QUFFQSxPQUxELE1BS087QUFDTmEsUUFBQUEsTUFBTSxHQUFHLEtBQUtBLE1BQUwsRUFBVCxDQURNLENBR047QUFDQTs7QUFDQWhFLFFBQUFBLEdBQUcsR0FBRytqRSxJQUFJLENBQUNoaEUsYUFBWDtBQUNBaTVELFFBQUFBLFlBQVksR0FBRytILElBQUksQ0FBQy9ILFlBQUwsSUFBcUJoOEQsR0FBRyxDQUFDRyxlQUF4Qzs7QUFDQSxlQUFRNjdELFlBQVksS0FDakJBLFlBQVksS0FBS2g4RCxHQUFHLENBQUNJLElBQXJCLElBQTZCNDdELFlBQVksS0FBS2g4RCxHQUFHLENBQUNHLGVBRGpDLENBQVosSUFFUG1qRSxNQUFNLENBQUNqaEMsR0FBUCxDQUFZMjVCLFlBQVosRUFBMEIsVUFBMUIsTUFBMkMsUUFGNUMsRUFFdUQ7QUFFdERBLFVBQUFBLFlBQVksR0FBR0EsWUFBWSxDQUFDcjdELFVBQTVCO0FBQ0E7O0FBQ0QsWUFBS3E3RCxZQUFZLElBQUlBLFlBQVksS0FBSytILElBQWpDLElBQXlDL0gsWUFBWSxDQUFDbjdELFFBQWIsS0FBMEIsQ0FBeEUsRUFBNEU7QUFFM0U7QUFDQTY1RixVQUFBQSxZQUFZLEdBQUdwM0IsTUFBTSxDQUFFdEgsWUFBRixDQUFOLENBQXVCaDRELE1BQXZCLEVBQWY7QUFDQTAyRixVQUFBQSxZQUFZLENBQUNwNEYsR0FBYixJQUFvQmdoRSxNQUFNLENBQUNqaEMsR0FBUCxDQUFZMjVCLFlBQVosRUFBMEIsZ0JBQTFCLEVBQTRDLElBQTVDLENBQXBCO0FBQ0EwK0IsVUFBQUEsWUFBWSxDQUFDcjRGLElBQWIsSUFBcUJpaEUsTUFBTSxDQUFDamhDLEdBQVAsQ0FBWTI1QixZQUFaLEVBQTBCLGlCQUExQixFQUE2QyxJQUE3QyxDQUFyQjtBQUNBO0FBQ0QsT0FuQ21CLENBcUNwQjs7O0FBQ0EsYUFBTztBQUNOMTVELFFBQUFBLEdBQUcsRUFBRTBCLE1BQU0sQ0FBQzFCLEdBQVAsR0FBYW80RixZQUFZLENBQUNwNEYsR0FBMUIsR0FBZ0NnaEUsTUFBTSxDQUFDamhDLEdBQVAsQ0FBWTBoQyxJQUFaLEVBQWtCLFdBQWxCLEVBQStCLElBQS9CLENBRC9CO0FBRU4xaEUsUUFBQUEsSUFBSSxFQUFFMkIsTUFBTSxDQUFDM0IsSUFBUCxHQUFjcTRGLFlBQVksQ0FBQ3I0RixJQUEzQixHQUFrQ2loRSxNQUFNLENBQUNqaEMsR0FBUCxDQUFZMGhDLElBQVosRUFBa0IsWUFBbEIsRUFBZ0MsSUFBaEM7QUFGbEMsT0FBUDtBQUlBLEtBbEZnQjtBQW9GakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQS9ILElBQUFBLFlBQVksRUFBRSx3QkFBVztBQUN4QixhQUFPLEtBQUtyZ0QsR0FBTCxDQUFVLFlBQVc7QUFDM0IsWUFBSXFnRCxZQUFZLEdBQUcsS0FBS0EsWUFBeEI7O0FBRUEsZUFBUUEsWUFBWSxJQUFJc0gsTUFBTSxDQUFDamhDLEdBQVAsQ0FBWTI1QixZQUFaLEVBQTBCLFVBQTFCLE1BQTJDLFFBQW5FLEVBQThFO0FBQzdFQSxVQUFBQSxZQUFZLEdBQUdBLFlBQVksQ0FBQ0EsWUFBNUI7QUFDQTs7QUFFRCxlQUFPQSxZQUFZLElBQUk3N0QsZUFBdkI7QUFDQSxPQVJNLENBQVA7QUFTQTtBQXhHZ0IsR0FBbEIsRUE1c1VpRixDQXV6VWpGOztBQUNBbWpFLEVBQUFBLE1BQU0sQ0FBQ3ZqQixJQUFQLENBQWE7QUFBRXgvQyxJQUFBQSxVQUFVLEVBQUUsYUFBZDtBQUE2QkwsSUFBQUEsU0FBUyxFQUFFO0FBQXhDLEdBQWIsRUFBc0UsVUFBVTgyRSxNQUFWLEVBQWtCcHBELElBQWxCLEVBQXlCO0FBQzlGLFFBQUl0ckIsR0FBRyxHQUFHLGtCQUFrQnNyQixJQUE1Qjs7QUFFQTAxQyxJQUFBQSxNQUFNLENBQUNDLEVBQVAsQ0FBV3lULE1BQVgsSUFBc0IsVUFBVTVyRSxHQUFWLEVBQWdCO0FBQ3JDLGFBQU93dUUsTUFBTSxDQUFFLElBQUYsRUFBUSxVQUFVN1YsSUFBVixFQUFnQmlULE1BQWhCLEVBQXdCNXJFLEdBQXhCLEVBQThCO0FBRWxEO0FBQ0EsWUFBSXF2RixHQUFKOztBQUNBLFlBQUs5M0IsUUFBUSxDQUFFb0IsSUFBRixDQUFiLEVBQXdCO0FBQ3ZCMDJCLFVBQUFBLEdBQUcsR0FBRzEyQixJQUFOO0FBQ0EsU0FGRCxNQUVPLElBQUtBLElBQUksQ0FBQ2xqRSxRQUFMLEtBQWtCLENBQXZCLEVBQTJCO0FBQ2pDNDVGLFVBQUFBLEdBQUcsR0FBRzEyQixJQUFJLENBQUNpSSxXQUFYO0FBQ0E7O0FBRUQsWUFBSzVnRSxHQUFHLEtBQUt1NUQsU0FBYixFQUF5QjtBQUN4QixpQkFBTzgxQixHQUFHLEdBQUdBLEdBQUcsQ0FBRTdzRSxJQUFGLENBQU4sR0FBaUJtMkMsSUFBSSxDQUFFaVQsTUFBRixDQUEvQjtBQUNBOztBQUVELFlBQUt5akIsR0FBTCxFQUFXO0FBQ1ZBLFVBQUFBLEdBQUcsQ0FBQ25wRixRQUFKLENBQ0MsQ0FBQ2hQLEdBQUQsR0FBTzhJLEdBQVAsR0FBYXF2RixHQUFHLENBQUNuNkYsV0FEbEIsRUFFQ2dDLEdBQUcsR0FBRzhJLEdBQUgsR0FBU3F2RixHQUFHLENBQUN4NkYsV0FGakI7QUFLQSxTQU5ELE1BTU87QUFDTjhqRSxVQUFBQSxJQUFJLENBQUVpVCxNQUFGLENBQUosR0FBaUI1ckUsR0FBakI7QUFDQTtBQUNELE9BdkJZLEVBdUJWNHJFLE1BdkJVLEVBdUJGNXJFLEdBdkJFLEVBdUJHckMsU0FBUyxDQUFDMUwsTUF2QmIsQ0FBYjtBQXdCQSxLQXpCRDtBQTBCQSxHQTdCRCxFQXh6VWlGLENBdTFVakY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBaW1FLEVBQUFBLE1BQU0sQ0FBQ3ZqQixJQUFQLENBQWEsQ0FBRSxLQUFGLEVBQVMsTUFBVCxDQUFiLEVBQWdDLFVBQVU5akIsRUFBVixFQUFjck8sSUFBZCxFQUFxQjtBQUNwRDAxQyxJQUFBQSxNQUFNLENBQUN5bUIsUUFBUCxDQUFpQm44RCxJQUFqQixJQUEwQm02RCxZQUFZLENBQUV2bEIsT0FBTyxDQUFDNGtCLGFBQVYsRUFDckMsVUFBVXJqQixJQUFWLEVBQWdCNmpCLFFBQWhCLEVBQTJCO0FBQzFCLFVBQUtBLFFBQUwsRUFBZ0I7QUFDZkEsUUFBQUEsUUFBUSxHQUFHRCxNQUFNLENBQUU1akIsSUFBRixFQUFRbjJDLElBQVIsQ0FBakIsQ0FEZSxDQUdmOztBQUNBLGVBQU9xNEQsU0FBUyxDQUFDdi9FLElBQVYsQ0FBZ0JraEYsUUFBaEIsSUFDTnRrQixNQUFNLENBQUVTLElBQUYsQ0FBTixDQUFlMzhELFFBQWYsR0FBMkJ3bUIsSUFBM0IsSUFBb0MsSUFEOUIsR0FFTmc2RCxRQUZEO0FBR0E7QUFDRCxLQVZvQyxDQUF0QztBQVlBLEdBYkQsRUE3MVVpRixDQTYyVWpGOztBQUNBdGtCLEVBQUFBLE1BQU0sQ0FBQ3ZqQixJQUFQLENBQWE7QUFBRTQ2QyxJQUFBQSxNQUFNLEVBQUUsUUFBVjtBQUFvQkMsSUFBQUEsS0FBSyxFQUFFO0FBQTNCLEdBQWIsRUFBbUQsVUFBVTU2RSxJQUFWLEVBQWdCM2tCLElBQWhCLEVBQXVCO0FBQ3pFaW9FLElBQUFBLE1BQU0sQ0FBQ3ZqQixJQUFQLENBQWE7QUFDWnVxQyxNQUFBQSxPQUFPLEVBQUUsVUFBVXRxRSxJQURQO0FBRVp0WSxNQUFBQSxPQUFPLEVBQUVyTSxJQUZHO0FBR1osVUFBSSxVQUFVMmtCO0FBSEYsS0FBYixFQUlHLFVBQVU2NkUsWUFBVixFQUF3QkMsUUFBeEIsRUFBbUM7QUFFckM7QUFDQXgzQixNQUFBQSxNQUFNLENBQUNDLEVBQVAsQ0FBV3UzQixRQUFYLElBQXdCLFVBQVV6USxNQUFWLEVBQWtCN3ZGLEtBQWxCLEVBQTBCO0FBQ2pELFlBQUlxL0UsU0FBUyxHQUFHOXdFLFNBQVMsQ0FBQzFMLE1BQVYsS0FBc0J3OUYsWUFBWSxJQUFJLE9BQU94USxNQUFQLEtBQWtCLFNBQXhELENBQWhCO0FBQUEsWUFDQ2IsS0FBSyxHQUFHcVIsWUFBWSxLQUFNeFEsTUFBTSxLQUFLLElBQVgsSUFBbUI3dkYsS0FBSyxLQUFLLElBQTdCLEdBQW9DLFFBQXBDLEdBQStDLFFBQXJELENBRHJCO0FBR0EsZUFBT28vRSxNQUFNLENBQUUsSUFBRixFQUFRLFVBQVU3VixJQUFWLEVBQWdCMW9FLElBQWhCLEVBQXNCYixLQUF0QixFQUE4QjtBQUNsRCxjQUFJd0YsR0FBSjs7QUFFQSxjQUFLMmlFLFFBQVEsQ0FBRW9CLElBQUYsQ0FBYixFQUF3QjtBQUV2QjtBQUNBLG1CQUFPKzJCLFFBQVEsQ0FBQ2p3RixPQUFULENBQWtCLE9BQWxCLE1BQWdDLENBQWhDLEdBQ05rNUQsSUFBSSxDQUFFLFVBQVUvakQsSUFBWixDQURFLEdBRU4rakQsSUFBSSxDQUFDcDhELFFBQUwsQ0FBY3hILGVBQWQsQ0FBK0IsV0FBVzZmLElBQTFDLENBRkQ7QUFHQSxXQVRpRCxDQVdsRDs7O0FBQ0EsY0FBSytqRCxJQUFJLENBQUNsakUsUUFBTCxLQUFrQixDQUF2QixFQUEyQjtBQUMxQmIsWUFBQUEsR0FBRyxHQUFHK2pFLElBQUksQ0FBQzVqRSxlQUFYLENBRDBCLENBRzFCO0FBQ0E7O0FBQ0EsbUJBQU9wRixJQUFJLENBQUNvRyxHQUFMLENBQ040aUUsSUFBSSxDQUFDM2pFLElBQUwsQ0FBVyxXQUFXNGYsSUFBdEIsQ0FETSxFQUN3QmhnQixHQUFHLENBQUUsV0FBV2dnQixJQUFiLENBRDNCLEVBRU4rakQsSUFBSSxDQUFDM2pFLElBQUwsQ0FBVyxXQUFXNGYsSUFBdEIsQ0FGTSxFQUV3QmhnQixHQUFHLENBQUUsV0FBV2dnQixJQUFiLENBRjNCLEVBR05oZ0IsR0FBRyxDQUFFLFdBQVdnZ0IsSUFBYixDQUhHLENBQVA7QUFLQTs7QUFFRCxpQkFBT3hsQixLQUFLLEtBQUttcUUsU0FBVixHQUVOO0FBQ0FyQixVQUFBQSxNQUFNLENBQUNqaEMsR0FBUCxDQUFZMGhDLElBQVosRUFBa0Ixb0UsSUFBbEIsRUFBd0JtdUYsS0FBeEIsQ0FITSxHQUtOO0FBQ0FsbUIsVUFBQUEsTUFBTSxDQUFDM25FLEtBQVAsQ0FBY29vRSxJQUFkLEVBQW9CMW9FLElBQXBCLEVBQTBCYixLQUExQixFQUFpQ2d2RixLQUFqQyxDQU5EO0FBT0EsU0EvQlksRUErQlZudUYsSUEvQlUsRUErQkp3K0UsU0FBUyxHQUFHd1EsTUFBSCxHQUFZMWxCLFNBL0JqQixFQStCNEJrVixTQS9CNUIsQ0FBYjtBQWdDQSxPQXBDRDtBQXFDQSxLQTVDRDtBQTZDQSxHQTlDRDtBQWlEQXZXLEVBQUFBLE1BQU0sQ0FBQ3ZqQixJQUFQLENBQWEsQ0FDWixXQURZLEVBRVosVUFGWSxFQUdaLGNBSFksRUFJWixXQUpZLEVBS1osYUFMWSxFQU1aLFVBTlksQ0FBYixFQU9HLFVBQVU5akIsRUFBVixFQUFjNWdDLElBQWQsRUFBcUI7QUFDdkJpb0UsSUFBQUEsTUFBTSxDQUFDQyxFQUFQLENBQVdsb0UsSUFBWCxJQUFvQixVQUFVa29FLEVBQVYsRUFBZTtBQUNsQyxhQUFPLEtBQUtpYyxFQUFMLENBQVNua0YsSUFBVCxFQUFla29FLEVBQWYsQ0FBUDtBQUNBLEtBRkQ7QUFHQSxHQVhEO0FBZ0JBRCxFQUFBQSxNQUFNLENBQUNDLEVBQVAsQ0FBVWUsTUFBVixDQUFrQjtBQUVqQjU0QixJQUFBQSxJQUFJLEVBQUUsY0FBVXBnQyxLQUFWLEVBQWlCN00sSUFBakIsRUFBdUI4a0UsRUFBdkIsRUFBNEI7QUFDakMsYUFBTyxLQUFLaWMsRUFBTCxDQUFTbDBFLEtBQVQsRUFBZ0IsSUFBaEIsRUFBc0I3TSxJQUF0QixFQUE0QjhrRSxFQUE1QixDQUFQO0FBQ0EsS0FKZ0I7QUFLakJ3M0IsSUFBQUEsTUFBTSxFQUFFLGdCQUFVenZGLEtBQVYsRUFBaUJpNEQsRUFBakIsRUFBc0I7QUFDN0IsYUFBTyxLQUFLb2MsR0FBTCxDQUFVcjBFLEtBQVYsRUFBaUIsSUFBakIsRUFBdUJpNEQsRUFBdkIsQ0FBUDtBQUNBLEtBUGdCO0FBU2pCeTNCLElBQUFBLFFBQVEsRUFBRSxrQkFBVXI3QyxRQUFWLEVBQW9CcjBDLEtBQXBCLEVBQTJCN00sSUFBM0IsRUFBaUM4a0UsRUFBakMsRUFBc0M7QUFDL0MsYUFBTyxLQUFLaWMsRUFBTCxDQUFTbDBFLEtBQVQsRUFBZ0JxMEMsUUFBaEIsRUFBMEJsaEQsSUFBMUIsRUFBZ0M4a0UsRUFBaEMsQ0FBUDtBQUNBLEtBWGdCO0FBWWpCMDNCLElBQUFBLFVBQVUsRUFBRSxvQkFBVXQ3QyxRQUFWLEVBQW9CcjBDLEtBQXBCLEVBQTJCaTRELEVBQTNCLEVBQWdDO0FBRTNDO0FBQ0EsYUFBT3g2RCxTQUFTLENBQUMxTCxNQUFWLEtBQXFCLENBQXJCLEdBQ04sS0FBS3NpRixHQUFMLENBQVVoZ0MsUUFBVixFQUFvQixJQUFwQixDQURNLEdBRU4sS0FBS2dnQyxHQUFMLENBQVVyMEUsS0FBVixFQUFpQnEwQyxRQUFRLElBQUksSUFBN0IsRUFBbUM0akIsRUFBbkMsQ0FGRDtBQUdBLEtBbEJnQjtBQW9CakIyM0IsSUFBQUEsS0FBSyxFQUFFLGVBQVVDLE1BQVYsRUFBa0JDLEtBQWxCLEVBQTBCO0FBQ2hDLGFBQU8sS0FBS2hZLFVBQUwsQ0FBaUIrWCxNQUFqQixFQUEwQjlYLFVBQTFCLENBQXNDK1gsS0FBSyxJQUFJRCxNQUEvQyxDQUFQO0FBQ0E7QUF0QmdCLEdBQWxCO0FBeUJBNzNCLEVBQUFBLE1BQU0sQ0FBQ3ZqQixJQUFQLENBQ0MsQ0FBRSw4REFDRix1RUFERSxHQUVGLHlEQUZBLEVBRTREdjBDLEtBRjVELENBRW1FLEdBRm5FLENBREQsRUFJQyxVQUFVeXdCLEVBQVYsRUFBY2pjLElBQWQsRUFBcUI7QUFFcEI7QUFDQXNqRCxJQUFBQSxNQUFNLENBQUNDLEVBQVAsQ0FBV3ZqRCxJQUFYLElBQW9CLFVBQVV2aEIsSUFBVixFQUFnQjhrRSxFQUFoQixFQUFxQjtBQUN4QyxhQUFPeDZELFNBQVMsQ0FBQzFMLE1BQVYsR0FBbUIsQ0FBbkIsR0FDTixLQUFLbWlGLEVBQUwsQ0FBU3gvRCxJQUFULEVBQWUsSUFBZixFQUFxQnZoQixJQUFyQixFQUEyQjhrRSxFQUEzQixDQURNLEdBRU4sS0FBSzcxRCxPQUFMLENBQWNzUyxJQUFkLENBRkQ7QUFHQSxLQUpEO0FBS0EsR0FaRixFQXg4VWlGLENBMDlVakY7QUFDQTs7QUFDQSxNQUFJOG5ELEtBQUssR0FBRyxvQ0FBWixDQTU5VWlGLENBODlVakY7QUFDQTtBQUNBO0FBQ0E7O0FBQ0F4RSxFQUFBQSxNQUFNLENBQUMrM0IsS0FBUCxHQUFlLFVBQVU5M0IsRUFBVixFQUFjeC9ELE9BQWQsRUFBd0I7QUFDdEMsUUFBSXlvRSxHQUFKLEVBQVNoWSxJQUFULEVBQWU2bUMsS0FBZjs7QUFFQSxRQUFLLE9BQU90M0YsT0FBUCxLQUFtQixRQUF4QixFQUFtQztBQUNsQ3lvRSxNQUFBQSxHQUFHLEdBQUdqSixFQUFFLENBQUV4L0QsT0FBRixDQUFSO0FBQ0FBLE1BQUFBLE9BQU8sR0FBR3cvRCxFQUFWO0FBQ0FBLE1BQUFBLEVBQUUsR0FBR2lKLEdBQUw7QUFDQSxLQVBxQyxDQVN0QztBQUNBOzs7QUFDQSxRQUFLLENBQUMvSixVQUFVLENBQUVjLEVBQUYsQ0FBaEIsRUFBeUI7QUFDeEIsYUFBT29CLFNBQVA7QUFDQSxLQWJxQyxDQWV0Qzs7O0FBQ0FuUSxJQUFBQSxJQUFJLEdBQUd2MkMsTUFBSyxDQUFDNVgsSUFBTixDQUFZMEMsU0FBWixFQUF1QixDQUF2QixDQUFQOztBQUNBc3lGLElBQUFBLEtBQUssR0FBRyxpQkFBVztBQUNsQixhQUFPOTNCLEVBQUUsQ0FBQzcvRCxLQUFILENBQVVLLE9BQU8sSUFBSSxJQUFyQixFQUEyQnl3RCxJQUFJLENBQUNyMUMsTUFBTCxDQUFhbEIsTUFBSyxDQUFDNVgsSUFBTixDQUFZMEMsU0FBWixDQUFiLENBQTNCLENBQVA7QUFDQSxLQUZELENBakJzQyxDQXFCdEM7OztBQUNBc3lGLElBQUFBLEtBQUssQ0FBQ3gxQixJQUFOLEdBQWF0QyxFQUFFLENBQUNzQyxJQUFILEdBQVV0QyxFQUFFLENBQUNzQyxJQUFILElBQVd2QyxNQUFNLENBQUN1QyxJQUFQLEVBQWxDO0FBRUEsV0FBT3cxQixLQUFQO0FBQ0EsR0F6QkQ7O0FBMkJBLzNCLEVBQUFBLE1BQU0sQ0FBQ2c0QixTQUFQLEdBQW1CLFVBQVVDLElBQVYsRUFBaUI7QUFDbkMsUUFBS0EsSUFBTCxFQUFZO0FBQ1hqNEIsTUFBQUEsTUFBTSxDQUFDaVcsU0FBUDtBQUNBLEtBRkQsTUFFTztBQUNOalcsTUFBQUEsTUFBTSxDQUFDdVIsS0FBUCxDQUFjLElBQWQ7QUFDQTtBQUNELEdBTkQ7O0FBT0F2UixFQUFBQSxNQUFNLENBQUNub0UsT0FBUCxHQUFpQkQsS0FBSyxDQUFDQyxPQUF2QjtBQUNBbW9FLEVBQUFBLE1BQU0sQ0FBQ2s0QixTQUFQLEdBQW1CdmdCLElBQUksQ0FBQ0MsS0FBeEI7QUFDQTVYLEVBQUFBLE1BQU0sQ0FBQzM4RCxRQUFQLEdBQWtCQSxRQUFsQjtBQUNBMjhELEVBQUFBLE1BQU0sQ0FBQ2IsVUFBUCxHQUFvQkEsVUFBcEI7QUFDQWEsRUFBQUEsTUFBTSxDQUFDWCxRQUFQLEdBQWtCQSxRQUFsQjtBQUNBVyxFQUFBQSxNQUFNLENBQUMrVyxTQUFQLEdBQW1CQSxTQUFuQjtBQUNBL1csRUFBQUEsTUFBTSxDQUFDam9FLElBQVAsR0FBY2dvRSxNQUFkO0FBRUFDLEVBQUFBLE1BQU0sQ0FBQ3BuRSxHQUFQLEdBQWFELElBQUksQ0FBQ0MsR0FBbEI7O0FBRUFvbkUsRUFBQUEsTUFBTSxDQUFDbTRCLFNBQVAsR0FBbUIsVUFBVTcrRixHQUFWLEVBQWdCO0FBRWxDO0FBQ0E7QUFDQTtBQUNBLFFBQUl2QixJQUFJLEdBQUdpb0UsTUFBTSxDQUFDam9FLElBQVAsQ0FBYXVCLEdBQWIsQ0FBWDtBQUNBLFdBQU8sQ0FBRXZCLElBQUksS0FBSyxRQUFULElBQXFCQSxJQUFJLEtBQUssUUFBaEMsS0FFTjtBQUNBO0FBQ0E7QUFDQSxLQUFDdVIsS0FBSyxDQUFFaFEsR0FBRyxHQUFHNEksVUFBVSxDQUFFNUksR0FBRixDQUFsQixDQUxQO0FBTUEsR0FaRDs7QUFjQTBtRSxFQUFBQSxNQUFNLENBQUN0cUIsSUFBUCxHQUFjLFVBQVVtcUIsSUFBVixFQUFpQjtBQUM5QixXQUFPQSxJQUFJLElBQUksSUFBUixHQUNOLEVBRE0sR0FFTixDQUFFQSxJQUFJLEdBQUcsRUFBVCxFQUFjMW5FLE9BQWQsQ0FBdUJxc0UsS0FBdkIsRUFBOEIsRUFBOUIsQ0FGRDtBQUdBLEdBSkQsQ0E1aFZpRixDQW9pVmpGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7OztBQUVBLE1BQUssSUFBTCxFQUFrRDtBQUNqRDR6QixJQUFBQSxpQ0FBa0IsRUFBWixtQ0FBZ0IsWUFBVztBQUNoQyxhQUFPcDRCLE1BQVA7QUFDQSxLQUZLO0FBQUEsa0dBQU47QUFHQTs7QUFLRCxNQUVDO0FBQ0FzNEIsRUFBQUEsT0FBTyxHQUFHeGhHLE1BQU0sQ0FBQ2twRSxNQUhsQjtBQUFBLE1BS0M7QUFDQXU0QixFQUFBQSxFQUFFLEdBQUd6aEcsTUFBTSxDQUFDMGhHLENBTmI7O0FBUUF4NEIsRUFBQUEsTUFBTSxDQUFDeTRCLFVBQVAsR0FBb0IsVUFBVXQzQixJQUFWLEVBQWlCO0FBQ3BDLFFBQUtycUUsTUFBTSxDQUFDMGhHLENBQVAsS0FBYXg0QixNQUFsQixFQUEyQjtBQUMxQmxwRSxNQUFBQSxNQUFNLENBQUMwaEcsQ0FBUCxHQUFXRCxFQUFYO0FBQ0E7O0FBRUQsUUFBS3AzQixJQUFJLElBQUlycUUsTUFBTSxDQUFDa3BFLE1BQVAsS0FBa0JBLE1BQS9CLEVBQXdDO0FBQ3ZDbHBFLE1BQUFBLE1BQU0sQ0FBQ2twRSxNQUFQLEdBQWdCczRCLE9BQWhCO0FBQ0E7O0FBRUQsV0FBT3Q0QixNQUFQO0FBQ0EsR0FWRCxDQWxrVmlGLENBOGtWakY7QUFDQTtBQUNBOzs7QUFDQSxNQUFLLE9BQU8xQixRQUFQLEtBQW9CLFdBQXpCLEVBQXVDO0FBQ3RDeG5FLElBQUFBLE1BQU0sQ0FBQ2twRSxNQUFQLEdBQWdCbHBFLE1BQU0sQ0FBQzBoRyxDQUFQLEdBQVd4NEIsTUFBM0I7QUFDQTs7QUFLRCxTQUFPQSxNQUFQO0FBQ0MsQ0FublZEOzs7Ozs7Ozs7QUNiQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBOztBQUFFLFdBQVM5QixPQUFULEVBQWtCO0FBQ2hCOztBQUNBLE1BQUksSUFBSixFQUFnRDtBQUM1Q2s2QixJQUFBQSxpQ0FBTyxDQUFDLHdCQUFELENBQUQsb0NBQWFsNkIsT0FBYjtBQUFBO0FBQUE7QUFBQSxrR0FBTjtBQUNILEdBRkQsTUFFTyxFQUlOO0FBRUosQ0FWQyxFQVVBLFVBQVNzNkIsQ0FBVCxFQUFZO0FBQ1Y7O0FBQ0EsTUFBSUcsS0FBSyxHQUFHN2hHLE1BQU0sQ0FBQzZoRyxLQUFQLElBQWdCLEVBQTVCOztBQUVBQSxFQUFBQSxLQUFLLEdBQUksWUFBVztBQUVoQixRQUFJQyxXQUFXLEdBQUcsQ0FBbEI7O0FBRUEsYUFBU0QsS0FBVCxDQUFlcjlGLE9BQWYsRUFBd0J3MkYsUUFBeEIsRUFBa0M7QUFFOUIsVUFBSXRmLENBQUMsR0FBRyxJQUFSO0FBQUEsVUFBY3FtQixZQUFkOztBQUVBcm1CLE1BQUFBLENBQUMsQ0FBQzc0RSxRQUFGLEdBQWE7QUFDVG0vRixRQUFBQSxhQUFhLEVBQUUsSUFETjtBQUVUQyxRQUFBQSxjQUFjLEVBQUUsS0FGUDtBQUdUQyxRQUFBQSxZQUFZLEVBQUVSLENBQUMsQ0FBQ2w5RixPQUFELENBSE47QUFJVDI5RixRQUFBQSxVQUFVLEVBQUVULENBQUMsQ0FBQ2w5RixPQUFELENBSko7QUFLVDQ5RixRQUFBQSxNQUFNLEVBQUUsSUFMQztBQU1UQyxRQUFBQSxRQUFRLEVBQUUsSUFORDtBQU9UQyxRQUFBQSxTQUFTLEVBQUUsa0ZBUEY7QUFRVEMsUUFBQUEsU0FBUyxFQUFFLDBFQVJGO0FBU1RDLFFBQUFBLFFBQVEsRUFBRSxLQVREO0FBVVRDLFFBQUFBLGFBQWEsRUFBRSxJQVZOO0FBV1RDLFFBQUFBLFVBQVUsRUFBRSxLQVhIO0FBWVRDLFFBQUFBLGFBQWEsRUFBRSxNQVpOO0FBYVRDLFFBQUFBLE9BQU8sRUFBRSxNQWJBO0FBY1RDLFFBQUFBLFlBQVksRUFBRSxzQkFBU0MsTUFBVCxFQUFpQjkvRixDQUFqQixFQUFvQjtBQUM5QixpQkFBTzArRixDQUFDLENBQUMsMEJBQUQsQ0FBRCxDQUE4QjM0QixJQUE5QixDQUFtQy9sRSxDQUFDLEdBQUcsQ0FBdkMsQ0FBUDtBQUNILFNBaEJRO0FBaUJUKy9GLFFBQUFBLElBQUksRUFBRSxLQWpCRztBQWtCVEMsUUFBQUEsU0FBUyxFQUFFLFlBbEJGO0FBbUJUcjNGLFFBQUFBLFNBQVMsRUFBRSxJQW5CRjtBQW9CVDZrRixRQUFBQSxNQUFNLEVBQUUsUUFwQkM7QUFxQlR5UyxRQUFBQSxZQUFZLEVBQUUsSUFyQkw7QUFzQlRDLFFBQUFBLElBQUksRUFBRSxLQXRCRztBQXVCVEMsUUFBQUEsYUFBYSxFQUFFLEtBdkJOO0FBd0JUQyxRQUFBQSxhQUFhLEVBQUUsS0F4Qk47QUF5QlRDLFFBQUFBLFFBQVEsRUFBRSxJQXpCRDtBQTBCVEMsUUFBQUEsWUFBWSxFQUFFLENBMUJMO0FBMkJUQyxRQUFBQSxRQUFRLEVBQUUsVUEzQkQ7QUE0QlRDLFFBQUFBLFdBQVcsRUFBRSxLQTVCSjtBQTZCVEMsUUFBQUEsWUFBWSxFQUFFLElBN0JMO0FBOEJUQyxRQUFBQSxZQUFZLEVBQUUsSUE5Qkw7QUErQlRDLFFBQUFBLGdCQUFnQixFQUFFLEtBL0JUO0FBZ0NUQyxRQUFBQSxTQUFTLEVBQUUsUUFoQ0Y7QUFpQ1RDLFFBQUFBLFVBQVUsRUFBRSxJQWpDSDtBQWtDVEMsUUFBQUEsSUFBSSxFQUFFLENBbENHO0FBbUNUQyxRQUFBQSxHQUFHLEVBQUUsS0FuQ0k7QUFvQ1RDLFFBQUFBLEtBQUssRUFBRSxFQXBDRTtBQXFDVEMsUUFBQUEsWUFBWSxFQUFFLENBckNMO0FBc0NUQyxRQUFBQSxZQUFZLEVBQUUsQ0F0Q0w7QUF1Q1RDLFFBQUFBLGNBQWMsRUFBRSxDQXZDUDtBQXdDVGxSLFFBQUFBLEtBQUssRUFBRSxHQXhDRTtBQXlDVG1SLFFBQUFBLEtBQUssRUFBRSxJQXpDRTtBQTBDVEMsUUFBQUEsWUFBWSxFQUFFLEtBMUNMO0FBMkNUQyxRQUFBQSxTQUFTLEVBQUUsSUEzQ0Y7QUE0Q1RDLFFBQUFBLGNBQWMsRUFBRSxDQTVDUDtBQTZDVEMsUUFBQUEsTUFBTSxFQUFFLElBN0NDO0FBOENUQyxRQUFBQSxZQUFZLEVBQUUsSUE5Q0w7QUErQ1RDLFFBQUFBLGFBQWEsRUFBRSxLQS9DTjtBQWdEVEMsUUFBQUEsUUFBUSxFQUFFLEtBaEREO0FBaURUQyxRQUFBQSxlQUFlLEVBQUUsS0FqRFI7QUFrRFRDLFFBQUFBLGNBQWMsRUFBRSxJQWxEUDtBQW1EVDdvRixRQUFBQSxNQUFNLEVBQUU7QUFuREMsT0FBYjtBQXNEQTAvRCxNQUFBQSxDQUFDLENBQUNvcEIsUUFBRixHQUFhO0FBQ1RDLFFBQUFBLFNBQVMsRUFBRSxLQURGO0FBRVQvakYsUUFBQUEsUUFBUSxFQUFFLEtBRkQ7QUFHVGdrRixRQUFBQSxhQUFhLEVBQUUsSUFITjtBQUlUQyxRQUFBQSxnQkFBZ0IsRUFBRSxDQUpUO0FBS1RDLFFBQUFBLFdBQVcsRUFBRSxJQUxKO0FBTVRDLFFBQUFBLFlBQVksRUFBRSxDQU5MO0FBT1RobEYsUUFBQUEsU0FBUyxFQUFFLENBUEY7QUFRVGlsRixRQUFBQSxLQUFLLEVBQUUsSUFSRTtBQVNUQyxRQUFBQSxTQUFTLEVBQUUsSUFURjtBQVVUQyxRQUFBQSxVQUFVLEVBQUUsSUFWSDtBQVdUQyxRQUFBQSxTQUFTLEVBQUUsQ0FYRjtBQVlUQyxRQUFBQSxVQUFVLEVBQUUsSUFaSDtBQWFUQyxRQUFBQSxVQUFVLEVBQUUsSUFiSDtBQWNUQyxRQUFBQSxTQUFTLEVBQUUsS0FkRjtBQWVUQyxRQUFBQSxVQUFVLEVBQUUsSUFmSDtBQWdCVEMsUUFBQUEsVUFBVSxFQUFFLElBaEJIO0FBaUJUQyxRQUFBQSxXQUFXLEVBQUUsSUFqQko7QUFrQlRDLFFBQUFBLE9BQU8sRUFBRSxJQWxCQTtBQW1CVEMsUUFBQUEsT0FBTyxFQUFFLEtBbkJBO0FBb0JUQyxRQUFBQSxXQUFXLEVBQUUsQ0FwQko7QUFxQlRDLFFBQUFBLFNBQVMsRUFBRSxJQXJCRjtBQXNCVEMsUUFBQUEsT0FBTyxFQUFFLEtBdEJBO0FBdUJUQyxRQUFBQSxLQUFLLEVBQUUsSUF2QkU7QUF3QlRDLFFBQUFBLFdBQVcsRUFBRSxFQXhCSjtBQXlCVEMsUUFBQUEsaUJBQWlCLEVBQUUsS0F6QlY7QUEwQlRDLFFBQUFBLFNBQVMsRUFBRTtBQTFCRixPQUFiO0FBNkJBNUUsTUFBQUEsQ0FBQyxDQUFDeDNCLE1BQUYsQ0FBU3dSLENBQVQsRUFBWUEsQ0FBQyxDQUFDb3BCLFFBQWQ7QUFFQXBwQixNQUFBQSxDQUFDLENBQUM2cUIsZ0JBQUYsR0FBcUIsSUFBckI7QUFDQTdxQixNQUFBQSxDQUFDLENBQUM4cUIsUUFBRixHQUFhLElBQWI7QUFDQTlxQixNQUFBQSxDQUFDLENBQUMrcUIsUUFBRixHQUFhLElBQWI7QUFDQS9xQixNQUFBQSxDQUFDLENBQUNnckIsV0FBRixHQUFnQixFQUFoQjtBQUNBaHJCLE1BQUFBLENBQUMsQ0FBQ2lyQixrQkFBRixHQUF1QixFQUF2QjtBQUNBanJCLE1BQUFBLENBQUMsQ0FBQ2tyQixjQUFGLEdBQW1CLEtBQW5CO0FBQ0FsckIsTUFBQUEsQ0FBQyxDQUFDbXJCLFFBQUYsR0FBYSxLQUFiO0FBQ0FuckIsTUFBQUEsQ0FBQyxDQUFDN2xFLFdBQUYsR0FBZ0IsS0FBaEI7QUFDQTZsRSxNQUFBQSxDQUFDLENBQUNwbEMsTUFBRixHQUFXLFFBQVg7QUFDQW9sQyxNQUFBQSxDQUFDLENBQUM5cEMsTUFBRixHQUFXLElBQVg7QUFDQThwQyxNQUFBQSxDQUFDLENBQUNvckIsWUFBRixHQUFpQixJQUFqQjtBQUNBcHJCLE1BQUFBLENBQUMsQ0FBQ2tvQixTQUFGLEdBQWMsSUFBZDtBQUNBbG9CLE1BQUFBLENBQUMsQ0FBQ3FyQixRQUFGLEdBQWEsQ0FBYjtBQUNBcnJCLE1BQUFBLENBQUMsQ0FBQ3NyQixXQUFGLEdBQWdCLElBQWhCO0FBQ0F0ckIsTUFBQUEsQ0FBQyxDQUFDdXJCLE9BQUYsR0FBWXZGLENBQUMsQ0FBQ2w5RixPQUFELENBQWI7QUFDQWszRSxNQUFBQSxDQUFDLENBQUN3ckIsWUFBRixHQUFpQixJQUFqQjtBQUNBeHJCLE1BQUFBLENBQUMsQ0FBQ3lyQixhQUFGLEdBQWtCLElBQWxCO0FBQ0F6ckIsTUFBQUEsQ0FBQyxDQUFDMHJCLGNBQUYsR0FBbUIsSUFBbkI7QUFDQTFyQixNQUFBQSxDQUFDLENBQUMyckIsZ0JBQUYsR0FBcUIsa0JBQXJCO0FBQ0EzckIsTUFBQUEsQ0FBQyxDQUFDNHJCLFdBQUYsR0FBZ0IsQ0FBaEI7QUFDQTVyQixNQUFBQSxDQUFDLENBQUM2ckIsV0FBRixHQUFnQixJQUFoQjtBQUVBeEYsTUFBQUEsWUFBWSxHQUFHTCxDQUFDLENBQUNsOUYsT0FBRCxDQUFELENBQVdILElBQVgsQ0FBZ0IsT0FBaEIsS0FBNEIsRUFBM0M7QUFFQXEzRSxNQUFBQSxDQUFDLENBQUN2UixPQUFGLEdBQVl1M0IsQ0FBQyxDQUFDeDNCLE1BQUYsQ0FBUyxFQUFULEVBQWF3UixDQUFDLENBQUM3NEUsUUFBZixFQUF5Qm00RixRQUF6QixFQUFtQytHLFlBQW5DLENBQVo7QUFFQXJtQixNQUFBQSxDQUFDLENBQUN5cEIsWUFBRixHQUFpQnpwQixDQUFDLENBQUN2UixPQUFGLENBQVVtNUIsWUFBM0I7QUFFQTVuQixNQUFBQSxDQUFDLENBQUN5akIsZ0JBQUYsR0FBcUJ6akIsQ0FBQyxDQUFDdlIsT0FBdkI7O0FBRUEsVUFBSSxPQUFPNThELFFBQVEsQ0FBQ2k2RixTQUFoQixLQUE4QixXQUFsQyxFQUErQztBQUMzQzlyQixRQUFBQSxDQUFDLENBQUNwbEMsTUFBRixHQUFXLFdBQVg7QUFDQW9sQyxRQUFBQSxDQUFDLENBQUMyckIsZ0JBQUYsR0FBcUIscUJBQXJCO0FBQ0gsT0FIRCxNQUdPLElBQUksT0FBTzk1RixRQUFRLENBQUNrNkYsWUFBaEIsS0FBaUMsV0FBckMsRUFBa0Q7QUFDckQvckIsUUFBQUEsQ0FBQyxDQUFDcGxDLE1BQUYsR0FBVyxjQUFYO0FBQ0FvbEMsUUFBQUEsQ0FBQyxDQUFDMnJCLGdCQUFGLEdBQXFCLHdCQUFyQjtBQUNIOztBQUVEM3JCLE1BQUFBLENBQUMsQ0FBQ2dzQixRQUFGLEdBQWFoRyxDQUFDLENBQUNULEtBQUYsQ0FBUXZsQixDQUFDLENBQUNnc0IsUUFBVixFQUFvQmhzQixDQUFwQixDQUFiO0FBQ0FBLE1BQUFBLENBQUMsQ0FBQ2lzQixhQUFGLEdBQWtCakcsQ0FBQyxDQUFDVCxLQUFGLENBQVF2bEIsQ0FBQyxDQUFDaXNCLGFBQVYsRUFBeUJqc0IsQ0FBekIsQ0FBbEI7QUFDQUEsTUFBQUEsQ0FBQyxDQUFDa3NCLGdCQUFGLEdBQXFCbEcsQ0FBQyxDQUFDVCxLQUFGLENBQVF2bEIsQ0FBQyxDQUFDa3NCLGdCQUFWLEVBQTRCbHNCLENBQTVCLENBQXJCO0FBQ0FBLE1BQUFBLENBQUMsQ0FBQ21zQixXQUFGLEdBQWdCbkcsQ0FBQyxDQUFDVCxLQUFGLENBQVF2bEIsQ0FBQyxDQUFDbXNCLFdBQVYsRUFBdUJuc0IsQ0FBdkIsQ0FBaEI7QUFDQUEsTUFBQUEsQ0FBQyxDQUFDb3NCLFlBQUYsR0FBaUJwRyxDQUFDLENBQUNULEtBQUYsQ0FBUXZsQixDQUFDLENBQUNvc0IsWUFBVixFQUF3QnBzQixDQUF4QixDQUFqQjtBQUNBQSxNQUFBQSxDQUFDLENBQUNxc0IsYUFBRixHQUFrQnJHLENBQUMsQ0FBQ1QsS0FBRixDQUFRdmxCLENBQUMsQ0FBQ3FzQixhQUFWLEVBQXlCcnNCLENBQXpCLENBQWxCO0FBQ0FBLE1BQUFBLENBQUMsQ0FBQ3NzQixXQUFGLEdBQWdCdEcsQ0FBQyxDQUFDVCxLQUFGLENBQVF2bEIsQ0FBQyxDQUFDc3NCLFdBQVYsRUFBdUJ0c0IsQ0FBdkIsQ0FBaEI7QUFDQUEsTUFBQUEsQ0FBQyxDQUFDdXNCLFlBQUYsR0FBaUJ2RyxDQUFDLENBQUNULEtBQUYsQ0FBUXZsQixDQUFDLENBQUN1c0IsWUFBVixFQUF3QnZzQixDQUF4QixDQUFqQjtBQUNBQSxNQUFBQSxDQUFDLENBQUN3c0IsV0FBRixHQUFnQnhHLENBQUMsQ0FBQ1QsS0FBRixDQUFRdmxCLENBQUMsQ0FBQ3dzQixXQUFWLEVBQXVCeHNCLENBQXZCLENBQWhCO0FBQ0FBLE1BQUFBLENBQUMsQ0FBQ3lzQixVQUFGLEdBQWV6RyxDQUFDLENBQUNULEtBQUYsQ0FBUXZsQixDQUFDLENBQUN5c0IsVUFBVixFQUFzQnpzQixDQUF0QixDQUFmO0FBRUFBLE1BQUFBLENBQUMsQ0FBQ29tQixXQUFGLEdBQWdCQSxXQUFXLEVBQTNCLENBMUk4QixDQTRJOUI7QUFDQTtBQUNBOztBQUNBcG1CLE1BQUFBLENBQUMsQ0FBQzBzQixRQUFGLEdBQWEsMkJBQWI7O0FBR0Exc0IsTUFBQUEsQ0FBQyxDQUFDMnNCLG1CQUFGOztBQUNBM3NCLE1BQUFBLENBQUMsQ0FBQ2psRCxJQUFGLENBQU8sSUFBUDtBQUVIOztBQUVELFdBQU9vckUsS0FBUDtBQUVILEdBN0pRLEVBQVQ7O0FBK0pBQSxFQUFBQSxLQUFLLENBQUN4akcsU0FBTixDQUFnQmlxRyxXQUFoQixHQUE4QixZQUFXO0FBQ3JDLFFBQUk1c0IsQ0FBQyxHQUFHLElBQVI7O0FBRUFBLElBQUFBLENBQUMsQ0FBQ21xQixXQUFGLENBQWM1ekIsSUFBZCxDQUFtQixlQUFuQixFQUFvQ3ZzRCxJQUFwQyxDQUF5QztBQUNyQyxxQkFBZTtBQURzQixLQUF6QyxFQUVHdXNELElBRkgsQ0FFUSwwQkFGUixFQUVvQ3ZzRCxJQUZwQyxDQUV5QztBQUNyQyxrQkFBWTtBQUR5QixLQUZ6QztBQU1ILEdBVEQ7O0FBV0FtOEUsRUFBQUEsS0FBSyxDQUFDeGpHLFNBQU4sQ0FBZ0JrcUcsUUFBaEIsR0FBMkIxRyxLQUFLLENBQUN4akcsU0FBTixDQUFnQm1xRyxRQUFoQixHQUEyQixVQUFTQyxNQUFULEVBQWlCNWpGLEtBQWpCLEVBQXdCNmpGLFNBQXhCLEVBQW1DO0FBRXJGLFFBQUlodEIsQ0FBQyxHQUFHLElBQVI7O0FBRUEsUUFBSSxPQUFPNzJELEtBQVAsS0FBa0IsU0FBdEIsRUFBaUM7QUFDN0I2akYsTUFBQUEsU0FBUyxHQUFHN2pGLEtBQVo7QUFDQUEsTUFBQUEsS0FBSyxHQUFHLElBQVI7QUFDSCxLQUhELE1BR08sSUFBSUEsS0FBSyxHQUFHLENBQVIsSUFBY0EsS0FBSyxJQUFJNjJELENBQUMsQ0FBQ2lxQixVQUE3QixFQUEwQztBQUM3QyxhQUFPLEtBQVA7QUFDSDs7QUFFRGpxQixJQUFBQSxDQUFDLENBQUNpdEIsTUFBRjs7QUFFQSxRQUFJLE9BQU85akYsS0FBUCxLQUFrQixRQUF0QixFQUFnQztBQUM1QixVQUFJQSxLQUFLLEtBQUssQ0FBVixJQUFlNjJELENBQUMsQ0FBQ29xQixPQUFGLENBQVU3aUcsTUFBVixLQUFxQixDQUF4QyxFQUEyQztBQUN2Q3krRixRQUFBQSxDQUFDLENBQUMrRyxNQUFELENBQUQsQ0FBVWxkLFFBQVYsQ0FBbUI3UCxDQUFDLENBQUNtcUIsV0FBckI7QUFDSCxPQUZELE1BRU8sSUFBSTZDLFNBQUosRUFBZTtBQUNsQmhILFFBQUFBLENBQUMsQ0FBQytHLE1BQUQsQ0FBRCxDQUFVdGdGLFlBQVYsQ0FBdUJ1ekQsQ0FBQyxDQUFDb3FCLE9BQUYsQ0FBVWw4QixFQUFWLENBQWEva0QsS0FBYixDQUF2QjtBQUNILE9BRk0sTUFFQTtBQUNINjhFLFFBQUFBLENBQUMsQ0FBQytHLE1BQUQsQ0FBRCxDQUFVaGQsV0FBVixDQUFzQi9QLENBQUMsQ0FBQ29xQixPQUFGLENBQVVsOEIsRUFBVixDQUFhL2tELEtBQWIsQ0FBdEI7QUFDSDtBQUNKLEtBUkQsTUFRTztBQUNILFVBQUk2akYsU0FBUyxLQUFLLElBQWxCLEVBQXdCO0FBQ3BCaEgsUUFBQUEsQ0FBQyxDQUFDK0csTUFBRCxDQUFELENBQVVqZCxTQUFWLENBQW9COVAsQ0FBQyxDQUFDbXFCLFdBQXRCO0FBQ0gsT0FGRCxNQUVPO0FBQ0huRSxRQUFBQSxDQUFDLENBQUMrRyxNQUFELENBQUQsQ0FBVWxkLFFBQVYsQ0FBbUI3UCxDQUFDLENBQUNtcUIsV0FBckI7QUFDSDtBQUNKOztBQUVEbnFCLElBQUFBLENBQUMsQ0FBQ29xQixPQUFGLEdBQVlwcUIsQ0FBQyxDQUFDbXFCLFdBQUYsQ0FBYzNpRyxRQUFkLENBQXVCLEtBQUtpbkUsT0FBTCxDQUFhNjVCLEtBQXBDLENBQVo7O0FBRUF0b0IsSUFBQUEsQ0FBQyxDQUFDbXFCLFdBQUYsQ0FBYzNpRyxRQUFkLENBQXVCLEtBQUtpbkUsT0FBTCxDQUFhNjVCLEtBQXBDLEVBQTJDaFosTUFBM0M7O0FBRUF0UCxJQUFBQSxDQUFDLENBQUNtcUIsV0FBRixDQUFjNWEsTUFBZCxDQUFxQnZQLENBQUMsQ0FBQ29xQixPQUF2Qjs7QUFFQXBxQixJQUFBQSxDQUFDLENBQUNvcUIsT0FBRixDQUFVbmdELElBQVYsQ0FBZSxVQUFTOWdDLEtBQVQsRUFBZ0JyZ0IsT0FBaEIsRUFBeUI7QUFDcENrOUYsTUFBQUEsQ0FBQyxDQUFDbDlGLE9BQUQsQ0FBRCxDQUFXa2hCLElBQVgsQ0FBZ0Isa0JBQWhCLEVBQW9DYixLQUFwQztBQUNILEtBRkQ7O0FBSUE2MkQsSUFBQUEsQ0FBQyxDQUFDd3JCLFlBQUYsR0FBaUJ4ckIsQ0FBQyxDQUFDb3FCLE9BQW5COztBQUVBcHFCLElBQUFBLENBQUMsQ0FBQ2t0QixNQUFGO0FBRUgsR0EzQ0Q7O0FBNkNBL0csRUFBQUEsS0FBSyxDQUFDeGpHLFNBQU4sQ0FBZ0J3cUcsYUFBaEIsR0FBZ0MsWUFBVztBQUN2QyxRQUFJbnRCLENBQUMsR0FBRyxJQUFSOztBQUNBLFFBQUlBLENBQUMsQ0FBQ3ZSLE9BQUYsQ0FBVSs1QixZQUFWLEtBQTJCLENBQTNCLElBQWdDeG9CLENBQUMsQ0FBQ3ZSLE9BQUYsQ0FBVTgzQixjQUFWLEtBQTZCLElBQTdELElBQXFFdm1CLENBQUMsQ0FBQ3ZSLE9BQUYsQ0FBVXc2QixRQUFWLEtBQXVCLEtBQWhHLEVBQXVHO0FBQ25HLFVBQUltRSxZQUFZLEdBQUdwdEIsQ0FBQyxDQUFDb3FCLE9BQUYsQ0FBVWw4QixFQUFWLENBQWE4UixDQUFDLENBQUN5cEIsWUFBZixFQUE2QjRELFdBQTdCLENBQXlDLElBQXpDLENBQW5COztBQUNBcnRCLE1BQUFBLENBQUMsQ0FBQ3lxQixLQUFGLENBQVFsdEYsT0FBUixDQUFnQjtBQUNaMVEsUUFBQUEsTUFBTSxFQUFFdWdHO0FBREksT0FBaEIsRUFFR3B0QixDQUFDLENBQUN2UixPQUFGLENBQVU4b0IsS0FGYjtBQUdIO0FBQ0osR0FSRDs7QUFVQTRPLEVBQUFBLEtBQUssQ0FBQ3hqRyxTQUFOLENBQWdCMnFHLFlBQWhCLEdBQStCLFVBQVNDLFVBQVQsRUFBcUI1aUcsUUFBckIsRUFBK0I7QUFFMUQsUUFBSTZpRyxTQUFTLEdBQUcsRUFBaEI7QUFBQSxRQUNJeHRCLENBQUMsR0FBRyxJQURSOztBQUdBQSxJQUFBQSxDQUFDLENBQUNtdEIsYUFBRjs7QUFFQSxRQUFJbnRCLENBQUMsQ0FBQ3ZSLE9BQUYsQ0FBVTQ1QixHQUFWLEtBQWtCLElBQWxCLElBQTBCcm9CLENBQUMsQ0FBQ3ZSLE9BQUYsQ0FBVXc2QixRQUFWLEtBQXVCLEtBQXJELEVBQTREO0FBQ3hEc0UsTUFBQUEsVUFBVSxHQUFHLENBQUNBLFVBQWQ7QUFDSDs7QUFDRCxRQUFJdnRCLENBQUMsQ0FBQzJxQixpQkFBRixLQUF3QixLQUE1QixFQUFtQztBQUMvQixVQUFJM3FCLENBQUMsQ0FBQ3ZSLE9BQUYsQ0FBVXc2QixRQUFWLEtBQXVCLEtBQTNCLEVBQWtDO0FBQzlCanBCLFFBQUFBLENBQUMsQ0FBQ21xQixXQUFGLENBQWM1c0YsT0FBZCxDQUFzQjtBQUNsQmhSLFVBQUFBLElBQUksRUFBRWdoRztBQURZLFNBQXRCLEVBRUd2dEIsQ0FBQyxDQUFDdlIsT0FBRixDQUFVOG9CLEtBRmIsRUFFb0J2WCxDQUFDLENBQUN2UixPQUFGLENBQVVxbUIsTUFGOUIsRUFFc0NucUYsUUFGdEM7QUFHSCxPQUpELE1BSU87QUFDSHExRSxRQUFBQSxDQUFDLENBQUNtcUIsV0FBRixDQUFjNXNGLE9BQWQsQ0FBc0I7QUFDbEIvUSxVQUFBQSxHQUFHLEVBQUUrZ0c7QUFEYSxTQUF0QixFQUVHdnRCLENBQUMsQ0FBQ3ZSLE9BQUYsQ0FBVThvQixLQUZiLEVBRW9CdlgsQ0FBQyxDQUFDdlIsT0FBRixDQUFVcW1CLE1BRjlCLEVBRXNDbnFGLFFBRnRDO0FBR0g7QUFFSixLQVhELE1BV087QUFFSCxVQUFJcTFFLENBQUMsQ0FBQ2tyQixjQUFGLEtBQXFCLEtBQXpCLEVBQWdDO0FBQzVCLFlBQUlsckIsQ0FBQyxDQUFDdlIsT0FBRixDQUFVNDVCLEdBQVYsS0FBa0IsSUFBdEIsRUFBNEI7QUFDeEJyb0IsVUFBQUEsQ0FBQyxDQUFDd3BCLFdBQUYsR0FBZ0IsQ0FBRXhwQixDQUFDLENBQUN3cEIsV0FBcEI7QUFDSDs7QUFDRHhELFFBQUFBLENBQUMsQ0FBQztBQUNFeUgsVUFBQUEsU0FBUyxFQUFFenRCLENBQUMsQ0FBQ3dwQjtBQURmLFNBQUQsQ0FBRCxDQUVHanNGLE9BRkgsQ0FFVztBQUNQa3dGLFVBQUFBLFNBQVMsRUFBRUY7QUFESixTQUZYLEVBSUc7QUFDQzlrRyxVQUFBQSxRQUFRLEVBQUV1M0UsQ0FBQyxDQUFDdlIsT0FBRixDQUFVOG9CLEtBRHJCO0FBRUN6QyxVQUFBQSxNQUFNLEVBQUU5VSxDQUFDLENBQUN2UixPQUFGLENBQVVxbUIsTUFGbkI7QUFHQ00sVUFBQUEsSUFBSSxFQUFFLGNBQVNodkYsR0FBVCxFQUFjO0FBQ2hCQSxZQUFBQSxHQUFHLEdBQUduQixJQUFJLENBQUMrc0IsSUFBTCxDQUFVNXJCLEdBQVYsQ0FBTjs7QUFDQSxnQkFBSTQ1RSxDQUFDLENBQUN2UixPQUFGLENBQVV3NkIsUUFBVixLQUF1QixLQUEzQixFQUFrQztBQUM5QnVFLGNBQUFBLFNBQVMsQ0FBQ3h0QixDQUFDLENBQUM4cUIsUUFBSCxDQUFULEdBQXdCLGVBQ3BCMWtHLEdBRG9CLEdBQ2QsVUFEVjs7QUFFQTQ1RSxjQUFBQSxDQUFDLENBQUNtcUIsV0FBRixDQUFjNTlELEdBQWQsQ0FBa0JpaEUsU0FBbEI7QUFDSCxhQUpELE1BSU87QUFDSEEsY0FBQUEsU0FBUyxDQUFDeHRCLENBQUMsQ0FBQzhxQixRQUFILENBQVQsR0FBd0IsbUJBQ3BCMWtHLEdBRG9CLEdBQ2QsS0FEVjs7QUFFQTQ1RSxjQUFBQSxDQUFDLENBQUNtcUIsV0FBRixDQUFjNTlELEdBQWQsQ0FBa0JpaEUsU0FBbEI7QUFDSDtBQUNKLFdBZEY7QUFlQ3JXLFVBQUFBLFFBQVEsRUFBRSxvQkFBVztBQUNqQixnQkFBSXhzRixRQUFKLEVBQWM7QUFDVkEsY0FBQUEsUUFBUSxDQUFDNEYsSUFBVDtBQUNIO0FBQ0o7QUFuQkYsU0FKSDtBQTBCSCxPQTlCRCxNQThCTztBQUVIeXZFLFFBQUFBLENBQUMsQ0FBQzB0QixlQUFGOztBQUNBSCxRQUFBQSxVQUFVLEdBQUd0b0csSUFBSSxDQUFDK3NCLElBQUwsQ0FBVXU3RSxVQUFWLENBQWI7O0FBRUEsWUFBSXZ0QixDQUFDLENBQUN2UixPQUFGLENBQVV3NkIsUUFBVixLQUF1QixLQUEzQixFQUFrQztBQUM5QnVFLFVBQUFBLFNBQVMsQ0FBQ3h0QixDQUFDLENBQUM4cUIsUUFBSCxDQUFULEdBQXdCLGlCQUFpQnlDLFVBQWpCLEdBQThCLGVBQXREO0FBQ0gsU0FGRCxNQUVPO0FBQ0hDLFVBQUFBLFNBQVMsQ0FBQ3h0QixDQUFDLENBQUM4cUIsUUFBSCxDQUFULEdBQXdCLHFCQUFxQnlDLFVBQXJCLEdBQWtDLFVBQTFEO0FBQ0g7O0FBQ0R2dEIsUUFBQUEsQ0FBQyxDQUFDbXFCLFdBQUYsQ0FBYzU5RCxHQUFkLENBQWtCaWhFLFNBQWxCOztBQUVBLFlBQUk3aUcsUUFBSixFQUFjO0FBQ1ZtMkIsVUFBQUEsVUFBVSxDQUFDLFlBQVc7QUFFbEJrL0MsWUFBQUEsQ0FBQyxDQUFDMnRCLGlCQUFGOztBQUVBaGpHLFlBQUFBLFFBQVEsQ0FBQzRGLElBQVQ7QUFDSCxXQUxTLEVBS1B5dkUsQ0FBQyxDQUFDdlIsT0FBRixDQUFVOG9CLEtBTEgsQ0FBVjtBQU1IO0FBRUo7QUFFSjtBQUVKLEdBOUVEOztBQWdGQTRPLEVBQUFBLEtBQUssQ0FBQ3hqRyxTQUFOLENBQWdCaXJHLFlBQWhCLEdBQStCLFlBQVc7QUFFdEMsUUFBSTV0QixDQUFDLEdBQUcsSUFBUjtBQUFBLFFBQ0kybUIsUUFBUSxHQUFHM21CLENBQUMsQ0FBQ3ZSLE9BQUYsQ0FBVWs0QixRQUR6Qjs7QUFHQSxRQUFLQSxRQUFRLElBQUlBLFFBQVEsS0FBSyxJQUE5QixFQUFxQztBQUNqQ0EsTUFBQUEsUUFBUSxHQUFHWCxDQUFDLENBQUNXLFFBQUQsQ0FBRCxDQUFZaG9CLEdBQVosQ0FBZ0JxQixDQUFDLENBQUN1ckIsT0FBbEIsQ0FBWDtBQUNIOztBQUVELFdBQU81RSxRQUFQO0FBRUgsR0FYRDs7QUFhQVIsRUFBQUEsS0FBSyxDQUFDeGpHLFNBQU4sQ0FBZ0Jna0csUUFBaEIsR0FBMkIsVUFBU3g5RSxLQUFULEVBQWdCO0FBRXZDLFFBQUk2MkQsQ0FBQyxHQUFHLElBQVI7QUFBQSxRQUNJMm1CLFFBQVEsR0FBRzNtQixDQUFDLENBQUM0dEIsWUFBRixFQURmOztBQUdBLFFBQUtqSCxRQUFRLEtBQUssSUFBYixJQUFxQixRQUFPQSxRQUFQLE1BQW9CLFFBQTlDLEVBQXlEO0FBQ3JEQSxNQUFBQSxRQUFRLENBQUMxOEMsSUFBVCxDQUFjLFlBQVc7QUFDckIsWUFBSWxnRCxNQUFNLEdBQUdpOEYsQ0FBQyxDQUFDLElBQUQsQ0FBRCxDQUFRNkgsS0FBUixDQUFjLFVBQWQsQ0FBYjs7QUFDQSxZQUFHLENBQUM5akcsTUFBTSxDQUFDNmdHLFNBQVgsRUFBc0I7QUFDbEI3Z0csVUFBQUEsTUFBTSxDQUFDK2pHLFlBQVAsQ0FBb0Iza0YsS0FBcEIsRUFBMkIsSUFBM0I7QUFDSDtBQUNKLE9BTEQ7QUFNSDtBQUVKLEdBZEQ7O0FBZ0JBZzlFLEVBQUFBLEtBQUssQ0FBQ3hqRyxTQUFOLENBQWdCK3FHLGVBQWhCLEdBQWtDLFVBQVNwRixLQUFULEVBQWdCO0FBRTlDLFFBQUl0b0IsQ0FBQyxHQUFHLElBQVI7QUFBQSxRQUNJK3RCLFVBQVUsR0FBRyxFQURqQjs7QUFHQSxRQUFJL3RCLENBQUMsQ0FBQ3ZSLE9BQUYsQ0FBVSs0QixJQUFWLEtBQW1CLEtBQXZCLEVBQThCO0FBQzFCdUcsTUFBQUEsVUFBVSxDQUFDL3RCLENBQUMsQ0FBQzByQixjQUFILENBQVYsR0FBK0IxckIsQ0FBQyxDQUFDeXJCLGFBQUYsR0FBa0IsR0FBbEIsR0FBd0J6ckIsQ0FBQyxDQUFDdlIsT0FBRixDQUFVOG9CLEtBQWxDLEdBQTBDLEtBQTFDLEdBQWtEdlgsQ0FBQyxDQUFDdlIsT0FBRixDQUFVeTRCLE9BQTNGO0FBQ0gsS0FGRCxNQUVPO0FBQ0g2RyxNQUFBQSxVQUFVLENBQUMvdEIsQ0FBQyxDQUFDMHJCLGNBQUgsQ0FBVixHQUErQixhQUFhMXJCLENBQUMsQ0FBQ3ZSLE9BQUYsQ0FBVThvQixLQUF2QixHQUErQixLQUEvQixHQUF1Q3ZYLENBQUMsQ0FBQ3ZSLE9BQUYsQ0FBVXk0QixPQUFoRjtBQUNIOztBQUVELFFBQUlsbkIsQ0FBQyxDQUFDdlIsT0FBRixDQUFVKzRCLElBQVYsS0FBbUIsS0FBdkIsRUFBOEI7QUFDMUJ4bkIsTUFBQUEsQ0FBQyxDQUFDbXFCLFdBQUYsQ0FBYzU5RCxHQUFkLENBQWtCd2hFLFVBQWxCO0FBQ0gsS0FGRCxNQUVPO0FBQ0gvdEIsTUFBQUEsQ0FBQyxDQUFDb3FCLE9BQUYsQ0FBVWw4QixFQUFWLENBQWFvNkIsS0FBYixFQUFvQi83RCxHQUFwQixDQUF3QndoRSxVQUF4QjtBQUNIO0FBRUosR0FqQkQ7O0FBbUJBNUgsRUFBQUEsS0FBSyxDQUFDeGpHLFNBQU4sQ0FBZ0JxcEcsUUFBaEIsR0FBMkIsWUFBVztBQUVsQyxRQUFJaHNCLENBQUMsR0FBRyxJQUFSOztBQUVBQSxJQUFBQSxDQUFDLENBQUNpc0IsYUFBRjs7QUFFQSxRQUFLanNCLENBQUMsQ0FBQ2lxQixVQUFGLEdBQWVqcUIsQ0FBQyxDQUFDdlIsT0FBRixDQUFVKzVCLFlBQTlCLEVBQTZDO0FBQ3pDeG9CLE1BQUFBLENBQUMsQ0FBQ3NwQixhQUFGLEdBQWtCM3VELFdBQVcsQ0FBRXFsQyxDQUFDLENBQUNrc0IsZ0JBQUosRUFBc0Jsc0IsQ0FBQyxDQUFDdlIsT0FBRixDQUFVczRCLGFBQWhDLENBQTdCO0FBQ0g7QUFFSixHQVZEOztBQVlBWixFQUFBQSxLQUFLLENBQUN4akcsU0FBTixDQUFnQnNwRyxhQUFoQixHQUFnQyxZQUFXO0FBRXZDLFFBQUlqc0IsQ0FBQyxHQUFHLElBQVI7O0FBRUEsUUFBSUEsQ0FBQyxDQUFDc3BCLGFBQU4sRUFBcUI7QUFDakJqdkQsTUFBQUEsYUFBYSxDQUFDMmxDLENBQUMsQ0FBQ3NwQixhQUFILENBQWI7QUFDSDtBQUVKLEdBUkQ7O0FBVUFuRCxFQUFBQSxLQUFLLENBQUN4akcsU0FBTixDQUFnQnVwRyxnQkFBaEIsR0FBbUMsWUFBVztBQUUxQyxRQUFJbHNCLENBQUMsR0FBRyxJQUFSO0FBQUEsUUFDSWd1QixPQUFPLEdBQUdodUIsQ0FBQyxDQUFDeXBCLFlBQUYsR0FBaUJ6cEIsQ0FBQyxDQUFDdlIsT0FBRixDQUFVZzZCLGNBRHpDOztBQUdBLFFBQUssQ0FBQ3pvQixDQUFDLENBQUM5cEMsTUFBSCxJQUFhLENBQUM4cEMsQ0FBQyxDQUFDN2xFLFdBQWhCLElBQStCLENBQUM2bEUsQ0FBQyxDQUFDbXJCLFFBQXZDLEVBQWtEO0FBRTlDLFVBQUtuckIsQ0FBQyxDQUFDdlIsT0FBRixDQUFVazVCLFFBQVYsS0FBdUIsS0FBNUIsRUFBb0M7QUFFaEMsWUFBSzNuQixDQUFDLENBQUN2N0QsU0FBRixLQUFnQixDQUFoQixJQUF1QnU3RCxDQUFDLENBQUN5cEIsWUFBRixHQUFpQixDQUFuQixLQUE2QnpwQixDQUFDLENBQUNpcUIsVUFBRixHQUFlLENBQXRFLEVBQTJFO0FBQ3ZFanFCLFVBQUFBLENBQUMsQ0FBQ3Y3RCxTQUFGLEdBQWMsQ0FBZDtBQUNILFNBRkQsTUFJSyxJQUFLdTdELENBQUMsQ0FBQ3Y3RCxTQUFGLEtBQWdCLENBQXJCLEVBQXlCO0FBRTFCdXBGLFVBQUFBLE9BQU8sR0FBR2h1QixDQUFDLENBQUN5cEIsWUFBRixHQUFpQnpwQixDQUFDLENBQUN2UixPQUFGLENBQVVnNkIsY0FBckM7O0FBRUEsY0FBS3pvQixDQUFDLENBQUN5cEIsWUFBRixHQUFpQixDQUFqQixLQUF1QixDQUE1QixFQUFnQztBQUM1QnpwQixZQUFBQSxDQUFDLENBQUN2N0QsU0FBRixHQUFjLENBQWQ7QUFDSDtBQUVKO0FBRUo7O0FBRUR1N0QsTUFBQUEsQ0FBQyxDQUFDOHRCLFlBQUYsQ0FBZ0JFLE9BQWhCO0FBRUg7QUFFSixHQTdCRDs7QUErQkE3SCxFQUFBQSxLQUFLLENBQUN4akcsU0FBTixDQUFnQnNyRyxXQUFoQixHQUE4QixZQUFXO0FBRXJDLFFBQUlqdUIsQ0FBQyxHQUFHLElBQVI7O0FBRUEsUUFBSUEsQ0FBQyxDQUFDdlIsT0FBRixDQUFVaTRCLE1BQVYsS0FBcUIsSUFBekIsRUFBZ0M7QUFFNUIxbUIsTUFBQUEsQ0FBQyxDQUFDK3BCLFVBQUYsR0FBZS9ELENBQUMsQ0FBQ2htQixDQUFDLENBQUN2UixPQUFGLENBQVVtNEIsU0FBWCxDQUFELENBQXVCak4sUUFBdkIsQ0FBZ0MsYUFBaEMsQ0FBZjtBQUNBM1osTUFBQUEsQ0FBQyxDQUFDOHBCLFVBQUYsR0FBZTlELENBQUMsQ0FBQ2htQixDQUFDLENBQUN2UixPQUFGLENBQVVvNEIsU0FBWCxDQUFELENBQXVCbE4sUUFBdkIsQ0FBZ0MsYUFBaEMsQ0FBZjs7QUFFQSxVQUFJM1osQ0FBQyxDQUFDaXFCLFVBQUYsR0FBZWpxQixDQUFDLENBQUN2UixPQUFGLENBQVUrNUIsWUFBN0IsRUFBNEM7QUFFeEN4b0IsUUFBQUEsQ0FBQyxDQUFDK3BCLFVBQUYsQ0FBYWpRLFdBQWIsQ0FBeUIsY0FBekIsRUFBeUNoQixVQUF6QyxDQUFvRCxzQkFBcEQ7O0FBQ0E5WSxRQUFBQSxDQUFDLENBQUM4cEIsVUFBRixDQUFhaFEsV0FBYixDQUF5QixjQUF6QixFQUF5Q2hCLFVBQXpDLENBQW9ELHNCQUFwRDs7QUFFQSxZQUFJOVksQ0FBQyxDQUFDMHNCLFFBQUYsQ0FBVzk3RixJQUFYLENBQWdCb3ZFLENBQUMsQ0FBQ3ZSLE9BQUYsQ0FBVW00QixTQUExQixDQUFKLEVBQTBDO0FBQ3RDNW1CLFVBQUFBLENBQUMsQ0FBQytwQixVQUFGLENBQWFqYSxTQUFiLENBQXVCOVAsQ0FBQyxDQUFDdlIsT0FBRixDQUFVKzNCLFlBQWpDO0FBQ0g7O0FBRUQsWUFBSXhtQixDQUFDLENBQUMwc0IsUUFBRixDQUFXOTdGLElBQVgsQ0FBZ0JvdkUsQ0FBQyxDQUFDdlIsT0FBRixDQUFVbzRCLFNBQTFCLENBQUosRUFBMEM7QUFDdEM3bUIsVUFBQUEsQ0FBQyxDQUFDOHBCLFVBQUYsQ0FBYWphLFFBQWIsQ0FBc0I3UCxDQUFDLENBQUN2UixPQUFGLENBQVUrM0IsWUFBaEM7QUFDSDs7QUFFRCxZQUFJeG1CLENBQUMsQ0FBQ3ZSLE9BQUYsQ0FBVWs1QixRQUFWLEtBQXVCLElBQTNCLEVBQWlDO0FBQzdCM25CLFVBQUFBLENBQUMsQ0FBQytwQixVQUFGLENBQ0twUSxRQURMLENBQ2MsZ0JBRGQsRUFFSzN2RSxJQUZMLENBRVUsZUFGVixFQUUyQixNQUYzQjtBQUdIO0FBRUosT0FuQkQsTUFtQk87QUFFSGcyRCxRQUFBQSxDQUFDLENBQUMrcEIsVUFBRixDQUFhOWhHLEdBQWIsQ0FBa0IrM0UsQ0FBQyxDQUFDOHBCLFVBQXBCLEVBRUtuUSxRQUZMLENBRWMsY0FGZCxFQUdLM3ZFLElBSEwsQ0FHVTtBQUNGLDJCQUFpQixNQURmO0FBRUYsc0JBQVk7QUFGVixTQUhWO0FBUUg7QUFFSjtBQUVKLEdBMUNEOztBQTRDQW04RSxFQUFBQSxLQUFLLENBQUN4akcsU0FBTixDQUFnQnVyRyxTQUFoQixHQUE0QixZQUFXO0FBRW5DLFFBQUlsdUIsQ0FBQyxHQUFHLElBQVI7QUFBQSxRQUNJMTRFLENBREo7QUFBQSxRQUNPNm1HLEdBRFA7O0FBR0EsUUFBSW51QixDQUFDLENBQUN2UixPQUFGLENBQVU0NEIsSUFBVixLQUFtQixJQUFuQixJQUEyQnJuQixDQUFDLENBQUNpcUIsVUFBRixHQUFlanFCLENBQUMsQ0FBQ3ZSLE9BQUYsQ0FBVSs1QixZQUF4RCxFQUFzRTtBQUVsRXhvQixNQUFBQSxDQUFDLENBQUN1ckIsT0FBRixDQUFVNVIsUUFBVixDQUFtQixjQUFuQjs7QUFFQXdVLE1BQUFBLEdBQUcsR0FBR25JLENBQUMsQ0FBQyxRQUFELENBQUQsQ0FBWXJNLFFBQVosQ0FBcUIzWixDQUFDLENBQUN2UixPQUFGLENBQVU2NEIsU0FBL0IsQ0FBTjs7QUFFQSxXQUFLaGdHLENBQUMsR0FBRyxDQUFULEVBQVlBLENBQUMsSUFBSTA0RSxDQUFDLENBQUNvdUIsV0FBRixFQUFqQixFQUFrQzltRyxDQUFDLElBQUksQ0FBdkMsRUFBMEM7QUFDdEM2bUcsUUFBQUEsR0FBRyxDQUFDNWUsTUFBSixDQUFXeVcsQ0FBQyxDQUFDLFFBQUQsQ0FBRCxDQUFZelcsTUFBWixDQUFtQnZQLENBQUMsQ0FBQ3ZSLE9BQUYsQ0FBVTA0QixZQUFWLENBQXVCNTJGLElBQXZCLENBQTRCLElBQTVCLEVBQWtDeXZFLENBQWxDLEVBQXFDMTRFLENBQXJDLENBQW5CLENBQVg7QUFDSDs7QUFFRDA0RSxNQUFBQSxDQUFDLENBQUMwcEIsS0FBRixHQUFVeUUsR0FBRyxDQUFDdGUsUUFBSixDQUFhN1AsQ0FBQyxDQUFDdlIsT0FBRixDQUFVZzRCLFVBQXZCLENBQVY7O0FBRUF6bUIsTUFBQUEsQ0FBQyxDQUFDMHBCLEtBQUYsQ0FBUW56QixJQUFSLENBQWEsSUFBYixFQUFtQnhnRCxLQUFuQixHQUEyQjRqRSxRQUEzQixDQUFvQyxjQUFwQztBQUVIO0FBRUosR0FyQkQ7O0FBdUJBd00sRUFBQUEsS0FBSyxDQUFDeGpHLFNBQU4sQ0FBZ0IwckcsUUFBaEIsR0FBMkIsWUFBVztBQUVsQyxRQUFJcnVCLENBQUMsR0FBRyxJQUFSOztBQUVBQSxJQUFBQSxDQUFDLENBQUNvcUIsT0FBRixHQUNJcHFCLENBQUMsQ0FBQ3VyQixPQUFGLENBQ0svakcsUUFETCxDQUNldzRFLENBQUMsQ0FBQ3ZSLE9BQUYsQ0FBVTY1QixLQUFWLEdBQWtCLHFCQURqQyxFQUVLM08sUUFGTCxDQUVjLGFBRmQsQ0FESjtBQUtBM1osSUFBQUEsQ0FBQyxDQUFDaXFCLFVBQUYsR0FBZWpxQixDQUFDLENBQUNvcUIsT0FBRixDQUFVN2lHLE1BQXpCOztBQUVBeTRFLElBQUFBLENBQUMsQ0FBQ29xQixPQUFGLENBQVVuZ0QsSUFBVixDQUFlLFVBQVM5Z0MsS0FBVCxFQUFnQnJnQixPQUFoQixFQUF5QjtBQUNwQ2s5RixNQUFBQSxDQUFDLENBQUNsOUYsT0FBRCxDQUFELENBQ0traEIsSUFETCxDQUNVLGtCQURWLEVBQzhCYixLQUQ5QixFQUVLeGdCLElBRkwsQ0FFVSxpQkFGVixFQUU2QnE5RixDQUFDLENBQUNsOUYsT0FBRCxDQUFELENBQVdraEIsSUFBWCxDQUFnQixPQUFoQixLQUE0QixFQUZ6RDtBQUdILEtBSkQ7O0FBTUFnMkQsSUFBQUEsQ0FBQyxDQUFDdXJCLE9BQUYsQ0FBVTVSLFFBQVYsQ0FBbUIsY0FBbkI7O0FBRUEzWixJQUFBQSxDQUFDLENBQUNtcUIsV0FBRixHQUFpQm5xQixDQUFDLENBQUNpcUIsVUFBRixLQUFpQixDQUFsQixHQUNaakUsQ0FBQyxDQUFDLDRCQUFELENBQUQsQ0FBZ0NuVyxRQUFoQyxDQUF5QzdQLENBQUMsQ0FBQ3VyQixPQUEzQyxDQURZLEdBRVp2ckIsQ0FBQyxDQUFDb3FCLE9BQUYsQ0FBVXpJLE9BQVYsQ0FBa0IsNEJBQWxCLEVBQWdEdHNGLE1BQWhELEVBRko7QUFJQTJxRSxJQUFBQSxDQUFDLENBQUN5cUIsS0FBRixHQUFVenFCLENBQUMsQ0FBQ21xQixXQUFGLENBQWNuOUUsSUFBZCxDQUNOLDJCQURNLEVBQ3VCM1gsTUFEdkIsRUFBVjs7QUFFQTJxRSxJQUFBQSxDQUFDLENBQUNtcUIsV0FBRixDQUFjNTlELEdBQWQsQ0FBa0IsU0FBbEIsRUFBNkIsQ0FBN0I7O0FBRUEsUUFBSXl6QyxDQUFDLENBQUN2UixPQUFGLENBQVV1NEIsVUFBVixLQUF5QixJQUF6QixJQUFpQ2huQixDQUFDLENBQUN2UixPQUFGLENBQVVrNkIsWUFBVixLQUEyQixJQUFoRSxFQUFzRTtBQUNsRTNvQixNQUFBQSxDQUFDLENBQUN2UixPQUFGLENBQVVnNkIsY0FBVixHQUEyQixDQUEzQjtBQUNIOztBQUVEekMsSUFBQUEsQ0FBQyxDQUFDLGdCQUFELEVBQW1CaG1CLENBQUMsQ0FBQ3VyQixPQUFyQixDQUFELENBQStCNXNCLEdBQS9CLENBQW1DLE9BQW5DLEVBQTRDZ2IsUUFBNUMsQ0FBcUQsZUFBckQ7O0FBRUEzWixJQUFBQSxDQUFDLENBQUNzdUIsYUFBRjs7QUFFQXR1QixJQUFBQSxDQUFDLENBQUNpdUIsV0FBRjs7QUFFQWp1QixJQUFBQSxDQUFDLENBQUNrdUIsU0FBRjs7QUFFQWx1QixJQUFBQSxDQUFDLENBQUN1dUIsVUFBRjs7QUFHQXZ1QixJQUFBQSxDQUFDLENBQUN3dUIsZUFBRixDQUFrQixPQUFPeHVCLENBQUMsQ0FBQ3lwQixZQUFULEtBQTBCLFFBQTFCLEdBQXFDenBCLENBQUMsQ0FBQ3lwQixZQUF2QyxHQUFzRCxDQUF4RTs7QUFFQSxRQUFJenBCLENBQUMsQ0FBQ3ZSLE9BQUYsQ0FBVXgrRCxTQUFWLEtBQXdCLElBQTVCLEVBQWtDO0FBQzlCK3ZFLE1BQUFBLENBQUMsQ0FBQ3lxQixLQUFGLENBQVE5USxRQUFSLENBQWlCLFdBQWpCO0FBQ0g7QUFFSixHQWhERDs7QUFrREF3TSxFQUFBQSxLQUFLLENBQUN4akcsU0FBTixDQUFnQjhyRyxTQUFoQixHQUE0QixZQUFXO0FBRW5DLFFBQUl6dUIsQ0FBQyxHQUFHLElBQVI7QUFBQSxRQUFjNXZFLENBQWQ7QUFBQSxRQUFpQjJSLENBQWpCO0FBQUEsUUFBb0JELENBQXBCO0FBQUEsUUFBdUI0c0YsU0FBdkI7QUFBQSxRQUFrQ0MsV0FBbEM7QUFBQSxRQUErQ0MsY0FBL0M7QUFBQSxRQUE4REMsZ0JBQTlEOztBQUVBSCxJQUFBQSxTQUFTLEdBQUc3OEYsUUFBUSxDQUFDNDFFLHNCQUFULEVBQVo7QUFDQW1uQixJQUFBQSxjQUFjLEdBQUc1dUIsQ0FBQyxDQUFDdXJCLE9BQUYsQ0FBVS9qRyxRQUFWLEVBQWpCOztBQUVBLFFBQUd3NEUsQ0FBQyxDQUFDdlIsT0FBRixDQUFVMjVCLElBQVYsR0FBaUIsQ0FBcEIsRUFBdUI7QUFFbkJ5RyxNQUFBQSxnQkFBZ0IsR0FBRzd1QixDQUFDLENBQUN2UixPQUFGLENBQVU4NUIsWUFBVixHQUF5QnZvQixDQUFDLENBQUN2UixPQUFGLENBQVUyNUIsSUFBdEQ7QUFDQXVHLE1BQUFBLFdBQVcsR0FBRzFwRyxJQUFJLENBQUMrc0IsSUFBTCxDQUNWNDhFLGNBQWMsQ0FBQ3JuRyxNQUFmLEdBQXdCc25HLGdCQURkLENBQWQ7O0FBSUEsV0FBSXorRixDQUFDLEdBQUcsQ0FBUixFQUFXQSxDQUFDLEdBQUd1K0YsV0FBZixFQUE0QnYrRixDQUFDLEVBQTdCLEVBQWdDO0FBQzVCLFlBQUlrNEYsS0FBSyxHQUFHejJGLFFBQVEsQ0FBQ2pNLGFBQVQsQ0FBdUIsS0FBdkIsQ0FBWjs7QUFDQSxhQUFJbWMsQ0FBQyxHQUFHLENBQVIsRUFBV0EsQ0FBQyxHQUFHaStELENBQUMsQ0FBQ3ZSLE9BQUYsQ0FBVTI1QixJQUF6QixFQUErQnJtRixDQUFDLEVBQWhDLEVBQW9DO0FBQ2hDLGNBQUkrc0YsR0FBRyxHQUFHajlGLFFBQVEsQ0FBQ2pNLGFBQVQsQ0FBdUIsS0FBdkIsQ0FBVjs7QUFDQSxlQUFJa2MsQ0FBQyxHQUFHLENBQVIsRUFBV0EsQ0FBQyxHQUFHaytELENBQUMsQ0FBQ3ZSLE9BQUYsQ0FBVTg1QixZQUF6QixFQUF1Q3ptRixDQUFDLEVBQXhDLEVBQTRDO0FBQ3hDLGdCQUFJL1gsTUFBTSxHQUFJcUcsQ0FBQyxHQUFHeStGLGdCQUFKLElBQXlCOXNGLENBQUMsR0FBR2krRCxDQUFDLENBQUN2UixPQUFGLENBQVU4NUIsWUFBZixHQUErQnptRixDQUF2RCxDQUFkOztBQUNBLGdCQUFJOHNGLGNBQWMsQ0FBQy80RixHQUFmLENBQW1COUwsTUFBbkIsQ0FBSixFQUFnQztBQUM1QitrRyxjQUFBQSxHQUFHLENBQUNsN0YsV0FBSixDQUFnQmc3RixjQUFjLENBQUMvNEYsR0FBZixDQUFtQjlMLE1BQW5CLENBQWhCO0FBQ0g7QUFDSjs7QUFDRHUrRixVQUFBQSxLQUFLLENBQUMxMEYsV0FBTixDQUFrQms3RixHQUFsQjtBQUNIOztBQUNESixRQUFBQSxTQUFTLENBQUM5NkYsV0FBVixDQUFzQjAwRixLQUF0QjtBQUNIOztBQUVEdG9CLE1BQUFBLENBQUMsQ0FBQ3VyQixPQUFGLENBQVU3cUIsS0FBVixHQUFrQjZPLE1BQWxCLENBQXlCbWYsU0FBekI7O0FBQ0ExdUIsTUFBQUEsQ0FBQyxDQUFDdXJCLE9BQUYsQ0FBVS9qRyxRQUFWLEdBQXFCQSxRQUFyQixHQUFnQ0EsUUFBaEMsR0FDSytrQyxHQURMLENBQ1M7QUFDRCxpQkFBUyxNQUFNeXpDLENBQUMsQ0FBQ3ZSLE9BQUYsQ0FBVTg1QixZQUFqQixHQUFpQyxHQUR4QztBQUVELG1CQUFXO0FBRlYsT0FEVDtBQU1IO0FBRUosR0F0Q0Q7O0FBd0NBcEMsRUFBQUEsS0FBSyxDQUFDeGpHLFNBQU4sQ0FBZ0Jvc0csZUFBaEIsR0FBa0MsVUFBU25vQixPQUFULEVBQWtCb29CLFdBQWxCLEVBQStCO0FBRTdELFFBQUlodkIsQ0FBQyxHQUFHLElBQVI7QUFBQSxRQUNJaXZCLFVBREo7QUFBQSxRQUNnQkMsZ0JBRGhCO0FBQUEsUUFDa0NDLGNBRGxDO0FBQUEsUUFDa0RDLGlCQUFpQixHQUFHLEtBRHRFOztBQUVBLFFBQUlDLFdBQVcsR0FBR3J2QixDQUFDLENBQUN1ckIsT0FBRixDQUFVOStGLEtBQVYsRUFBbEI7O0FBQ0EsUUFBSW0vRixXQUFXLEdBQUd0bkcsTUFBTSxDQUFDc0ksVUFBUCxJQUFxQm81RixDQUFDLENBQUMxaEcsTUFBRCxDQUFELENBQVVtSSxLQUFWLEVBQXZDOztBQUVBLFFBQUl1ekUsQ0FBQyxDQUFDa29CLFNBQUYsS0FBZ0IsUUFBcEIsRUFBOEI7QUFDMUJpSCxNQUFBQSxjQUFjLEdBQUd2RCxXQUFqQjtBQUNILEtBRkQsTUFFTyxJQUFJNXJCLENBQUMsQ0FBQ2tvQixTQUFGLEtBQWdCLFFBQXBCLEVBQThCO0FBQ2pDaUgsTUFBQUEsY0FBYyxHQUFHRSxXQUFqQjtBQUNILEtBRk0sTUFFQSxJQUFJcnZCLENBQUMsQ0FBQ2tvQixTQUFGLEtBQWdCLEtBQXBCLEVBQTJCO0FBQzlCaUgsTUFBQUEsY0FBYyxHQUFHbHFHLElBQUksQ0FBQ2tKLEdBQUwsQ0FBU3k5RixXQUFULEVBQXNCeUQsV0FBdEIsQ0FBakI7QUFDSDs7QUFFRCxRQUFLcnZCLENBQUMsQ0FBQ3ZSLE9BQUYsQ0FBVTA1QixVQUFWLElBQ0Rub0IsQ0FBQyxDQUFDdlIsT0FBRixDQUFVMDVCLFVBQVYsQ0FBcUI1Z0csTUFEcEIsSUFFRHk0RSxDQUFDLENBQUN2UixPQUFGLENBQVUwNUIsVUFBVixLQUF5QixJQUY3QixFQUVtQztBQUUvQitHLE1BQUFBLGdCQUFnQixHQUFHLElBQW5COztBQUVBLFdBQUtELFVBQUwsSUFBbUJqdkIsQ0FBQyxDQUFDZ3JCLFdBQXJCLEVBQWtDO0FBQzlCLFlBQUlockIsQ0FBQyxDQUFDZ3JCLFdBQUYsQ0FBY3orQixjQUFkLENBQTZCMGlDLFVBQTdCLENBQUosRUFBOEM7QUFDMUMsY0FBSWp2QixDQUFDLENBQUN5akIsZ0JBQUYsQ0FBbUJxRSxXQUFuQixLQUFtQyxLQUF2QyxFQUE4QztBQUMxQyxnQkFBSXFILGNBQWMsR0FBR252QixDQUFDLENBQUNnckIsV0FBRixDQUFjaUUsVUFBZCxDQUFyQixFQUFnRDtBQUM1Q0MsY0FBQUEsZ0JBQWdCLEdBQUdsdkIsQ0FBQyxDQUFDZ3JCLFdBQUYsQ0FBY2lFLFVBQWQsQ0FBbkI7QUFDSDtBQUNKLFdBSkQsTUFJTztBQUNILGdCQUFJRSxjQUFjLEdBQUdudkIsQ0FBQyxDQUFDZ3JCLFdBQUYsQ0FBY2lFLFVBQWQsQ0FBckIsRUFBZ0Q7QUFDNUNDLGNBQUFBLGdCQUFnQixHQUFHbHZCLENBQUMsQ0FBQ2dyQixXQUFGLENBQWNpRSxVQUFkLENBQW5CO0FBQ0g7QUFDSjtBQUNKO0FBQ0o7O0FBRUQsVUFBSUMsZ0JBQWdCLEtBQUssSUFBekIsRUFBK0I7QUFDM0IsWUFBSWx2QixDQUFDLENBQUM2cUIsZ0JBQUYsS0FBdUIsSUFBM0IsRUFBaUM7QUFDN0IsY0FBSXFFLGdCQUFnQixLQUFLbHZCLENBQUMsQ0FBQzZxQixnQkFBdkIsSUFBMkNtRSxXQUEvQyxFQUE0RDtBQUN4RGh2QixZQUFBQSxDQUFDLENBQUM2cUIsZ0JBQUYsR0FDSXFFLGdCQURKOztBQUVBLGdCQUFJbHZCLENBQUMsQ0FBQ2lyQixrQkFBRixDQUFxQmlFLGdCQUFyQixNQUEyQyxTQUEvQyxFQUEwRDtBQUN0RGx2QixjQUFBQSxDQUFDLENBQUNzdkIsT0FBRixDQUFVSixnQkFBVjtBQUNILGFBRkQsTUFFTztBQUNIbHZCLGNBQUFBLENBQUMsQ0FBQ3ZSLE9BQUYsR0FBWXUzQixDQUFDLENBQUN4M0IsTUFBRixDQUFTLEVBQVQsRUFBYXdSLENBQUMsQ0FBQ3lqQixnQkFBZixFQUNSempCLENBQUMsQ0FBQ2lyQixrQkFBRixDQUNJaUUsZ0JBREosQ0FEUSxDQUFaOztBQUdBLGtCQUFJdG9CLE9BQU8sS0FBSyxJQUFoQixFQUFzQjtBQUNsQjVHLGdCQUFBQSxDQUFDLENBQUN5cEIsWUFBRixHQUFpQnpwQixDQUFDLENBQUN2UixPQUFGLENBQVVtNUIsWUFBM0I7QUFDSDs7QUFDRDVuQixjQUFBQSxDQUFDLENBQUNqeEMsT0FBRixDQUFVNjNDLE9BQVY7QUFDSDs7QUFDRHdvQixZQUFBQSxpQkFBaUIsR0FBR0YsZ0JBQXBCO0FBQ0g7QUFDSixTQWpCRCxNQWlCTztBQUNIbHZCLFVBQUFBLENBQUMsQ0FBQzZxQixnQkFBRixHQUFxQnFFLGdCQUFyQjs7QUFDQSxjQUFJbHZCLENBQUMsQ0FBQ2lyQixrQkFBRixDQUFxQmlFLGdCQUFyQixNQUEyQyxTQUEvQyxFQUEwRDtBQUN0RGx2QixZQUFBQSxDQUFDLENBQUNzdkIsT0FBRixDQUFVSixnQkFBVjtBQUNILFdBRkQsTUFFTztBQUNIbHZCLFlBQUFBLENBQUMsQ0FBQ3ZSLE9BQUYsR0FBWXUzQixDQUFDLENBQUN4M0IsTUFBRixDQUFTLEVBQVQsRUFBYXdSLENBQUMsQ0FBQ3lqQixnQkFBZixFQUNSempCLENBQUMsQ0FBQ2lyQixrQkFBRixDQUNJaUUsZ0JBREosQ0FEUSxDQUFaOztBQUdBLGdCQUFJdG9CLE9BQU8sS0FBSyxJQUFoQixFQUFzQjtBQUNsQjVHLGNBQUFBLENBQUMsQ0FBQ3lwQixZQUFGLEdBQWlCenBCLENBQUMsQ0FBQ3ZSLE9BQUYsQ0FBVW01QixZQUEzQjtBQUNIOztBQUNENW5CLFlBQUFBLENBQUMsQ0FBQ2p4QyxPQUFGLENBQVU2M0MsT0FBVjtBQUNIOztBQUNEd29CLFVBQUFBLGlCQUFpQixHQUFHRixnQkFBcEI7QUFDSDtBQUNKLE9BakNELE1BaUNPO0FBQ0gsWUFBSWx2QixDQUFDLENBQUM2cUIsZ0JBQUYsS0FBdUIsSUFBM0IsRUFBaUM7QUFDN0I3cUIsVUFBQUEsQ0FBQyxDQUFDNnFCLGdCQUFGLEdBQXFCLElBQXJCO0FBQ0E3cUIsVUFBQUEsQ0FBQyxDQUFDdlIsT0FBRixHQUFZdVIsQ0FBQyxDQUFDeWpCLGdCQUFkOztBQUNBLGNBQUk3YyxPQUFPLEtBQUssSUFBaEIsRUFBc0I7QUFDbEI1RyxZQUFBQSxDQUFDLENBQUN5cEIsWUFBRixHQUFpQnpwQixDQUFDLENBQUN2UixPQUFGLENBQVVtNUIsWUFBM0I7QUFDSDs7QUFDRDVuQixVQUFBQSxDQUFDLENBQUNqeEMsT0FBRixDQUFVNjNDLE9BQVY7O0FBQ0F3b0IsVUFBQUEsaUJBQWlCLEdBQUdGLGdCQUFwQjtBQUNIO0FBQ0osT0E3RDhCLENBK0QvQjs7O0FBQ0EsVUFBSSxDQUFDdG9CLE9BQUQsSUFBWXdvQixpQkFBaUIsS0FBSyxLQUF0QyxFQUE4QztBQUMxQ3B2QixRQUFBQSxDQUFDLENBQUN1ckIsT0FBRixDQUFVM3pGLE9BQVYsQ0FBa0IsWUFBbEIsRUFBZ0MsQ0FBQ29vRSxDQUFELEVBQUlvdkIsaUJBQUosQ0FBaEM7QUFDSDtBQUNKO0FBRUosR0F0RkQ7O0FBd0ZBakosRUFBQUEsS0FBSyxDQUFDeGpHLFNBQU4sQ0FBZ0J3cEcsV0FBaEIsR0FBOEIsVUFBUzdpRyxLQUFULEVBQWdCaW1HLFdBQWhCLEVBQTZCO0FBRXZELFFBQUl2dkIsQ0FBQyxHQUFHLElBQVI7QUFBQSxRQUNJd3ZCLE9BQU8sR0FBR3hKLENBQUMsQ0FBQzE4RixLQUFLLENBQUNxVyxhQUFQLENBRGY7QUFBQSxRQUVJOHZGLFdBRko7QUFBQSxRQUVpQm5GLFdBRmpCO0FBQUEsUUFFOEJvRixZQUY5QixDQUZ1RCxDQU12RDs7O0FBQ0EsUUFBR0YsT0FBTyxDQUFDbnhCLEVBQVIsQ0FBVyxHQUFYLENBQUgsRUFBb0I7QUFDaEIvMEUsTUFBQUEsS0FBSyxDQUFDQyxjQUFOO0FBQ0gsS0FUc0QsQ0FXdkQ7OztBQUNBLFFBQUcsQ0FBQ2ltRyxPQUFPLENBQUNueEIsRUFBUixDQUFXLElBQVgsQ0FBSixFQUFzQjtBQUNsQm14QixNQUFBQSxPQUFPLEdBQUdBLE9BQU8sQ0FBQ2x6RixPQUFSLENBQWdCLElBQWhCLENBQVY7QUFDSDs7QUFFRG96RixJQUFBQSxZQUFZLEdBQUkxdkIsQ0FBQyxDQUFDaXFCLFVBQUYsR0FBZWpxQixDQUFDLENBQUN2UixPQUFGLENBQVVnNkIsY0FBekIsS0FBNEMsQ0FBNUQ7QUFDQWdILElBQUFBLFdBQVcsR0FBR0MsWUFBWSxHQUFHLENBQUgsR0FBTyxDQUFDMXZCLENBQUMsQ0FBQ2lxQixVQUFGLEdBQWVqcUIsQ0FBQyxDQUFDeXBCLFlBQWxCLElBQWtDenBCLENBQUMsQ0FBQ3ZSLE9BQUYsQ0FBVWc2QixjQUE3RTs7QUFFQSxZQUFRbi9GLEtBQUssQ0FBQ1gsSUFBTixDQUFXMDRDLE9BQW5CO0FBRUksV0FBSyxVQUFMO0FBQ0lpcEQsUUFBQUEsV0FBVyxHQUFHbUYsV0FBVyxLQUFLLENBQWhCLEdBQW9CenZCLENBQUMsQ0FBQ3ZSLE9BQUYsQ0FBVWc2QixjQUE5QixHQUErQ3pvQixDQUFDLENBQUN2UixPQUFGLENBQVUrNUIsWUFBVixHQUF5QmlILFdBQXRGOztBQUNBLFlBQUl6dkIsQ0FBQyxDQUFDaXFCLFVBQUYsR0FBZWpxQixDQUFDLENBQUN2UixPQUFGLENBQVUrNUIsWUFBN0IsRUFBMkM7QUFDdkN4b0IsVUFBQUEsQ0FBQyxDQUFDOHRCLFlBQUYsQ0FBZTl0QixDQUFDLENBQUN5cEIsWUFBRixHQUFpQmEsV0FBaEMsRUFBNkMsS0FBN0MsRUFBb0RpRixXQUFwRDtBQUNIOztBQUNEOztBQUVKLFdBQUssTUFBTDtBQUNJakYsUUFBQUEsV0FBVyxHQUFHbUYsV0FBVyxLQUFLLENBQWhCLEdBQW9CenZCLENBQUMsQ0FBQ3ZSLE9BQUYsQ0FBVWc2QixjQUE5QixHQUErQ2dILFdBQTdEOztBQUNBLFlBQUl6dkIsQ0FBQyxDQUFDaXFCLFVBQUYsR0FBZWpxQixDQUFDLENBQUN2UixPQUFGLENBQVUrNUIsWUFBN0IsRUFBMkM7QUFDdkN4b0IsVUFBQUEsQ0FBQyxDQUFDOHRCLFlBQUYsQ0FBZTl0QixDQUFDLENBQUN5cEIsWUFBRixHQUFpQmEsV0FBaEMsRUFBNkMsS0FBN0MsRUFBb0RpRixXQUFwRDtBQUNIOztBQUNEOztBQUVKLFdBQUssT0FBTDtBQUNJLFlBQUlwbUYsS0FBSyxHQUFHN2YsS0FBSyxDQUFDWCxJQUFOLENBQVd3Z0IsS0FBWCxLQUFxQixDQUFyQixHQUF5QixDQUF6QixHQUNSN2YsS0FBSyxDQUFDWCxJQUFOLENBQVd3Z0IsS0FBWCxJQUFvQnFtRixPQUFPLENBQUNybUYsS0FBUixLQUFrQjYyRCxDQUFDLENBQUN2UixPQUFGLENBQVVnNkIsY0FEcEQ7O0FBR0F6b0IsUUFBQUEsQ0FBQyxDQUFDOHRCLFlBQUYsQ0FBZTl0QixDQUFDLENBQUMydkIsY0FBRixDQUFpQnhtRixLQUFqQixDQUFmLEVBQXdDLEtBQXhDLEVBQStDb21GLFdBQS9DOztBQUNBQyxRQUFBQSxPQUFPLENBQUNob0csUUFBUixHQUFtQm9RLE9BQW5CLENBQTJCLE9BQTNCO0FBQ0E7O0FBRUo7QUFDSTtBQXpCUjtBQTRCSCxHQS9DRDs7QUFpREF1dUYsRUFBQUEsS0FBSyxDQUFDeGpHLFNBQU4sQ0FBZ0JndEcsY0FBaEIsR0FBaUMsVUFBU3htRixLQUFULEVBQWdCO0FBRTdDLFFBQUk2MkQsQ0FBQyxHQUFHLElBQVI7QUFBQSxRQUNJNHZCLFVBREo7QUFBQSxRQUNnQkMsYUFEaEI7O0FBR0FELElBQUFBLFVBQVUsR0FBRzV2QixDQUFDLENBQUM4dkIsbUJBQUYsRUFBYjtBQUNBRCxJQUFBQSxhQUFhLEdBQUcsQ0FBaEI7O0FBQ0EsUUFBSTFtRixLQUFLLEdBQUd5bUYsVUFBVSxDQUFDQSxVQUFVLENBQUNyb0csTUFBWCxHQUFvQixDQUFyQixDQUF0QixFQUErQztBQUMzQzRoQixNQUFBQSxLQUFLLEdBQUd5bUYsVUFBVSxDQUFDQSxVQUFVLENBQUNyb0csTUFBWCxHQUFvQixDQUFyQixDQUFsQjtBQUNILEtBRkQsTUFFTztBQUNILFdBQUssSUFBSTZVLENBQVQsSUFBY3d6RixVQUFkLEVBQTBCO0FBQ3RCLFlBQUl6bUYsS0FBSyxHQUFHeW1GLFVBQVUsQ0FBQ3h6RixDQUFELENBQXRCLEVBQTJCO0FBQ3ZCK00sVUFBQUEsS0FBSyxHQUFHMG1GLGFBQVI7QUFDQTtBQUNIOztBQUNEQSxRQUFBQSxhQUFhLEdBQUdELFVBQVUsQ0FBQ3h6RixDQUFELENBQTFCO0FBQ0g7QUFDSjs7QUFFRCxXQUFPK00sS0FBUDtBQUNILEdBcEJEOztBQXNCQWc5RSxFQUFBQSxLQUFLLENBQUN4akcsU0FBTixDQUFnQm90RyxhQUFoQixHQUFnQyxZQUFXO0FBRXZDLFFBQUkvdkIsQ0FBQyxHQUFHLElBQVI7O0FBRUEsUUFBSUEsQ0FBQyxDQUFDdlIsT0FBRixDQUFVNDRCLElBQVYsSUFBa0JybkIsQ0FBQyxDQUFDMHBCLEtBQUYsS0FBWSxJQUFsQyxFQUF3QztBQUVwQzFELE1BQUFBLENBQUMsQ0FBQyxJQUFELEVBQU9obUIsQ0FBQyxDQUFDMHBCLEtBQVQsQ0FBRCxDQUNLN2YsR0FETCxDQUNTLGFBRFQsRUFDd0I3SixDQUFDLENBQUNtc0IsV0FEMUIsRUFFS3RpQixHQUZMLENBRVMsa0JBRlQsRUFFNkJtYyxDQUFDLENBQUNULEtBQUYsQ0FBUXZsQixDQUFDLENBQUNnd0IsU0FBVixFQUFxQmh3QixDQUFyQixFQUF3QixJQUF4QixDQUY3QixFQUdLNkosR0FITCxDQUdTLGtCQUhULEVBRzZCbWMsQ0FBQyxDQUFDVCxLQUFGLENBQVF2bEIsQ0FBQyxDQUFDZ3dCLFNBQVYsRUFBcUJod0IsQ0FBckIsRUFBd0IsS0FBeEIsQ0FIN0I7O0FBS0EsVUFBSUEsQ0FBQyxDQUFDdlIsT0FBRixDQUFVNjNCLGFBQVYsS0FBNEIsSUFBaEMsRUFBc0M7QUFDbEN0bUIsUUFBQUEsQ0FBQyxDQUFDMHBCLEtBQUYsQ0FBUTdmLEdBQVIsQ0FBWSxlQUFaLEVBQTZCN0osQ0FBQyxDQUFDeXNCLFVBQS9CO0FBQ0g7QUFDSjs7QUFFRHpzQixJQUFBQSxDQUFDLENBQUN1ckIsT0FBRixDQUFVMWhCLEdBQVYsQ0FBYyx3QkFBZDs7QUFFQSxRQUFJN0osQ0FBQyxDQUFDdlIsT0FBRixDQUFVaTRCLE1BQVYsS0FBcUIsSUFBckIsSUFBNkIxbUIsQ0FBQyxDQUFDaXFCLFVBQUYsR0FBZWpxQixDQUFDLENBQUN2UixPQUFGLENBQVUrNUIsWUFBMUQsRUFBd0U7QUFDcEV4b0IsTUFBQUEsQ0FBQyxDQUFDK3BCLFVBQUYsSUFBZ0IvcEIsQ0FBQyxDQUFDK3BCLFVBQUYsQ0FBYWxnQixHQUFiLENBQWlCLGFBQWpCLEVBQWdDN0osQ0FBQyxDQUFDbXNCLFdBQWxDLENBQWhCO0FBQ0Fuc0IsTUFBQUEsQ0FBQyxDQUFDOHBCLFVBQUYsSUFBZ0I5cEIsQ0FBQyxDQUFDOHBCLFVBQUYsQ0FBYWpnQixHQUFiLENBQWlCLGFBQWpCLEVBQWdDN0osQ0FBQyxDQUFDbXNCLFdBQWxDLENBQWhCOztBQUVBLFVBQUluc0IsQ0FBQyxDQUFDdlIsT0FBRixDQUFVNjNCLGFBQVYsS0FBNEIsSUFBaEMsRUFBc0M7QUFDbEN0bUIsUUFBQUEsQ0FBQyxDQUFDK3BCLFVBQUYsSUFBZ0IvcEIsQ0FBQyxDQUFDK3BCLFVBQUYsQ0FBYWxnQixHQUFiLENBQWlCLGVBQWpCLEVBQWtDN0osQ0FBQyxDQUFDeXNCLFVBQXBDLENBQWhCO0FBQ0F6c0IsUUFBQUEsQ0FBQyxDQUFDOHBCLFVBQUYsSUFBZ0I5cEIsQ0FBQyxDQUFDOHBCLFVBQUYsQ0FBYWpnQixHQUFiLENBQWlCLGVBQWpCLEVBQWtDN0osQ0FBQyxDQUFDeXNCLFVBQXBDLENBQWhCO0FBQ0g7QUFDSjs7QUFFRHpzQixJQUFBQSxDQUFDLENBQUN5cUIsS0FBRixDQUFRNWdCLEdBQVIsQ0FBWSxrQ0FBWixFQUFnRDdKLENBQUMsQ0FBQ3VzQixZQUFsRDs7QUFDQXZzQixJQUFBQSxDQUFDLENBQUN5cUIsS0FBRixDQUFRNWdCLEdBQVIsQ0FBWSxpQ0FBWixFQUErQzdKLENBQUMsQ0FBQ3VzQixZQUFqRDs7QUFDQXZzQixJQUFBQSxDQUFDLENBQUN5cUIsS0FBRixDQUFRNWdCLEdBQVIsQ0FBWSw4QkFBWixFQUE0QzdKLENBQUMsQ0FBQ3VzQixZQUE5Qzs7QUFDQXZzQixJQUFBQSxDQUFDLENBQUN5cUIsS0FBRixDQUFRNWdCLEdBQVIsQ0FBWSxvQ0FBWixFQUFrRDdKLENBQUMsQ0FBQ3VzQixZQUFwRDs7QUFFQXZzQixJQUFBQSxDQUFDLENBQUN5cUIsS0FBRixDQUFRNWdCLEdBQVIsQ0FBWSxhQUFaLEVBQTJCN0osQ0FBQyxDQUFDb3NCLFlBQTdCOztBQUVBcEcsSUFBQUEsQ0FBQyxDQUFDbjBGLFFBQUQsQ0FBRCxDQUFZZzRFLEdBQVosQ0FBZ0I3SixDQUFDLENBQUMyckIsZ0JBQWxCLEVBQW9DM3JCLENBQUMsQ0FBQytTLFVBQXRDOztBQUVBL1MsSUFBQUEsQ0FBQyxDQUFDaXdCLGtCQUFGOztBQUVBLFFBQUlqd0IsQ0FBQyxDQUFDdlIsT0FBRixDQUFVNjNCLGFBQVYsS0FBNEIsSUFBaEMsRUFBc0M7QUFDbEN0bUIsTUFBQUEsQ0FBQyxDQUFDeXFCLEtBQUYsQ0FBUTVnQixHQUFSLENBQVksZUFBWixFQUE2QjdKLENBQUMsQ0FBQ3lzQixVQUEvQjtBQUNIOztBQUVELFFBQUl6c0IsQ0FBQyxDQUFDdlIsT0FBRixDQUFVZzVCLGFBQVYsS0FBNEIsSUFBaEMsRUFBc0M7QUFDbEN6QixNQUFBQSxDQUFDLENBQUNobUIsQ0FBQyxDQUFDbXFCLFdBQUgsQ0FBRCxDQUFpQjNpRyxRQUFqQixHQUE0QnFpRixHQUE1QixDQUFnQyxhQUFoQyxFQUErQzdKLENBQUMsQ0FBQ3FzQixhQUFqRDtBQUNIOztBQUVEckcsSUFBQUEsQ0FBQyxDQUFDMWhHLE1BQUQsQ0FBRCxDQUFVdWxGLEdBQVYsQ0FBYyxtQ0FBbUM3SixDQUFDLENBQUNvbUIsV0FBbkQsRUFBZ0VwbUIsQ0FBQyxDQUFDa3dCLGlCQUFsRTtBQUVBbEssSUFBQUEsQ0FBQyxDQUFDMWhHLE1BQUQsQ0FBRCxDQUFVdWxGLEdBQVYsQ0FBYyx3QkFBd0I3SixDQUFDLENBQUNvbUIsV0FBeEMsRUFBcURwbUIsQ0FBQyxDQUFDbXdCLE1BQXZEO0FBRUFuSyxJQUFBQSxDQUFDLENBQUMsbUJBQUQsRUFBc0JobUIsQ0FBQyxDQUFDbXFCLFdBQXhCLENBQUQsQ0FBc0N0Z0IsR0FBdEMsQ0FBMEMsV0FBMUMsRUFBdUQ3SixDQUFDLENBQUN6MkUsY0FBekQ7QUFFQXk4RixJQUFBQSxDQUFDLENBQUMxaEcsTUFBRCxDQUFELENBQVV1bEYsR0FBVixDQUFjLHNCQUFzQjdKLENBQUMsQ0FBQ29tQixXQUF0QyxFQUFtRHBtQixDQUFDLENBQUNzc0IsV0FBckQ7QUFFSCxHQXZERDs7QUF5REFuRyxFQUFBQSxLQUFLLENBQUN4akcsU0FBTixDQUFnQnN0RyxrQkFBaEIsR0FBcUMsWUFBVztBQUU1QyxRQUFJandCLENBQUMsR0FBRyxJQUFSOztBQUVBQSxJQUFBQSxDQUFDLENBQUN5cUIsS0FBRixDQUFRNWdCLEdBQVIsQ0FBWSxrQkFBWixFQUFnQ21jLENBQUMsQ0FBQ1QsS0FBRixDQUFRdmxCLENBQUMsQ0FBQ2d3QixTQUFWLEVBQXFCaHdCLENBQXJCLEVBQXdCLElBQXhCLENBQWhDOztBQUNBQSxJQUFBQSxDQUFDLENBQUN5cUIsS0FBRixDQUFRNWdCLEdBQVIsQ0FBWSxrQkFBWixFQUFnQ21jLENBQUMsQ0FBQ1QsS0FBRixDQUFRdmxCLENBQUMsQ0FBQ2d3QixTQUFWLEVBQXFCaHdCLENBQXJCLEVBQXdCLEtBQXhCLENBQWhDO0FBRUgsR0FQRDs7QUFTQW1tQixFQUFBQSxLQUFLLENBQUN4akcsU0FBTixDQUFnQnl0RyxXQUFoQixHQUE4QixZQUFXO0FBRXJDLFFBQUlwd0IsQ0FBQyxHQUFHLElBQVI7QUFBQSxRQUFjNHVCLGNBQWQ7O0FBRUEsUUFBRzV1QixDQUFDLENBQUN2UixPQUFGLENBQVUyNUIsSUFBVixHQUFpQixDQUFwQixFQUF1QjtBQUNuQndHLE1BQUFBLGNBQWMsR0FBRzV1QixDQUFDLENBQUNvcUIsT0FBRixDQUFVNWlHLFFBQVYsR0FBcUJBLFFBQXJCLEVBQWpCO0FBQ0FvbkcsTUFBQUEsY0FBYyxDQUFDOVYsVUFBZixDQUEwQixPQUExQjs7QUFDQTlZLE1BQUFBLENBQUMsQ0FBQ3VyQixPQUFGLENBQVU3cUIsS0FBVixHQUFrQjZPLE1BQWxCLENBQXlCcWYsY0FBekI7QUFDSDtBQUVKLEdBVkQ7O0FBWUF6SSxFQUFBQSxLQUFLLENBQUN4akcsU0FBTixDQUFnQnlwRyxZQUFoQixHQUErQixVQUFTOWlHLEtBQVQsRUFBZ0I7QUFFM0MsUUFBSTAyRSxDQUFDLEdBQUcsSUFBUjs7QUFFQSxRQUFJQSxDQUFDLENBQUNzckIsV0FBRixLQUFrQixLQUF0QixFQUE2QjtBQUN6QmhpRyxNQUFBQSxLQUFLLENBQUNzUix3QkFBTjtBQUNBdFIsTUFBQUEsS0FBSyxDQUFDZ2lGLGVBQU47QUFDQWhpRixNQUFBQSxLQUFLLENBQUNDLGNBQU47QUFDSDtBQUVKLEdBVkQ7O0FBWUE0OEYsRUFBQUEsS0FBSyxDQUFDeGpHLFNBQU4sQ0FBZ0IwdEcsT0FBaEIsR0FBMEIsVUFBU3RoRSxPQUFULEVBQWtCO0FBRXhDLFFBQUlpeEMsQ0FBQyxHQUFHLElBQVI7O0FBRUFBLElBQUFBLENBQUMsQ0FBQ2lzQixhQUFGOztBQUVBanNCLElBQUFBLENBQUMsQ0FBQzBxQixXQUFGLEdBQWdCLEVBQWhCOztBQUVBMXFCLElBQUFBLENBQUMsQ0FBQyt2QixhQUFGOztBQUVBL0osSUFBQUEsQ0FBQyxDQUFDLGVBQUQsRUFBa0JobUIsQ0FBQyxDQUFDdXJCLE9BQXBCLENBQUQsQ0FBOEJqYyxNQUE5Qjs7QUFFQSxRQUFJdFAsQ0FBQyxDQUFDMHBCLEtBQU4sRUFBYTtBQUNUMXBCLE1BQUFBLENBQUMsQ0FBQzBwQixLQUFGLENBQVF2aEcsTUFBUjtBQUNIOztBQUVELFFBQUs2M0UsQ0FBQyxDQUFDK3BCLFVBQUYsSUFBZ0IvcEIsQ0FBQyxDQUFDK3BCLFVBQUYsQ0FBYXhpRyxNQUFsQyxFQUEyQztBQUV2Q3k0RSxNQUFBQSxDQUFDLENBQUMrcEIsVUFBRixDQUNLalEsV0FETCxDQUNpQix5Q0FEakIsRUFFS2hCLFVBRkwsQ0FFZ0Isb0NBRmhCLEVBR0t2c0QsR0FITCxDQUdTLFNBSFQsRUFHbUIsRUFIbkI7O0FBS0EsVUFBS3l6QyxDQUFDLENBQUMwc0IsUUFBRixDQUFXOTdGLElBQVgsQ0FBaUJvdkUsQ0FBQyxDQUFDdlIsT0FBRixDQUFVbTRCLFNBQTNCLENBQUwsRUFBNkM7QUFDekM1bUIsUUFBQUEsQ0FBQyxDQUFDK3BCLFVBQUYsQ0FBYTVoRyxNQUFiO0FBQ0g7QUFDSjs7QUFFRCxRQUFLNjNFLENBQUMsQ0FBQzhwQixVQUFGLElBQWdCOXBCLENBQUMsQ0FBQzhwQixVQUFGLENBQWF2aUcsTUFBbEMsRUFBMkM7QUFFdkN5NEUsTUFBQUEsQ0FBQyxDQUFDOHBCLFVBQUYsQ0FDS2hRLFdBREwsQ0FDaUIseUNBRGpCLEVBRUtoQixVQUZMLENBRWdCLG9DQUZoQixFQUdLdnNELEdBSEwsQ0FHUyxTQUhULEVBR21CLEVBSG5COztBQUtBLFVBQUt5ekMsQ0FBQyxDQUFDMHNCLFFBQUYsQ0FBVzk3RixJQUFYLENBQWlCb3ZFLENBQUMsQ0FBQ3ZSLE9BQUYsQ0FBVW80QixTQUEzQixDQUFMLEVBQTZDO0FBQ3pDN21CLFFBQUFBLENBQUMsQ0FBQzhwQixVQUFGLENBQWEzaEcsTUFBYjtBQUNIO0FBQ0o7O0FBR0QsUUFBSTYzRSxDQUFDLENBQUNvcUIsT0FBTixFQUFlO0FBRVhwcUIsTUFBQUEsQ0FBQyxDQUFDb3FCLE9BQUYsQ0FDS3RRLFdBREwsQ0FDaUIsbUVBRGpCLEVBRUtoQixVQUZMLENBRWdCLGFBRmhCLEVBR0tBLFVBSEwsQ0FHZ0Isa0JBSGhCLEVBSUs3dUMsSUFKTCxDQUlVLFlBQVU7QUFDWis3QyxRQUFBQSxDQUFDLENBQUMsSUFBRCxDQUFELENBQVFoOEUsSUFBUixDQUFhLE9BQWIsRUFBc0JnOEUsQ0FBQyxDQUFDLElBQUQsQ0FBRCxDQUFRcjlGLElBQVIsQ0FBYSxpQkFBYixDQUF0QjtBQUNILE9BTkw7O0FBUUFxM0UsTUFBQUEsQ0FBQyxDQUFDbXFCLFdBQUYsQ0FBYzNpRyxRQUFkLENBQXVCLEtBQUtpbkUsT0FBTCxDQUFhNjVCLEtBQXBDLEVBQTJDaFosTUFBM0M7O0FBRUF0UCxNQUFBQSxDQUFDLENBQUNtcUIsV0FBRixDQUFjN2EsTUFBZDs7QUFFQXRQLE1BQUFBLENBQUMsQ0FBQ3lxQixLQUFGLENBQVFuYixNQUFSOztBQUVBdFAsTUFBQUEsQ0FBQyxDQUFDdXJCLE9BQUYsQ0FBVWhjLE1BQVYsQ0FBaUJ2UCxDQUFDLENBQUNvcUIsT0FBbkI7QUFDSDs7QUFFRHBxQixJQUFBQSxDQUFDLENBQUNvd0IsV0FBRjs7QUFFQXB3QixJQUFBQSxDQUFDLENBQUN1ckIsT0FBRixDQUFVelIsV0FBVixDQUFzQixjQUF0Qjs7QUFDQTlaLElBQUFBLENBQUMsQ0FBQ3VyQixPQUFGLENBQVV6UixXQUFWLENBQXNCLG1CQUF0Qjs7QUFDQTlaLElBQUFBLENBQUMsQ0FBQ3VyQixPQUFGLENBQVV6UixXQUFWLENBQXNCLGNBQXRCOztBQUVBOVosSUFBQUEsQ0FBQyxDQUFDNHFCLFNBQUYsR0FBYyxJQUFkOztBQUVBLFFBQUcsQ0FBQzc3RCxPQUFKLEVBQWE7QUFDVGl4QyxNQUFBQSxDQUFDLENBQUN1ckIsT0FBRixDQUFVM3pGLE9BQVYsQ0FBa0IsU0FBbEIsRUFBNkIsQ0FBQ29vRSxDQUFELENBQTdCO0FBQ0g7QUFFSixHQXhFRDs7QUEwRUFtbUIsRUFBQUEsS0FBSyxDQUFDeGpHLFNBQU4sQ0FBZ0JnckcsaUJBQWhCLEdBQW9DLFVBQVNyRixLQUFULEVBQWdCO0FBRWhELFFBQUl0b0IsQ0FBQyxHQUFHLElBQVI7QUFBQSxRQUNJK3RCLFVBQVUsR0FBRyxFQURqQjs7QUFHQUEsSUFBQUEsVUFBVSxDQUFDL3RCLENBQUMsQ0FBQzByQixjQUFILENBQVYsR0FBK0IsRUFBL0I7O0FBRUEsUUFBSTFyQixDQUFDLENBQUN2UixPQUFGLENBQVUrNEIsSUFBVixLQUFtQixLQUF2QixFQUE4QjtBQUMxQnhuQixNQUFBQSxDQUFDLENBQUNtcUIsV0FBRixDQUFjNTlELEdBQWQsQ0FBa0J3aEUsVUFBbEI7QUFDSCxLQUZELE1BRU87QUFDSC90QixNQUFBQSxDQUFDLENBQUNvcUIsT0FBRixDQUFVbDhCLEVBQVYsQ0FBYW82QixLQUFiLEVBQW9CLzdELEdBQXBCLENBQXdCd2hFLFVBQXhCO0FBQ0g7QUFFSixHQWJEOztBQWVBNUgsRUFBQUEsS0FBSyxDQUFDeGpHLFNBQU4sQ0FBZ0IydEcsU0FBaEIsR0FBNEIsVUFBU0MsVUFBVCxFQUFxQjVsRyxRQUFyQixFQUErQjtBQUV2RCxRQUFJcTFFLENBQUMsR0FBRyxJQUFSOztBQUVBLFFBQUlBLENBQUMsQ0FBQ2tyQixjQUFGLEtBQXFCLEtBQXpCLEVBQWdDO0FBRTVCbHJCLE1BQUFBLENBQUMsQ0FBQ29xQixPQUFGLENBQVVsOEIsRUFBVixDQUFhcWlDLFVBQWIsRUFBeUJoa0UsR0FBekIsQ0FBNkI7QUFDekJqc0IsUUFBQUEsTUFBTSxFQUFFMC9ELENBQUMsQ0FBQ3ZSLE9BQUYsQ0FBVW51RDtBQURPLE9BQTdCOztBQUlBMC9ELE1BQUFBLENBQUMsQ0FBQ29xQixPQUFGLENBQVVsOEIsRUFBVixDQUFhcWlDLFVBQWIsRUFBeUJoekYsT0FBekIsQ0FBaUM7QUFDN0IyMkUsUUFBQUEsT0FBTyxFQUFFO0FBRG9CLE9BQWpDLEVBRUdsVSxDQUFDLENBQUN2UixPQUFGLENBQVU4b0IsS0FGYixFQUVvQnZYLENBQUMsQ0FBQ3ZSLE9BQUYsQ0FBVXFtQixNQUY5QixFQUVzQ25xRixRQUZ0QztBQUlILEtBVkQsTUFVTztBQUVIcTFFLE1BQUFBLENBQUMsQ0FBQzB0QixlQUFGLENBQWtCNkMsVUFBbEI7O0FBRUF2d0IsTUFBQUEsQ0FBQyxDQUFDb3FCLE9BQUYsQ0FBVWw4QixFQUFWLENBQWFxaUMsVUFBYixFQUF5QmhrRSxHQUF6QixDQUE2QjtBQUN6QjJuRCxRQUFBQSxPQUFPLEVBQUUsQ0FEZ0I7QUFFekI1ekUsUUFBQUEsTUFBTSxFQUFFMC9ELENBQUMsQ0FBQ3ZSLE9BQUYsQ0FBVW51RDtBQUZPLE9BQTdCOztBQUtBLFVBQUkzVixRQUFKLEVBQWM7QUFDVm0yQixRQUFBQSxVQUFVLENBQUMsWUFBVztBQUVsQmsvQyxVQUFBQSxDQUFDLENBQUMydEIsaUJBQUYsQ0FBb0I0QyxVQUFwQjs7QUFFQTVsRyxVQUFBQSxRQUFRLENBQUM0RixJQUFUO0FBQ0gsU0FMUyxFQUtQeXZFLENBQUMsQ0FBQ3ZSLE9BQUYsQ0FBVThvQixLQUxILENBQVY7QUFNSDtBQUVKO0FBRUosR0FsQ0Q7O0FBb0NBNE8sRUFBQUEsS0FBSyxDQUFDeGpHLFNBQU4sQ0FBZ0I2dEcsWUFBaEIsR0FBK0IsVUFBU0QsVUFBVCxFQUFxQjtBQUVoRCxRQUFJdndCLENBQUMsR0FBRyxJQUFSOztBQUVBLFFBQUlBLENBQUMsQ0FBQ2tyQixjQUFGLEtBQXFCLEtBQXpCLEVBQWdDO0FBRTVCbHJCLE1BQUFBLENBQUMsQ0FBQ29xQixPQUFGLENBQVVsOEIsRUFBVixDQUFhcWlDLFVBQWIsRUFBeUJoekYsT0FBekIsQ0FBaUM7QUFDN0IyMkUsUUFBQUEsT0FBTyxFQUFFLENBRG9CO0FBRTdCNXpFLFFBQUFBLE1BQU0sRUFBRTAvRCxDQUFDLENBQUN2UixPQUFGLENBQVVudUQsTUFBVixHQUFtQjtBQUZFLE9BQWpDLEVBR0cwL0QsQ0FBQyxDQUFDdlIsT0FBRixDQUFVOG9CLEtBSGIsRUFHb0J2WCxDQUFDLENBQUN2UixPQUFGLENBQVVxbUIsTUFIOUI7QUFLSCxLQVBELE1BT087QUFFSDlVLE1BQUFBLENBQUMsQ0FBQzB0QixlQUFGLENBQWtCNkMsVUFBbEI7O0FBRUF2d0IsTUFBQUEsQ0FBQyxDQUFDb3FCLE9BQUYsQ0FBVWw4QixFQUFWLENBQWFxaUMsVUFBYixFQUF5QmhrRSxHQUF6QixDQUE2QjtBQUN6QjJuRCxRQUFBQSxPQUFPLEVBQUUsQ0FEZ0I7QUFFekI1ekUsUUFBQUEsTUFBTSxFQUFFMC9ELENBQUMsQ0FBQ3ZSLE9BQUYsQ0FBVW51RCxNQUFWLEdBQW1CO0FBRkYsT0FBN0I7QUFLSDtBQUVKLEdBdEJEOztBQXdCQTZsRixFQUFBQSxLQUFLLENBQUN4akcsU0FBTixDQUFnQjh0RyxZQUFoQixHQUErQnRLLEtBQUssQ0FBQ3hqRyxTQUFOLENBQWdCK3RHLFdBQWhCLEdBQThCLFVBQVNockUsTUFBVCxFQUFpQjtBQUUxRSxRQUFJczZDLENBQUMsR0FBRyxJQUFSOztBQUVBLFFBQUl0NkMsTUFBTSxLQUFLLElBQWYsRUFBcUI7QUFFakJzNkMsTUFBQUEsQ0FBQyxDQUFDd3JCLFlBQUYsR0FBaUJ4ckIsQ0FBQyxDQUFDb3FCLE9BQW5COztBQUVBcHFCLE1BQUFBLENBQUMsQ0FBQ2l0QixNQUFGOztBQUVBanRCLE1BQUFBLENBQUMsQ0FBQ21xQixXQUFGLENBQWMzaUcsUUFBZCxDQUF1QixLQUFLaW5FLE9BQUwsQ0FBYTY1QixLQUFwQyxFQUEyQ2haLE1BQTNDOztBQUVBdFAsTUFBQUEsQ0FBQyxDQUFDd3JCLFlBQUYsQ0FBZTlsRSxNQUFmLENBQXNCQSxNQUF0QixFQUE4Qm1xRCxRQUE5QixDQUF1QzdQLENBQUMsQ0FBQ21xQixXQUF6Qzs7QUFFQW5xQixNQUFBQSxDQUFDLENBQUNrdEIsTUFBRjtBQUVIO0FBRUosR0FsQkQ7O0FBb0JBL0csRUFBQUEsS0FBSyxDQUFDeGpHLFNBQU4sQ0FBZ0JndUcsWUFBaEIsR0FBK0IsWUFBVztBQUV0QyxRQUFJM3dCLENBQUMsR0FBRyxJQUFSOztBQUVBQSxJQUFBQSxDQUFDLENBQUN1ckIsT0FBRixDQUNLMWhCLEdBREwsQ0FDUyx3QkFEVCxFQUVLSCxFQUZMLENBRVEsd0JBRlIsRUFFa0MsR0FGbEMsRUFFdUMsVUFBU3BnRixLQUFULEVBQWdCO0FBRW5EQSxNQUFBQSxLQUFLLENBQUNzUix3QkFBTjtBQUNBLFVBQUlnMkYsR0FBRyxHQUFHNUssQ0FBQyxDQUFDLElBQUQsQ0FBWDtBQUVBbGxFLE1BQUFBLFVBQVUsQ0FBQyxZQUFXO0FBRWxCLFlBQUlrL0MsQ0FBQyxDQUFDdlIsT0FBRixDQUFVdTVCLFlBQWQsRUFBNkI7QUFDekJob0IsVUFBQUEsQ0FBQyxDQUFDbXJCLFFBQUYsR0FBYXlGLEdBQUcsQ0FBQ3Z5QixFQUFKLENBQU8sUUFBUCxDQUFiOztBQUNBMkIsVUFBQUEsQ0FBQyxDQUFDZ3NCLFFBQUY7QUFDSDtBQUVKLE9BUFMsRUFPUCxDQVBPLENBQVY7QUFTSCxLQWhCRDtBQWlCSCxHQXJCRDs7QUF1QkE3RixFQUFBQSxLQUFLLENBQUN4akcsU0FBTixDQUFnQmt1RyxVQUFoQixHQUE2QjFLLEtBQUssQ0FBQ3hqRyxTQUFOLENBQWdCbXVHLGlCQUFoQixHQUFvQyxZQUFXO0FBRXhFLFFBQUk5d0IsQ0FBQyxHQUFHLElBQVI7O0FBQ0EsV0FBT0EsQ0FBQyxDQUFDeXBCLFlBQVQ7QUFFSCxHQUxEOztBQU9BdEQsRUFBQUEsS0FBSyxDQUFDeGpHLFNBQU4sQ0FBZ0J5ckcsV0FBaEIsR0FBOEIsWUFBVztBQUVyQyxRQUFJcHVCLENBQUMsR0FBRyxJQUFSOztBQUVBLFFBQUkrd0IsVUFBVSxHQUFHLENBQWpCO0FBQ0EsUUFBSUMsT0FBTyxHQUFHLENBQWQ7QUFDQSxRQUFJQyxRQUFRLEdBQUcsQ0FBZjs7QUFFQSxRQUFJanhCLENBQUMsQ0FBQ3ZSLE9BQUYsQ0FBVWs1QixRQUFWLEtBQXVCLElBQTNCLEVBQWlDO0FBQzdCLFVBQUkzbkIsQ0FBQyxDQUFDaXFCLFVBQUYsSUFBZ0JqcUIsQ0FBQyxDQUFDdlIsT0FBRixDQUFVKzVCLFlBQTlCLEVBQTRDO0FBQ3ZDLFVBQUV5SSxRQUFGO0FBQ0osT0FGRCxNQUVPO0FBQ0gsZUFBT0YsVUFBVSxHQUFHL3dCLENBQUMsQ0FBQ2lxQixVQUF0QixFQUFrQztBQUM5QixZQUFFZ0gsUUFBRjtBQUNBRixVQUFBQSxVQUFVLEdBQUdDLE9BQU8sR0FBR2h4QixDQUFDLENBQUN2UixPQUFGLENBQVVnNkIsY0FBakM7QUFDQXVJLFVBQUFBLE9BQU8sSUFBSWh4QixDQUFDLENBQUN2UixPQUFGLENBQVVnNkIsY0FBVixJQUE0QnpvQixDQUFDLENBQUN2UixPQUFGLENBQVUrNUIsWUFBdEMsR0FBcUR4b0IsQ0FBQyxDQUFDdlIsT0FBRixDQUFVZzZCLGNBQS9ELEdBQWdGem9CLENBQUMsQ0FBQ3ZSLE9BQUYsQ0FBVSs1QixZQUFyRztBQUNIO0FBQ0o7QUFDSixLQVZELE1BVU8sSUFBSXhvQixDQUFDLENBQUN2UixPQUFGLENBQVV1NEIsVUFBVixLQUF5QixJQUE3QixFQUFtQztBQUN0Q2lLLE1BQUFBLFFBQVEsR0FBR2p4QixDQUFDLENBQUNpcUIsVUFBYjtBQUNILEtBRk0sTUFFQSxJQUFHLENBQUNqcUIsQ0FBQyxDQUFDdlIsT0FBRixDQUFVazRCLFFBQWQsRUFBd0I7QUFDM0JzSyxNQUFBQSxRQUFRLEdBQUcsSUFBSWhzRyxJQUFJLENBQUMrc0IsSUFBTCxDQUFVLENBQUNndUQsQ0FBQyxDQUFDaXFCLFVBQUYsR0FBZWpxQixDQUFDLENBQUN2UixPQUFGLENBQVUrNUIsWUFBMUIsSUFBMEN4b0IsQ0FBQyxDQUFDdlIsT0FBRixDQUFVZzZCLGNBQTlELENBQWY7QUFDSCxLQUZNLE1BRUQ7QUFDRixhQUFPc0ksVUFBVSxHQUFHL3dCLENBQUMsQ0FBQ2lxQixVQUF0QixFQUFrQztBQUM5QixVQUFFZ0gsUUFBRjtBQUNBRixRQUFBQSxVQUFVLEdBQUdDLE9BQU8sR0FBR2h4QixDQUFDLENBQUN2UixPQUFGLENBQVVnNkIsY0FBakM7QUFDQXVJLFFBQUFBLE9BQU8sSUFBSWh4QixDQUFDLENBQUN2UixPQUFGLENBQVVnNkIsY0FBVixJQUE0QnpvQixDQUFDLENBQUN2UixPQUFGLENBQVUrNUIsWUFBdEMsR0FBcUR4b0IsQ0FBQyxDQUFDdlIsT0FBRixDQUFVZzZCLGNBQS9ELEdBQWdGem9CLENBQUMsQ0FBQ3ZSLE9BQUYsQ0FBVSs1QixZQUFyRztBQUNIO0FBQ0o7O0FBRUQsV0FBT3lJLFFBQVEsR0FBRyxDQUFsQjtBQUVILEdBaENEOztBQWtDQTlLLEVBQUFBLEtBQUssQ0FBQ3hqRyxTQUFOLENBQWdCdXVHLE9BQWhCLEdBQTBCLFVBQVNYLFVBQVQsRUFBcUI7QUFFM0MsUUFBSXZ3QixDQUFDLEdBQUcsSUFBUjtBQUFBLFFBQ0l1dEIsVUFESjtBQUFBLFFBRUk0RCxjQUZKO0FBQUEsUUFHSUMsY0FBYyxHQUFHLENBSHJCO0FBQUEsUUFJSUMsV0FKSjtBQUFBLFFBS0lsZ0YsSUFMSjs7QUFPQTZ1RCxJQUFBQSxDQUFDLENBQUNzcUIsV0FBRixHQUFnQixDQUFoQjtBQUNBNkcsSUFBQUEsY0FBYyxHQUFHbnhCLENBQUMsQ0FBQ29xQixPQUFGLENBQVVyMEUsS0FBVixHQUFrQnMzRSxXQUFsQixDQUE4QixJQUE5QixDQUFqQjs7QUFFQSxRQUFJcnRCLENBQUMsQ0FBQ3ZSLE9BQUYsQ0FBVWs1QixRQUFWLEtBQXVCLElBQTNCLEVBQWlDO0FBQzdCLFVBQUkzbkIsQ0FBQyxDQUFDaXFCLFVBQUYsR0FBZWpxQixDQUFDLENBQUN2UixPQUFGLENBQVUrNUIsWUFBN0IsRUFBMkM7QUFDdkN4b0IsUUFBQUEsQ0FBQyxDQUFDc3FCLFdBQUYsR0FBaUJ0cUIsQ0FBQyxDQUFDa3FCLFVBQUYsR0FBZWxxQixDQUFDLENBQUN2UixPQUFGLENBQVUrNUIsWUFBMUIsR0FBMEMsQ0FBQyxDQUEzRDtBQUNBcjNFLFFBQUFBLElBQUksR0FBRyxDQUFDLENBQVI7O0FBRUEsWUFBSTZ1RCxDQUFDLENBQUN2UixPQUFGLENBQVV3NkIsUUFBVixLQUF1QixJQUF2QixJQUErQmpwQixDQUFDLENBQUN2UixPQUFGLENBQVV1NEIsVUFBVixLQUF5QixJQUE1RCxFQUFrRTtBQUM5RCxjQUFJaG5CLENBQUMsQ0FBQ3ZSLE9BQUYsQ0FBVSs1QixZQUFWLEtBQTJCLENBQS9CLEVBQWtDO0FBQzlCcjNFLFlBQUFBLElBQUksR0FBRyxDQUFDLEdBQVI7QUFDSCxXQUZELE1BRU8sSUFBSTZ1RCxDQUFDLENBQUN2UixPQUFGLENBQVUrNUIsWUFBVixLQUEyQixDQUEvQixFQUFrQztBQUNyQ3IzRSxZQUFBQSxJQUFJLEdBQUcsQ0FBQyxDQUFSO0FBQ0g7QUFDSjs7QUFDRGlnRixRQUFBQSxjQUFjLEdBQUlELGNBQWMsR0FBR254QixDQUFDLENBQUN2UixPQUFGLENBQVUrNUIsWUFBNUIsR0FBNENyM0UsSUFBN0Q7QUFDSDs7QUFDRCxVQUFJNnVELENBQUMsQ0FBQ2lxQixVQUFGLEdBQWVqcUIsQ0FBQyxDQUFDdlIsT0FBRixDQUFVZzZCLGNBQXpCLEtBQTRDLENBQWhELEVBQW1EO0FBQy9DLFlBQUk4SCxVQUFVLEdBQUd2d0IsQ0FBQyxDQUFDdlIsT0FBRixDQUFVZzZCLGNBQXZCLEdBQXdDem9CLENBQUMsQ0FBQ2lxQixVQUExQyxJQUF3RGpxQixDQUFDLENBQUNpcUIsVUFBRixHQUFlanFCLENBQUMsQ0FBQ3ZSLE9BQUYsQ0FBVSs1QixZQUFyRixFQUFtRztBQUMvRixjQUFJK0gsVUFBVSxHQUFHdndCLENBQUMsQ0FBQ2lxQixVQUFuQixFQUErQjtBQUMzQmpxQixZQUFBQSxDQUFDLENBQUNzcUIsV0FBRixHQUFpQixDQUFDdHFCLENBQUMsQ0FBQ3ZSLE9BQUYsQ0FBVSs1QixZQUFWLElBQTBCK0gsVUFBVSxHQUFHdndCLENBQUMsQ0FBQ2lxQixVQUF6QyxDQUFELElBQXlEanFCLENBQUMsQ0FBQ2txQixVQUE1RCxHQUEwRSxDQUFDLENBQTNGO0FBQ0FrSCxZQUFBQSxjQUFjLEdBQUksQ0FBQ3B4QixDQUFDLENBQUN2UixPQUFGLENBQVUrNUIsWUFBVixJQUEwQitILFVBQVUsR0FBR3Z3QixDQUFDLENBQUNpcUIsVUFBekMsQ0FBRCxJQUF5RGtILGNBQTFELEdBQTRFLENBQUMsQ0FBOUY7QUFDSCxXQUhELE1BR087QUFDSG54QixZQUFBQSxDQUFDLENBQUNzcUIsV0FBRixHQUFrQnRxQixDQUFDLENBQUNpcUIsVUFBRixHQUFlanFCLENBQUMsQ0FBQ3ZSLE9BQUYsQ0FBVWc2QixjQUExQixHQUE0Q3pvQixDQUFDLENBQUNrcUIsVUFBL0MsR0FBNkQsQ0FBQyxDQUE5RTtBQUNBa0gsWUFBQUEsY0FBYyxHQUFLcHhCLENBQUMsQ0FBQ2lxQixVQUFGLEdBQWVqcUIsQ0FBQyxDQUFDdlIsT0FBRixDQUFVZzZCLGNBQTFCLEdBQTRDMEksY0FBN0MsR0FBK0QsQ0FBQyxDQUFqRjtBQUNIO0FBQ0o7QUFDSjtBQUNKLEtBekJELE1BeUJPO0FBQ0gsVUFBSVosVUFBVSxHQUFHdndCLENBQUMsQ0FBQ3ZSLE9BQUYsQ0FBVSs1QixZQUF2QixHQUFzQ3hvQixDQUFDLENBQUNpcUIsVUFBNUMsRUFBd0Q7QUFDcERqcUIsUUFBQUEsQ0FBQyxDQUFDc3FCLFdBQUYsR0FBZ0IsQ0FBRWlHLFVBQVUsR0FBR3Z3QixDQUFDLENBQUN2UixPQUFGLENBQVUrNUIsWUFBeEIsR0FBd0N4b0IsQ0FBQyxDQUFDaXFCLFVBQTNDLElBQXlEanFCLENBQUMsQ0FBQ2txQixVQUEzRTtBQUNBa0gsUUFBQUEsY0FBYyxHQUFHLENBQUViLFVBQVUsR0FBR3Z3QixDQUFDLENBQUN2UixPQUFGLENBQVUrNUIsWUFBeEIsR0FBd0N4b0IsQ0FBQyxDQUFDaXFCLFVBQTNDLElBQXlEa0gsY0FBMUU7QUFDSDtBQUNKOztBQUVELFFBQUlueEIsQ0FBQyxDQUFDaXFCLFVBQUYsSUFBZ0JqcUIsQ0FBQyxDQUFDdlIsT0FBRixDQUFVKzVCLFlBQTlCLEVBQTRDO0FBQ3hDeG9CLE1BQUFBLENBQUMsQ0FBQ3NxQixXQUFGLEdBQWdCLENBQWhCO0FBQ0E4RyxNQUFBQSxjQUFjLEdBQUcsQ0FBakI7QUFDSDs7QUFFRCxRQUFJcHhCLENBQUMsQ0FBQ3ZSLE9BQUYsQ0FBVXU0QixVQUFWLEtBQXlCLElBQXpCLElBQWlDaG5CLENBQUMsQ0FBQ2lxQixVQUFGLElBQWdCanFCLENBQUMsQ0FBQ3ZSLE9BQUYsQ0FBVSs1QixZQUEvRCxFQUE2RTtBQUN6RXhvQixNQUFBQSxDQUFDLENBQUNzcUIsV0FBRixHQUFrQnRxQixDQUFDLENBQUNrcUIsVUFBRixHQUFlamxHLElBQUksQ0FBQ3VnRCxLQUFMLENBQVd3NkIsQ0FBQyxDQUFDdlIsT0FBRixDQUFVKzVCLFlBQXJCLENBQWhCLEdBQXNELENBQXZELEdBQThEeG9CLENBQUMsQ0FBQ2txQixVQUFGLEdBQWVscUIsQ0FBQyxDQUFDaXFCLFVBQWxCLEdBQWdDLENBQTdHO0FBQ0gsS0FGRCxNQUVPLElBQUlqcUIsQ0FBQyxDQUFDdlIsT0FBRixDQUFVdTRCLFVBQVYsS0FBeUIsSUFBekIsSUFBaUNobkIsQ0FBQyxDQUFDdlIsT0FBRixDQUFVazVCLFFBQVYsS0FBdUIsSUFBNUQsRUFBa0U7QUFDckUzbkIsTUFBQUEsQ0FBQyxDQUFDc3FCLFdBQUYsSUFBaUJ0cUIsQ0FBQyxDQUFDa3FCLFVBQUYsR0FBZWpsRyxJQUFJLENBQUN1Z0QsS0FBTCxDQUFXdzZCLENBQUMsQ0FBQ3ZSLE9BQUYsQ0FBVSs1QixZQUFWLEdBQXlCLENBQXBDLENBQWYsR0FBd0R4b0IsQ0FBQyxDQUFDa3FCLFVBQTNFO0FBQ0gsS0FGTSxNQUVBLElBQUlscUIsQ0FBQyxDQUFDdlIsT0FBRixDQUFVdTRCLFVBQVYsS0FBeUIsSUFBN0IsRUFBbUM7QUFDdENobkIsTUFBQUEsQ0FBQyxDQUFDc3FCLFdBQUYsR0FBZ0IsQ0FBaEI7QUFDQXRxQixNQUFBQSxDQUFDLENBQUNzcUIsV0FBRixJQUFpQnRxQixDQUFDLENBQUNrcUIsVUFBRixHQUFlamxHLElBQUksQ0FBQ3VnRCxLQUFMLENBQVd3NkIsQ0FBQyxDQUFDdlIsT0FBRixDQUFVKzVCLFlBQVYsR0FBeUIsQ0FBcEMsQ0FBaEM7QUFDSDs7QUFFRCxRQUFJeG9CLENBQUMsQ0FBQ3ZSLE9BQUYsQ0FBVXc2QixRQUFWLEtBQXVCLEtBQTNCLEVBQWtDO0FBQzlCc0UsTUFBQUEsVUFBVSxHQUFLZ0QsVUFBVSxHQUFHdndCLENBQUMsQ0FBQ2txQixVQUFoQixHQUE4QixDQUFDLENBQWhDLEdBQXFDbHFCLENBQUMsQ0FBQ3NxQixXQUFwRDtBQUNILEtBRkQsTUFFTztBQUNIaUQsTUFBQUEsVUFBVSxHQUFLZ0QsVUFBVSxHQUFHWSxjQUFkLEdBQWdDLENBQUMsQ0FBbEMsR0FBdUNDLGNBQXBEO0FBQ0g7O0FBRUQsUUFBSXB4QixDQUFDLENBQUN2UixPQUFGLENBQVV1NkIsYUFBVixLQUE0QixJQUFoQyxFQUFzQztBQUVsQyxVQUFJaHBCLENBQUMsQ0FBQ2lxQixVQUFGLElBQWdCanFCLENBQUMsQ0FBQ3ZSLE9BQUYsQ0FBVSs1QixZQUExQixJQUEwQ3hvQixDQUFDLENBQUN2UixPQUFGLENBQVVrNUIsUUFBVixLQUF1QixLQUFyRSxFQUE0RTtBQUN4RTBKLFFBQUFBLFdBQVcsR0FBR3J4QixDQUFDLENBQUNtcUIsV0FBRixDQUFjM2lHLFFBQWQsQ0FBdUIsY0FBdkIsRUFBdUMwbUUsRUFBdkMsQ0FBMENxaUMsVUFBMUMsQ0FBZDtBQUNILE9BRkQsTUFFTztBQUNIYyxRQUFBQSxXQUFXLEdBQUdyeEIsQ0FBQyxDQUFDbXFCLFdBQUYsQ0FBYzNpRyxRQUFkLENBQXVCLGNBQXZCLEVBQXVDMG1FLEVBQXZDLENBQTBDcWlDLFVBQVUsR0FBR3Z3QixDQUFDLENBQUN2UixPQUFGLENBQVUrNUIsWUFBakUsQ0FBZDtBQUNIOztBQUVELFVBQUl4b0IsQ0FBQyxDQUFDdlIsT0FBRixDQUFVNDVCLEdBQVYsS0FBa0IsSUFBdEIsRUFBNEI7QUFDeEIsWUFBSWdKLFdBQVcsQ0FBQyxDQUFELENBQWYsRUFBb0I7QUFDaEI5RCxVQUFBQSxVQUFVLEdBQUcsQ0FBQ3Z0QixDQUFDLENBQUNtcUIsV0FBRixDQUFjMTlGLEtBQWQsS0FBd0I0a0csV0FBVyxDQUFDLENBQUQsQ0FBWCxDQUFlcC9GLFVBQXZDLEdBQW9Eby9GLFdBQVcsQ0FBQzVrRyxLQUFaLEVBQXJELElBQTRFLENBQUMsQ0FBMUY7QUFDSCxTQUZELE1BRU87QUFDSDhnRyxVQUFBQSxVQUFVLEdBQUksQ0FBZDtBQUNIO0FBQ0osT0FORCxNQU1PO0FBQ0hBLFFBQUFBLFVBQVUsR0FBRzhELFdBQVcsQ0FBQyxDQUFELENBQVgsR0FBaUJBLFdBQVcsQ0FBQyxDQUFELENBQVgsQ0FBZXAvRixVQUFmLEdBQTRCLENBQUMsQ0FBOUMsR0FBa0QsQ0FBL0Q7QUFDSDs7QUFFRCxVQUFJK3RFLENBQUMsQ0FBQ3ZSLE9BQUYsQ0FBVXU0QixVQUFWLEtBQXlCLElBQTdCLEVBQW1DO0FBQy9CLFlBQUlobkIsQ0FBQyxDQUFDaXFCLFVBQUYsSUFBZ0JqcUIsQ0FBQyxDQUFDdlIsT0FBRixDQUFVKzVCLFlBQTFCLElBQTBDeG9CLENBQUMsQ0FBQ3ZSLE9BQUYsQ0FBVWs1QixRQUFWLEtBQXVCLEtBQXJFLEVBQTRFO0FBQ3hFMEosVUFBQUEsV0FBVyxHQUFHcnhCLENBQUMsQ0FBQ21xQixXQUFGLENBQWMzaUcsUUFBZCxDQUF1QixjQUF2QixFQUF1QzBtRSxFQUF2QyxDQUEwQ3FpQyxVQUExQyxDQUFkO0FBQ0gsU0FGRCxNQUVPO0FBQ0hjLFVBQUFBLFdBQVcsR0FBR3J4QixDQUFDLENBQUNtcUIsV0FBRixDQUFjM2lHLFFBQWQsQ0FBdUIsY0FBdkIsRUFBdUMwbUUsRUFBdkMsQ0FBMENxaUMsVUFBVSxHQUFHdndCLENBQUMsQ0FBQ3ZSLE9BQUYsQ0FBVSs1QixZQUF2QixHQUFzQyxDQUFoRixDQUFkO0FBQ0g7O0FBRUQsWUFBSXhvQixDQUFDLENBQUN2UixPQUFGLENBQVU0NUIsR0FBVixLQUFrQixJQUF0QixFQUE0QjtBQUN4QixjQUFJZ0osV0FBVyxDQUFDLENBQUQsQ0FBZixFQUFvQjtBQUNoQjlELFlBQUFBLFVBQVUsR0FBRyxDQUFDdnRCLENBQUMsQ0FBQ21xQixXQUFGLENBQWMxOUYsS0FBZCxLQUF3QjRrRyxXQUFXLENBQUMsQ0FBRCxDQUFYLENBQWVwL0YsVUFBdkMsR0FBb0RvL0YsV0FBVyxDQUFDNWtHLEtBQVosRUFBckQsSUFBNEUsQ0FBQyxDQUExRjtBQUNILFdBRkQsTUFFTztBQUNIOGdHLFlBQUFBLFVBQVUsR0FBSSxDQUFkO0FBQ0g7QUFDSixTQU5ELE1BTU87QUFDSEEsVUFBQUEsVUFBVSxHQUFHOEQsV0FBVyxDQUFDLENBQUQsQ0FBWCxHQUFpQkEsV0FBVyxDQUFDLENBQUQsQ0FBWCxDQUFlcC9GLFVBQWYsR0FBNEIsQ0FBQyxDQUE5QyxHQUFrRCxDQUEvRDtBQUNIOztBQUVEczdGLFFBQUFBLFVBQVUsSUFBSSxDQUFDdnRCLENBQUMsQ0FBQ3lxQixLQUFGLENBQVFoK0YsS0FBUixLQUFrQjRrRyxXQUFXLENBQUN2ekQsVUFBWixFQUFuQixJQUErQyxDQUE3RDtBQUNIO0FBQ0o7O0FBRUQsV0FBT3l2RCxVQUFQO0FBRUgsR0F6R0Q7O0FBMkdBcEgsRUFBQUEsS0FBSyxDQUFDeGpHLFNBQU4sQ0FBZ0IydUcsU0FBaEIsR0FBNEJuTCxLQUFLLENBQUN4akcsU0FBTixDQUFnQjR1RyxjQUFoQixHQUFpQyxVQUFTMXBCLE1BQVQsRUFBaUI7QUFFMUUsUUFBSTdILENBQUMsR0FBRyxJQUFSOztBQUVBLFdBQU9BLENBQUMsQ0FBQ3ZSLE9BQUYsQ0FBVW9aLE1BQVYsQ0FBUDtBQUVILEdBTkQ7O0FBUUFzZSxFQUFBQSxLQUFLLENBQUN4akcsU0FBTixDQUFnQm10RyxtQkFBaEIsR0FBc0MsWUFBVztBQUU3QyxRQUFJOXZCLENBQUMsR0FBRyxJQUFSO0FBQUEsUUFDSSt3QixVQUFVLEdBQUcsQ0FEakI7QUFBQSxRQUVJQyxPQUFPLEdBQUcsQ0FGZDtBQUFBLFFBR0lRLE9BQU8sR0FBRyxFQUhkO0FBQUEsUUFJSW5tRyxHQUpKOztBQU1BLFFBQUkyMEUsQ0FBQyxDQUFDdlIsT0FBRixDQUFVazVCLFFBQVYsS0FBdUIsS0FBM0IsRUFBa0M7QUFDOUJ0OEYsTUFBQUEsR0FBRyxHQUFHMjBFLENBQUMsQ0FBQ2lxQixVQUFSO0FBQ0gsS0FGRCxNQUVPO0FBQ0g4RyxNQUFBQSxVQUFVLEdBQUcvd0IsQ0FBQyxDQUFDdlIsT0FBRixDQUFVZzZCLGNBQVYsR0FBMkIsQ0FBQyxDQUF6QztBQUNBdUksTUFBQUEsT0FBTyxHQUFHaHhCLENBQUMsQ0FBQ3ZSLE9BQUYsQ0FBVWc2QixjQUFWLEdBQTJCLENBQUMsQ0FBdEM7QUFDQXA5RixNQUFBQSxHQUFHLEdBQUcyMEUsQ0FBQyxDQUFDaXFCLFVBQUYsR0FBZSxDQUFyQjtBQUNIOztBQUVELFdBQU84RyxVQUFVLEdBQUcxbEcsR0FBcEIsRUFBeUI7QUFDckJtbUcsTUFBQUEsT0FBTyxDQUFDenBHLElBQVIsQ0FBYWdwRyxVQUFiO0FBQ0FBLE1BQUFBLFVBQVUsR0FBR0MsT0FBTyxHQUFHaHhCLENBQUMsQ0FBQ3ZSLE9BQUYsQ0FBVWc2QixjQUFqQztBQUNBdUksTUFBQUEsT0FBTyxJQUFJaHhCLENBQUMsQ0FBQ3ZSLE9BQUYsQ0FBVWc2QixjQUFWLElBQTRCem9CLENBQUMsQ0FBQ3ZSLE9BQUYsQ0FBVSs1QixZQUF0QyxHQUFxRHhvQixDQUFDLENBQUN2UixPQUFGLENBQVVnNkIsY0FBL0QsR0FBZ0Z6b0IsQ0FBQyxDQUFDdlIsT0FBRixDQUFVKzVCLFlBQXJHO0FBQ0g7O0FBRUQsV0FBT2dKLE9BQVA7QUFFSCxHQXhCRDs7QUEwQkFyTCxFQUFBQSxLQUFLLENBQUN4akcsU0FBTixDQUFnQjh1RyxRQUFoQixHQUEyQixZQUFXO0FBRWxDLFdBQU8sSUFBUDtBQUVILEdBSkQ7O0FBTUF0TCxFQUFBQSxLQUFLLENBQUN4akcsU0FBTixDQUFnQit1RyxhQUFoQixHQUFnQyxZQUFXO0FBRXZDLFFBQUkxeEIsQ0FBQyxHQUFHLElBQVI7QUFBQSxRQUNJMnhCLGVBREo7QUFBQSxRQUNxQkMsV0FEckI7QUFBQSxRQUNrQ0MsWUFEbEM7O0FBR0FBLElBQUFBLFlBQVksR0FBRzd4QixDQUFDLENBQUN2UixPQUFGLENBQVV1NEIsVUFBVixLQUF5QixJQUF6QixHQUFnQ2huQixDQUFDLENBQUNrcUIsVUFBRixHQUFlamxHLElBQUksQ0FBQ3VnRCxLQUFMLENBQVd3NkIsQ0FBQyxDQUFDdlIsT0FBRixDQUFVKzVCLFlBQVYsR0FBeUIsQ0FBcEMsQ0FBL0MsR0FBd0YsQ0FBdkc7O0FBRUEsUUFBSXhvQixDQUFDLENBQUN2UixPQUFGLENBQVVrNkIsWUFBVixLQUEyQixJQUEvQixFQUFxQztBQUNqQzNvQixNQUFBQSxDQUFDLENBQUNtcUIsV0FBRixDQUFjNXpCLElBQWQsQ0FBbUIsY0FBbkIsRUFBbUN0c0IsSUFBbkMsQ0FBd0MsVUFBUzlnQyxLQUFULEVBQWdCbS9FLEtBQWhCLEVBQXVCO0FBQzNELFlBQUlBLEtBQUssQ0FBQ3IyRixVQUFOLEdBQW1CNC9GLFlBQW5CLEdBQW1DN0wsQ0FBQyxDQUFDc0MsS0FBRCxDQUFELENBQVN4cUQsVUFBVCxLQUF3QixDQUEzRCxHQUFpRWtpQyxDQUFDLENBQUN1cUIsU0FBRixHQUFjLENBQUMsQ0FBcEYsRUFBd0Y7QUFDcEZxSCxVQUFBQSxXQUFXLEdBQUd0SixLQUFkO0FBQ0EsaUJBQU8sS0FBUDtBQUNIO0FBQ0osT0FMRDs7QUFPQXFKLE1BQUFBLGVBQWUsR0FBRzFzRyxJQUFJLENBQUMyYixHQUFMLENBQVNvbEYsQ0FBQyxDQUFDNEwsV0FBRCxDQUFELENBQWU1bkYsSUFBZixDQUFvQixrQkFBcEIsSUFBMENnMkQsQ0FBQyxDQUFDeXBCLFlBQXJELEtBQXNFLENBQXhGO0FBRUEsYUFBT2tJLGVBQVA7QUFFSCxLQVpELE1BWU87QUFDSCxhQUFPM3hCLENBQUMsQ0FBQ3ZSLE9BQUYsQ0FBVWc2QixjQUFqQjtBQUNIO0FBRUosR0F2QkQ7O0FBeUJBdEMsRUFBQUEsS0FBSyxDQUFDeGpHLFNBQU4sQ0FBZ0JtdkcsSUFBaEIsR0FBdUIzTCxLQUFLLENBQUN4akcsU0FBTixDQUFnQm92RyxTQUFoQixHQUE0QixVQUFTekosS0FBVCxFQUFnQmlILFdBQWhCLEVBQTZCO0FBRTVFLFFBQUl2dkIsQ0FBQyxHQUFHLElBQVI7O0FBRUFBLElBQUFBLENBQUMsQ0FBQ21zQixXQUFGLENBQWM7QUFDVnhqRyxNQUFBQSxJQUFJLEVBQUU7QUFDRjA0QyxRQUFBQSxPQUFPLEVBQUUsT0FEUDtBQUVGbDRCLFFBQUFBLEtBQUssRUFBRTRtQyxRQUFRLENBQUN1NEMsS0FBRDtBQUZiO0FBREksS0FBZCxFQUtHaUgsV0FMSDtBQU9ILEdBWEQ7O0FBYUFwSixFQUFBQSxLQUFLLENBQUN4akcsU0FBTixDQUFnQm80QixJQUFoQixHQUF1QixVQUFTaTNFLFFBQVQsRUFBbUI7QUFFdEMsUUFBSWh5QixDQUFDLEdBQUcsSUFBUjs7QUFFQSxRQUFJLENBQUNnbUIsQ0FBQyxDQUFDaG1CLENBQUMsQ0FBQ3VyQixPQUFILENBQUQsQ0FBYXJSLFFBQWIsQ0FBc0IsbUJBQXRCLENBQUwsRUFBaUQ7QUFFN0M4TCxNQUFBQSxDQUFDLENBQUNobUIsQ0FBQyxDQUFDdXJCLE9BQUgsQ0FBRCxDQUFhNVIsUUFBYixDQUFzQixtQkFBdEI7O0FBRUEzWixNQUFBQSxDQUFDLENBQUN5dUIsU0FBRjs7QUFDQXp1QixNQUFBQSxDQUFDLENBQUNxdUIsUUFBRjs7QUFDQXJ1QixNQUFBQSxDQUFDLENBQUNpeUIsUUFBRjs7QUFDQWp5QixNQUFBQSxDQUFDLENBQUNreUIsU0FBRjs7QUFDQWx5QixNQUFBQSxDQUFDLENBQUNteUIsVUFBRjs7QUFDQW55QixNQUFBQSxDQUFDLENBQUNveUIsZ0JBQUY7O0FBQ0FweUIsTUFBQUEsQ0FBQyxDQUFDcXlCLFlBQUY7O0FBQ0FyeUIsTUFBQUEsQ0FBQyxDQUFDdXVCLFVBQUY7O0FBQ0F2dUIsTUFBQUEsQ0FBQyxDQUFDK3VCLGVBQUYsQ0FBa0IsSUFBbEI7O0FBQ0EvdUIsTUFBQUEsQ0FBQyxDQUFDMndCLFlBQUY7QUFFSDs7QUFFRCxRQUFJcUIsUUFBSixFQUFjO0FBQ1ZoeUIsTUFBQUEsQ0FBQyxDQUFDdXJCLE9BQUYsQ0FBVTN6RixPQUFWLENBQWtCLE1BQWxCLEVBQTBCLENBQUNvb0UsQ0FBRCxDQUExQjtBQUNIOztBQUVELFFBQUlBLENBQUMsQ0FBQ3ZSLE9BQUYsQ0FBVTYzQixhQUFWLEtBQTRCLElBQWhDLEVBQXNDO0FBQ2xDdG1CLE1BQUFBLENBQUMsQ0FBQ3N5QixPQUFGO0FBQ0g7O0FBRUQsUUFBS3R5QixDQUFDLENBQUN2UixPQUFGLENBQVVxNEIsUUFBZixFQUEwQjtBQUV0QjltQixNQUFBQSxDQUFDLENBQUM5cEMsTUFBRixHQUFXLEtBQVg7O0FBQ0E4cEMsTUFBQUEsQ0FBQyxDQUFDZ3NCLFFBQUY7QUFFSDtBQUVKLEdBcENEOztBQXNDQTdGLEVBQUFBLEtBQUssQ0FBQ3hqRyxTQUFOLENBQWdCMnZHLE9BQWhCLEdBQTBCLFlBQVc7QUFDakMsUUFBSXR5QixDQUFDLEdBQUcsSUFBUjtBQUFBLFFBQ1F1eUIsWUFBWSxHQUFHdHRHLElBQUksQ0FBQytzQixJQUFMLENBQVVndUQsQ0FBQyxDQUFDaXFCLFVBQUYsR0FBZWpxQixDQUFDLENBQUN2UixPQUFGLENBQVUrNUIsWUFBbkMsQ0FEdkI7QUFBQSxRQUVRZ0ssaUJBQWlCLEdBQUd4eUIsQ0FBQyxDQUFDOHZCLG1CQUFGLEdBQXdCcHFFLE1BQXhCLENBQStCLFVBQVNwd0IsR0FBVCxFQUFjO0FBQzdELGFBQVFBLEdBQUcsSUFBSSxDQUFSLElBQWVBLEdBQUcsR0FBRzBxRSxDQUFDLENBQUNpcUIsVUFBOUI7QUFDSCxLQUZtQixDQUY1Qjs7QUFNQWpxQixJQUFBQSxDQUFDLENBQUNvcUIsT0FBRixDQUFVbmlHLEdBQVYsQ0FBYyszRSxDQUFDLENBQUNtcUIsV0FBRixDQUFjNXpCLElBQWQsQ0FBbUIsZUFBbkIsQ0FBZCxFQUFtRHZzRCxJQUFuRCxDQUF3RDtBQUNwRCxxQkFBZSxNQURxQztBQUVwRCxrQkFBWTtBQUZ3QyxLQUF4RCxFQUdHdXNELElBSEgsQ0FHUSwwQkFIUixFQUdvQ3ZzRCxJQUhwQyxDQUd5QztBQUNyQyxrQkFBWTtBQUR5QixLQUh6Qzs7QUFPQSxRQUFJZzJELENBQUMsQ0FBQzBwQixLQUFGLEtBQVksSUFBaEIsRUFBc0I7QUFDbEIxcEIsTUFBQUEsQ0FBQyxDQUFDb3FCLE9BQUYsQ0FBVXpyQixHQUFWLENBQWNxQixDQUFDLENBQUNtcUIsV0FBRixDQUFjNXpCLElBQWQsQ0FBbUIsZUFBbkIsQ0FBZCxFQUFtRHRzQixJQUFuRCxDQUF3RCxVQUFTM2lELENBQVQsRUFBWTtBQUNoRSxZQUFJbXJHLGlCQUFpQixHQUFHRCxpQkFBaUIsQ0FBQ3o5RixPQUFsQixDQUEwQnpOLENBQTFCLENBQXhCO0FBRUEwK0YsUUFBQUEsQ0FBQyxDQUFDLElBQUQsQ0FBRCxDQUFRaDhFLElBQVIsQ0FBYTtBQUNULGtCQUFRLFVBREM7QUFFVCxnQkFBTSxnQkFBZ0JnMkQsQ0FBQyxDQUFDb21CLFdBQWxCLEdBQWdDOStGLENBRjdCO0FBR1Qsc0JBQVksQ0FBQztBQUhKLFNBQWI7O0FBTUEsWUFBSW1yRyxpQkFBaUIsS0FBSyxDQUFDLENBQTNCLEVBQThCO0FBQzNCLGNBQUlDLGlCQUFpQixHQUFHLHdCQUF3QjF5QixDQUFDLENBQUNvbUIsV0FBMUIsR0FBd0NxTSxpQkFBaEU7O0FBQ0EsY0FBSXpNLENBQUMsQ0FBQyxNQUFNME0saUJBQVAsQ0FBRCxDQUEyQm5yRyxNQUEvQixFQUF1QztBQUNyQ3krRixZQUFBQSxDQUFDLENBQUMsSUFBRCxDQUFELENBQVFoOEUsSUFBUixDQUFhO0FBQ1Qsa0NBQW9CMG9GO0FBRFgsYUFBYjtBQUdEO0FBQ0g7QUFDSixPQWpCRDs7QUFtQkExeUIsTUFBQUEsQ0FBQyxDQUFDMHBCLEtBQUYsQ0FBUTEvRSxJQUFSLENBQWEsTUFBYixFQUFxQixTQUFyQixFQUFnQ3VzRCxJQUFoQyxDQUFxQyxJQUFyQyxFQUEyQ3RzQixJQUEzQyxDQUFnRCxVQUFTM2lELENBQVQsRUFBWTtBQUN4RCxZQUFJcXJHLGdCQUFnQixHQUFHSCxpQkFBaUIsQ0FBQ2xyRyxDQUFELENBQXhDO0FBRUEwK0YsUUFBQUEsQ0FBQyxDQUFDLElBQUQsQ0FBRCxDQUFRaDhFLElBQVIsQ0FBYTtBQUNULGtCQUFRO0FBREMsU0FBYjtBQUlBZzhFLFFBQUFBLENBQUMsQ0FBQyxJQUFELENBQUQsQ0FBUXp2QixJQUFSLENBQWEsUUFBYixFQUF1QnhnRCxLQUF2QixHQUErQi9MLElBQS9CLENBQW9DO0FBQ2hDLGtCQUFRLEtBRHdCO0FBRWhDLGdCQUFNLHdCQUF3QmcyRCxDQUFDLENBQUNvbUIsV0FBMUIsR0FBd0M5K0YsQ0FGZDtBQUdoQywyQkFBaUIsZ0JBQWdCMDRFLENBQUMsQ0FBQ29tQixXQUFsQixHQUFnQ3VNLGdCQUhqQjtBQUloQyx3QkFBZXJyRyxDQUFDLEdBQUcsQ0FBTCxHQUFVLE1BQVYsR0FBbUJpckcsWUFKRDtBQUtoQywyQkFBaUIsSUFMZTtBQU1oQyxzQkFBWTtBQU5vQixTQUFwQztBQVNILE9BaEJELEVBZ0JHcmtDLEVBaEJILENBZ0JNOFIsQ0FBQyxDQUFDeXBCLFlBaEJSLEVBZ0JzQmx6QixJQWhCdEIsQ0FnQjJCLFFBaEIzQixFQWdCcUN2c0QsSUFoQnJDLENBZ0IwQztBQUN0Qyx5QkFBaUIsTUFEcUI7QUFFdEMsb0JBQVk7QUFGMEIsT0FoQjFDLEVBbUJHMVosR0FuQkg7QUFvQkg7O0FBRUQsU0FBSyxJQUFJaEosQ0FBQyxHQUFDMDRFLENBQUMsQ0FBQ3lwQixZQUFSLEVBQXNCcCtGLEdBQUcsR0FBQy9ELENBQUMsR0FBQzA0RSxDQUFDLENBQUN2UixPQUFGLENBQVUrNUIsWUFBM0MsRUFBeURsaEcsQ0FBQyxHQUFHK0QsR0FBN0QsRUFBa0UvRCxDQUFDLEVBQW5FLEVBQXVFO0FBQ3JFLFVBQUkwNEUsQ0FBQyxDQUFDdlIsT0FBRixDQUFVaTVCLGFBQWQsRUFBNkI7QUFDM0IxbkIsUUFBQUEsQ0FBQyxDQUFDb3FCLE9BQUYsQ0FBVWw4QixFQUFWLENBQWE1bUUsQ0FBYixFQUFnQjBpQixJQUFoQixDQUFxQjtBQUFDLHNCQUFZO0FBQWIsU0FBckI7QUFDRCxPQUZELE1BRU87QUFDTGcyRCxRQUFBQSxDQUFDLENBQUNvcUIsT0FBRixDQUFVbDhCLEVBQVYsQ0FBYTVtRSxDQUFiLEVBQWdCd3hGLFVBQWhCLENBQTJCLFVBQTNCO0FBQ0Q7QUFDRjs7QUFFRDlZLElBQUFBLENBQUMsQ0FBQzRzQixXQUFGO0FBRUgsR0FsRUQ7O0FBb0VBekcsRUFBQUEsS0FBSyxDQUFDeGpHLFNBQU4sQ0FBZ0Jpd0csZUFBaEIsR0FBa0MsWUFBVztBQUV6QyxRQUFJNXlCLENBQUMsR0FBRyxJQUFSOztBQUVBLFFBQUlBLENBQUMsQ0FBQ3ZSLE9BQUYsQ0FBVWk0QixNQUFWLEtBQXFCLElBQXJCLElBQTZCMW1CLENBQUMsQ0FBQ2lxQixVQUFGLEdBQWVqcUIsQ0FBQyxDQUFDdlIsT0FBRixDQUFVKzVCLFlBQTFELEVBQXdFO0FBQ3BFeG9CLE1BQUFBLENBQUMsQ0FBQytwQixVQUFGLENBQ0lsZ0IsR0FESixDQUNRLGFBRFIsRUFFSUgsRUFGSixDQUVPLGFBRlAsRUFFc0I7QUFDZHJvQyxRQUFBQSxPQUFPLEVBQUU7QUFESyxPQUZ0QixFQUlNMitCLENBQUMsQ0FBQ21zQixXQUpSOztBQUtBbnNCLE1BQUFBLENBQUMsQ0FBQzhwQixVQUFGLENBQ0lqZ0IsR0FESixDQUNRLGFBRFIsRUFFSUgsRUFGSixDQUVPLGFBRlAsRUFFc0I7QUFDZHJvQyxRQUFBQSxPQUFPLEVBQUU7QUFESyxPQUZ0QixFQUlNMitCLENBQUMsQ0FBQ21zQixXQUpSOztBQU1BLFVBQUluc0IsQ0FBQyxDQUFDdlIsT0FBRixDQUFVNjNCLGFBQVYsS0FBNEIsSUFBaEMsRUFBc0M7QUFDbEN0bUIsUUFBQUEsQ0FBQyxDQUFDK3BCLFVBQUYsQ0FBYXJnQixFQUFiLENBQWdCLGVBQWhCLEVBQWlDMUosQ0FBQyxDQUFDeXNCLFVBQW5DOztBQUNBenNCLFFBQUFBLENBQUMsQ0FBQzhwQixVQUFGLENBQWFwZ0IsRUFBYixDQUFnQixlQUFoQixFQUFpQzFKLENBQUMsQ0FBQ3lzQixVQUFuQztBQUNIO0FBQ0o7QUFFSixHQXRCRDs7QUF3QkF0RyxFQUFBQSxLQUFLLENBQUN4akcsU0FBTixDQUFnQmt3RyxhQUFoQixHQUFnQyxZQUFXO0FBRXZDLFFBQUk3eUIsQ0FBQyxHQUFHLElBQVI7O0FBRUEsUUFBSUEsQ0FBQyxDQUFDdlIsT0FBRixDQUFVNDRCLElBQVYsS0FBbUIsSUFBbkIsSUFBMkJybkIsQ0FBQyxDQUFDaXFCLFVBQUYsR0FBZWpxQixDQUFDLENBQUN2UixPQUFGLENBQVUrNUIsWUFBeEQsRUFBc0U7QUFDbEV4QyxNQUFBQSxDQUFDLENBQUMsSUFBRCxFQUFPaG1CLENBQUMsQ0FBQzBwQixLQUFULENBQUQsQ0FBaUJoZ0IsRUFBakIsQ0FBb0IsYUFBcEIsRUFBbUM7QUFDL0Jyb0MsUUFBQUEsT0FBTyxFQUFFO0FBRHNCLE9BQW5DLEVBRUcyK0IsQ0FBQyxDQUFDbXNCLFdBRkw7O0FBSUEsVUFBSW5zQixDQUFDLENBQUN2UixPQUFGLENBQVU2M0IsYUFBVixLQUE0QixJQUFoQyxFQUFzQztBQUNsQ3RtQixRQUFBQSxDQUFDLENBQUMwcEIsS0FBRixDQUFRaGdCLEVBQVIsQ0FBVyxlQUFYLEVBQTRCMUosQ0FBQyxDQUFDeXNCLFVBQTlCO0FBQ0g7QUFDSjs7QUFFRCxRQUFJenNCLENBQUMsQ0FBQ3ZSLE9BQUYsQ0FBVTQ0QixJQUFWLEtBQW1CLElBQW5CLElBQTJCcm5CLENBQUMsQ0FBQ3ZSLE9BQUYsQ0FBVXc1QixnQkFBVixLQUErQixJQUExRCxJQUFrRWpvQixDQUFDLENBQUNpcUIsVUFBRixHQUFlanFCLENBQUMsQ0FBQ3ZSLE9BQUYsQ0FBVSs1QixZQUEvRixFQUE2RztBQUV6R3hDLE1BQUFBLENBQUMsQ0FBQyxJQUFELEVBQU9obUIsQ0FBQyxDQUFDMHBCLEtBQVQsQ0FBRCxDQUNLaGdCLEVBREwsQ0FDUSxrQkFEUixFQUM0QnNjLENBQUMsQ0FBQ1QsS0FBRixDQUFRdmxCLENBQUMsQ0FBQ2d3QixTQUFWLEVBQXFCaHdCLENBQXJCLEVBQXdCLElBQXhCLENBRDVCLEVBRUswSixFQUZMLENBRVEsa0JBRlIsRUFFNEJzYyxDQUFDLENBQUNULEtBQUYsQ0FBUXZsQixDQUFDLENBQUNnd0IsU0FBVixFQUFxQmh3QixDQUFyQixFQUF3QixLQUF4QixDQUY1QjtBQUlIO0FBRUosR0F0QkQ7O0FBd0JBbW1CLEVBQUFBLEtBQUssQ0FBQ3hqRyxTQUFOLENBQWdCbXdHLGVBQWhCLEdBQWtDLFlBQVc7QUFFekMsUUFBSTl5QixDQUFDLEdBQUcsSUFBUjs7QUFFQSxRQUFLQSxDQUFDLENBQUN2UixPQUFGLENBQVVzNUIsWUFBZixFQUE4QjtBQUUxQi9uQixNQUFBQSxDQUFDLENBQUN5cUIsS0FBRixDQUFRL2dCLEVBQVIsQ0FBVyxrQkFBWCxFQUErQnNjLENBQUMsQ0FBQ1QsS0FBRixDQUFRdmxCLENBQUMsQ0FBQ2d3QixTQUFWLEVBQXFCaHdCLENBQXJCLEVBQXdCLElBQXhCLENBQS9COztBQUNBQSxNQUFBQSxDQUFDLENBQUN5cUIsS0FBRixDQUFRL2dCLEVBQVIsQ0FBVyxrQkFBWCxFQUErQnNjLENBQUMsQ0FBQ1QsS0FBRixDQUFRdmxCLENBQUMsQ0FBQ2d3QixTQUFWLEVBQXFCaHdCLENBQXJCLEVBQXdCLEtBQXhCLENBQS9CO0FBRUg7QUFFSixHQVhEOztBQWFBbW1CLEVBQUFBLEtBQUssQ0FBQ3hqRyxTQUFOLENBQWdCeXZHLGdCQUFoQixHQUFtQyxZQUFXO0FBRTFDLFFBQUlweUIsQ0FBQyxHQUFHLElBQVI7O0FBRUFBLElBQUFBLENBQUMsQ0FBQzR5QixlQUFGOztBQUVBNXlCLElBQUFBLENBQUMsQ0FBQzZ5QixhQUFGOztBQUNBN3lCLElBQUFBLENBQUMsQ0FBQzh5QixlQUFGOztBQUVBOXlCLElBQUFBLENBQUMsQ0FBQ3lxQixLQUFGLENBQVEvZ0IsRUFBUixDQUFXLGtDQUFYLEVBQStDO0FBQzNDbndDLE1BQUFBLE1BQU0sRUFBRTtBQURtQyxLQUEvQyxFQUVHeW1DLENBQUMsQ0FBQ3VzQixZQUZMOztBQUdBdnNCLElBQUFBLENBQUMsQ0FBQ3lxQixLQUFGLENBQVEvZ0IsRUFBUixDQUFXLGlDQUFYLEVBQThDO0FBQzFDbndDLE1BQUFBLE1BQU0sRUFBRTtBQURrQyxLQUE5QyxFQUVHeW1DLENBQUMsQ0FBQ3VzQixZQUZMOztBQUdBdnNCLElBQUFBLENBQUMsQ0FBQ3lxQixLQUFGLENBQVEvZ0IsRUFBUixDQUFXLDhCQUFYLEVBQTJDO0FBQ3ZDbndDLE1BQUFBLE1BQU0sRUFBRTtBQUQrQixLQUEzQyxFQUVHeW1DLENBQUMsQ0FBQ3VzQixZQUZMOztBQUdBdnNCLElBQUFBLENBQUMsQ0FBQ3lxQixLQUFGLENBQVEvZ0IsRUFBUixDQUFXLG9DQUFYLEVBQWlEO0FBQzdDbndDLE1BQUFBLE1BQU0sRUFBRTtBQURxQyxLQUFqRCxFQUVHeW1DLENBQUMsQ0FBQ3VzQixZQUZMOztBQUlBdnNCLElBQUFBLENBQUMsQ0FBQ3lxQixLQUFGLENBQVEvZ0IsRUFBUixDQUFXLGFBQVgsRUFBMEIxSixDQUFDLENBQUNvc0IsWUFBNUI7O0FBRUFwRyxJQUFBQSxDQUFDLENBQUNuMEYsUUFBRCxDQUFELENBQVk2M0UsRUFBWixDQUFlMUosQ0FBQyxDQUFDMnJCLGdCQUFqQixFQUFtQzNGLENBQUMsQ0FBQ1QsS0FBRixDQUFRdmxCLENBQUMsQ0FBQytTLFVBQVYsRUFBc0IvUyxDQUF0QixDQUFuQzs7QUFFQSxRQUFJQSxDQUFDLENBQUN2UixPQUFGLENBQVU2M0IsYUFBVixLQUE0QixJQUFoQyxFQUFzQztBQUNsQ3RtQixNQUFBQSxDQUFDLENBQUN5cUIsS0FBRixDQUFRL2dCLEVBQVIsQ0FBVyxlQUFYLEVBQTRCMUosQ0FBQyxDQUFDeXNCLFVBQTlCO0FBQ0g7O0FBRUQsUUFBSXpzQixDQUFDLENBQUN2UixPQUFGLENBQVVnNUIsYUFBVixLQUE0QixJQUFoQyxFQUFzQztBQUNsQ3pCLE1BQUFBLENBQUMsQ0FBQ2htQixDQUFDLENBQUNtcUIsV0FBSCxDQUFELENBQWlCM2lHLFFBQWpCLEdBQTRCa2lGLEVBQTVCLENBQStCLGFBQS9CLEVBQThDMUosQ0FBQyxDQUFDcXNCLGFBQWhEO0FBQ0g7O0FBRURyRyxJQUFBQSxDQUFDLENBQUMxaEcsTUFBRCxDQUFELENBQVVvbEYsRUFBVixDQUFhLG1DQUFtQzFKLENBQUMsQ0FBQ29tQixXQUFsRCxFQUErREosQ0FBQyxDQUFDVCxLQUFGLENBQVF2bEIsQ0FBQyxDQUFDa3dCLGlCQUFWLEVBQTZCbHdCLENBQTdCLENBQS9EO0FBRUFnbUIsSUFBQUEsQ0FBQyxDQUFDMWhHLE1BQUQsQ0FBRCxDQUFVb2xGLEVBQVYsQ0FBYSx3QkFBd0IxSixDQUFDLENBQUNvbUIsV0FBdkMsRUFBb0RKLENBQUMsQ0FBQ1QsS0FBRixDQUFRdmxCLENBQUMsQ0FBQ213QixNQUFWLEVBQWtCbndCLENBQWxCLENBQXBEO0FBRUFnbUIsSUFBQUEsQ0FBQyxDQUFDLG1CQUFELEVBQXNCaG1CLENBQUMsQ0FBQ21xQixXQUF4QixDQUFELENBQXNDemdCLEVBQXRDLENBQXlDLFdBQXpDLEVBQXNEMUosQ0FBQyxDQUFDejJFLGNBQXhEO0FBRUF5OEYsSUFBQUEsQ0FBQyxDQUFDMWhHLE1BQUQsQ0FBRCxDQUFVb2xGLEVBQVYsQ0FBYSxzQkFBc0IxSixDQUFDLENBQUNvbUIsV0FBckMsRUFBa0RwbUIsQ0FBQyxDQUFDc3NCLFdBQXBEO0FBQ0F0RyxJQUFBQSxDQUFDLENBQUNobUIsQ0FBQyxDQUFDc3NCLFdBQUgsQ0FBRDtBQUVILEdBM0NEOztBQTZDQW5HLEVBQUFBLEtBQUssQ0FBQ3hqRyxTQUFOLENBQWdCb3dHLE1BQWhCLEdBQXlCLFlBQVc7QUFFaEMsUUFBSS95QixDQUFDLEdBQUcsSUFBUjs7QUFFQSxRQUFJQSxDQUFDLENBQUN2UixPQUFGLENBQVVpNEIsTUFBVixLQUFxQixJQUFyQixJQUE2QjFtQixDQUFDLENBQUNpcUIsVUFBRixHQUFlanFCLENBQUMsQ0FBQ3ZSLE9BQUYsQ0FBVSs1QixZQUExRCxFQUF3RTtBQUVwRXhvQixNQUFBQSxDQUFDLENBQUMrcEIsVUFBRixDQUFhN2lCLElBQWI7O0FBQ0FsSCxNQUFBQSxDQUFDLENBQUM4cEIsVUFBRixDQUFhNWlCLElBQWI7QUFFSDs7QUFFRCxRQUFJbEgsQ0FBQyxDQUFDdlIsT0FBRixDQUFVNDRCLElBQVYsS0FBbUIsSUFBbkIsSUFBMkJybkIsQ0FBQyxDQUFDaXFCLFVBQUYsR0FBZWpxQixDQUFDLENBQUN2UixPQUFGLENBQVUrNUIsWUFBeEQsRUFBc0U7QUFFbEV4b0IsTUFBQUEsQ0FBQyxDQUFDMHBCLEtBQUYsQ0FBUXhpQixJQUFSO0FBRUg7QUFFSixHQWpCRDs7QUFtQkFpZixFQUFBQSxLQUFLLENBQUN4akcsU0FBTixDQUFnQjhwRyxVQUFoQixHQUE2QixVQUFTbmpHLEtBQVQsRUFBZ0I7QUFFekMsUUFBSTAyRSxDQUFDLEdBQUcsSUFBUixDQUZ5QyxDQUd4Qzs7O0FBQ0QsUUFBRyxDQUFDMTJFLEtBQUssQ0FBQ1MsTUFBTixDQUFhK2dCLE9BQWIsQ0FBcUJ1QixLQUFyQixDQUEyQix1QkFBM0IsQ0FBSixFQUF5RDtBQUNyRCxVQUFJL2lCLEtBQUssQ0FBQzJqRixPQUFOLEtBQWtCLEVBQWxCLElBQXdCak4sQ0FBQyxDQUFDdlIsT0FBRixDQUFVNjNCLGFBQVYsS0FBNEIsSUFBeEQsRUFBOEQ7QUFDMUR0bUIsUUFBQUEsQ0FBQyxDQUFDbXNCLFdBQUYsQ0FBYztBQUNWeGpHLFVBQUFBLElBQUksRUFBRTtBQUNGMDRDLFlBQUFBLE9BQU8sRUFBRTIrQixDQUFDLENBQUN2UixPQUFGLENBQVU0NUIsR0FBVixLQUFrQixJQUFsQixHQUF5QixNQUF6QixHQUFtQztBQUQxQztBQURJLFNBQWQ7QUFLSCxPQU5ELE1BTU8sSUFBSS8rRixLQUFLLENBQUMyakYsT0FBTixLQUFrQixFQUFsQixJQUF3QmpOLENBQUMsQ0FBQ3ZSLE9BQUYsQ0FBVTYzQixhQUFWLEtBQTRCLElBQXhELEVBQThEO0FBQ2pFdG1CLFFBQUFBLENBQUMsQ0FBQ21zQixXQUFGLENBQWM7QUFDVnhqRyxVQUFBQSxJQUFJLEVBQUU7QUFDRjA0QyxZQUFBQSxPQUFPLEVBQUUyK0IsQ0FBQyxDQUFDdlIsT0FBRixDQUFVNDVCLEdBQVYsS0FBa0IsSUFBbEIsR0FBeUIsVUFBekIsR0FBc0M7QUFEN0M7QUFESSxTQUFkO0FBS0g7QUFDSjtBQUVKLEdBcEJEOztBQXNCQWxDLEVBQUFBLEtBQUssQ0FBQ3hqRyxTQUFOLENBQWdCa2xHLFFBQWhCLEdBQTJCLFlBQVc7QUFFbEMsUUFBSTduQixDQUFDLEdBQUcsSUFBUjtBQUFBLFFBQ0lnekIsU0FESjtBQUFBLFFBQ2VDLFVBRGY7QUFBQSxRQUMyQkMsVUFEM0I7QUFBQSxRQUN1Q0MsUUFEdkM7O0FBR0EsYUFBU0MsVUFBVCxDQUFvQkMsV0FBcEIsRUFBaUM7QUFFN0JyTixNQUFBQSxDQUFDLENBQUMsZ0JBQUQsRUFBbUJxTixXQUFuQixDQUFELENBQWlDcHBELElBQWpDLENBQXNDLFlBQVc7QUFFN0MsWUFBSTR3QixLQUFLLEdBQUdtckIsQ0FBQyxDQUFDLElBQUQsQ0FBYjtBQUFBLFlBQ0lzTixXQUFXLEdBQUd0TixDQUFDLENBQUMsSUFBRCxDQUFELENBQVFoOEUsSUFBUixDQUFhLFdBQWIsQ0FEbEI7QUFBQSxZQUVJdXBGLFdBQVcsR0FBR3ZOLENBQUMsQ0FBQyxJQUFELENBQUQsQ0FBUWg4RSxJQUFSLENBQWEsYUFBYixDQUZsQjtBQUFBLFlBR0l3cEYsVUFBVSxHQUFJeE4sQ0FBQyxDQUFDLElBQUQsQ0FBRCxDQUFRaDhFLElBQVIsQ0FBYSxZQUFiLEtBQThCZzJELENBQUMsQ0FBQ3VyQixPQUFGLENBQVV2aEYsSUFBVixDQUFlLFlBQWYsQ0FIaEQ7QUFBQSxZQUlJeXBGLFdBQVcsR0FBRzVoRyxRQUFRLENBQUNqTSxhQUFULENBQXVCLEtBQXZCLENBSmxCOztBQU1BNnRHLFFBQUFBLFdBQVcsQ0FBQ2hSLE1BQVosR0FBcUIsWUFBVztBQUU1QjVuQixVQUFBQSxLQUFLLENBQ0F0OUQsT0FETCxDQUNhO0FBQUUyMkUsWUFBQUEsT0FBTyxFQUFFO0FBQVgsV0FEYixFQUM2QixHQUQ3QixFQUNrQyxZQUFXO0FBRXJDLGdCQUFJcWYsV0FBSixFQUFpQjtBQUNiMTRCLGNBQUFBLEtBQUssQ0FDQTd3RCxJQURMLENBQ1UsUUFEVixFQUNvQnVwRixXQURwQjs7QUFHQSxrQkFBSUMsVUFBSixFQUFnQjtBQUNaMzRCLGdCQUFBQSxLQUFLLENBQ0E3d0QsSUFETCxDQUNVLE9BRFYsRUFDbUJ3cEYsVUFEbkI7QUFFSDtBQUNKOztBQUVEMzRCLFlBQUFBLEtBQUssQ0FDQTd3RCxJQURMLENBQ1UsS0FEVixFQUNpQnNwRixXQURqQixFQUVLLzFGLE9BRkwsQ0FFYTtBQUFFMjJFLGNBQUFBLE9BQU8sRUFBRTtBQUFYLGFBRmIsRUFFNkIsR0FGN0IsRUFFa0MsWUFBVztBQUNyQ3JaLGNBQUFBLEtBQUssQ0FDQWllLFVBREwsQ0FDZ0Isa0NBRGhCLEVBRUtnQixXQUZMLENBRWlCLGVBRmpCO0FBR0gsYUFOTDs7QUFPQTlaLFlBQUFBLENBQUMsQ0FBQ3VyQixPQUFGLENBQVUzekYsT0FBVixDQUFrQixZQUFsQixFQUFnQyxDQUFDb29FLENBQUQsRUFBSW5GLEtBQUosRUFBV3k0QixXQUFYLENBQWhDO0FBQ0gsV0FyQkw7QUF1QkgsU0F6QkQ7O0FBMkJBRyxRQUFBQSxXQUFXLENBQUMvUSxPQUFaLEdBQXNCLFlBQVc7QUFFN0I3bkIsVUFBQUEsS0FBSyxDQUNBaWUsVUFETCxDQUNpQixXQURqQixFQUVLZ0IsV0FGTCxDQUVrQixlQUZsQixFQUdLSCxRQUhMLENBR2Usc0JBSGY7O0FBS0EzWixVQUFBQSxDQUFDLENBQUN1ckIsT0FBRixDQUFVM3pGLE9BQVYsQ0FBa0IsZUFBbEIsRUFBbUMsQ0FBRW9vRSxDQUFGLEVBQUtuRixLQUFMLEVBQVl5NEIsV0FBWixDQUFuQztBQUVILFNBVEQ7O0FBV0FHLFFBQUFBLFdBQVcsQ0FBQzFtQyxHQUFaLEdBQWtCdW1DLFdBQWxCO0FBRUgsT0FoREQ7QUFrREg7O0FBRUQsUUFBSXR6QixDQUFDLENBQUN2UixPQUFGLENBQVV1NEIsVUFBVixLQUF5QixJQUE3QixFQUFtQztBQUMvQixVQUFJaG5CLENBQUMsQ0FBQ3ZSLE9BQUYsQ0FBVWs1QixRQUFWLEtBQXVCLElBQTNCLEVBQWlDO0FBQzdCdUwsUUFBQUEsVUFBVSxHQUFHbHpCLENBQUMsQ0FBQ3lwQixZQUFGLElBQWtCenBCLENBQUMsQ0FBQ3ZSLE9BQUYsQ0FBVSs1QixZQUFWLEdBQXlCLENBQXpCLEdBQTZCLENBQS9DLENBQWI7QUFDQTJLLFFBQUFBLFFBQVEsR0FBR0QsVUFBVSxHQUFHbHpCLENBQUMsQ0FBQ3ZSLE9BQUYsQ0FBVSs1QixZQUF2QixHQUFzQyxDQUFqRDtBQUNILE9BSEQsTUFHTztBQUNIMEssUUFBQUEsVUFBVSxHQUFHanVHLElBQUksQ0FBQ29HLEdBQUwsQ0FBUyxDQUFULEVBQVkyMEUsQ0FBQyxDQUFDeXBCLFlBQUYsSUFBa0J6cEIsQ0FBQyxDQUFDdlIsT0FBRixDQUFVKzVCLFlBQVYsR0FBeUIsQ0FBekIsR0FBNkIsQ0FBL0MsQ0FBWixDQUFiO0FBQ0EySyxRQUFBQSxRQUFRLEdBQUcsS0FBS256QixDQUFDLENBQUN2UixPQUFGLENBQVUrNUIsWUFBVixHQUF5QixDQUF6QixHQUE2QixDQUFsQyxJQUF1Q3hvQixDQUFDLENBQUN5cEIsWUFBcEQ7QUFDSDtBQUNKLEtBUkQsTUFRTztBQUNIeUosTUFBQUEsVUFBVSxHQUFHbHpCLENBQUMsQ0FBQ3ZSLE9BQUYsQ0FBVWs1QixRQUFWLEdBQXFCM25CLENBQUMsQ0FBQ3ZSLE9BQUYsQ0FBVSs1QixZQUFWLEdBQXlCeG9CLENBQUMsQ0FBQ3lwQixZQUFoRCxHQUErRHpwQixDQUFDLENBQUN5cEIsWUFBOUU7QUFDQTBKLE1BQUFBLFFBQVEsR0FBR2x1RyxJQUFJLENBQUMrc0IsSUFBTCxDQUFVa2hGLFVBQVUsR0FBR2x6QixDQUFDLENBQUN2UixPQUFGLENBQVUrNUIsWUFBakMsQ0FBWDs7QUFDQSxVQUFJeG9CLENBQUMsQ0FBQ3ZSLE9BQUYsQ0FBVSs0QixJQUFWLEtBQW1CLElBQXZCLEVBQTZCO0FBQ3pCLFlBQUkwTCxVQUFVLEdBQUcsQ0FBakIsRUFBb0JBLFVBQVU7QUFDOUIsWUFBSUMsUUFBUSxJQUFJbnpCLENBQUMsQ0FBQ2lxQixVQUFsQixFQUE4QmtKLFFBQVE7QUFDekM7QUFDSjs7QUFFREgsSUFBQUEsU0FBUyxHQUFHaHpCLENBQUMsQ0FBQ3VyQixPQUFGLENBQVVoMUIsSUFBVixDQUFlLGNBQWYsRUFBK0JwdUQsS0FBL0IsQ0FBcUMrcUYsVUFBckMsRUFBaURDLFFBQWpELENBQVo7O0FBRUEsUUFBSW56QixDQUFDLENBQUN2UixPQUFGLENBQVVvNUIsUUFBVixLQUF1QixhQUEzQixFQUEwQztBQUN0QyxVQUFJNkwsU0FBUyxHQUFHUixVQUFVLEdBQUcsQ0FBN0I7QUFBQSxVQUNJUyxTQUFTLEdBQUdSLFFBRGhCO0FBQUEsVUFFSS9JLE9BQU8sR0FBR3BxQixDQUFDLENBQUN1ckIsT0FBRixDQUFVaDFCLElBQVYsQ0FBZSxjQUFmLENBRmQ7O0FBSUEsV0FBSyxJQUFJanZFLENBQUMsR0FBRyxDQUFiLEVBQWdCQSxDQUFDLEdBQUcwNEUsQ0FBQyxDQUFDdlIsT0FBRixDQUFVZzZCLGNBQTlCLEVBQThDbmhHLENBQUMsRUFBL0MsRUFBbUQ7QUFDL0MsWUFBSW9zRyxTQUFTLEdBQUcsQ0FBaEIsRUFBbUJBLFNBQVMsR0FBRzF6QixDQUFDLENBQUNpcUIsVUFBRixHQUFlLENBQTNCO0FBQ25CK0ksUUFBQUEsU0FBUyxHQUFHQSxTQUFTLENBQUMvcUcsR0FBVixDQUFjbWlHLE9BQU8sQ0FBQ2w4QixFQUFSLENBQVd3bEMsU0FBWCxDQUFkLENBQVo7QUFDQVYsUUFBQUEsU0FBUyxHQUFHQSxTQUFTLENBQUMvcUcsR0FBVixDQUFjbWlHLE9BQU8sQ0FBQ2w4QixFQUFSLENBQVd5bEMsU0FBWCxDQUFkLENBQVo7QUFDQUQsUUFBQUEsU0FBUztBQUNUQyxRQUFBQSxTQUFTO0FBQ1o7QUFDSjs7QUFFRFAsSUFBQUEsVUFBVSxDQUFDSixTQUFELENBQVY7O0FBRUEsUUFBSWh6QixDQUFDLENBQUNpcUIsVUFBRixJQUFnQmpxQixDQUFDLENBQUN2UixPQUFGLENBQVUrNUIsWUFBOUIsRUFBNEM7QUFDeEN5SyxNQUFBQSxVQUFVLEdBQUdqekIsQ0FBQyxDQUFDdXJCLE9BQUYsQ0FBVWgxQixJQUFWLENBQWUsY0FBZixDQUFiO0FBQ0E2OEIsTUFBQUEsVUFBVSxDQUFDSCxVQUFELENBQVY7QUFDSCxLQUhELE1BSUEsSUFBSWp6QixDQUFDLENBQUN5cEIsWUFBRixJQUFrQnpwQixDQUFDLENBQUNpcUIsVUFBRixHQUFlanFCLENBQUMsQ0FBQ3ZSLE9BQUYsQ0FBVSs1QixZQUEvQyxFQUE2RDtBQUN6RHlLLE1BQUFBLFVBQVUsR0FBR2p6QixDQUFDLENBQUN1ckIsT0FBRixDQUFVaDFCLElBQVYsQ0FBZSxlQUFmLEVBQWdDcHVELEtBQWhDLENBQXNDLENBQXRDLEVBQXlDNjNELENBQUMsQ0FBQ3ZSLE9BQUYsQ0FBVSs1QixZQUFuRCxDQUFiO0FBQ0E0SyxNQUFBQSxVQUFVLENBQUNILFVBQUQsQ0FBVjtBQUNILEtBSEQsTUFHTyxJQUFJanpCLENBQUMsQ0FBQ3lwQixZQUFGLEtBQW1CLENBQXZCLEVBQTBCO0FBQzdCd0osTUFBQUEsVUFBVSxHQUFHanpCLENBQUMsQ0FBQ3VyQixPQUFGLENBQVVoMUIsSUFBVixDQUFlLGVBQWYsRUFBZ0NwdUQsS0FBaEMsQ0FBc0M2M0QsQ0FBQyxDQUFDdlIsT0FBRixDQUFVKzVCLFlBQVYsR0FBeUIsQ0FBQyxDQUFoRSxDQUFiO0FBQ0E0SyxNQUFBQSxVQUFVLENBQUNILFVBQUQsQ0FBVjtBQUNIO0FBRUosR0ExR0Q7O0FBNEdBOU0sRUFBQUEsS0FBSyxDQUFDeGpHLFNBQU4sQ0FBZ0J3dkcsVUFBaEIsR0FBNkIsWUFBVztBQUVwQyxRQUFJbnlCLENBQUMsR0FBRyxJQUFSOztBQUVBQSxJQUFBQSxDQUFDLENBQUNzc0IsV0FBRjs7QUFFQXRzQixJQUFBQSxDQUFDLENBQUNtcUIsV0FBRixDQUFjNTlELEdBQWQsQ0FBa0I7QUFDZDJuRCxNQUFBQSxPQUFPLEVBQUU7QUFESyxLQUFsQjs7QUFJQWxVLElBQUFBLENBQUMsQ0FBQ3VyQixPQUFGLENBQVV6UixXQUFWLENBQXNCLGVBQXRCOztBQUVBOVosSUFBQUEsQ0FBQyxDQUFDK3lCLE1BQUY7O0FBRUEsUUFBSS95QixDQUFDLENBQUN2UixPQUFGLENBQVVvNUIsUUFBVixLQUF1QixhQUEzQixFQUEwQztBQUN0QzduQixNQUFBQSxDQUFDLENBQUM0ekIsbUJBQUY7QUFDSDtBQUVKLEdBbEJEOztBQW9CQXpOLEVBQUFBLEtBQUssQ0FBQ3hqRyxTQUFOLENBQWdCZzFDLElBQWhCLEdBQXVCd3VELEtBQUssQ0FBQ3hqRyxTQUFOLENBQWdCa3hHLFNBQWhCLEdBQTRCLFlBQVc7QUFFMUQsUUFBSTd6QixDQUFDLEdBQUcsSUFBUjs7QUFFQUEsSUFBQUEsQ0FBQyxDQUFDbXNCLFdBQUYsQ0FBYztBQUNWeGpHLE1BQUFBLElBQUksRUFBRTtBQUNGMDRDLFFBQUFBLE9BQU8sRUFBRTtBQURQO0FBREksS0FBZDtBQU1ILEdBVkQ7O0FBWUE4a0QsRUFBQUEsS0FBSyxDQUFDeGpHLFNBQU4sQ0FBZ0J1dEcsaUJBQWhCLEdBQW9DLFlBQVc7QUFFM0MsUUFBSWx3QixDQUFDLEdBQUcsSUFBUjs7QUFFQUEsSUFBQUEsQ0FBQyxDQUFDK3VCLGVBQUY7O0FBQ0EvdUIsSUFBQUEsQ0FBQyxDQUFDc3NCLFdBQUY7QUFFSCxHQVBEOztBQVNBbkcsRUFBQUEsS0FBSyxDQUFDeGpHLFNBQU4sQ0FBZ0JxaEMsS0FBaEIsR0FBd0JtaUUsS0FBSyxDQUFDeGpHLFNBQU4sQ0FBZ0JteEcsVUFBaEIsR0FBNkIsWUFBVztBQUU1RCxRQUFJOXpCLENBQUMsR0FBRyxJQUFSOztBQUVBQSxJQUFBQSxDQUFDLENBQUNpc0IsYUFBRjs7QUFDQWpzQixJQUFBQSxDQUFDLENBQUM5cEMsTUFBRixHQUFXLElBQVg7QUFFSCxHQVBEOztBQVNBaXdELEVBQUFBLEtBQUssQ0FBQ3hqRyxTQUFOLENBQWdCNGIsSUFBaEIsR0FBdUI0bkYsS0FBSyxDQUFDeGpHLFNBQU4sQ0FBZ0JveEcsU0FBaEIsR0FBNEIsWUFBVztBQUUxRCxRQUFJL3pCLENBQUMsR0FBRyxJQUFSOztBQUVBQSxJQUFBQSxDQUFDLENBQUNnc0IsUUFBRjs7QUFDQWhzQixJQUFBQSxDQUFDLENBQUN2UixPQUFGLENBQVVxNEIsUUFBVixHQUFxQixJQUFyQjtBQUNBOW1CLElBQUFBLENBQUMsQ0FBQzlwQyxNQUFGLEdBQVcsS0FBWDtBQUNBOHBDLElBQUFBLENBQUMsQ0FBQ21yQixRQUFGLEdBQWEsS0FBYjtBQUNBbnJCLElBQUFBLENBQUMsQ0FBQzdsRSxXQUFGLEdBQWdCLEtBQWhCO0FBRUgsR0FWRDs7QUFZQWdzRixFQUFBQSxLQUFLLENBQUN4akcsU0FBTixDQUFnQnF4RyxTQUFoQixHQUE0QixVQUFTN3FGLEtBQVQsRUFBZ0I7QUFFeEMsUUFBSTYyRCxDQUFDLEdBQUcsSUFBUjs7QUFFQSxRQUFJLENBQUNBLENBQUMsQ0FBQzRxQixTQUFQLEVBQW1CO0FBRWY1cUIsTUFBQUEsQ0FBQyxDQUFDdXJCLE9BQUYsQ0FBVTN6RixPQUFWLENBQWtCLGFBQWxCLEVBQWlDLENBQUNvb0UsQ0FBRCxFQUFJNzJELEtBQUosQ0FBakM7O0FBRUE2MkQsTUFBQUEsQ0FBQyxDQUFDcXBCLFNBQUYsR0FBYyxLQUFkOztBQUVBLFVBQUlycEIsQ0FBQyxDQUFDaXFCLFVBQUYsR0FBZWpxQixDQUFDLENBQUN2UixPQUFGLENBQVUrNUIsWUFBN0IsRUFBMkM7QUFDdkN4b0IsUUFBQUEsQ0FBQyxDQUFDc3NCLFdBQUY7QUFDSDs7QUFFRHRzQixNQUFBQSxDQUFDLENBQUN1cUIsU0FBRixHQUFjLElBQWQ7O0FBRUEsVUFBS3ZxQixDQUFDLENBQUN2UixPQUFGLENBQVVxNEIsUUFBZixFQUEwQjtBQUN0QjltQixRQUFBQSxDQUFDLENBQUNnc0IsUUFBRjtBQUNIOztBQUVELFVBQUloc0IsQ0FBQyxDQUFDdlIsT0FBRixDQUFVNjNCLGFBQVYsS0FBNEIsSUFBaEMsRUFBc0M7QUFDbEN0bUIsUUFBQUEsQ0FBQyxDQUFDc3lCLE9BQUY7O0FBRUEsWUFBSXR5QixDQUFDLENBQUN2UixPQUFGLENBQVVpNUIsYUFBZCxFQUE2QjtBQUN6QixjQUFJdU0sYUFBYSxHQUFHak8sQ0FBQyxDQUFDaG1CLENBQUMsQ0FBQ29xQixPQUFGLENBQVV2MEYsR0FBVixDQUFjbXFFLENBQUMsQ0FBQ3lwQixZQUFoQixDQUFELENBQXJCO0FBQ0F3SyxVQUFBQSxhQUFhLENBQUNqcUYsSUFBZCxDQUFtQixVQUFuQixFQUErQixDQUEvQixFQUFrQ29qRSxLQUFsQztBQUNIO0FBQ0o7QUFFSjtBQUVKLEdBL0JEOztBQWlDQStZLEVBQUFBLEtBQUssQ0FBQ3hqRyxTQUFOLENBQWdCeWhELElBQWhCLEdBQXVCK2hELEtBQUssQ0FBQ3hqRyxTQUFOLENBQWdCdXhHLFNBQWhCLEdBQTRCLFlBQVc7QUFFMUQsUUFBSWwwQixDQUFDLEdBQUcsSUFBUjs7QUFFQUEsSUFBQUEsQ0FBQyxDQUFDbXNCLFdBQUYsQ0FBYztBQUNWeGpHLE1BQUFBLElBQUksRUFBRTtBQUNGMDRDLFFBQUFBLE9BQU8sRUFBRTtBQURQO0FBREksS0FBZDtBQU1ILEdBVkQ7O0FBWUE4a0QsRUFBQUEsS0FBSyxDQUFDeGpHLFNBQU4sQ0FBZ0I0RyxjQUFoQixHQUFpQyxVQUFTRCxLQUFULEVBQWdCO0FBRTdDQSxJQUFBQSxLQUFLLENBQUNDLGNBQU47QUFFSCxHQUpEOztBQU1BNDhGLEVBQUFBLEtBQUssQ0FBQ3hqRyxTQUFOLENBQWdCaXhHLG1CQUFoQixHQUFzQyxVQUFVTyxRQUFWLEVBQXFCO0FBRXZEQSxJQUFBQSxRQUFRLEdBQUdBLFFBQVEsSUFBSSxDQUF2Qjs7QUFFQSxRQUFJbjBCLENBQUMsR0FBRyxJQUFSO0FBQUEsUUFDSW8wQixXQUFXLEdBQUdwTyxDQUFDLENBQUUsZ0JBQUYsRUFBb0JobUIsQ0FBQyxDQUFDdXJCLE9BQXRCLENBRG5CO0FBQUEsUUFFSTF3QixLQUZKO0FBQUEsUUFHSXk0QixXQUhKO0FBQUEsUUFJSUMsV0FKSjtBQUFBLFFBS0lDLFVBTEo7QUFBQSxRQU1JQyxXQU5KOztBQVFBLFFBQUtXLFdBQVcsQ0FBQzdzRyxNQUFqQixFQUEwQjtBQUV0QnN6RSxNQUFBQSxLQUFLLEdBQUd1NUIsV0FBVyxDQUFDcitFLEtBQVosRUFBUjtBQUNBdTlFLE1BQUFBLFdBQVcsR0FBR3o0QixLQUFLLENBQUM3d0QsSUFBTixDQUFXLFdBQVgsQ0FBZDtBQUNBdXBGLE1BQUFBLFdBQVcsR0FBRzE0QixLQUFLLENBQUM3d0QsSUFBTixDQUFXLGFBQVgsQ0FBZDtBQUNBd3BGLE1BQUFBLFVBQVUsR0FBSTM0QixLQUFLLENBQUM3d0QsSUFBTixDQUFXLFlBQVgsS0FBNEJnMkQsQ0FBQyxDQUFDdXJCLE9BQUYsQ0FBVXZoRixJQUFWLENBQWUsWUFBZixDQUExQztBQUNBeXBGLE1BQUFBLFdBQVcsR0FBRzVoRyxRQUFRLENBQUNqTSxhQUFULENBQXVCLEtBQXZCLENBQWQ7O0FBRUE2dEcsTUFBQUEsV0FBVyxDQUFDaFIsTUFBWixHQUFxQixZQUFXO0FBRTVCLFlBQUk4USxXQUFKLEVBQWlCO0FBQ2IxNEIsVUFBQUEsS0FBSyxDQUNBN3dELElBREwsQ0FDVSxRQURWLEVBQ29CdXBGLFdBRHBCOztBQUdBLGNBQUlDLFVBQUosRUFBZ0I7QUFDWjM0QixZQUFBQSxLQUFLLENBQ0E3d0QsSUFETCxDQUNVLE9BRFYsRUFDbUJ3cEYsVUFEbkI7QUFFSDtBQUNKOztBQUVEMzRCLFFBQUFBLEtBQUssQ0FDQTd3RCxJQURMLENBQ1csS0FEWCxFQUNrQnNwRixXQURsQixFQUVLeGEsVUFGTCxDQUVnQixrQ0FGaEIsRUFHS2dCLFdBSEwsQ0FHaUIsZUFIakI7O0FBS0EsWUFBSzlaLENBQUMsQ0FBQ3ZSLE9BQUYsQ0FBVTgzQixjQUFWLEtBQTZCLElBQWxDLEVBQXlDO0FBQ3JDdm1CLFVBQUFBLENBQUMsQ0FBQ3NzQixXQUFGO0FBQ0g7O0FBRUR0c0IsUUFBQUEsQ0FBQyxDQUFDdXJCLE9BQUYsQ0FBVTN6RixPQUFWLENBQWtCLFlBQWxCLEVBQWdDLENBQUVvb0UsQ0FBRixFQUFLbkYsS0FBTCxFQUFZeTRCLFdBQVosQ0FBaEM7O0FBQ0F0ekIsUUFBQUEsQ0FBQyxDQUFDNHpCLG1CQUFGO0FBRUgsT0F4QkQ7O0FBMEJBSCxNQUFBQSxXQUFXLENBQUMvUSxPQUFaLEdBQXNCLFlBQVc7QUFFN0IsWUFBS3lSLFFBQVEsR0FBRyxDQUFoQixFQUFvQjtBQUVoQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNvQnJ6RSxVQUFBQSxVQUFVLENBQUUsWUFBVztBQUNuQmsvQyxZQUFBQSxDQUFDLENBQUM0ekIsbUJBQUYsQ0FBdUJPLFFBQVEsR0FBRyxDQUFsQztBQUNILFdBRlMsRUFFUCxHQUZPLENBQVY7QUFJSCxTQVhELE1BV087QUFFSHQ1QixVQUFBQSxLQUFLLENBQ0FpZSxVQURMLENBQ2lCLFdBRGpCLEVBRUtnQixXQUZMLENBRWtCLGVBRmxCLEVBR0tILFFBSEwsQ0FHZSxzQkFIZjs7QUFLQTNaLFVBQUFBLENBQUMsQ0FBQ3VyQixPQUFGLENBQVUzekYsT0FBVixDQUFrQixlQUFsQixFQUFtQyxDQUFFb29FLENBQUYsRUFBS25GLEtBQUwsRUFBWXk0QixXQUFaLENBQW5DOztBQUVBdHpCLFVBQUFBLENBQUMsQ0FBQzR6QixtQkFBRjtBQUVIO0FBRUosT0ExQkQ7O0FBNEJBSCxNQUFBQSxXQUFXLENBQUMxbUMsR0FBWixHQUFrQnVtQyxXQUFsQjtBQUVILEtBaEVELE1BZ0VPO0FBRUh0ekIsTUFBQUEsQ0FBQyxDQUFDdXJCLE9BQUYsQ0FBVTN6RixPQUFWLENBQWtCLGlCQUFsQixFQUFxQyxDQUFFb29FLENBQUYsQ0FBckM7QUFFSDtBQUVKLEdBbEZEOztBQW9GQW1tQixFQUFBQSxLQUFLLENBQUN4akcsU0FBTixDQUFnQm9zQyxPQUFoQixHQUEwQixVQUFVc2xFLFlBQVYsRUFBeUI7QUFFL0MsUUFBSXIwQixDQUFDLEdBQUcsSUFBUjtBQUFBLFFBQWN5cEIsWUFBZDtBQUFBLFFBQTRCNkssZ0JBQTVCOztBQUVBQSxJQUFBQSxnQkFBZ0IsR0FBR3QwQixDQUFDLENBQUNpcUIsVUFBRixHQUFlanFCLENBQUMsQ0FBQ3ZSLE9BQUYsQ0FBVSs1QixZQUE1QyxDQUorQyxDQU0vQztBQUNBOztBQUNBLFFBQUksQ0FBQ3hvQixDQUFDLENBQUN2UixPQUFGLENBQVVrNUIsUUFBWCxJQUF5QjNuQixDQUFDLENBQUN5cEIsWUFBRixHQUFpQjZLLGdCQUE5QyxFQUFrRTtBQUM5RHQwQixNQUFBQSxDQUFDLENBQUN5cEIsWUFBRixHQUFpQjZLLGdCQUFqQjtBQUNILEtBVjhDLENBWS9DOzs7QUFDQSxRQUFLdDBCLENBQUMsQ0FBQ2lxQixVQUFGLElBQWdCanFCLENBQUMsQ0FBQ3ZSLE9BQUYsQ0FBVSs1QixZQUEvQixFQUE4QztBQUMxQ3hvQixNQUFBQSxDQUFDLENBQUN5cEIsWUFBRixHQUFpQixDQUFqQjtBQUVIOztBQUVEQSxJQUFBQSxZQUFZLEdBQUd6cEIsQ0FBQyxDQUFDeXBCLFlBQWpCOztBQUVBenBCLElBQUFBLENBQUMsQ0FBQ3F3QixPQUFGLENBQVUsSUFBVjs7QUFFQXJLLElBQUFBLENBQUMsQ0FBQ3gzQixNQUFGLENBQVN3UixDQUFULEVBQVlBLENBQUMsQ0FBQ29wQixRQUFkLEVBQXdCO0FBQUVLLE1BQUFBLFlBQVksRUFBRUE7QUFBaEIsS0FBeEI7O0FBRUF6cEIsSUFBQUEsQ0FBQyxDQUFDamxELElBQUY7O0FBRUEsUUFBSSxDQUFDczVFLFlBQUwsRUFBb0I7QUFFaEJyMEIsTUFBQUEsQ0FBQyxDQUFDbXNCLFdBQUYsQ0FBYztBQUNWeGpHLFFBQUFBLElBQUksRUFBRTtBQUNGMDRDLFVBQUFBLE9BQU8sRUFBRSxPQURQO0FBRUZsNEIsVUFBQUEsS0FBSyxFQUFFc2dGO0FBRkw7QUFESSxPQUFkLEVBS0csS0FMSDtBQU9IO0FBRUosR0FyQ0Q7O0FBdUNBdEQsRUFBQUEsS0FBSyxDQUFDeGpHLFNBQU4sQ0FBZ0JncUcsbUJBQWhCLEdBQXNDLFlBQVc7QUFFN0MsUUFBSTNzQixDQUFDLEdBQUcsSUFBUjtBQUFBLFFBQWNpdkIsVUFBZDtBQUFBLFFBQTBCc0YsaUJBQTFCO0FBQUEsUUFBNkNsa0csQ0FBN0M7QUFBQSxRQUNJbWtHLGtCQUFrQixHQUFHeDBCLENBQUMsQ0FBQ3ZSLE9BQUYsQ0FBVTA1QixVQUFWLElBQXdCLElBRGpEOztBQUdBLFFBQUtuQyxDQUFDLENBQUN6Z0csSUFBRixDQUFPaXZHLGtCQUFQLE1BQStCLE9BQS9CLElBQTBDQSxrQkFBa0IsQ0FBQ2p0RyxNQUFsRSxFQUEyRTtBQUV2RXk0RSxNQUFBQSxDQUFDLENBQUNrb0IsU0FBRixHQUFjbG9CLENBQUMsQ0FBQ3ZSLE9BQUYsQ0FBVXk1QixTQUFWLElBQXVCLFFBQXJDOztBQUVBLFdBQU0rRyxVQUFOLElBQW9CdUYsa0JBQXBCLEVBQXlDO0FBRXJDbmtHLFFBQUFBLENBQUMsR0FBRzJ2RSxDQUFDLENBQUNnckIsV0FBRixDQUFjempHLE1BQWQsR0FBcUIsQ0FBekI7O0FBRUEsWUFBSWl0RyxrQkFBa0IsQ0FBQ2pvQyxjQUFuQixDQUFrQzBpQyxVQUFsQyxDQUFKLEVBQW1EO0FBQy9Dc0YsVUFBQUEsaUJBQWlCLEdBQUdDLGtCQUFrQixDQUFDdkYsVUFBRCxDQUFsQixDQUErQkEsVUFBbkQsQ0FEK0MsQ0FHL0M7QUFDQTs7QUFDQSxpQkFBTzUrRixDQUFDLElBQUksQ0FBWixFQUFnQjtBQUNaLGdCQUFJMnZFLENBQUMsQ0FBQ2dyQixXQUFGLENBQWMzNkYsQ0FBZCxLQUFvQjJ2RSxDQUFDLENBQUNnckIsV0FBRixDQUFjMzZGLENBQWQsTUFBcUJra0csaUJBQTdDLEVBQWlFO0FBQzdEdjBCLGNBQUFBLENBQUMsQ0FBQ2dyQixXQUFGLENBQWMzaUcsTUFBZCxDQUFxQmdJLENBQXJCLEVBQXVCLENBQXZCO0FBQ0g7O0FBQ0RBLFlBQUFBLENBQUM7QUFDSjs7QUFFRDJ2RSxVQUFBQSxDQUFDLENBQUNnckIsV0FBRixDQUFjampHLElBQWQsQ0FBbUJ3c0csaUJBQW5COztBQUNBdjBCLFVBQUFBLENBQUMsQ0FBQ2lyQixrQkFBRixDQUFxQnNKLGlCQUFyQixJQUEwQ0Msa0JBQWtCLENBQUN2RixVQUFELENBQWxCLENBQStCM1AsUUFBekU7QUFFSDtBQUVKOztBQUVEdGYsTUFBQUEsQ0FBQyxDQUFDZ3JCLFdBQUYsQ0FBY3hnRSxJQUFkLENBQW1CLFVBQVNwNkIsQ0FBVCxFQUFZMlIsQ0FBWixFQUFlO0FBQzlCLGVBQVNpK0QsQ0FBQyxDQUFDdlIsT0FBRixDQUFVcTVCLFdBQVosR0FBNEIxM0YsQ0FBQyxHQUFDMlIsQ0FBOUIsR0FBa0NBLENBQUMsR0FBQzNSLENBQTNDO0FBQ0gsT0FGRDtBQUlIO0FBRUosR0F0Q0Q7O0FBd0NBKzFGLEVBQUFBLEtBQUssQ0FBQ3hqRyxTQUFOLENBQWdCdXFHLE1BQWhCLEdBQXlCLFlBQVc7QUFFaEMsUUFBSWx0QixDQUFDLEdBQUcsSUFBUjs7QUFFQUEsSUFBQUEsQ0FBQyxDQUFDb3FCLE9BQUYsR0FDSXBxQixDQUFDLENBQUNtcUIsV0FBRixDQUNLM2lHLFFBREwsQ0FDY3c0RSxDQUFDLENBQUN2UixPQUFGLENBQVU2NUIsS0FEeEIsRUFFSzNPLFFBRkwsQ0FFYyxhQUZkLENBREo7QUFLQTNaLElBQUFBLENBQUMsQ0FBQ2lxQixVQUFGLEdBQWVqcUIsQ0FBQyxDQUFDb3FCLE9BQUYsQ0FBVTdpRyxNQUF6Qjs7QUFFQSxRQUFJeTRFLENBQUMsQ0FBQ3lwQixZQUFGLElBQWtCenBCLENBQUMsQ0FBQ2lxQixVQUFwQixJQUFrQ2pxQixDQUFDLENBQUN5cEIsWUFBRixLQUFtQixDQUF6RCxFQUE0RDtBQUN4RHpwQixNQUFBQSxDQUFDLENBQUN5cEIsWUFBRixHQUFpQnpwQixDQUFDLENBQUN5cEIsWUFBRixHQUFpQnpwQixDQUFDLENBQUN2UixPQUFGLENBQVVnNkIsY0FBNUM7QUFDSDs7QUFFRCxRQUFJem9CLENBQUMsQ0FBQ2lxQixVQUFGLElBQWdCanFCLENBQUMsQ0FBQ3ZSLE9BQUYsQ0FBVSs1QixZQUE5QixFQUE0QztBQUN4Q3hvQixNQUFBQSxDQUFDLENBQUN5cEIsWUFBRixHQUFpQixDQUFqQjtBQUNIOztBQUVEenBCLElBQUFBLENBQUMsQ0FBQzJzQixtQkFBRjs7QUFFQTNzQixJQUFBQSxDQUFDLENBQUNpeUIsUUFBRjs7QUFDQWp5QixJQUFBQSxDQUFDLENBQUNzdUIsYUFBRjs7QUFDQXR1QixJQUFBQSxDQUFDLENBQUNpdUIsV0FBRjs7QUFDQWp1QixJQUFBQSxDQUFDLENBQUNxeUIsWUFBRjs7QUFDQXJ5QixJQUFBQSxDQUFDLENBQUM0eUIsZUFBRjs7QUFDQTV5QixJQUFBQSxDQUFDLENBQUNrdUIsU0FBRjs7QUFDQWx1QixJQUFBQSxDQUFDLENBQUN1dUIsVUFBRjs7QUFDQXZ1QixJQUFBQSxDQUFDLENBQUM2eUIsYUFBRjs7QUFDQTd5QixJQUFBQSxDQUFDLENBQUNpd0Isa0JBQUY7O0FBQ0Fqd0IsSUFBQUEsQ0FBQyxDQUFDOHlCLGVBQUY7O0FBRUE5eUIsSUFBQUEsQ0FBQyxDQUFDK3VCLGVBQUYsQ0FBa0IsS0FBbEIsRUFBeUIsSUFBekI7O0FBRUEsUUFBSS91QixDQUFDLENBQUN2UixPQUFGLENBQVVnNUIsYUFBVixLQUE0QixJQUFoQyxFQUFzQztBQUNsQ3pCLE1BQUFBLENBQUMsQ0FBQ2htQixDQUFDLENBQUNtcUIsV0FBSCxDQUFELENBQWlCM2lHLFFBQWpCLEdBQTRCa2lGLEVBQTVCLENBQStCLGFBQS9CLEVBQThDMUosQ0FBQyxDQUFDcXNCLGFBQWhEO0FBQ0g7O0FBRURyc0IsSUFBQUEsQ0FBQyxDQUFDd3VCLGVBQUYsQ0FBa0IsT0FBT3h1QixDQUFDLENBQUN5cEIsWUFBVCxLQUEwQixRQUExQixHQUFxQ3pwQixDQUFDLENBQUN5cEIsWUFBdkMsR0FBc0QsQ0FBeEU7O0FBRUF6cEIsSUFBQUEsQ0FBQyxDQUFDc3NCLFdBQUY7O0FBQ0F0c0IsSUFBQUEsQ0FBQyxDQUFDMndCLFlBQUY7O0FBRUEzd0IsSUFBQUEsQ0FBQyxDQUFDOXBDLE1BQUYsR0FBVyxDQUFDOHBDLENBQUMsQ0FBQ3ZSLE9BQUYsQ0FBVXE0QixRQUF0Qjs7QUFDQTltQixJQUFBQSxDQUFDLENBQUNnc0IsUUFBRjs7QUFFQWhzQixJQUFBQSxDQUFDLENBQUN1ckIsT0FBRixDQUFVM3pGLE9BQVYsQ0FBa0IsUUFBbEIsRUFBNEIsQ0FBQ29vRSxDQUFELENBQTVCO0FBRUgsR0FoREQ7O0FBa0RBbW1CLEVBQUFBLEtBQUssQ0FBQ3hqRyxTQUFOLENBQWdCd3RHLE1BQWhCLEdBQXlCLFlBQVc7QUFFaEMsUUFBSW53QixDQUFDLEdBQUcsSUFBUjs7QUFFQSxRQUFJZ21CLENBQUMsQ0FBQzFoRyxNQUFELENBQUQsQ0FBVW1JLEtBQVYsT0FBc0J1ekUsQ0FBQyxDQUFDNHJCLFdBQTVCLEVBQXlDO0FBQ3JDejVDLE1BQUFBLFlBQVksQ0FBQzZ0QixDQUFDLENBQUN5MEIsV0FBSCxDQUFaO0FBQ0F6MEIsTUFBQUEsQ0FBQyxDQUFDeTBCLFdBQUYsR0FBZ0Jud0csTUFBTSxDQUFDdzhCLFVBQVAsQ0FBa0IsWUFBVztBQUN6Q2svQyxRQUFBQSxDQUFDLENBQUM0ckIsV0FBRixHQUFnQjVGLENBQUMsQ0FBQzFoRyxNQUFELENBQUQsQ0FBVW1JLEtBQVYsRUFBaEI7O0FBQ0F1ekUsUUFBQUEsQ0FBQyxDQUFDK3VCLGVBQUY7O0FBQ0EsWUFBSSxDQUFDL3VCLENBQUMsQ0FBQzRxQixTQUFQLEVBQW1CO0FBQUU1cUIsVUFBQUEsQ0FBQyxDQUFDc3NCLFdBQUY7QUFBa0I7QUFDMUMsT0FKZSxFQUliLEVBSmEsQ0FBaEI7QUFLSDtBQUNKLEdBWkQ7O0FBY0FuRyxFQUFBQSxLQUFLLENBQUN4akcsU0FBTixDQUFnQit4RyxXQUFoQixHQUE4QnZPLEtBQUssQ0FBQ3hqRyxTQUFOLENBQWdCZ3lHLFdBQWhCLEdBQThCLFVBQVN4ckYsS0FBVCxFQUFnQnlyRixZQUFoQixFQUE4QkMsU0FBOUIsRUFBeUM7QUFFakcsUUFBSTcwQixDQUFDLEdBQUcsSUFBUjs7QUFFQSxRQUFJLE9BQU83MkQsS0FBUCxLQUFrQixTQUF0QixFQUFpQztBQUM3QnlyRixNQUFBQSxZQUFZLEdBQUd6ckYsS0FBZjtBQUNBQSxNQUFBQSxLQUFLLEdBQUd5ckYsWUFBWSxLQUFLLElBQWpCLEdBQXdCLENBQXhCLEdBQTRCNTBCLENBQUMsQ0FBQ2lxQixVQUFGLEdBQWUsQ0FBbkQ7QUFDSCxLQUhELE1BR087QUFDSDlnRixNQUFBQSxLQUFLLEdBQUd5ckYsWUFBWSxLQUFLLElBQWpCLEdBQXdCLEVBQUV6ckYsS0FBMUIsR0FBa0NBLEtBQTFDO0FBQ0g7O0FBRUQsUUFBSTYyRCxDQUFDLENBQUNpcUIsVUFBRixHQUFlLENBQWYsSUFBb0I5Z0YsS0FBSyxHQUFHLENBQTVCLElBQWlDQSxLQUFLLEdBQUc2MkQsQ0FBQyxDQUFDaXFCLFVBQUYsR0FBZSxDQUE1RCxFQUErRDtBQUMzRCxhQUFPLEtBQVA7QUFDSDs7QUFFRGpxQixJQUFBQSxDQUFDLENBQUNpdEIsTUFBRjs7QUFFQSxRQUFJNEgsU0FBUyxLQUFLLElBQWxCLEVBQXdCO0FBQ3BCNzBCLE1BQUFBLENBQUMsQ0FBQ21xQixXQUFGLENBQWMzaUcsUUFBZCxHQUF5QlcsTUFBekI7QUFDSCxLQUZELE1BRU87QUFDSDYzRSxNQUFBQSxDQUFDLENBQUNtcUIsV0FBRixDQUFjM2lHLFFBQWQsQ0FBdUIsS0FBS2luRSxPQUFMLENBQWE2NUIsS0FBcEMsRUFBMkNwNkIsRUFBM0MsQ0FBOEMva0QsS0FBOUMsRUFBcURoaEIsTUFBckQ7QUFDSDs7QUFFRDYzRSxJQUFBQSxDQUFDLENBQUNvcUIsT0FBRixHQUFZcHFCLENBQUMsQ0FBQ21xQixXQUFGLENBQWMzaUcsUUFBZCxDQUF1QixLQUFLaW5FLE9BQUwsQ0FBYTY1QixLQUFwQyxDQUFaOztBQUVBdG9CLElBQUFBLENBQUMsQ0FBQ21xQixXQUFGLENBQWMzaUcsUUFBZCxDQUF1QixLQUFLaW5FLE9BQUwsQ0FBYTY1QixLQUFwQyxFQUEyQ2haLE1BQTNDOztBQUVBdFAsSUFBQUEsQ0FBQyxDQUFDbXFCLFdBQUYsQ0FBYzVhLE1BQWQsQ0FBcUJ2UCxDQUFDLENBQUNvcUIsT0FBdkI7O0FBRUFwcUIsSUFBQUEsQ0FBQyxDQUFDd3JCLFlBQUYsR0FBaUJ4ckIsQ0FBQyxDQUFDb3FCLE9BQW5COztBQUVBcHFCLElBQUFBLENBQUMsQ0FBQ2t0QixNQUFGO0FBRUgsR0FqQ0Q7O0FBbUNBL0csRUFBQUEsS0FBSyxDQUFDeGpHLFNBQU4sQ0FBZ0JteUcsTUFBaEIsR0FBeUIsVUFBU3hqRyxRQUFULEVBQW1CO0FBRXhDLFFBQUkwdUUsQ0FBQyxHQUFHLElBQVI7QUFBQSxRQUNJKzBCLGFBQWEsR0FBRyxFQURwQjtBQUFBLFFBRUl2cEcsQ0FGSjtBQUFBLFFBRU9DLENBRlA7O0FBSUEsUUFBSXUwRSxDQUFDLENBQUN2UixPQUFGLENBQVU0NUIsR0FBVixLQUFrQixJQUF0QixFQUE0QjtBQUN4Qi8yRixNQUFBQSxRQUFRLEdBQUcsQ0FBQ0EsUUFBWjtBQUNIOztBQUNEOUYsSUFBQUEsQ0FBQyxHQUFHdzBFLENBQUMsQ0FBQ29yQixZQUFGLElBQWtCLE1BQWxCLEdBQTJCbm1HLElBQUksQ0FBQytzQixJQUFMLENBQVUxZ0IsUUFBVixJQUFzQixJQUFqRCxHQUF3RCxLQUE1RDtBQUNBN0YsSUFBQUEsQ0FBQyxHQUFHdTBFLENBQUMsQ0FBQ29yQixZQUFGLElBQWtCLEtBQWxCLEdBQTBCbm1HLElBQUksQ0FBQytzQixJQUFMLENBQVUxZ0IsUUFBVixJQUFzQixJQUFoRCxHQUF1RCxLQUEzRDtBQUVBeWpHLElBQUFBLGFBQWEsQ0FBQy8wQixDQUFDLENBQUNvckIsWUFBSCxDQUFiLEdBQWdDOTVGLFFBQWhDOztBQUVBLFFBQUkwdUUsQ0FBQyxDQUFDMnFCLGlCQUFGLEtBQXdCLEtBQTVCLEVBQW1DO0FBQy9CM3FCLE1BQUFBLENBQUMsQ0FBQ21xQixXQUFGLENBQWM1OUQsR0FBZCxDQUFrQndvRSxhQUFsQjtBQUNILEtBRkQsTUFFTztBQUNIQSxNQUFBQSxhQUFhLEdBQUcsRUFBaEI7O0FBQ0EsVUFBSS8wQixDQUFDLENBQUNrckIsY0FBRixLQUFxQixLQUF6QixFQUFnQztBQUM1QjZKLFFBQUFBLGFBQWEsQ0FBQy8wQixDQUFDLENBQUM4cUIsUUFBSCxDQUFiLEdBQTRCLGVBQWV0L0YsQ0FBZixHQUFtQixJQUFuQixHQUEwQkMsQ0FBMUIsR0FBOEIsR0FBMUQ7O0FBQ0F1MEUsUUFBQUEsQ0FBQyxDQUFDbXFCLFdBQUYsQ0FBYzU5RCxHQUFkLENBQWtCd29FLGFBQWxCO0FBQ0gsT0FIRCxNQUdPO0FBQ0hBLFFBQUFBLGFBQWEsQ0FBQy8wQixDQUFDLENBQUM4cUIsUUFBSCxDQUFiLEdBQTRCLGlCQUFpQnQvRixDQUFqQixHQUFxQixJQUFyQixHQUE0QkMsQ0FBNUIsR0FBZ0MsUUFBNUQ7O0FBQ0F1MEUsUUFBQUEsQ0FBQyxDQUFDbXFCLFdBQUYsQ0FBYzU5RCxHQUFkLENBQWtCd29FLGFBQWxCO0FBQ0g7QUFDSjtBQUVKLEdBM0JEOztBQTZCQTVPLEVBQUFBLEtBQUssQ0FBQ3hqRyxTQUFOLENBQWdCcXlHLGFBQWhCLEdBQWdDLFlBQVc7QUFFdkMsUUFBSWgxQixDQUFDLEdBQUcsSUFBUjs7QUFFQSxRQUFJQSxDQUFDLENBQUN2UixPQUFGLENBQVV3NkIsUUFBVixLQUF1QixLQUEzQixFQUFrQztBQUM5QixVQUFJanBCLENBQUMsQ0FBQ3ZSLE9BQUYsQ0FBVXU0QixVQUFWLEtBQXlCLElBQTdCLEVBQW1DO0FBQy9CaG5CLFFBQUFBLENBQUMsQ0FBQ3lxQixLQUFGLENBQVFsK0QsR0FBUixDQUFZO0FBQ1Jpb0QsVUFBQUEsT0FBTyxFQUFHLFNBQVN4VSxDQUFDLENBQUN2UixPQUFGLENBQVV3NEI7QUFEckIsU0FBWjtBQUdIO0FBQ0osS0FORCxNQU1PO0FBQ0hqbkIsTUFBQUEsQ0FBQyxDQUFDeXFCLEtBQUYsQ0FBUTU5RixNQUFSLENBQWVtekUsQ0FBQyxDQUFDb3FCLE9BQUYsQ0FBVXIwRSxLQUFWLEdBQWtCczNFLFdBQWxCLENBQThCLElBQTlCLElBQXNDcnRCLENBQUMsQ0FBQ3ZSLE9BQUYsQ0FBVSs1QixZQUEvRDs7QUFDQSxVQUFJeG9CLENBQUMsQ0FBQ3ZSLE9BQUYsQ0FBVXU0QixVQUFWLEtBQXlCLElBQTdCLEVBQW1DO0FBQy9CaG5CLFFBQUFBLENBQUMsQ0FBQ3lxQixLQUFGLENBQVFsK0QsR0FBUixDQUFZO0FBQ1Jpb0QsVUFBQUEsT0FBTyxFQUFHeFUsQ0FBQyxDQUFDdlIsT0FBRixDQUFVdzRCLGFBQVYsR0FBMEI7QUFENUIsU0FBWjtBQUdIO0FBQ0o7O0FBRURqbkIsSUFBQUEsQ0FBQyxDQUFDMnBCLFNBQUYsR0FBYzNwQixDQUFDLENBQUN5cUIsS0FBRixDQUFRaCtGLEtBQVIsRUFBZDtBQUNBdXpFLElBQUFBLENBQUMsQ0FBQzRwQixVQUFGLEdBQWU1cEIsQ0FBQyxDQUFDeXFCLEtBQUYsQ0FBUTU5RixNQUFSLEVBQWY7O0FBR0EsUUFBSW16RSxDQUFDLENBQUN2UixPQUFGLENBQVV3NkIsUUFBVixLQUF1QixLQUF2QixJQUFnQ2pwQixDQUFDLENBQUN2UixPQUFGLENBQVV1NkIsYUFBVixLQUE0QixLQUFoRSxFQUF1RTtBQUNuRWhwQixNQUFBQSxDQUFDLENBQUNrcUIsVUFBRixHQUFlamxHLElBQUksQ0FBQytzQixJQUFMLENBQVVndUQsQ0FBQyxDQUFDMnBCLFNBQUYsR0FBYzNwQixDQUFDLENBQUN2UixPQUFGLENBQVUrNUIsWUFBbEMsQ0FBZjs7QUFDQXhvQixNQUFBQSxDQUFDLENBQUNtcUIsV0FBRixDQUFjMTlGLEtBQWQsQ0FBb0J4SCxJQUFJLENBQUMrc0IsSUFBTCxDQUFXZ3VELENBQUMsQ0FBQ2txQixVQUFGLEdBQWVscUIsQ0FBQyxDQUFDbXFCLFdBQUYsQ0FBYzNpRyxRQUFkLENBQXVCLGNBQXZCLEVBQXVDRCxNQUFqRSxDQUFwQjtBQUVILEtBSkQsTUFJTyxJQUFJeTRFLENBQUMsQ0FBQ3ZSLE9BQUYsQ0FBVXU2QixhQUFWLEtBQTRCLElBQWhDLEVBQXNDO0FBQ3pDaHBCLE1BQUFBLENBQUMsQ0FBQ21xQixXQUFGLENBQWMxOUYsS0FBZCxDQUFvQixPQUFPdXpFLENBQUMsQ0FBQ2lxQixVQUE3QjtBQUNILEtBRk0sTUFFQTtBQUNIanFCLE1BQUFBLENBQUMsQ0FBQ2txQixVQUFGLEdBQWVqbEcsSUFBSSxDQUFDK3NCLElBQUwsQ0FBVWd1RCxDQUFDLENBQUMycEIsU0FBWixDQUFmOztBQUNBM3BCLE1BQUFBLENBQUMsQ0FBQ21xQixXQUFGLENBQWN0OUYsTUFBZCxDQUFxQjVILElBQUksQ0FBQytzQixJQUFMLENBQVdndUQsQ0FBQyxDQUFDb3FCLE9BQUYsQ0FBVXIwRSxLQUFWLEdBQWtCczNFLFdBQWxCLENBQThCLElBQTlCLElBQXNDcnRCLENBQUMsQ0FBQ21xQixXQUFGLENBQWMzaUcsUUFBZCxDQUF1QixjQUF2QixFQUF1Q0QsTUFBeEYsQ0FBckI7QUFDSDs7QUFFRCxRQUFJMkcsTUFBTSxHQUFHOHhFLENBQUMsQ0FBQ29xQixPQUFGLENBQVVyMEUsS0FBVixHQUFrQituQixVQUFsQixDQUE2QixJQUE3QixJQUFxQ2tpQyxDQUFDLENBQUNvcUIsT0FBRixDQUFVcjBFLEtBQVYsR0FBa0J0cEIsS0FBbEIsRUFBbEQ7O0FBQ0EsUUFBSXV6RSxDQUFDLENBQUN2UixPQUFGLENBQVV1NkIsYUFBVixLQUE0QixLQUFoQyxFQUF1Q2hwQixDQUFDLENBQUNtcUIsV0FBRixDQUFjM2lHLFFBQWQsQ0FBdUIsY0FBdkIsRUFBdUNpRixLQUF2QyxDQUE2Q3V6RSxDQUFDLENBQUNrcUIsVUFBRixHQUFlaDhGLE1BQTVEO0FBRTFDLEdBckNEOztBQXVDQWk0RixFQUFBQSxLQUFLLENBQUN4akcsU0FBTixDQUFnQnN5RyxPQUFoQixHQUEwQixZQUFXO0FBRWpDLFFBQUlqMUIsQ0FBQyxHQUFHLElBQVI7QUFBQSxRQUNJdXRCLFVBREo7O0FBR0F2dEIsSUFBQUEsQ0FBQyxDQUFDb3FCLE9BQUYsQ0FBVW5nRCxJQUFWLENBQWUsVUFBUzlnQyxLQUFULEVBQWdCcmdCLE9BQWhCLEVBQXlCO0FBQ3BDeWtHLE1BQUFBLFVBQVUsR0FBSXZ0QixDQUFDLENBQUNrcUIsVUFBRixHQUFlL2dGLEtBQWhCLEdBQXlCLENBQUMsQ0FBdkM7O0FBQ0EsVUFBSTYyRCxDQUFDLENBQUN2UixPQUFGLENBQVU0NUIsR0FBVixLQUFrQixJQUF0QixFQUE0QjtBQUN4QnJDLFFBQUFBLENBQUMsQ0FBQ2w5RixPQUFELENBQUQsQ0FBV3lqQyxHQUFYLENBQWU7QUFDWGo3QixVQUFBQSxRQUFRLEVBQUUsVUFEQztBQUVYNUUsVUFBQUEsS0FBSyxFQUFFNmdHLFVBRkk7QUFHWC9nRyxVQUFBQSxHQUFHLEVBQUUsQ0FITTtBQUlYOFQsVUFBQUEsTUFBTSxFQUFFMC9ELENBQUMsQ0FBQ3ZSLE9BQUYsQ0FBVW51RCxNQUFWLEdBQW1CLENBSmhCO0FBS1g0ekUsVUFBQUEsT0FBTyxFQUFFO0FBTEUsU0FBZjtBQU9ILE9BUkQsTUFRTztBQUNIOFIsUUFBQUEsQ0FBQyxDQUFDbDlGLE9BQUQsQ0FBRCxDQUFXeWpDLEdBQVgsQ0FBZTtBQUNYajdCLFVBQUFBLFFBQVEsRUFBRSxVQURDO0FBRVgvRSxVQUFBQSxJQUFJLEVBQUVnaEcsVUFGSztBQUdYL2dHLFVBQUFBLEdBQUcsRUFBRSxDQUhNO0FBSVg4VCxVQUFBQSxNQUFNLEVBQUUwL0QsQ0FBQyxDQUFDdlIsT0FBRixDQUFVbnVELE1BQVYsR0FBbUIsQ0FKaEI7QUFLWDR6RSxVQUFBQSxPQUFPLEVBQUU7QUFMRSxTQUFmO0FBT0g7QUFDSixLQW5CRDs7QUFxQkFsVSxJQUFBQSxDQUFDLENBQUNvcUIsT0FBRixDQUFVbDhCLEVBQVYsQ0FBYThSLENBQUMsQ0FBQ3lwQixZQUFmLEVBQTZCbDlELEdBQTdCLENBQWlDO0FBQzdCanNCLE1BQUFBLE1BQU0sRUFBRTAvRCxDQUFDLENBQUN2UixPQUFGLENBQVVudUQsTUFBVixHQUFtQixDQURFO0FBRTdCNHpFLE1BQUFBLE9BQU8sRUFBRTtBQUZvQixLQUFqQztBQUtILEdBL0JEOztBQWlDQWlTLEVBQUFBLEtBQUssQ0FBQ3hqRyxTQUFOLENBQWdCdXlHLFNBQWhCLEdBQTRCLFlBQVc7QUFFbkMsUUFBSWwxQixDQUFDLEdBQUcsSUFBUjs7QUFFQSxRQUFJQSxDQUFDLENBQUN2UixPQUFGLENBQVUrNUIsWUFBVixLQUEyQixDQUEzQixJQUFnQ3hvQixDQUFDLENBQUN2UixPQUFGLENBQVU4M0IsY0FBVixLQUE2QixJQUE3RCxJQUFxRXZtQixDQUFDLENBQUN2UixPQUFGLENBQVV3NkIsUUFBVixLQUF1QixLQUFoRyxFQUF1RztBQUNuRyxVQUFJbUUsWUFBWSxHQUFHcHRCLENBQUMsQ0FBQ29xQixPQUFGLENBQVVsOEIsRUFBVixDQUFhOFIsQ0FBQyxDQUFDeXBCLFlBQWYsRUFBNkI0RCxXQUE3QixDQUF5QyxJQUF6QyxDQUFuQjs7QUFDQXJ0QixNQUFBQSxDQUFDLENBQUN5cUIsS0FBRixDQUFRbCtELEdBQVIsQ0FBWSxRQUFaLEVBQXNCNmdFLFlBQXRCO0FBQ0g7QUFFSixHQVREOztBQVdBakgsRUFBQUEsS0FBSyxDQUFDeGpHLFNBQU4sQ0FBZ0J3eUcsU0FBaEIsR0FDQWhQLEtBQUssQ0FBQ3hqRyxTQUFOLENBQWdCeXlHLGNBQWhCLEdBQWlDLFlBQVc7QUFFeEM7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRVEsUUFBSXAxQixDQUFDLEdBQUcsSUFBUjtBQUFBLFFBQWMzdkUsQ0FBZDtBQUFBLFFBQWlCdThELElBQWpCO0FBQUEsUUFBdUJpYixNQUF2QjtBQUFBLFFBQStCbmpGLEtBQS9CO0FBQUEsUUFBc0NxcUMsT0FBTyxHQUFHLEtBQWhEO0FBQUEsUUFBdUR4cEMsSUFBdkQ7O0FBRUEsUUFBSXlnRyxDQUFDLENBQUN6Z0csSUFBRixDQUFRME4sU0FBUyxDQUFDLENBQUQsQ0FBakIsTUFBMkIsUUFBL0IsRUFBMEM7QUFFdEM0MEUsTUFBQUEsTUFBTSxHQUFJNTBFLFNBQVMsQ0FBQyxDQUFELENBQW5CO0FBQ0E4N0IsTUFBQUEsT0FBTyxHQUFHOTdCLFNBQVMsQ0FBQyxDQUFELENBQW5CO0FBQ0ExTixNQUFBQSxJQUFJLEdBQUcsVUFBUDtBQUVILEtBTkQsTUFNTyxJQUFLeWdHLENBQUMsQ0FBQ3pnRyxJQUFGLENBQVEwTixTQUFTLENBQUMsQ0FBRCxDQUFqQixNQUEyQixRQUFoQyxFQUEyQztBQUU5QzQwRSxNQUFBQSxNQUFNLEdBQUk1MEUsU0FBUyxDQUFDLENBQUQsQ0FBbkI7QUFDQXZPLE1BQUFBLEtBQUssR0FBR3VPLFNBQVMsQ0FBQyxDQUFELENBQWpCO0FBQ0E4N0IsTUFBQUEsT0FBTyxHQUFHOTdCLFNBQVMsQ0FBQyxDQUFELENBQW5COztBQUVBLFVBQUtBLFNBQVMsQ0FBQyxDQUFELENBQVQsS0FBaUIsWUFBakIsSUFBaUMreUYsQ0FBQyxDQUFDemdHLElBQUYsQ0FBUTBOLFNBQVMsQ0FBQyxDQUFELENBQWpCLE1BQTJCLE9BQWpFLEVBQTJFO0FBRXZFMU4sUUFBQUEsSUFBSSxHQUFHLFlBQVA7QUFFSCxPQUpELE1BSU8sSUFBSyxPQUFPME4sU0FBUyxDQUFDLENBQUQsQ0FBaEIsS0FBd0IsV0FBN0IsRUFBMkM7QUFFOUMxTixRQUFBQSxJQUFJLEdBQUcsUUFBUDtBQUVIO0FBRUo7O0FBRUQsUUFBS0EsSUFBSSxLQUFLLFFBQWQsRUFBeUI7QUFFckJ5NkUsTUFBQUEsQ0FBQyxDQUFDdlIsT0FBRixDQUFVb1osTUFBVixJQUFvQm5qRixLQUFwQjtBQUdILEtBTEQsTUFLTyxJQUFLYSxJQUFJLEtBQUssVUFBZCxFQUEyQjtBQUU5QnlnRyxNQUFBQSxDQUFDLENBQUMvN0MsSUFBRixDQUFRNDlCLE1BQVIsRUFBaUIsVUFBVTJQLEdBQVYsRUFBZWxpRixHQUFmLEVBQXFCO0FBRWxDMHFFLFFBQUFBLENBQUMsQ0FBQ3ZSLE9BQUYsQ0FBVStvQixHQUFWLElBQWlCbGlGLEdBQWpCO0FBRUgsT0FKRDtBQU9ILEtBVE0sTUFTQSxJQUFLL1AsSUFBSSxLQUFLLFlBQWQsRUFBNkI7QUFFaEMsV0FBTXFuRSxJQUFOLElBQWNsb0UsS0FBZCxFQUFzQjtBQUVsQixZQUFJc2hHLENBQUMsQ0FBQ3pnRyxJQUFGLENBQVF5NkUsQ0FBQyxDQUFDdlIsT0FBRixDQUFVMDVCLFVBQWxCLE1BQW1DLE9BQXZDLEVBQWlEO0FBRTdDbm9CLFVBQUFBLENBQUMsQ0FBQ3ZSLE9BQUYsQ0FBVTA1QixVQUFWLEdBQXVCLENBQUV6akcsS0FBSyxDQUFDa29FLElBQUQsQ0FBUCxDQUF2QjtBQUVILFNBSkQsTUFJTztBQUVIdjhELFVBQUFBLENBQUMsR0FBRzJ2RSxDQUFDLENBQUN2UixPQUFGLENBQVUwNUIsVUFBVixDQUFxQjVnRyxNQUFyQixHQUE0QixDQUFoQyxDQUZHLENBSUg7O0FBQ0EsaUJBQU84SSxDQUFDLElBQUksQ0FBWixFQUFnQjtBQUVaLGdCQUFJMnZFLENBQUMsQ0FBQ3ZSLE9BQUYsQ0FBVTA1QixVQUFWLENBQXFCOTNGLENBQXJCLEVBQXdCNCtGLFVBQXhCLEtBQXVDdnFHLEtBQUssQ0FBQ2tvRSxJQUFELENBQUwsQ0FBWXFpQyxVQUF2RCxFQUFvRTtBQUVoRWp2QixjQUFBQSxDQUFDLENBQUN2UixPQUFGLENBQVUwNUIsVUFBVixDQUFxQjkvRixNQUFyQixDQUE0QmdJLENBQTVCLEVBQThCLENBQTlCO0FBRUg7O0FBRURBLFlBQUFBLENBQUM7QUFFSjs7QUFFRDJ2RSxVQUFBQSxDQUFDLENBQUN2UixPQUFGLENBQVUwNUIsVUFBVixDQUFxQnBnRyxJQUFyQixDQUEyQnJELEtBQUssQ0FBQ2tvRSxJQUFELENBQWhDO0FBRUg7QUFFSjtBQUVKOztBQUVELFFBQUs3OUIsT0FBTCxFQUFlO0FBRVhpeEMsTUFBQUEsQ0FBQyxDQUFDaXRCLE1BQUY7O0FBQ0FqdEIsTUFBQUEsQ0FBQyxDQUFDa3RCLE1BQUY7QUFFSDtBQUVKLEdBaEdEOztBQWtHQS9HLEVBQUFBLEtBQUssQ0FBQ3hqRyxTQUFOLENBQWdCMnBHLFdBQWhCLEdBQThCLFlBQVc7QUFFckMsUUFBSXRzQixDQUFDLEdBQUcsSUFBUjs7QUFFQUEsSUFBQUEsQ0FBQyxDQUFDZzFCLGFBQUY7O0FBRUFoMUIsSUFBQUEsQ0FBQyxDQUFDazFCLFNBQUY7O0FBRUEsUUFBSWwxQixDQUFDLENBQUN2UixPQUFGLENBQVUrNEIsSUFBVixLQUFtQixLQUF2QixFQUE4QjtBQUMxQnhuQixNQUFBQSxDQUFDLENBQUM4MEIsTUFBRixDQUFTOTBCLENBQUMsQ0FBQ2t4QixPQUFGLENBQVVseEIsQ0FBQyxDQUFDeXBCLFlBQVosQ0FBVDtBQUNILEtBRkQsTUFFTztBQUNIenBCLE1BQUFBLENBQUMsQ0FBQ2kxQixPQUFGO0FBQ0g7O0FBRURqMUIsSUFBQUEsQ0FBQyxDQUFDdXJCLE9BQUYsQ0FBVTN6RixPQUFWLENBQWtCLGFBQWxCLEVBQWlDLENBQUNvb0UsQ0FBRCxDQUFqQztBQUVILEdBaEJEOztBQWtCQW1tQixFQUFBQSxLQUFLLENBQUN4akcsU0FBTixDQUFnQnN2RyxRQUFoQixHQUEyQixZQUFXO0FBRWxDLFFBQUlqeUIsQ0FBQyxHQUFHLElBQVI7QUFBQSxRQUNJeGxDLFNBQVMsR0FBRzNvQyxRQUFRLENBQUN2SCxJQUFULENBQWN6RSxLQUQ5Qjs7QUFHQW02RSxJQUFBQSxDQUFDLENBQUNvckIsWUFBRixHQUFpQnByQixDQUFDLENBQUN2UixPQUFGLENBQVV3NkIsUUFBVixLQUF1QixJQUF2QixHQUE4QixLQUE5QixHQUFzQyxNQUF2RDs7QUFFQSxRQUFJanBCLENBQUMsQ0FBQ29yQixZQUFGLEtBQW1CLEtBQXZCLEVBQThCO0FBQzFCcHJCLE1BQUFBLENBQUMsQ0FBQ3VyQixPQUFGLENBQVU1UixRQUFWLENBQW1CLGdCQUFuQjtBQUNILEtBRkQsTUFFTztBQUNIM1osTUFBQUEsQ0FBQyxDQUFDdXJCLE9BQUYsQ0FBVXpSLFdBQVYsQ0FBc0IsZ0JBQXRCO0FBQ0g7O0FBRUQsUUFBSXQvQyxTQUFTLENBQUM2NkQsZ0JBQVYsS0FBK0J4bUMsU0FBL0IsSUFDQXIwQixTQUFTLENBQUM4NkQsYUFBVixLQUE0QnptQyxTQUQ1QixJQUVBcjBCLFNBQVMsQ0FBQys2RCxZQUFWLEtBQTJCMW1DLFNBRi9CLEVBRTBDO0FBQ3RDLFVBQUltUixDQUFDLENBQUN2UixPQUFGLENBQVVxNkIsTUFBVixLQUFxQixJQUF6QixFQUErQjtBQUMzQjlvQixRQUFBQSxDQUFDLENBQUNrckIsY0FBRixHQUFtQixJQUFuQjtBQUNIO0FBQ0o7O0FBRUQsUUFBS2xyQixDQUFDLENBQUN2UixPQUFGLENBQVUrNEIsSUFBZixFQUFzQjtBQUNsQixVQUFLLE9BQU94bkIsQ0FBQyxDQUFDdlIsT0FBRixDQUFVbnVELE1BQWpCLEtBQTRCLFFBQWpDLEVBQTRDO0FBQ3hDLFlBQUkwL0QsQ0FBQyxDQUFDdlIsT0FBRixDQUFVbnVELE1BQVYsR0FBbUIsQ0FBdkIsRUFBMkI7QUFDdkIwL0QsVUFBQUEsQ0FBQyxDQUFDdlIsT0FBRixDQUFVbnVELE1BQVYsR0FBbUIsQ0FBbkI7QUFDSDtBQUNKLE9BSkQsTUFJTztBQUNIMC9ELFFBQUFBLENBQUMsQ0FBQ3ZSLE9BQUYsQ0FBVW51RCxNQUFWLEdBQW1CMC9ELENBQUMsQ0FBQzc0RSxRQUFGLENBQVdtWixNQUE5QjtBQUNIO0FBQ0o7O0FBRUQsUUFBSWs2QixTQUFTLENBQUNnN0QsVUFBVixLQUF5QjNtQyxTQUE3QixFQUF3QztBQUNwQ21SLE1BQUFBLENBQUMsQ0FBQzhxQixRQUFGLEdBQWEsWUFBYjtBQUNBOXFCLE1BQUFBLENBQUMsQ0FBQ3lyQixhQUFGLEdBQWtCLGNBQWxCO0FBQ0F6ckIsTUFBQUEsQ0FBQyxDQUFDMHJCLGNBQUYsR0FBbUIsYUFBbkI7QUFDQSxVQUFJbHhELFNBQVMsQ0FBQ2k3RCxtQkFBVixLQUFrQzVtQyxTQUFsQyxJQUErQ3IwQixTQUFTLENBQUNrN0QsaUJBQVYsS0FBZ0M3bUMsU0FBbkYsRUFBOEZtUixDQUFDLENBQUM4cUIsUUFBRixHQUFhLEtBQWI7QUFDakc7O0FBQ0QsUUFBSXR3RCxTQUFTLENBQUNtN0QsWUFBVixLQUEyQjltQyxTQUEvQixFQUEwQztBQUN0Q21SLE1BQUFBLENBQUMsQ0FBQzhxQixRQUFGLEdBQWEsY0FBYjtBQUNBOXFCLE1BQUFBLENBQUMsQ0FBQ3lyQixhQUFGLEdBQWtCLGdCQUFsQjtBQUNBenJCLE1BQUFBLENBQUMsQ0FBQzByQixjQUFGLEdBQW1CLGVBQW5CO0FBQ0EsVUFBSWx4RCxTQUFTLENBQUNpN0QsbUJBQVYsS0FBa0M1bUMsU0FBbEMsSUFBK0NyMEIsU0FBUyxDQUFDbzdELGNBQVYsS0FBNkIvbUMsU0FBaEYsRUFBMkZtUixDQUFDLENBQUM4cUIsUUFBRixHQUFhLEtBQWI7QUFDOUY7O0FBQ0QsUUFBSXR3RCxTQUFTLENBQUNxN0QsZUFBVixLQUE4QmhuQyxTQUFsQyxFQUE2QztBQUN6Q21SLE1BQUFBLENBQUMsQ0FBQzhxQixRQUFGLEdBQWEsaUJBQWI7QUFDQTlxQixNQUFBQSxDQUFDLENBQUN5ckIsYUFBRixHQUFrQixtQkFBbEI7QUFDQXpyQixNQUFBQSxDQUFDLENBQUMwckIsY0FBRixHQUFtQixrQkFBbkI7QUFDQSxVQUFJbHhELFNBQVMsQ0FBQ2k3RCxtQkFBVixLQUFrQzVtQyxTQUFsQyxJQUErQ3IwQixTQUFTLENBQUNrN0QsaUJBQVYsS0FBZ0M3bUMsU0FBbkYsRUFBOEZtUixDQUFDLENBQUM4cUIsUUFBRixHQUFhLEtBQWI7QUFDakc7O0FBQ0QsUUFBSXR3RCxTQUFTLENBQUNzN0QsV0FBVixLQUEwQmpuQyxTQUE5QixFQUF5QztBQUNyQ21SLE1BQUFBLENBQUMsQ0FBQzhxQixRQUFGLEdBQWEsYUFBYjtBQUNBOXFCLE1BQUFBLENBQUMsQ0FBQ3lyQixhQUFGLEdBQWtCLGVBQWxCO0FBQ0F6ckIsTUFBQUEsQ0FBQyxDQUFDMHJCLGNBQUYsR0FBbUIsY0FBbkI7QUFDQSxVQUFJbHhELFNBQVMsQ0FBQ3M3RCxXQUFWLEtBQTBCam5DLFNBQTlCLEVBQXlDbVIsQ0FBQyxDQUFDOHFCLFFBQUYsR0FBYSxLQUFiO0FBQzVDOztBQUNELFFBQUl0d0QsU0FBUyxDQUFDaUUsU0FBVixLQUF3Qm93QixTQUF4QixJQUFxQ21SLENBQUMsQ0FBQzhxQixRQUFGLEtBQWUsS0FBeEQsRUFBK0Q7QUFDM0Q5cUIsTUFBQUEsQ0FBQyxDQUFDOHFCLFFBQUYsR0FBYSxXQUFiO0FBQ0E5cUIsTUFBQUEsQ0FBQyxDQUFDeXJCLGFBQUYsR0FBa0IsV0FBbEI7QUFDQXpyQixNQUFBQSxDQUFDLENBQUMwckIsY0FBRixHQUFtQixZQUFuQjtBQUNIOztBQUNEMXJCLElBQUFBLENBQUMsQ0FBQzJxQixpQkFBRixHQUFzQjNxQixDQUFDLENBQUN2UixPQUFGLENBQVVzNkIsWUFBVixJQUEyQi9vQixDQUFDLENBQUM4cUIsUUFBRixLQUFlLElBQWYsSUFBdUI5cUIsQ0FBQyxDQUFDOHFCLFFBQUYsS0FBZSxLQUF2RjtBQUNILEdBN0REOztBQWdFQTNFLEVBQUFBLEtBQUssQ0FBQ3hqRyxTQUFOLENBQWdCNnJHLGVBQWhCLEdBQWtDLFVBQVNybEYsS0FBVCxFQUFnQjtBQUU5QyxRQUFJNjJELENBQUMsR0FBRyxJQUFSO0FBQUEsUUFDSTZ4QixZQURKO0FBQUEsUUFDa0JrRSxTQURsQjtBQUFBLFFBQzZCdEcsV0FEN0I7QUFBQSxRQUMwQ3VHLFNBRDFDOztBQUdBRCxJQUFBQSxTQUFTLEdBQUcvMUIsQ0FBQyxDQUFDdXJCLE9BQUYsQ0FDUGgxQixJQURPLENBQ0YsY0FERSxFQUVQdWpCLFdBRk8sQ0FFSyx5Q0FGTCxFQUdQOXZFLElBSE8sQ0FHRixhQUhFLEVBR2EsTUFIYixDQUFaOztBQUtBZzJELElBQUFBLENBQUMsQ0FBQ29xQixPQUFGLENBQ0tsOEIsRUFETCxDQUNRL2tELEtBRFIsRUFFS3d3RSxRQUZMLENBRWMsZUFGZDs7QUFJQSxRQUFJM1osQ0FBQyxDQUFDdlIsT0FBRixDQUFVdTRCLFVBQVYsS0FBeUIsSUFBN0IsRUFBbUM7QUFFL0IsVUFBSWlQLFFBQVEsR0FBR2oyQixDQUFDLENBQUN2UixPQUFGLENBQVUrNUIsWUFBVixHQUF5QixDQUF6QixLQUErQixDQUEvQixHQUFtQyxDQUFuQyxHQUF1QyxDQUF0RDtBQUVBcUosTUFBQUEsWUFBWSxHQUFHNXNHLElBQUksQ0FBQ3VnRCxLQUFMLENBQVd3NkIsQ0FBQyxDQUFDdlIsT0FBRixDQUFVKzVCLFlBQVYsR0FBeUIsQ0FBcEMsQ0FBZjs7QUFFQSxVQUFJeG9CLENBQUMsQ0FBQ3ZSLE9BQUYsQ0FBVWs1QixRQUFWLEtBQXVCLElBQTNCLEVBQWlDO0FBRTdCLFlBQUl4K0UsS0FBSyxJQUFJMG9GLFlBQVQsSUFBeUIxb0YsS0FBSyxJQUFLNjJELENBQUMsQ0FBQ2lxQixVQUFGLEdBQWUsQ0FBaEIsR0FBcUI0SCxZQUEzRCxFQUF5RTtBQUNyRTd4QixVQUFBQSxDQUFDLENBQUNvcUIsT0FBRixDQUNLamlGLEtBREwsQ0FDV2dCLEtBQUssR0FBRzBvRixZQUFSLEdBQXVCb0UsUUFEbEMsRUFDNEM5c0YsS0FBSyxHQUFHMG9GLFlBQVIsR0FBdUIsQ0FEbkUsRUFFS2xZLFFBRkwsQ0FFYyxjQUZkLEVBR0szdkUsSUFITCxDQUdVLGFBSFYsRUFHeUIsT0FIekI7QUFLSCxTQU5ELE1BTU87QUFFSHlsRixVQUFBQSxXQUFXLEdBQUd6dkIsQ0FBQyxDQUFDdlIsT0FBRixDQUFVKzVCLFlBQVYsR0FBeUJyL0UsS0FBdkM7QUFDQTRzRixVQUFBQSxTQUFTLENBQ0o1dEYsS0FETCxDQUNXc25GLFdBQVcsR0FBR29DLFlBQWQsR0FBNkIsQ0FBN0IsR0FBaUNvRSxRQUQ1QyxFQUNzRHhHLFdBQVcsR0FBR29DLFlBQWQsR0FBNkIsQ0FEbkYsRUFFS2xZLFFBRkwsQ0FFYyxjQUZkLEVBR0szdkUsSUFITCxDQUdVLGFBSFYsRUFHeUIsT0FIekI7QUFLSDs7QUFFRCxZQUFJYixLQUFLLEtBQUssQ0FBZCxFQUFpQjtBQUViNHNGLFVBQUFBLFNBQVMsQ0FDSjduQyxFQURMLENBQ1E2bkMsU0FBUyxDQUFDeHVHLE1BQVYsR0FBbUIsQ0FBbkIsR0FBdUJ5NEUsQ0FBQyxDQUFDdlIsT0FBRixDQUFVKzVCLFlBRHpDLEVBRUs3TyxRQUZMLENBRWMsY0FGZDtBQUlILFNBTkQsTUFNTyxJQUFJeHdFLEtBQUssS0FBSzYyRCxDQUFDLENBQUNpcUIsVUFBRixHQUFlLENBQTdCLEVBQWdDO0FBRW5DOEwsVUFBQUEsU0FBUyxDQUNKN25DLEVBREwsQ0FDUThSLENBQUMsQ0FBQ3ZSLE9BQUYsQ0FBVSs1QixZQURsQixFQUVLN08sUUFGTCxDQUVjLGNBRmQ7QUFJSDtBQUVKOztBQUVEM1osTUFBQUEsQ0FBQyxDQUFDb3FCLE9BQUYsQ0FDS2w4QixFQURMLENBQ1Eva0QsS0FEUixFQUVLd3dFLFFBRkwsQ0FFYyxjQUZkO0FBSUgsS0E1Q0QsTUE0Q087QUFFSCxVQUFJeHdFLEtBQUssSUFBSSxDQUFULElBQWNBLEtBQUssSUFBSzYyRCxDQUFDLENBQUNpcUIsVUFBRixHQUFlanFCLENBQUMsQ0FBQ3ZSLE9BQUYsQ0FBVSs1QixZQUFyRCxFQUFvRTtBQUVoRXhvQixRQUFBQSxDQUFDLENBQUNvcUIsT0FBRixDQUNLamlGLEtBREwsQ0FDV2dCLEtBRFgsRUFDa0JBLEtBQUssR0FBRzYyRCxDQUFDLENBQUN2UixPQUFGLENBQVUrNUIsWUFEcEMsRUFFSzdPLFFBRkwsQ0FFYyxjQUZkLEVBR0szdkUsSUFITCxDQUdVLGFBSFYsRUFHeUIsT0FIekI7QUFLSCxPQVBELE1BT08sSUFBSStyRixTQUFTLENBQUN4dUcsTUFBVixJQUFvQnk0RSxDQUFDLENBQUN2UixPQUFGLENBQVUrNUIsWUFBbEMsRUFBZ0Q7QUFFbkR1TixRQUFBQSxTQUFTLENBQ0pwYyxRQURMLENBQ2MsY0FEZCxFQUVLM3ZFLElBRkwsQ0FFVSxhQUZWLEVBRXlCLE9BRnpCO0FBSUgsT0FOTSxNQU1BO0FBRUhnc0YsUUFBQUEsU0FBUyxHQUFHaDJCLENBQUMsQ0FBQ2lxQixVQUFGLEdBQWVqcUIsQ0FBQyxDQUFDdlIsT0FBRixDQUFVKzVCLFlBQXJDO0FBQ0FpSCxRQUFBQSxXQUFXLEdBQUd6dkIsQ0FBQyxDQUFDdlIsT0FBRixDQUFVazVCLFFBQVYsS0FBdUIsSUFBdkIsR0FBOEIzbkIsQ0FBQyxDQUFDdlIsT0FBRixDQUFVKzVCLFlBQVYsR0FBeUJyL0UsS0FBdkQsR0FBK0RBLEtBQTdFOztBQUVBLFlBQUk2MkQsQ0FBQyxDQUFDdlIsT0FBRixDQUFVKzVCLFlBQVYsSUFBMEJ4b0IsQ0FBQyxDQUFDdlIsT0FBRixDQUFVZzZCLGNBQXBDLElBQXVEem9CLENBQUMsQ0FBQ2lxQixVQUFGLEdBQWU5Z0YsS0FBaEIsR0FBeUI2MkQsQ0FBQyxDQUFDdlIsT0FBRixDQUFVKzVCLFlBQTdGLEVBQTJHO0FBRXZHdU4sVUFBQUEsU0FBUyxDQUNKNXRGLEtBREwsQ0FDV3NuRixXQUFXLElBQUl6dkIsQ0FBQyxDQUFDdlIsT0FBRixDQUFVKzVCLFlBQVYsR0FBeUJ3TixTQUE3QixDQUR0QixFQUMrRHZHLFdBQVcsR0FBR3VHLFNBRDdFLEVBRUtyYyxRQUZMLENBRWMsY0FGZCxFQUdLM3ZFLElBSEwsQ0FHVSxhQUhWLEVBR3lCLE9BSHpCO0FBS0gsU0FQRCxNQU9PO0FBRUgrckYsVUFBQUEsU0FBUyxDQUNKNXRGLEtBREwsQ0FDV3NuRixXQURYLEVBQ3dCQSxXQUFXLEdBQUd6dkIsQ0FBQyxDQUFDdlIsT0FBRixDQUFVKzVCLFlBRGhELEVBRUs3TyxRQUZMLENBRWMsY0FGZCxFQUdLM3ZFLElBSEwsQ0FHVSxhQUhWLEVBR3lCLE9BSHpCO0FBS0g7QUFFSjtBQUVKOztBQUVELFFBQUlnMkQsQ0FBQyxDQUFDdlIsT0FBRixDQUFVbzVCLFFBQVYsS0FBdUIsVUFBdkIsSUFBcUM3bkIsQ0FBQyxDQUFDdlIsT0FBRixDQUFVbzVCLFFBQVYsS0FBdUIsYUFBaEUsRUFBK0U7QUFDM0U3bkIsTUFBQUEsQ0FBQyxDQUFDNm5CLFFBQUY7QUFDSDtBQUNKLEdBckdEOztBQXVHQTFCLEVBQUFBLEtBQUssQ0FBQ3hqRyxTQUFOLENBQWdCMnJHLGFBQWhCLEdBQWdDLFlBQVc7QUFFdkMsUUFBSXR1QixDQUFDLEdBQUcsSUFBUjtBQUFBLFFBQ0kxNEUsQ0FESjtBQUFBLFFBQ09pcEcsVUFEUDtBQUFBLFFBQ21CMkYsYUFEbkI7O0FBR0EsUUFBSWwyQixDQUFDLENBQUN2UixPQUFGLENBQVUrNEIsSUFBVixLQUFtQixJQUF2QixFQUE2QjtBQUN6QnhuQixNQUFBQSxDQUFDLENBQUN2UixPQUFGLENBQVV1NEIsVUFBVixHQUF1QixLQUF2QjtBQUNIOztBQUVELFFBQUlobkIsQ0FBQyxDQUFDdlIsT0FBRixDQUFVazVCLFFBQVYsS0FBdUIsSUFBdkIsSUFBK0IzbkIsQ0FBQyxDQUFDdlIsT0FBRixDQUFVKzRCLElBQVYsS0FBbUIsS0FBdEQsRUFBNkQ7QUFFekQrSSxNQUFBQSxVQUFVLEdBQUcsSUFBYjs7QUFFQSxVQUFJdndCLENBQUMsQ0FBQ2lxQixVQUFGLEdBQWVqcUIsQ0FBQyxDQUFDdlIsT0FBRixDQUFVKzVCLFlBQTdCLEVBQTJDO0FBRXZDLFlBQUl4b0IsQ0FBQyxDQUFDdlIsT0FBRixDQUFVdTRCLFVBQVYsS0FBeUIsSUFBN0IsRUFBbUM7QUFDL0JrUCxVQUFBQSxhQUFhLEdBQUdsMkIsQ0FBQyxDQUFDdlIsT0FBRixDQUFVKzVCLFlBQVYsR0FBeUIsQ0FBekM7QUFDSCxTQUZELE1BRU87QUFDSDBOLFVBQUFBLGFBQWEsR0FBR2wyQixDQUFDLENBQUN2UixPQUFGLENBQVUrNUIsWUFBMUI7QUFDSDs7QUFFRCxhQUFLbGhHLENBQUMsR0FBRzA0RSxDQUFDLENBQUNpcUIsVUFBWCxFQUF1QjNpRyxDQUFDLEdBQUkwNEUsQ0FBQyxDQUFDaXFCLFVBQUYsR0FDcEJpTSxhQURSLEVBQ3dCNXVHLENBQUMsSUFBSSxDQUQ3QixFQUNnQztBQUM1QmlwRyxVQUFBQSxVQUFVLEdBQUdqcEcsQ0FBQyxHQUFHLENBQWpCO0FBQ0EwK0YsVUFBQUEsQ0FBQyxDQUFDaG1CLENBQUMsQ0FBQ29xQixPQUFGLENBQVVtRyxVQUFWLENBQUQsQ0FBRCxDQUF5QmwzRSxLQUF6QixDQUErQixJQUEvQixFQUFxQ3JQLElBQXJDLENBQTBDLElBQTFDLEVBQWdELEVBQWhELEVBQ0tBLElBREwsQ0FDVSxrQkFEVixFQUM4QnVtRixVQUFVLEdBQUd2d0IsQ0FBQyxDQUFDaXFCLFVBRDdDLEVBRUtuYSxTQUZMLENBRWU5UCxDQUFDLENBQUNtcUIsV0FGakIsRUFFOEJ4USxRQUY5QixDQUV1QyxjQUZ2QztBQUdIOztBQUNELGFBQUtyeUYsQ0FBQyxHQUFHLENBQVQsRUFBWUEsQ0FBQyxHQUFHNHVHLGFBQWEsR0FBSWwyQixDQUFDLENBQUNpcUIsVUFBbkMsRUFBK0MzaUcsQ0FBQyxJQUFJLENBQXBELEVBQXVEO0FBQ25EaXBHLFVBQUFBLFVBQVUsR0FBR2pwRyxDQUFiO0FBQ0EwK0YsVUFBQUEsQ0FBQyxDQUFDaG1CLENBQUMsQ0FBQ29xQixPQUFGLENBQVVtRyxVQUFWLENBQUQsQ0FBRCxDQUF5QmwzRSxLQUF6QixDQUErQixJQUEvQixFQUFxQ3JQLElBQXJDLENBQTBDLElBQTFDLEVBQWdELEVBQWhELEVBQ0tBLElBREwsQ0FDVSxrQkFEVixFQUM4QnVtRixVQUFVLEdBQUd2d0IsQ0FBQyxDQUFDaXFCLFVBRDdDLEVBRUtwYSxRQUZMLENBRWM3UCxDQUFDLENBQUNtcUIsV0FGaEIsRUFFNkJ4USxRQUY3QixDQUVzQyxjQUZ0QztBQUdIOztBQUNEM1osUUFBQUEsQ0FBQyxDQUFDbXFCLFdBQUYsQ0FBYzV6QixJQUFkLENBQW1CLGVBQW5CLEVBQW9DQSxJQUFwQyxDQUF5QyxNQUF6QyxFQUFpRHRzQixJQUFqRCxDQUFzRCxZQUFXO0FBQzdEKzdDLFVBQUFBLENBQUMsQ0FBQyxJQUFELENBQUQsQ0FBUWg4RSxJQUFSLENBQWEsSUFBYixFQUFtQixFQUFuQjtBQUNILFNBRkQ7QUFJSDtBQUVKO0FBRUosR0ExQ0Q7O0FBNENBbThFLEVBQUFBLEtBQUssQ0FBQ3hqRyxTQUFOLENBQWdCcXRHLFNBQWhCLEdBQTRCLFVBQVU1b0IsTUFBVixFQUFtQjtBQUUzQyxRQUFJcEgsQ0FBQyxHQUFHLElBQVI7O0FBRUEsUUFBSSxDQUFDb0gsTUFBTCxFQUFjO0FBQ1ZwSCxNQUFBQSxDQUFDLENBQUNnc0IsUUFBRjtBQUNIOztBQUNEaHNCLElBQUFBLENBQUMsQ0FBQzdsRSxXQUFGLEdBQWdCaXRFLE1BQWhCO0FBRUgsR0FURDs7QUFXQStlLEVBQUFBLEtBQUssQ0FBQ3hqRyxTQUFOLENBQWdCMHBHLGFBQWhCLEdBQWdDLFVBQVMvaUcsS0FBVCxFQUFnQjtBQUU1QyxRQUFJMDJFLENBQUMsR0FBRyxJQUFSOztBQUVBLFFBQUltMkIsYUFBYSxHQUNiblEsQ0FBQyxDQUFDMThGLEtBQUssQ0FBQ1MsTUFBUCxDQUFELENBQWdCczBFLEVBQWhCLENBQW1CLGNBQW5CLElBQ0kybkIsQ0FBQyxDQUFDMThGLEtBQUssQ0FBQ1MsTUFBUCxDQURMLEdBRUlpOEYsQ0FBQyxDQUFDMThGLEtBQUssQ0FBQ1MsTUFBUCxDQUFELENBQWdCdzFFLE9BQWhCLENBQXdCLGNBQXhCLENBSFI7QUFLQSxRQUFJcDJELEtBQUssR0FBRzRtQyxRQUFRLENBQUNvbUQsYUFBYSxDQUFDbnNGLElBQWQsQ0FBbUIsa0JBQW5CLENBQUQsQ0FBcEI7QUFFQSxRQUFJLENBQUNiLEtBQUwsRUFBWUEsS0FBSyxHQUFHLENBQVI7O0FBRVosUUFBSTYyRCxDQUFDLENBQUNpcUIsVUFBRixJQUFnQmpxQixDQUFDLENBQUN2UixPQUFGLENBQVUrNUIsWUFBOUIsRUFBNEM7QUFFeEN4b0IsTUFBQUEsQ0FBQyxDQUFDOHRCLFlBQUYsQ0FBZTNrRixLQUFmLEVBQXNCLEtBQXRCLEVBQTZCLElBQTdCOztBQUNBO0FBRUg7O0FBRUQ2MkQsSUFBQUEsQ0FBQyxDQUFDOHRCLFlBQUYsQ0FBZTNrRixLQUFmO0FBRUgsR0F0QkQ7O0FBd0JBZzlFLEVBQUFBLEtBQUssQ0FBQ3hqRyxTQUFOLENBQWdCbXJHLFlBQWhCLEdBQStCLFVBQVMza0YsS0FBVCxFQUFnQml0RixJQUFoQixFQUFzQjdHLFdBQXRCLEVBQW1DO0FBRTlELFFBQUk4QixXQUFKO0FBQUEsUUFBaUJnRixTQUFqQjtBQUFBLFFBQTRCQyxRQUE1QjtBQUFBLFFBQXNDQyxTQUF0QztBQUFBLFFBQWlEaEosVUFBVSxHQUFHLElBQTlEO0FBQUEsUUFDSXZ0QixDQUFDLEdBQUcsSUFEUjtBQUFBLFFBQ2N3MkIsU0FEZDs7QUFHQUosSUFBQUEsSUFBSSxHQUFHQSxJQUFJLElBQUksS0FBZjs7QUFFQSxRQUFJcDJCLENBQUMsQ0FBQ3FwQixTQUFGLEtBQWdCLElBQWhCLElBQXdCcnBCLENBQUMsQ0FBQ3ZSLE9BQUYsQ0FBVTA2QixjQUFWLEtBQTZCLElBQXpELEVBQStEO0FBQzNEO0FBQ0g7O0FBRUQsUUFBSW5wQixDQUFDLENBQUN2UixPQUFGLENBQVUrNEIsSUFBVixLQUFtQixJQUFuQixJQUEyQnhuQixDQUFDLENBQUN5cEIsWUFBRixLQUFtQnRnRixLQUFsRCxFQUF5RDtBQUNyRDtBQUNIOztBQUVELFFBQUlpdEYsSUFBSSxLQUFLLEtBQWIsRUFBb0I7QUFDaEJwMkIsTUFBQUEsQ0FBQyxDQUFDMm1CLFFBQUYsQ0FBV3g5RSxLQUFYO0FBQ0g7O0FBRURrb0YsSUFBQUEsV0FBVyxHQUFHbG9GLEtBQWQ7QUFDQW9rRixJQUFBQSxVQUFVLEdBQUd2dEIsQ0FBQyxDQUFDa3hCLE9BQUYsQ0FBVUcsV0FBVixDQUFiO0FBQ0FrRixJQUFBQSxTQUFTLEdBQUd2MkIsQ0FBQyxDQUFDa3hCLE9BQUYsQ0FBVWx4QixDQUFDLENBQUN5cEIsWUFBWixDQUFaO0FBRUF6cEIsSUFBQUEsQ0FBQyxDQUFDd3BCLFdBQUYsR0FBZ0J4cEIsQ0FBQyxDQUFDdXFCLFNBQUYsS0FBZ0IsSUFBaEIsR0FBdUJnTSxTQUF2QixHQUFtQ3YyQixDQUFDLENBQUN1cUIsU0FBckQ7O0FBRUEsUUFBSXZxQixDQUFDLENBQUN2UixPQUFGLENBQVVrNUIsUUFBVixLQUF1QixLQUF2QixJQUFnQzNuQixDQUFDLENBQUN2UixPQUFGLENBQVV1NEIsVUFBVixLQUF5QixLQUF6RCxLQUFtRTc5RSxLQUFLLEdBQUcsQ0FBUixJQUFhQSxLQUFLLEdBQUc2MkQsQ0FBQyxDQUFDb3VCLFdBQUYsS0FBa0JwdUIsQ0FBQyxDQUFDdlIsT0FBRixDQUFVZzZCLGNBQXBILENBQUosRUFBeUk7QUFDckksVUFBSXpvQixDQUFDLENBQUN2UixPQUFGLENBQVUrNEIsSUFBVixLQUFtQixLQUF2QixFQUE4QjtBQUMxQjZKLFFBQUFBLFdBQVcsR0FBR3J4QixDQUFDLENBQUN5cEIsWUFBaEI7O0FBQ0EsWUFBSThGLFdBQVcsS0FBSyxJQUFoQixJQUF3QnZ2QixDQUFDLENBQUNpcUIsVUFBRixHQUFlanFCLENBQUMsQ0FBQ3ZSLE9BQUYsQ0FBVSs1QixZQUFyRCxFQUFtRTtBQUMvRHhvQixVQUFBQSxDQUFDLENBQUNzdEIsWUFBRixDQUFlaUosU0FBZixFQUEwQixZQUFXO0FBQ2pDdjJCLFlBQUFBLENBQUMsQ0FBQ2cwQixTQUFGLENBQVkzQyxXQUFaO0FBQ0gsV0FGRDtBQUdILFNBSkQsTUFJTztBQUNIcnhCLFVBQUFBLENBQUMsQ0FBQ2cwQixTQUFGLENBQVkzQyxXQUFaO0FBQ0g7QUFDSjs7QUFDRDtBQUNILEtBWkQsTUFZTyxJQUFJcnhCLENBQUMsQ0FBQ3ZSLE9BQUYsQ0FBVWs1QixRQUFWLEtBQXVCLEtBQXZCLElBQWdDM25CLENBQUMsQ0FBQ3ZSLE9BQUYsQ0FBVXU0QixVQUFWLEtBQXlCLElBQXpELEtBQWtFNzlFLEtBQUssR0FBRyxDQUFSLElBQWFBLEtBQUssR0FBSTYyRCxDQUFDLENBQUNpcUIsVUFBRixHQUFlanFCLENBQUMsQ0FBQ3ZSLE9BQUYsQ0FBVWc2QixjQUFqSCxDQUFKLEVBQXVJO0FBQzFJLFVBQUl6b0IsQ0FBQyxDQUFDdlIsT0FBRixDQUFVKzRCLElBQVYsS0FBbUIsS0FBdkIsRUFBOEI7QUFDMUI2SixRQUFBQSxXQUFXLEdBQUdyeEIsQ0FBQyxDQUFDeXBCLFlBQWhCOztBQUNBLFlBQUk4RixXQUFXLEtBQUssSUFBaEIsSUFBd0J2dkIsQ0FBQyxDQUFDaXFCLFVBQUYsR0FBZWpxQixDQUFDLENBQUN2UixPQUFGLENBQVUrNUIsWUFBckQsRUFBbUU7QUFDL0R4b0IsVUFBQUEsQ0FBQyxDQUFDc3RCLFlBQUYsQ0FBZWlKLFNBQWYsRUFBMEIsWUFBVztBQUNqQ3YyQixZQUFBQSxDQUFDLENBQUNnMEIsU0FBRixDQUFZM0MsV0FBWjtBQUNILFdBRkQ7QUFHSCxTQUpELE1BSU87QUFDSHJ4QixVQUFBQSxDQUFDLENBQUNnMEIsU0FBRixDQUFZM0MsV0FBWjtBQUNIO0FBQ0o7O0FBQ0Q7QUFDSDs7QUFFRCxRQUFLcnhCLENBQUMsQ0FBQ3ZSLE9BQUYsQ0FBVXE0QixRQUFmLEVBQTBCO0FBQ3RCenNELE1BQUFBLGFBQWEsQ0FBQzJsQyxDQUFDLENBQUNzcEIsYUFBSCxDQUFiO0FBQ0g7O0FBRUQsUUFBSStILFdBQVcsR0FBRyxDQUFsQixFQUFxQjtBQUNqQixVQUFJcnhCLENBQUMsQ0FBQ2lxQixVQUFGLEdBQWVqcUIsQ0FBQyxDQUFDdlIsT0FBRixDQUFVZzZCLGNBQXpCLEtBQTRDLENBQWhELEVBQW1EO0FBQy9DNE4sUUFBQUEsU0FBUyxHQUFHcjJCLENBQUMsQ0FBQ2lxQixVQUFGLEdBQWdCanFCLENBQUMsQ0FBQ2lxQixVQUFGLEdBQWVqcUIsQ0FBQyxDQUFDdlIsT0FBRixDQUFVZzZCLGNBQXJEO0FBQ0gsT0FGRCxNQUVPO0FBQ0g0TixRQUFBQSxTQUFTLEdBQUdyMkIsQ0FBQyxDQUFDaXFCLFVBQUYsR0FBZW9ILFdBQTNCO0FBQ0g7QUFDSixLQU5ELE1BTU8sSUFBSUEsV0FBVyxJQUFJcnhCLENBQUMsQ0FBQ2lxQixVQUFyQixFQUFpQztBQUNwQyxVQUFJanFCLENBQUMsQ0FBQ2lxQixVQUFGLEdBQWVqcUIsQ0FBQyxDQUFDdlIsT0FBRixDQUFVZzZCLGNBQXpCLEtBQTRDLENBQWhELEVBQW1EO0FBQy9DNE4sUUFBQUEsU0FBUyxHQUFHLENBQVo7QUFDSCxPQUZELE1BRU87QUFDSEEsUUFBQUEsU0FBUyxHQUFHaEYsV0FBVyxHQUFHcnhCLENBQUMsQ0FBQ2lxQixVQUE1QjtBQUNIO0FBQ0osS0FOTSxNQU1BO0FBQ0hvTSxNQUFBQSxTQUFTLEdBQUdoRixXQUFaO0FBQ0g7O0FBRURyeEIsSUFBQUEsQ0FBQyxDQUFDcXBCLFNBQUYsR0FBYyxJQUFkOztBQUVBcnBCLElBQUFBLENBQUMsQ0FBQ3VyQixPQUFGLENBQVUzekYsT0FBVixDQUFrQixjQUFsQixFQUFrQyxDQUFDb29FLENBQUQsRUFBSUEsQ0FBQyxDQUFDeXBCLFlBQU4sRUFBb0I0TSxTQUFwQixDQUFsQzs7QUFFQUMsSUFBQUEsUUFBUSxHQUFHdDJCLENBQUMsQ0FBQ3lwQixZQUFiO0FBQ0F6cEIsSUFBQUEsQ0FBQyxDQUFDeXBCLFlBQUYsR0FBaUI0TSxTQUFqQjs7QUFFQXIyQixJQUFBQSxDQUFDLENBQUN3dUIsZUFBRixDQUFrQnh1QixDQUFDLENBQUN5cEIsWUFBcEI7O0FBRUEsUUFBS3pwQixDQUFDLENBQUN2UixPQUFGLENBQVVrNEIsUUFBZixFQUEwQjtBQUV0QjZQLE1BQUFBLFNBQVMsR0FBR3gyQixDQUFDLENBQUM0dEIsWUFBRixFQUFaO0FBQ0E0SSxNQUFBQSxTQUFTLEdBQUdBLFNBQVMsQ0FBQzNJLEtBQVYsQ0FBZ0IsVUFBaEIsQ0FBWjs7QUFFQSxVQUFLMkksU0FBUyxDQUFDdk0sVUFBVixJQUF3QnVNLFNBQVMsQ0FBQy9uQyxPQUFWLENBQWtCKzVCLFlBQS9DLEVBQThEO0FBQzFEZ08sUUFBQUEsU0FBUyxDQUFDaEksZUFBVixDQUEwQnh1QixDQUFDLENBQUN5cEIsWUFBNUI7QUFDSDtBQUVKOztBQUVEenBCLElBQUFBLENBQUMsQ0FBQ3V1QixVQUFGOztBQUNBdnVCLElBQUFBLENBQUMsQ0FBQ3F5QixZQUFGOztBQUVBLFFBQUlyeUIsQ0FBQyxDQUFDdlIsT0FBRixDQUFVKzRCLElBQVYsS0FBbUIsSUFBdkIsRUFBNkI7QUFDekIsVUFBSStILFdBQVcsS0FBSyxJQUFwQixFQUEwQjtBQUV0QnZ2QixRQUFBQSxDQUFDLENBQUN3d0IsWUFBRixDQUFlOEYsUUFBZjs7QUFFQXQyQixRQUFBQSxDQUFDLENBQUNzd0IsU0FBRixDQUFZK0YsU0FBWixFQUF1QixZQUFXO0FBQzlCcjJCLFVBQUFBLENBQUMsQ0FBQ2cwQixTQUFGLENBQVlxQyxTQUFaO0FBQ0gsU0FGRDtBQUlILE9BUkQsTUFRTztBQUNIcjJCLFFBQUFBLENBQUMsQ0FBQ2cwQixTQUFGLENBQVlxQyxTQUFaO0FBQ0g7O0FBQ0RyMkIsTUFBQUEsQ0FBQyxDQUFDbXRCLGFBQUY7O0FBQ0E7QUFDSDs7QUFFRCxRQUFJb0MsV0FBVyxLQUFLLElBQWhCLElBQXdCdnZCLENBQUMsQ0FBQ2lxQixVQUFGLEdBQWVqcUIsQ0FBQyxDQUFDdlIsT0FBRixDQUFVKzVCLFlBQXJELEVBQW1FO0FBQy9EeG9CLE1BQUFBLENBQUMsQ0FBQ3N0QixZQUFGLENBQWVDLFVBQWYsRUFBMkIsWUFBVztBQUNsQ3Z0QixRQUFBQSxDQUFDLENBQUNnMEIsU0FBRixDQUFZcUMsU0FBWjtBQUNILE9BRkQ7QUFHSCxLQUpELE1BSU87QUFDSHIyQixNQUFBQSxDQUFDLENBQUNnMEIsU0FBRixDQUFZcUMsU0FBWjtBQUNIO0FBRUosR0F0SEQ7O0FBd0hBbFEsRUFBQUEsS0FBSyxDQUFDeGpHLFNBQU4sQ0FBZ0J1dkcsU0FBaEIsR0FBNEIsWUFBVztBQUVuQyxRQUFJbHlCLENBQUMsR0FBRyxJQUFSOztBQUVBLFFBQUlBLENBQUMsQ0FBQ3ZSLE9BQUYsQ0FBVWk0QixNQUFWLEtBQXFCLElBQXJCLElBQTZCMW1CLENBQUMsQ0FBQ2lxQixVQUFGLEdBQWVqcUIsQ0FBQyxDQUFDdlIsT0FBRixDQUFVKzVCLFlBQTFELEVBQXdFO0FBRXBFeG9CLE1BQUFBLENBQUMsQ0FBQytwQixVQUFGLENBQWE1aUIsSUFBYjs7QUFDQW5ILE1BQUFBLENBQUMsQ0FBQzhwQixVQUFGLENBQWEzaUIsSUFBYjtBQUVIOztBQUVELFFBQUluSCxDQUFDLENBQUN2UixPQUFGLENBQVU0NEIsSUFBVixLQUFtQixJQUFuQixJQUEyQnJuQixDQUFDLENBQUNpcUIsVUFBRixHQUFlanFCLENBQUMsQ0FBQ3ZSLE9BQUYsQ0FBVSs1QixZQUF4RCxFQUFzRTtBQUVsRXhvQixNQUFBQSxDQUFDLENBQUMwcEIsS0FBRixDQUFRdmlCLElBQVI7QUFFSDs7QUFFRG5ILElBQUFBLENBQUMsQ0FBQ3VyQixPQUFGLENBQVU1UixRQUFWLENBQW1CLGVBQW5CO0FBRUgsR0FuQkQ7O0FBcUJBd00sRUFBQUEsS0FBSyxDQUFDeGpHLFNBQU4sQ0FBZ0I4ekcsY0FBaEIsR0FBaUMsWUFBVztBQUV4QyxRQUFJQyxLQUFKO0FBQUEsUUFBV0MsS0FBWDtBQUFBLFFBQWtCenBHLENBQWxCO0FBQUEsUUFBcUIwcEcsVUFBckI7QUFBQSxRQUFpQzUyQixDQUFDLEdBQUcsSUFBckM7O0FBRUEwMkIsSUFBQUEsS0FBSyxHQUFHMTJCLENBQUMsQ0FBQzBxQixXQUFGLENBQWNwckYsTUFBZCxHQUF1QjBnRSxDQUFDLENBQUMwcUIsV0FBRixDQUFjL3dFLElBQTdDO0FBQ0FnOUUsSUFBQUEsS0FBSyxHQUFHMzJCLENBQUMsQ0FBQzBxQixXQUFGLENBQWNuckYsTUFBZCxHQUF1QnlnRSxDQUFDLENBQUMwcUIsV0FBRixDQUFjOXdFLElBQTdDO0FBQ0Exc0IsSUFBQUEsQ0FBQyxHQUFHakksSUFBSSxDQUFDb2EsS0FBTCxDQUFXczNGLEtBQVgsRUFBa0JELEtBQWxCLENBQUo7QUFFQUUsSUFBQUEsVUFBVSxHQUFHM3hHLElBQUksQ0FBQ0MsS0FBTCxDQUFXZ0ksQ0FBQyxHQUFHLEdBQUosR0FBVWpJLElBQUksQ0FBQ2MsRUFBMUIsQ0FBYjs7QUFDQSxRQUFJNndHLFVBQVUsR0FBRyxDQUFqQixFQUFvQjtBQUNoQkEsTUFBQUEsVUFBVSxHQUFHLE1BQU0zeEcsSUFBSSxDQUFDMmIsR0FBTCxDQUFTZzJGLFVBQVQsQ0FBbkI7QUFDSDs7QUFFRCxRQUFLQSxVQUFVLElBQUksRUFBZixJQUF1QkEsVUFBVSxJQUFJLENBQXpDLEVBQTZDO0FBQ3pDLGFBQVE1MkIsQ0FBQyxDQUFDdlIsT0FBRixDQUFVNDVCLEdBQVYsS0FBa0IsS0FBbEIsR0FBMEIsTUFBMUIsR0FBbUMsT0FBM0M7QUFDSDs7QUFDRCxRQUFLdU8sVUFBVSxJQUFJLEdBQWYsSUFBd0JBLFVBQVUsSUFBSSxHQUExQyxFQUFnRDtBQUM1QyxhQUFRNTJCLENBQUMsQ0FBQ3ZSLE9BQUYsQ0FBVTQ1QixHQUFWLEtBQWtCLEtBQWxCLEdBQTBCLE1BQTFCLEdBQW1DLE9BQTNDO0FBQ0g7O0FBQ0QsUUFBS3VPLFVBQVUsSUFBSSxHQUFmLElBQXdCQSxVQUFVLElBQUksR0FBMUMsRUFBZ0Q7QUFDNUMsYUFBUTUyQixDQUFDLENBQUN2UixPQUFGLENBQVU0NUIsR0FBVixLQUFrQixLQUFsQixHQUEwQixPQUExQixHQUFvQyxNQUE1QztBQUNIOztBQUNELFFBQUlyb0IsQ0FBQyxDQUFDdlIsT0FBRixDQUFVeTZCLGVBQVYsS0FBOEIsSUFBbEMsRUFBd0M7QUFDcEMsVUFBSzBOLFVBQVUsSUFBSSxFQUFmLElBQXVCQSxVQUFVLElBQUksR0FBekMsRUFBK0M7QUFDM0MsZUFBTyxNQUFQO0FBQ0gsT0FGRCxNQUVPO0FBQ0gsZUFBTyxJQUFQO0FBQ0g7QUFDSjs7QUFFRCxXQUFPLFVBQVA7QUFFSCxHQWhDRDs7QUFrQ0F6USxFQUFBQSxLQUFLLENBQUN4akcsU0FBTixDQUFnQmswRyxRQUFoQixHQUEyQixVQUFTdnRHLEtBQVQsRUFBZ0I7QUFFdkMsUUFBSTAyRSxDQUFDLEdBQUcsSUFBUjtBQUFBLFFBQ0lpcUIsVUFESjtBQUFBLFFBRUl4bEYsU0FGSjs7QUFJQXU3RCxJQUFBQSxDQUFDLENBQUMxNkQsUUFBRixHQUFhLEtBQWI7QUFDQTA2RCxJQUFBQSxDQUFDLENBQUN3cUIsT0FBRixHQUFZLEtBQVo7O0FBRUEsUUFBSXhxQixDQUFDLENBQUNncUIsU0FBTixFQUFpQjtBQUNiaHFCLE1BQUFBLENBQUMsQ0FBQ2dxQixTQUFGLEdBQWMsS0FBZDtBQUNBLGFBQU8sS0FBUDtBQUNIOztBQUVEaHFCLElBQUFBLENBQUMsQ0FBQzdsRSxXQUFGLEdBQWdCLEtBQWhCO0FBQ0E2bEUsSUFBQUEsQ0FBQyxDQUFDc3JCLFdBQUYsR0FBa0J0ckIsQ0FBQyxDQUFDMHFCLFdBQUYsQ0FBY29NLFdBQWQsR0FBNEIsRUFBOUIsR0FBcUMsS0FBckMsR0FBNkMsSUFBN0Q7O0FBRUEsUUFBSzkyQixDQUFDLENBQUMwcUIsV0FBRixDQUFjL3dFLElBQWQsS0FBdUJrMUMsU0FBNUIsRUFBd0M7QUFDcEMsYUFBTyxLQUFQO0FBQ0g7O0FBRUQsUUFBS21SLENBQUMsQ0FBQzBxQixXQUFGLENBQWNxTSxPQUFkLEtBQTBCLElBQS9CLEVBQXNDO0FBQ2xDLzJCLE1BQUFBLENBQUMsQ0FBQ3VyQixPQUFGLENBQVUzekYsT0FBVixDQUFrQixNQUFsQixFQUEwQixDQUFDb29FLENBQUQsRUFBSUEsQ0FBQyxDQUFDeTJCLGNBQUYsRUFBSixDQUExQjtBQUNIOztBQUVELFFBQUt6MkIsQ0FBQyxDQUFDMHFCLFdBQUYsQ0FBY29NLFdBQWQsSUFBNkI5MkIsQ0FBQyxDQUFDMHFCLFdBQUYsQ0FBY3NNLFFBQWhELEVBQTJEO0FBRXZEdnlGLE1BQUFBLFNBQVMsR0FBR3U3RCxDQUFDLENBQUN5MkIsY0FBRixFQUFaOztBQUVBLGNBQVNoeUYsU0FBVDtBQUVJLGFBQUssTUFBTDtBQUNBLGFBQUssTUFBTDtBQUVJd2xGLFVBQUFBLFVBQVUsR0FDTmpxQixDQUFDLENBQUN2UixPQUFGLENBQVVrNkIsWUFBVixHQUNJM29CLENBQUMsQ0FBQzJ2QixjQUFGLENBQWtCM3ZCLENBQUMsQ0FBQ3lwQixZQUFGLEdBQWlCenBCLENBQUMsQ0FBQzB4QixhQUFGLEVBQW5DLENBREosR0FFSTF4QixDQUFDLENBQUN5cEIsWUFBRixHQUFpQnpwQixDQUFDLENBQUMweEIsYUFBRixFQUh6QjtBQUtBMXhCLFVBQUFBLENBQUMsQ0FBQ3VwQixnQkFBRixHQUFxQixDQUFyQjtBQUVBOztBQUVKLGFBQUssT0FBTDtBQUNBLGFBQUssSUFBTDtBQUVJVSxVQUFBQSxVQUFVLEdBQ05qcUIsQ0FBQyxDQUFDdlIsT0FBRixDQUFVazZCLFlBQVYsR0FDSTNvQixDQUFDLENBQUMydkIsY0FBRixDQUFrQjN2QixDQUFDLENBQUN5cEIsWUFBRixHQUFpQnpwQixDQUFDLENBQUMweEIsYUFBRixFQUFuQyxDQURKLEdBRUkxeEIsQ0FBQyxDQUFDeXBCLFlBQUYsR0FBaUJ6cEIsQ0FBQyxDQUFDMHhCLGFBQUYsRUFIekI7QUFLQTF4QixVQUFBQSxDQUFDLENBQUN1cEIsZ0JBQUYsR0FBcUIsQ0FBckI7QUFFQTs7QUFFSjtBQTFCSjs7QUErQkEsVUFBSTlrRixTQUFTLElBQUksVUFBakIsRUFBOEI7QUFFMUJ1N0QsUUFBQUEsQ0FBQyxDQUFDOHRCLFlBQUYsQ0FBZ0I3RCxVQUFoQjs7QUFDQWpxQixRQUFBQSxDQUFDLENBQUMwcUIsV0FBRixHQUFnQixFQUFoQjs7QUFDQTFxQixRQUFBQSxDQUFDLENBQUN1ckIsT0FBRixDQUFVM3pGLE9BQVYsQ0FBa0IsT0FBbEIsRUFBMkIsQ0FBQ29vRSxDQUFELEVBQUl2N0QsU0FBSixDQUEzQjtBQUVIO0FBRUosS0EzQ0QsTUEyQ087QUFFSCxVQUFLdTdELENBQUMsQ0FBQzBxQixXQUFGLENBQWNwckYsTUFBZCxLQUF5QjBnRSxDQUFDLENBQUMwcUIsV0FBRixDQUFjL3dFLElBQTVDLEVBQW1EO0FBRS9DcW1ELFFBQUFBLENBQUMsQ0FBQzh0QixZQUFGLENBQWdCOXRCLENBQUMsQ0FBQ3lwQixZQUFsQjs7QUFDQXpwQixRQUFBQSxDQUFDLENBQUMwcUIsV0FBRixHQUFnQixFQUFoQjtBQUVIO0FBRUo7QUFFSixHQS9FRDs7QUFpRkF2RSxFQUFBQSxLQUFLLENBQUN4akcsU0FBTixDQUFnQjRwRyxZQUFoQixHQUErQixVQUFTampHLEtBQVQsRUFBZ0I7QUFFM0MsUUFBSTAyRSxDQUFDLEdBQUcsSUFBUjs7QUFFQSxRQUFLQSxDQUFDLENBQUN2UixPQUFGLENBQVVpNkIsS0FBVixLQUFvQixLQUFyQixJQUFnQyxnQkFBZ0I3MkYsUUFBaEIsSUFBNEJtdUUsQ0FBQyxDQUFDdlIsT0FBRixDQUFVaTZCLEtBQVYsS0FBb0IsS0FBcEYsRUFBNEY7QUFDeEY7QUFDSCxLQUZELE1BRU8sSUFBSTFvQixDQUFDLENBQUN2UixPQUFGLENBQVV4K0QsU0FBVixLQUF3QixLQUF4QixJQUFpQzNHLEtBQUssQ0FBQy9ELElBQU4sQ0FBV3dQLE9BQVgsQ0FBbUIsT0FBbkIsTUFBZ0MsQ0FBQyxDQUF0RSxFQUF5RTtBQUM1RTtBQUNIOztBQUVEaXJFLElBQUFBLENBQUMsQ0FBQzBxQixXQUFGLENBQWN1TSxXQUFkLEdBQTRCM3RHLEtBQUssQ0FBQ3FYLGFBQU4sSUFBdUJyWCxLQUFLLENBQUNxWCxhQUFOLENBQW9CN1csT0FBcEIsS0FBZ0Mra0UsU0FBdkQsR0FDeEJ2bEUsS0FBSyxDQUFDcVgsYUFBTixDQUFvQjdXLE9BQXBCLENBQTRCdkMsTUFESixHQUNhLENBRHpDO0FBR0F5NEUsSUFBQUEsQ0FBQyxDQUFDMHFCLFdBQUYsQ0FBY3NNLFFBQWQsR0FBeUJoM0IsQ0FBQyxDQUFDMnBCLFNBQUYsR0FBYzNwQixDQUFDLENBQUN2UixPQUFGLENBQ2xDbzZCLGNBREw7O0FBR0EsUUFBSTdvQixDQUFDLENBQUN2UixPQUFGLENBQVV5NkIsZUFBVixLQUE4QixJQUFsQyxFQUF3QztBQUNwQ2xwQixNQUFBQSxDQUFDLENBQUMwcUIsV0FBRixDQUFjc00sUUFBZCxHQUF5QmgzQixDQUFDLENBQUM0cEIsVUFBRixHQUFlNXBCLENBQUMsQ0FBQ3ZSLE9BQUYsQ0FDbkNvNkIsY0FETDtBQUVIOztBQUVELFlBQVF2L0YsS0FBSyxDQUFDWCxJQUFOLENBQVc0d0MsTUFBbkI7QUFFSSxXQUFLLE9BQUw7QUFDSXltQyxRQUFBQSxDQUFDLENBQUNrM0IsVUFBRixDQUFhNXRHLEtBQWI7O0FBQ0E7O0FBRUosV0FBSyxNQUFMO0FBQ0kwMkUsUUFBQUEsQ0FBQyxDQUFDbTNCLFNBQUYsQ0FBWTd0RyxLQUFaOztBQUNBOztBQUVKLFdBQUssS0FBTDtBQUNJMDJFLFFBQUFBLENBQUMsQ0FBQzYyQixRQUFGLENBQVd2dEcsS0FBWDs7QUFDQTtBQVpSO0FBZ0JILEdBckNEOztBQXVDQTY4RixFQUFBQSxLQUFLLENBQUN4akcsU0FBTixDQUFnQncwRyxTQUFoQixHQUE0QixVQUFTN3RHLEtBQVQsRUFBZ0I7QUFFeEMsUUFBSTAyRSxDQUFDLEdBQUcsSUFBUjtBQUFBLFFBQ0lvM0IsVUFBVSxHQUFHLEtBRGpCO0FBQUEsUUFFSWpULE9BRko7QUFBQSxRQUVhc1MsY0FGYjtBQUFBLFFBRTZCSyxXQUY3QjtBQUFBLFFBRTBDTyxjQUYxQztBQUFBLFFBRTBEdnRHLE9BRjFEO0FBQUEsUUFFbUV3dEcsbUJBRm5FOztBQUlBeHRHLElBQUFBLE9BQU8sR0FBR1IsS0FBSyxDQUFDcVgsYUFBTixLQUF3Qmt1RCxTQUF4QixHQUFvQ3ZsRSxLQUFLLENBQUNxWCxhQUFOLENBQW9CN1csT0FBeEQsR0FBa0UsSUFBNUU7O0FBRUEsUUFBSSxDQUFDazJFLENBQUMsQ0FBQzE2RCxRQUFILElBQWUwNkQsQ0FBQyxDQUFDZ3FCLFNBQWpCLElBQThCbGdHLE9BQU8sSUFBSUEsT0FBTyxDQUFDdkMsTUFBUixLQUFtQixDQUFoRSxFQUFtRTtBQUMvRCxhQUFPLEtBQVA7QUFDSDs7QUFFRDQ4RixJQUFBQSxPQUFPLEdBQUdua0IsQ0FBQyxDQUFDa3hCLE9BQUYsQ0FBVWx4QixDQUFDLENBQUN5cEIsWUFBWixDQUFWO0FBRUF6cEIsSUFBQUEsQ0FBQyxDQUFDMHFCLFdBQUYsQ0FBYy93RSxJQUFkLEdBQXFCN3ZCLE9BQU8sS0FBSytrRSxTQUFaLEdBQXdCL2tFLE9BQU8sQ0FBQyxDQUFELENBQVAsQ0FBV3FELEtBQW5DLEdBQTJDN0QsS0FBSyxDQUFDaTdCLE9BQXRFO0FBQ0F5N0MsSUFBQUEsQ0FBQyxDQUFDMHFCLFdBQUYsQ0FBYzl3RSxJQUFkLEdBQXFCOXZCLE9BQU8sS0FBSytrRSxTQUFaLEdBQXdCL2tFLE9BQU8sQ0FBQyxDQUFELENBQVAsQ0FBV3NELEtBQW5DLEdBQTJDOUQsS0FBSyxDQUFDazdCLE9BQXRFO0FBRUF3N0MsSUFBQUEsQ0FBQyxDQUFDMHFCLFdBQUYsQ0FBY29NLFdBQWQsR0FBNEI3eEcsSUFBSSxDQUFDQyxLQUFMLENBQVdELElBQUksQ0FBQ2dpQixJQUFMLENBQ25DaGlCLElBQUksQ0FBQzJ3QixHQUFMLENBQVNvcUQsQ0FBQyxDQUFDMHFCLFdBQUYsQ0FBYy93RSxJQUFkLEdBQXFCcW1ELENBQUMsQ0FBQzBxQixXQUFGLENBQWNwckYsTUFBNUMsRUFBb0QsQ0FBcEQsQ0FEbUMsQ0FBWCxDQUE1QjtBQUdBZzRGLElBQUFBLG1CQUFtQixHQUFHcnlHLElBQUksQ0FBQ0MsS0FBTCxDQUFXRCxJQUFJLENBQUNnaUIsSUFBTCxDQUM3QmhpQixJQUFJLENBQUMyd0IsR0FBTCxDQUFTb3FELENBQUMsQ0FBQzBxQixXQUFGLENBQWM5d0UsSUFBZCxHQUFxQm9tRCxDQUFDLENBQUMwcUIsV0FBRixDQUFjbnJGLE1BQTVDLEVBQW9ELENBQXBELENBRDZCLENBQVgsQ0FBdEI7O0FBR0EsUUFBSSxDQUFDeWdFLENBQUMsQ0FBQ3ZSLE9BQUYsQ0FBVXk2QixlQUFYLElBQThCLENBQUNscEIsQ0FBQyxDQUFDd3FCLE9BQWpDLElBQTRDOE0sbUJBQW1CLEdBQUcsQ0FBdEUsRUFBeUU7QUFDckV0M0IsTUFBQUEsQ0FBQyxDQUFDZ3FCLFNBQUYsR0FBYyxJQUFkO0FBQ0EsYUFBTyxLQUFQO0FBQ0g7O0FBRUQsUUFBSWhxQixDQUFDLENBQUN2UixPQUFGLENBQVV5NkIsZUFBVixLQUE4QixJQUFsQyxFQUF3QztBQUNwQ2xwQixNQUFBQSxDQUFDLENBQUMwcUIsV0FBRixDQUFjb00sV0FBZCxHQUE0QlEsbUJBQTVCO0FBQ0g7O0FBRURiLElBQUFBLGNBQWMsR0FBR3oyQixDQUFDLENBQUN5MkIsY0FBRixFQUFqQjs7QUFFQSxRQUFJbnRHLEtBQUssQ0FBQ3FYLGFBQU4sS0FBd0JrdUQsU0FBeEIsSUFBcUNtUixDQUFDLENBQUMwcUIsV0FBRixDQUFjb00sV0FBZCxHQUE0QixDQUFyRSxFQUF3RTtBQUNwRTkyQixNQUFBQSxDQUFDLENBQUN3cUIsT0FBRixHQUFZLElBQVo7QUFDQWxoRyxNQUFBQSxLQUFLLENBQUNDLGNBQU47QUFDSDs7QUFFRDh0RyxJQUFBQSxjQUFjLEdBQUcsQ0FBQ3IzQixDQUFDLENBQUN2UixPQUFGLENBQVU0NUIsR0FBVixLQUFrQixLQUFsQixHQUEwQixDQUExQixHQUE4QixDQUFDLENBQWhDLEtBQXNDcm9CLENBQUMsQ0FBQzBxQixXQUFGLENBQWMvd0UsSUFBZCxHQUFxQnFtRCxDQUFDLENBQUMwcUIsV0FBRixDQUFjcHJGLE1BQW5DLEdBQTRDLENBQTVDLEdBQWdELENBQUMsQ0FBdkYsQ0FBakI7O0FBQ0EsUUFBSTBnRSxDQUFDLENBQUN2UixPQUFGLENBQVV5NkIsZUFBVixLQUE4QixJQUFsQyxFQUF3QztBQUNwQ21PLE1BQUFBLGNBQWMsR0FBR3IzQixDQUFDLENBQUMwcUIsV0FBRixDQUFjOXdFLElBQWQsR0FBcUJvbUQsQ0FBQyxDQUFDMHFCLFdBQUYsQ0FBY25yRixNQUFuQyxHQUE0QyxDQUE1QyxHQUFnRCxDQUFDLENBQWxFO0FBQ0g7O0FBR0R1M0YsSUFBQUEsV0FBVyxHQUFHOTJCLENBQUMsQ0FBQzBxQixXQUFGLENBQWNvTSxXQUE1QjtBQUVBOTJCLElBQUFBLENBQUMsQ0FBQzBxQixXQUFGLENBQWNxTSxPQUFkLEdBQXdCLEtBQXhCOztBQUVBLFFBQUkvMkIsQ0FBQyxDQUFDdlIsT0FBRixDQUFVazVCLFFBQVYsS0FBdUIsS0FBM0IsRUFBa0M7QUFDOUIsVUFBSzNuQixDQUFDLENBQUN5cEIsWUFBRixLQUFtQixDQUFuQixJQUF3QmdOLGNBQWMsS0FBSyxPQUE1QyxJQUF5RHoyQixDQUFDLENBQUN5cEIsWUFBRixJQUFrQnpwQixDQUFDLENBQUNvdUIsV0FBRixFQUFsQixJQUFxQ3FJLGNBQWMsS0FBSyxNQUFySCxFQUE4SDtBQUMxSEssUUFBQUEsV0FBVyxHQUFHOTJCLENBQUMsQ0FBQzBxQixXQUFGLENBQWNvTSxXQUFkLEdBQTRCOTJCLENBQUMsQ0FBQ3ZSLE9BQUYsQ0FBVTg0QixZQUFwRDtBQUNBdm5CLFFBQUFBLENBQUMsQ0FBQzBxQixXQUFGLENBQWNxTSxPQUFkLEdBQXdCLElBQXhCO0FBQ0g7QUFDSjs7QUFFRCxRQUFJLzJCLENBQUMsQ0FBQ3ZSLE9BQUYsQ0FBVXc2QixRQUFWLEtBQXVCLEtBQTNCLEVBQWtDO0FBQzlCanBCLE1BQUFBLENBQUMsQ0FBQ3VxQixTQUFGLEdBQWNwRyxPQUFPLEdBQUcyUyxXQUFXLEdBQUdPLGNBQXRDO0FBQ0gsS0FGRCxNQUVPO0FBQ0hyM0IsTUFBQUEsQ0FBQyxDQUFDdXFCLFNBQUYsR0FBY3BHLE9BQU8sR0FBSTJTLFdBQVcsSUFBSTkyQixDQUFDLENBQUN5cUIsS0FBRixDQUFRNTlGLE1BQVIsS0FBbUJtekUsQ0FBQyxDQUFDMnBCLFNBQXpCLENBQVosR0FBbUQwTixjQUEzRTtBQUNIOztBQUNELFFBQUlyM0IsQ0FBQyxDQUFDdlIsT0FBRixDQUFVeTZCLGVBQVYsS0FBOEIsSUFBbEMsRUFBd0M7QUFDcENscEIsTUFBQUEsQ0FBQyxDQUFDdXFCLFNBQUYsR0FBY3BHLE9BQU8sR0FBRzJTLFdBQVcsR0FBR08sY0FBdEM7QUFDSDs7QUFFRCxRQUFJcjNCLENBQUMsQ0FBQ3ZSLE9BQUYsQ0FBVSs0QixJQUFWLEtBQW1CLElBQW5CLElBQTJCeG5CLENBQUMsQ0FBQ3ZSLE9BQUYsQ0FBVW02QixTQUFWLEtBQXdCLEtBQXZELEVBQThEO0FBQzFELGFBQU8sS0FBUDtBQUNIOztBQUVELFFBQUk1b0IsQ0FBQyxDQUFDcXBCLFNBQUYsS0FBZ0IsSUFBcEIsRUFBMEI7QUFDdEJycEIsTUFBQUEsQ0FBQyxDQUFDdXFCLFNBQUYsR0FBYyxJQUFkO0FBQ0EsYUFBTyxLQUFQO0FBQ0g7O0FBRUR2cUIsSUFBQUEsQ0FBQyxDQUFDODBCLE1BQUYsQ0FBUzkwQixDQUFDLENBQUN1cUIsU0FBWDtBQUVILEdBNUVEOztBQThFQXBFLEVBQUFBLEtBQUssQ0FBQ3hqRyxTQUFOLENBQWdCdTBHLFVBQWhCLEdBQTZCLFVBQVM1dEcsS0FBVCxFQUFnQjtBQUV6QyxRQUFJMDJFLENBQUMsR0FBRyxJQUFSO0FBQUEsUUFDSWwyRSxPQURKOztBQUdBazJFLElBQUFBLENBQUMsQ0FBQzdsRSxXQUFGLEdBQWdCLElBQWhCOztBQUVBLFFBQUk2bEUsQ0FBQyxDQUFDMHFCLFdBQUYsQ0FBY3VNLFdBQWQsS0FBOEIsQ0FBOUIsSUFBbUNqM0IsQ0FBQyxDQUFDaXFCLFVBQUYsSUFBZ0JqcUIsQ0FBQyxDQUFDdlIsT0FBRixDQUFVKzVCLFlBQWpFLEVBQStFO0FBQzNFeG9CLE1BQUFBLENBQUMsQ0FBQzBxQixXQUFGLEdBQWdCLEVBQWhCO0FBQ0EsYUFBTyxLQUFQO0FBQ0g7O0FBRUQsUUFBSXBoRyxLQUFLLENBQUNxWCxhQUFOLEtBQXdCa3VELFNBQXhCLElBQXFDdmxFLEtBQUssQ0FBQ3FYLGFBQU4sQ0FBb0I3VyxPQUFwQixLQUFnQytrRSxTQUF6RSxFQUFvRjtBQUNoRi9rRSxNQUFBQSxPQUFPLEdBQUdSLEtBQUssQ0FBQ3FYLGFBQU4sQ0FBb0I3VyxPQUFwQixDQUE0QixDQUE1QixDQUFWO0FBQ0g7O0FBRURrMkUsSUFBQUEsQ0FBQyxDQUFDMHFCLFdBQUYsQ0FBY3ByRixNQUFkLEdBQXVCMGdFLENBQUMsQ0FBQzBxQixXQUFGLENBQWMvd0UsSUFBZCxHQUFxQjd2QixPQUFPLEtBQUsra0UsU0FBWixHQUF3Qi9rRSxPQUFPLENBQUNxRCxLQUFoQyxHQUF3QzdELEtBQUssQ0FBQ2k3QixPQUExRjtBQUNBeTdDLElBQUFBLENBQUMsQ0FBQzBxQixXQUFGLENBQWNuckYsTUFBZCxHQUF1QnlnRSxDQUFDLENBQUMwcUIsV0FBRixDQUFjOXdFLElBQWQsR0FBcUI5dkIsT0FBTyxLQUFLK2tFLFNBQVosR0FBd0Iva0UsT0FBTyxDQUFDc0QsS0FBaEMsR0FBd0M5RCxLQUFLLENBQUNrN0IsT0FBMUY7QUFFQXc3QyxJQUFBQSxDQUFDLENBQUMxNkQsUUFBRixHQUFhLElBQWI7QUFFSCxHQXJCRDs7QUF1QkE2Z0YsRUFBQUEsS0FBSyxDQUFDeGpHLFNBQU4sQ0FBZ0I0MEcsY0FBaEIsR0FBaUNwUixLQUFLLENBQUN4akcsU0FBTixDQUFnQjYwRyxhQUFoQixHQUFnQyxZQUFXO0FBRXhFLFFBQUl4M0IsQ0FBQyxHQUFHLElBQVI7O0FBRUEsUUFBSUEsQ0FBQyxDQUFDd3JCLFlBQUYsS0FBbUIsSUFBdkIsRUFBNkI7QUFFekJ4ckIsTUFBQUEsQ0FBQyxDQUFDaXRCLE1BQUY7O0FBRUFqdEIsTUFBQUEsQ0FBQyxDQUFDbXFCLFdBQUYsQ0FBYzNpRyxRQUFkLENBQXVCLEtBQUtpbkUsT0FBTCxDQUFhNjVCLEtBQXBDLEVBQTJDaFosTUFBM0M7O0FBRUF0UCxNQUFBQSxDQUFDLENBQUN3ckIsWUFBRixDQUFlM2IsUUFBZixDQUF3QjdQLENBQUMsQ0FBQ21xQixXQUExQjs7QUFFQW5xQixNQUFBQSxDQUFDLENBQUNrdEIsTUFBRjtBQUVIO0FBRUosR0FoQkQ7O0FBa0JBL0csRUFBQUEsS0FBSyxDQUFDeGpHLFNBQU4sQ0FBZ0JzcUcsTUFBaEIsR0FBeUIsWUFBVztBQUVoQyxRQUFJanRCLENBQUMsR0FBRyxJQUFSOztBQUVBZ21CLElBQUFBLENBQUMsQ0FBQyxlQUFELEVBQWtCaG1CLENBQUMsQ0FBQ3VyQixPQUFwQixDQUFELENBQThCcGpHLE1BQTlCOztBQUVBLFFBQUk2M0UsQ0FBQyxDQUFDMHBCLEtBQU4sRUFBYTtBQUNUMXBCLE1BQUFBLENBQUMsQ0FBQzBwQixLQUFGLENBQVF2aEcsTUFBUjtBQUNIOztBQUVELFFBQUk2M0UsQ0FBQyxDQUFDK3BCLFVBQUYsSUFBZ0IvcEIsQ0FBQyxDQUFDMHNCLFFBQUYsQ0FBVzk3RixJQUFYLENBQWdCb3ZFLENBQUMsQ0FBQ3ZSLE9BQUYsQ0FBVW00QixTQUExQixDQUFwQixFQUEwRDtBQUN0RDVtQixNQUFBQSxDQUFDLENBQUMrcEIsVUFBRixDQUFhNWhHLE1BQWI7QUFDSDs7QUFFRCxRQUFJNjNFLENBQUMsQ0FBQzhwQixVQUFGLElBQWdCOXBCLENBQUMsQ0FBQzBzQixRQUFGLENBQVc5N0YsSUFBWCxDQUFnQm92RSxDQUFDLENBQUN2UixPQUFGLENBQVVvNEIsU0FBMUIsQ0FBcEIsRUFBMEQ7QUFDdEQ3bUIsTUFBQUEsQ0FBQyxDQUFDOHBCLFVBQUYsQ0FBYTNoRyxNQUFiO0FBQ0g7O0FBRUQ2M0UsSUFBQUEsQ0FBQyxDQUFDb3FCLE9BQUYsQ0FDS3RRLFdBREwsQ0FDaUIsc0RBRGpCLEVBRUs5dkUsSUFGTCxDQUVVLGFBRlYsRUFFeUIsTUFGekIsRUFHS3VpQixHQUhMLENBR1MsT0FIVCxFQUdrQixFQUhsQjtBQUtILEdBdkJEOztBQXlCQTQ1RCxFQUFBQSxLQUFLLENBQUN4akcsU0FBTixDQUFnQjJzRyxPQUFoQixHQUEwQixVQUFTbUksY0FBVCxFQUF5QjtBQUUvQyxRQUFJejNCLENBQUMsR0FBRyxJQUFSOztBQUNBQSxJQUFBQSxDQUFDLENBQUN1ckIsT0FBRixDQUFVM3pGLE9BQVYsQ0FBa0IsU0FBbEIsRUFBNkIsQ0FBQ29vRSxDQUFELEVBQUl5M0IsY0FBSixDQUE3Qjs7QUFDQXozQixJQUFBQSxDQUFDLENBQUNxd0IsT0FBRjtBQUVILEdBTkQ7O0FBUUFsSyxFQUFBQSxLQUFLLENBQUN4akcsU0FBTixDQUFnQjB2RyxZQUFoQixHQUErQixZQUFXO0FBRXRDLFFBQUlyeUIsQ0FBQyxHQUFHLElBQVI7QUFBQSxRQUNJNnhCLFlBREo7O0FBR0FBLElBQUFBLFlBQVksR0FBRzVzRyxJQUFJLENBQUN1Z0QsS0FBTCxDQUFXdzZCLENBQUMsQ0FBQ3ZSLE9BQUYsQ0FBVSs1QixZQUFWLEdBQXlCLENBQXBDLENBQWY7O0FBRUEsUUFBS3hvQixDQUFDLENBQUN2UixPQUFGLENBQVVpNEIsTUFBVixLQUFxQixJQUFyQixJQUNEMW1CLENBQUMsQ0FBQ2lxQixVQUFGLEdBQWVqcUIsQ0FBQyxDQUFDdlIsT0FBRixDQUFVKzVCLFlBRHhCLElBRUQsQ0FBQ3hvQixDQUFDLENBQUN2UixPQUFGLENBQVVrNUIsUUFGZixFQUUwQjtBQUV0QjNuQixNQUFBQSxDQUFDLENBQUMrcEIsVUFBRixDQUFhalEsV0FBYixDQUF5QixnQkFBekIsRUFBMkM5dkUsSUFBM0MsQ0FBZ0QsZUFBaEQsRUFBaUUsT0FBakU7O0FBQ0FnMkQsTUFBQUEsQ0FBQyxDQUFDOHBCLFVBQUYsQ0FBYWhRLFdBQWIsQ0FBeUIsZ0JBQXpCLEVBQTJDOXZFLElBQTNDLENBQWdELGVBQWhELEVBQWlFLE9BQWpFOztBQUVBLFVBQUlnMkQsQ0FBQyxDQUFDeXBCLFlBQUYsS0FBbUIsQ0FBdkIsRUFBMEI7QUFFdEJ6cEIsUUFBQUEsQ0FBQyxDQUFDK3BCLFVBQUYsQ0FBYXBRLFFBQWIsQ0FBc0IsZ0JBQXRCLEVBQXdDM3ZFLElBQXhDLENBQTZDLGVBQTdDLEVBQThELE1BQTlEOztBQUNBZzJELFFBQUFBLENBQUMsQ0FBQzhwQixVQUFGLENBQWFoUSxXQUFiLENBQXlCLGdCQUF6QixFQUEyQzl2RSxJQUEzQyxDQUFnRCxlQUFoRCxFQUFpRSxPQUFqRTtBQUVILE9BTEQsTUFLTyxJQUFJZzJELENBQUMsQ0FBQ3lwQixZQUFGLElBQWtCenBCLENBQUMsQ0FBQ2lxQixVQUFGLEdBQWVqcUIsQ0FBQyxDQUFDdlIsT0FBRixDQUFVKzVCLFlBQTNDLElBQTJEeG9CLENBQUMsQ0FBQ3ZSLE9BQUYsQ0FBVXU0QixVQUFWLEtBQXlCLEtBQXhGLEVBQStGO0FBRWxHaG5CLFFBQUFBLENBQUMsQ0FBQzhwQixVQUFGLENBQWFuUSxRQUFiLENBQXNCLGdCQUF0QixFQUF3QzN2RSxJQUF4QyxDQUE2QyxlQUE3QyxFQUE4RCxNQUE5RDs7QUFDQWcyRCxRQUFBQSxDQUFDLENBQUMrcEIsVUFBRixDQUFhalEsV0FBYixDQUF5QixnQkFBekIsRUFBMkM5dkUsSUFBM0MsQ0FBZ0QsZUFBaEQsRUFBaUUsT0FBakU7QUFFSCxPQUxNLE1BS0EsSUFBSWcyRCxDQUFDLENBQUN5cEIsWUFBRixJQUFrQnpwQixDQUFDLENBQUNpcUIsVUFBRixHQUFlLENBQWpDLElBQXNDanFCLENBQUMsQ0FBQ3ZSLE9BQUYsQ0FBVXU0QixVQUFWLEtBQXlCLElBQW5FLEVBQXlFO0FBRTVFaG5CLFFBQUFBLENBQUMsQ0FBQzhwQixVQUFGLENBQWFuUSxRQUFiLENBQXNCLGdCQUF0QixFQUF3QzN2RSxJQUF4QyxDQUE2QyxlQUE3QyxFQUE4RCxNQUE5RDs7QUFDQWcyRCxRQUFBQSxDQUFDLENBQUMrcEIsVUFBRixDQUFhalEsV0FBYixDQUF5QixnQkFBekIsRUFBMkM5dkUsSUFBM0MsQ0FBZ0QsZUFBaEQsRUFBaUUsT0FBakU7QUFFSDtBQUVKO0FBRUosR0FqQ0Q7O0FBbUNBbThFLEVBQUFBLEtBQUssQ0FBQ3hqRyxTQUFOLENBQWdCNHJHLFVBQWhCLEdBQTZCLFlBQVc7QUFFcEMsUUFBSXZ1QixDQUFDLEdBQUcsSUFBUjs7QUFFQSxRQUFJQSxDQUFDLENBQUMwcEIsS0FBRixLQUFZLElBQWhCLEVBQXNCO0FBRWxCMXBCLE1BQUFBLENBQUMsQ0FBQzBwQixLQUFGLENBQ0tuekIsSUFETCxDQUNVLElBRFYsRUFFU3VqQixXQUZULENBRXFCLGNBRnJCLEVBR1N4cEYsR0FIVDs7QUFLQTB2RSxNQUFBQSxDQUFDLENBQUMwcEIsS0FBRixDQUNLbnpCLElBREwsQ0FDVSxJQURWLEVBRUtySSxFQUZMLENBRVFqcEUsSUFBSSxDQUFDdWdELEtBQUwsQ0FBV3c2QixDQUFDLENBQUN5cEIsWUFBRixHQUFpQnpwQixDQUFDLENBQUN2UixPQUFGLENBQVVnNkIsY0FBdEMsQ0FGUixFQUdLOU8sUUFITCxDQUdjLGNBSGQ7QUFLSDtBQUVKLEdBbEJEOztBQW9CQXdNLEVBQUFBLEtBQUssQ0FBQ3hqRyxTQUFOLENBQWdCb3dGLFVBQWhCLEdBQTZCLFlBQVc7QUFFcEMsUUFBSS9TLENBQUMsR0FBRyxJQUFSOztBQUVBLFFBQUtBLENBQUMsQ0FBQ3ZSLE9BQUYsQ0FBVXE0QixRQUFmLEVBQTBCO0FBRXRCLFVBQUtqMUYsUUFBUSxDQUFDbXVFLENBQUMsQ0FBQ3BsQyxNQUFILENBQWIsRUFBMEI7QUFFdEJvbEMsUUFBQUEsQ0FBQyxDQUFDN2xFLFdBQUYsR0FBZ0IsSUFBaEI7QUFFSCxPQUpELE1BSU87QUFFSDZsRSxRQUFBQSxDQUFDLENBQUM3bEUsV0FBRixHQUFnQixLQUFoQjtBQUVIO0FBRUo7QUFFSixHQWxCRDs7QUFvQkE2ckYsRUFBQUEsQ0FBQyxDQUFDdjRCLEVBQUYsQ0FBS29nQyxLQUFMLEdBQWEsWUFBVztBQUNwQixRQUFJN3RCLENBQUMsR0FBRyxJQUFSO0FBQUEsUUFDSXdYLEdBQUcsR0FBR3ZrRixTQUFTLENBQUMsQ0FBRCxDQURuQjtBQUFBLFFBRUl5ckQsSUFBSSxHQUFHdDVELEtBQUssQ0FBQ3pDLFNBQU4sQ0FBZ0J3bEIsS0FBaEIsQ0FBc0I1WCxJQUF0QixDQUEyQjBDLFNBQTNCLEVBQXNDLENBQXRDLENBRlg7QUFBQSxRQUdJNUMsQ0FBQyxHQUFHMnZFLENBQUMsQ0FBQ3o0RSxNQUhWO0FBQUEsUUFJSUQsQ0FKSjtBQUFBLFFBS0l3bUUsR0FMSjs7QUFNQSxTQUFLeG1FLENBQUMsR0FBRyxDQUFULEVBQVlBLENBQUMsR0FBRytJLENBQWhCLEVBQW1CL0ksQ0FBQyxFQUFwQixFQUF3QjtBQUNwQixVQUFJLFFBQU9rd0YsR0FBUCxLQUFjLFFBQWQsSUFBMEIsT0FBT0EsR0FBUCxJQUFjLFdBQTVDLEVBQ0l4WCxDQUFDLENBQUMxNEUsQ0FBRCxDQUFELENBQUt1bUcsS0FBTCxHQUFhLElBQUkxSCxLQUFKLENBQVVubUIsQ0FBQyxDQUFDMTRFLENBQUQsQ0FBWCxFQUFnQmt3RixHQUFoQixDQUFiLENBREosS0FHSTFwQixHQUFHLEdBQUdrUyxDQUFDLENBQUMxNEUsQ0FBRCxDQUFELENBQUt1bUcsS0FBTCxDQUFXclcsR0FBWCxFQUFnQjVwRixLQUFoQixDQUFzQm95RSxDQUFDLENBQUMxNEUsQ0FBRCxDQUFELENBQUt1bUcsS0FBM0IsRUFBa0NudkMsSUFBbEMsQ0FBTjtBQUNKLFVBQUksT0FBT29QLEdBQVAsSUFBYyxXQUFsQixFQUErQixPQUFPQSxHQUFQO0FBQ2xDOztBQUNELFdBQU9rUyxDQUFQO0FBQ0gsR0FmRDtBQWlCSCxDQWo3RkMsQ0FBRCIsInNvdXJjZXMiOlsid2VicGFjazovL2Jhc2UtZW52Ly4vbm9kZV9tb2R1bGVzL2dzYXAvRHJhZ2dhYmxlLmpzIiwid2VicGFjazovL2Jhc2UtZW52Ly4vbm9kZV9tb2R1bGVzL2dzYXAvdXRpbHMvcGF0aHMuanMiLCJ3ZWJwYWNrOi8vYmFzZS1lbnYvLi9ub2RlX21vZHVsZXMvZ3NhcC9Nb3Rpb25QYXRoUGx1Z2luLmpzIiwid2VicGFjazovL2Jhc2UtZW52Ly4vbm9kZV9tb2R1bGVzL2dzYXAvT2JzZXJ2ZXIuanMiLCJ3ZWJwYWNrOi8vYmFzZS1lbnYvLi9ub2RlX21vZHVsZXMvZ3NhcC9TY3JvbGxUcmlnZ2VyLmpzIiwid2VicGFjazovL2Jhc2UtZW52Ly4vbm9kZV9tb2R1bGVzL2dzYXAvZ3NhcC1jb3JlLmpzIiwid2VicGFjazovL2Jhc2UtZW52Ly4vbm9kZV9tb2R1bGVzL2dzYXAvQ1NTUGx1Z2luLmpzIiwid2VicGFjazovL2Jhc2UtZW52Ly4vbm9kZV9tb2R1bGVzL2dzYXAvaW5kZXguanMiLCJ3ZWJwYWNrOi8vYmFzZS1lbnYvLi9ub2RlX21vZHVsZXMvZ3NhcC91dGlscy9tYXRyaXguanMiLCJ3ZWJwYWNrOi8vYmFzZS1lbnYvLi9ub2RlX21vZHVsZXMvanF1ZXJ5L2Rpc3QvanF1ZXJ5LmpzIiwid2VicGFjazovL2Jhc2UtZW52Ly4vbm9kZV9tb2R1bGVzL3NsaWNrLWNhcm91c2VsL3NsaWNrL3NsaWNrLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImZ1bmN0aW9uIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZikgeyBpZiAoc2VsZiA9PT0gdm9pZCAwKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gc2VsZjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHNMb29zZShzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MucHJvdG90eXBlKTsgc3ViQ2xhc3MucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gc3ViQ2xhc3M7IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxuLyohXG4gKiBEcmFnZ2FibGUgMy4xMC40XG4gKiBodHRwczovL2dyZWVuc29jay5jb21cbiAqXG4gKiBAbGljZW5zZSBDb3B5cmlnaHQgMjAwOC0yMDIyLCBHcmVlblNvY2suIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBTdWJqZWN0IHRvIHRoZSB0ZXJtcyBhdCBodHRwczovL2dyZWVuc29jay5jb20vc3RhbmRhcmQtbGljZW5zZSBvciBmb3JcbiAqIENsdWIgR3JlZW5Tb2NrIG1lbWJlcnMsIHRoZSBhZ3JlZW1lbnQgaXNzdWVkIHdpdGggdGhhdCBtZW1iZXJzaGlwLlxuICogQGF1dGhvcjogSmFjayBEb3lsZSwgamFja0BncmVlbnNvY2suY29tXG4gKi9cblxuLyogZXNsaW50LWRpc2FibGUgKi9cbmltcG9ydCB7IGdldEdsb2JhbE1hdHJpeCwgTWF0cml4MkQgfSBmcm9tIFwiLi91dGlscy9tYXRyaXguanNcIjtcblxudmFyIGdzYXAsXG4gICAgX3dpbixcbiAgICBfZG9jLFxuICAgIF9kb2NFbGVtZW50LFxuICAgIF9ib2R5LFxuICAgIF90ZW1wRGl2LFxuICAgIF9wbGFjZWhvbGRlckRpdixcbiAgICBfY29yZUluaXR0ZWQsXG4gICAgX2NoZWNrUHJlZml4LFxuICAgIF90b0FycmF5LFxuICAgIF9zdXBwb3J0c1Bhc3NpdmUsXG4gICAgX2lzVG91Y2hEZXZpY2UsXG4gICAgX3RvdWNoRXZlbnRMb29rdXAsXG4gICAgX2RyYWdDb3VudCxcbiAgICBfaXNNdWx0aVRvdWNoaW5nLFxuICAgIF9pc0FuZHJvaWQsXG4gICAgSW5lcnRpYVBsdWdpbixcbiAgICBfZGVmYXVsdEN1cnNvcixcbiAgICBfc3VwcG9ydHNQb2ludGVyLFxuICAgIF93aW5kb3dFeGlzdHMgPSBmdW5jdGlvbiBfd2luZG93RXhpc3RzKCkge1xuICByZXR1cm4gdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIjtcbn0sXG4gICAgX2dldEdTQVAgPSBmdW5jdGlvbiBfZ2V0R1NBUCgpIHtcbiAgcmV0dXJuIGdzYXAgfHwgX3dpbmRvd0V4aXN0cygpICYmIChnc2FwID0gd2luZG93LmdzYXApICYmIGdzYXAucmVnaXN0ZXJQbHVnaW4gJiYgZ3NhcDtcbn0sXG4gICAgX2lzRnVuY3Rpb24gPSBmdW5jdGlvbiBfaXNGdW5jdGlvbih2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSBcImZ1bmN0aW9uXCI7XG59LFxuICAgIF9pc09iamVjdCA9IGZ1bmN0aW9uIF9pc09iamVjdCh2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiO1xufSxcbiAgICBfaXNVbmRlZmluZWQgPSBmdW5jdGlvbiBfaXNVbmRlZmluZWQodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gXCJ1bmRlZmluZWRcIjtcbn0sXG4gICAgX2VtcHR5RnVuYyA9IGZ1bmN0aW9uIF9lbXB0eUZ1bmMoKSB7XG4gIHJldHVybiBmYWxzZTtcbn0sXG4gICAgX3RyYW5zZm9ybVByb3AgPSBcInRyYW5zZm9ybVwiLFxuICAgIF90cmFuc2Zvcm1PcmlnaW5Qcm9wID0gXCJ0cmFuc2Zvcm1PcmlnaW5cIixcbiAgICBfcm91bmQgPSBmdW5jdGlvbiBfcm91bmQodmFsdWUpIHtcbiAgcmV0dXJuIE1hdGgucm91bmQodmFsdWUgKiAxMDAwMCkgLyAxMDAwMDtcbn0sXG4gICAgX2lzQXJyYXkgPSBBcnJheS5pc0FycmF5LFxuICAgIF9jcmVhdGVFbGVtZW50ID0gZnVuY3Rpb24gX2NyZWF0ZUVsZW1lbnQodHlwZSwgbnMpIHtcbiAgdmFyIGUgPSBfZG9jLmNyZWF0ZUVsZW1lbnROUyA/IF9kb2MuY3JlYXRlRWxlbWVudE5TKChucyB8fCBcImh0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWxcIikucmVwbGFjZSgvXmh0dHBzLywgXCJodHRwXCIpLCB0eXBlKSA6IF9kb2MuY3JlYXRlRWxlbWVudCh0eXBlKTsgLy9zb21lIHNlcnZlcnMgc3dhcCBpbiBodHRwcyBmb3IgaHR0cCBpbiB0aGUgbmFtZXNwYWNlIHdoaWNoIGNhbiBicmVhayB0aGluZ3MsIG1ha2luZyBcInN0eWxlXCIgaW5hY2Nlc3NpYmxlLlxuXG4gIHJldHVybiBlLnN0eWxlID8gZSA6IF9kb2MuY3JlYXRlRWxlbWVudCh0eXBlKTsgLy9zb21lIGVudmlyb25tZW50cyB3b24ndCBhbGxvdyBhY2Nlc3MgdG8gdGhlIGVsZW1lbnQncyBzdHlsZSB3aGVuIGNyZWF0ZWQgd2l0aCBhIG5hbWVzcGFjZSBpbiB3aGljaCBjYXNlIHdlIGRlZmF1bHQgdG8gdGhlIHN0YW5kYXJkIGNyZWF0ZUVsZW1lbnQoKSB0byB3b3JrIGFyb3VuZCB0aGUgaXNzdWUuIEFsc28gbm90ZSB0aGF0IHdoZW4gR1NBUCBpcyBlbWJlZGRlZCBkaXJlY3RseSBpbnNpZGUgYW4gU1ZHIGZpbGUsIGNyZWF0ZUVsZW1lbnQoKSB3b24ndCBhbGxvdyBhY2Nlc3MgdG8gdGhlIHN0eWxlIG9iamVjdCBpbiBGaXJlZm94IChzZWUgaHR0cHM6Ly9ncmVlbnNvY2suY29tL2ZvcnVtcy90b3BpYy8yMDIxNS1wcm9ibGVtLXVzaW5nLXR3ZWVubWF4LWluLXN0YW5kYWxvbmUtc2VsZi1jb250YWluaW5nLXN2Zy1maWxlLWVyci1jYW5ub3Qtc2V0LXByb3BlcnR5LWNzc3RleHQtb2YtdW5kZWZpbmVkLykuXG59LFxuICAgIF9SQUQyREVHID0gMTgwIC8gTWF0aC5QSSxcbiAgICBfYmlnTnVtID0gMWUyMCxcbiAgICBfaWRlbnRpdHlNYXRyaXggPSBuZXcgTWF0cml4MkQoKSxcbiAgICBfZ2V0VGltZSA9IERhdGUubm93IHx8IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xufSxcbiAgICBfcmVuZGVyUXVldWUgPSBbXSxcbiAgICBfbG9va3VwID0ge30sXG4gICAgLy93aGVuIGEgRHJhZ2dhYmxlIGlzIGNyZWF0ZWQsIHRoZSB0YXJnZXQgZ2V0cyBhIHVuaXF1ZSBfZ3NEcmFnSUQgcHJvcGVydHkgdGhhdCBhbGxvd3MgZ2V0cyBhc3NvY2lhdGVkIHdpdGggdGhlIERyYWdnYWJsZSBpbnN0YW5jZSBmb3IgcXVpY2sgbG9va3VwcyBpbiBEcmFnZ2FibGUuZ2V0KCkuIFRoaXMgYXZvaWRzIGNpcmN1bGFyIHJlZmVyZW5jZXMgdGhhdCBjb3VsZCBjYXVzZSBnYyBwcm9ibGVtcy5cbl9sb29rdXBDb3VudCA9IDAsXG4gICAgX2NsaWNrYWJsZVRhZ0V4cCA9IC9eKD86YXxpbnB1dHx0ZXh0YXJlYXxidXR0b258c2VsZWN0KSQvaSxcbiAgICBfbGFzdERyYWdUaW1lID0gMCxcbiAgICBfdGVtcDEgPSB7fSxcbiAgICAvLyBhIHNpbXBsZSBvYmplY3Qgd2UgcmV1c2UgYW5kIHBvcHVsYXRlICh1c3VhbGx5IHgveSBwcm9wZXJ0aWVzKSB0byBjb25zZXJ2ZSBtZW1vcnkgYW5kIGltcHJvdmUgcGVyZm9ybWFuY2UuXG5fd2luZG93UHJveHkgPSB7fSxcbiAgICAvL21lbW9yeS9wZXJmb3JtYW5jZSBvcHRpbWl6YXRpb24gLSB3ZSByZXVzZSB0aGlzIG9iamVjdCBkdXJpbmcgYXV0b1Njcm9sbCB0byBzdG9yZSB3aW5kb3ctcmVsYXRlZCBib3VuZHMvb2Zmc2V0cy5cbl9jb3B5ID0gZnVuY3Rpb24gX2NvcHkob2JqLCBmYWN0b3IpIHtcbiAgdmFyIGNvcHkgPSB7fSxcbiAgICAgIHA7XG5cbiAgZm9yIChwIGluIG9iaikge1xuICAgIGNvcHlbcF0gPSBmYWN0b3IgPyBvYmpbcF0gKiBmYWN0b3IgOiBvYmpbcF07XG4gIH1cblxuICByZXR1cm4gY29weTtcbn0sXG4gICAgX2V4dGVuZCA9IGZ1bmN0aW9uIF9leHRlbmQob2JqLCBkZWZhdWx0cykge1xuICBmb3IgKHZhciBwIGluIGRlZmF1bHRzKSB7XG4gICAgaWYgKCEocCBpbiBvYmopKSB7XG4gICAgICBvYmpbcF0gPSBkZWZhdWx0c1twXTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gb2JqO1xufSxcbiAgICBfc2V0VG91Y2hBY3Rpb25Gb3JBbGxEZXNjZW5kYW50cyA9IGZ1bmN0aW9uIF9zZXRUb3VjaEFjdGlvbkZvckFsbERlc2NlbmRhbnRzKGVsZW1lbnRzLCB2YWx1ZSkge1xuICB2YXIgaSA9IGVsZW1lbnRzLmxlbmd0aCxcbiAgICAgIGNoaWxkcmVuO1xuXG4gIHdoaWxlIChpLS0pIHtcbiAgICB2YWx1ZSA/IGVsZW1lbnRzW2ldLnN0eWxlLnRvdWNoQWN0aW9uID0gdmFsdWUgOiBlbGVtZW50c1tpXS5zdHlsZS5yZW1vdmVQcm9wZXJ0eShcInRvdWNoLWFjdGlvblwiKTtcbiAgICBjaGlsZHJlbiA9IGVsZW1lbnRzW2ldLmNoaWxkcmVuO1xuICAgIGNoaWxkcmVuICYmIGNoaWxkcmVuLmxlbmd0aCAmJiBfc2V0VG91Y2hBY3Rpb25Gb3JBbGxEZXNjZW5kYW50cyhjaGlsZHJlbiwgdmFsdWUpO1xuICB9XG59LFxuICAgIF9yZW5kZXJRdWV1ZVRpY2sgPSBmdW5jdGlvbiBfcmVuZGVyUXVldWVUaWNrKCkge1xuICByZXR1cm4gX3JlbmRlclF1ZXVlLmZvckVhY2goZnVuY3Rpb24gKGZ1bmMpIHtcbiAgICByZXR1cm4gZnVuYygpO1xuICB9KTtcbn0sXG4gICAgX2FkZFRvUmVuZGVyUXVldWUgPSBmdW5jdGlvbiBfYWRkVG9SZW5kZXJRdWV1ZShmdW5jKSB7XG4gIF9yZW5kZXJRdWV1ZS5wdXNoKGZ1bmMpO1xuXG4gIGlmIChfcmVuZGVyUXVldWUubGVuZ3RoID09PSAxKSB7XG4gICAgZ3NhcC50aWNrZXIuYWRkKF9yZW5kZXJRdWV1ZVRpY2spO1xuICB9XG59LFxuICAgIF9yZW5kZXJRdWV1ZVRpbWVvdXQgPSBmdW5jdGlvbiBfcmVuZGVyUXVldWVUaW1lb3V0KCkge1xuICByZXR1cm4gIV9yZW5kZXJRdWV1ZS5sZW5ndGggJiYgZ3NhcC50aWNrZXIucmVtb3ZlKF9yZW5kZXJRdWV1ZVRpY2spO1xufSxcbiAgICBfcmVtb3ZlRnJvbVJlbmRlclF1ZXVlID0gZnVuY3Rpb24gX3JlbW92ZUZyb21SZW5kZXJRdWV1ZShmdW5jKSB7XG4gIHZhciBpID0gX3JlbmRlclF1ZXVlLmxlbmd0aDtcblxuICB3aGlsZSAoaS0tKSB7XG4gICAgaWYgKF9yZW5kZXJRdWV1ZVtpXSA9PT0gZnVuYykge1xuICAgICAgX3JlbmRlclF1ZXVlLnNwbGljZShpLCAxKTtcbiAgICB9XG4gIH1cblxuICBnc2FwLnRvKF9yZW5kZXJRdWV1ZVRpbWVvdXQsIHtcbiAgICBvdmVyd3JpdGU6IHRydWUsXG4gICAgZGVsYXk6IDE1LFxuICAgIGR1cmF0aW9uOiAwLFxuICAgIG9uQ29tcGxldGU6IF9yZW5kZXJRdWV1ZVRpbWVvdXQsXG4gICAgZGF0YTogXCJfZHJhZ2dhYmxlXCJcbiAgfSk7IC8vcmVtb3ZlIHRoZSBcInRpY2tcIiBsaXN0ZW5lciBvbmx5IGFmdGVyIHRoZSByZW5kZXIgcXVldWUgaXMgZW1wdHkgZm9yIDE1IHNlY29uZHMgKHRvIGltcHJvdmUgcGVyZm9ybWFuY2UpLiBBZGRpbmcvcmVtb3ZpbmcgaXQgY29uc3RhbnRseSBmb3IgZXZlcnkgY2xpY2svdG91Y2ggd291bGRuJ3QgZGVsaXZlciBvcHRpbWFsIHNwZWVkLCBhbmQgd2UgYWxzbyBkb24ndCB3YW50IHRoZSB0aWNrZXIgdG8ga2VlcCBjYWxsaW5nIHRoZSByZW5kZXIgbWV0aG9kIHdoZW4gdGhpbmdzIGFyZSBpZGxlIGZvciBsb25nIHBlcmlvZHMgb2YgdGltZSAod2Ugd2FudCB0byBpbXByb3ZlIGJhdHRlcnkgbGlmZSBvbiBtb2JpbGUgZGV2aWNlcykuXG59LFxuICAgIF9zZXREZWZhdWx0cyA9IGZ1bmN0aW9uIF9zZXREZWZhdWx0cyhvYmosIGRlZmF1bHRzKSB7XG4gIGZvciAodmFyIHAgaW4gZGVmYXVsdHMpIHtcbiAgICBpZiAoIShwIGluIG9iaikpIHtcbiAgICAgIG9ialtwXSA9IGRlZmF1bHRzW3BdO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBvYmo7XG59LFxuICAgIF9hZGRMaXN0ZW5lciA9IGZ1bmN0aW9uIF9hZGRMaXN0ZW5lcihlbGVtZW50LCB0eXBlLCBmdW5jLCBjYXB0dXJlKSB7XG4gIGlmIChlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIpIHtcbiAgICB2YXIgdG91Y2hUeXBlID0gX3RvdWNoRXZlbnRMb29rdXBbdHlwZV07XG4gICAgY2FwdHVyZSA9IGNhcHR1cmUgfHwgKF9zdXBwb3J0c1Bhc3NpdmUgPyB7XG4gICAgICBwYXNzaXZlOiBmYWxzZVxuICAgIH0gOiBudWxsKTtcbiAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIodG91Y2hUeXBlIHx8IHR5cGUsIGZ1bmMsIGNhcHR1cmUpO1xuICAgIHRvdWNoVHlwZSAmJiB0eXBlICE9PSB0b3VjaFR5cGUgJiYgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKHR5cGUsIGZ1bmMsIGNhcHR1cmUpOyAvL3NvbWUgYnJvd3NlcnMgYWN0dWFsbHkgc3VwcG9ydCBib3RoLCBzbyBtdXN0IHdlLiBCdXQgcG9pbnRlciBldmVudHMgY292ZXIgYWxsLlxuICB9XG59LFxuICAgIF9yZW1vdmVMaXN0ZW5lciA9IGZ1bmN0aW9uIF9yZW1vdmVMaXN0ZW5lcihlbGVtZW50LCB0eXBlLCBmdW5jKSB7XG4gIGlmIChlbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIpIHtcbiAgICB2YXIgdG91Y2hUeXBlID0gX3RvdWNoRXZlbnRMb29rdXBbdHlwZV07XG4gICAgZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKHRvdWNoVHlwZSB8fCB0eXBlLCBmdW5jKTtcbiAgICB0b3VjaFR5cGUgJiYgdHlwZSAhPT0gdG91Y2hUeXBlICYmIGVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcih0eXBlLCBmdW5jKTtcbiAgfVxufSxcbiAgICBfcHJldmVudERlZmF1bHQgPSBmdW5jdGlvbiBfcHJldmVudERlZmF1bHQoZXZlbnQpIHtcbiAgZXZlbnQucHJldmVudERlZmF1bHQgJiYgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgZXZlbnQucHJldmVudE1hbmlwdWxhdGlvbiAmJiBldmVudC5wcmV2ZW50TWFuaXB1bGF0aW9uKCk7IC8vZm9yIHNvbWUgTWljcm9zb2Z0IGJyb3dzZXJzXG59LFxuICAgIF9oYXNUb3VjaElEID0gZnVuY3Rpb24gX2hhc1RvdWNoSUQobGlzdCwgSUQpIHtcbiAgdmFyIGkgPSBsaXN0Lmxlbmd0aDtcblxuICB3aGlsZSAoaS0tKSB7XG4gICAgaWYgKGxpc3RbaV0uaWRlbnRpZmllciA9PT0gSUQpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxufSxcbiAgICBfb25NdWx0aVRvdWNoRG9jdW1lbnRFbmQgPSBmdW5jdGlvbiBfb25NdWx0aVRvdWNoRG9jdW1lbnRFbmQoZXZlbnQpIHtcbiAgX2lzTXVsdGlUb3VjaGluZyA9IGV2ZW50LnRvdWNoZXMgJiYgX2RyYWdDb3VudCA8IGV2ZW50LnRvdWNoZXMubGVuZ3RoO1xuXG4gIF9yZW1vdmVMaXN0ZW5lcihldmVudC50YXJnZXQsIFwidG91Y2hlbmRcIiwgX29uTXVsdGlUb3VjaERvY3VtZW50RW5kKTtcbn0sXG4gICAgX29uTXVsdGlUb3VjaERvY3VtZW50ID0gZnVuY3Rpb24gX29uTXVsdGlUb3VjaERvY3VtZW50KGV2ZW50KSB7XG4gIF9pc011bHRpVG91Y2hpbmcgPSBldmVudC50b3VjaGVzICYmIF9kcmFnQ291bnQgPCBldmVudC50b3VjaGVzLmxlbmd0aDtcblxuICBfYWRkTGlzdGVuZXIoZXZlbnQudGFyZ2V0LCBcInRvdWNoZW5kXCIsIF9vbk11bHRpVG91Y2hEb2N1bWVudEVuZCk7XG59LFxuICAgIF9nZXREb2NTY3JvbGxUb3AgPSBmdW5jdGlvbiBfZ2V0RG9jU2Nyb2xsVG9wKGRvYykge1xuICByZXR1cm4gX3dpbi5wYWdlWU9mZnNldCB8fCBkb2Muc2Nyb2xsVG9wIHx8IGRvYy5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsVG9wIHx8IGRvYy5ib2R5LnNjcm9sbFRvcCB8fCAwO1xufSxcbiAgICBfZ2V0RG9jU2Nyb2xsTGVmdCA9IGZ1bmN0aW9uIF9nZXREb2NTY3JvbGxMZWZ0KGRvYykge1xuICByZXR1cm4gX3dpbi5wYWdlWE9mZnNldCB8fCBkb2Muc2Nyb2xsTGVmdCB8fCBkb2MuZG9jdW1lbnRFbGVtZW50LnNjcm9sbExlZnQgfHwgZG9jLmJvZHkuc2Nyb2xsTGVmdCB8fCAwO1xufSxcbiAgICBfYWRkU2Nyb2xsTGlzdGVuZXIgPSBmdW5jdGlvbiBfYWRkU2Nyb2xsTGlzdGVuZXIoZSwgY2FsbGJhY2spIHtcbiAgX2FkZExpc3RlbmVyKGUsIFwic2Nyb2xsXCIsIGNhbGxiYWNrKTtcblxuICBpZiAoIV9pc1Jvb3QoZS5wYXJlbnROb2RlKSkge1xuICAgIF9hZGRTY3JvbGxMaXN0ZW5lcihlLnBhcmVudE5vZGUsIGNhbGxiYWNrKTtcbiAgfVxufSxcbiAgICBfcmVtb3ZlU2Nyb2xsTGlzdGVuZXIgPSBmdW5jdGlvbiBfcmVtb3ZlU2Nyb2xsTGlzdGVuZXIoZSwgY2FsbGJhY2spIHtcbiAgX3JlbW92ZUxpc3RlbmVyKGUsIFwic2Nyb2xsXCIsIGNhbGxiYWNrKTtcblxuICBpZiAoIV9pc1Jvb3QoZS5wYXJlbnROb2RlKSkge1xuICAgIF9yZW1vdmVTY3JvbGxMaXN0ZW5lcihlLnBhcmVudE5vZGUsIGNhbGxiYWNrKTtcbiAgfVxufSxcbiAgICBfaXNSb290ID0gZnVuY3Rpb24gX2lzUm9vdChlKSB7XG4gIHJldHVybiAhISghZSB8fCBlID09PSBfZG9jRWxlbWVudCB8fCBlLm5vZGVUeXBlID09PSA5IHx8IGUgPT09IF9kb2MuYm9keSB8fCBlID09PSBfd2luIHx8ICFlLm5vZGVUeXBlIHx8ICFlLnBhcmVudE5vZGUpO1xufSxcbiAgICBfZ2V0TWF4U2Nyb2xsID0gZnVuY3Rpb24gX2dldE1heFNjcm9sbChlbGVtZW50LCBheGlzKSB7XG4gIHZhciBkaW0gPSBheGlzID09PSBcInhcIiA/IFwiV2lkdGhcIiA6IFwiSGVpZ2h0XCIsXG4gICAgICBzY3JvbGwgPSBcInNjcm9sbFwiICsgZGltLFxuICAgICAgY2xpZW50ID0gXCJjbGllbnRcIiArIGRpbTtcbiAgcmV0dXJuIE1hdGgubWF4KDAsIF9pc1Jvb3QoZWxlbWVudCkgPyBNYXRoLm1heChfZG9jRWxlbWVudFtzY3JvbGxdLCBfYm9keVtzY3JvbGxdKSAtIChfd2luW1wiaW5uZXJcIiArIGRpbV0gfHwgX2RvY0VsZW1lbnRbY2xpZW50XSB8fCBfYm9keVtjbGllbnRdKSA6IGVsZW1lbnRbc2Nyb2xsXSAtIGVsZW1lbnRbY2xpZW50XSk7XG59LFxuICAgIF9yZWNvcmRNYXhTY3JvbGxzID0gZnVuY3Rpb24gX3JlY29yZE1heFNjcm9sbHMoZSwgc2tpcEN1cnJlbnQpIHtcbiAgLy9yZWNvcmRzIF9nc01heFNjcm9sbFggYW5kIF9nc01heFNjcm9sbFkgcHJvcGVydGllcyBmb3IgdGhlIGVsZW1lbnQgYW5kIGFsbCBhbmNlc3RvcnMgdXAgdGhlIGNoYWluIHNvIHRoYXQgd2UgY2FuIGNhcCBpdCwgb3RoZXJ3aXNlIGRyYWdnaW5nIGJleW9uZCB0aGUgZWRnZXMgd2l0aCBhdXRvU2Nyb2xsIG9uIGNhbiBlbmRsZXNzbHkgc2Nyb2xsLlxuICB2YXIgeCA9IF9nZXRNYXhTY3JvbGwoZSwgXCJ4XCIpLFxuICAgICAgeSA9IF9nZXRNYXhTY3JvbGwoZSwgXCJ5XCIpO1xuXG4gIGlmIChfaXNSb290KGUpKSB7XG4gICAgZSA9IF93aW5kb3dQcm94eTtcbiAgfSBlbHNlIHtcbiAgICBfcmVjb3JkTWF4U2Nyb2xscyhlLnBhcmVudE5vZGUsIHNraXBDdXJyZW50KTtcbiAgfVxuXG4gIGUuX2dzTWF4U2Nyb2xsWCA9IHg7XG4gIGUuX2dzTWF4U2Nyb2xsWSA9IHk7XG5cbiAgaWYgKCFza2lwQ3VycmVudCkge1xuICAgIGUuX2dzU2Nyb2xsWCA9IGUuc2Nyb2xsTGVmdCB8fCAwO1xuICAgIGUuX2dzU2Nyb2xsWSA9IGUuc2Nyb2xsVG9wIHx8IDA7XG4gIH1cbn0sXG4gICAgX3NldFN0eWxlID0gZnVuY3Rpb24gX3NldFN0eWxlKGVsZW1lbnQsIHByb3BlcnR5LCB2YWx1ZSkge1xuICB2YXIgc3R5bGUgPSBlbGVtZW50LnN0eWxlO1xuXG4gIGlmICghc3R5bGUpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAoX2lzVW5kZWZpbmVkKHN0eWxlW3Byb3BlcnR5XSkpIHtcbiAgICBwcm9wZXJ0eSA9IF9jaGVja1ByZWZpeChwcm9wZXJ0eSwgZWxlbWVudCkgfHwgcHJvcGVydHk7XG4gIH1cblxuICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgIHN0eWxlLnJlbW92ZVByb3BlcnR5ICYmIHN0eWxlLnJlbW92ZVByb3BlcnR5KHByb3BlcnR5LnJlcGxhY2UoLyhbQS1aXSkvZywgXCItJDFcIikudG9Mb3dlckNhc2UoKSk7XG4gIH0gZWxzZSB7XG4gICAgc3R5bGVbcHJvcGVydHldID0gdmFsdWU7XG4gIH1cbn0sXG4gICAgX2dldENvbXB1dGVkU3R5bGUgPSBmdW5jdGlvbiBfZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KSB7XG4gIHJldHVybiBfd2luLmdldENvbXB1dGVkU3R5bGUoZWxlbWVudCBpbnN0YW5jZW9mIEVsZW1lbnQgPyBlbGVtZW50IDogZWxlbWVudC5ob3N0IHx8IChlbGVtZW50LnBhcmVudE5vZGUgfHwge30pLmhvc3QgfHwgZWxlbWVudCk7XG59LFxuICAgIC8vdGhlIFwiaG9zdFwiIHN0dWZmIGhlbHBzIHRvIGFjY29tbW9kYXRlIFNoYWRvd0RvbSBvYmplY3RzLlxuX3RlbXBSZWN0ID0ge30sXG4gICAgLy9yZXVzZSB0byByZWR1Y2UgZ2FyYmFnZSBjb2xsZWN0aW9uIHRhc2tzXG5fcGFyc2VSZWN0ID0gZnVuY3Rpb24gX3BhcnNlUmVjdChlKSB7XG4gIC8vYWNjZXB0cyBhIERPTSBlbGVtZW50LCBhIG1vdXNlIGV2ZW50LCBvciBhIHJlY3RhbmdsZSBvYmplY3QgYW5kIHJldHVybnMgdGhlIGNvcnJlc3BvbmRpbmcgcmVjdGFuZ2xlIHdpdGggbGVmdCwgcmlnaHQsIHdpZHRoLCBoZWlnaHQsIHRvcCwgYW5kIGJvdHRvbSBwcm9wZXJ0aWVzXG4gIGlmIChlID09PSBfd2luKSB7XG4gICAgX3RlbXBSZWN0LmxlZnQgPSBfdGVtcFJlY3QudG9wID0gMDtcbiAgICBfdGVtcFJlY3Qud2lkdGggPSBfdGVtcFJlY3QucmlnaHQgPSBfZG9jRWxlbWVudC5jbGllbnRXaWR0aCB8fCBlLmlubmVyV2lkdGggfHwgX2JvZHkuY2xpZW50V2lkdGggfHwgMDtcbiAgICBfdGVtcFJlY3QuaGVpZ2h0ID0gX3RlbXBSZWN0LmJvdHRvbSA9IChlLmlubmVySGVpZ2h0IHx8IDApIC0gMjAgPCBfZG9jRWxlbWVudC5jbGllbnRIZWlnaHQgPyBfZG9jRWxlbWVudC5jbGllbnRIZWlnaHQgOiBlLmlubmVySGVpZ2h0IHx8IF9ib2R5LmNsaWVudEhlaWdodCB8fCAwO1xuICAgIHJldHVybiBfdGVtcFJlY3Q7XG4gIH1cblxuICB2YXIgZG9jID0gZS5vd25lckRvY3VtZW50IHx8IF9kb2MsXG4gICAgICByID0gIV9pc1VuZGVmaW5lZChlLnBhZ2VYKSA/IHtcbiAgICBsZWZ0OiBlLnBhZ2VYIC0gX2dldERvY1Njcm9sbExlZnQoZG9jKSxcbiAgICB0b3A6IGUucGFnZVkgLSBfZ2V0RG9jU2Nyb2xsVG9wKGRvYyksXG4gICAgcmlnaHQ6IGUucGFnZVggLSBfZ2V0RG9jU2Nyb2xsTGVmdChkb2MpICsgMSxcbiAgICBib3R0b206IGUucGFnZVkgLSBfZ2V0RG9jU2Nyb2xsVG9wKGRvYykgKyAxXG4gIH0gOiAhZS5ub2RlVHlwZSAmJiAhX2lzVW5kZWZpbmVkKGUubGVmdCkgJiYgIV9pc1VuZGVmaW5lZChlLnRvcCkgPyBlIDogX3RvQXJyYXkoZSlbMF0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG5cbiAgaWYgKF9pc1VuZGVmaW5lZChyLnJpZ2h0KSAmJiAhX2lzVW5kZWZpbmVkKHIud2lkdGgpKSB7XG4gICAgci5yaWdodCA9IHIubGVmdCArIHIud2lkdGg7XG4gICAgci5ib3R0b20gPSByLnRvcCArIHIuaGVpZ2h0O1xuICB9IGVsc2UgaWYgKF9pc1VuZGVmaW5lZChyLndpZHRoKSkge1xuICAgIC8vc29tZSBicm93c2VycyBkb24ndCBpbmNsdWRlIHdpZHRoIGFuZCBoZWlnaHQgcHJvcGVydGllcy4gV2UgY2FuJ3QganVzdCBzZXQgdGhlbSBkaXJlY3RseSBvbiByIGJlY2F1c2Ugc29tZSBicm93c2VycyB0aHJvdyBlcnJvcnMsIHNvIGNyZWF0ZSBhIG5ldyBnZW5lcmljIG9iamVjdC5cbiAgICByID0ge1xuICAgICAgd2lkdGg6IHIucmlnaHQgLSByLmxlZnQsXG4gICAgICBoZWlnaHQ6IHIuYm90dG9tIC0gci50b3AsXG4gICAgICByaWdodDogci5yaWdodCxcbiAgICAgIGxlZnQ6IHIubGVmdCxcbiAgICAgIGJvdHRvbTogci5ib3R0b20sXG4gICAgICB0b3A6IHIudG9wXG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiByO1xufSxcbiAgICBfZGlzcGF0Y2hFdmVudCA9IGZ1bmN0aW9uIF9kaXNwYXRjaEV2ZW50KHRhcmdldCwgdHlwZSwgY2FsbGJhY2tOYW1lKSB7XG4gIHZhciB2YXJzID0gdGFyZ2V0LnZhcnMsXG4gICAgICBjYWxsYmFjayA9IHZhcnNbY2FsbGJhY2tOYW1lXSxcbiAgICAgIGxpc3RlbmVycyA9IHRhcmdldC5fbGlzdGVuZXJzW3R5cGVdLFxuICAgICAgcmVzdWx0O1xuXG4gIGlmIChfaXNGdW5jdGlvbihjYWxsYmFjaykpIHtcbiAgICByZXN1bHQgPSBjYWxsYmFjay5hcHBseSh2YXJzLmNhbGxiYWNrU2NvcGUgfHwgdGFyZ2V0LCB2YXJzW2NhbGxiYWNrTmFtZSArIFwiUGFyYW1zXCJdIHx8IFt0YXJnZXQucG9pbnRlckV2ZW50XSk7XG4gIH1cblxuICBpZiAobGlzdGVuZXJzICYmIHRhcmdldC5kaXNwYXRjaEV2ZW50KHR5cGUpID09PSBmYWxzZSkge1xuICAgIHJlc3VsdCA9IGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn0sXG4gICAgX2dldEJvdW5kcyA9IGZ1bmN0aW9uIF9nZXRCb3VuZHModGFyZ2V0LCBjb250ZXh0KSB7XG4gIC8vYWNjZXB0cyBhbnkgb2YgdGhlIGZvbGxvd2luZzogYSBET00gZWxlbWVudCwgalF1ZXJ5IG9iamVjdCwgc2VsZWN0b3IgdGV4dCwgb3IgYW4gb2JqZWN0IGRlZmluaW5nIGJvdW5kcyBhcyB7dG9wLCBsZWZ0LCB3aWR0aCwgaGVpZ2h0fSBvciB7bWluWCwgbWF4WCwgbWluWSwgbWF4WX0uIFJldHVybnMgYW4gb2JqZWN0IHdpdGggbGVmdCwgdG9wLCB3aWR0aCwgYW5kIGhlaWdodCBwcm9wZXJ0aWVzLlxuICB2YXIgZSA9IF90b0FycmF5KHRhcmdldClbMF0sXG4gICAgICB0b3AsXG4gICAgICBsZWZ0LFxuICAgICAgb2Zmc2V0O1xuXG4gIGlmICghZS5ub2RlVHlwZSAmJiBlICE9PSBfd2luKSB7XG4gICAgaWYgKCFfaXNVbmRlZmluZWQodGFyZ2V0LmxlZnQpKSB7XG4gICAgICBvZmZzZXQgPSB7XG4gICAgICAgIHg6IDAsXG4gICAgICAgIHk6IDBcbiAgICAgIH07IC8vX2dldE9mZnNldFRyYW5zZm9ybU9yaWdpbihjb250ZXh0KTsgLy90aGUgYm91bmRzIHNob3VsZCBiZSByZWxhdGl2ZSB0byB0aGUgb3JpZ2luXG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGxlZnQ6IHRhcmdldC5sZWZ0IC0gb2Zmc2V0LngsXG4gICAgICAgIHRvcDogdGFyZ2V0LnRvcCAtIG9mZnNldC55LFxuICAgICAgICB3aWR0aDogdGFyZ2V0LndpZHRoLFxuICAgICAgICBoZWlnaHQ6IHRhcmdldC5oZWlnaHRcbiAgICAgIH07XG4gICAgfVxuXG4gICAgbGVmdCA9IHRhcmdldC5taW4gfHwgdGFyZ2V0Lm1pblggfHwgdGFyZ2V0Lm1pblJvdGF0aW9uIHx8IDA7XG4gICAgdG9wID0gdGFyZ2V0Lm1pbiB8fCB0YXJnZXQubWluWSB8fCAwO1xuICAgIHJldHVybiB7XG4gICAgICBsZWZ0OiBsZWZ0LFxuICAgICAgdG9wOiB0b3AsXG4gICAgICB3aWR0aDogKHRhcmdldC5tYXggfHwgdGFyZ2V0Lm1heFggfHwgdGFyZ2V0Lm1heFJvdGF0aW9uIHx8IDApIC0gbGVmdCxcbiAgICAgIGhlaWdodDogKHRhcmdldC5tYXggfHwgdGFyZ2V0Lm1heFkgfHwgMCkgLSB0b3BcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIF9nZXRFbGVtZW50Qm91bmRzKGUsIGNvbnRleHQpO1xufSxcbiAgICBfcG9pbnQxID0ge30sXG4gICAgLy93ZSByZXVzZSB0byBtaW5pbWl6ZSBnYXJiYWdlIGNvbGxlY3Rpb24gdGFza3MuXG5fZ2V0RWxlbWVudEJvdW5kcyA9IGZ1bmN0aW9uIF9nZXRFbGVtZW50Qm91bmRzKGVsZW1lbnQsIGNvbnRleHQpIHtcbiAgY29udGV4dCA9IF90b0FycmF5KGNvbnRleHQpWzBdO1xuICB2YXIgaXNTVkcgPSBlbGVtZW50LmdldEJCb3ggJiYgZWxlbWVudC5vd25lclNWR0VsZW1lbnQsXG4gICAgICBkb2MgPSBlbGVtZW50Lm93bmVyRG9jdW1lbnQgfHwgX2RvYyxcbiAgICAgIGxlZnQsXG4gICAgICByaWdodCxcbiAgICAgIHRvcCxcbiAgICAgIGJvdHRvbSxcbiAgICAgIG1hdHJpeCxcbiAgICAgIHAxLFxuICAgICAgcDIsXG4gICAgICBwMyxcbiAgICAgIHA0LFxuICAgICAgYmJveCxcbiAgICAgIHdpZHRoLFxuICAgICAgaGVpZ2h0LFxuICAgICAgY3MsXG4gICAgICBjb250ZXh0UGFyZW50O1xuXG4gIGlmIChlbGVtZW50ID09PSBfd2luKSB7XG4gICAgdG9wID0gX2dldERvY1Njcm9sbFRvcChkb2MpO1xuICAgIGxlZnQgPSBfZ2V0RG9jU2Nyb2xsTGVmdChkb2MpO1xuICAgIHJpZ2h0ID0gbGVmdCArIChkb2MuZG9jdW1lbnRFbGVtZW50LmNsaWVudFdpZHRoIHx8IGVsZW1lbnQuaW5uZXJXaWR0aCB8fCBkb2MuYm9keS5jbGllbnRXaWR0aCB8fCAwKTtcbiAgICBib3R0b20gPSB0b3AgKyAoKGVsZW1lbnQuaW5uZXJIZWlnaHQgfHwgMCkgLSAyMCA8IGRvYy5kb2N1bWVudEVsZW1lbnQuY2xpZW50SGVpZ2h0ID8gZG9jLmRvY3VtZW50RWxlbWVudC5jbGllbnRIZWlnaHQgOiBlbGVtZW50LmlubmVySGVpZ2h0IHx8IGRvYy5ib2R5LmNsaWVudEhlaWdodCB8fCAwKTsgLy9zb21lIGJyb3dzZXJzIChsaWtlIEZpcmVmb3gpIGlnbm9yZSBhYnNvbHV0ZWx5IHBvc2l0aW9uZWQgZWxlbWVudHMsIGFuZCBjb2xsYXBzZSB0aGUgaGVpZ2h0IG9mIHRoZSBkb2N1bWVudEVsZW1lbnQsIHNvIGl0IGNvdWxkIGJlIDhweCwgZm9yIGV4YW1wbGUsIGlmIHlvdSBoYXZlIGp1c3QgYW4gYWJzb2x1dGVseSBwb3NpdGlvbmVkIGRpdi4gSW4gdGhhdCBjYXNlLCB3ZSB1c2UgdGhlIGlubmVySGVpZ2h0IHRvIHJlc29sdmUgdGhpcy5cbiAgfSBlbHNlIGlmIChjb250ZXh0ID09PSBfd2luIHx8IF9pc1VuZGVmaW5lZChjb250ZXh0KSkge1xuICAgIHJldHVybiBlbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICB9IGVsc2Uge1xuICAgIGxlZnQgPSB0b3AgPSAwO1xuXG4gICAgaWYgKGlzU1ZHKSB7XG4gICAgICBiYm94ID0gZWxlbWVudC5nZXRCQm94KCk7XG4gICAgICB3aWR0aCA9IGJib3gud2lkdGg7XG4gICAgICBoZWlnaHQgPSBiYm94LmhlaWdodDtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGVsZW1lbnQudmlld0JveCAmJiAoYmJveCA9IGVsZW1lbnQudmlld0JveC5iYXNlVmFsKSkge1xuICAgICAgICBsZWZ0ID0gYmJveC54IHx8IDA7XG4gICAgICAgIHRvcCA9IGJib3gueSB8fCAwO1xuICAgICAgICB3aWR0aCA9IGJib3gud2lkdGg7XG4gICAgICAgIGhlaWdodCA9IGJib3guaGVpZ2h0O1xuICAgICAgfVxuXG4gICAgICBpZiAoIXdpZHRoKSB7XG4gICAgICAgIGNzID0gX2dldENvbXB1dGVkU3R5bGUoZWxlbWVudCk7XG4gICAgICAgIGJib3ggPSBjcy5ib3hTaXppbmcgPT09IFwiYm9yZGVyLWJveFwiO1xuICAgICAgICB3aWR0aCA9IChwYXJzZUZsb2F0KGNzLndpZHRoKSB8fCBlbGVtZW50LmNsaWVudFdpZHRoIHx8IDApICsgKGJib3ggPyAwIDogcGFyc2VGbG9hdChjcy5ib3JkZXJMZWZ0V2lkdGgpICsgcGFyc2VGbG9hdChjcy5ib3JkZXJSaWdodFdpZHRoKSk7XG4gICAgICAgIGhlaWdodCA9IChwYXJzZUZsb2F0KGNzLmhlaWdodCkgfHwgZWxlbWVudC5jbGllbnRIZWlnaHQgfHwgMCkgKyAoYmJveCA/IDAgOiBwYXJzZUZsb2F0KGNzLmJvcmRlclRvcFdpZHRoKSArIHBhcnNlRmxvYXQoY3MuYm9yZGVyQm90dG9tV2lkdGgpKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByaWdodCA9IHdpZHRoO1xuICAgIGJvdHRvbSA9IGhlaWdodDtcbiAgfVxuXG4gIGlmIChlbGVtZW50ID09PSBjb250ZXh0KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGxlZnQ6IGxlZnQsXG4gICAgICB0b3A6IHRvcCxcbiAgICAgIHdpZHRoOiByaWdodCAtIGxlZnQsXG4gICAgICBoZWlnaHQ6IGJvdHRvbSAtIHRvcFxuICAgIH07XG4gIH1cblxuICBtYXRyaXggPSBnZXRHbG9iYWxNYXRyaXgoY29udGV4dCwgdHJ1ZSkubXVsdGlwbHkoZ2V0R2xvYmFsTWF0cml4KGVsZW1lbnQpKTtcbiAgcDEgPSBtYXRyaXguYXBwbHkoe1xuICAgIHg6IGxlZnQsXG4gICAgeTogdG9wXG4gIH0pO1xuICBwMiA9IG1hdHJpeC5hcHBseSh7XG4gICAgeDogcmlnaHQsXG4gICAgeTogdG9wXG4gIH0pO1xuICBwMyA9IG1hdHJpeC5hcHBseSh7XG4gICAgeDogcmlnaHQsXG4gICAgeTogYm90dG9tXG4gIH0pO1xuICBwNCA9IG1hdHJpeC5hcHBseSh7XG4gICAgeDogbGVmdCxcbiAgICB5OiBib3R0b21cbiAgfSk7XG4gIGxlZnQgPSBNYXRoLm1pbihwMS54LCBwMi54LCBwMy54LCBwNC54KTtcbiAgdG9wID0gTWF0aC5taW4ocDEueSwgcDIueSwgcDMueSwgcDQueSk7XG4gIGNvbnRleHRQYXJlbnQgPSBjb250ZXh0LnBhcmVudE5vZGUgfHwge307XG4gIHJldHVybiB7XG4gICAgbGVmdDogbGVmdCArIChjb250ZXh0UGFyZW50LnNjcm9sbExlZnQgfHwgMCksXG4gICAgdG9wOiB0b3AgKyAoY29udGV4dFBhcmVudC5zY3JvbGxUb3AgfHwgMCksXG4gICAgd2lkdGg6IE1hdGgubWF4KHAxLngsIHAyLngsIHAzLngsIHA0LngpIC0gbGVmdCxcbiAgICBoZWlnaHQ6IE1hdGgubWF4KHAxLnksIHAyLnksIHAzLnksIHA0LnkpIC0gdG9wXG4gIH07XG59LFxuICAgIF9wYXJzZUluZXJ0aWEgPSBmdW5jdGlvbiBfcGFyc2VJbmVydGlhKGRyYWdnYWJsZSwgc25hcCwgbWF4LCBtaW4sIGZhY3RvciwgZm9yY2VaZXJvVmVsb2NpdHkpIHtcbiAgdmFyIHZhcnMgPSB7fSxcbiAgICAgIGEsXG4gICAgICBpLFxuICAgICAgbDtcblxuICBpZiAoc25hcCkge1xuICAgIGlmIChmYWN0b3IgIT09IDEgJiYgc25hcCBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAvL3NvbWUgZGF0YSBtdXN0IGJlIGFsdGVyZWQgdG8gbWFrZSBzZW5zZSwgbGlrZSBpZiB0aGUgdXNlciBwYXNzZXMgaW4gYW4gYXJyYXkgb2Ygcm90YXRpb25hbCB2YWx1ZXMgaW4gZGVncmVlcywgd2UgbXVzdCBjb252ZXJ0IGl0IHRvIHJhZGlhbnMuIE9yIGZvciBzY3JvbGxMZWZ0IGFuZCBzY3JvbGxUb3AsIHdlIGludmVydCB0aGUgdmFsdWVzLlxuICAgICAgdmFycy5lbmQgPSBhID0gW107XG4gICAgICBsID0gc25hcC5sZW5ndGg7XG5cbiAgICAgIGlmIChfaXNPYmplY3Qoc25hcFswXSkpIHtcbiAgICAgICAgLy9pZiB0aGUgYXJyYXkgaXMgcG9wdWxhdGVkIHdpdGggb2JqZWN0cywgbGlrZSBwb2ludHMgKHt4OjEwMCwgeToyMDB9KSwgbWFrZSBjb3BpZXMgYmVmb3JlIG11bHRpcGx5aW5nIGJ5IHRoZSBmYWN0b3IsIG90aGVyd2lzZSB3ZSdsbCBtZXNzIHVwIHRoZSBvcmlnaW5hbHMgYW5kIHRoZSB1c2VyIG1heSByZXVzZSBpdCBlbHNld2hlcmUuXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICBhW2ldID0gX2NvcHkoc25hcFtpXSwgZmFjdG9yKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgIGFbaV0gPSBzbmFwW2ldICogZmFjdG9yO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIG1heCArPSAxLjE7IC8vYWxsb3cgMS4xIHBpeGVscyBvZiB3aWdnbGUgcm9vbSB3aGVuIHNuYXBwaW5nIGluIG9yZGVyIHRvIHdvcmsgYXJvdW5kIHNvbWUgYnJvd3NlciBpbmNvbnNpc3RlbmNpZXMgaW4gdGhlIHdheSBib3VuZHMgYXJlIHJlcG9ydGVkIHdoaWNoIGNhbiBtYWtlIHRoZW0gcm91Z2hseSBhIHBpeGVsIG9mZi4gRm9yIGV4YW1wbGUsIGlmIFwic25hcDpbLSQoJyNtZW51Jykud2lkdGgoKSwgMF1cIiB3YXMgZGVmaW5lZCBhbmQgI21lbnUgaGFkIGEgd3JhcHBlciB0aGF0IHdhcyB1c2VkIGFzIHRoZSBib3VuZHMsIHNvbWUgYnJvd3NlcnMgd291bGQgYmUgb25lIHBpeGVsIG9mZiwgbWFraW5nIHRoZSBtaW5pbXVtIC03NTIgZm9yIGV4YW1wbGUgd2hlbiBzbmFwIHdhcyBbLTc1MywwXSwgdGh1cyBpbnN0ZWFkIG9mIHNuYXBwaW5nIHRvIC03NTMsIGl0IHdvdWxkIHNuYXAgdG8gMCBzaW5jZSAtNzUzIHdhcyBiZWxvdyB0aGUgbWluaW11bS5cblxuICAgICAgbWluIC09IDEuMTtcbiAgICB9IGVsc2UgaWYgKF9pc0Z1bmN0aW9uKHNuYXApKSB7XG4gICAgICB2YXJzLmVuZCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gc25hcC5jYWxsKGRyYWdnYWJsZSwgdmFsdWUpLFxuICAgICAgICAgICAgY29weSxcbiAgICAgICAgICAgIHA7XG5cbiAgICAgICAgaWYgKGZhY3RvciAhPT0gMSkge1xuICAgICAgICAgIGlmIChfaXNPYmplY3QocmVzdWx0KSkge1xuICAgICAgICAgICAgY29weSA9IHt9O1xuXG4gICAgICAgICAgICBmb3IgKHAgaW4gcmVzdWx0KSB7XG4gICAgICAgICAgICAgIGNvcHlbcF0gPSByZXN1bHRbcF0gKiBmYWN0b3I7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJlc3VsdCA9IGNvcHk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdCAqPSBmYWN0b3I7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDsgLy93ZSBuZWVkIHRvIGVuc3VyZSB0aGF0IHdlIGNhbiBzY29wZSB0aGUgZnVuY3Rpb24gY2FsbCB0byB0aGUgRHJhZ2dhYmxlIGluc3RhbmNlIGl0c2VsZiBzbyB0aGF0IHVzZXJzIGNhbiBhY2Nlc3MgaW1wb3J0YW50IHZhbHVlcyBsaWtlIG1heFgsIG1pblgsIG1heFksIG1pblksIHgsIGFuZCB5IGZyb20gd2l0aGluIHRoYXQgZnVuY3Rpb24uXG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXJzLmVuZCA9IHNuYXA7XG4gICAgfVxuICB9XG5cbiAgaWYgKG1heCB8fCBtYXggPT09IDApIHtcbiAgICB2YXJzLm1heCA9IG1heDtcbiAgfVxuXG4gIGlmIChtaW4gfHwgbWluID09PSAwKSB7XG4gICAgdmFycy5taW4gPSBtaW47XG4gIH1cblxuICBpZiAoZm9yY2VaZXJvVmVsb2NpdHkpIHtcbiAgICB2YXJzLnZlbG9jaXR5ID0gMDtcbiAgfVxuXG4gIHJldHVybiB2YXJzO1xufSxcbiAgICBfaXNDbGlja2FibGUgPSBmdW5jdGlvbiBfaXNDbGlja2FibGUoZWxlbWVudCkge1xuICAvL3NvbWV0aW1lcyBpdCdzIGNvbnZlbmllbnQgdG8gbWFyayBhbiBlbGVtZW50IGFzIGNsaWNrYWJsZSBieSBhZGRpbmcgYSBkYXRhLWNsaWNrYWJsZT1cInRydWVcIiBhdHRyaWJ1dGUgKGluIHdoaWNoIGNhc2Ugd2Ugd29uJ3QgcHJldmVudERlZmF1bHQoKSB0aGUgbW91c2UvdG91Y2ggZXZlbnQpLiBUaGlzIG1ldGhvZCBjaGVja3MgaWYgdGhlIGVsZW1lbnQgaXMgYW4gPGE+LCA8aW5wdXQ+LCBvciA8YnV0dG9uPiBvciBoYXMgYW4gb25jbGljayBvciBoYXMgdGhlIGRhdGEtY2xpY2thYmxlIG9yIGNvbnRlbnRFZGl0YWJsZSBhdHRyaWJ1dGUgc2V0IHRvIHRydWUgKG9yIGFueSBvZiBpdHMgcGFyZW50IGVsZW1lbnRzKS5cbiAgdmFyIGRhdGE7XG4gIHJldHVybiAhZWxlbWVudCB8fCAhZWxlbWVudC5nZXRBdHRyaWJ1dGUgfHwgZWxlbWVudCA9PT0gX2JvZHkgPyBmYWxzZSA6IChkYXRhID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoXCJkYXRhLWNsaWNrYWJsZVwiKSkgPT09IFwidHJ1ZVwiIHx8IGRhdGEgIT09IFwiZmFsc2VcIiAmJiAoZWxlbWVudC5vbmNsaWNrIHx8IF9jbGlja2FibGVUYWdFeHAudGVzdChlbGVtZW50Lm5vZGVOYW1lICsgXCJcIikgfHwgZWxlbWVudC5nZXRBdHRyaWJ1dGUoXCJjb250ZW50RWRpdGFibGVcIikgPT09IFwidHJ1ZVwiKSA/IHRydWUgOiBfaXNDbGlja2FibGUoZWxlbWVudC5wYXJlbnROb2RlKTtcbn0sXG4gICAgX3NldFNlbGVjdGFibGUgPSBmdW5jdGlvbiBfc2V0U2VsZWN0YWJsZShlbGVtZW50cywgc2VsZWN0YWJsZSkge1xuICB2YXIgaSA9IGVsZW1lbnRzLmxlbmd0aCxcbiAgICAgIGU7XG5cbiAgd2hpbGUgKGktLSkge1xuICAgIGUgPSBlbGVtZW50c1tpXTtcbiAgICBlLm9uZHJhZ3N0YXJ0ID0gZS5vbnNlbGVjdHN0YXJ0ID0gc2VsZWN0YWJsZSA/IG51bGwgOiBfZW1wdHlGdW5jO1xuICAgIGdzYXAuc2V0KGUsIHtcbiAgICAgIGxhenk6IHRydWUsXG4gICAgICB1c2VyU2VsZWN0OiBzZWxlY3RhYmxlID8gXCJ0ZXh0XCIgOiBcIm5vbmVcIlxuICAgIH0pO1xuICB9XG59LFxuICAgIF9pc0ZpeGVkID0gZnVuY3Rpb24gX2lzRml4ZWQoZWxlbWVudCkge1xuICBpZiAoX2dldENvbXB1dGVkU3R5bGUoZWxlbWVudCkucG9zaXRpb24gPT09IFwiZml4ZWRcIikge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgZWxlbWVudCA9IGVsZW1lbnQucGFyZW50Tm9kZTtcblxuICBpZiAoZWxlbWVudCAmJiBlbGVtZW50Lm5vZGVUeXBlID09PSAxKSB7XG4gICAgLy8gYXZvaWQgZG9jdW1lbnQgZnJhZ21lbnRzIHdoaWNoIHdpbGwgdGhyb3cgYW4gZXJyb3IuXG4gICAgcmV0dXJuIF9pc0ZpeGVkKGVsZW1lbnQpO1xuICB9XG59LFxuICAgIF9zdXBwb3J0czNELFxuICAgIF9hZGRQYWRkaW5nQlIsXG4gICAgLy9UaGUgU2Nyb2xsUHJveHkgY2xhc3Mgd3JhcHMgYW4gZWxlbWVudCdzIGNvbnRlbnRzIGludG8gYW5vdGhlciBkaXYgKHdlIGNhbGwgaXQgXCJjb250ZW50XCIpIHRoYXQgd2UgZWl0aGVyIGFkZCBwYWRkaW5nIHdoZW4gbmVjZXNzYXJ5IG9yIGFwcGx5IGEgdHJhbnNsYXRlM2QoKSB0cmFuc2Zvcm0gaW4gb3JkZXIgdG8gb3ZlcnNjcm9sbCAoc2Nyb2xsIHBhc3QgdGhlIGJvdW5kYXJpZXMpLiBUaGlzIGFsbG93cyB1cyB0byBzaW1wbHkgc2V0IHRoZSBzY3JvbGxUb3Avc2Nyb2xsTGVmdCAob3IgdG9wL2xlZnQgZm9yIGVhc2llciByZXZlcnNlLWF4aXMgb3JpZW50YXRpb24sIHdoaWNoIGlzIHdoYXQgd2UgZG8gaW4gRHJhZ2dhYmxlKSBhbmQgaXQnbGwgZG8gYWxsIHRoZSB3b3JrIGZvciB1cy4gRm9yIGV4YW1wbGUsIGlmIHdlIHRyaWVkIHNldHRpbmcgc2Nyb2xsVG9wIHRvIC0xMDAgb24gYSBub3JtYWwgRE9NIGVsZW1lbnQsIGl0IHdvdWxkbid0IHdvcmsgLSBpdCdkIGxvb2sgdGhlIHNhbWUgYXMgc2V0dGluZyBpdCB0byAwLCBidXQgaWYgd2Ugc2V0IHNjcm9sbFRvcCBvZiBhIFNjcm9sbFByb3h5IHRvIC0xMDAsIGl0J2xsIGdpdmUgdGhlIGNvcnJlY3QgYXBwZWFyYW5jZSBieSBlaXRoZXIgc2V0dGluZyBwYWRkaW5nVG9wIG9mIHRoZSB3cmFwcGVyIHRvIDEwMCBvciBhcHBseWluZyBhIDEwMC1waXhlbCB0cmFuc2xhdGVZLlxuU2Nyb2xsUHJveHkgPSBmdW5jdGlvbiBTY3JvbGxQcm94eShlbGVtZW50LCB2YXJzKSB7XG4gIGVsZW1lbnQgPSBnc2FwLnV0aWxzLnRvQXJyYXkoZWxlbWVudClbMF07XG4gIHZhcnMgPSB2YXJzIHx8IHt9O1xuICB2YXIgY29udGVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiksXG4gICAgICBzdHlsZSA9IGNvbnRlbnQuc3R5bGUsXG4gICAgICBub2RlID0gZWxlbWVudC5maXJzdENoaWxkLFxuICAgICAgb2Zmc2V0VG9wID0gMCxcbiAgICAgIG9mZnNldExlZnQgPSAwLFxuICAgICAgcHJldlRvcCA9IGVsZW1lbnQuc2Nyb2xsVG9wLFxuICAgICAgcHJldkxlZnQgPSBlbGVtZW50LnNjcm9sbExlZnQsXG4gICAgICBzY3JvbGxXaWR0aCA9IGVsZW1lbnQuc2Nyb2xsV2lkdGgsXG4gICAgICBzY3JvbGxIZWlnaHQgPSBlbGVtZW50LnNjcm9sbEhlaWdodCxcbiAgICAgIGV4dHJhUGFkUmlnaHQgPSAwLFxuICAgICAgbWF4TGVmdCA9IDAsXG4gICAgICBtYXhUb3AgPSAwLFxuICAgICAgZWxlbWVudFdpZHRoLFxuICAgICAgZWxlbWVudEhlaWdodCxcbiAgICAgIGNvbnRlbnRIZWlnaHQsXG4gICAgICBuZXh0Tm9kZSxcbiAgICAgIHRyYW5zZm9ybVN0YXJ0LFxuICAgICAgdHJhbnNmb3JtRW5kO1xuXG4gIGlmIChfc3VwcG9ydHMzRCAmJiB2YXJzLmZvcmNlM0QgIT09IGZhbHNlKSB7XG4gICAgdHJhbnNmb3JtU3RhcnQgPSBcInRyYW5zbGF0ZTNkKFwiO1xuICAgIHRyYW5zZm9ybUVuZCA9IFwicHgsMHB4KVwiO1xuICB9IGVsc2UgaWYgKF90cmFuc2Zvcm1Qcm9wKSB7XG4gICAgdHJhbnNmb3JtU3RhcnQgPSBcInRyYW5zbGF0ZShcIjtcbiAgICB0cmFuc2Zvcm1FbmQgPSBcInB4KVwiO1xuICB9XG5cbiAgdGhpcy5zY3JvbGxUb3AgPSBmdW5jdGlvbiAodmFsdWUsIGZvcmNlKSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gLXRoaXMudG9wKCk7XG4gICAgfVxuXG4gICAgdGhpcy50b3AoLXZhbHVlLCBmb3JjZSk7XG4gIH07XG5cbiAgdGhpcy5zY3JvbGxMZWZ0ID0gZnVuY3Rpb24gKHZhbHVlLCBmb3JjZSkge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIC10aGlzLmxlZnQoKTtcbiAgICB9XG5cbiAgICB0aGlzLmxlZnQoLXZhbHVlLCBmb3JjZSk7XG4gIH07XG5cbiAgdGhpcy5sZWZ0ID0gZnVuY3Rpb24gKHZhbHVlLCBmb3JjZSkge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIC0oZWxlbWVudC5zY3JvbGxMZWZ0ICsgb2Zmc2V0TGVmdCk7XG4gICAgfVxuXG4gICAgdmFyIGRpZiA9IGVsZW1lbnQuc2Nyb2xsTGVmdCAtIHByZXZMZWZ0LFxuICAgICAgICBvbGRPZmZzZXQgPSBvZmZzZXRMZWZ0O1xuXG4gICAgaWYgKChkaWYgPiAyIHx8IGRpZiA8IC0yKSAmJiAhZm9yY2UpIHtcbiAgICAgIC8vaWYgdGhlIHVzZXIgaW50ZXJhY3RzIHdpdGggdGhlIHNjcm9sbGJhciAob3Igc29tZXRoaW5nIGVsc2Ugc2Nyb2xscyBpdCwgbGlrZSB0aGUgbW91c2Ugd2hlZWwpLCB3ZSBzaG91bGQga2lsbCBhbnkgdHdlZW5zIG9mIHRoZSBTY3JvbGxQcm94eS5cbiAgICAgIHByZXZMZWZ0ID0gZWxlbWVudC5zY3JvbGxMZWZ0O1xuICAgICAgZ3NhcC5raWxsVHdlZW5zT2YodGhpcywge1xuICAgICAgICBsZWZ0OiAxLFxuICAgICAgICBzY3JvbGxMZWZ0OiAxXG4gICAgICB9KTtcbiAgICAgIHRoaXMubGVmdCgtcHJldkxlZnQpO1xuXG4gICAgICBpZiAodmFycy5vbktpbGwpIHtcbiAgICAgICAgdmFycy5vbktpbGwoKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhbHVlID0gLXZhbHVlOyAvL2ludmVydCBiZWNhdXNlIHNjcm9sbGluZyB3b3JrcyBpbiB0aGUgb3Bwb3NpdGUgZGlyZWN0aW9uXG5cbiAgICBpZiAodmFsdWUgPCAwKSB7XG4gICAgICBvZmZzZXRMZWZ0ID0gdmFsdWUgLSAwLjUgfCAwO1xuICAgICAgdmFsdWUgPSAwO1xuICAgIH0gZWxzZSBpZiAodmFsdWUgPiBtYXhMZWZ0KSB7XG4gICAgICBvZmZzZXRMZWZ0ID0gdmFsdWUgLSBtYXhMZWZ0IHwgMDtcbiAgICAgIHZhbHVlID0gbWF4TGVmdDtcbiAgICB9IGVsc2Uge1xuICAgICAgb2Zmc2V0TGVmdCA9IDA7XG4gICAgfVxuXG4gICAgaWYgKG9mZnNldExlZnQgfHwgb2xkT2Zmc2V0KSB7XG4gICAgICBpZiAoIXRoaXMuX3NraXApIHtcbiAgICAgICAgc3R5bGVbX3RyYW5zZm9ybVByb3BdID0gdHJhbnNmb3JtU3RhcnQgKyAtb2Zmc2V0TGVmdCArIFwicHgsXCIgKyAtb2Zmc2V0VG9wICsgdHJhbnNmb3JtRW5kO1xuICAgICAgfVxuXG4gICAgICBpZiAob2Zmc2V0TGVmdCArIGV4dHJhUGFkUmlnaHQgPj0gMCkge1xuICAgICAgICBzdHlsZS5wYWRkaW5nUmlnaHQgPSBvZmZzZXRMZWZ0ICsgZXh0cmFQYWRSaWdodCArIFwicHhcIjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBlbGVtZW50LnNjcm9sbExlZnQgPSB2YWx1ZSB8IDA7XG4gICAgcHJldkxlZnQgPSBlbGVtZW50LnNjcm9sbExlZnQ7IC8vZG9uJ3QgbWVyZ2UgdGhpcyB3aXRoIHRoZSBsaW5lIGFib3ZlIGJlY2F1c2Ugc29tZSBicm93c2VycyBhZGp1c3QgdGhlIHNjcm9sbExlZnQgYWZ0ZXIgaXQncyBzZXQsIHNvIGluIG9yZGVyIHRvIGJlIDEwMCUgYWNjdXJhdGUgaW4gdHJhY2tpbmcgaXQsIHdlIG5lZWQgdG8gYXNrIHRoZSBicm93c2VyIHRvIHJlcG9ydCBpdC5cbiAgfTtcblxuICB0aGlzLnRvcCA9IGZ1bmN0aW9uICh2YWx1ZSwgZm9yY2UpIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiAtKGVsZW1lbnQuc2Nyb2xsVG9wICsgb2Zmc2V0VG9wKTtcbiAgICB9XG5cbiAgICB2YXIgZGlmID0gZWxlbWVudC5zY3JvbGxUb3AgLSBwcmV2VG9wLFxuICAgICAgICBvbGRPZmZzZXQgPSBvZmZzZXRUb3A7XG5cbiAgICBpZiAoKGRpZiA+IDIgfHwgZGlmIDwgLTIpICYmICFmb3JjZSkge1xuICAgICAgLy9pZiB0aGUgdXNlciBpbnRlcmFjdHMgd2l0aCB0aGUgc2Nyb2xsYmFyIChvciBzb21ldGhpbmcgZWxzZSBzY3JvbGxzIGl0LCBsaWtlIHRoZSBtb3VzZSB3aGVlbCksIHdlIHNob3VsZCBraWxsIGFueSB0d2VlbnMgb2YgdGhlIFNjcm9sbFByb3h5LlxuICAgICAgcHJldlRvcCA9IGVsZW1lbnQuc2Nyb2xsVG9wO1xuICAgICAgZ3NhcC5raWxsVHdlZW5zT2YodGhpcywge1xuICAgICAgICB0b3A6IDEsXG4gICAgICAgIHNjcm9sbFRvcDogMVxuICAgICAgfSk7XG4gICAgICB0aGlzLnRvcCgtcHJldlRvcCk7XG5cbiAgICAgIGlmICh2YXJzLm9uS2lsbCkge1xuICAgICAgICB2YXJzLm9uS2lsbCgpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFsdWUgPSAtdmFsdWU7IC8vaW52ZXJ0IGJlY2F1c2Ugc2Nyb2xsaW5nIHdvcmtzIGluIHRoZSBvcHBvc2l0ZSBkaXJlY3Rpb25cblxuICAgIGlmICh2YWx1ZSA8IDApIHtcbiAgICAgIG9mZnNldFRvcCA9IHZhbHVlIC0gMC41IHwgMDtcbiAgICAgIHZhbHVlID0gMDtcbiAgICB9IGVsc2UgaWYgKHZhbHVlID4gbWF4VG9wKSB7XG4gICAgICBvZmZzZXRUb3AgPSB2YWx1ZSAtIG1heFRvcCB8IDA7XG4gICAgICB2YWx1ZSA9IG1heFRvcDtcbiAgICB9IGVsc2Uge1xuICAgICAgb2Zmc2V0VG9wID0gMDtcbiAgICB9XG5cbiAgICBpZiAob2Zmc2V0VG9wIHx8IG9sZE9mZnNldCkge1xuICAgICAgaWYgKCF0aGlzLl9za2lwKSB7XG4gICAgICAgIHN0eWxlW190cmFuc2Zvcm1Qcm9wXSA9IHRyYW5zZm9ybVN0YXJ0ICsgLW9mZnNldExlZnQgKyBcInB4LFwiICsgLW9mZnNldFRvcCArIHRyYW5zZm9ybUVuZDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBlbGVtZW50LnNjcm9sbFRvcCA9IHZhbHVlIHwgMDtcbiAgICBwcmV2VG9wID0gZWxlbWVudC5zY3JvbGxUb3A7XG4gIH07XG5cbiAgdGhpcy5tYXhTY3JvbGxUb3AgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIG1heFRvcDtcbiAgfTtcblxuICB0aGlzLm1heFNjcm9sbExlZnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIG1heExlZnQ7XG4gIH07XG5cbiAgdGhpcy5kaXNhYmxlID0gZnVuY3Rpb24gKCkge1xuICAgIG5vZGUgPSBjb250ZW50LmZpcnN0Q2hpbGQ7XG5cbiAgICB3aGlsZSAobm9kZSkge1xuICAgICAgbmV4dE5vZGUgPSBub2RlLm5leHRTaWJsaW5nO1xuICAgICAgZWxlbWVudC5hcHBlbmRDaGlsZChub2RlKTtcbiAgICAgIG5vZGUgPSBuZXh0Tm9kZTtcbiAgICB9XG5cbiAgICBpZiAoZWxlbWVudCA9PT0gY29udGVudC5wYXJlbnROb2RlKSB7XG4gICAgICAvL2luIGNhc2UgZGlzYWJsZSgpIGlzIGNhbGxlZCB3aGVuIGl0J3MgYWxyZWFkeSBkaXNhYmxlZC5cbiAgICAgIGVsZW1lbnQucmVtb3ZlQ2hpbGQoY29udGVudCk7XG4gICAgfVxuICB9O1xuXG4gIHRoaXMuZW5hYmxlID0gZnVuY3Rpb24gKCkge1xuICAgIG5vZGUgPSBlbGVtZW50LmZpcnN0Q2hpbGQ7XG5cbiAgICBpZiAobm9kZSA9PT0gY29udGVudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHdoaWxlIChub2RlKSB7XG4gICAgICBuZXh0Tm9kZSA9IG5vZGUubmV4dFNpYmxpbmc7XG4gICAgICBjb250ZW50LmFwcGVuZENoaWxkKG5vZGUpO1xuICAgICAgbm9kZSA9IG5leHROb2RlO1xuICAgIH1cblxuICAgIGVsZW1lbnQuYXBwZW5kQ2hpbGQoY29udGVudCk7XG4gICAgdGhpcy5jYWxpYnJhdGUoKTtcbiAgfTtcblxuICB0aGlzLmNhbGlicmF0ZSA9IGZ1bmN0aW9uIChmb3JjZSkge1xuICAgIHZhciB3aWR0aE1hdGNoZXMgPSBlbGVtZW50LmNsaWVudFdpZHRoID09PSBlbGVtZW50V2lkdGgsXG4gICAgICAgIGNzLFxuICAgICAgICB4LFxuICAgICAgICB5O1xuICAgIHByZXZUb3AgPSBlbGVtZW50LnNjcm9sbFRvcDtcbiAgICBwcmV2TGVmdCA9IGVsZW1lbnQuc2Nyb2xsTGVmdDtcblxuICAgIGlmICh3aWR0aE1hdGNoZXMgJiYgZWxlbWVudC5jbGllbnRIZWlnaHQgPT09IGVsZW1lbnRIZWlnaHQgJiYgY29udGVudC5vZmZzZXRIZWlnaHQgPT09IGNvbnRlbnRIZWlnaHQgJiYgc2Nyb2xsV2lkdGggPT09IGVsZW1lbnQuc2Nyb2xsV2lkdGggJiYgc2Nyb2xsSGVpZ2h0ID09PSBlbGVtZW50LnNjcm9sbEhlaWdodCAmJiAhZm9yY2UpIHtcbiAgICAgIHJldHVybjsgLy9ubyBuZWVkIHRvIHJlY2FsY3VsYXRlIHRoaW5ncyBpZiB0aGUgd2lkdGggYW5kIGhlaWdodCBoYXZlbid0IGNoYW5nZWQuXG4gICAgfVxuXG4gICAgaWYgKG9mZnNldFRvcCB8fCBvZmZzZXRMZWZ0KSB7XG4gICAgICB4ID0gdGhpcy5sZWZ0KCk7XG4gICAgICB5ID0gdGhpcy50b3AoKTtcbiAgICAgIHRoaXMubGVmdCgtZWxlbWVudC5zY3JvbGxMZWZ0KTtcbiAgICAgIHRoaXMudG9wKC1lbGVtZW50LnNjcm9sbFRvcCk7XG4gICAgfVxuXG4gICAgY3MgPSBfZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KTsgLy9maXJzdCwgd2UgbmVlZCB0byByZW1vdmUgYW55IHdpZHRoIGNvbnN0cmFpbnRzIHRvIHNlZSBob3cgdGhlIGNvbnRlbnQgbmF0dXJhbGx5IGZsb3dzIHNvIHRoYXQgd2UgY2FuIHNlZSBpZiBpdCdzIHdpZGVyIHRoYW4gdGhlIGNvbnRhaW5pbmcgZWxlbWVudC4gSWYgc28sIHdlJ3ZlIGdvdCB0byByZWNvcmQgdGhlIGFtb3VudCBvZiBvdmVyYWdlIHNvIHRoYXQgd2UgY2FuIGFwcGx5IHRoYXQgYXMgcGFkZGluZyBpbiBvcmRlciBmb3IgYnJvd3NlcnMgdG8gY29ycmVjdGx5IGhhbmRsZSB0aGluZ3MuIFRoZW4gd2Ugc3dpdGNoIGJhY2sgdG8gYSB3aWR0aCBvZiAxMDAlICh3aXRob3V0IHRoYXQsIHNvbWUgYnJvd3NlcnMgZG9uJ3QgZmxvdyB0aGUgY29udGVudCBjb3JyZWN0bHkpXG5cbiAgICBpZiAoIXdpZHRoTWF0Y2hlcyB8fCBmb3JjZSkge1xuICAgICAgc3R5bGUuZGlzcGxheSA9IFwiYmxvY2tcIjtcbiAgICAgIHN0eWxlLndpZHRoID0gXCJhdXRvXCI7XG4gICAgICBzdHlsZS5wYWRkaW5nUmlnaHQgPSBcIjBweFwiO1xuICAgICAgZXh0cmFQYWRSaWdodCA9IE1hdGgubWF4KDAsIGVsZW1lbnQuc2Nyb2xsV2lkdGggLSBlbGVtZW50LmNsaWVudFdpZHRoKTsgLy9pZiB0aGUgY29udGVudCBpcyB3aWRlciB0aGFuIHRoZSBjb250YWluZXIsIHdlIG5lZWQgdG8gYWRkIHRoZSBwYWRkaW5nTGVmdCBhbmQgcGFkZGluZ1JpZ2h0IGluIG9yZGVyIGZvciB0aGluZ3MgdG8gYmVoYXZlIGNvcnJlY3RseS5cblxuICAgICAgaWYgKGV4dHJhUGFkUmlnaHQpIHtcbiAgICAgICAgZXh0cmFQYWRSaWdodCArPSBwYXJzZUZsb2F0KGNzLnBhZGRpbmdMZWZ0KSArIChfYWRkUGFkZGluZ0JSID8gcGFyc2VGbG9hdChjcy5wYWRkaW5nUmlnaHQpIDogMCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgc3R5bGUuZGlzcGxheSA9IFwiaW5saW5lLWJsb2NrXCI7XG4gICAgc3R5bGUucG9zaXRpb24gPSBcInJlbGF0aXZlXCI7XG4gICAgc3R5bGUub3ZlcmZsb3cgPSBcInZpc2libGVcIjtcbiAgICBzdHlsZS52ZXJ0aWNhbEFsaWduID0gXCJ0b3BcIjtcbiAgICBzdHlsZS5ib3hTaXppbmcgPSBcImNvbnRlbnQtYm94XCI7XG4gICAgc3R5bGUud2lkdGggPSBcIjEwMCVcIjtcbiAgICBzdHlsZS5wYWRkaW5nUmlnaHQgPSBleHRyYVBhZFJpZ2h0ICsgXCJweFwiOyAvL3NvbWUgYnJvd3NlcnMgbmVnbGVjdCB0byBmYWN0b3IgaW4gdGhlIGJvdHRvbSBwYWRkaW5nIHdoZW4gY2FsY3VsYXRpbmcgdGhlIHNjcm9sbEhlaWdodCwgc28gd2UgbmVlZCB0byBhZGQgdGhhdCBwYWRkaW5nIHRvIHRoZSBjb250ZW50IHdoZW4gdGhhdCBoYXBwZW5zLiBBbGxvdyBhIDJweCBtYXJnaW4gZm9yIGVycm9yXG5cbiAgICBpZiAoX2FkZFBhZGRpbmdCUikge1xuICAgICAgc3R5bGUucGFkZGluZ0JvdHRvbSA9IGNzLnBhZGRpbmdCb3R0b207XG4gICAgfVxuXG4gICAgZWxlbWVudFdpZHRoID0gZWxlbWVudC5jbGllbnRXaWR0aDtcbiAgICBlbGVtZW50SGVpZ2h0ID0gZWxlbWVudC5jbGllbnRIZWlnaHQ7XG4gICAgc2Nyb2xsV2lkdGggPSBlbGVtZW50LnNjcm9sbFdpZHRoO1xuICAgIHNjcm9sbEhlaWdodCA9IGVsZW1lbnQuc2Nyb2xsSGVpZ2h0O1xuICAgIG1heExlZnQgPSBlbGVtZW50LnNjcm9sbFdpZHRoIC0gZWxlbWVudFdpZHRoO1xuICAgIG1heFRvcCA9IGVsZW1lbnQuc2Nyb2xsSGVpZ2h0IC0gZWxlbWVudEhlaWdodDtcbiAgICBjb250ZW50SGVpZ2h0ID0gY29udGVudC5vZmZzZXRIZWlnaHQ7XG4gICAgc3R5bGUuZGlzcGxheSA9IFwiYmxvY2tcIjtcblxuICAgIGlmICh4IHx8IHkpIHtcbiAgICAgIHRoaXMubGVmdCh4KTtcbiAgICAgIHRoaXMudG9wKHkpO1xuICAgIH1cbiAgfTtcblxuICB0aGlzLmNvbnRlbnQgPSBjb250ZW50O1xuICB0aGlzLmVsZW1lbnQgPSBlbGVtZW50O1xuICB0aGlzLl9za2lwID0gZmFsc2U7XG4gIHRoaXMuZW5hYmxlKCk7XG59LFxuICAgIF9pbml0Q29yZSA9IGZ1bmN0aW9uIF9pbml0Q29yZShyZXF1aXJlZCkge1xuICBpZiAoX3dpbmRvd0V4aXN0cygpICYmIGRvY3VtZW50LmJvZHkpIHtcbiAgICB2YXIgbmF2ID0gd2luZG93ICYmIHdpbmRvdy5uYXZpZ2F0b3I7XG4gICAgX3dpbiA9IHdpbmRvdztcbiAgICBfZG9jID0gZG9jdW1lbnQ7XG4gICAgX2RvY0VsZW1lbnQgPSBfZG9jLmRvY3VtZW50RWxlbWVudDtcbiAgICBfYm9keSA9IF9kb2MuYm9keTtcbiAgICBfdGVtcERpdiA9IF9jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgIF9zdXBwb3J0c1BvaW50ZXIgPSAhIXdpbmRvdy5Qb2ludGVyRXZlbnQ7XG4gICAgX3BsYWNlaG9sZGVyRGl2ID0gX2NyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgX3BsYWNlaG9sZGVyRGl2LnN0eWxlLmNzc1RleHQgPSBcInZpc2liaWxpdHk6aGlkZGVuO2hlaWdodDoxcHg7dG9wOi0xcHg7cG9pbnRlci1ldmVudHM6bm9uZTtwb3NpdGlvbjpyZWxhdGl2ZTtjbGVhcjpib3RoO2N1cnNvcjpncmFiXCI7XG4gICAgX2RlZmF1bHRDdXJzb3IgPSBfcGxhY2Vob2xkZXJEaXYuc3R5bGUuY3Vyc29yID09PSBcImdyYWJcIiA/IFwiZ3JhYlwiIDogXCJtb3ZlXCI7XG4gICAgX2lzQW5kcm9pZCA9IG5hdiAmJiBuYXYudXNlckFnZW50LnRvTG93ZXJDYXNlKCkuaW5kZXhPZihcImFuZHJvaWRcIikgIT09IC0xOyAvL0FuZHJvaWQgaGFuZGxlcyB0b3VjaCBldmVudHMgaW4gYW4gb2RkIHdheSBhbmQgaXQncyB2aXJ0dWFsbHkgaW1wb3NzaWJsZSB0byBcImZlYXR1cmUgdGVzdFwiIHNvIHdlIHJlc29ydCB0byBVQSBzbmlmZmluZ1xuXG4gICAgX2lzVG91Y2hEZXZpY2UgPSBcIm9udG91Y2hzdGFydFwiIGluIF9kb2NFbGVtZW50ICYmIFwib3JpZW50YXRpb25cIiBpbiBfd2luIHx8IG5hdiAmJiAobmF2Lk1heFRvdWNoUG9pbnRzID4gMCB8fCBuYXYubXNNYXhUb3VjaFBvaW50cyA+IDApO1xuXG4gICAgX2FkZFBhZGRpbmdCUiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIC8vdGhpcyBmdW5jdGlvbiBpcyBpbiBjaGFyZ2Ugb2YgYW5hbHl6aW5nIGJyb3dzZXIgYmVoYXZpb3IgcmVsYXRlZCB0byBwYWRkaW5nLiBJdCBzZXRzIHRoZSBfYWRkUGFkZGluZ0JSIHRvIHRydWUgaWYgdGhlIGJyb3dzZXIgZG9lc24ndCBub3JtYWxseSBmYWN0b3IgaW4gdGhlIGJvdHRvbSBvciByaWdodCBwYWRkaW5nIG9uIHRoZSBlbGVtZW50IGluc2lkZSB0aGUgc2Nyb2xsaW5nIGFyZWEsIGFuZCBpdCBzZXRzIF9hZGRQYWRkaW5nTGVmdCB0byB0cnVlIGlmIGl0J3MgYSBicm93c2VyIHRoYXQgcmVxdWlyZXMgdGhlIGV4dHJhIG9mZnNldCAob2Zmc2V0TGVmdCkgdG8gYmUgYWRkZWQgdG8gdGhlIHBhZGRpbmdSaWdodCAobGlrZSBPcGVyYSkuXG4gICAgICB2YXIgZGl2ID0gX2NyZWF0ZUVsZW1lbnQoXCJkaXZcIiksXG4gICAgICAgICAgY2hpbGQgPSBfY3JlYXRlRWxlbWVudChcImRpdlwiKSxcbiAgICAgICAgICBjaGlsZFN0eWxlID0gY2hpbGQuc3R5bGUsXG4gICAgICAgICAgcGFyZW50ID0gX2JvZHksXG4gICAgICAgICAgdmFsO1xuXG4gICAgICBjaGlsZFN0eWxlLmRpc3BsYXkgPSBcImlubGluZS1ibG9ja1wiO1xuICAgICAgY2hpbGRTdHlsZS5wb3NpdGlvbiA9IFwicmVsYXRpdmVcIjtcbiAgICAgIGRpdi5zdHlsZS5jc3NUZXh0ID0gY2hpbGQuaW5uZXJIVE1MID0gXCJ3aWR0aDo5MHB4O2hlaWdodDo0MHB4O3BhZGRpbmc6MTBweDtvdmVyZmxvdzphdXRvO3Zpc2liaWxpdHk6aGlkZGVuXCI7XG4gICAgICBkaXYuYXBwZW5kQ2hpbGQoY2hpbGQpO1xuICAgICAgcGFyZW50LmFwcGVuZENoaWxkKGRpdik7XG4gICAgICB2YWwgPSBjaGlsZC5vZmZzZXRIZWlnaHQgKyAxOCA+IGRpdi5zY3JvbGxIZWlnaHQ7IC8vZGl2LnNjcm9sbEhlaWdodCBzaG91bGQgYmUgY2hpbGQub2Zmc2V0SGVpZ2h0ICsgMjAgYmVjYXVzZSBvZiB0aGUgMTBweCBvZiBwYWRkaW5nIG9uIGVhY2ggc2lkZSwgYnV0IHNvbWUgYnJvd3NlcnMgaWdub3JlIG9uZSBzaWRlLiBXZSBhbGxvdyBhIDJweCBtYXJnaW4gb2YgZXJyb3IuXG5cbiAgICAgIHBhcmVudC5yZW1vdmVDaGlsZChkaXYpO1xuICAgICAgcmV0dXJuIHZhbDtcbiAgICB9KCk7XG5cbiAgICBfdG91Y2hFdmVudExvb2t1cCA9IGZ1bmN0aW9uICh0eXBlcykge1xuICAgICAgLy93ZSBjcmVhdGUgYW4gb2JqZWN0IHRoYXQgbWFrZXMgaXQgZWFzeSB0byB0cmFuc2xhdGUgdG91Y2ggZXZlbnQgdHlwZXMgaW50byB0aGVpciBcInBvaW50ZXJcIiBjb3VudGVycGFydHMgaWYgd2UncmUgaW4gYSBicm93c2VyIHRoYXQgdXNlcyB0aG9zZSBpbnN0ZWFkLiBMaWtlIElFMTAgdXNlcyBcIk1TUG9pbnRlckRvd25cIiBpbnN0ZWFkIG9mIFwidG91Y2hzdGFydFwiLCBmb3IgZXhhbXBsZS5cbiAgICAgIHZhciBzdGFuZGFyZCA9IHR5cGVzLnNwbGl0KFwiLFwiKSxcbiAgICAgICAgICBjb252ZXJ0ZWQgPSAoXCJvbnBvaW50ZXJkb3duXCIgaW4gX3RlbXBEaXYgPyBcInBvaW50ZXJkb3duLHBvaW50ZXJtb3ZlLHBvaW50ZXJ1cCxwb2ludGVyY2FuY2VsXCIgOiBcIm9ubXNwb2ludGVyZG93blwiIGluIF90ZW1wRGl2ID8gXCJNU1BvaW50ZXJEb3duLE1TUG9pbnRlck1vdmUsTVNQb2ludGVyVXAsTVNQb2ludGVyQ2FuY2VsXCIgOiB0eXBlcykuc3BsaXQoXCIsXCIpLFxuICAgICAgICAgIG9iaiA9IHt9LFxuICAgICAgICAgIGkgPSA0O1xuXG4gICAgICB3aGlsZSAoLS1pID4gLTEpIHtcbiAgICAgICAgb2JqW3N0YW5kYXJkW2ldXSA9IGNvbnZlcnRlZFtpXTtcbiAgICAgICAgb2JqW2NvbnZlcnRlZFtpXV0gPSBzdGFuZGFyZFtpXTtcbiAgICAgIH0gLy90byBhdm9pZCBwcm9ibGVtcyBpbiBpT1MgOSwgdGVzdCB0byBzZWUgaWYgdGhlIGJyb3dzZXIgc3VwcG9ydHMgdGhlIFwicGFzc2l2ZVwiIG9wdGlvbiBvbiBhZGRFdmVudExpc3RlbmVyKCkuXG5cblxuICAgICAgdHJ5IHtcbiAgICAgICAgX2RvY0VsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcInRlc3RcIiwgbnVsbCwgT2JqZWN0LmRlZmluZVByb3BlcnR5KHt9LCBcInBhc3NpdmVcIiwge1xuICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgX3N1cHBvcnRzUGFzc2l2ZSA9IDE7XG4gICAgICAgICAgfVxuICAgICAgICB9KSk7XG4gICAgICB9IGNhdGNoIChlKSB7fVxuXG4gICAgICByZXR1cm4gb2JqO1xuICAgIH0oXCJ0b3VjaHN0YXJ0LHRvdWNobW92ZSx0b3VjaGVuZCx0b3VjaGNhbmNlbFwiKTtcblxuICAgIF9hZGRMaXN0ZW5lcihfZG9jLCBcInRvdWNoY2FuY2VsXCIsIF9lbXB0eUZ1bmMpOyAvL3NvbWUgb2xkZXIgQW5kcm9pZCBkZXZpY2VzIGludGVybWl0dGVudGx5IHN0b3AgZGlzcGF0Y2hpbmcgXCJ0b3VjaG1vdmVcIiBldmVudHMgaWYgd2UgZG9uJ3QgbGlzdGVuIGZvciBcInRvdWNoY2FuY2VsXCIgb24gdGhlIGRvY3VtZW50LiBWZXJ5IHN0cmFuZ2UgaW5kZWVkLlxuXG5cbiAgICBfYWRkTGlzdGVuZXIoX3dpbiwgXCJ0b3VjaG1vdmVcIiwgX2VtcHR5RnVuYyk7IC8vd29ya3MgYXJvdW5kIFNhZmFyaSBidWdzIHRoYXQgc3RpbGwgYWxsb3cgdGhlIHBhZ2UgdG8gc2Nyb2xsIGV2ZW4gd2hlbiB3ZSBwcmV2ZW50RGVmYXVsdCgpIG9uIHRoZSB0b3VjaG1vdmUgZXZlbnQuXG5cblxuICAgIF9ib2R5ICYmIF9ib2R5LmFkZEV2ZW50TGlzdGVuZXIoXCJ0b3VjaHN0YXJ0XCIsIF9lbXB0eUZ1bmMpOyAvL3dvcmtzIGFyb3VuZCBTYWZhcmkgYnVnOiBodHRwczovL2dyZWVuc29jay5jb20vZm9ydW1zL3RvcGljLzIxNDUwLWRyYWdnYWJsZS1pbi1pZnJhbWUtb24tbW9iaWxlLWlzLWJ1Z2d5L1xuXG4gICAgX2FkZExpc3RlbmVyKF9kb2MsIFwiY29udGV4dG1lbnVcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgZm9yICh2YXIgcCBpbiBfbG9va3VwKSB7XG4gICAgICAgIGlmIChfbG9va3VwW3BdLmlzUHJlc3NlZCkge1xuICAgICAgICAgIF9sb29rdXBbcF0uZW5kRHJhZygpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBnc2FwID0gX2NvcmVJbml0dGVkID0gX2dldEdTQVAoKTtcbiAgfVxuXG4gIGlmIChnc2FwKSB7XG4gICAgSW5lcnRpYVBsdWdpbiA9IGdzYXAucGx1Z2lucy5pbmVydGlhO1xuICAgIF9jaGVja1ByZWZpeCA9IGdzYXAudXRpbHMuY2hlY2tQcmVmaXg7XG4gICAgX3RyYW5zZm9ybVByb3AgPSBfY2hlY2tQcmVmaXgoX3RyYW5zZm9ybVByb3ApO1xuICAgIF90cmFuc2Zvcm1PcmlnaW5Qcm9wID0gX2NoZWNrUHJlZml4KF90cmFuc2Zvcm1PcmlnaW5Qcm9wKTtcbiAgICBfdG9BcnJheSA9IGdzYXAudXRpbHMudG9BcnJheTtcbiAgICBfc3VwcG9ydHMzRCA9ICEhX2NoZWNrUHJlZml4KFwicGVyc3BlY3RpdmVcIik7XG4gIH0gZWxzZSBpZiAocmVxdWlyZWQpIHtcbiAgICBjb25zb2xlLndhcm4oXCJQbGVhc2UgZ3NhcC5yZWdpc3RlclBsdWdpbihEcmFnZ2FibGUpXCIpO1xuICB9XG59O1xuXG52YXIgRXZlbnREaXNwYXRjaGVyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gRXZlbnREaXNwYXRjaGVyKHRhcmdldCkge1xuICAgIHRoaXMuX2xpc3RlbmVycyA9IHt9O1xuICAgIHRoaXMudGFyZ2V0ID0gdGFyZ2V0IHx8IHRoaXM7XG4gIH1cblxuICB2YXIgX3Byb3RvID0gRXZlbnREaXNwYXRjaGVyLnByb3RvdHlwZTtcblxuICBfcHJvdG8uYWRkRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uIGFkZEV2ZW50TGlzdGVuZXIodHlwZSwgY2FsbGJhY2spIHtcbiAgICB2YXIgbGlzdCA9IHRoaXMuX2xpc3RlbmVyc1t0eXBlXSB8fCAodGhpcy5fbGlzdGVuZXJzW3R5cGVdID0gW10pO1xuXG4gICAgaWYgKCF+bGlzdC5pbmRleE9mKGNhbGxiYWNrKSkge1xuICAgICAgbGlzdC5wdXNoKGNhbGxiYWNrKTtcbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLnJlbW92ZUV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbiByZW1vdmVFdmVudExpc3RlbmVyKHR5cGUsIGNhbGxiYWNrKSB7XG4gICAgdmFyIGxpc3QgPSB0aGlzLl9saXN0ZW5lcnNbdHlwZV0sXG4gICAgICAgIGkgPSBsaXN0ICYmIGxpc3QuaW5kZXhPZihjYWxsYmFjaykgfHwgLTE7XG4gICAgaSA+IC0xICYmIGxpc3Quc3BsaWNlKGksIDEpO1xuICB9O1xuXG4gIF9wcm90by5kaXNwYXRjaEV2ZW50ID0gZnVuY3Rpb24gZGlzcGF0Y2hFdmVudCh0eXBlKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIHZhciByZXN1bHQ7XG4gICAgKHRoaXMuX2xpc3RlbmVyc1t0eXBlXSB8fCBbXSkuZm9yRWFjaChmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICAgIHJldHVybiBjYWxsYmFjay5jYWxsKF90aGlzLCB7XG4gICAgICAgIHR5cGU6IHR5cGUsXG4gICAgICAgIHRhcmdldDogX3RoaXMudGFyZ2V0XG4gICAgICB9KSA9PT0gZmFsc2UgJiYgKHJlc3VsdCA9IGZhbHNlKTtcbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0OyAvL2lmIGFueSBvZiB0aGUgY2FsbGJhY2tzIHJldHVybiBmYWxzZSwgcGFzcyB0aGF0IGFsb25nLlxuICB9O1xuXG4gIHJldHVybiBFdmVudERpc3BhdGNoZXI7XG59KCk7XG5cbmV4cG9ydCB2YXIgRHJhZ2dhYmxlID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfRXZlbnREaXNwYXRjaGVyKSB7XG4gIF9pbmhlcml0c0xvb3NlKERyYWdnYWJsZSwgX0V2ZW50RGlzcGF0Y2hlcik7XG5cbiAgZnVuY3Rpb24gRHJhZ2dhYmxlKHRhcmdldCwgdmFycykge1xuICAgIHZhciBfdGhpczI7XG5cbiAgICBfdGhpczIgPSBfRXZlbnREaXNwYXRjaGVyLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICBfY29yZUluaXR0ZWQgfHwgX2luaXRDb3JlKDEpO1xuICAgIHRhcmdldCA9IF90b0FycmF5KHRhcmdldClbMF07IC8vaW4gY2FzZSB0aGUgdGFyZ2V0IGlzIGEgc2VsZWN0b3Igb2JqZWN0IG9yIHNlbGVjdG9yIHRleHRcblxuICAgIGlmICghSW5lcnRpYVBsdWdpbikge1xuICAgICAgSW5lcnRpYVBsdWdpbiA9IGdzYXAucGx1Z2lucy5pbmVydGlhO1xuICAgIH1cblxuICAgIF90aGlzMi52YXJzID0gdmFycyA9IF9jb3B5KHZhcnMgfHwge30pO1xuICAgIF90aGlzMi50YXJnZXQgPSB0YXJnZXQ7XG4gICAgX3RoaXMyLnggPSBfdGhpczIueSA9IF90aGlzMi5yb3RhdGlvbiA9IDA7XG4gICAgX3RoaXMyLmRyYWdSZXNpc3RhbmNlID0gcGFyc2VGbG9hdCh2YXJzLmRyYWdSZXNpc3RhbmNlKSB8fCAwO1xuICAgIF90aGlzMi5lZGdlUmVzaXN0YW5jZSA9IGlzTmFOKHZhcnMuZWRnZVJlc2lzdGFuY2UpID8gMSA6IHBhcnNlRmxvYXQodmFycy5lZGdlUmVzaXN0YW5jZSkgfHwgMDtcbiAgICBfdGhpczIubG9ja0F4aXMgPSB2YXJzLmxvY2tBeGlzO1xuICAgIF90aGlzMi5hdXRvU2Nyb2xsID0gdmFycy5hdXRvU2Nyb2xsIHx8IDA7XG4gICAgX3RoaXMyLmxvY2tlZEF4aXMgPSBudWxsO1xuICAgIF90aGlzMi5hbGxvd0V2ZW50RGVmYXVsdCA9ICEhdmFycy5hbGxvd0V2ZW50RGVmYXVsdDtcbiAgICBnc2FwLmdldFByb3BlcnR5KHRhcmdldCwgXCJ4XCIpOyAvLyB0byBlbnN1cmUgdGhhdCB0cmFuc2Zvcm1zIGFyZSBpbnN0YW50aWF0ZWQuXG5cbiAgICB2YXIgdHlwZSA9ICh2YXJzLnR5cGUgfHwgXCJ4LHlcIikudG9Mb3dlckNhc2UoKSxcbiAgICAgICAgeHlNb2RlID0gfnR5cGUuaW5kZXhPZihcInhcIikgfHwgfnR5cGUuaW5kZXhPZihcInlcIiksXG4gICAgICAgIHJvdGF0aW9uTW9kZSA9IHR5cGUuaW5kZXhPZihcInJvdGF0aW9uXCIpICE9PSAtMSxcbiAgICAgICAgeFByb3AgPSByb3RhdGlvbk1vZGUgPyBcInJvdGF0aW9uXCIgOiB4eU1vZGUgPyBcInhcIiA6IFwibGVmdFwiLFxuICAgICAgICB5UHJvcCA9IHh5TW9kZSA/IFwieVwiIDogXCJ0b3BcIixcbiAgICAgICAgYWxsb3dYID0gISEofnR5cGUuaW5kZXhPZihcInhcIikgfHwgfnR5cGUuaW5kZXhPZihcImxlZnRcIikgfHwgdHlwZSA9PT0gXCJzY3JvbGxcIiksXG4gICAgICAgIGFsbG93WSA9ICEhKH50eXBlLmluZGV4T2YoXCJ5XCIpIHx8IH50eXBlLmluZGV4T2YoXCJ0b3BcIikgfHwgdHlwZSA9PT0gXCJzY3JvbGxcIiksXG4gICAgICAgIG1pbmltdW1Nb3ZlbWVudCA9IHZhcnMubWluaW11bU1vdmVtZW50IHx8IDIsXG4gICAgICAgIHNlbGYgPSBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzMiksXG4gICAgICAgIHRyaWdnZXJzID0gX3RvQXJyYXkodmFycy50cmlnZ2VyIHx8IHZhcnMuaGFuZGxlIHx8IHRhcmdldCksXG4gICAgICAgIGtpbGxQcm9wcyA9IHt9LFxuICAgICAgICBkcmFnRW5kVGltZSA9IDAsXG4gICAgICAgIGNoZWNrQXV0b1Njcm9sbEJvdW5kcyA9IGZhbHNlLFxuICAgICAgICBhdXRvU2Nyb2xsTWFyZ2luVG9wID0gdmFycy5hdXRvU2Nyb2xsTWFyZ2luVG9wIHx8IDQwLFxuICAgICAgICBhdXRvU2Nyb2xsTWFyZ2luUmlnaHQgPSB2YXJzLmF1dG9TY3JvbGxNYXJnaW5SaWdodCB8fCA0MCxcbiAgICAgICAgYXV0b1Njcm9sbE1hcmdpbkJvdHRvbSA9IHZhcnMuYXV0b1Njcm9sbE1hcmdpbkJvdHRvbSB8fCA0MCxcbiAgICAgICAgYXV0b1Njcm9sbE1hcmdpbkxlZnQgPSB2YXJzLmF1dG9TY3JvbGxNYXJnaW5MZWZ0IHx8IDQwLFxuICAgICAgICBpc0NsaWNrYWJsZSA9IHZhcnMuY2xpY2thYmxlVGVzdCB8fCBfaXNDbGlja2FibGUsXG4gICAgICAgIGNsaWNrVGltZSA9IDAsXG4gICAgICAgIGdzQ2FjaGUgPSB0YXJnZXQuX2dzYXAgfHwgZ3NhcC5jb3JlLmdldENhY2hlKHRhcmdldCksXG4gICAgICAgIGlzRml4ZWQgPSBfaXNGaXhlZCh0YXJnZXQpLFxuICAgICAgICBnZXRQcm9wQXNOdW0gPSBmdW5jdGlvbiBnZXRQcm9wQXNOdW0ocHJvcGVydHksIHVuaXQpIHtcbiAgICAgIHJldHVybiBwYXJzZUZsb2F0KGdzQ2FjaGUuZ2V0KHRhcmdldCwgcHJvcGVydHksIHVuaXQpKTtcbiAgICB9LFxuICAgICAgICBvd25lckRvYyA9IHRhcmdldC5vd25lckRvY3VtZW50IHx8IF9kb2MsXG4gICAgICAgIGVuYWJsZWQsXG4gICAgICAgIHNjcm9sbFByb3h5LFxuICAgICAgICBzdGFydFBvaW50ZXJYLFxuICAgICAgICBzdGFydFBvaW50ZXJZLFxuICAgICAgICBzdGFydEVsZW1lbnRYLFxuICAgICAgICBzdGFydEVsZW1lbnRZLFxuICAgICAgICBoYXNCb3VuZHMsXG4gICAgICAgIGhhc0RyYWdDYWxsYmFjayxcbiAgICAgICAgaGFzTW92ZUNhbGxiYWNrLFxuICAgICAgICBtYXhYLFxuICAgICAgICBtaW5YLFxuICAgICAgICBtYXhZLFxuICAgICAgICBtaW5ZLFxuICAgICAgICB0b3VjaCxcbiAgICAgICAgdG91Y2hJRCxcbiAgICAgICAgcm90YXRpb25PcmlnaW4sXG4gICAgICAgIGRpcnR5LFxuICAgICAgICBvbGQsXG4gICAgICAgIHNuYXBYLFxuICAgICAgICBzbmFwWSxcbiAgICAgICAgc25hcFhZLFxuICAgICAgICBpc0NsaWNraW5nLFxuICAgICAgICB0b3VjaEV2ZW50VGFyZ2V0LFxuICAgICAgICBtYXRyaXgsXG4gICAgICAgIGludGVycnVwdGVkLFxuICAgICAgICBhbGxvd05hdGl2ZVRvdWNoU2Nyb2xsaW5nLFxuICAgICAgICB0b3VjaERyYWdBeGlzLFxuICAgICAgICBpc0Rpc3BhdGNoaW5nLFxuICAgICAgICBjbGlja0Rpc3BhdGNoLFxuICAgICAgICB0cnVzdGVkQ2xpY2tEaXNwYXRjaCxcbiAgICAgICAgaXNQcmV2ZW50aW5nRGVmYXVsdCxcbiAgICAgICAgaW5uZXJNYXRyaXgsXG4gICAgICAgIG9uQ29udGV4dE1lbnUgPSBmdW5jdGlvbiBvbkNvbnRleHRNZW51KGUpIHtcbiAgICAgIC8vdXNlZCB0byBwcmV2ZW50IGxvbmctdG91Y2ggZnJvbSB0cmlnZ2VyaW5nIGEgY29udGV4dCBtZW51LlxuICAgICAgLy8gKHNlbGYuaXNQcmVzc2VkICYmIGUud2hpY2ggPCAyKSAmJiBzZWxmLmVuZERyYWcoKSAvLyBwcmV2aW91c2x5IGVuZGVkIGRyYWcgd2hlbiBjb250ZXh0IG1lbnUgd2FzIHRyaWdnZXJlZCwgYnV0IGluc3RlYWQgd2Ugc2hvdWxkIGp1c3Qgc3RvcCBwcm9wYWdhdGlvbiBhbmQgcHJldmVudCB0aGUgZGVmYXVsdCBldmVudCBiZWhhdmlvci5cbiAgICAgIF9wcmV2ZW50RGVmYXVsdChlKTtcblxuICAgICAgZS5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24gJiYgZS5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9LFxuICAgICAgICAvL3RoaXMgbWV0aG9kIGdldHMgY2FsbGVkIG9uIGV2ZXJ5IHRpY2sgb2YgVHdlZW5MaXRlLnRpY2tlciB3aGljaCBhbGxvd3MgdXMgdG8gc3luY2hyb25pemUgdGhlIHJlbmRlcnMgdG8gdGhlIGNvcmUgZW5naW5lICh3aGljaCBpcyB0eXBpY2FsbHkgc3luY2hyb25pemVkIHdpdGggdGhlIGRpc3BsYXkgcmVmcmVzaCB2aWEgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKS4gVGhpcyBpcyBhbiBvcHRpbWl6YXRpb24gLSBpdCdzIGJldHRlciB0aGFuIGFwcGx5aW5nIHRoZSB2YWx1ZXMgaW5zaWRlIHRoZSBcIm1vdXNlbW92ZVwiIG9yIFwidG91Y2htb3ZlXCIgZXZlbnQgaGFuZGxlciB3aGljaCBtYXkgZ2V0IGNhbGxlZCBtYW55IHRpbWVzIGluYmV0d2VlbiByZWZyZXNoZXMuXG4gICAgcmVuZGVyID0gZnVuY3Rpb24gcmVuZGVyKHN1cHByZXNzRXZlbnRzKSB7XG4gICAgICBpZiAoc2VsZi5hdXRvU2Nyb2xsICYmIHNlbGYuaXNEcmFnZ2luZyAmJiAoY2hlY2tBdXRvU2Nyb2xsQm91bmRzIHx8IGRpcnR5KSkge1xuICAgICAgICB2YXIgZSA9IHRhcmdldCxcbiAgICAgICAgICAgIGF1dG9TY3JvbGxGYWN0b3IgPSBzZWxmLmF1dG9TY3JvbGwgKiAxNSxcbiAgICAgICAgICAgIC8vbXVsdGlwbHlpbmcgYnkgMTUganVzdCBnaXZlcyB1cyBhIGJldHRlciBcImZlZWxcIiBzcGVlZC13aXNlLlxuICAgICAgICBwYXJlbnQsXG4gICAgICAgICAgICBpc1Jvb3QsXG4gICAgICAgICAgICByZWN0LFxuICAgICAgICAgICAgcG9pbnRlclgsXG4gICAgICAgICAgICBwb2ludGVyWSxcbiAgICAgICAgICAgIGNoYW5nZVgsXG4gICAgICAgICAgICBjaGFuZ2VZLFxuICAgICAgICAgICAgZ2FwO1xuICAgICAgICBjaGVja0F1dG9TY3JvbGxCb3VuZHMgPSBmYWxzZTtcbiAgICAgICAgX3dpbmRvd1Byb3h5LnNjcm9sbFRvcCA9IF93aW4ucGFnZVlPZmZzZXQgIT0gbnVsbCA/IF93aW4ucGFnZVlPZmZzZXQgOiBvd25lckRvYy5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsVG9wICE9IG51bGwgPyBvd25lckRvYy5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsVG9wIDogb3duZXJEb2MuYm9keS5zY3JvbGxUb3A7XG4gICAgICAgIF93aW5kb3dQcm94eS5zY3JvbGxMZWZ0ID0gX3dpbi5wYWdlWE9mZnNldCAhPSBudWxsID8gX3dpbi5wYWdlWE9mZnNldCA6IG93bmVyRG9jLmRvY3VtZW50RWxlbWVudC5zY3JvbGxMZWZ0ICE9IG51bGwgPyBvd25lckRvYy5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsTGVmdCA6IG93bmVyRG9jLmJvZHkuc2Nyb2xsTGVmdDtcbiAgICAgICAgcG9pbnRlclggPSBzZWxmLnBvaW50ZXJYIC0gX3dpbmRvd1Byb3h5LnNjcm9sbExlZnQ7XG4gICAgICAgIHBvaW50ZXJZID0gc2VsZi5wb2ludGVyWSAtIF93aW5kb3dQcm94eS5zY3JvbGxUb3A7XG5cbiAgICAgICAgd2hpbGUgKGUgJiYgIWlzUm9vdCkge1xuICAgICAgICAgIC8vd2FsayB1cCB0aGUgY2hhaW4gYW5kIHNlbnNlIHdoZXJldmVyIHRoZSBwb2ludGVyIGlzIHdpdGhpbiA0MHB4IG9mIGFuIGVkZ2UgdGhhdCdzIHNjcm9sbGFibGUuXG4gICAgICAgICAgaXNSb290ID0gX2lzUm9vdChlLnBhcmVudE5vZGUpO1xuICAgICAgICAgIHBhcmVudCA9IGlzUm9vdCA/IF93aW5kb3dQcm94eSA6IGUucGFyZW50Tm9kZTtcbiAgICAgICAgICByZWN0ID0gaXNSb290ID8ge1xuICAgICAgICAgICAgYm90dG9tOiBNYXRoLm1heChfZG9jRWxlbWVudC5jbGllbnRIZWlnaHQsIF93aW4uaW5uZXJIZWlnaHQgfHwgMCksXG4gICAgICAgICAgICByaWdodDogTWF0aC5tYXgoX2RvY0VsZW1lbnQuY2xpZW50V2lkdGgsIF93aW4uaW5uZXJXaWR0aCB8fCAwKSxcbiAgICAgICAgICAgIGxlZnQ6IDAsXG4gICAgICAgICAgICB0b3A6IDBcbiAgICAgICAgICB9IDogcGFyZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICAgIGNoYW5nZVggPSBjaGFuZ2VZID0gMDtcblxuICAgICAgICAgIGlmIChhbGxvd1kpIHtcbiAgICAgICAgICAgIGdhcCA9IHBhcmVudC5fZ3NNYXhTY3JvbGxZIC0gcGFyZW50LnNjcm9sbFRvcDtcblxuICAgICAgICAgICAgaWYgKGdhcCA8IDApIHtcbiAgICAgICAgICAgICAgY2hhbmdlWSA9IGdhcDtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAocG9pbnRlclkgPiByZWN0LmJvdHRvbSAtIGF1dG9TY3JvbGxNYXJnaW5Cb3R0b20gJiYgZ2FwKSB7XG4gICAgICAgICAgICAgIGNoZWNrQXV0b1Njcm9sbEJvdW5kcyA9IHRydWU7XG4gICAgICAgICAgICAgIGNoYW5nZVkgPSBNYXRoLm1pbihnYXAsIGF1dG9TY3JvbGxGYWN0b3IgKiAoMSAtIE1hdGgubWF4KDAsIHJlY3QuYm90dG9tIC0gcG9pbnRlclkpIC8gYXV0b1Njcm9sbE1hcmdpbkJvdHRvbSkgfCAwKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAocG9pbnRlclkgPCByZWN0LnRvcCArIGF1dG9TY3JvbGxNYXJnaW5Ub3AgJiYgcGFyZW50LnNjcm9sbFRvcCkge1xuICAgICAgICAgICAgICBjaGVja0F1dG9TY3JvbGxCb3VuZHMgPSB0cnVlO1xuICAgICAgICAgICAgICBjaGFuZ2VZID0gLU1hdGgubWluKHBhcmVudC5zY3JvbGxUb3AsIGF1dG9TY3JvbGxGYWN0b3IgKiAoMSAtIE1hdGgubWF4KDAsIHBvaW50ZXJZIC0gcmVjdC50b3ApIC8gYXV0b1Njcm9sbE1hcmdpblRvcCkgfCAwKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGNoYW5nZVkpIHtcbiAgICAgICAgICAgICAgcGFyZW50LnNjcm9sbFRvcCArPSBjaGFuZ2VZO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChhbGxvd1gpIHtcbiAgICAgICAgICAgIGdhcCA9IHBhcmVudC5fZ3NNYXhTY3JvbGxYIC0gcGFyZW50LnNjcm9sbExlZnQ7XG5cbiAgICAgICAgICAgIGlmIChnYXAgPCAwKSB7XG4gICAgICAgICAgICAgIGNoYW5nZVggPSBnYXA7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHBvaW50ZXJYID4gcmVjdC5yaWdodCAtIGF1dG9TY3JvbGxNYXJnaW5SaWdodCAmJiBnYXApIHtcbiAgICAgICAgICAgICAgY2hlY2tBdXRvU2Nyb2xsQm91bmRzID0gdHJ1ZTtcbiAgICAgICAgICAgICAgY2hhbmdlWCA9IE1hdGgubWluKGdhcCwgYXV0b1Njcm9sbEZhY3RvciAqICgxIC0gTWF0aC5tYXgoMCwgcmVjdC5yaWdodCAtIHBvaW50ZXJYKSAvIGF1dG9TY3JvbGxNYXJnaW5SaWdodCkgfCAwKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAocG9pbnRlclggPCByZWN0LmxlZnQgKyBhdXRvU2Nyb2xsTWFyZ2luTGVmdCAmJiBwYXJlbnQuc2Nyb2xsTGVmdCkge1xuICAgICAgICAgICAgICBjaGVja0F1dG9TY3JvbGxCb3VuZHMgPSB0cnVlO1xuICAgICAgICAgICAgICBjaGFuZ2VYID0gLU1hdGgubWluKHBhcmVudC5zY3JvbGxMZWZ0LCBhdXRvU2Nyb2xsRmFjdG9yICogKDEgLSBNYXRoLm1heCgwLCBwb2ludGVyWCAtIHJlY3QubGVmdCkgLyBhdXRvU2Nyb2xsTWFyZ2luTGVmdCkgfCAwKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGNoYW5nZVgpIHtcbiAgICAgICAgICAgICAgcGFyZW50LnNjcm9sbExlZnQgKz0gY2hhbmdlWDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoaXNSb290ICYmIChjaGFuZ2VYIHx8IGNoYW5nZVkpKSB7XG4gICAgICAgICAgICBfd2luLnNjcm9sbFRvKHBhcmVudC5zY3JvbGxMZWZ0LCBwYXJlbnQuc2Nyb2xsVG9wKTtcblxuICAgICAgICAgICAgc2V0UG9pbnRlclBvc2l0aW9uKHNlbGYucG9pbnRlclggKyBjaGFuZ2VYLCBzZWxmLnBvaW50ZXJZICsgY2hhbmdlWSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZSA9IHBhcmVudDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoZGlydHkpIHtcbiAgICAgICAgdmFyIHggPSBzZWxmLngsXG4gICAgICAgICAgICB5ID0gc2VsZi55O1xuXG4gICAgICAgIGlmIChyb3RhdGlvbk1vZGUpIHtcbiAgICAgICAgICBzZWxmLmRlbHRhWCA9IHggLSBwYXJzZUZsb2F0KGdzQ2FjaGUucm90YXRpb24pO1xuICAgICAgICAgIHNlbGYucm90YXRpb24gPSB4O1xuICAgICAgICAgIGdzQ2FjaGUucm90YXRpb24gPSB4ICsgXCJkZWdcIjtcbiAgICAgICAgICBnc0NhY2hlLnJlbmRlclRyYW5zZm9ybSgxLCBnc0NhY2hlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoc2Nyb2xsUHJveHkpIHtcbiAgICAgICAgICAgIGlmIChhbGxvd1kpIHtcbiAgICAgICAgICAgICAgc2VsZi5kZWx0YVkgPSB5IC0gc2Nyb2xsUHJveHkudG9wKCk7XG4gICAgICAgICAgICAgIHNjcm9sbFByb3h5LnRvcCh5KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGFsbG93WCkge1xuICAgICAgICAgICAgICBzZWxmLmRlbHRhWCA9IHggLSBzY3JvbGxQcm94eS5sZWZ0KCk7XG4gICAgICAgICAgICAgIHNjcm9sbFByb3h5LmxlZnQoeCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIGlmICh4eU1vZGUpIHtcbiAgICAgICAgICAgIGlmIChhbGxvd1kpIHtcbiAgICAgICAgICAgICAgc2VsZi5kZWx0YVkgPSB5IC0gcGFyc2VGbG9hdChnc0NhY2hlLnkpO1xuICAgICAgICAgICAgICBnc0NhY2hlLnkgPSB5ICsgXCJweFwiO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoYWxsb3dYKSB7XG4gICAgICAgICAgICAgIHNlbGYuZGVsdGFYID0geCAtIHBhcnNlRmxvYXQoZ3NDYWNoZS54KTtcbiAgICAgICAgICAgICAgZ3NDYWNoZS54ID0geCArIFwicHhcIjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZ3NDYWNoZS5yZW5kZXJUcmFuc2Zvcm0oMSwgZ3NDYWNoZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChhbGxvd1kpIHtcbiAgICAgICAgICAgICAgc2VsZi5kZWx0YVkgPSB5IC0gcGFyc2VGbG9hdCh0YXJnZXQuc3R5bGUudG9wIHx8IDApO1xuICAgICAgICAgICAgICB0YXJnZXQuc3R5bGUudG9wID0geSArIFwicHhcIjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGFsbG93WCkge1xuICAgICAgICAgICAgICBzZWxmLmRlbHRhWCA9IHggLSBwYXJzZUZsb2F0KHRhcmdldC5zdHlsZS5sZWZ0IHx8IDApO1xuICAgICAgICAgICAgICB0YXJnZXQuc3R5bGUubGVmdCA9IHggKyBcInB4XCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGhhc0RyYWdDYWxsYmFjayAmJiAhc3VwcHJlc3NFdmVudHMgJiYgIWlzRGlzcGF0Y2hpbmcpIHtcbiAgICAgICAgICBpc0Rpc3BhdGNoaW5nID0gdHJ1ZTsgLy9pbiBjYXNlIG9uRHJhZyBoYXMgYW4gdXBkYXRlKCkgY2FsbCAoYXZvaWQgZW5kbGVzcyBsb29wKVxuXG4gICAgICAgICAgaWYgKF9kaXNwYXRjaEV2ZW50KHNlbGYsIFwiZHJhZ1wiLCBcIm9uRHJhZ1wiKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIGlmIChhbGxvd1gpIHtcbiAgICAgICAgICAgICAgc2VsZi54IC09IHNlbGYuZGVsdGFYO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoYWxsb3dZKSB7XG4gICAgICAgICAgICAgIHNlbGYueSAtPSBzZWxmLmRlbHRhWTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmVuZGVyKHRydWUpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlzRGlzcGF0Y2hpbmcgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBkaXJ0eSA9IGZhbHNlO1xuICAgIH0sXG4gICAgICAgIC8vY29waWVzIHRoZSB4L3kgZnJvbSB0aGUgZWxlbWVudCAod2hldGhlciB0aGF0IGJlIHRyYW5zZm9ybXMsIHRvcC9sZWZ0LCBvciBTY3JvbGxQcm94eSdzIHRvcC9sZWZ0KSB0byB0aGUgRHJhZ2dhYmxlJ3MgeCBhbmQgeSAoYW5kIHJvdGF0aW9uIGlmIG5lY2Vzc2FyeSkgcHJvcGVydGllcyBzbyB0aGF0IHRoZXkgcmVmbGVjdCByZWFsaXR5IGFuZCBpdCBhbHNvIChvcHRpb25hbGx5KSBhcHBsaWVzIGFueSBzbmFwcGluZyBuZWNlc3NhcnkuIFRoaXMgaXMgdXNlZCBieSB0aGUgSW5lcnRpYVBsdWdpbiB0d2VlbiBpbiBhbiBvblVwZGF0ZSB0byBlbnN1cmUgdGhpbmdzIGFyZSBzeW5jZWQgYW5kIHNuYXBwZWQuXG4gICAgc3luY1hZID0gZnVuY3Rpb24gc3luY1hZKHNraXBPblVwZGF0ZSwgc2tpcFNuYXApIHtcbiAgICAgIHZhciB4ID0gc2VsZi54LFxuICAgICAgICAgIHkgPSBzZWxmLnksXG4gICAgICAgICAgc25hcHBlZFZhbHVlLFxuICAgICAgICAgIGNzO1xuXG4gICAgICBpZiAoIXRhcmdldC5fZ3NhcCkge1xuICAgICAgICAvL2p1c3QgaW4gY2FzZSB0aGUgX2dzYXAgY2FjaGUgZ290IHdpcGVkLCBsaWtlIGlmIHRoZSB1c2VyIGNhbGxlZCBjbGVhclByb3BzIG9uIHRoZSB0cmFuc2Zvcm0gb3Igc29tZXRoaW5nICh2ZXJ5IHJhcmUpLlxuICAgICAgICBnc0NhY2hlID0gZ3NhcC5jb3JlLmdldENhY2hlKHRhcmdldCk7XG4gICAgICB9XG5cbiAgICAgIGdzQ2FjaGUudW5jYWNoZSAmJiBnc2FwLmdldFByb3BlcnR5KHRhcmdldCwgXCJ4XCIpOyAvLyB0cmlnZ2VyIGEgcmUtY2FjaGVcblxuICAgICAgaWYgKHh5TW9kZSkge1xuICAgICAgICBzZWxmLnggPSBwYXJzZUZsb2F0KGdzQ2FjaGUueCk7XG4gICAgICAgIHNlbGYueSA9IHBhcnNlRmxvYXQoZ3NDYWNoZS55KTtcbiAgICAgIH0gZWxzZSBpZiAocm90YXRpb25Nb2RlKSB7XG4gICAgICAgIHNlbGYueCA9IHNlbGYucm90YXRpb24gPSBwYXJzZUZsb2F0KGdzQ2FjaGUucm90YXRpb24pO1xuICAgICAgfSBlbHNlIGlmIChzY3JvbGxQcm94eSkge1xuICAgICAgICBzZWxmLnkgPSBzY3JvbGxQcm94eS50b3AoKTtcbiAgICAgICAgc2VsZi54ID0gc2Nyb2xsUHJveHkubGVmdCgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2VsZi55ID0gcGFyc2VGbG9hdCh0YXJnZXQuc3R5bGUudG9wIHx8IChjcyA9IF9nZXRDb21wdXRlZFN0eWxlKHRhcmdldCkpICYmIGNzLnRvcCkgfHwgMDtcbiAgICAgICAgc2VsZi54ID0gcGFyc2VGbG9hdCh0YXJnZXQuc3R5bGUubGVmdCB8fCAoY3MgfHwge30pLmxlZnQpIHx8IDA7XG4gICAgICB9XG5cbiAgICAgIGlmICgoc25hcFggfHwgc25hcFkgfHwgc25hcFhZKSAmJiAhc2tpcFNuYXAgJiYgKHNlbGYuaXNEcmFnZ2luZyB8fCBzZWxmLmlzVGhyb3dpbmcpKSB7XG4gICAgICAgIGlmIChzbmFwWFkpIHtcbiAgICAgICAgICBfdGVtcDEueCA9IHNlbGYueDtcbiAgICAgICAgICBfdGVtcDEueSA9IHNlbGYueTtcbiAgICAgICAgICBzbmFwcGVkVmFsdWUgPSBzbmFwWFkoX3RlbXAxKTtcblxuICAgICAgICAgIGlmIChzbmFwcGVkVmFsdWUueCAhPT0gc2VsZi54KSB7XG4gICAgICAgICAgICBzZWxmLnggPSBzbmFwcGVkVmFsdWUueDtcbiAgICAgICAgICAgIGRpcnR5ID0gdHJ1ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoc25hcHBlZFZhbHVlLnkgIT09IHNlbGYueSkge1xuICAgICAgICAgICAgc2VsZi55ID0gc25hcHBlZFZhbHVlLnk7XG4gICAgICAgICAgICBkaXJ0eSA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHNuYXBYKSB7XG4gICAgICAgICAgc25hcHBlZFZhbHVlID0gc25hcFgoc2VsZi54KTtcblxuICAgICAgICAgIGlmIChzbmFwcGVkVmFsdWUgIT09IHNlbGYueCkge1xuICAgICAgICAgICAgc2VsZi54ID0gc25hcHBlZFZhbHVlO1xuXG4gICAgICAgICAgICBpZiAocm90YXRpb25Nb2RlKSB7XG4gICAgICAgICAgICAgIHNlbGYucm90YXRpb24gPSBzbmFwcGVkVmFsdWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGRpcnR5ID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc25hcFkpIHtcbiAgICAgICAgICBzbmFwcGVkVmFsdWUgPSBzbmFwWShzZWxmLnkpO1xuXG4gICAgICAgICAgaWYgKHNuYXBwZWRWYWx1ZSAhPT0gc2VsZi55KSB7XG4gICAgICAgICAgICBzZWxmLnkgPSBzbmFwcGVkVmFsdWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZGlydHkgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGRpcnR5ICYmIHJlbmRlcih0cnVlKTtcblxuICAgICAgaWYgKCFza2lwT25VcGRhdGUpIHtcbiAgICAgICAgc2VsZi5kZWx0YVggPSBzZWxmLnggLSB4O1xuICAgICAgICBzZWxmLmRlbHRhWSA9IHNlbGYueSAtIHk7XG5cbiAgICAgICAgX2Rpc3BhdGNoRXZlbnQoc2VsZiwgXCJ0aHJvd3VwZGF0ZVwiLCBcIm9uVGhyb3dVcGRhdGVcIik7XG4gICAgICB9XG4gICAgfSxcbiAgICAgICAgYnVpbGRTbmFwRnVuYyA9IGZ1bmN0aW9uIGJ1aWxkU25hcEZ1bmMoc25hcCwgbWluLCBtYXgsIGZhY3Rvcikge1xuICAgICAgaWYgKG1pbiA9PSBudWxsKSB7XG4gICAgICAgIG1pbiA9IC1fYmlnTnVtO1xuICAgICAgfVxuXG4gICAgICBpZiAobWF4ID09IG51bGwpIHtcbiAgICAgICAgbWF4ID0gX2JpZ051bTtcbiAgICAgIH1cblxuICAgICAgaWYgKF9pc0Z1bmN0aW9uKHNuYXApKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAobikge1xuICAgICAgICAgIHZhciBlZGdlVG9sZXJhbmNlID0gIXNlbGYuaXNQcmVzc2VkID8gMSA6IDEgLSBzZWxmLmVkZ2VSZXNpc3RhbmNlOyAvL2lmIHdlJ3JlIHR3ZWVuaW5nLCBkaXNhYmxlIHRoZSBlZGdlVG9sZXJhbmNlIGJlY2F1c2UgaXQncyBhbHJlYWR5IGZhY3RvcmVkIGludG8gdGhlIHR3ZWVuaW5nIHZhbHVlcyAod2UgZG9uJ3Qgd2FudCB0byBhcHBseSBpdCBtdWx0aXBsZSB0aW1lcylcblxuICAgICAgICAgIHJldHVybiBzbmFwLmNhbGwoc2VsZiwgbiA+IG1heCA/IG1heCArIChuIC0gbWF4KSAqIGVkZ2VUb2xlcmFuY2UgOiBuIDwgbWluID8gbWluICsgKG4gLSBtaW4pICogZWRnZVRvbGVyYW5jZSA6IG4pICogZmFjdG9yO1xuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICBpZiAoX2lzQXJyYXkoc25hcCkpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChuKSB7XG4gICAgICAgICAgdmFyIGkgPSBzbmFwLmxlbmd0aCxcbiAgICAgICAgICAgICAgY2xvc2VzdCA9IDAsXG4gICAgICAgICAgICAgIGFic0RpZiA9IF9iaWdOdW0sXG4gICAgICAgICAgICAgIHZhbCxcbiAgICAgICAgICAgICAgZGlmO1xuXG4gICAgICAgICAgd2hpbGUgKC0taSA+IC0xKSB7XG4gICAgICAgICAgICB2YWwgPSBzbmFwW2ldO1xuICAgICAgICAgICAgZGlmID0gdmFsIC0gbjtcblxuICAgICAgICAgICAgaWYgKGRpZiA8IDApIHtcbiAgICAgICAgICAgICAgZGlmID0gLWRpZjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGRpZiA8IGFic0RpZiAmJiB2YWwgPj0gbWluICYmIHZhbCA8PSBtYXgpIHtcbiAgICAgICAgICAgICAgY2xvc2VzdCA9IGk7XG4gICAgICAgICAgICAgIGFic0RpZiA9IGRpZjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gc25hcFtjbG9zZXN0XTtcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGlzTmFOKHNuYXApID8gZnVuY3Rpb24gKG4pIHtcbiAgICAgICAgcmV0dXJuIG47XG4gICAgICB9IDogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gc25hcCAqIGZhY3RvcjtcbiAgICAgIH07XG4gICAgfSxcbiAgICAgICAgYnVpbGRQb2ludFNuYXBGdW5jID0gZnVuY3Rpb24gYnVpbGRQb2ludFNuYXBGdW5jKHNuYXAsIG1pblgsIG1heFgsIG1pblksIG1heFksIHJhZGl1cywgZmFjdG9yKSB7XG4gICAgICByYWRpdXMgPSByYWRpdXMgJiYgcmFkaXVzIDwgX2JpZ051bSA/IHJhZGl1cyAqIHJhZGl1cyA6IF9iaWdOdW07IC8vc28gd2UgZG9uJ3QgaGF2ZSB0byBNYXRoLnNxcnQoKSBpbiB0aGUgZnVuY3Rpb25zLiBQZXJmb3JtYW5jZSBvcHRpbWl6YXRpb24uXG5cbiAgICAgIGlmIChfaXNGdW5jdGlvbihzbmFwKSkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHBvaW50KSB7XG4gICAgICAgICAgdmFyIGVkZ2VUb2xlcmFuY2UgPSAhc2VsZi5pc1ByZXNzZWQgPyAxIDogMSAtIHNlbGYuZWRnZVJlc2lzdGFuY2UsXG4gICAgICAgICAgICAgIHggPSBwb2ludC54LFxuICAgICAgICAgICAgICB5ID0gcG9pbnQueSxcbiAgICAgICAgICAgICAgcmVzdWx0LFxuICAgICAgICAgICAgICBkeCxcbiAgICAgICAgICAgICAgZHk7IC8vaWYgd2UncmUgdHdlZW5pbmcsIGRpc2FibGUgdGhlIGVkZ2VUb2xlcmFuY2UgYmVjYXVzZSBpdCdzIGFscmVhZHkgZmFjdG9yZWQgaW50byB0aGUgdHdlZW5pbmcgdmFsdWVzICh3ZSBkb24ndCB3YW50IHRvIGFwcGx5IGl0IG11bHRpcGxlIHRpbWVzKVxuXG4gICAgICAgICAgcG9pbnQueCA9IHggPSB4ID4gbWF4WCA/IG1heFggKyAoeCAtIG1heFgpICogZWRnZVRvbGVyYW5jZSA6IHggPCBtaW5YID8gbWluWCArICh4IC0gbWluWCkgKiBlZGdlVG9sZXJhbmNlIDogeDtcbiAgICAgICAgICBwb2ludC55ID0geSA9IHkgPiBtYXhZID8gbWF4WSArICh5IC0gbWF4WSkgKiBlZGdlVG9sZXJhbmNlIDogeSA8IG1pblkgPyBtaW5ZICsgKHkgLSBtaW5ZKSAqIGVkZ2VUb2xlcmFuY2UgOiB5O1xuICAgICAgICAgIHJlc3VsdCA9IHNuYXAuY2FsbChzZWxmLCBwb2ludCk7XG5cbiAgICAgICAgICBpZiAocmVzdWx0ICE9PSBwb2ludCkge1xuICAgICAgICAgICAgcG9pbnQueCA9IHJlc3VsdC54O1xuICAgICAgICAgICAgcG9pbnQueSA9IHJlc3VsdC55O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChmYWN0b3IgIT09IDEpIHtcbiAgICAgICAgICAgIHBvaW50LnggKj0gZmFjdG9yO1xuICAgICAgICAgICAgcG9pbnQueSAqPSBmYWN0b3I7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHJhZGl1cyA8IF9iaWdOdW0pIHtcbiAgICAgICAgICAgIGR4ID0gcG9pbnQueCAtIHg7XG4gICAgICAgICAgICBkeSA9IHBvaW50LnkgLSB5O1xuXG4gICAgICAgICAgICBpZiAoZHggKiBkeCArIGR5ICogZHkgPiByYWRpdXMpIHtcbiAgICAgICAgICAgICAgcG9pbnQueCA9IHg7XG4gICAgICAgICAgICAgIHBvaW50LnkgPSB5O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBwb2ludDtcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgaWYgKF9pc0FycmF5KHNuYXApKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAocCkge1xuICAgICAgICAgIHZhciBpID0gc25hcC5sZW5ndGgsXG4gICAgICAgICAgICAgIGNsb3Nlc3QgPSAwLFxuICAgICAgICAgICAgICBtaW5EaXN0ID0gX2JpZ051bSxcbiAgICAgICAgICAgICAgeCxcbiAgICAgICAgICAgICAgeSxcbiAgICAgICAgICAgICAgcG9pbnQsXG4gICAgICAgICAgICAgIGRpc3Q7XG5cbiAgICAgICAgICB3aGlsZSAoLS1pID4gLTEpIHtcbiAgICAgICAgICAgIHBvaW50ID0gc25hcFtpXTtcbiAgICAgICAgICAgIHggPSBwb2ludC54IC0gcC54O1xuICAgICAgICAgICAgeSA9IHBvaW50LnkgLSBwLnk7XG4gICAgICAgICAgICBkaXN0ID0geCAqIHggKyB5ICogeTtcblxuICAgICAgICAgICAgaWYgKGRpc3QgPCBtaW5EaXN0KSB7XG4gICAgICAgICAgICAgIGNsb3Nlc3QgPSBpO1xuICAgICAgICAgICAgICBtaW5EaXN0ID0gZGlzdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gbWluRGlzdCA8PSByYWRpdXMgPyBzbmFwW2Nsb3Nlc3RdIDogcDtcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGZ1bmN0aW9uIChuKSB7XG4gICAgICAgIHJldHVybiBuO1xuICAgICAgfTtcbiAgICB9LFxuICAgICAgICBjYWxjdWxhdGVCb3VuZHMgPSBmdW5jdGlvbiBjYWxjdWxhdGVCb3VuZHMoKSB7XG4gICAgICB2YXIgYm91bmRzLCB0YXJnZXRCb3VuZHMsIHNuYXAsIHNuYXBJc1JhdztcbiAgICAgIGhhc0JvdW5kcyA9IGZhbHNlO1xuXG4gICAgICBpZiAoc2Nyb2xsUHJveHkpIHtcbiAgICAgICAgc2Nyb2xsUHJveHkuY2FsaWJyYXRlKCk7XG4gICAgICAgIHNlbGYubWluWCA9IG1pblggPSAtc2Nyb2xsUHJveHkubWF4U2Nyb2xsTGVmdCgpO1xuICAgICAgICBzZWxmLm1pblkgPSBtaW5ZID0gLXNjcm9sbFByb3h5Lm1heFNjcm9sbFRvcCgpO1xuICAgICAgICBzZWxmLm1heFggPSBtYXhYID0gc2VsZi5tYXhZID0gbWF4WSA9IDA7XG4gICAgICAgIGhhc0JvdW5kcyA9IHRydWU7XG4gICAgICB9IGVsc2UgaWYgKCEhdmFycy5ib3VuZHMpIHtcbiAgICAgICAgYm91bmRzID0gX2dldEJvdW5kcyh2YXJzLmJvdW5kcywgdGFyZ2V0LnBhcmVudE5vZGUpOyAvL2NvdWxkIGJlIGEgc2VsZWN0b3IvalF1ZXJ5IG9iamVjdCBvciBhIERPTSBlbGVtZW50IG9yIGEgZ2VuZXJpYyBvYmplY3QgbGlrZSB7dG9wOjAsIGxlZnQ6MTAwLCB3aWR0aDoxMDAwLCBoZWlnaHQ6ODAwfSBvciB7bWluWDoxMDAsIG1heFg6MTEwMCwgbWluWTowLCBtYXhZOjgwMH1cblxuICAgICAgICBpZiAocm90YXRpb25Nb2RlKSB7XG4gICAgICAgICAgc2VsZi5taW5YID0gbWluWCA9IGJvdW5kcy5sZWZ0O1xuICAgICAgICAgIHNlbGYubWF4WCA9IG1heFggPSBib3VuZHMubGVmdCArIGJvdW5kcy53aWR0aDtcbiAgICAgICAgICBzZWxmLm1pblkgPSBtaW5ZID0gc2VsZi5tYXhZID0gbWF4WSA9IDA7XG4gICAgICAgIH0gZWxzZSBpZiAoIV9pc1VuZGVmaW5lZCh2YXJzLmJvdW5kcy5tYXhYKSB8fCAhX2lzVW5kZWZpbmVkKHZhcnMuYm91bmRzLm1heFkpKSB7XG4gICAgICAgICAgYm91bmRzID0gdmFycy5ib3VuZHM7XG4gICAgICAgICAgc2VsZi5taW5YID0gbWluWCA9IGJvdW5kcy5taW5YO1xuICAgICAgICAgIHNlbGYubWluWSA9IG1pblkgPSBib3VuZHMubWluWTtcbiAgICAgICAgICBzZWxmLm1heFggPSBtYXhYID0gYm91bmRzLm1heFg7XG4gICAgICAgICAgc2VsZi5tYXhZID0gbWF4WSA9IGJvdW5kcy5tYXhZO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRhcmdldEJvdW5kcyA9IF9nZXRCb3VuZHModGFyZ2V0LCB0YXJnZXQucGFyZW50Tm9kZSk7XG4gICAgICAgICAgc2VsZi5taW5YID0gbWluWCA9IE1hdGgucm91bmQoZ2V0UHJvcEFzTnVtKHhQcm9wLCBcInB4XCIpICsgYm91bmRzLmxlZnQgLSB0YXJnZXRCb3VuZHMubGVmdCk7XG4gICAgICAgICAgc2VsZi5taW5ZID0gbWluWSA9IE1hdGgucm91bmQoZ2V0UHJvcEFzTnVtKHlQcm9wLCBcInB4XCIpICsgYm91bmRzLnRvcCAtIHRhcmdldEJvdW5kcy50b3ApO1xuICAgICAgICAgIHNlbGYubWF4WCA9IG1heFggPSBNYXRoLnJvdW5kKG1pblggKyAoYm91bmRzLndpZHRoIC0gdGFyZ2V0Qm91bmRzLndpZHRoKSk7XG4gICAgICAgICAgc2VsZi5tYXhZID0gbWF4WSA9IE1hdGgucm91bmQobWluWSArIChib3VuZHMuaGVpZ2h0IC0gdGFyZ2V0Qm91bmRzLmhlaWdodCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG1pblggPiBtYXhYKSB7XG4gICAgICAgICAgc2VsZi5taW5YID0gbWF4WDtcbiAgICAgICAgICBzZWxmLm1heFggPSBtYXhYID0gbWluWDtcbiAgICAgICAgICBtaW5YID0gc2VsZi5taW5YO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG1pblkgPiBtYXhZKSB7XG4gICAgICAgICAgc2VsZi5taW5ZID0gbWF4WTtcbiAgICAgICAgICBzZWxmLm1heFkgPSBtYXhZID0gbWluWTtcbiAgICAgICAgICBtaW5ZID0gc2VsZi5taW5ZO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHJvdGF0aW9uTW9kZSkge1xuICAgICAgICAgIHNlbGYubWluUm90YXRpb24gPSBtaW5YO1xuICAgICAgICAgIHNlbGYubWF4Um90YXRpb24gPSBtYXhYO1xuICAgICAgICB9XG5cbiAgICAgICAgaGFzQm91bmRzID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKHZhcnMubGl2ZVNuYXApIHtcbiAgICAgICAgc25hcCA9IHZhcnMubGl2ZVNuYXAgPT09IHRydWUgPyB2YXJzLnNuYXAgfHwge30gOiB2YXJzLmxpdmVTbmFwO1xuICAgICAgICBzbmFwSXNSYXcgPSBfaXNBcnJheShzbmFwKSB8fCBfaXNGdW5jdGlvbihzbmFwKTtcblxuICAgICAgICBpZiAocm90YXRpb25Nb2RlKSB7XG4gICAgICAgICAgc25hcFggPSBidWlsZFNuYXBGdW5jKHNuYXBJc1JhdyA/IHNuYXAgOiBzbmFwLnJvdGF0aW9uLCBtaW5YLCBtYXhYLCAxKTtcbiAgICAgICAgICBzbmFwWSA9IG51bGw7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKHNuYXAucG9pbnRzKSB7XG4gICAgICAgICAgICBzbmFwWFkgPSBidWlsZFBvaW50U25hcEZ1bmMoc25hcElzUmF3ID8gc25hcCA6IHNuYXAucG9pbnRzLCBtaW5YLCBtYXhYLCBtaW5ZLCBtYXhZLCBzbmFwLnJhZGl1cywgc2Nyb2xsUHJveHkgPyAtMSA6IDEpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoYWxsb3dYKSB7XG4gICAgICAgICAgICAgIHNuYXBYID0gYnVpbGRTbmFwRnVuYyhzbmFwSXNSYXcgPyBzbmFwIDogc25hcC54IHx8IHNuYXAubGVmdCB8fCBzbmFwLnNjcm9sbExlZnQsIG1pblgsIG1heFgsIHNjcm9sbFByb3h5ID8gLTEgOiAxKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGFsbG93WSkge1xuICAgICAgICAgICAgICBzbmFwWSA9IGJ1aWxkU25hcEZ1bmMoc25hcElzUmF3ID8gc25hcCA6IHNuYXAueSB8fCBzbmFwLnRvcCB8fCBzbmFwLnNjcm9sbFRvcCwgbWluWSwgbWF4WSwgc2Nyb2xsUHJveHkgPyAtMSA6IDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgICAgIG9uVGhyb3dDb21wbGV0ZSA9IGZ1bmN0aW9uIG9uVGhyb3dDb21wbGV0ZSgpIHtcbiAgICAgIHNlbGYuaXNUaHJvd2luZyA9IGZhbHNlO1xuXG4gICAgICBfZGlzcGF0Y2hFdmVudChzZWxmLCBcInRocm93Y29tcGxldGVcIiwgXCJvblRocm93Q29tcGxldGVcIik7XG4gICAgfSxcbiAgICAgICAgb25UaHJvd0ludGVycnVwdCA9IGZ1bmN0aW9uIG9uVGhyb3dJbnRlcnJ1cHQoKSB7XG4gICAgICBzZWxmLmlzVGhyb3dpbmcgPSBmYWxzZTtcbiAgICB9LFxuICAgICAgICBhbmltYXRlID0gZnVuY3Rpb24gYW5pbWF0ZShpbmVydGlhLCBmb3JjZVplcm9WZWxvY2l0eSkge1xuICAgICAgdmFyIHNuYXAsIHNuYXBJc1JhdywgdHdlZW4sIG92ZXJzaG9vdFRvbGVyYW5jZTtcblxuICAgICAgaWYgKGluZXJ0aWEgJiYgSW5lcnRpYVBsdWdpbikge1xuICAgICAgICBpZiAoaW5lcnRpYSA9PT0gdHJ1ZSkge1xuICAgICAgICAgIHNuYXAgPSB2YXJzLnNuYXAgfHwgdmFycy5saXZlU25hcCB8fCB7fTtcbiAgICAgICAgICBzbmFwSXNSYXcgPSBfaXNBcnJheShzbmFwKSB8fCBfaXNGdW5jdGlvbihzbmFwKTtcbiAgICAgICAgICBpbmVydGlhID0ge1xuICAgICAgICAgICAgcmVzaXN0YW5jZTogKHZhcnMudGhyb3dSZXNpc3RhbmNlIHx8IHZhcnMucmVzaXN0YW5jZSB8fCAxMDAwKSAvIChyb3RhdGlvbk1vZGUgPyAxMCA6IDEpXG4gICAgICAgICAgfTtcblxuICAgICAgICAgIGlmIChyb3RhdGlvbk1vZGUpIHtcbiAgICAgICAgICAgIGluZXJ0aWEucm90YXRpb24gPSBfcGFyc2VJbmVydGlhKHNlbGYsIHNuYXBJc1JhdyA/IHNuYXAgOiBzbmFwLnJvdGF0aW9uLCBtYXhYLCBtaW5YLCAxLCBmb3JjZVplcm9WZWxvY2l0eSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChhbGxvd1gpIHtcbiAgICAgICAgICAgICAgaW5lcnRpYVt4UHJvcF0gPSBfcGFyc2VJbmVydGlhKHNlbGYsIHNuYXBJc1JhdyA/IHNuYXAgOiBzbmFwLnBvaW50cyB8fCBzbmFwLnggfHwgc25hcC5sZWZ0LCBtYXhYLCBtaW5YLCBzY3JvbGxQcm94eSA/IC0xIDogMSwgZm9yY2VaZXJvVmVsb2NpdHkgfHwgc2VsZi5sb2NrZWRBeGlzID09PSBcInhcIik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChhbGxvd1kpIHtcbiAgICAgICAgICAgICAgaW5lcnRpYVt5UHJvcF0gPSBfcGFyc2VJbmVydGlhKHNlbGYsIHNuYXBJc1JhdyA/IHNuYXAgOiBzbmFwLnBvaW50cyB8fCBzbmFwLnkgfHwgc25hcC50b3AsIG1heFksIG1pblksIHNjcm9sbFByb3h5ID8gLTEgOiAxLCBmb3JjZVplcm9WZWxvY2l0eSB8fCBzZWxmLmxvY2tlZEF4aXMgPT09IFwieVwiKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHNuYXAucG9pbnRzIHx8IF9pc0FycmF5KHNuYXApICYmIF9pc09iamVjdChzbmFwWzBdKSkge1xuICAgICAgICAgICAgICBpbmVydGlhLmxpbmtlZFByb3BzID0geFByb3AgKyBcIixcIiArIHlQcm9wO1xuICAgICAgICAgICAgICBpbmVydGlhLnJhZGl1cyA9IHNuYXAucmFkaXVzOyAvL25vdGU6IHdlIGFsc28gZGlzYWJsZSBsaXZlU25hcHBpbmcgd2hpbGUgdGhyb3dpbmcgaWYgdGhlcmUncyBhIFwicmFkaXVzXCIgZGVmaW5lZCwgb3RoZXJ3aXNlIGl0IGxvb2tzIHdlaXJkIHRvIGhhdmUgdGhlIGl0ZW0gdGhyb3duIHBhc3QgYSBzbmFwcGluZyBwb2ludCBidXQgbGl2ZS1zbmFwcGluZyBtaWQtdHdlZW4uIFdlIGRvIHRoaXMgYnkgYWx0ZXJpbmcgdGhlIG9uVXBkYXRlUGFyYW1zIHNvIHRoYXQgXCJza2lwU25hcFwiIHBhcmFtZXRlciBpcyB0cnVlIGZvciBzeW5jWFkuXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgc2VsZi5pc1Rocm93aW5nID0gdHJ1ZTtcbiAgICAgICAgb3ZlcnNob290VG9sZXJhbmNlID0gIWlzTmFOKHZhcnMub3ZlcnNob290VG9sZXJhbmNlKSA/IHZhcnMub3ZlcnNob290VG9sZXJhbmNlIDogdmFycy5lZGdlUmVzaXN0YW5jZSA9PT0gMSA/IDAgOiAxIC0gc2VsZi5lZGdlUmVzaXN0YW5jZSArIDAuMjtcblxuICAgICAgICBpZiAoIWluZXJ0aWEuZHVyYXRpb24pIHtcbiAgICAgICAgICBpbmVydGlhLmR1cmF0aW9uID0ge1xuICAgICAgICAgICAgbWF4OiBNYXRoLm1heCh2YXJzLm1pbkR1cmF0aW9uIHx8IDAsIFwibWF4RHVyYXRpb25cIiBpbiB2YXJzID8gdmFycy5tYXhEdXJhdGlvbiA6IDIpLFxuICAgICAgICAgICAgbWluOiAhaXNOYU4odmFycy5taW5EdXJhdGlvbikgPyB2YXJzLm1pbkR1cmF0aW9uIDogb3ZlcnNob290VG9sZXJhbmNlID09PSAwIHx8IF9pc09iamVjdChpbmVydGlhKSAmJiBpbmVydGlhLnJlc2lzdGFuY2UgPiAxMDAwID8gMCA6IDAuNSxcbiAgICAgICAgICAgIG92ZXJzaG9vdDogb3ZlcnNob290VG9sZXJhbmNlXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIHNlbGYudHdlZW4gPSB0d2VlbiA9IGdzYXAudG8oc2Nyb2xsUHJveHkgfHwgdGFyZ2V0LCB7XG4gICAgICAgICAgaW5lcnRpYTogaW5lcnRpYSxcbiAgICAgICAgICBkYXRhOiBcIl9kcmFnZ2FibGVcIixcbiAgICAgICAgICBvbkNvbXBsZXRlOiBvblRocm93Q29tcGxldGUsXG4gICAgICAgICAgb25JbnRlcnJ1cHQ6IG9uVGhyb3dJbnRlcnJ1cHQsXG4gICAgICAgICAgb25VcGRhdGU6IHZhcnMuZmFzdE1vZGUgPyBfZGlzcGF0Y2hFdmVudCA6IHN5bmNYWSxcbiAgICAgICAgICBvblVwZGF0ZVBhcmFtczogdmFycy5mYXN0TW9kZSA/IFtzZWxmLCBcIm9udGhyb3d1cGRhdGVcIiwgXCJvblRocm93VXBkYXRlXCJdIDogc25hcCAmJiBzbmFwLnJhZGl1cyA/IFtmYWxzZSwgdHJ1ZV0gOiBbXVxuICAgICAgICB9KTtcblxuICAgICAgICBpZiAoIXZhcnMuZmFzdE1vZGUpIHtcbiAgICAgICAgICBpZiAoc2Nyb2xsUHJveHkpIHtcbiAgICAgICAgICAgIHNjcm9sbFByb3h5Ll9za2lwID0gdHJ1ZTsgLy8gTWljcm9zb2Z0IGJyb3dzZXJzIGhhdmUgYSBidWcgdGhhdCBjYXVzZXMgdGhlbSB0byBicmllZmx5IHJlbmRlciB0aGUgcG9zaXRpb24gaW5jb3JyZWN0bHkgKGl0IGZsYXNoZXMgdG8gdGhlIGVuZCBzdGF0ZSB3aGVuIHdlIHNlZWsoKSB0aGUgdHdlZW4gZXZlbiB0aG91Z2ggd2UganVtcCByaWdodCBiYWNrIHRvIHRoZSBjdXJyZW50IHBvc2l0aW9uLCBhbmQgdGhpcyBvbmx5IHNlZW1zIHRvIGhhcHBlbiB3aGVuIHdlJ3JlIGFmZmVjdGluZyBib3RoIHRvcCBhbmQgbGVmdCksIHNvIHdlIHNldCBhIF9zdXNwZW5kVHJhbnNmb3JtcyBmbGFnIHRvIHByZXZlbnQgaXQgZnJvbSBhY3R1YWxseSBhcHBseWluZyB0aGUgdmFsdWVzIGluIHRoZSBTY3JvbGxQcm94eS5cbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0d2Vlbi5yZW5kZXIoMWU5LCB0cnVlLCB0cnVlKTsgLy8gZm9yY2UgdG8gdGhlIGVuZC4gUmVtZW1iZXIsIHRoZSBkdXJhdGlvbiB3aWxsIGxpa2VseSBjaGFuZ2UgdXBvbiBpbml0dGluZyBiZWNhdXNlIHRoYXQncyB3aGVuIEluZXJ0aWFQbHVnaW4gY2FsY3VsYXRlcyBpdC5cblxuICAgICAgICAgIHN5bmNYWSh0cnVlLCB0cnVlKTtcbiAgICAgICAgICBzZWxmLmVuZFggPSBzZWxmLng7XG4gICAgICAgICAgc2VsZi5lbmRZID0gc2VsZi55O1xuXG4gICAgICAgICAgaWYgKHJvdGF0aW9uTW9kZSkge1xuICAgICAgICAgICAgc2VsZi5lbmRSb3RhdGlvbiA9IHNlbGYueDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0d2Vlbi5wbGF5KDApO1xuICAgICAgICAgIHN5bmNYWSh0cnVlLCB0cnVlKTtcblxuICAgICAgICAgIGlmIChzY3JvbGxQcm94eSkge1xuICAgICAgICAgICAgc2Nyb2xsUHJveHkuX3NraXAgPSBmYWxzZTsgLy9NaWNyb3NvZnQgYnJvd3NlcnMgaGF2ZSBhIGJ1ZyB0aGF0IGNhdXNlcyB0aGVtIHRvIGJyaWVmbHkgcmVuZGVyIHRoZSBwb3NpdGlvbiBpbmNvcnJlY3RseSAoaXQgZmxhc2hlcyB0byB0aGUgZW5kIHN0YXRlIHdoZW4gd2Ugc2VlaygpIHRoZSB0d2VlbiBldmVuIHRob3VnaCB3ZSBqdW1wIHJpZ2h0IGJhY2sgdG8gdGhlIGN1cnJlbnQgcG9zaXRpb24sIGFuZCB0aGlzIG9ubHkgc2VlbXMgdG8gaGFwcGVuIHdoZW4gd2UncmUgYWZmZWN0aW5nIGJvdGggdG9wIGFuZCBsZWZ0KSwgc28gd2Ugc2V0IGEgX3N1c3BlbmRUcmFuc2Zvcm1zIGZsYWcgdG8gcHJldmVudCBpdCBmcm9tIGFjdHVhbGx5IGFwcGx5aW5nIHRoZSB2YWx1ZXMgaW4gdGhlIFNjcm9sbFByb3h5LlxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChoYXNCb3VuZHMpIHtcbiAgICAgICAgc2VsZi5hcHBseUJvdW5kcygpO1xuICAgICAgfVxuICAgIH0sXG4gICAgICAgIHVwZGF0ZU1hdHJpeCA9IGZ1bmN0aW9uIHVwZGF0ZU1hdHJpeChzaGlmdFN0YXJ0KSB7XG4gICAgICB2YXIgc3RhcnQgPSBtYXRyaXgsXG4gICAgICAgICAgcDtcbiAgICAgIG1hdHJpeCA9IGdldEdsb2JhbE1hdHJpeCh0YXJnZXQucGFyZW50Tm9kZSwgdHJ1ZSk7XG5cbiAgICAgIGlmIChzaGlmdFN0YXJ0ICYmIHNlbGYuaXNQcmVzc2VkICYmICFtYXRyaXguZXF1YWxzKHN0YXJ0IHx8IG5ldyBNYXRyaXgyRCgpKSkge1xuICAgICAgICAvL2lmIHRoZSBtYXRyaXggY2hhbmdlcyBXSElMRSB0aGUgZWxlbWVudCBpcyBwcmVzc2VkLCB3ZSBtdXN0IGFkanVzdCB0aGUgc3RhcnRQb2ludGVyWCBhbmQgc3RhcnRQb2ludGVyWSBhY2NvcmRpbmdseSwgc28gd2UgaW52ZXJ0IHRoZSBvcmlnaW5hbCBtYXRyaXggYW5kIGZpZ3VyZSBvdXQgd2hlcmUgdGhlIHBvaW50ZXJYIGFuZCBwb2ludGVyWSB3ZXJlIGluIHRoZSBnbG9iYWwgc3BhY2UsIHRoZW4gYXBwbHkgdGhlIG5ldyBtYXRyaXggdG8gZ2V0IHRoZSB1cGRhdGVkIGNvb3JkaW5hdGVzLlxuICAgICAgICBwID0gc3RhcnQuaW52ZXJzZSgpLmFwcGx5KHtcbiAgICAgICAgICB4OiBzdGFydFBvaW50ZXJYLFxuICAgICAgICAgIHk6IHN0YXJ0UG9pbnRlcllcbiAgICAgICAgfSk7XG4gICAgICAgIG1hdHJpeC5hcHBseShwLCBwKTtcbiAgICAgICAgc3RhcnRQb2ludGVyWCA9IHAueDtcbiAgICAgICAgc3RhcnRQb2ludGVyWSA9IHAueTtcbiAgICAgIH1cblxuICAgICAgaWYgKG1hdHJpeC5lcXVhbHMoX2lkZW50aXR5TWF0cml4KSkge1xuICAgICAgICAvL2lmIHRoZXJlIGFyZSBubyB0cmFuc2Zvcm1zLCB3ZSBjYW4gb3B0aW1pemUgcGVyZm9ybWFuY2UgYnkgbm90IGZhY3RvcmluZyBpbiB0aGUgbWF0cml4XG4gICAgICAgIG1hdHJpeCA9IG51bGw7XG4gICAgICB9XG4gICAgfSxcbiAgICAgICAgcmVjb3JkU3RhcnRQb3NpdGlvbnMgPSBmdW5jdGlvbiByZWNvcmRTdGFydFBvc2l0aW9ucygpIHtcbiAgICAgIHZhciBlZGdlVG9sZXJhbmNlID0gMSAtIHNlbGYuZWRnZVJlc2lzdGFuY2UsXG4gICAgICAgICAgb2Zmc2V0WCA9IGlzRml4ZWQgPyBfZ2V0RG9jU2Nyb2xsTGVmdChvd25lckRvYykgOiAwLFxuICAgICAgICAgIG9mZnNldFkgPSBpc0ZpeGVkID8gX2dldERvY1Njcm9sbFRvcChvd25lckRvYykgOiAwLFxuICAgICAgICAgIHBhcnNlZE9yaWdpbixcbiAgICAgICAgICB4LFxuICAgICAgICAgIHk7XG4gICAgICB1cGRhdGVNYXRyaXgoZmFsc2UpO1xuICAgICAgX3BvaW50MS54ID0gc2VsZi5wb2ludGVyWCAtIG9mZnNldFg7XG4gICAgICBfcG9pbnQxLnkgPSBzZWxmLnBvaW50ZXJZIC0gb2Zmc2V0WTtcbiAgICAgIG1hdHJpeCAmJiBtYXRyaXguYXBwbHkoX3BvaW50MSwgX3BvaW50MSk7XG4gICAgICBzdGFydFBvaW50ZXJYID0gX3BvaW50MS54OyAvL3RyYW5zbGF0ZSB0byBsb2NhbCBjb29yZGluYXRlIHN5c3RlbVxuXG4gICAgICBzdGFydFBvaW50ZXJZID0gX3BvaW50MS55O1xuXG4gICAgICBpZiAoZGlydHkpIHtcbiAgICAgICAgc2V0UG9pbnRlclBvc2l0aW9uKHNlbGYucG9pbnRlclgsIHNlbGYucG9pbnRlclkpO1xuICAgICAgICByZW5kZXIodHJ1ZSk7XG4gICAgICB9XG5cbiAgICAgIGlubmVyTWF0cml4ID0gZ2V0R2xvYmFsTWF0cml4KHRhcmdldCk7XG5cbiAgICAgIGlmIChzY3JvbGxQcm94eSkge1xuICAgICAgICBjYWxjdWxhdGVCb3VuZHMoKTtcbiAgICAgICAgc3RhcnRFbGVtZW50WSA9IHNjcm9sbFByb3h5LnRvcCgpO1xuICAgICAgICBzdGFydEVsZW1lbnRYID0gc2Nyb2xsUHJveHkubGVmdCgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy9pZiB0aGUgZWxlbWVudCBpcyBpbiB0aGUgcHJvY2VzcyBvZiB0d2VlbmluZywgZG9uJ3QgZm9yY2Ugc25hcHBpbmcgdG8gb2NjdXIgYmVjYXVzZSBpdCBjb3VsZCBtYWtlIGl0IGp1bXAuIEltYWdpbmUgdGhlIHVzZXIgdGhyb3dpbmcsIHRoZW4gYmVmb3JlIGl0J3MgZG9uZSwgY2xpY2tpbmcgb24gdGhlIGVsZW1lbnQgaW4gaXRzIGluYmV0d2VlbiBzdGF0ZS5cbiAgICAgICAgaWYgKGlzVHdlZW5pbmcoKSkge1xuICAgICAgICAgIHN5bmNYWSh0cnVlLCB0cnVlKTtcbiAgICAgICAgICBjYWxjdWxhdGVCb3VuZHMoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzZWxmLmFwcGx5Qm91bmRzKCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocm90YXRpb25Nb2RlKSB7XG4gICAgICAgICAgcGFyc2VkT3JpZ2luID0gdGFyZ2V0Lm93bmVyU1ZHRWxlbWVudCA/IFtnc0NhY2hlLnhPcmlnaW4gLSB0YXJnZXQuZ2V0QkJveCgpLngsIGdzQ2FjaGUueU9yaWdpbiAtIHRhcmdldC5nZXRCQm94KCkueV0gOiAoX2dldENvbXB1dGVkU3R5bGUodGFyZ2V0KVtfdHJhbnNmb3JtT3JpZ2luUHJvcF0gfHwgXCIwIDBcIikuc3BsaXQoXCIgXCIpO1xuICAgICAgICAgIHJvdGF0aW9uT3JpZ2luID0gc2VsZi5yb3RhdGlvbk9yaWdpbiA9IGdldEdsb2JhbE1hdHJpeCh0YXJnZXQpLmFwcGx5KHtcbiAgICAgICAgICAgIHg6IHBhcnNlRmxvYXQocGFyc2VkT3JpZ2luWzBdKSB8fCAwLFxuICAgICAgICAgICAgeTogcGFyc2VGbG9hdChwYXJzZWRPcmlnaW5bMV0pIHx8IDBcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBzeW5jWFkodHJ1ZSwgdHJ1ZSk7XG4gICAgICAgICAgeCA9IHNlbGYucG9pbnRlclggLSByb3RhdGlvbk9yaWdpbi54IC0gb2Zmc2V0WDtcbiAgICAgICAgICB5ID0gcm90YXRpb25PcmlnaW4ueSAtIHNlbGYucG9pbnRlclkgKyBvZmZzZXRZO1xuICAgICAgICAgIHN0YXJ0RWxlbWVudFggPSBzZWxmLng7IC8vc3RhcnRpbmcgcm90YXRpb24gKHggYWx3YXlzIHJlZmVycyB0byByb3RhdGlvbiBpbiB0eXBlOlwicm90YXRpb25cIiwgbWVhc3VyZWQgaW4gZGVncmVlcylcblxuICAgICAgICAgIHN0YXJ0RWxlbWVudFkgPSBzZWxmLnkgPSBNYXRoLmF0YW4yKHksIHgpICogX1JBRDJERUc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy9wYXJlbnQgPSAhaXNGaXhlZCAmJiB0YXJnZXQucGFyZW50Tm9kZTtcbiAgICAgICAgICAvL3N0YXJ0U2Nyb2xsVG9wID0gcGFyZW50ID8gcGFyZW50LnNjcm9sbFRvcCB8fCAwIDogMDtcbiAgICAgICAgICAvL3N0YXJ0U2Nyb2xsTGVmdCA9IHBhcmVudCA/IHBhcmVudC5zY3JvbGxMZWZ0IHx8IDAgOiAwO1xuICAgICAgICAgIHN0YXJ0RWxlbWVudFkgPSBnZXRQcm9wQXNOdW0oeVByb3AsIFwicHhcIik7IC8vcmVjb3JkIHRoZSBzdGFydGluZyB0b3AgYW5kIGxlZnQgdmFsdWVzIHNvIHRoYXQgd2UgY2FuIGp1c3QgYWRkIHRoZSBtb3VzZSdzIG1vdmVtZW50IHRvIHRoZW0gbGF0ZXIuXG5cbiAgICAgICAgICBzdGFydEVsZW1lbnRYID0gZ2V0UHJvcEFzTnVtKHhQcm9wLCBcInB4XCIpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChoYXNCb3VuZHMgJiYgZWRnZVRvbGVyYW5jZSkge1xuICAgICAgICBpZiAoc3RhcnRFbGVtZW50WCA+IG1heFgpIHtcbiAgICAgICAgICBzdGFydEVsZW1lbnRYID0gbWF4WCArIChzdGFydEVsZW1lbnRYIC0gbWF4WCkgLyBlZGdlVG9sZXJhbmNlO1xuICAgICAgICB9IGVsc2UgaWYgKHN0YXJ0RWxlbWVudFggPCBtaW5YKSB7XG4gICAgICAgICAgc3RhcnRFbGVtZW50WCA9IG1pblggLSAobWluWCAtIHN0YXJ0RWxlbWVudFgpIC8gZWRnZVRvbGVyYW5jZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghcm90YXRpb25Nb2RlKSB7XG4gICAgICAgICAgaWYgKHN0YXJ0RWxlbWVudFkgPiBtYXhZKSB7XG4gICAgICAgICAgICBzdGFydEVsZW1lbnRZID0gbWF4WSArIChzdGFydEVsZW1lbnRZIC0gbWF4WSkgLyBlZGdlVG9sZXJhbmNlO1xuICAgICAgICAgIH0gZWxzZSBpZiAoc3RhcnRFbGVtZW50WSA8IG1pblkpIHtcbiAgICAgICAgICAgIHN0YXJ0RWxlbWVudFkgPSBtaW5ZIC0gKG1pblkgLSBzdGFydEVsZW1lbnRZKSAvIGVkZ2VUb2xlcmFuY2U7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHNlbGYuc3RhcnRYID0gc3RhcnRFbGVtZW50WCA9IF9yb3VuZChzdGFydEVsZW1lbnRYKTtcbiAgICAgIHNlbGYuc3RhcnRZID0gc3RhcnRFbGVtZW50WSA9IF9yb3VuZChzdGFydEVsZW1lbnRZKTtcbiAgICB9LFxuICAgICAgICBpc1R3ZWVuaW5nID0gZnVuY3Rpb24gaXNUd2VlbmluZygpIHtcbiAgICAgIHJldHVybiBzZWxmLnR3ZWVuICYmIHNlbGYudHdlZW4uaXNBY3RpdmUoKTtcbiAgICB9LFxuICAgICAgICByZW1vdmVQbGFjZWhvbGRlciA9IGZ1bmN0aW9uIHJlbW92ZVBsYWNlaG9sZGVyKCkge1xuICAgICAgaWYgKF9wbGFjZWhvbGRlckRpdi5wYXJlbnROb2RlICYmICFpc1R3ZWVuaW5nKCkgJiYgIXNlbGYuaXNEcmFnZ2luZykge1xuICAgICAgICAvL19wbGFjZWhvbGRlckRpdiBqdXN0IHByb3BzIG9wZW4gYXV0by1zY3JvbGxpbmcgY29udGFpbmVycyBzbyB0aGV5IGRvbid0IGNvbGxhcHNlIGFzIHRoZSB1c2VyIGRyYWdzIGxlZnQvdXAuIFdlIHJlbW92ZSBpdCBhZnRlciBkcmFnZ2luZyAoYW5kIHRocm93aW5nLCBpZiBuZWNlc3NhcnkpIGZpbmlzaGVzLlxuICAgICAgICBfcGxhY2Vob2xkZXJEaXYucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChfcGxhY2Vob2xkZXJEaXYpO1xuICAgICAgfVxuICAgIH0sXG4gICAgICAgIC8vY2FsbGVkIHdoZW4gdGhlIG1vdXNlIGlzIHByZXNzZWQgKG9yIHRvdWNoIHN0YXJ0cylcbiAgICBvblByZXNzID0gZnVuY3Rpb24gb25QcmVzcyhlLCBmb3JjZSkge1xuICAgICAgdmFyIGk7XG5cbiAgICAgIGlmICghZW5hYmxlZCB8fCBzZWxmLmlzUHJlc3NlZCB8fCAhZSB8fCAoZS50eXBlID09PSBcIm1vdXNlZG93blwiIHx8IGUudHlwZSA9PT0gXCJwb2ludGVyZG93blwiKSAmJiAhZm9yY2UgJiYgX2dldFRpbWUoKSAtIGNsaWNrVGltZSA8IDMwICYmIF90b3VjaEV2ZW50TG9va3VwW3NlbGYucG9pbnRlckV2ZW50LnR5cGVdKSB7XG4gICAgICAgIC8vd2hlbiB3ZSBET04nVCBwcmV2ZW50RGVmYXVsdCgpIGluIG9yZGVyIHRvIGFjY29tbW9kYXRlIHRvdWNoLXNjcm9sbGluZyBhbmQgdGhlIHVzZXIganVzdCB0YXBzLCBtYW55IGJyb3dzZXJzIGFsc28gZmlyZSBhIG1vdXNlZG93bi9tb3VzZXVwIHNlcXVlbmNlIEFGVEVSIHRoZSB0b3VjaHN0YXJ0L3RvdWNoZW5kIHNlcXVlbmNlLCB0aHVzIGl0J2QgcmVzdWx0IGluIHR3byBxdWljayBcImNsaWNrXCIgZXZlbnRzIGJlaW5nIGRpc3BhdGNoZWQuIFRoaXMgbGluZSBzZW5zZXMgdGhhdCBjb25kaXRpb24gYW5kIGhhbHRzIGl0IG9uIHRoZSBzdWJzZXF1ZW50IG1vdXNlZG93bi5cbiAgICAgICAgaXNQcmV2ZW50aW5nRGVmYXVsdCAmJiBlICYmIGVuYWJsZWQgJiYgX3ByZXZlbnREZWZhdWx0KGUpOyAvLyBpbiBzb21lIGJyb3dzZXJzLCB3ZSBtdXN0IGxpc3RlbiBmb3IgbXVsdGlwbGUgZXZlbnQgdHlwZXMgbGlrZSB0b3VjaHN0YXJ0LCBwb2ludGVyZG93biwgbW91c2Vkb3duLiBUaGUgZmlyc3QgdGltZSB0aGlzIGZ1bmN0aW9uIGlzIGNhbGxlZCwgd2UgcmVjb3JkIHdoZXRoZXIgb3Igbm90IHdlIF9wcmV2ZW50RGVmYXVsdCgpIHNvIHRoYXQgb24gZHVwbGljYXRlIGNhbGxzLCB3ZSBjYW4gZG8gdGhlIHNhbWUgaWYgbmVjZXNzYXJ5LlxuXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaW50ZXJydXB0ZWQgPSBpc1R3ZWVuaW5nKCk7XG4gICAgICBzZWxmLnBvaW50ZXJFdmVudCA9IGU7XG5cbiAgICAgIGlmIChfdG91Y2hFdmVudExvb2t1cFtlLnR5cGVdKSB7XG4gICAgICAgIC8vbm90ZTogb24gaU9TLCBCT1RIIHRvdWNobW92ZSBhbmQgbW91c2Vtb3ZlIGFyZSBkaXNwYXRjaGVkLCBidXQgdGhlIG1vdXNlbW92ZSBoYXMgcGFnZVkgYW5kIHBhZ2VYIG9mIDAgd2hpY2ggd291bGQgbWVzcyB1cCB0aGUgY2FsY3VsYXRpb25zIGFuZCBuZWVkbGVzc2x5IGh1cnQgcGVyZm9ybWFuY2UuXG4gICAgICAgIHRvdWNoRXZlbnRUYXJnZXQgPSB+ZS50eXBlLmluZGV4T2YoXCJ0b3VjaFwiKSA/IGUuY3VycmVudFRhcmdldCB8fCBlLnRhcmdldCA6IG93bmVyRG9jOyAvL3BvaW50ZXItYmFzZWQgdG91Y2hlcyAoZm9yIE1pY3Jvc29mdCBicm93c2VycykgZG9uJ3QgcmVtYWluIGxvY2tlZCB0byB0aGUgb3JpZ2luYWwgdGFyZ2V0IGxpa2Ugb3RoZXIgYnJvd3NlcnMsIHNvIHdlIG11c3QgdXNlIHRoZSBkb2N1bWVudCBpbnN0ZWFkLiBUaGUgZXZlbnQgdHlwZSB3b3VsZCBiZSBcIk1TUG9pbnRlckRvd25cIiBvciBcInBvaW50ZXJkb3duXCIuXG5cbiAgICAgICAgX2FkZExpc3RlbmVyKHRvdWNoRXZlbnRUYXJnZXQsIFwidG91Y2hlbmRcIiwgb25SZWxlYXNlKTtcblxuICAgICAgICBfYWRkTGlzdGVuZXIodG91Y2hFdmVudFRhcmdldCwgXCJ0b3VjaG1vdmVcIiwgb25Nb3ZlKTsgLy8gcG9zc2libGUgZnV0dXJlIGNoYW5nZSBpZiBQb2ludGVyRXZlbnRzIGFyZSBtb3JlIHN0YW5kYXJkaXplZDogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0VsZW1lbnQvc2V0UG9pbnRlckNhcHR1cmVcblxuXG4gICAgICAgIF9hZGRMaXN0ZW5lcih0b3VjaEV2ZW50VGFyZ2V0LCBcInRvdWNoY2FuY2VsXCIsIG9uUmVsZWFzZSk7XG5cbiAgICAgICAgX2FkZExpc3RlbmVyKG93bmVyRG9jLCBcInRvdWNoc3RhcnRcIiwgX29uTXVsdGlUb3VjaERvY3VtZW50KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRvdWNoRXZlbnRUYXJnZXQgPSBudWxsO1xuXG4gICAgICAgIF9hZGRMaXN0ZW5lcihvd25lckRvYywgXCJtb3VzZW1vdmVcIiwgb25Nb3ZlKTsgLy9hdHRhY2ggdGhlc2UgdG8gdGhlIGRvY3VtZW50IGluc3RlYWQgb2YgdGhlIGJveCBpdHNlbGYgc28gdGhhdCBpZiB0aGUgdXNlcidzIG1vdXNlIG1vdmVzIHRvbyBxdWlja2x5IChhbmQgb2ZmIG9mIHRoZSBib3gpLCB0aGluZ3Mgc3RpbGwgd29yay5cblxuICAgICAgfVxuXG4gICAgICB0b3VjaERyYWdBeGlzID0gbnVsbDtcblxuICAgICAgaWYgKCFfc3VwcG9ydHNQb2ludGVyIHx8ICF0b3VjaEV2ZW50VGFyZ2V0KSB7XG4gICAgICAgIF9hZGRMaXN0ZW5lcihvd25lckRvYywgXCJtb3VzZXVwXCIsIG9uUmVsZWFzZSk7XG5cbiAgICAgICAgZSAmJiBlLnRhcmdldCAmJiBfYWRkTGlzdGVuZXIoZS50YXJnZXQsIFwibW91c2V1cFwiLCBvblJlbGVhc2UpOyAvL3dlIGFsc28gaGF2ZSB0byBsaXN0ZW4gZGlyZWN0bHkgb24gdGhlIGVsZW1lbnQgYmVjYXVzZSBzb21lIGJyb3dzZXJzIGRvbid0IGJ1YmJsZSB1cCB0aGUgZXZlbnQgdG8gdGhlIF9kb2Mgb24gZWxlbWVudHMgd2l0aCBjb250ZW50RWRpdGFibGU9XCJ0cnVlXCJcbiAgICAgIH1cblxuICAgICAgaXNDbGlja2luZyA9IGlzQ2xpY2thYmxlLmNhbGwoc2VsZiwgZS50YXJnZXQpICYmIHZhcnMuZHJhZ0NsaWNrYWJsZXMgPT09IGZhbHNlICYmICFmb3JjZTtcblxuICAgICAgaWYgKGlzQ2xpY2tpbmcpIHtcbiAgICAgICAgX2FkZExpc3RlbmVyKGUudGFyZ2V0LCBcImNoYW5nZVwiLCBvblJlbGVhc2UpOyAvL2luIHNvbWUgYnJvd3NlcnMsIHdoZW4geW91IG1vdXNlZG93biBvbiBhIDxzZWxlY3Q+IGVsZW1lbnQsIG5vIG1vdXNldXAgZ2V0cyBkaXNwYXRjaGVkISBTbyB3ZSBsaXN0ZW4gZm9yIGEgXCJjaGFuZ2VcIiBldmVudCBpbnN0ZWFkLlxuXG5cbiAgICAgICAgX2Rpc3BhdGNoRXZlbnQoc2VsZiwgXCJwcmVzc0luaXRcIiwgXCJvblByZXNzSW5pdFwiKTtcblxuICAgICAgICBfZGlzcGF0Y2hFdmVudChzZWxmLCBcInByZXNzXCIsIFwib25QcmVzc1wiKTtcblxuICAgICAgICBfc2V0U2VsZWN0YWJsZSh0cmlnZ2VycywgdHJ1ZSk7IC8vYWNjb21tb2RhdGVzIHRoaW5ncyBsaWtlIGlucHV0cyBhbmQgZWxlbWVudHMgd2l0aCBjb250ZW50RWRpdGFibGU9XCJ0cnVlXCIgKG90aGVyd2lzZSB1c2VyIGNvdWxkbid0IGRyYWcgdG8gc2VsZWN0IHRleHQpXG5cblxuICAgICAgICBpc1ByZXZlbnRpbmdEZWZhdWx0ID0gZmFsc2U7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgYWxsb3dOYXRpdmVUb3VjaFNjcm9sbGluZyA9ICF0b3VjaEV2ZW50VGFyZ2V0IHx8IGFsbG93WCA9PT0gYWxsb3dZIHx8IHNlbGYudmFycy5hbGxvd05hdGl2ZVRvdWNoU2Nyb2xsaW5nID09PSBmYWxzZSB8fCBzZWxmLnZhcnMuYWxsb3dDb250ZXh0TWVudSAmJiBlICYmIChlLmN0cmxLZXkgfHwgZS53aGljaCA+IDIpID8gZmFsc2UgOiBhbGxvd1ggPyBcInlcIiA6IFwieFwiOyAvL25vdGU6IGluIENocm9tZSwgcmlnaHQtY2xpY2tpbmcgKGZvciBhIGNvbnRleHQgbWVudSkgZmlyZXMgb25QcmVzcyBhbmQgaXQgZG9lc24ndCBoYXZlIHRoZSBldmVudC53aGljaCBzZXQgcHJvcGVybHksIHNvIHdlIG11c3QgbG9vayBmb3IgZXZlbnQuY3RybEtleS4gSWYgdGhlIHVzZXIgd2FudHMgdG8gYWxsb3cgY29udGV4dCBtZW51cyB3ZSBzaG91bGQgb2YgY291cnNlIHNlbnNlIGl0IGhlcmUgYW5kIG5vdCBhbGxvdyBuYXRpdmUgdG91Y2ggc2Nyb2xsaW5nLlxuXG4gICAgICBpc1ByZXZlbnRpbmdEZWZhdWx0ID0gIWFsbG93TmF0aXZlVG91Y2hTY3JvbGxpbmcgJiYgIXNlbGYuYWxsb3dFdmVudERlZmF1bHQ7XG5cbiAgICAgIGlmIChpc1ByZXZlbnRpbmdEZWZhdWx0KSB7XG4gICAgICAgIF9wcmV2ZW50RGVmYXVsdChlKTtcblxuICAgICAgICBfYWRkTGlzdGVuZXIoX3dpbiwgXCJ0b3VjaGZvcmNlY2hhbmdlXCIsIF9wcmV2ZW50RGVmYXVsdCk7IC8vd29ya3MgYXJvdW5kIHNhZmFyaSBidWc6IGh0dHBzOi8vZ3JlZW5zb2NrLmNvbS9mb3J1bXMvdG9waWMvMjE0NTAtZHJhZ2dhYmxlLWluLWlmcmFtZS1vbi1tb2JpbGUtaXMtYnVnZ3kvXG5cbiAgICAgIH1cblxuICAgICAgaWYgKGUuY2hhbmdlZFRvdWNoZXMpIHtcbiAgICAgICAgLy90b3VjaCBldmVudHMgc3RvcmUgdGhlIGRhdGEgc2xpZ2h0bHkgZGlmZmVyZW50bHlcbiAgICAgICAgZSA9IHRvdWNoID0gZS5jaGFuZ2VkVG91Y2hlc1swXTtcbiAgICAgICAgdG91Y2hJRCA9IGUuaWRlbnRpZmllcjtcbiAgICAgIH0gZWxzZSBpZiAoZS5wb2ludGVySWQpIHtcbiAgICAgICAgdG91Y2hJRCA9IGUucG9pbnRlcklkOyAvL2ZvciBzb21lIE1pY3Jvc29mdCBicm93c2Vyc1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdG91Y2ggPSB0b3VjaElEID0gbnVsbDtcbiAgICAgIH1cblxuICAgICAgX2RyYWdDb3VudCsrO1xuXG4gICAgICBfYWRkVG9SZW5kZXJRdWV1ZShyZW5kZXIpOyAvL2NhdXNlcyB0aGUgRHJhZ2dhYmxlIHRvIHJlbmRlciBvbiBlYWNoIFwidGlja1wiIG9mIFR3ZWVuTGl0ZS50aWNrZXIgKHBlcmZvcm1hbmNlIG9wdGltaXphdGlvbiAtIHVwZGF0aW5nIHZhbHVlcyBpbiBhIG1vdXNlbW92ZSBjYW4gY2F1c2UgdGhlbSB0byBoYXBwZW4gdG9vIGZyZXF1ZW50bHksIGxpa2UgbXVsdGlwbGUgdGltZXMgYmV0d2VlbiBmcmFtZSByZWRyYXdzIHdoaWNoIGlzIHdhc3RlZnVsLCBhbmQgaXQgYWxzbyBwcmV2ZW50cyB2YWx1ZXMgZnJvbSB1cGRhdGluZyBwcm9wZXJseSBpbiBJRTgpXG5cblxuICAgICAgc3RhcnRQb2ludGVyWSA9IHNlbGYucG9pbnRlclkgPSBlLnBhZ2VZOyAvL3JlY29yZCB0aGUgc3RhcnRpbmcgeCBhbmQgeSBzbyB0aGF0IHdlIGNhbiBjYWxjdWxhdGUgdGhlIG1vdmVtZW50IGZyb20gdGhlIG9yaWdpbmFsIGluIF9vbk1vdXNlTW92ZVxuXG4gICAgICBzdGFydFBvaW50ZXJYID0gc2VsZi5wb2ludGVyWCA9IGUucGFnZVg7XG5cbiAgICAgIF9kaXNwYXRjaEV2ZW50KHNlbGYsIFwicHJlc3NJbml0XCIsIFwib25QcmVzc0luaXRcIik7XG5cbiAgICAgIGlmIChhbGxvd05hdGl2ZVRvdWNoU2Nyb2xsaW5nIHx8IHNlbGYuYXV0b1Njcm9sbCkge1xuICAgICAgICBfcmVjb3JkTWF4U2Nyb2xscyh0YXJnZXQucGFyZW50Tm9kZSk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0YXJnZXQucGFyZW50Tm9kZSAmJiBzZWxmLmF1dG9TY3JvbGwgJiYgIXNjcm9sbFByb3h5ICYmICFyb3RhdGlvbk1vZGUgJiYgdGFyZ2V0LnBhcmVudE5vZGUuX2dzTWF4U2Nyb2xsWCAmJiAhX3BsYWNlaG9sZGVyRGl2LnBhcmVudE5vZGUgJiYgIXRhcmdldC5nZXRCQm94KSB7XG4gICAgICAgIC8vYWRkIGEgcGxhY2Vob2xkZXIgZGl2IHRvIHByZXZlbnQgdGhlIHBhcmVudCBjb250YWluZXIgZnJvbSBjb2xsYXBzaW5nIHdoZW4gdGhlIHVzZXIgZHJhZ3MgdGhlIGVsZW1lbnQgbGVmdC5cbiAgICAgICAgX3BsYWNlaG9sZGVyRGl2LnN0eWxlLndpZHRoID0gdGFyZ2V0LnBhcmVudE5vZGUuc2Nyb2xsV2lkdGggKyBcInB4XCI7XG4gICAgICAgIHRhcmdldC5wYXJlbnROb2RlLmFwcGVuZENoaWxkKF9wbGFjZWhvbGRlckRpdik7XG4gICAgICB9XG5cbiAgICAgIHJlY29yZFN0YXJ0UG9zaXRpb25zKCk7XG4gICAgICBzZWxmLnR3ZWVuICYmIHNlbGYudHdlZW4ua2lsbCgpO1xuICAgICAgc2VsZi5pc1Rocm93aW5nID0gZmFsc2U7XG4gICAgICBnc2FwLmtpbGxUd2VlbnNPZihzY3JvbGxQcm94eSB8fCB0YXJnZXQsIGtpbGxQcm9wcywgdHJ1ZSk7IC8vaW4gY2FzZSB0aGUgdXNlciB0cmllcyB0byBkcmFnIGl0IGJlZm9yZSB0aGUgbGFzdCB0d2VlbiBpcyBkb25lLlxuXG4gICAgICBzY3JvbGxQcm94eSAmJiBnc2FwLmtpbGxUd2VlbnNPZih0YXJnZXQsIHtcbiAgICAgICAgc2Nyb2xsVG86IDFcbiAgICAgIH0sIHRydWUpOyAvL2p1c3QgaW4gY2FzZSB0aGUgb3JpZ2luYWwgdGFyZ2V0J3Mgc2Nyb2xsIHBvc2l0aW9uIGlzIGJlaW5nIHR3ZWVuZWQgc29tZXdoZXJlIGVsc2UuXG5cbiAgICAgIHNlbGYudHdlZW4gPSBzZWxmLmxvY2tlZEF4aXMgPSBudWxsO1xuXG4gICAgICBpZiAodmFycy56SW5kZXhCb29zdCB8fCAhcm90YXRpb25Nb2RlICYmICFzY3JvbGxQcm94eSAmJiB2YXJzLnpJbmRleEJvb3N0ICE9PSBmYWxzZSkge1xuICAgICAgICB0YXJnZXQuc3R5bGUuekluZGV4ID0gRHJhZ2dhYmxlLnpJbmRleCsrO1xuICAgICAgfVxuXG4gICAgICBzZWxmLmlzUHJlc3NlZCA9IHRydWU7XG4gICAgICBoYXNEcmFnQ2FsbGJhY2sgPSAhISh2YXJzLm9uRHJhZyB8fCBzZWxmLl9saXN0ZW5lcnMuZHJhZyk7XG4gICAgICBoYXNNb3ZlQ2FsbGJhY2sgPSAhISh2YXJzLm9uTW92ZSB8fCBzZWxmLl9saXN0ZW5lcnMubW92ZSk7XG5cbiAgICAgIGlmICh2YXJzLmN1cnNvciAhPT0gZmFsc2UgfHwgdmFycy5hY3RpdmVDdXJzb3IpIHtcbiAgICAgICAgaSA9IHRyaWdnZXJzLmxlbmd0aDtcblxuICAgICAgICB3aGlsZSAoLS1pID4gLTEpIHtcbiAgICAgICAgICBnc2FwLnNldCh0cmlnZ2Vyc1tpXSwge1xuICAgICAgICAgICAgY3Vyc29yOiB2YXJzLmFjdGl2ZUN1cnNvciB8fCB2YXJzLmN1cnNvciB8fCAoX2RlZmF1bHRDdXJzb3IgPT09IFwiZ3JhYlwiID8gXCJncmFiYmluZ1wiIDogX2RlZmF1bHRDdXJzb3IpXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgX2Rpc3BhdGNoRXZlbnQoc2VsZiwgXCJwcmVzc1wiLCBcIm9uUHJlc3NcIik7XG4gICAgfSxcbiAgICAgICAgLy9jYWxsZWQgZXZlcnkgdGltZSB0aGUgbW91c2UvdG91Y2ggbW92ZXNcbiAgICBvbk1vdmUgPSBmdW5jdGlvbiBvbk1vdmUoZSkge1xuICAgICAgdmFyIG9yaWdpbmFsRXZlbnQgPSBlLFxuICAgICAgICAgIHRvdWNoZXMsXG4gICAgICAgICAgcG9pbnRlclgsXG4gICAgICAgICAgcG9pbnRlclksXG4gICAgICAgICAgaSxcbiAgICAgICAgICBkeCxcbiAgICAgICAgICBkeTtcblxuICAgICAgaWYgKCFlbmFibGVkIHx8IF9pc011bHRpVG91Y2hpbmcgfHwgIXNlbGYuaXNQcmVzc2VkIHx8ICFlKSB7XG4gICAgICAgIGlzUHJldmVudGluZ0RlZmF1bHQgJiYgZSAmJiBlbmFibGVkICYmIF9wcmV2ZW50RGVmYXVsdChlKTsgLy8gaW4gc29tZSBicm93c2Vycywgd2UgbXVzdCBsaXN0ZW4gZm9yIG11bHRpcGxlIGV2ZW50IHR5cGVzIGxpa2UgdG91Y2htb3ZlLCBwb2ludGVybW92ZSwgbW91c2Vtb3ZlLiBUaGUgZmlyc3QgdGltZSB0aGlzIGZ1bmN0aW9uIGlzIGNhbGxlZCwgd2UgcmVjb3JkIHdoZXRoZXIgb3Igbm90IHdlIF9wcmV2ZW50RGVmYXVsdCgpIHNvIHRoYXQgb24gZHVwbGljYXRlIGNhbGxzLCB3ZSBjYW4gZG8gdGhlIHNhbWUgaWYgbmVjZXNzYXJ5LlxuXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgc2VsZi5wb2ludGVyRXZlbnQgPSBlO1xuICAgICAgdG91Y2hlcyA9IGUuY2hhbmdlZFRvdWNoZXM7XG5cbiAgICAgIGlmICh0b3VjaGVzKSB7XG4gICAgICAgIC8vdG91Y2ggZXZlbnRzIHN0b3JlIHRoZSBkYXRhIHNsaWdodGx5IGRpZmZlcmVudGx5XG4gICAgICAgIGUgPSB0b3VjaGVzWzBdO1xuXG4gICAgICAgIGlmIChlICE9PSB0b3VjaCAmJiBlLmlkZW50aWZpZXIgIT09IHRvdWNoSUQpIHtcbiAgICAgICAgICAvL1VzdWFsbHkgY2hhbmdlZFRvdWNoZXNbMF0gd2lsbCBiZSB3aGF0IHdlJ3JlIGxvb2tpbmcgZm9yLCBidXQgaW4gY2FzZSBpdCdzIG5vdCwgbG9vayB0aHJvdWdoIHRoZSByZXN0IG9mIHRoZSBhcnJheS4uLihhbmQgQW5kcm9pZCBicm93c2VycyBkb24ndCByZXVzZSB0aGUgZXZlbnQgbGlrZSBpT1MpXG4gICAgICAgICAgaSA9IHRvdWNoZXMubGVuZ3RoO1xuXG4gICAgICAgICAgd2hpbGUgKC0taSA+IC0xICYmIChlID0gdG91Y2hlc1tpXSkuaWRlbnRpZmllciAhPT0gdG91Y2hJRCAmJiBlLnRhcmdldCAhPT0gdGFyZ2V0KSB7fSAvLyBTb21lIEFuZHJvaWQgZGV2aWNlcyBkaXNwYXRjaCBhIHRvdWNoc3RhcnQgQU5EIHBvaW50ZXJkb3duIGluaXRpYWxseSwgYW5kIHRoZW4gb25seSBwb2ludGVybW92ZSB0aHVzIHRoZSB0b3VjaElEIG1heSBub3QgbWF0Y2ggYmVjYXVzZSBpdCB3YXMgZ3JhYmJlZCBmcm9tIHRoZSB0b3VjaHN0YXJ0IGV2ZW50IHdoZXJlYXMgdGhlIHBvaW50ZXIgZXZlbnQgaXMgdGhlIG9uZSB0aGF0IHRoZSBicm93c2VyIGRpc3BhdGNoZXMgZm9yIG1vdmUsIHNvIGlmIHRoZSBldmVudCB0YXJnZXQgbWF0Y2hlcyB0aGlzIERyYWdnYWJsZSdzIHRhcmdldCwgbGV0IGl0IHRocm91Z2guXG5cblxuICAgICAgICAgIGlmIChpIDwgMCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChlLnBvaW50ZXJJZCAmJiB0b3VjaElEICYmIGUucG9pbnRlcklkICE9PSB0b3VjaElEKSB7XG4gICAgICAgIC8vZm9yIHNvbWUgTWljcm9zb2Z0IGJyb3dzZXJzLCB3ZSBtdXN0IGF0dGFjaCB0aGUgbGlzdGVuZXIgdG8gdGhlIGRvYyByYXRoZXIgdGhhbiB0aGUgdHJpZ2dlciBzbyB0aGF0IHdoZW4gdGhlIGZpbmdlciBtb3ZlcyBvdXRzaWRlIHRoZSBib3VuZHMgb2YgdGhlIHRyaWdnZXIsIHRoaW5ncyBzdGlsbCB3b3JrLiBTbyBpZiB0aGUgZXZlbnQgd2UncmUgcmVjZWl2aW5nIGhhcyBhIHBvaW50ZXJJZCB0aGF0IGRvZXNuJ3QgbWF0Y2ggdGhlIHRvdWNoSUQsIGlnbm9yZSBpdCAoZm9yIG11bHRpLXRvdWNoKVxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmICh0b3VjaEV2ZW50VGFyZ2V0ICYmIGFsbG93TmF0aXZlVG91Y2hTY3JvbGxpbmcgJiYgIXRvdWNoRHJhZ0F4aXMpIHtcbiAgICAgICAgLy9BbmRyb2lkIGJyb3dzZXJzIGZvcmNlIHVzIHRvIGRlY2lkZSBvbiB0aGUgZmlyc3QgXCJ0b3VjaG1vdmVcIiBldmVudCBpZiB3ZSBzaG91bGQgYWxsb3cgdGhlIGRlZmF1bHQgKHNjcm9sbGluZykgYmVoYXZpb3Igb3IgcHJldmVudERlZmF1bHQoKS4gT3RoZXJ3aXNlLCBhIFwidG91Y2hjYW5jZWxcIiB3aWxsIGJlIGZpcmVkIGFuZCB0aGVuIG5vIFwidG91Y2htb3ZlXCIgb3IgXCJ0b3VjaGVuZFwiIHdpbGwgZmlyZSBkdXJpbmcgdGhlIHNjcm9sbGluZyAobm8gZ29vZCkuXG4gICAgICAgIF9wb2ludDEueCA9IGUucGFnZVggLSAoaXNGaXhlZCA/IF9nZXREb2NTY3JvbGxMZWZ0KG93bmVyRG9jKSA6IDApO1xuICAgICAgICBfcG9pbnQxLnkgPSBlLnBhZ2VZIC0gKGlzRml4ZWQgPyBfZ2V0RG9jU2Nyb2xsVG9wKG93bmVyRG9jKSA6IDApO1xuICAgICAgICBtYXRyaXggJiYgbWF0cml4LmFwcGx5KF9wb2ludDEsIF9wb2ludDEpO1xuICAgICAgICBwb2ludGVyWCA9IF9wb2ludDEueDtcbiAgICAgICAgcG9pbnRlclkgPSBfcG9pbnQxLnk7XG4gICAgICAgIGR4ID0gTWF0aC5hYnMocG9pbnRlclggLSBzdGFydFBvaW50ZXJYKTtcbiAgICAgICAgZHkgPSBNYXRoLmFicyhwb2ludGVyWSAtIHN0YXJ0UG9pbnRlclkpO1xuXG4gICAgICAgIGlmIChkeCAhPT0gZHkgJiYgKGR4ID4gbWluaW11bU1vdmVtZW50IHx8IGR5ID4gbWluaW11bU1vdmVtZW50KSB8fCBfaXNBbmRyb2lkICYmIGFsbG93TmF0aXZlVG91Y2hTY3JvbGxpbmcgPT09IHRvdWNoRHJhZ0F4aXMpIHtcbiAgICAgICAgICB0b3VjaERyYWdBeGlzID0gZHggPiBkeSAmJiBhbGxvd1ggPyBcInhcIiA6IFwieVwiO1xuXG4gICAgICAgICAgaWYgKGFsbG93TmF0aXZlVG91Y2hTY3JvbGxpbmcgJiYgdG91Y2hEcmFnQXhpcyAhPT0gYWxsb3dOYXRpdmVUb3VjaFNjcm9sbGluZykge1xuICAgICAgICAgICAgX2FkZExpc3RlbmVyKF93aW4sIFwidG91Y2hmb3JjZWNoYW5nZVwiLCBfcHJldmVudERlZmF1bHQpOyAvLyBwcmV2ZW50cyBuYXRpdmUgdG91Y2ggc2Nyb2xsaW5nIGZyb20gdGFraW5nIG92ZXIgaWYgdGhlIHVzZXIgc3RhcnRlZCBkcmFnZ2luZyBpbiB0aGUgb3RoZXIgZGlyZWN0aW9uIGluIGlPUyBTYWZhcmlcblxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChzZWxmLnZhcnMubG9ja0F4aXNPblRvdWNoU2Nyb2xsICE9PSBmYWxzZSAmJiBhbGxvd1ggJiYgYWxsb3dZKSB7XG4gICAgICAgICAgICBzZWxmLmxvY2tlZEF4aXMgPSB0b3VjaERyYWdBeGlzID09PSBcInhcIiA/IFwieVwiIDogXCJ4XCI7XG4gICAgICAgICAgICBfaXNGdW5jdGlvbihzZWxmLnZhcnMub25Mb2NrQXhpcykgJiYgc2VsZi52YXJzLm9uTG9ja0F4aXMuY2FsbChzZWxmLCBvcmlnaW5hbEV2ZW50KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoX2lzQW5kcm9pZCAmJiBhbGxvd05hdGl2ZVRvdWNoU2Nyb2xsaW5nID09PSB0b3VjaERyYWdBeGlzKSB7XG4gICAgICAgICAgICBvblJlbGVhc2Uob3JpZ2luYWxFdmVudCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICghc2VsZi5hbGxvd0V2ZW50RGVmYXVsdCAmJiAoIWFsbG93TmF0aXZlVG91Y2hTY3JvbGxpbmcgfHwgdG91Y2hEcmFnQXhpcyAmJiBhbGxvd05hdGl2ZVRvdWNoU2Nyb2xsaW5nICE9PSB0b3VjaERyYWdBeGlzKSAmJiBvcmlnaW5hbEV2ZW50LmNhbmNlbGFibGUgIT09IGZhbHNlKSB7XG4gICAgICAgIF9wcmV2ZW50RGVmYXVsdChvcmlnaW5hbEV2ZW50KTtcblxuICAgICAgICBpc1ByZXZlbnRpbmdEZWZhdWx0ID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSBpZiAoaXNQcmV2ZW50aW5nRGVmYXVsdCkge1xuICAgICAgICBpc1ByZXZlbnRpbmdEZWZhdWx0ID0gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIGlmIChzZWxmLmF1dG9TY3JvbGwpIHtcbiAgICAgICAgY2hlY2tBdXRvU2Nyb2xsQm91bmRzID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgc2V0UG9pbnRlclBvc2l0aW9uKGUucGFnZVgsIGUucGFnZVksIGhhc01vdmVDYWxsYmFjayk7XG4gICAgfSxcbiAgICAgICAgc2V0UG9pbnRlclBvc2l0aW9uID0gZnVuY3Rpb24gc2V0UG9pbnRlclBvc2l0aW9uKHBvaW50ZXJYLCBwb2ludGVyWSwgaW52b2tlT25Nb3ZlKSB7XG4gICAgICB2YXIgZHJhZ1RvbGVyYW5jZSA9IDEgLSBzZWxmLmRyYWdSZXNpc3RhbmNlLFxuICAgICAgICAgIGVkZ2VUb2xlcmFuY2UgPSAxIC0gc2VsZi5lZGdlUmVzaXN0YW5jZSxcbiAgICAgICAgICBwcmV2UG9pbnRlclggPSBzZWxmLnBvaW50ZXJYLFxuICAgICAgICAgIHByZXZQb2ludGVyWSA9IHNlbGYucG9pbnRlclksXG4gICAgICAgICAgcHJldlN0YXJ0RWxlbWVudFkgPSBzdGFydEVsZW1lbnRZLFxuICAgICAgICAgIHByZXZYID0gc2VsZi54LFxuICAgICAgICAgIHByZXZZID0gc2VsZi55LFxuICAgICAgICAgIHByZXZFbmRYID0gc2VsZi5lbmRYLFxuICAgICAgICAgIHByZXZFbmRZID0gc2VsZi5lbmRZLFxuICAgICAgICAgIHByZXZFbmRSb3RhdGlvbiA9IHNlbGYuZW5kUm90YXRpb24sXG4gICAgICAgICAgcHJldkRpcnR5ID0gZGlydHksXG4gICAgICAgICAgeENoYW5nZSxcbiAgICAgICAgICB5Q2hhbmdlLFxuICAgICAgICAgIHgsXG4gICAgICAgICAgeSxcbiAgICAgICAgICBkaWYsXG4gICAgICAgICAgdGVtcDtcbiAgICAgIHNlbGYucG9pbnRlclggPSBwb2ludGVyWDtcbiAgICAgIHNlbGYucG9pbnRlclkgPSBwb2ludGVyWTtcblxuICAgICAgaWYgKGlzRml4ZWQpIHtcbiAgICAgICAgcG9pbnRlclggLT0gX2dldERvY1Njcm9sbExlZnQob3duZXJEb2MpO1xuICAgICAgICBwb2ludGVyWSAtPSBfZ2V0RG9jU2Nyb2xsVG9wKG93bmVyRG9jKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHJvdGF0aW9uTW9kZSkge1xuICAgICAgICB5ID0gTWF0aC5hdGFuMihyb3RhdGlvbk9yaWdpbi55IC0gcG9pbnRlclksIHBvaW50ZXJYIC0gcm90YXRpb25PcmlnaW4ueCkgKiBfUkFEMkRFRztcbiAgICAgICAgZGlmID0gc2VsZi55IC0geTtcblxuICAgICAgICBpZiAoZGlmID4gMTgwKSB7XG4gICAgICAgICAgc3RhcnRFbGVtZW50WSAtPSAzNjA7XG4gICAgICAgICAgc2VsZi55ID0geTtcbiAgICAgICAgfSBlbHNlIGlmIChkaWYgPCAtMTgwKSB7XG4gICAgICAgICAgc3RhcnRFbGVtZW50WSArPSAzNjA7XG4gICAgICAgICAgc2VsZi55ID0geTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzZWxmLnggIT09IHN0YXJ0RWxlbWVudFggfHwgTWF0aC5hYnMoc3RhcnRFbGVtZW50WSAtIHkpID4gbWluaW11bU1vdmVtZW50KSB7XG4gICAgICAgICAgc2VsZi55ID0geTtcbiAgICAgICAgICB4ID0gc3RhcnRFbGVtZW50WCArIChzdGFydEVsZW1lbnRZIC0geSkgKiBkcmFnVG9sZXJhbmNlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHggPSBzdGFydEVsZW1lbnRYO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAobWF0cml4KSB7XG4gICAgICAgICAgdGVtcCA9IHBvaW50ZXJYICogbWF0cml4LmEgKyBwb2ludGVyWSAqIG1hdHJpeC5jICsgbWF0cml4LmU7XG4gICAgICAgICAgcG9pbnRlclkgPSBwb2ludGVyWCAqIG1hdHJpeC5iICsgcG9pbnRlclkgKiBtYXRyaXguZCArIG1hdHJpeC5mO1xuICAgICAgICAgIHBvaW50ZXJYID0gdGVtcDtcbiAgICAgICAgfVxuXG4gICAgICAgIHlDaGFuZ2UgPSBwb2ludGVyWSAtIHN0YXJ0UG9pbnRlclk7XG4gICAgICAgIHhDaGFuZ2UgPSBwb2ludGVyWCAtIHN0YXJ0UG9pbnRlclg7XG5cbiAgICAgICAgaWYgKHlDaGFuZ2UgPCBtaW5pbXVtTW92ZW1lbnQgJiYgeUNoYW5nZSA+IC1taW5pbXVtTW92ZW1lbnQpIHtcbiAgICAgICAgICB5Q2hhbmdlID0gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh4Q2hhbmdlIDwgbWluaW11bU1vdmVtZW50ICYmIHhDaGFuZ2UgPiAtbWluaW11bU1vdmVtZW50KSB7XG4gICAgICAgICAgeENoYW5nZSA9IDA7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoKHNlbGYubG9ja0F4aXMgfHwgc2VsZi5sb2NrZWRBeGlzKSAmJiAoeENoYW5nZSB8fCB5Q2hhbmdlKSkge1xuICAgICAgICAgIHRlbXAgPSBzZWxmLmxvY2tlZEF4aXM7XG5cbiAgICAgICAgICBpZiAoIXRlbXApIHtcbiAgICAgICAgICAgIHNlbGYubG9ja2VkQXhpcyA9IHRlbXAgPSBhbGxvd1ggJiYgTWF0aC5hYnMoeENoYW5nZSkgPiBNYXRoLmFicyh5Q2hhbmdlKSA/IFwieVwiIDogYWxsb3dZID8gXCJ4XCIgOiBudWxsO1xuXG4gICAgICAgICAgICBpZiAodGVtcCAmJiBfaXNGdW5jdGlvbihzZWxmLnZhcnMub25Mb2NrQXhpcykpIHtcbiAgICAgICAgICAgICAgc2VsZi52YXJzLm9uTG9ja0F4aXMuY2FsbChzZWxmLCBzZWxmLnBvaW50ZXJFdmVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHRlbXAgPT09IFwieVwiKSB7XG4gICAgICAgICAgICB5Q2hhbmdlID0gMDtcbiAgICAgICAgICB9IGVsc2UgaWYgKHRlbXAgPT09IFwieFwiKSB7XG4gICAgICAgICAgICB4Q2hhbmdlID0gMDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB4ID0gX3JvdW5kKHN0YXJ0RWxlbWVudFggKyB4Q2hhbmdlICogZHJhZ1RvbGVyYW5jZSk7XG4gICAgICAgIHkgPSBfcm91bmQoc3RhcnRFbGVtZW50WSArIHlDaGFuZ2UgKiBkcmFnVG9sZXJhbmNlKTtcbiAgICAgIH1cblxuICAgICAgaWYgKChzbmFwWCB8fCBzbmFwWSB8fCBzbmFwWFkpICYmIChzZWxmLnggIT09IHggfHwgc2VsZi55ICE9PSB5ICYmICFyb3RhdGlvbk1vZGUpKSB7XG4gICAgICAgIGlmIChzbmFwWFkpIHtcbiAgICAgICAgICBfdGVtcDEueCA9IHg7XG4gICAgICAgICAgX3RlbXAxLnkgPSB5O1xuICAgICAgICAgIHRlbXAgPSBzbmFwWFkoX3RlbXAxKTtcbiAgICAgICAgICB4ID0gX3JvdW5kKHRlbXAueCk7XG4gICAgICAgICAgeSA9IF9yb3VuZCh0ZW1wLnkpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHNuYXBYKSB7XG4gICAgICAgICAgeCA9IF9yb3VuZChzbmFwWCh4KSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc25hcFkpIHtcbiAgICAgICAgICB5ID0gX3JvdW5kKHNuYXBZKHkpKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoaGFzQm91bmRzKSB7XG4gICAgICAgIGlmICh4ID4gbWF4WCkge1xuICAgICAgICAgIHggPSBtYXhYICsgTWF0aC5yb3VuZCgoeCAtIG1heFgpICogZWRnZVRvbGVyYW5jZSk7XG4gICAgICAgIH0gZWxzZSBpZiAoeCA8IG1pblgpIHtcbiAgICAgICAgICB4ID0gbWluWCArIE1hdGgucm91bmQoKHggLSBtaW5YKSAqIGVkZ2VUb2xlcmFuY2UpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFyb3RhdGlvbk1vZGUpIHtcbiAgICAgICAgICBpZiAoeSA+IG1heFkpIHtcbiAgICAgICAgICAgIHkgPSBNYXRoLnJvdW5kKG1heFkgKyAoeSAtIG1heFkpICogZWRnZVRvbGVyYW5jZSk7XG4gICAgICAgICAgfSBlbHNlIGlmICh5IDwgbWluWSkge1xuICAgICAgICAgICAgeSA9IE1hdGgucm91bmQobWluWSArICh5IC0gbWluWSkgKiBlZGdlVG9sZXJhbmNlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHNlbGYueCAhPT0geCB8fCBzZWxmLnkgIT09IHkgJiYgIXJvdGF0aW9uTW9kZSkge1xuICAgICAgICBpZiAocm90YXRpb25Nb2RlKSB7XG4gICAgICAgICAgc2VsZi5lbmRSb3RhdGlvbiA9IHNlbGYueCA9IHNlbGYuZW5kWCA9IHg7XG4gICAgICAgICAgZGlydHkgPSB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChhbGxvd1kpIHtcbiAgICAgICAgICAgIHNlbGYueSA9IHNlbGYuZW5kWSA9IHk7XG4gICAgICAgICAgICBkaXJ0eSA9IHRydWU7IC8vYSBmbGFnIHRoYXQgaW5kaWNhdGVzIHdlIG5lZWQgdG8gcmVuZGVyIHRoZSB0YXJnZXQgbmV4dCB0aW1lIHRoZSBUd2VlbkxpdGUudGlja2VyIGRpc3BhdGNoZXMgYSBcInRpY2tcIiBldmVudCAodHlwaWNhbGx5IG9uIGEgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKSAtIHRoaXMgaXMgYSBwZXJmb3JtYW5jZSBvcHRpbWl6YXRpb24gKHdlIHNob3VsZG4ndCByZW5kZXIgb24gZXZlcnkgbW92ZSBiZWNhdXNlIHNvbWV0aW1lcyBtYW55IG1vdmUgZXZlbnRzIGNhbiBnZXQgZGlzcGF0Y2hlZCBiZXR3ZWVuIHNjcmVlbiByZWZyZXNoZXMsIGFuZCB0aGF0J2QgYmUgd2FzdGVmdWwgdG8gcmVuZGVyIGV2ZXJ5IHRpbWUpXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGFsbG93WCkge1xuICAgICAgICAgICAgc2VsZi54ID0gc2VsZi5lbmRYID0geDtcbiAgICAgICAgICAgIGRpcnR5ID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWludm9rZU9uTW92ZSB8fCBfZGlzcGF0Y2hFdmVudChzZWxmLCBcIm1vdmVcIiwgXCJvbk1vdmVcIikgIT09IGZhbHNlKSB7XG4gICAgICAgICAgaWYgKCFzZWxmLmlzRHJhZ2dpbmcgJiYgc2VsZi5pc1ByZXNzZWQpIHtcbiAgICAgICAgICAgIHNlbGYuaXNEcmFnZ2luZyA9IHRydWU7XG5cbiAgICAgICAgICAgIF9kaXNwYXRjaEV2ZW50KHNlbGYsIFwiZHJhZ3N0YXJ0XCIsIFwib25EcmFnU3RhcnRcIik7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vcmV2ZXJ0IGJlY2F1c2UgdGhlIG9uTW92ZSByZXR1cm5lZCBmYWxzZSFcbiAgICAgICAgICBzZWxmLnBvaW50ZXJYID0gcHJldlBvaW50ZXJYO1xuICAgICAgICAgIHNlbGYucG9pbnRlclkgPSBwcmV2UG9pbnRlclk7XG4gICAgICAgICAgc3RhcnRFbGVtZW50WSA9IHByZXZTdGFydEVsZW1lbnRZO1xuICAgICAgICAgIHNlbGYueCA9IHByZXZYO1xuICAgICAgICAgIHNlbGYueSA9IHByZXZZO1xuICAgICAgICAgIHNlbGYuZW5kWCA9IHByZXZFbmRYO1xuICAgICAgICAgIHNlbGYuZW5kWSA9IHByZXZFbmRZO1xuICAgICAgICAgIHNlbGYuZW5kUm90YXRpb24gPSBwcmV2RW5kUm90YXRpb247XG4gICAgICAgICAgZGlydHkgPSBwcmV2RGlydHk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgICAgICAvL2NhbGxlZCB3aGVuIHRoZSBtb3VzZS90b3VjaCBpcyByZWxlYXNlZFxuICAgIG9uUmVsZWFzZSA9IGZ1bmN0aW9uIG9uUmVsZWFzZShlLCBmb3JjZSkge1xuICAgICAgaWYgKCFlbmFibGVkIHx8ICFzZWxmLmlzUHJlc3NlZCB8fCBlICYmIHRvdWNoSUQgIT0gbnVsbCAmJiAhZm9yY2UgJiYgKGUucG9pbnRlcklkICYmIGUucG9pbnRlcklkICE9PSB0b3VjaElEICYmIGUudGFyZ2V0ICE9PSB0YXJnZXQgfHwgZS5jaGFuZ2VkVG91Y2hlcyAmJiAhX2hhc1RvdWNoSUQoZS5jaGFuZ2VkVG91Y2hlcywgdG91Y2hJRCkpKSB7XG4gICAgICAgIC8vZm9yIHNvbWUgTWljcm9zb2Z0IGJyb3dzZXJzLCB3ZSBtdXN0IGF0dGFjaCB0aGUgbGlzdGVuZXIgdG8gdGhlIGRvYyByYXRoZXIgdGhhbiB0aGUgdHJpZ2dlciBzbyB0aGF0IHdoZW4gdGhlIGZpbmdlciBtb3ZlcyBvdXRzaWRlIHRoZSBib3VuZHMgb2YgdGhlIHRyaWdnZXIsIHRoaW5ncyBzdGlsbCB3b3JrLiBTbyBpZiB0aGUgZXZlbnQgd2UncmUgcmVjZWl2aW5nIGhhcyBhIHBvaW50ZXJJZCB0aGF0IGRvZXNuJ3QgbWF0Y2ggdGhlIHRvdWNoSUQsIGlnbm9yZSBpdCAoZm9yIG11bHRpLXRvdWNoKVxuICAgICAgICBpc1ByZXZlbnRpbmdEZWZhdWx0ICYmIGUgJiYgZW5hYmxlZCAmJiBfcHJldmVudERlZmF1bHQoZSk7IC8vIGluIHNvbWUgYnJvd3NlcnMsIHdlIG11c3QgbGlzdGVuIGZvciBtdWx0aXBsZSBldmVudCB0eXBlcyBsaWtlIHRvdWNoZW5kLCBwb2ludGVydXAsIG1vdXNldXAuIFRoZSBmaXJzdCB0aW1lIHRoaXMgZnVuY3Rpb24gaXMgY2FsbGVkLCB3ZSByZWNvcmQgd2hldGhlciBvciBub3Qgd2UgX3ByZXZlbnREZWZhdWx0KCkgc28gdGhhdCBvbiBkdXBsaWNhdGUgY2FsbHMsIHdlIGNhbiBkbyB0aGUgc2FtZSBpZiBuZWNlc3NhcnkuXG5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBzZWxmLmlzUHJlc3NlZCA9IGZhbHNlO1xuICAgICAgdmFyIG9yaWdpbmFsRXZlbnQgPSBlLFxuICAgICAgICAgIHdhc0RyYWdnaW5nID0gc2VsZi5pc0RyYWdnaW5nLFxuICAgICAgICAgIGlzQ29udGV4dE1lbnVSZWxlYXNlID0gc2VsZi52YXJzLmFsbG93Q29udGV4dE1lbnUgJiYgZSAmJiAoZS5jdHJsS2V5IHx8IGUud2hpY2ggPiAyKSxcbiAgICAgICAgICBwbGFjZWhvbGRlckRlbGF5ZWRDYWxsID0gZ3NhcC5kZWxheWVkQ2FsbCgwLjAwMSwgcmVtb3ZlUGxhY2Vob2xkZXIpLFxuICAgICAgICAgIHRvdWNoZXMsXG4gICAgICAgICAgaSxcbiAgICAgICAgICBzeW50aGV0aWNFdmVudCxcbiAgICAgICAgICBldmVudFRhcmdldCxcbiAgICAgICAgICBzeW50aGV0aWNDbGljaztcblxuICAgICAgaWYgKHRvdWNoRXZlbnRUYXJnZXQpIHtcbiAgICAgICAgX3JlbW92ZUxpc3RlbmVyKHRvdWNoRXZlbnRUYXJnZXQsIFwidG91Y2hlbmRcIiwgb25SZWxlYXNlKTtcblxuICAgICAgICBfcmVtb3ZlTGlzdGVuZXIodG91Y2hFdmVudFRhcmdldCwgXCJ0b3VjaG1vdmVcIiwgb25Nb3ZlKTtcblxuICAgICAgICBfcmVtb3ZlTGlzdGVuZXIodG91Y2hFdmVudFRhcmdldCwgXCJ0b3VjaGNhbmNlbFwiLCBvblJlbGVhc2UpO1xuXG4gICAgICAgIF9yZW1vdmVMaXN0ZW5lcihvd25lckRvYywgXCJ0b3VjaHN0YXJ0XCIsIF9vbk11bHRpVG91Y2hEb2N1bWVudCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBfcmVtb3ZlTGlzdGVuZXIob3duZXJEb2MsIFwibW91c2Vtb3ZlXCIsIG9uTW92ZSk7XG4gICAgICB9XG5cbiAgICAgIF9yZW1vdmVMaXN0ZW5lcihfd2luLCBcInRvdWNoZm9yY2VjaGFuZ2VcIiwgX3ByZXZlbnREZWZhdWx0KTtcblxuICAgICAgaWYgKCFfc3VwcG9ydHNQb2ludGVyIHx8ICF0b3VjaEV2ZW50VGFyZ2V0KSB7XG4gICAgICAgIF9yZW1vdmVMaXN0ZW5lcihvd25lckRvYywgXCJtb3VzZXVwXCIsIG9uUmVsZWFzZSk7XG5cbiAgICAgICAgZSAmJiBlLnRhcmdldCAmJiBfcmVtb3ZlTGlzdGVuZXIoZS50YXJnZXQsIFwibW91c2V1cFwiLCBvblJlbGVhc2UpO1xuICAgICAgfVxuXG4gICAgICBkaXJ0eSA9IGZhbHNlO1xuXG4gICAgICBpZiAod2FzRHJhZ2dpbmcpIHtcbiAgICAgICAgZHJhZ0VuZFRpbWUgPSBfbGFzdERyYWdUaW1lID0gX2dldFRpbWUoKTtcbiAgICAgICAgc2VsZi5pc0RyYWdnaW5nID0gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIGlmIChpc0NsaWNraW5nICYmICFpc0NvbnRleHRNZW51UmVsZWFzZSkge1xuICAgICAgICBpZiAoZSkge1xuICAgICAgICAgIF9yZW1vdmVMaXN0ZW5lcihlLnRhcmdldCwgXCJjaGFuZ2VcIiwgb25SZWxlYXNlKTtcblxuICAgICAgICAgIHNlbGYucG9pbnRlckV2ZW50ID0gb3JpZ2luYWxFdmVudDtcbiAgICAgICAgfVxuXG4gICAgICAgIF9zZXRTZWxlY3RhYmxlKHRyaWdnZXJzLCBmYWxzZSk7XG5cbiAgICAgICAgX2Rpc3BhdGNoRXZlbnQoc2VsZiwgXCJyZWxlYXNlXCIsIFwib25SZWxlYXNlXCIpO1xuXG4gICAgICAgIF9kaXNwYXRjaEV2ZW50KHNlbGYsIFwiY2xpY2tcIiwgXCJvbkNsaWNrXCIpO1xuXG4gICAgICAgIGlzQ2xpY2tpbmcgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBfcmVtb3ZlRnJvbVJlbmRlclF1ZXVlKHJlbmRlcik7XG5cbiAgICAgIGkgPSB0cmlnZ2Vycy5sZW5ndGg7XG5cbiAgICAgIHdoaWxlICgtLWkgPiAtMSkge1xuICAgICAgICBfc2V0U3R5bGUodHJpZ2dlcnNbaV0sIFwiY3Vyc29yXCIsIHZhcnMuY3Vyc29yIHx8ICh2YXJzLmN1cnNvciAhPT0gZmFsc2UgPyBfZGVmYXVsdEN1cnNvciA6IG51bGwpKTtcbiAgICAgIH1cblxuICAgICAgX2RyYWdDb3VudC0tO1xuXG4gICAgICBpZiAoZSkge1xuICAgICAgICB0b3VjaGVzID0gZS5jaGFuZ2VkVG91Y2hlcztcblxuICAgICAgICBpZiAodG91Y2hlcykge1xuICAgICAgICAgIC8vdG91Y2ggZXZlbnRzIHN0b3JlIHRoZSBkYXRhIHNsaWdodGx5IGRpZmZlcmVudGx5XG4gICAgICAgICAgZSA9IHRvdWNoZXNbMF07XG5cbiAgICAgICAgICBpZiAoZSAhPT0gdG91Y2ggJiYgZS5pZGVudGlmaWVyICE9PSB0b3VjaElEKSB7XG4gICAgICAgICAgICAvL1VzdWFsbHkgY2hhbmdlZFRvdWNoZXNbMF0gd2lsbCBiZSB3aGF0IHdlJ3JlIGxvb2tpbmcgZm9yLCBidXQgaW4gY2FzZSBpdCdzIG5vdCwgbG9vayB0aHJvdWdoIHRoZSByZXN0IG9mIHRoZSBhcnJheS4uLihhbmQgQW5kcm9pZCBicm93c2VycyBkb24ndCByZXVzZSB0aGUgZXZlbnQgbGlrZSBpT1MpXG4gICAgICAgICAgICBpID0gdG91Y2hlcy5sZW5ndGg7XG5cbiAgICAgICAgICAgIHdoaWxlICgtLWkgPiAtMSAmJiAoZSA9IHRvdWNoZXNbaV0pLmlkZW50aWZpZXIgIT09IHRvdWNoSUQgJiYgZS50YXJnZXQgIT09IHRhcmdldCkge31cblxuICAgICAgICAgICAgaWYgKGkgPCAwKSB7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBzZWxmLnBvaW50ZXJFdmVudCA9IG9yaWdpbmFsRXZlbnQ7XG4gICAgICAgIHNlbGYucG9pbnRlclggPSBlLnBhZ2VYO1xuICAgICAgICBzZWxmLnBvaW50ZXJZID0gZS5wYWdlWTtcbiAgICAgIH1cblxuICAgICAgaWYgKGlzQ29udGV4dE1lbnVSZWxlYXNlICYmIG9yaWdpbmFsRXZlbnQpIHtcbiAgICAgICAgX3ByZXZlbnREZWZhdWx0KG9yaWdpbmFsRXZlbnQpO1xuXG4gICAgICAgIGlzUHJldmVudGluZ0RlZmF1bHQgPSB0cnVlO1xuXG4gICAgICAgIF9kaXNwYXRjaEV2ZW50KHNlbGYsIFwicmVsZWFzZVwiLCBcIm9uUmVsZWFzZVwiKTtcbiAgICAgIH0gZWxzZSBpZiAob3JpZ2luYWxFdmVudCAmJiAhd2FzRHJhZ2dpbmcpIHtcbiAgICAgICAgaXNQcmV2ZW50aW5nRGVmYXVsdCA9IGZhbHNlO1xuXG4gICAgICAgIGlmIChpbnRlcnJ1cHRlZCAmJiAodmFycy5zbmFwIHx8IHZhcnMuYm91bmRzKSkge1xuICAgICAgICAgIC8vb3RoZXJ3aXNlLCBpZiB0aGUgdXNlciBjbGlja3Mgb24gdGhlIG9iamVjdCB3aGlsZSBpdCdzIGFuaW1hdGluZyB0byBhIHNuYXBwZWQgcG9zaXRpb24sIGFuZCB0aGVuIHJlbGVhc2VzIHdpdGhvdXQgbW92aW5nIDMgcGl4ZWxzLCBpdCB3aWxsIGp1c3Qgc3RheSB0aGVyZSAoaXQgc2hvdWxkIGFuaW1hdGUvc25hcClcbiAgICAgICAgICBhbmltYXRlKHZhcnMuaW5lcnRpYSB8fCB2YXJzLnRocm93UHJvcHMpO1xuICAgICAgICB9XG5cbiAgICAgICAgX2Rpc3BhdGNoRXZlbnQoc2VsZiwgXCJyZWxlYXNlXCIsIFwib25SZWxlYXNlXCIpO1xuXG4gICAgICAgIGlmICgoIV9pc0FuZHJvaWQgfHwgb3JpZ2luYWxFdmVudC50eXBlICE9PSBcInRvdWNobW92ZVwiKSAmJiBvcmlnaW5hbEV2ZW50LnR5cGUuaW5kZXhPZihcImNhbmNlbFwiKSA9PT0gLTEpIHtcbiAgICAgICAgICAvL3RvIGFjY29tbW9kYXRlIG5hdGl2ZSBzY3JvbGxpbmcgb24gQW5kcm9pZCBkZXZpY2VzLCB3ZSBoYXZlIHRvIGltbWVkaWF0ZWx5IGNhbGwgb25SZWxlYXNlKCkgb24gdGhlIGZpcnN0IHRvdWNobW92ZSBldmVudCwgYnV0IHRoYXQgc2hvdWxkbid0IHRyaWdnZXIgYSBcImNsaWNrXCIuXG4gICAgICAgICAgX2Rpc3BhdGNoRXZlbnQoc2VsZiwgXCJjbGlja1wiLCBcIm9uQ2xpY2tcIik7XG5cbiAgICAgICAgICBpZiAoX2dldFRpbWUoKSAtIGNsaWNrVGltZSA8IDMwMCkge1xuICAgICAgICAgICAgX2Rpc3BhdGNoRXZlbnQoc2VsZiwgXCJkb3VibGVjbGlja1wiLCBcIm9uRG91YmxlQ2xpY2tcIik7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZXZlbnRUYXJnZXQgPSBvcmlnaW5hbEV2ZW50LnRhcmdldCB8fCB0YXJnZXQ7IC8vb2xkIElFIHVzZXMgc3JjRWxlbWVudFxuXG4gICAgICAgICAgY2xpY2tUaW1lID0gX2dldFRpbWUoKTtcblxuICAgICAgICAgIHN5bnRoZXRpY0NsaWNrID0gZnVuY3Rpb24gc3ludGhldGljQ2xpY2soKSB7XG4gICAgICAgICAgICAvLyBzb21lIGJyb3dzZXJzIChsaWtlIEZpcmVmb3gpIHdvbid0IHRydXN0IHNjcmlwdC1nZW5lcmF0ZWQgY2xpY2tzLCBzbyBpZiB0aGUgdXNlciB0cmllcyB0byBjbGljayBvbiBhIHZpZGVvIHRvIHBsYXkgaXQsIGZvciBleGFtcGxlLCBpdCBzaW1wbHkgd29uJ3Qgd29yay4gU2luY2UgYSByZWd1bGFyIFwiY2xpY2tcIiBldmVudCB3aWxsIG1vc3QgbGlrZWx5IGJlIGdlbmVyYXRlZCBhbnl3YXkgKG9uZSB0aGF0IGhhcyBpdHMgaXNUcnVzdGVkIGZsYWcgc2V0IHRvIHRydWUpLCB3ZSBtdXN0IHNsaWdodGx5IGRlbGF5IG91ciBzY3JpcHQtZ2VuZXJhdGVkIGNsaWNrIHNvIHRoYXQgdGhlIFwicmVhbFwiL3RydXN0ZWQgb25lIGlzIHByaW9yaXRpemVkLiBSZW1lbWJlciwgd2hlbiB0aGVyZSBhcmUgZHVwbGljYXRlIGV2ZW50cyBpbiBxdWljayBzdWNjZXNzaW9uLCB3ZSBzdXBwcmVzcyBhbGwgYnV0IHRoZSBmaXJzdCBvbmUuIFNvbWUgYnJvd3NlcnMgZG9uJ3QgZXZlbiB0cmlnZ2VyIHRoZSBcInJlYWxcIiBvbmUgYXQgYWxsLCBzbyBvdXIgc3ludGhldGljIG9uZSBpcyBhIHNhZmV0eSB2YWx2ZSB0aGF0IGVuc3VyZXMgdGhhdCBubyBtYXR0ZXIgd2hhdCwgYSBjbGljayBldmVudCBkb2VzIGdldCBkaXNwYXRjaGVkLlxuICAgICAgICAgICAgaWYgKGNsaWNrVGltZSAhPT0gY2xpY2tEaXNwYXRjaCAmJiBzZWxmLmVuYWJsZWQoKSAmJiAhc2VsZi5pc1ByZXNzZWQgJiYgIW9yaWdpbmFsRXZlbnQuZGVmYXVsdFByZXZlbnRlZCkge1xuICAgICAgICAgICAgICBpZiAoZXZlbnRUYXJnZXQuY2xpY2spIHtcbiAgICAgICAgICAgICAgICAvL3NvbWUgYnJvd3NlcnMgKGxpa2UgbW9iaWxlIFNhZmFyaSkgZG9uJ3QgcHJvcGVybHkgdHJpZ2dlciB0aGUgY2xpY2sgZXZlbnRcbiAgICAgICAgICAgICAgICBldmVudFRhcmdldC5jbGljaygpO1xuICAgICAgICAgICAgICB9IGVsc2UgaWYgKG93bmVyRG9jLmNyZWF0ZUV2ZW50KSB7XG4gICAgICAgICAgICAgICAgc3ludGhldGljRXZlbnQgPSBvd25lckRvYy5jcmVhdGVFdmVudChcIk1vdXNlRXZlbnRzXCIpO1xuICAgICAgICAgICAgICAgIHN5bnRoZXRpY0V2ZW50LmluaXRNb3VzZUV2ZW50KFwiY2xpY2tcIiwgdHJ1ZSwgdHJ1ZSwgX3dpbiwgMSwgc2VsZi5wb2ludGVyRXZlbnQuc2NyZWVuWCwgc2VsZi5wb2ludGVyRXZlbnQuc2NyZWVuWSwgc2VsZi5wb2ludGVyWCwgc2VsZi5wb2ludGVyWSwgZmFsc2UsIGZhbHNlLCBmYWxzZSwgZmFsc2UsIDAsIG51bGwpO1xuICAgICAgICAgICAgICAgIGV2ZW50VGFyZ2V0LmRpc3BhdGNoRXZlbnQoc3ludGhldGljRXZlbnQpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcblxuICAgICAgICAgIGlmICghX2lzQW5kcm9pZCAmJiAhb3JpZ2luYWxFdmVudC5kZWZhdWx0UHJldmVudGVkKSB7XG4gICAgICAgICAgICAvL2lPUyBTYWZhcmkgcmVxdWlyZXMgdGhlIHN5bnRoZXRpYyBjbGljayB0byBoYXBwZW4gaW1tZWRpYXRlbHkgb3IgZWxzZSBpdCBzaW1wbHkgd29uJ3Qgd29yaywgYnV0IEFuZHJvaWQgZG9lc24ndCBwbGF5IG5pY2UuXG4gICAgICAgICAgICBnc2FwLmRlbGF5ZWRDYWxsKDAuMDUsIHN5bnRoZXRpY0NsaWNrKTsgLy9pbiBhZGRpdGlvbiB0byB0aGUgaU9TIGJ1ZyB3b3JrYXJvdW5kLCB0aGVyZSdzIGEgRmlyZWZveCBpc3N1ZSB3aXRoIGNsaWNraW5nIG9uIHRoaW5ncyBsaWtlIGEgdmlkZW8gdG8gcGxheSwgc28gd2UgbXVzdCBmYWtlIGEgY2xpY2sgZXZlbnQgaW4gYSBzbGlnaHRseSBkZWxheWVkIGZhc2hpb24uIFByZXZpb3VzbHksIHdlIGxpc3RlbmVkIGZvciB0aGUgXCJjbGlja1wiIGV2ZW50IHdpdGggXCJjYXB0dXJlXCIgZmFsc2Ugd2hpY2ggc29sdmVkIHRoZSB2aWRlby1jbGljay10by1wbGF5IGlzc3VlLCBidXQgaXQgd291bGQgYWxsb3cgdGhlIFwiY2xpY2tcIiBldmVudCB0byBiZSBkaXNwYXRjaGVkIHR3aWNlIGxpa2UgaWYgeW91IHdlcmUgdXNpbmcgYSBqUXVlcnkuY2xpY2soKSBiZWNhdXNlIHRoYXQgd2FzIGhhbmRsZWQgaW4gdGhlIGNhcHR1cmUgcGhhc2UsIHRodXMgd2UgaGFkIHRvIHN3aXRjaCB0byB0aGUgY2FwdHVyZSBwaGFzZSB0byBhdm9pZCB0aGUgZG91YmxlLWRpc3BhdGNoaW5nLCBidXQgZG8gdGhlIGRlbGF5ZWQgc3ludGhldGljIGNsaWNrLiBEb24ndCBmaXJlIGl0IHRvbyBmYXN0IChsaWtlIDAuMDAwMDEpIGJlY2F1c2Ugd2Ugd2FudCB0byBnaXZlIHRoZSBuYXRpdmUgZXZlbnQgYSBjaGFuY2UgdG8gZmlyZSBmaXJzdCBhcyBpdCdzIFwidHJ1c3RlZFwiLlxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYW5pbWF0ZSh2YXJzLmluZXJ0aWEgfHwgdmFycy50aHJvd1Byb3BzKTsgLy93aWxsIHNraXAgaWYgaW5lcnRpYS90aHJvd1Byb3BzIGlzbid0IGRlZmluZWQgb3IgSW5lcnRpYVBsdWdpbiBpc24ndCBsb2FkZWQuXG5cbiAgICAgICAgaWYgKCFzZWxmLmFsbG93RXZlbnREZWZhdWx0ICYmIG9yaWdpbmFsRXZlbnQgJiYgKHZhcnMuZHJhZ0NsaWNrYWJsZXMgIT09IGZhbHNlIHx8ICFpc0NsaWNrYWJsZS5jYWxsKHNlbGYsIG9yaWdpbmFsRXZlbnQudGFyZ2V0KSkgJiYgd2FzRHJhZ2dpbmcgJiYgKCFhbGxvd05hdGl2ZVRvdWNoU2Nyb2xsaW5nIHx8IHRvdWNoRHJhZ0F4aXMgJiYgYWxsb3dOYXRpdmVUb3VjaFNjcm9sbGluZyA9PT0gdG91Y2hEcmFnQXhpcykgJiYgb3JpZ2luYWxFdmVudC5jYW5jZWxhYmxlICE9PSBmYWxzZSkge1xuICAgICAgICAgIGlzUHJldmVudGluZ0RlZmF1bHQgPSB0cnVlO1xuXG4gICAgICAgICAgX3ByZXZlbnREZWZhdWx0KG9yaWdpbmFsRXZlbnQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlzUHJldmVudGluZ0RlZmF1bHQgPSBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIF9kaXNwYXRjaEV2ZW50KHNlbGYsIFwicmVsZWFzZVwiLCBcIm9uUmVsZWFzZVwiKTtcbiAgICAgIH1cblxuICAgICAgaXNUd2VlbmluZygpICYmIHBsYWNlaG9sZGVyRGVsYXllZENhbGwuZHVyYXRpb24oc2VsZi50d2Vlbi5kdXJhdGlvbigpKTsgLy9zeW5jIHRoZSB0aW1pbmcgc28gdGhhdCB0aGUgcGxhY2Vob2xkZXIgRElWIGdldHNcblxuICAgICAgd2FzRHJhZ2dpbmcgJiYgX2Rpc3BhdGNoRXZlbnQoc2VsZiwgXCJkcmFnZW5kXCIsIFwib25EcmFnRW5kXCIpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSxcbiAgICAgICAgdXBkYXRlU2Nyb2xsID0gZnVuY3Rpb24gdXBkYXRlU2Nyb2xsKGUpIHtcbiAgICAgIGlmIChlICYmIHNlbGYuaXNEcmFnZ2luZyAmJiAhc2Nyb2xsUHJveHkpIHtcbiAgICAgICAgdmFyIHBhcmVudCA9IGUudGFyZ2V0IHx8IHRhcmdldC5wYXJlbnROb2RlLFxuICAgICAgICAgICAgZGVsdGFYID0gcGFyZW50LnNjcm9sbExlZnQgLSBwYXJlbnQuX2dzU2Nyb2xsWCxcbiAgICAgICAgICAgIGRlbHRhWSA9IHBhcmVudC5zY3JvbGxUb3AgLSBwYXJlbnQuX2dzU2Nyb2xsWTtcblxuICAgICAgICBpZiAoZGVsdGFYIHx8IGRlbHRhWSkge1xuICAgICAgICAgIGlmIChtYXRyaXgpIHtcbiAgICAgICAgICAgIHN0YXJ0UG9pbnRlclggLT0gZGVsdGFYICogbWF0cml4LmEgKyBkZWx0YVkgKiBtYXRyaXguYztcbiAgICAgICAgICAgIHN0YXJ0UG9pbnRlclkgLT0gZGVsdGFZICogbWF0cml4LmQgKyBkZWx0YVggKiBtYXRyaXguYjtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc3RhcnRQb2ludGVyWCAtPSBkZWx0YVg7XG4gICAgICAgICAgICBzdGFydFBvaW50ZXJZIC09IGRlbHRhWTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBwYXJlbnQuX2dzU2Nyb2xsWCArPSBkZWx0YVg7XG4gICAgICAgICAgcGFyZW50Ll9nc1Njcm9sbFkgKz0gZGVsdGFZO1xuICAgICAgICAgIHNldFBvaW50ZXJQb3NpdGlvbihzZWxmLnBvaW50ZXJYLCBzZWxmLnBvaW50ZXJZKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgICAgIG9uQ2xpY2sgPSBmdW5jdGlvbiBvbkNsaWNrKGUpIHtcbiAgICAgIC8vdGhpcyB3YXMgYSBodWdlIHBhaW4gaW4gdGhlIG5lY2sgdG8gYWxpZ24gYWxsIHRoZSB2YXJpb3VzIGJyb3dzZXJzIGFuZCB0aGVpciBiZWhhdmlvcnMuIENocm9tZSwgRmlyZWZveCwgU2FmYXJpLCBPcGVyYSwgQW5kcm9pZCwgYW5kIE1pY3Jvc29mdCBFZGdlIGFsbCBoYW5kbGUgZXZlbnRzIGRpZmZlcmVudGx5ISBTb21lIHdpbGwgb25seSB0cmlnZ2VyIG5hdGl2ZSBiZWhhdmlvciAobGlrZSBjaGVja2JveCB0b2dnbGluZykgZnJvbSB0cnVzdGVkIGV2ZW50cy4gT3RoZXJzIGRvbid0IGV2ZW4gc3VwcG9ydCBpc1RydXN0ZWQsIGJ1dCByZXF1aXJlIDIgZXZlbnRzIHRvIGZsb3cgdGhyb3VnaCBiZWZvcmUgdHJpZ2dlcmluZyBuYXRpdmUgYmVoYXZpb3IuIEVkZ2UgdHJlYXRzIGV2ZXJ5dGhpbmcgYXMgdHJ1c3RlZCBidXQgYWxzbyBtYW5kYXRlcyB0aGF0IDIgZmxvdyB0aHJvdWdoIHRvIHRyaWdnZXIgdGhlIGNvcnJlY3QgbmF0aXZlIGJlaGF2aW9yLlxuICAgICAgdmFyIHRpbWUgPSBfZ2V0VGltZSgpLFxuICAgICAgICAgIHJlY2VudGx5Q2xpY2tlZCA9IHRpbWUgLSBjbGlja1RpbWUgPCAxMDAsXG4gICAgICAgICAgcmVjZW50bHlEcmFnZ2VkID0gdGltZSAtIGRyYWdFbmRUaW1lIDwgNTAsXG4gICAgICAgICAgYWxyZWFkeURpc3BhdGNoZWQgPSByZWNlbnRseUNsaWNrZWQgJiYgY2xpY2tEaXNwYXRjaCA9PT0gY2xpY2tUaW1lLFxuICAgICAgICAgIGRlZmF1bHRQcmV2ZW50ZWQgPSBzZWxmLnBvaW50ZXJFdmVudCAmJiBzZWxmLnBvaW50ZXJFdmVudC5kZWZhdWx0UHJldmVudGVkLFxuICAgICAgICAgIGFscmVhZHlEaXNwYXRjaGVkVHJ1c3RlZCA9IHJlY2VudGx5Q2xpY2tlZCAmJiB0cnVzdGVkQ2xpY2tEaXNwYXRjaCA9PT0gY2xpY2tUaW1lLFxuICAgICAgICAgIHRydXN0ZWQgPSBlLmlzVHJ1c3RlZCB8fCBlLmlzVHJ1c3RlZCA9PSBudWxsICYmIHJlY2VudGx5Q2xpY2tlZCAmJiBhbHJlYWR5RGlzcGF0Y2hlZDsgLy9ub3RlOiBTYWZhcmkgZG9lc24ndCBzdXBwb3J0IGlzVHJ1c3RlZCwgYW5kIGl0IHdvbid0IHByb3Blcmx5IGV4ZWN1dGUgbmF0aXZlIGJlaGF2aW9yIChsaWtlIHRvZ2dsaW5nIGNoZWNrYm94ZXMpIG9uIHRoZSBmaXJzdCBzeW50aGV0aWMgXCJjbGlja1wiIGV2ZW50IC0gd2UgbXVzdCB3YWl0IGZvciB0aGUgMm5kIGFuZCB0cmVhdCBpdCBhcyB0cnVzdGVkIChidXQgc3RvcCBwcm9wYWdhdGlvbiBhdCB0aGF0IHBvaW50KS4gQ29uZnVzaW5nLCBJIGtub3cuIERvbid0IHlvdSBsb3ZlIGNyb3NzLWJyb3dzZXIgY29tcGF0aWJpbGl0eSBjaGFsbGVuZ2VzP1xuXG5cbiAgICAgIGlmICgoYWxyZWFkeURpc3BhdGNoZWQgfHwgcmVjZW50bHlEcmFnZ2VkICYmIHNlbGYudmFycy5zdXBwcmVzc0NsaWNrT25EcmFnICE9PSBmYWxzZSkgJiYgZS5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24pIHtcbiAgICAgICAgZS5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHJlY2VudGx5Q2xpY2tlZCAmJiAhKHNlbGYucG9pbnRlckV2ZW50ICYmIHNlbGYucG9pbnRlckV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQpICYmICghYWxyZWFkeURpc3BhdGNoZWQgfHwgdHJ1c3RlZCAmJiAhYWxyZWFkeURpc3BhdGNoZWRUcnVzdGVkKSkge1xuICAgICAgICAvL2xldCB0aGUgZmlyc3QgY2xpY2sgcGFzcyB0aHJvdWdoIHVuaGluZGVyZWQuIExldCB0aGUgbmV4dCBvbmUgb25seSBpZiBpdCdzIHRydXN0ZWQsIHRoZW4gbm8gbW9yZSAoc3RvcCBxdWljay1zdWNjZXNzaW9uIG9uZXMpXG4gICAgICAgIGlmICh0cnVzdGVkICYmIGFscmVhZHlEaXNwYXRjaGVkKSB7XG4gICAgICAgICAgdHJ1c3RlZENsaWNrRGlzcGF0Y2ggPSBjbGlja1RpbWU7XG4gICAgICAgIH1cblxuICAgICAgICBjbGlja0Rpc3BhdGNoID0gY2xpY2tUaW1lO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmIChzZWxmLmlzUHJlc3NlZCB8fCByZWNlbnRseURyYWdnZWQgfHwgcmVjZW50bHlDbGlja2VkKSB7XG4gICAgICAgIGlmICghdHJ1c3RlZCB8fCAhZS5kZXRhaWwgfHwgIXJlY2VudGx5Q2xpY2tlZCB8fCBkZWZhdWx0UHJldmVudGVkKSB7XG4gICAgICAgICAgX3ByZXZlbnREZWZhdWx0KGUpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICghcmVjZW50bHlDbGlja2VkICYmICFyZWNlbnRseURyYWdnZWQpIHtcbiAgICAgICAgLy8gZm9yIHNjcmlwdC10cmlnZ2VyZWQgZXZlbnQgZGlzcGF0Y2hlcywgbGlrZSBlbGVtZW50LmNsaWNrKClcbiAgICAgICAgZSAmJiBlLnRhcmdldCAmJiAoc2VsZi5wb2ludGVyRXZlbnQgPSBlKTtcblxuICAgICAgICBfZGlzcGF0Y2hFdmVudChzZWxmLCBcImNsaWNrXCIsIFwib25DbGlja1wiKTtcbiAgICAgIH1cbiAgICB9LFxuICAgICAgICBsb2NhbGl6ZVBvaW50ID0gZnVuY3Rpb24gbG9jYWxpemVQb2ludChwKSB7XG4gICAgICByZXR1cm4gbWF0cml4ID8ge1xuICAgICAgICB4OiBwLnggKiBtYXRyaXguYSArIHAueSAqIG1hdHJpeC5jICsgbWF0cml4LmUsXG4gICAgICAgIHk6IHAueCAqIG1hdHJpeC5iICsgcC55ICogbWF0cml4LmQgKyBtYXRyaXguZlxuICAgICAgfSA6IHtcbiAgICAgICAgeDogcC54LFxuICAgICAgICB5OiBwLnlcbiAgICAgIH07XG4gICAgfTtcblxuICAgIG9sZCA9IERyYWdnYWJsZS5nZXQodGFyZ2V0KTtcbiAgICBvbGQgJiYgb2xkLmtpbGwoKTsgLy8gYXZvaWRzIGR1cGxpY2F0ZXMgKGFuIGVsZW1lbnQgY2FuIG9ubHkgYmUgY29udHJvbGxlZCBieSBvbmUgRHJhZ2dhYmxlKVxuICAgIC8vZ2l2ZSB0aGUgdXNlciBhY2Nlc3MgdG8gc3RhcnQvc3RvcCBkcmFnZ2luZy4uLlxuXG4gICAgX3RoaXMyLnN0YXJ0RHJhZyA9IGZ1bmN0aW9uIChldmVudCwgYWxpZ24pIHtcbiAgICAgIHZhciByMSwgcjIsIHAxLCBwMjtcbiAgICAgIG9uUHJlc3MoZXZlbnQgfHwgc2VsZi5wb2ludGVyRXZlbnQsIHRydWUpOyAvL2lmIHRoZSBwb2ludGVyIGlzbid0IG9uIHRvcCBvZiB0aGUgZWxlbWVudCwgYWRqdXN0IHRoaW5ncyBhY2NvcmRpbmdseVxuXG4gICAgICBpZiAoYWxpZ24gJiYgIXNlbGYuaGl0VGVzdChldmVudCB8fCBzZWxmLnBvaW50ZXJFdmVudCkpIHtcbiAgICAgICAgcjEgPSBfcGFyc2VSZWN0KGV2ZW50IHx8IHNlbGYucG9pbnRlckV2ZW50KTtcbiAgICAgICAgcjIgPSBfcGFyc2VSZWN0KHRhcmdldCk7XG4gICAgICAgIHAxID0gbG9jYWxpemVQb2ludCh7XG4gICAgICAgICAgeDogcjEubGVmdCArIHIxLndpZHRoIC8gMixcbiAgICAgICAgICB5OiByMS50b3AgKyByMS5oZWlnaHQgLyAyXG4gICAgICAgIH0pO1xuICAgICAgICBwMiA9IGxvY2FsaXplUG9pbnQoe1xuICAgICAgICAgIHg6IHIyLmxlZnQgKyByMi53aWR0aCAvIDIsXG4gICAgICAgICAgeTogcjIudG9wICsgcjIuaGVpZ2h0IC8gMlxuICAgICAgICB9KTtcbiAgICAgICAgc3RhcnRQb2ludGVyWCAtPSBwMS54IC0gcDIueDtcbiAgICAgICAgc3RhcnRQb2ludGVyWSAtPSBwMS55IC0gcDIueTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFzZWxmLmlzRHJhZ2dpbmcpIHtcbiAgICAgICAgc2VsZi5pc0RyYWdnaW5nID0gdHJ1ZTtcblxuICAgICAgICBfZGlzcGF0Y2hFdmVudChzZWxmLCBcImRyYWdzdGFydFwiLCBcIm9uRHJhZ1N0YXJ0XCIpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBfdGhpczIuZHJhZyA9IG9uTW92ZTtcblxuICAgIF90aGlzMi5lbmREcmFnID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgIHJldHVybiBvblJlbGVhc2UoZSB8fCBzZWxmLnBvaW50ZXJFdmVudCwgdHJ1ZSk7XG4gICAgfTtcblxuICAgIF90aGlzMi50aW1lU2luY2VEcmFnID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHNlbGYuaXNEcmFnZ2luZyA/IDAgOiAoX2dldFRpbWUoKSAtIGRyYWdFbmRUaW1lKSAvIDEwMDA7XG4gICAgfTtcblxuICAgIF90aGlzMi50aW1lU2luY2VDbGljayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiAoX2dldFRpbWUoKSAtIGNsaWNrVGltZSkgLyAxMDAwO1xuICAgIH07XG5cbiAgICBfdGhpczIuaGl0VGVzdCA9IGZ1bmN0aW9uICh0YXJnZXQsIHRocmVzaG9sZCkge1xuICAgICAgcmV0dXJuIERyYWdnYWJsZS5oaXRUZXN0KHNlbGYudGFyZ2V0LCB0YXJnZXQsIHRocmVzaG9sZCk7XG4gICAgfTtcblxuICAgIF90aGlzMi5nZXREaXJlY3Rpb24gPSBmdW5jdGlvbiAoZnJvbSwgZGlhZ29uYWxUaHJlc2hvbGQpIHtcbiAgICAgIC8vZnJvbSBjYW4gYmUgXCJzdGFydFwiIChkZWZhdWx0KSwgXCJ2ZWxvY2l0eVwiLCBvciBhbiBlbGVtZW50XG4gICAgICB2YXIgbW9kZSA9IGZyb20gPT09IFwidmVsb2NpdHlcIiAmJiBJbmVydGlhUGx1Z2luID8gZnJvbSA6IF9pc09iamVjdChmcm9tKSAmJiAhcm90YXRpb25Nb2RlID8gXCJlbGVtZW50XCIgOiBcInN0YXJ0XCIsXG4gICAgICAgICAgeENoYW5nZSxcbiAgICAgICAgICB5Q2hhbmdlLFxuICAgICAgICAgIHJhdGlvLFxuICAgICAgICAgIGRpcmVjdGlvbixcbiAgICAgICAgICByMSxcbiAgICAgICAgICByMjtcblxuICAgICAgaWYgKG1vZGUgPT09IFwiZWxlbWVudFwiKSB7XG4gICAgICAgIHIxID0gX3BhcnNlUmVjdChzZWxmLnRhcmdldCk7XG4gICAgICAgIHIyID0gX3BhcnNlUmVjdChmcm9tKTtcbiAgICAgIH1cblxuICAgICAgeENoYW5nZSA9IG1vZGUgPT09IFwic3RhcnRcIiA/IHNlbGYueCAtIHN0YXJ0RWxlbWVudFggOiBtb2RlID09PSBcInZlbG9jaXR5XCIgPyBJbmVydGlhUGx1Z2luLmdldFZlbG9jaXR5KHRhcmdldCwgeFByb3ApIDogcjEubGVmdCArIHIxLndpZHRoIC8gMiAtIChyMi5sZWZ0ICsgcjIud2lkdGggLyAyKTtcblxuICAgICAgaWYgKHJvdGF0aW9uTW9kZSkge1xuICAgICAgICByZXR1cm4geENoYW5nZSA8IDAgPyBcImNvdW50ZXItY2xvY2t3aXNlXCIgOiBcImNsb2Nrd2lzZVwiO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGlhZ29uYWxUaHJlc2hvbGQgPSBkaWFnb25hbFRocmVzaG9sZCB8fCAyO1xuICAgICAgICB5Q2hhbmdlID0gbW9kZSA9PT0gXCJzdGFydFwiID8gc2VsZi55IC0gc3RhcnRFbGVtZW50WSA6IG1vZGUgPT09IFwidmVsb2NpdHlcIiA/IEluZXJ0aWFQbHVnaW4uZ2V0VmVsb2NpdHkodGFyZ2V0LCB5UHJvcCkgOiByMS50b3AgKyByMS5oZWlnaHQgLyAyIC0gKHIyLnRvcCArIHIyLmhlaWdodCAvIDIpO1xuICAgICAgICByYXRpbyA9IE1hdGguYWJzKHhDaGFuZ2UgLyB5Q2hhbmdlKTtcbiAgICAgICAgZGlyZWN0aW9uID0gcmF0aW8gPCAxIC8gZGlhZ29uYWxUaHJlc2hvbGQgPyBcIlwiIDogeENoYW5nZSA8IDAgPyBcImxlZnRcIiA6IFwicmlnaHRcIjtcblxuICAgICAgICBpZiAocmF0aW8gPCBkaWFnb25hbFRocmVzaG9sZCkge1xuICAgICAgICAgIGlmIChkaXJlY3Rpb24gIT09IFwiXCIpIHtcbiAgICAgICAgICAgIGRpcmVjdGlvbiArPSBcIi1cIjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBkaXJlY3Rpb24gKz0geUNoYW5nZSA8IDAgPyBcInVwXCIgOiBcImRvd25cIjtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gZGlyZWN0aW9uO1xuICAgIH07XG5cbiAgICBfdGhpczIuYXBwbHlCb3VuZHMgPSBmdW5jdGlvbiAobmV3Qm91bmRzLCBzdGlja3kpIHtcbiAgICAgIHZhciB4LCB5LCBmb3JjZVplcm9WZWxvY2l0eSwgZSwgcGFyZW50LCBpc1Jvb3Q7XG5cbiAgICAgIGlmIChuZXdCb3VuZHMgJiYgdmFycy5ib3VuZHMgIT09IG5ld0JvdW5kcykge1xuICAgICAgICB2YXJzLmJvdW5kcyA9IG5ld0JvdW5kcztcbiAgICAgICAgcmV0dXJuIHNlbGYudXBkYXRlKHRydWUsIHN0aWNreSk7XG4gICAgICB9XG5cbiAgICAgIHN5bmNYWSh0cnVlKTtcbiAgICAgIGNhbGN1bGF0ZUJvdW5kcygpO1xuXG4gICAgICBpZiAoaGFzQm91bmRzICYmICFpc1R3ZWVuaW5nKCkpIHtcbiAgICAgICAgeCA9IHNlbGYueDtcbiAgICAgICAgeSA9IHNlbGYueTtcblxuICAgICAgICBpZiAoeCA+IG1heFgpIHtcbiAgICAgICAgICB4ID0gbWF4WDtcbiAgICAgICAgfSBlbHNlIGlmICh4IDwgbWluWCkge1xuICAgICAgICAgIHggPSBtaW5YO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHkgPiBtYXhZKSB7XG4gICAgICAgICAgeSA9IG1heFk7XG4gICAgICAgIH0gZWxzZSBpZiAoeSA8IG1pblkpIHtcbiAgICAgICAgICB5ID0gbWluWTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzZWxmLnggIT09IHggfHwgc2VsZi55ICE9PSB5KSB7XG4gICAgICAgICAgZm9yY2VaZXJvVmVsb2NpdHkgPSB0cnVlO1xuICAgICAgICAgIHNlbGYueCA9IHNlbGYuZW5kWCA9IHg7XG5cbiAgICAgICAgICBpZiAocm90YXRpb25Nb2RlKSB7XG4gICAgICAgICAgICBzZWxmLmVuZFJvdGF0aW9uID0geDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc2VsZi55ID0gc2VsZi5lbmRZID0geTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBkaXJ0eSA9IHRydWU7XG4gICAgICAgICAgcmVuZGVyKHRydWUpO1xuXG4gICAgICAgICAgaWYgKHNlbGYuYXV0b1Njcm9sbCAmJiAhc2VsZi5pc0RyYWdnaW5nKSB7XG4gICAgICAgICAgICBfcmVjb3JkTWF4U2Nyb2xscyh0YXJnZXQucGFyZW50Tm9kZSk7XG5cbiAgICAgICAgICAgIGUgPSB0YXJnZXQ7XG4gICAgICAgICAgICBfd2luZG93UHJveHkuc2Nyb2xsVG9wID0gX3dpbi5wYWdlWU9mZnNldCAhPSBudWxsID8gX3dpbi5wYWdlWU9mZnNldCA6IG93bmVyRG9jLmRvY3VtZW50RWxlbWVudC5zY3JvbGxUb3AgIT0gbnVsbCA/IG93bmVyRG9jLmRvY3VtZW50RWxlbWVudC5zY3JvbGxUb3AgOiBvd25lckRvYy5ib2R5LnNjcm9sbFRvcDtcbiAgICAgICAgICAgIF93aW5kb3dQcm94eS5zY3JvbGxMZWZ0ID0gX3dpbi5wYWdlWE9mZnNldCAhPSBudWxsID8gX3dpbi5wYWdlWE9mZnNldCA6IG93bmVyRG9jLmRvY3VtZW50RWxlbWVudC5zY3JvbGxMZWZ0ICE9IG51bGwgPyBvd25lckRvYy5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsTGVmdCA6IG93bmVyRG9jLmJvZHkuc2Nyb2xsTGVmdDtcblxuICAgICAgICAgICAgd2hpbGUgKGUgJiYgIWlzUm9vdCkge1xuICAgICAgICAgICAgICAvL3dhbGsgdXAgdGhlIGNoYWluIGFuZCBzZW5zZSB3aGVyZXZlciB0aGUgc2Nyb2xsVG9wL3Njcm9sbExlZnQgZXhjZWVkcyB0aGUgbWF4aW11bS5cbiAgICAgICAgICAgICAgaXNSb290ID0gX2lzUm9vdChlLnBhcmVudE5vZGUpO1xuICAgICAgICAgICAgICBwYXJlbnQgPSBpc1Jvb3QgPyBfd2luZG93UHJveHkgOiBlLnBhcmVudE5vZGU7XG5cbiAgICAgICAgICAgICAgaWYgKGFsbG93WSAmJiBwYXJlbnQuc2Nyb2xsVG9wID4gcGFyZW50Ll9nc01heFNjcm9sbFkpIHtcbiAgICAgICAgICAgICAgICBwYXJlbnQuc2Nyb2xsVG9wID0gcGFyZW50Ll9nc01heFNjcm9sbFk7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBpZiAoYWxsb3dYICYmIHBhcmVudC5zY3JvbGxMZWZ0ID4gcGFyZW50Ll9nc01heFNjcm9sbFgpIHtcbiAgICAgICAgICAgICAgICBwYXJlbnQuc2Nyb2xsTGVmdCA9IHBhcmVudC5fZ3NNYXhTY3JvbGxYO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgZSA9IHBhcmVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc2VsZi5pc1Rocm93aW5nICYmIChmb3JjZVplcm9WZWxvY2l0eSB8fCBzZWxmLmVuZFggPiBtYXhYIHx8IHNlbGYuZW5kWCA8IG1pblggfHwgc2VsZi5lbmRZID4gbWF4WSB8fCBzZWxmLmVuZFkgPCBtaW5ZKSkge1xuICAgICAgICAgIGFuaW1hdGUodmFycy5pbmVydGlhIHx8IHZhcnMudGhyb3dQcm9wcywgZm9yY2VaZXJvVmVsb2NpdHkpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzZWxmO1xuICAgIH07XG5cbiAgICBfdGhpczIudXBkYXRlID0gZnVuY3Rpb24gKGFwcGx5Qm91bmRzLCBzdGlja3ksIGlnbm9yZUV4dGVybmFsQ2hhbmdlcykge1xuICAgICAgaWYgKHN0aWNreSAmJiBzZWxmLmlzUHJlc3NlZCkge1xuICAgICAgICAvLyBpbiBjYXNlIHRoZSBlbGVtZW50IHdhcyByZXBvc2l0aW9uZWQgaW4gdGhlIGRvY3VtZW50IGZsb3csIHRodXMgaXRzIHgveSBtYXkgYmUgaWRlbnRpY2FsIGJ1dCBpdHMgcG9zaXRpb24gaXMgYWN0dWFsbHkgcXVpdGUgZGlmZmVyZW50LlxuICAgICAgICB2YXIgbSA9IGdldEdsb2JhbE1hdHJpeCh0YXJnZXQpLFxuICAgICAgICAgICAgcCA9IGlubmVyTWF0cml4LmFwcGx5KHtcbiAgICAgICAgICB4OiBzZWxmLnggLSBzdGFydEVsZW1lbnRYLFxuICAgICAgICAgIHk6IHNlbGYueSAtIHN0YXJ0RWxlbWVudFlcbiAgICAgICAgfSksXG4gICAgICAgICAgICBtMiA9IGdldEdsb2JhbE1hdHJpeCh0YXJnZXQucGFyZW50Tm9kZSwgdHJ1ZSk7XG4gICAgICAgIG0yLmFwcGx5KHtcbiAgICAgICAgICB4OiBtLmUgLSBwLngsXG4gICAgICAgICAgeTogbS5mIC0gcC55XG4gICAgICAgIH0sIHApO1xuICAgICAgICBzZWxmLnggLT0gcC54IC0gbTIuZTtcbiAgICAgICAgc2VsZi55IC09IHAueSAtIG0yLmY7XG4gICAgICAgIHJlbmRlcih0cnVlKTtcbiAgICAgICAgcmVjb3JkU3RhcnRQb3NpdGlvbnMoKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHggPSBzZWxmLngsXG4gICAgICAgICAgeSA9IHNlbGYueTtcbiAgICAgIHVwZGF0ZU1hdHJpeCghc3RpY2t5KTtcblxuICAgICAgaWYgKGFwcGx5Qm91bmRzKSB7XG4gICAgICAgIHNlbGYuYXBwbHlCb3VuZHMoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRpcnR5ICYmIGlnbm9yZUV4dGVybmFsQ2hhbmdlcyAmJiByZW5kZXIodHJ1ZSk7XG4gICAgICAgIHN5bmNYWSh0cnVlKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHN0aWNreSkge1xuICAgICAgICBzZXRQb2ludGVyUG9zaXRpb24oc2VsZi5wb2ludGVyWCwgc2VsZi5wb2ludGVyWSk7XG4gICAgICAgIGRpcnR5ICYmIHJlbmRlcih0cnVlKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHNlbGYuaXNQcmVzc2VkICYmICFzdGlja3kgJiYgKGFsbG93WCAmJiBNYXRoLmFicyh4IC0gc2VsZi54KSA+IDAuMDEgfHwgYWxsb3dZICYmIE1hdGguYWJzKHkgLSBzZWxmLnkpID4gMC4wMSAmJiAhcm90YXRpb25Nb2RlKSkge1xuICAgICAgICByZWNvcmRTdGFydFBvc2l0aW9ucygpO1xuICAgICAgfVxuXG4gICAgICBpZiAoc2VsZi5hdXRvU2Nyb2xsKSB7XG4gICAgICAgIF9yZWNvcmRNYXhTY3JvbGxzKHRhcmdldC5wYXJlbnROb2RlLCBzZWxmLmlzRHJhZ2dpbmcpO1xuXG4gICAgICAgIGNoZWNrQXV0b1Njcm9sbEJvdW5kcyA9IHNlbGYuaXNEcmFnZ2luZztcbiAgICAgICAgcmVuZGVyKHRydWUpOyAvL2luIGNhc2UgcmVwYXJlbnRpbmcgb2NjdXJyZWQuXG5cbiAgICAgICAgX3JlbW92ZVNjcm9sbExpc3RlbmVyKHRhcmdldCwgdXBkYXRlU2Nyb2xsKTtcblxuICAgICAgICBfYWRkU2Nyb2xsTGlzdGVuZXIodGFyZ2V0LCB1cGRhdGVTY3JvbGwpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc2VsZjtcbiAgICB9O1xuXG4gICAgX3RoaXMyLmVuYWJsZSA9IGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgICB2YXIgc2V0VmFycyA9IHtcbiAgICAgICAgbGF6eTogdHJ1ZVxuICAgICAgfSxcbiAgICAgICAgICBpZCxcbiAgICAgICAgICBpLFxuICAgICAgICAgIHRyaWdnZXI7XG5cbiAgICAgIGlmICh2YXJzLmN1cnNvciAhPT0gZmFsc2UpIHtcbiAgICAgICAgc2V0VmFycy5jdXJzb3IgPSB2YXJzLmN1cnNvciB8fCBfZGVmYXVsdEN1cnNvcjtcbiAgICAgIH1cblxuICAgICAgaWYgKGdzYXAudXRpbHMuY2hlY2tQcmVmaXgoXCJ0b3VjaENhbGxvdXRcIikpIHtcbiAgICAgICAgc2V0VmFycy50b3VjaENhbGxvdXQgPSBcIm5vbmVcIjtcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGUgIT09IFwic29mdFwiKSB7XG4gICAgICAgIF9zZXRUb3VjaEFjdGlvbkZvckFsbERlc2NlbmRhbnRzKHRyaWdnZXJzLCBhbGxvd1ggPT09IGFsbG93WSA/IFwibm9uZVwiIDogdmFycy5hbGxvd05hdGl2ZVRvdWNoU2Nyb2xsaW5nICYmIHRhcmdldC5zY3JvbGxIZWlnaHQgPT09IHRhcmdldC5jbGllbnRIZWlnaHQgPT09ICh0YXJnZXQuc2Nyb2xsV2lkdGggPT09IHRhcmdldC5jbGllbnRIZWlnaHQpIHx8IHZhcnMuYWxsb3dFdmVudERlZmF1bHQgPyBcIm1hbmlwdWxhdGlvblwiIDogYWxsb3dYID8gXCJwYW4teVwiIDogXCJwYW4teFwiKTsgLy8gU29tZSBicm93c2VycyBsaWtlIEludGVybmV0IEV4cGxvcmVyIHdpbGwgZmlyZSBhIHBvaW50ZXJjYW5jZWwgZXZlbnQgd2hlbiB0aGUgdXNlciBhdHRlbXB0cyB0byBkcmFnIHdoZW4gdG91Y2hBY3Rpb24gaXMgXCJtYW5pcHVsYXRlXCIgYmVjYXVzZSBpdCdzIHBlcmNlaXZlZCBhcyBhIHBhbi4gSWYgdGhlIGVsZW1lbnQgaGFzIHNjcm9sbGFibGUgY29udGVudCBpbiBvbmx5IG9uZSBkaXJlY3Rpb24sIHdlIHNob3VsZCB1c2UgcGFuLXggb3IgcGFuLXkgYWNjb3JkaW5nbHkgc28gdGhhdCB0aGUgcG9pbnRlcmNhbmNlbCBkb2Vzbid0IHByZXZlbnQgZHJhZ2dpbmcuXG5cblxuICAgICAgICBpID0gdHJpZ2dlcnMubGVuZ3RoO1xuXG4gICAgICAgIHdoaWxlICgtLWkgPiAtMSkge1xuICAgICAgICAgIHRyaWdnZXIgPSB0cmlnZ2Vyc1tpXTtcbiAgICAgICAgICBfc3VwcG9ydHNQb2ludGVyIHx8IF9hZGRMaXN0ZW5lcih0cmlnZ2VyLCBcIm1vdXNlZG93blwiLCBvblByZXNzKTtcblxuICAgICAgICAgIF9hZGRMaXN0ZW5lcih0cmlnZ2VyLCBcInRvdWNoc3RhcnRcIiwgb25QcmVzcyk7XG5cbiAgICAgICAgICBfYWRkTGlzdGVuZXIodHJpZ2dlciwgXCJjbGlja1wiLCBvbkNsaWNrLCB0cnVlKTsgLy9ub3RlOiB1c2VkIHRvIHBhc3MgdHJ1ZSBmb3IgY2FwdHVyZSBidXQgaXQgcHJldmVudGVkIGNsaWNrLXRvLXBsYXktdmlkZW8gZnVuY3Rpb25hbGl0eSBpbiBGaXJlZm94LlxuXG5cbiAgICAgICAgICBnc2FwLnNldCh0cmlnZ2VyLCBzZXRWYXJzKTtcblxuICAgICAgICAgIGlmICh0cmlnZ2VyLmdldEJCb3ggJiYgdHJpZ2dlci5vd25lclNWR0VsZW1lbnQpIHtcbiAgICAgICAgICAgIC8vIGEgYnVnIGluIGNocm9tZSBkb2Vzbid0IHJlc3BlY3QgdG91Y2gtYWN0aW9uIG9uIFNWRyBlbGVtZW50cyAtIGl0IG9ubHkgd29ya3MgaWYgd2Ugc2V0IGl0IG9uIHRoZSBwYXJlbnQgU1ZHLlxuICAgICAgICAgICAgZ3NhcC5zZXQodHJpZ2dlci5vd25lclNWR0VsZW1lbnQsIHtcbiAgICAgICAgICAgICAgdG91Y2hBY3Rpb246IGFsbG93WCA9PT0gYWxsb3dZID8gXCJub25lXCIgOiB2YXJzLmFsbG93TmF0aXZlVG91Y2hTY3JvbGxpbmcgfHwgdmFycy5hbGxvd0V2ZW50RGVmYXVsdCA/IFwibWFuaXB1bGF0aW9uXCIgOiBhbGxvd1ggPyBcInBhbi15XCIgOiBcInBhbi14XCJcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhcnMuYWxsb3dDb250ZXh0TWVudSB8fCBfYWRkTGlzdGVuZXIodHJpZ2dlciwgXCJjb250ZXh0bWVudVwiLCBvbkNvbnRleHRNZW51KTtcbiAgICAgICAgfVxuXG4gICAgICAgIF9zZXRTZWxlY3RhYmxlKHRyaWdnZXJzLCBmYWxzZSk7XG4gICAgICB9XG5cbiAgICAgIF9hZGRTY3JvbGxMaXN0ZW5lcih0YXJnZXQsIHVwZGF0ZVNjcm9sbCk7XG5cbiAgICAgIGVuYWJsZWQgPSB0cnVlO1xuXG4gICAgICBpZiAoSW5lcnRpYVBsdWdpbiAmJiB0eXBlICE9PSBcInNvZnRcIikge1xuICAgICAgICBJbmVydGlhUGx1Z2luLnRyYWNrKHNjcm9sbFByb3h5IHx8IHRhcmdldCwgeHlNb2RlID8gXCJ4LHlcIiA6IHJvdGF0aW9uTW9kZSA/IFwicm90YXRpb25cIiA6IFwidG9wLGxlZnRcIik7XG4gICAgICB9XG5cbiAgICAgIHRhcmdldC5fZ3NEcmFnSUQgPSBpZCA9IFwiZFwiICsgX2xvb2t1cENvdW50Kys7XG4gICAgICBfbG9va3VwW2lkXSA9IHNlbGY7XG5cbiAgICAgIGlmIChzY3JvbGxQcm94eSkge1xuICAgICAgICBzY3JvbGxQcm94eS5lbmFibGUoKTtcbiAgICAgICAgc2Nyb2xsUHJveHkuZWxlbWVudC5fZ3NEcmFnSUQgPSBpZDtcbiAgICAgIH1cblxuICAgICAgKHZhcnMuYm91bmRzIHx8IHJvdGF0aW9uTW9kZSkgJiYgcmVjb3JkU3RhcnRQb3NpdGlvbnMoKTtcbiAgICAgIHZhcnMuYm91bmRzICYmIHNlbGYuYXBwbHlCb3VuZHMoKTtcbiAgICAgIHJldHVybiBzZWxmO1xuICAgIH07XG5cbiAgICBfdGhpczIuZGlzYWJsZSA9IGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgICB2YXIgZHJhZ2dpbmcgPSBzZWxmLmlzRHJhZ2dpbmcsXG4gICAgICAgICAgaSA9IHRyaWdnZXJzLmxlbmd0aCxcbiAgICAgICAgICB0cmlnZ2VyO1xuXG4gICAgICB3aGlsZSAoLS1pID4gLTEpIHtcbiAgICAgICAgX3NldFN0eWxlKHRyaWdnZXJzW2ldLCBcImN1cnNvclwiLCBudWxsKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGUgIT09IFwic29mdFwiKSB7XG4gICAgICAgIF9zZXRUb3VjaEFjdGlvbkZvckFsbERlc2NlbmRhbnRzKHRyaWdnZXJzLCBudWxsKTtcblxuICAgICAgICBpID0gdHJpZ2dlcnMubGVuZ3RoO1xuXG4gICAgICAgIHdoaWxlICgtLWkgPiAtMSkge1xuICAgICAgICAgIHRyaWdnZXIgPSB0cmlnZ2Vyc1tpXTtcblxuICAgICAgICAgIF9zZXRTdHlsZSh0cmlnZ2VyLCBcInRvdWNoQ2FsbG91dFwiLCBudWxsKTtcblxuICAgICAgICAgIF9yZW1vdmVMaXN0ZW5lcih0cmlnZ2VyLCBcIm1vdXNlZG93blwiLCBvblByZXNzKTtcblxuICAgICAgICAgIF9yZW1vdmVMaXN0ZW5lcih0cmlnZ2VyLCBcInRvdWNoc3RhcnRcIiwgb25QcmVzcyk7XG5cbiAgICAgICAgICBfcmVtb3ZlTGlzdGVuZXIodHJpZ2dlciwgXCJjbGlja1wiLCBvbkNsaWNrKTtcblxuICAgICAgICAgIF9yZW1vdmVMaXN0ZW5lcih0cmlnZ2VyLCBcImNvbnRleHRtZW51XCIsIG9uQ29udGV4dE1lbnUpO1xuICAgICAgICB9XG5cbiAgICAgICAgX3NldFNlbGVjdGFibGUodHJpZ2dlcnMsIHRydWUpO1xuXG4gICAgICAgIGlmICh0b3VjaEV2ZW50VGFyZ2V0KSB7XG4gICAgICAgICAgX3JlbW92ZUxpc3RlbmVyKHRvdWNoRXZlbnRUYXJnZXQsIFwidG91Y2hjYW5jZWxcIiwgb25SZWxlYXNlKTtcblxuICAgICAgICAgIF9yZW1vdmVMaXN0ZW5lcih0b3VjaEV2ZW50VGFyZ2V0LCBcInRvdWNoZW5kXCIsIG9uUmVsZWFzZSk7XG5cbiAgICAgICAgICBfcmVtb3ZlTGlzdGVuZXIodG91Y2hFdmVudFRhcmdldCwgXCJ0b3VjaG1vdmVcIiwgb25Nb3ZlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIF9yZW1vdmVMaXN0ZW5lcihvd25lckRvYywgXCJtb3VzZXVwXCIsIG9uUmVsZWFzZSk7XG5cbiAgICAgICAgX3JlbW92ZUxpc3RlbmVyKG93bmVyRG9jLCBcIm1vdXNlbW92ZVwiLCBvbk1vdmUpO1xuICAgICAgfVxuXG4gICAgICBfcmVtb3ZlU2Nyb2xsTGlzdGVuZXIodGFyZ2V0LCB1cGRhdGVTY3JvbGwpO1xuXG4gICAgICBlbmFibGVkID0gZmFsc2U7XG4gICAgICBJbmVydGlhUGx1Z2luICYmIHR5cGUgIT09IFwic29mdFwiICYmIEluZXJ0aWFQbHVnaW4udW50cmFjayhzY3JvbGxQcm94eSB8fCB0YXJnZXQsIHh5TW9kZSA/IFwieCx5XCIgOiByb3RhdGlvbk1vZGUgPyBcInJvdGF0aW9uXCIgOiBcInRvcCxsZWZ0XCIpO1xuICAgICAgc2Nyb2xsUHJveHkgJiYgc2Nyb2xsUHJveHkuZGlzYWJsZSgpO1xuXG4gICAgICBfcmVtb3ZlRnJvbVJlbmRlclF1ZXVlKHJlbmRlcik7XG5cbiAgICAgIHNlbGYuaXNEcmFnZ2luZyA9IHNlbGYuaXNQcmVzc2VkID0gaXNDbGlja2luZyA9IGZhbHNlO1xuICAgICAgZHJhZ2dpbmcgJiYgX2Rpc3BhdGNoRXZlbnQoc2VsZiwgXCJkcmFnZW5kXCIsIFwib25EcmFnRW5kXCIpO1xuICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfTtcblxuICAgIF90aGlzMi5lbmFibGVkID0gZnVuY3Rpb24gKHZhbHVlLCB0eXBlKSB7XG4gICAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IHZhbHVlID8gc2VsZi5lbmFibGUodHlwZSkgOiBzZWxmLmRpc2FibGUodHlwZSkgOiBlbmFibGVkO1xuICAgIH07XG5cbiAgICBfdGhpczIua2lsbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHNlbGYuaXNUaHJvd2luZyA9IGZhbHNlO1xuICAgICAgc2VsZi50d2VlbiAmJiBzZWxmLnR3ZWVuLmtpbGwoKTtcbiAgICAgIHNlbGYuZGlzYWJsZSgpO1xuICAgICAgZ3NhcC5zZXQodHJpZ2dlcnMsIHtcbiAgICAgICAgY2xlYXJQcm9wczogXCJ1c2VyU2VsZWN0XCJcbiAgICAgIH0pO1xuICAgICAgZGVsZXRlIF9sb29rdXBbdGFyZ2V0Ll9nc0RyYWdJRF07XG4gICAgICByZXR1cm4gc2VsZjtcbiAgICB9O1xuXG4gICAgaWYgKH50eXBlLmluZGV4T2YoXCJzY3JvbGxcIikpIHtcbiAgICAgIHNjcm9sbFByb3h5ID0gX3RoaXMyLnNjcm9sbFByb3h5ID0gbmV3IFNjcm9sbFByb3h5KHRhcmdldCwgX2V4dGVuZCh7XG4gICAgICAgIG9uS2lsbDogZnVuY3Rpb24gb25LaWxsKCkge1xuICAgICAgICAgIC8vU2Nyb2xsUHJveHkncyBvbktpbGwoKSBnZXRzIGNhbGxlZCBpZi93aGVuIHRoZSBTY3JvbGxQcm94eSBzZW5zZXMgdGhhdCB0aGUgdXNlciBpbnRlcmFjdGVkIHdpdGggdGhlIHNjcm9sbCBwb3NpdGlvbiBtYW51YWxseSAobGlrZSB1c2luZyB0aGUgc2Nyb2xsYmFyKS4gSUU5IGRvZXNuJ3QgZmlyZSB0aGUgXCJtb3VzZXVwXCIgcHJvcGVybHkgd2hlbiB1c2VycyBkcmFnIHRoZSBzY3JvbGxiYXIgb2YgYW4gZWxlbWVudCwgc28gdGhpcyB3b3JrcyBhcm91bmQgdGhhdCBpc3N1ZS5cbiAgICAgICAgICBzZWxmLmlzUHJlc3NlZCAmJiBvblJlbGVhc2UobnVsbCk7XG4gICAgICAgIH1cbiAgICAgIH0sIHZhcnMpKTsgLy9hIGJ1ZyBpbiBtYW55IEFuZHJvaWQgZGV2aWNlcycgc3RvY2sgYnJvd3NlciBjYXVzZXMgc2Nyb2xsVG9wIHRvIGdldCBmb3JjZWQgYmFjayB0byAwIGFmdGVyIGl0IGlzIGFsdGVyZWQgdmlhIEpTLCBzbyB3ZSBzZXQgb3ZlcmZsb3cgdG8gXCJoaWRkZW5cIiBvbiBtb2JpbGUvdG91Y2ggZGV2aWNlcyAodGhleSBoaWRlIHRoZSBzY3JvbGwgYmFyIGFueXdheSkuIFRoYXQgd29ya3MgYXJvdW5kIHRoZSBidWcuIChUaGlzIGJ1ZyBpcyBkaXNjdXNzZWQgYXQgaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC9hbmRyb2lkL2lzc3Vlcy9kZXRhaWw/aWQ9MTk2MjUpXG5cbiAgICAgIHRhcmdldC5zdHlsZS5vdmVyZmxvd1kgPSBhbGxvd1kgJiYgIV9pc1RvdWNoRGV2aWNlID8gXCJhdXRvXCIgOiBcImhpZGRlblwiO1xuICAgICAgdGFyZ2V0LnN0eWxlLm92ZXJmbG93WCA9IGFsbG93WCAmJiAhX2lzVG91Y2hEZXZpY2UgPyBcImF1dG9cIiA6IFwiaGlkZGVuXCI7XG4gICAgICB0YXJnZXQgPSBzY3JvbGxQcm94eS5jb250ZW50O1xuICAgIH1cblxuICAgIGlmIChyb3RhdGlvbk1vZGUpIHtcbiAgICAgIGtpbGxQcm9wcy5yb3RhdGlvbiA9IDE7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChhbGxvd1gpIHtcbiAgICAgICAga2lsbFByb3BzW3hQcm9wXSA9IDE7XG4gICAgICB9XG5cbiAgICAgIGlmIChhbGxvd1kpIHtcbiAgICAgICAga2lsbFByb3BzW3lQcm9wXSA9IDE7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZ3NDYWNoZS5mb3JjZTNEID0gXCJmb3JjZTNEXCIgaW4gdmFycyA/IHZhcnMuZm9yY2UzRCA6IHRydWU7IC8vb3RoZXJ3aXNlLCBub3JtYWwgZHJhZ2dpbmcgd291bGQgYmUgaW4gMkQgYW5kIHRoZW4gYXMgc29vbiBhcyBpdCdzIHJlbGVhc2VkIGFuZCB0aGVyZSdzIGFuIGluZXJ0aWEgdHdlZW4sIGl0J2QganVtcCB0byAzRCB3aGljaCBjYW4gY3JlYXRlIGFuIGluaXRpYWwganVtcCBkdWUgdG8gdGhlIHdvcmsgdGhlIGJyb3dzZXIgbXVzdCB0byBkbyBsYXllcml6ZSBpdC5cblxuICAgIF90aGlzMi5lbmFibGUoKTtcblxuICAgIHJldHVybiBfdGhpczI7XG4gIH1cblxuICBEcmFnZ2FibGUucmVnaXN0ZXIgPSBmdW5jdGlvbiByZWdpc3Rlcihjb3JlKSB7XG4gICAgZ3NhcCA9IGNvcmU7XG5cbiAgICBfaW5pdENvcmUoKTtcbiAgfTtcblxuICBEcmFnZ2FibGUuY3JlYXRlID0gZnVuY3Rpb24gY3JlYXRlKHRhcmdldHMsIHZhcnMpIHtcbiAgICBfY29yZUluaXR0ZWQgfHwgX2luaXRDb3JlKHRydWUpO1xuICAgIHJldHVybiBfdG9BcnJheSh0YXJnZXRzKS5tYXAoZnVuY3Rpb24gKHRhcmdldCkge1xuICAgICAgcmV0dXJuIG5ldyBEcmFnZ2FibGUodGFyZ2V0LCB2YXJzKTtcbiAgICB9KTtcbiAgfTtcblxuICBEcmFnZ2FibGUuZ2V0ID0gZnVuY3Rpb24gZ2V0KHRhcmdldCkge1xuICAgIHJldHVybiBfbG9va3VwWyhfdG9BcnJheSh0YXJnZXQpWzBdIHx8IHt9KS5fZ3NEcmFnSURdO1xuICB9O1xuXG4gIERyYWdnYWJsZS50aW1lU2luY2VEcmFnID0gZnVuY3Rpb24gdGltZVNpbmNlRHJhZygpIHtcbiAgICByZXR1cm4gKF9nZXRUaW1lKCkgLSBfbGFzdERyYWdUaW1lKSAvIDEwMDA7XG4gIH07XG5cbiAgRHJhZ2dhYmxlLmhpdFRlc3QgPSBmdW5jdGlvbiBoaXRUZXN0KG9iajEsIG9iajIsIHRocmVzaG9sZCkge1xuICAgIGlmIChvYmoxID09PSBvYmoyKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgdmFyIHIxID0gX3BhcnNlUmVjdChvYmoxKSxcbiAgICAgICAgcjIgPSBfcGFyc2VSZWN0KG9iajIpLFxuICAgICAgICB0b3AgPSByMS50b3AsXG4gICAgICAgIGxlZnQgPSByMS5sZWZ0LFxuICAgICAgICByaWdodCA9IHIxLnJpZ2h0LFxuICAgICAgICBib3R0b20gPSByMS5ib3R0b20sXG4gICAgICAgIHdpZHRoID0gcjEud2lkdGgsXG4gICAgICAgIGhlaWdodCA9IHIxLmhlaWdodCxcbiAgICAgICAgaXNPdXRzaWRlID0gcjIubGVmdCA+IHJpZ2h0IHx8IHIyLnJpZ2h0IDwgbGVmdCB8fCByMi50b3AgPiBib3R0b20gfHwgcjIuYm90dG9tIDwgdG9wLFxuICAgICAgICBvdmVybGFwLFxuICAgICAgICBhcmVhLFxuICAgICAgICBpc1JhdGlvO1xuXG4gICAgaWYgKGlzT3V0c2lkZSB8fCAhdGhyZXNob2xkKSB7XG4gICAgICByZXR1cm4gIWlzT3V0c2lkZTtcbiAgICB9XG5cbiAgICBpc1JhdGlvID0gKHRocmVzaG9sZCArIFwiXCIpLmluZGV4T2YoXCIlXCIpICE9PSAtMTtcbiAgICB0aHJlc2hvbGQgPSBwYXJzZUZsb2F0KHRocmVzaG9sZCkgfHwgMDtcbiAgICBvdmVybGFwID0ge1xuICAgICAgbGVmdDogTWF0aC5tYXgobGVmdCwgcjIubGVmdCksXG4gICAgICB0b3A6IE1hdGgubWF4KHRvcCwgcjIudG9wKVxuICAgIH07XG4gICAgb3ZlcmxhcC53aWR0aCA9IE1hdGgubWluKHJpZ2h0LCByMi5yaWdodCkgLSBvdmVybGFwLmxlZnQ7XG4gICAgb3ZlcmxhcC5oZWlnaHQgPSBNYXRoLm1pbihib3R0b20sIHIyLmJvdHRvbSkgLSBvdmVybGFwLnRvcDtcblxuICAgIGlmIChvdmVybGFwLndpZHRoIDwgMCB8fCBvdmVybGFwLmhlaWdodCA8IDApIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAoaXNSYXRpbykge1xuICAgICAgdGhyZXNob2xkICo9IDAuMDE7XG4gICAgICBhcmVhID0gb3ZlcmxhcC53aWR0aCAqIG92ZXJsYXAuaGVpZ2h0O1xuICAgICAgcmV0dXJuIGFyZWEgPj0gd2lkdGggKiBoZWlnaHQgKiB0aHJlc2hvbGQgfHwgYXJlYSA+PSByMi53aWR0aCAqIHIyLmhlaWdodCAqIHRocmVzaG9sZDtcbiAgICB9XG5cbiAgICByZXR1cm4gb3ZlcmxhcC53aWR0aCA+IHRocmVzaG9sZCAmJiBvdmVybGFwLmhlaWdodCA+IHRocmVzaG9sZDtcbiAgfTtcblxuICByZXR1cm4gRHJhZ2dhYmxlO1xufShFdmVudERpc3BhdGNoZXIpO1xuXG5fc2V0RGVmYXVsdHMoRHJhZ2dhYmxlLnByb3RvdHlwZSwge1xuICBwb2ludGVyWDogMCxcbiAgcG9pbnRlclk6IDAsXG4gIHN0YXJ0WDogMCxcbiAgc3RhcnRZOiAwLFxuICBkZWx0YVg6IDAsXG4gIGRlbHRhWTogMCxcbiAgaXNEcmFnZ2luZzogZmFsc2UsXG4gIGlzUHJlc3NlZDogZmFsc2Vcbn0pO1xuXG5EcmFnZ2FibGUuekluZGV4ID0gMTAwMDtcbkRyYWdnYWJsZS52ZXJzaW9uID0gXCIzLjEwLjRcIjtcbl9nZXRHU0FQKCkgJiYgZ3NhcC5yZWdpc3RlclBsdWdpbihEcmFnZ2FibGUpO1xuZXhwb3J0IHsgRHJhZ2dhYmxlIGFzIGRlZmF1bHQgfTsiLCIvKiFcbiAqIHBhdGhzIDMuMTAuNFxuICogaHR0cHM6Ly9ncmVlbnNvY2suY29tXG4gKlxuICogQ29weXJpZ2h0IDIwMDgtMjAyMiwgR3JlZW5Tb2NrLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogU3ViamVjdCB0byB0aGUgdGVybXMgYXQgaHR0cHM6Ly9ncmVlbnNvY2suY29tL3N0YW5kYXJkLWxpY2Vuc2Ugb3IgZm9yXG4gKiBDbHViIEdyZWVuU29jayBtZW1iZXJzLCB0aGUgYWdyZWVtZW50IGlzc3VlZCB3aXRoIHRoYXQgbWVtYmVyc2hpcC5cbiAqIEBhdXRob3I6IEphY2sgRG95bGUsIGphY2tAZ3JlZW5zb2NrLmNvbVxuKi9cblxuLyogZXNsaW50LWRpc2FibGUgKi9cbnZhciBfc3ZnUGF0aEV4cCA9IC9bYWNobG1xc3R2el18KC0/XFxkKlxcLj9cXGQqKD86ZVtcXC0rXT9cXGQrKT8pWzAtOV0vaWcsXG4gICAgX251bWJlcnNFeHAgPSAvKD86KC0pP1xcZCpcXC4/XFxkKig/OmVbXFwtK10/XFxkKyk/KVswLTldL2lnLFxuICAgIF9zY2llbnRpZmljID0gL1tcXCtcXC1dP1xcZCpcXC4/XFxkK2VbXFwrXFwtXT9cXGQrL2lnLFxuICAgIF9zZWxlY3RvckV4cCA9IC8oXlsjXFwuXVthLXpdfFthLXldW2Etel0pL2ksXG4gICAgX0RFRzJSQUQgPSBNYXRoLlBJIC8gMTgwLFxuICAgIF9SQUQyREVHID0gMTgwIC8gTWF0aC5QSSxcbiAgICBfc2luID0gTWF0aC5zaW4sXG4gICAgX2NvcyA9IE1hdGguY29zLFxuICAgIF9hYnMgPSBNYXRoLmFicyxcbiAgICBfc3FydCA9IE1hdGguc3FydCxcbiAgICBfYXRhbjIgPSBNYXRoLmF0YW4yLFxuICAgIF9sYXJnZU51bSA9IDFlOCxcbiAgICBfaXNTdHJpbmcgPSBmdW5jdGlvbiBfaXNTdHJpbmcodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIjtcbn0sXG4gICAgX2lzTnVtYmVyID0gZnVuY3Rpb24gX2lzTnVtYmVyKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09IFwibnVtYmVyXCI7XG59LFxuICAgIF9pc1VuZGVmaW5lZCA9IGZ1bmN0aW9uIF9pc1VuZGVmaW5lZCh2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSBcInVuZGVmaW5lZFwiO1xufSxcbiAgICBfdGVtcCA9IHt9LFxuICAgIF90ZW1wMiA9IHt9LFxuICAgIF9yb3VuZGluZ051bSA9IDFlNSxcbiAgICBfd3JhcFByb2dyZXNzID0gZnVuY3Rpb24gX3dyYXBQcm9ncmVzcyhwcm9ncmVzcykge1xuICByZXR1cm4gTWF0aC5yb3VuZCgocHJvZ3Jlc3MgKyBfbGFyZ2VOdW0pICUgMSAqIF9yb3VuZGluZ051bSkgLyBfcm91bmRpbmdOdW0gfHwgKHByb2dyZXNzIDwgMCA/IDAgOiAxKTtcbn0sXG4gICAgLy9pZiBwcm9ncmVzcyBsYW5kcyBvbiAxLCB0aGUgJSB3aWxsIG1ha2UgaXQgMCB3aGljaCBpcyB3aHkgd2UgfHwgMSwgYnV0IG5vdCBpZiBpdCdzIG5lZ2F0aXZlIGJlY2F1c2UgaXQgbWFrZXMgbW9yZSBzZW5zZSBmb3IgbW90aW9uIHRvIGVuZCBhdCAwIGluIHRoYXQgY2FzZS5cbl9yb3VuZCA9IGZ1bmN0aW9uIF9yb3VuZCh2YWx1ZSkge1xuICByZXR1cm4gTWF0aC5yb3VuZCh2YWx1ZSAqIF9yb3VuZGluZ051bSkgLyBfcm91bmRpbmdOdW0gfHwgMDtcbn0sXG4gICAgX3JvdW5kUHJlY2lzZSA9IGZ1bmN0aW9uIF9yb3VuZFByZWNpc2UodmFsdWUpIHtcbiAgcmV0dXJuIE1hdGgucm91bmQodmFsdWUgKiAxZTEwKSAvIDFlMTAgfHwgMDtcbn0sXG4gICAgX3NwbGl0U2VnbWVudCA9IGZ1bmN0aW9uIF9zcGxpdFNlZ21lbnQocmF3UGF0aCwgc2VnSW5kZXgsIGksIHQpIHtcbiAgdmFyIHNlZ21lbnQgPSByYXdQYXRoW3NlZ0luZGV4XSxcbiAgICAgIHNoaWZ0ID0gdCA9PT0gMSA/IDYgOiBzdWJkaXZpZGVTZWdtZW50KHNlZ21lbnQsIGksIHQpO1xuXG4gIGlmIChzaGlmdCAmJiBzaGlmdCArIGkgKyAyIDwgc2VnbWVudC5sZW5ndGgpIHtcbiAgICByYXdQYXRoLnNwbGljZShzZWdJbmRleCwgMCwgc2VnbWVudC5zbGljZSgwLCBpICsgc2hpZnQgKyAyKSk7XG4gICAgc2VnbWVudC5zcGxpY2UoMCwgaSArIHNoaWZ0KTtcbiAgICByZXR1cm4gMTtcbiAgfVxufSxcbiAgICBfZ2V0U2FtcGxlSW5kZXggPSBmdW5jdGlvbiBfZ2V0U2FtcGxlSW5kZXgoc2FtcGxlcywgbGVuZ3RoLCBwcm9ncmVzcykge1xuICAvLyBzbGlnaHRseSBzbG93ZXIgd2F5IHRoYW4gZG9pbmcgdGhpcyAod2hlbiB0aGVyZSdzIG5vIGxvb2t1cCk6IHNlZ21lbnQubG9va3VwW3Byb2dyZXNzIDwgMSA/IH5+KGxlbmd0aCAvIHNlZ21lbnQubWluTGVuZ3RoKSA6IHNlZ21lbnQubG9va3VwLmxlbmd0aCAtIDFdIHx8IDA7XG4gIHZhciBsID0gc2FtcGxlcy5sZW5ndGgsXG4gICAgICBpID0gfn4ocHJvZ3Jlc3MgKiBsKTtcblxuICBpZiAoc2FtcGxlc1tpXSA+IGxlbmd0aCkge1xuICAgIHdoaWxlICgtLWkgJiYgc2FtcGxlc1tpXSA+IGxlbmd0aCkge31cblxuICAgIGkgPCAwICYmIChpID0gMCk7XG4gIH0gZWxzZSB7XG4gICAgd2hpbGUgKHNhbXBsZXNbKytpXSA8IGxlbmd0aCAmJiBpIDwgbCkge31cbiAgfVxuXG4gIHJldHVybiBpIDwgbCA/IGkgOiBsIC0gMTtcbn0sXG4gICAgX3JldmVyc2VSYXdQYXRoID0gZnVuY3Rpb24gX3JldmVyc2VSYXdQYXRoKHJhd1BhdGgsIHNraXBPdXRlcikge1xuICB2YXIgaSA9IHJhd1BhdGgubGVuZ3RoO1xuICBza2lwT3V0ZXIgfHwgcmF3UGF0aC5yZXZlcnNlKCk7XG5cbiAgd2hpbGUgKGktLSkge1xuICAgIHJhd1BhdGhbaV0ucmV2ZXJzZWQgfHwgcmV2ZXJzZVNlZ21lbnQocmF3UGF0aFtpXSk7XG4gIH1cbn0sXG4gICAgX2NvcHlNZXRhRGF0YSA9IGZ1bmN0aW9uIF9jb3B5TWV0YURhdGEoc291cmNlLCBjb3B5KSB7XG4gIGNvcHkudG90YWxMZW5ndGggPSBzb3VyY2UudG90YWxMZW5ndGg7XG5cbiAgaWYgKHNvdXJjZS5zYW1wbGVzKSB7XG4gICAgLy9zZWdtZW50XG4gICAgY29weS5zYW1wbGVzID0gc291cmNlLnNhbXBsZXMuc2xpY2UoMCk7XG4gICAgY29weS5sb29rdXAgPSBzb3VyY2UubG9va3VwLnNsaWNlKDApO1xuICAgIGNvcHkubWluTGVuZ3RoID0gc291cmNlLm1pbkxlbmd0aDtcbiAgICBjb3B5LnJlc29sdXRpb24gPSBzb3VyY2UucmVzb2x1dGlvbjtcbiAgfSBlbHNlIGlmIChzb3VyY2UudG90YWxQb2ludHMpIHtcbiAgICAvL3Jhd1BhdGhcbiAgICBjb3B5LnRvdGFsUG9pbnRzID0gc291cmNlLnRvdGFsUG9pbnRzO1xuICB9XG5cbiAgcmV0dXJuIGNvcHk7XG59LFxuICAgIC8vcHVzaGVzIGEgbmV3IHNlZ21lbnQgaW50byBhIHJhd1BhdGgsIGJ1dCBpZiBpdHMgc3RhcnRpbmcgdmFsdWVzIG1hdGNoIHRoZSBlbmRpbmcgdmFsdWVzIG9mIHRoZSBsYXN0IHNlZ21lbnQsIGl0J2xsIG1lcmdlIGl0IGludG8gdGhhdCBzYW1lIHNlZ21lbnQgKHRvIHJlZHVjZSB0aGUgbnVtYmVyIG9mIHNlZ21lbnRzKVxuX2FwcGVuZE9yTWVyZ2UgPSBmdW5jdGlvbiBfYXBwZW5kT3JNZXJnZShyYXdQYXRoLCBzZWdtZW50KSB7XG4gIHZhciBpbmRleCA9IHJhd1BhdGgubGVuZ3RoLFxuICAgICAgcHJldlNlZyA9IHJhd1BhdGhbaW5kZXggLSAxXSB8fCBbXSxcbiAgICAgIGwgPSBwcmV2U2VnLmxlbmd0aDtcblxuICBpZiAoaW5kZXggJiYgc2VnbWVudFswXSA9PT0gcHJldlNlZ1tsIC0gMl0gJiYgc2VnbWVudFsxXSA9PT0gcHJldlNlZ1tsIC0gMV0pIHtcbiAgICBzZWdtZW50ID0gcHJldlNlZy5jb25jYXQoc2VnbWVudC5zbGljZSgyKSk7XG4gICAgaW5kZXgtLTtcbiAgfVxuXG4gIHJhd1BhdGhbaW5kZXhdID0gc2VnbWVudDtcbn0sXG4gICAgX2Jlc3REaXN0YW5jZTtcbi8qIFRFUk1JTk9MT0dZXG4gLSBSYXdQYXRoIC0gYW4gYXJyYXkgb2YgYXJyYXlzLCBvbmUgZm9yIGVhY2ggU2VnbWVudC4gQSBzaW5nbGUgUmF3UGF0aCBjb3VsZCBoYXZlIG11bHRpcGxlIFwiTVwiIGNvbW1hbmRzLCBkZWZpbmluZyBTZWdtZW50cyAocGF0aHMgYXJlbid0IGFsd2F5cyBjb25uZWN0ZWQpLlxuIC0gU2VnbWVudCAtIGFuIGFycmF5IGNvbnRhaW5pbmcgYSBzZXF1ZW5jZSBvZiBDdWJpYyBCZXppZXIgY29vcmRpbmF0ZXMgaW4gYWx0ZXJuYXRpbmcgeCwgeSwgeCwgeSBmb3JtYXQuIFN0YXJ0aW5nIGFuY2hvciwgdGhlbiBjb250cm9sIHBvaW50IDEsIGNvbnRyb2wgcG9pbnQgMiwgYW5kIGVuZGluZyBhbmNob3IsIHRoZW4gdGhlIG5leHQgY29udHJvbCBwb2ludCAxLCBjb250cm9sIHBvaW50IDIsIGFuY2hvciwgZXRjLiBVc2VzIGxlc3MgbWVtb3J5IHRoYW4gYW4gYXJyYXkgd2l0aCBhIGJ1bmNoIG9mIHt4LCB5fSBwb2ludHMuXG4gLSBCZXppZXIgLSBhIHNpbmdsZSBjdWJpYyBCZXppZXIgd2l0aCBhIHN0YXJ0aW5nIGFuY2hvciwgdHdvIGNvbnRyb2wgcG9pbnRzLCBhbmQgYW4gZW5kaW5nIGFuY2hvci5cbiAtIHRoZSB2YXJpYWJsZSBcInRcIiBpcyB0eXBpY2FsbHkgdGhlIHBvc2l0aW9uIGFsb25nIGFuIGluZGl2aWR1YWwgQmV6aWVyIHBhdGggKHRpbWUpIGFuZCBpdCdzIE5PVCBsaW5lYXIsIG1lYW5pbmcgaXQgY291bGQgYWNjZWxlcmF0ZS9kZWNlbGVyYXRlIGJhc2VkIG9uIHRoZSBjb250cm9sIHBvaW50cyB3aGVyZWFzIHRoZSBcInBcIiBvciBcInByb2dyZXNzXCIgdmFsdWUgaXMgbGluZWFybHkgbWFwcGVkIHRvIHRoZSB3aG9sZSBwYXRoLCBzbyBpdCBzaG91bGRuJ3QgcmVhbGx5IGFjY2VsZXJhdGUvZGVjZWxlcmF0ZSBiYXNlZCBvbiBjb250cm9sIHBvaW50cy4gU28gYSBwcm9ncmVzcyBvZiAwLjIgd291bGQgYmUgYWxtb3N0IGV4YWN0bHkgMjAlIGFsb25nIHRoZSBwYXRoLiBcInRcIiBpcyBPTkxZIGluIGFuIGluZGl2aWR1YWwgQmV6aWVyIHBpZWNlLlxuICovXG4vL2FjY2VwdHMgYmFzaWMgc2VsZWN0b3IgdGV4dCwgYSBwYXRoIGluc3RhbmNlLCBhIFJhd1BhdGggaW5zdGFuY2UsIG9yIGEgU2VnbWVudCBhbmQgcmV0dXJucyBhIFJhd1BhdGggKG1ha2VzIGl0IGVhc3kgdG8gaG9tb2dlbml6ZSB0aGluZ3MpLiBJZiBhbiBlbGVtZW50IG9yIHNlbGVjdG9yIHRleHQgaXMgcGFzc2VkIGluLCBpdCdsbCBhbHNvIGNhY2hlIHRoZSB2YWx1ZSBzbyB0aGF0IGlmIGl0J3MgcXVlcmllZCBhZ2FpbiwgaXQnbGwganVzdCB0YWtlIHRoZSBwYXRoIGRhdGEgZnJvbSB0aGVyZSBpbnN0ZWFkIG9mIHBhcnNpbmcgaXQgYWxsIG92ZXIgYWdhaW4gKGFzIGxvbmcgYXMgdGhlIHBhdGggZGF0YSBpdHNlbGYgaGFzbid0IGNoYW5nZWQgLSBpdCdsbCBjaGVjaykuXG5cblxuZXhwb3J0IGZ1bmN0aW9uIGdldFJhd1BhdGgodmFsdWUpIHtcbiAgdmFsdWUgPSBfaXNTdHJpbmcodmFsdWUpICYmIF9zZWxlY3RvckV4cC50ZXN0KHZhbHVlKSA/IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IodmFsdWUpIHx8IHZhbHVlIDogdmFsdWU7XG4gIHZhciBlID0gdmFsdWUuZ2V0QXR0cmlidXRlID8gdmFsdWUgOiAwLFxuICAgICAgcmF3UGF0aDtcblxuICBpZiAoZSAmJiAodmFsdWUgPSB2YWx1ZS5nZXRBdHRyaWJ1dGUoXCJkXCIpKSkge1xuICAgIC8vaW1wbGVtZW50cyBjYWNoaW5nXG4gICAgaWYgKCFlLl9nc1BhdGgpIHtcbiAgICAgIGUuX2dzUGF0aCA9IHt9O1xuICAgIH1cblxuICAgIHJhd1BhdGggPSBlLl9nc1BhdGhbdmFsdWVdO1xuICAgIHJldHVybiByYXdQYXRoICYmICFyYXdQYXRoLl9kaXJ0eSA/IHJhd1BhdGggOiBlLl9nc1BhdGhbdmFsdWVdID0gc3RyaW5nVG9SYXdQYXRoKHZhbHVlKTtcbiAgfVxuXG4gIHJldHVybiAhdmFsdWUgPyBjb25zb2xlLndhcm4oXCJFeHBlY3RpbmcgYSA8cGF0aD4gZWxlbWVudCBvciBhbiBTVkcgcGF0aCBkYXRhIHN0cmluZ1wiKSA6IF9pc1N0cmluZyh2YWx1ZSkgPyBzdHJpbmdUb1Jhd1BhdGgodmFsdWUpIDogX2lzTnVtYmVyKHZhbHVlWzBdKSA/IFt2YWx1ZV0gOiB2YWx1ZTtcbn0gLy9jb3BpZXMgYSBSYXdQYXRoIFdJVEhPVVQgdGhlIGxlbmd0aCBtZXRhIGRhdGEgKGZvciBzcGVlZClcblxuZXhwb3J0IGZ1bmN0aW9uIGNvcHlSYXdQYXRoKHJhd1BhdGgpIHtcbiAgdmFyIGEgPSBbXSxcbiAgICAgIGkgPSAwO1xuXG4gIGZvciAoOyBpIDwgcmF3UGF0aC5sZW5ndGg7IGkrKykge1xuICAgIGFbaV0gPSBfY29weU1ldGFEYXRhKHJhd1BhdGhbaV0sIHJhd1BhdGhbaV0uc2xpY2UoMCkpO1xuICB9XG5cbiAgcmV0dXJuIF9jb3B5TWV0YURhdGEocmF3UGF0aCwgYSk7XG59XG5leHBvcnQgZnVuY3Rpb24gcmV2ZXJzZVNlZ21lbnQoc2VnbWVudCkge1xuICB2YXIgaSA9IDAsXG4gICAgICB5O1xuICBzZWdtZW50LnJldmVyc2UoKTsgLy90aGlzIHdpbGwgaW52ZXJ0IHRoZSBvcmRlciB5LCB4LCB5LCB4IHNvIHdlIG11c3QgZmxpcCBpdCBiYWNrLlxuXG4gIGZvciAoOyBpIDwgc2VnbWVudC5sZW5ndGg7IGkgKz0gMikge1xuICAgIHkgPSBzZWdtZW50W2ldO1xuICAgIHNlZ21lbnRbaV0gPSBzZWdtZW50W2kgKyAxXTtcbiAgICBzZWdtZW50W2kgKyAxXSA9IHk7XG4gIH1cblxuICBzZWdtZW50LnJldmVyc2VkID0gIXNlZ21lbnQucmV2ZXJzZWQ7XG59XG5cbnZhciBfY3JlYXRlUGF0aCA9IGZ1bmN0aW9uIF9jcmVhdGVQYXRoKGUsIGlnbm9yZSkge1xuICB2YXIgcGF0aCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIsIFwicGF0aFwiKSxcbiAgICAgIGF0dHIgPSBbXS5zbGljZS5jYWxsKGUuYXR0cmlidXRlcyksXG4gICAgICBpID0gYXR0ci5sZW5ndGgsXG4gICAgICBuYW1lO1xuICBpZ25vcmUgPSBcIixcIiArIGlnbm9yZSArIFwiLFwiO1xuXG4gIHdoaWxlICgtLWkgPiAtMSkge1xuICAgIG5hbWUgPSBhdHRyW2ldLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7IC8vaW4gTWljcm9zb2Z0IEVkZ2UsIGlmIHlvdSBkb24ndCBzZXQgdGhlIGF0dHJpYnV0ZSB3aXRoIGEgbG93ZXJjYXNlIG5hbWUsIGl0IGRvZXNuJ3QgcmVuZGVyIGNvcnJlY3RseSEgU3VwZXIgd2VpcmQuXG5cbiAgICBpZiAoaWdub3JlLmluZGV4T2YoXCIsXCIgKyBuYW1lICsgXCIsXCIpIDwgMCkge1xuICAgICAgcGF0aC5zZXRBdHRyaWJ1dGVOUyhudWxsLCBuYW1lLCBhdHRyW2ldLm5vZGVWYWx1ZSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHBhdGg7XG59LFxuICAgIF90eXBlQXR0cnMgPSB7XG4gIHJlY3Q6IFwicngscnkseCx5LHdpZHRoLGhlaWdodFwiLFxuICBjaXJjbGU6IFwicixjeCxjeVwiLFxuICBlbGxpcHNlOiBcInJ4LHJ5LGN4LGN5XCIsXG4gIGxpbmU6IFwieDEseDIseTEseTJcIlxufSxcbiAgICBfYXR0clRvT2JqID0gZnVuY3Rpb24gX2F0dHJUb09iaihlLCBhdHRycykge1xuICB2YXIgcHJvcHMgPSBhdHRycyA/IGF0dHJzLnNwbGl0KFwiLFwiKSA6IFtdLFxuICAgICAgb2JqID0ge30sXG4gICAgICBpID0gcHJvcHMubGVuZ3RoO1xuXG4gIHdoaWxlICgtLWkgPiAtMSkge1xuICAgIG9ialtwcm9wc1tpXV0gPSArZS5nZXRBdHRyaWJ1dGUocHJvcHNbaV0pIHx8IDA7XG4gIH1cblxuICByZXR1cm4gb2JqO1xufTsgLy9jb252ZXJ0cyBhbiBTVkcgc2hhcGUgbGlrZSA8Y2lyY2xlPiwgPHJlY3Q+LCA8cG9seWdvbj4sIDxwb2x5bGluZT4sIDxlbGxpcHNlPiwgZXRjLiB0byBhIDxwYXRoPiwgc3dhcHBpbmcgaXQgaW4gYW5kIGNvcHlpbmcgdGhlIGF0dHJpYnV0ZXMgdG8gbWF0Y2guXG5cblxuZXhwb3J0IGZ1bmN0aW9uIGNvbnZlcnRUb1BhdGgoZWxlbWVudCwgc3dhcCkge1xuICB2YXIgdHlwZSA9IGVsZW1lbnQudGFnTmFtZS50b0xvd2VyQ2FzZSgpLFxuICAgICAgY2lyYyA9IDAuNTUyMjg0NzQ5ODMxLFxuICAgICAgZGF0YSxcbiAgICAgIHgsXG4gICAgICB5LFxuICAgICAgcixcbiAgICAgIHJ5LFxuICAgICAgcGF0aCxcbiAgICAgIHJjaXJjLFxuICAgICAgcnljaXJjLFxuICAgICAgcG9pbnRzLFxuICAgICAgdyxcbiAgICAgIGgsXG4gICAgICB4MixcbiAgICAgIHgzLFxuICAgICAgeDQsXG4gICAgICB4NSxcbiAgICAgIHg2LFxuICAgICAgeTIsXG4gICAgICB5MyxcbiAgICAgIHk0LFxuICAgICAgeTUsXG4gICAgICB5NixcbiAgICAgIGF0dHI7XG5cbiAgaWYgKHR5cGUgPT09IFwicGF0aFwiIHx8ICFlbGVtZW50LmdldEJCb3gpIHtcbiAgICByZXR1cm4gZWxlbWVudDtcbiAgfVxuXG4gIHBhdGggPSBfY3JlYXRlUGF0aChlbGVtZW50LCBcIngseSx3aWR0aCxoZWlnaHQsY3gsY3kscngscnkscix4MSx4Mix5MSx5Mixwb2ludHNcIik7XG4gIGF0dHIgPSBfYXR0clRvT2JqKGVsZW1lbnQsIF90eXBlQXR0cnNbdHlwZV0pO1xuXG4gIGlmICh0eXBlID09PSBcInJlY3RcIikge1xuICAgIHIgPSBhdHRyLnJ4O1xuICAgIHJ5ID0gYXR0ci5yeSB8fCByO1xuICAgIHggPSBhdHRyLng7XG4gICAgeSA9IGF0dHIueTtcbiAgICB3ID0gYXR0ci53aWR0aCAtIHIgKiAyO1xuICAgIGggPSBhdHRyLmhlaWdodCAtIHJ5ICogMjtcblxuICAgIGlmIChyIHx8IHJ5KSB7XG4gICAgICAvL2lmIHRoZXJlIGFyZSByb3VuZGVkIGNvcm5lcnMsIHJlbmRlciBjdWJpYyBiZXppZXJzXG4gICAgICB4MiA9IHggKyByICogKDEgLSBjaXJjKTtcbiAgICAgIHgzID0geCArIHI7XG4gICAgICB4NCA9IHgzICsgdztcbiAgICAgIHg1ID0geDQgKyByICogY2lyYztcbiAgICAgIHg2ID0geDQgKyByO1xuICAgICAgeTIgPSB5ICsgcnkgKiAoMSAtIGNpcmMpO1xuICAgICAgeTMgPSB5ICsgcnk7XG4gICAgICB5NCA9IHkzICsgaDtcbiAgICAgIHk1ID0geTQgKyByeSAqIGNpcmM7XG4gICAgICB5NiA9IHk0ICsgcnk7XG4gICAgICBkYXRhID0gXCJNXCIgKyB4NiArIFwiLFwiICsgeTMgKyBcIiBWXCIgKyB5NCArIFwiIENcIiArIFt4NiwgeTUsIHg1LCB5NiwgeDQsIHk2LCB4NCAtICh4NCAtIHgzKSAvIDMsIHk2LCB4MyArICh4NCAtIHgzKSAvIDMsIHk2LCB4MywgeTYsIHgyLCB5NiwgeCwgeTUsIHgsIHk0LCB4LCB5NCAtICh5NCAtIHkzKSAvIDMsIHgsIHkzICsgKHk0IC0geTMpIC8gMywgeCwgeTMsIHgsIHkyLCB4MiwgeSwgeDMsIHksIHgzICsgKHg0IC0geDMpIC8gMywgeSwgeDQgLSAoeDQgLSB4MykgLyAzLCB5LCB4NCwgeSwgeDUsIHksIHg2LCB5MiwgeDYsIHkzXS5qb2luKFwiLFwiKSArIFwielwiO1xuICAgIH0gZWxzZSB7XG4gICAgICBkYXRhID0gXCJNXCIgKyAoeCArIHcpICsgXCIsXCIgKyB5ICsgXCIgdlwiICsgaCArIFwiIGhcIiArIC13ICsgXCIgdlwiICsgLWggKyBcIiBoXCIgKyB3ICsgXCJ6XCI7XG4gICAgfVxuICB9IGVsc2UgaWYgKHR5cGUgPT09IFwiY2lyY2xlXCIgfHwgdHlwZSA9PT0gXCJlbGxpcHNlXCIpIHtcbiAgICBpZiAodHlwZSA9PT0gXCJjaXJjbGVcIikge1xuICAgICAgciA9IHJ5ID0gYXR0ci5yO1xuICAgICAgcnljaXJjID0gciAqIGNpcmM7XG4gICAgfSBlbHNlIHtcbiAgICAgIHIgPSBhdHRyLnJ4O1xuICAgICAgcnkgPSBhdHRyLnJ5O1xuICAgICAgcnljaXJjID0gcnkgKiBjaXJjO1xuICAgIH1cblxuICAgIHggPSBhdHRyLmN4O1xuICAgIHkgPSBhdHRyLmN5O1xuICAgIHJjaXJjID0gciAqIGNpcmM7XG4gICAgZGF0YSA9IFwiTVwiICsgKHggKyByKSArIFwiLFwiICsgeSArIFwiIENcIiArIFt4ICsgciwgeSArIHJ5Y2lyYywgeCArIHJjaXJjLCB5ICsgcnksIHgsIHkgKyByeSwgeCAtIHJjaXJjLCB5ICsgcnksIHggLSByLCB5ICsgcnljaXJjLCB4IC0gciwgeSwgeCAtIHIsIHkgLSByeWNpcmMsIHggLSByY2lyYywgeSAtIHJ5LCB4LCB5IC0gcnksIHggKyByY2lyYywgeSAtIHJ5LCB4ICsgciwgeSAtIHJ5Y2lyYywgeCArIHIsIHldLmpvaW4oXCIsXCIpICsgXCJ6XCI7XG4gIH0gZWxzZSBpZiAodHlwZSA9PT0gXCJsaW5lXCIpIHtcbiAgICBkYXRhID0gXCJNXCIgKyBhdHRyLngxICsgXCIsXCIgKyBhdHRyLnkxICsgXCIgTFwiICsgYXR0ci54MiArIFwiLFwiICsgYXR0ci55MjsgLy9wcmV2aW91c2x5LCB3ZSBqdXN0IGNvbnZlcnRlZCB0byBcIk14LHkgTHgseVwiIGJ1dCBTYWZhcmkgaGFzIGJ1Z3MgdGhhdCBjYXVzZSB0aGF0IG5vdCB0byByZW5kZXIgcHJvcGVybHkgd2hlbiB1c2luZyBhIHN0cm9rZS1kYXNoYXJyYXkgdGhhdCdzIG5vdCBmdWxseSB2aXNpYmxlISBVc2luZyBhIGN1YmljIGJlemllciBmaXhlcyB0aGF0IGlzc3VlLlxuICB9IGVsc2UgaWYgKHR5cGUgPT09IFwicG9seWxpbmVcIiB8fCB0eXBlID09PSBcInBvbHlnb25cIikge1xuICAgIHBvaW50cyA9IChlbGVtZW50LmdldEF0dHJpYnV0ZShcInBvaW50c1wiKSArIFwiXCIpLm1hdGNoKF9udW1iZXJzRXhwKSB8fCBbXTtcbiAgICB4ID0gcG9pbnRzLnNoaWZ0KCk7XG4gICAgeSA9IHBvaW50cy5zaGlmdCgpO1xuICAgIGRhdGEgPSBcIk1cIiArIHggKyBcIixcIiArIHkgKyBcIiBMXCIgKyBwb2ludHMuam9pbihcIixcIik7XG5cbiAgICBpZiAodHlwZSA9PT0gXCJwb2x5Z29uXCIpIHtcbiAgICAgIGRhdGEgKz0gXCIsXCIgKyB4ICsgXCIsXCIgKyB5ICsgXCJ6XCI7XG4gICAgfVxuICB9XG5cbiAgcGF0aC5zZXRBdHRyaWJ1dGUoXCJkXCIsIHJhd1BhdGhUb1N0cmluZyhwYXRoLl9nc1Jhd1BhdGggPSBzdHJpbmdUb1Jhd1BhdGgoZGF0YSkpKTtcblxuICBpZiAoc3dhcCAmJiBlbGVtZW50LnBhcmVudE5vZGUpIHtcbiAgICBlbGVtZW50LnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKHBhdGgsIGVsZW1lbnQpO1xuICAgIGVsZW1lbnQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChlbGVtZW50KTtcbiAgfVxuXG4gIHJldHVybiBwYXRoO1xufSAvL3JldHVybnMgdGhlIHJvdGF0aW9uIChpbiBkZWdyZWVzKSBhdCBhIHBhcnRpY3VsYXIgcHJvZ3Jlc3Mgb24gYSByYXdQYXRoICh0aGUgc2xvcGUgb2YgdGhlIHRhbmdlbnQpXG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRSb3RhdGlvbkF0UHJvZ3Jlc3MocmF3UGF0aCwgcHJvZ3Jlc3MpIHtcbiAgdmFyIGQgPSBnZXRQcm9ncmVzc0RhdGEocmF3UGF0aCwgcHJvZ3Jlc3MgPj0gMSA/IDEgLSAxZS05IDogcHJvZ3Jlc3MgPyBwcm9ncmVzcyA6IDFlLTkpO1xuICByZXR1cm4gZ2V0Um90YXRpb25BdEJlemllclQoZC5zZWdtZW50LCBkLmksIGQudCk7XG59XG5cbmZ1bmN0aW9uIGdldFJvdGF0aW9uQXRCZXppZXJUKHNlZ21lbnQsIGksIHQpIHtcbiAgdmFyIGEgPSBzZWdtZW50W2ldLFxuICAgICAgYiA9IHNlZ21lbnRbaSArIDJdLFxuICAgICAgYyA9IHNlZ21lbnRbaSArIDRdLFxuICAgICAgeDtcbiAgYSArPSAoYiAtIGEpICogdDtcbiAgYiArPSAoYyAtIGIpICogdDtcbiAgYSArPSAoYiAtIGEpICogdDtcbiAgeCA9IGIgKyAoYyArIChzZWdtZW50W2kgKyA2XSAtIGMpICogdCAtIGIpICogdCAtIGE7XG4gIGEgPSBzZWdtZW50W2kgKyAxXTtcbiAgYiA9IHNlZ21lbnRbaSArIDNdO1xuICBjID0gc2VnbWVudFtpICsgNV07XG4gIGEgKz0gKGIgLSBhKSAqIHQ7XG4gIGIgKz0gKGMgLSBiKSAqIHQ7XG4gIGEgKz0gKGIgLSBhKSAqIHQ7XG4gIHJldHVybiBfcm91bmQoX2F0YW4yKGIgKyAoYyArIChzZWdtZW50W2kgKyA3XSAtIGMpICogdCAtIGIpICogdCAtIGEsIHgpICogX1JBRDJERUcpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc2xpY2VSYXdQYXRoKHJhd1BhdGgsIHN0YXJ0LCBlbmQpIHtcbiAgZW5kID0gX2lzVW5kZWZpbmVkKGVuZCkgPyAxIDogX3JvdW5kUHJlY2lzZShlbmQpIHx8IDA7IC8vIHdlIG11c3Qgcm91bmQgdG8gYXZvaWQgaXNzdWVzIGxpa2UgNC4xNSAvIDggPSAwLjgzMDAwMDAwMDAwMDAwMDEgaW5zdGVhZCBvZiAwLjgzIG9yIDIuOCAvIDUgPSAwLjU1OTk5OTk5OTk5OTk5OTkgaW5zdGVhZCBvZiAwLjU2IGFuZCBpZiBzb21lb25lIGlzIGRvaW5nIGEgbG9vcCBsaWtlIHN0YXJ0OiAyLjggLyAwLjUsIGVuZDogMi44IC8gMC41ICsgMS5cblxuICBzdGFydCA9IF9yb3VuZFByZWNpc2Uoc3RhcnQpIHx8IDA7XG4gIHZhciBsb29wcyA9IE1hdGgubWF4KDAsIH5+KF9hYnMoZW5kIC0gc3RhcnQpIC0gMWUtOCkpLFxuICAgICAgcGF0aCA9IGNvcHlSYXdQYXRoKHJhd1BhdGgpO1xuXG4gIGlmIChzdGFydCA+IGVuZCkge1xuICAgIHN0YXJ0ID0gMSAtIHN0YXJ0O1xuICAgIGVuZCA9IDEgLSBlbmQ7XG5cbiAgICBfcmV2ZXJzZVJhd1BhdGgocGF0aCk7XG5cbiAgICBwYXRoLnRvdGFsTGVuZ3RoID0gMDtcbiAgfVxuXG4gIGlmIChzdGFydCA8IDAgfHwgZW5kIDwgMCkge1xuICAgIHZhciBvZmZzZXQgPSBNYXRoLmFicyh+fk1hdGgubWluKHN0YXJ0LCBlbmQpKSArIDE7XG4gICAgc3RhcnQgKz0gb2Zmc2V0O1xuICAgIGVuZCArPSBvZmZzZXQ7XG4gIH1cblxuICBwYXRoLnRvdGFsTGVuZ3RoIHx8IGNhY2hlUmF3UGF0aE1lYXN1cmVtZW50cyhwYXRoKTtcbiAgdmFyIHdyYXAgPSBlbmQgPiAxLFxuICAgICAgcyA9IGdldFByb2dyZXNzRGF0YShwYXRoLCBzdGFydCwgX3RlbXAsIHRydWUpLFxuICAgICAgZSA9IGdldFByb2dyZXNzRGF0YShwYXRoLCBlbmQsIF90ZW1wMiksXG4gICAgICBlU2VnID0gZS5zZWdtZW50LFxuICAgICAgc1NlZyA9IHMuc2VnbWVudCxcbiAgICAgIGVTZWdJbmRleCA9IGUuc2VnSW5kZXgsXG4gICAgICBzU2VnSW5kZXggPSBzLnNlZ0luZGV4LFxuICAgICAgZWkgPSBlLmksXG4gICAgICBzaSA9IHMuaSxcbiAgICAgIHNhbWVTZWdtZW50ID0gc1NlZ0luZGV4ID09PSBlU2VnSW5kZXgsXG4gICAgICBzYW1lQmV6aWVyID0gZWkgPT09IHNpICYmIHNhbWVTZWdtZW50LFxuICAgICAgd3JhcHNCZWhpbmQsXG4gICAgICBzU2hpZnQsXG4gICAgICBlU2hpZnQsXG4gICAgICBpLFxuICAgICAgY29weSxcbiAgICAgIHRvdGFsU2VnbWVudHMsXG4gICAgICBsLFxuICAgICAgajtcblxuICBpZiAod3JhcCB8fCBsb29wcykge1xuICAgIHdyYXBzQmVoaW5kID0gZVNlZ0luZGV4IDwgc1NlZ0luZGV4IHx8IHNhbWVTZWdtZW50ICYmIGVpIDwgc2kgfHwgc2FtZUJlemllciAmJiBlLnQgPCBzLnQ7XG5cbiAgICBpZiAoX3NwbGl0U2VnbWVudChwYXRoLCBzU2VnSW5kZXgsIHNpLCBzLnQpKSB7XG4gICAgICBzU2VnSW5kZXgrKztcblxuICAgICAgaWYgKCF3cmFwc0JlaGluZCkge1xuICAgICAgICBlU2VnSW5kZXgrKztcblxuICAgICAgICBpZiAoc2FtZUJlemllcikge1xuICAgICAgICAgIGUudCA9IChlLnQgLSBzLnQpIC8gKDEgLSBzLnQpO1xuICAgICAgICAgIGVpID0gMDtcbiAgICAgICAgfSBlbHNlIGlmIChzYW1lU2VnbWVudCkge1xuICAgICAgICAgIGVpIC09IHNpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKE1hdGguYWJzKDEgLSAoZW5kIC0gc3RhcnQpKSA8IDFlLTUpIHtcbiAgICAgIGVTZWdJbmRleCA9IHNTZWdJbmRleCAtIDE7XG4gICAgfSBlbHNlIGlmICghZS50ICYmIGVTZWdJbmRleCkge1xuICAgICAgZVNlZ0luZGV4LS07XG4gICAgfSBlbHNlIGlmIChfc3BsaXRTZWdtZW50KHBhdGgsIGVTZWdJbmRleCwgZWksIGUudCkgJiYgd3JhcHNCZWhpbmQpIHtcbiAgICAgIHNTZWdJbmRleCsrO1xuICAgIH1cblxuICAgIGlmIChzLnQgPT09IDEpIHtcbiAgICAgIHNTZWdJbmRleCA9IChzU2VnSW5kZXggKyAxKSAlIHBhdGgubGVuZ3RoO1xuICAgIH1cblxuICAgIGNvcHkgPSBbXTtcbiAgICB0b3RhbFNlZ21lbnRzID0gcGF0aC5sZW5ndGg7XG4gICAgbCA9IDEgKyB0b3RhbFNlZ21lbnRzICogbG9vcHM7XG4gICAgaiA9IHNTZWdJbmRleDtcbiAgICBsICs9ICh0b3RhbFNlZ21lbnRzIC0gc1NlZ0luZGV4ICsgZVNlZ0luZGV4KSAlIHRvdGFsU2VnbWVudHM7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgbDsgaSsrKSB7XG4gICAgICBfYXBwZW5kT3JNZXJnZShjb3B5LCBwYXRoW2orKyAlIHRvdGFsU2VnbWVudHNdKTtcbiAgICB9XG5cbiAgICBwYXRoID0gY29weTtcbiAgfSBlbHNlIHtcbiAgICBlU2hpZnQgPSBlLnQgPT09IDEgPyA2IDogc3ViZGl2aWRlU2VnbWVudChlU2VnLCBlaSwgZS50KTtcblxuICAgIGlmIChzdGFydCAhPT0gZW5kKSB7XG4gICAgICBzU2hpZnQgPSBzdWJkaXZpZGVTZWdtZW50KHNTZWcsIHNpLCBzYW1lQmV6aWVyID8gcy50IC8gZS50IDogcy50KTtcbiAgICAgIHNhbWVTZWdtZW50ICYmIChlU2hpZnQgKz0gc1NoaWZ0KTtcbiAgICAgIGVTZWcuc3BsaWNlKGVpICsgZVNoaWZ0ICsgMik7XG4gICAgICAoc1NoaWZ0IHx8IHNpKSAmJiBzU2VnLnNwbGljZSgwLCBzaSArIHNTaGlmdCk7XG4gICAgICBpID0gcGF0aC5sZW5ndGg7XG5cbiAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgLy9jaG9wIG9mZiBhbnkgZXh0cmEgc2VnbWVudHNcbiAgICAgICAgKGkgPCBzU2VnSW5kZXggfHwgaSA+IGVTZWdJbmRleCkgJiYgcGF0aC5zcGxpY2UoaSwgMSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGVTZWcuYW5nbGUgPSBnZXRSb3RhdGlvbkF0QmV6aWVyVChlU2VnLCBlaSArIGVTaGlmdCwgMCk7IC8vcmVjb3JkIHRoZSB2YWx1ZSBiZWZvcmUgd2UgY2hvcCBiZWNhdXNlIGl0J2xsIGJlIGltcG9zc2libGUgdG8gZGV0ZXJtaW5lIHRoZSBhbmdsZSBhZnRlciBpdHMgbGVuZ3RoIGlzIDAhXG5cbiAgICAgIGVpICs9IGVTaGlmdDtcbiAgICAgIHMgPSBlU2VnW2VpXTtcbiAgICAgIGUgPSBlU2VnW2VpICsgMV07XG4gICAgICBlU2VnLmxlbmd0aCA9IGVTZWcudG90YWxMZW5ndGggPSAwO1xuICAgICAgZVNlZy50b3RhbFBvaW50cyA9IHBhdGgudG90YWxQb2ludHMgPSA4O1xuICAgICAgZVNlZy5wdXNoKHMsIGUsIHMsIGUsIHMsIGUsIHMsIGUpO1xuICAgIH1cbiAgfVxuXG4gIHBhdGgudG90YWxMZW5ndGggPSAwO1xuICByZXR1cm4gcGF0aDtcbn0gLy9tZWFzdXJlcyBhIFNlZ21lbnQgYWNjb3JkaW5nIHRvIGl0cyByZXNvbHV0aW9uIChzbyBpZiBzZWdtZW50LnJlc29sdXRpb24gaXMgNiwgZm9yIGV4YW1wbGUsIGl0J2xsIHRha2UgNiBzYW1wbGVzIGVxdWFsbHkgYWNyb3NzIGVhY2ggQmV6aWVyKSBhbmQgY3JlYXRlL3BvcHVsYXRlIGEgXCJzYW1wbGVzXCIgQXJyYXkgdGhhdCBoYXMgdGhlIGxlbmd0aCB1cCB0byBlYWNoIG9mIHRob3NlIHNhbXBsZSBwb2ludHMgKGFsd2F5cyBpbmNyZWFzaW5nIGZyb20gdGhlIHN0YXJ0KSBhcyB3ZWxsIGFzIGEgXCJsb29rdXBcIiBhcnJheSB0aGF0J3MgYnJva2VuIHVwIGFjY29yZGluZyB0byB0aGUgc21hbGxlc3QgZGlzdGFuY2UgYmV0d2VlbiAyIHNhbXBsZXMuIFRoaXMgZ2l2ZXMgdXMgYSB2ZXJ5IGZhc3Qgd2F5IG9mIGxvb2tpbmcgdXAgYSBwcm9ncmVzcyBwb3NpdGlvbiByYXRoZXIgdGhhbiBsb29waW5nIHRocm91Z2ggYWxsIHRoZSBwb2ludHMvQmV6aWVycy4gWW91IGNhbiBvcHRpb25hbGx5IGhhdmUgaXQgb25seSBtZWFzdXJlIGEgc3Vic2V0LCBzdGFydGluZyBhdCBzdGFydEluZGV4IGFuZCBnb2luZyBmb3IgYSBzcGVjaWZpYyBudW1iZXIgb2YgYmV6aWVycyAocmVtZW1iZXIsIHRoZXJlIGFyZSAzIHgveSBwYWlycyBlYWNoLCBmb3IgYSB0b3RhbCBvZiA2IGVsZW1lbnRzIGZvciBlYWNoIEJlemllcikuIEl0IHdpbGwgYWxzbyBwb3B1bGF0ZSBhIFwidG90YWxMZW5ndGhcIiBwcm9wZXJ0eSwgYnV0IHRoYXQncyBub3QgZ2VuZXJhbGx5IHN1cGVyIGFjY3VyYXRlIGJlY2F1c2UgYnkgZGVmYXVsdCBpdCdsbCBvbmx5IHRha2UgNiBzYW1wbGVzIHBlciBCZXppZXIuIEJ1dCBmb3IgcGVyZm9ybWFuY2UgcmVhc29ucywgaXQncyBwZXJmZWN0bHkgYWRlcXVhdGUgZm9yIG1lYXN1cmluZyBwcm9ncmVzcyB2YWx1ZXMgYWxvbmcgdGhlIHBhdGguIElmIHlvdSBuZWVkIGEgbW9yZSBhY2N1cmF0ZSB0b3RhbExlbmd0aCwgZWl0aGVyIGluY3JlYXNlIHRoZSByZXNvbHV0aW9uIG9yIHVzZSB0aGUgbW9yZSBhZHZhbmNlZCBiZXppZXJUb1BvaW50cygpIG1ldGhvZCB3aGljaCBrZWVwcyBhZGRpbmcgcG9pbnRzIHVudGlsIHRoZXkgZG9uJ3QgZGV2aWF0ZSBieSBtb3JlIHRoYW4gYSBjZXJ0YWluIHByZWNpc2lvbiB2YWx1ZS5cblxuZnVuY3Rpb24gbWVhc3VyZVNlZ21lbnQoc2VnbWVudCwgc3RhcnRJbmRleCwgYmV6aWVyUXR5KSB7XG4gIHN0YXJ0SW5kZXggPSBzdGFydEluZGV4IHx8IDA7XG5cbiAgaWYgKCFzZWdtZW50LnNhbXBsZXMpIHtcbiAgICBzZWdtZW50LnNhbXBsZXMgPSBbXTtcbiAgICBzZWdtZW50Lmxvb2t1cCA9IFtdO1xuICB9XG5cbiAgdmFyIHJlc29sdXRpb24gPSB+fnNlZ21lbnQucmVzb2x1dGlvbiB8fCAxMixcbiAgICAgIGluYyA9IDEgLyByZXNvbHV0aW9uLFxuICAgICAgZW5kSW5kZXggPSBiZXppZXJRdHkgPyBzdGFydEluZGV4ICsgYmV6aWVyUXR5ICogNiArIDEgOiBzZWdtZW50Lmxlbmd0aCxcbiAgICAgIHgxID0gc2VnbWVudFtzdGFydEluZGV4XSxcbiAgICAgIHkxID0gc2VnbWVudFtzdGFydEluZGV4ICsgMV0sXG4gICAgICBzYW1wbGVzSW5kZXggPSBzdGFydEluZGV4ID8gc3RhcnRJbmRleCAvIDYgKiByZXNvbHV0aW9uIDogMCxcbiAgICAgIHNhbXBsZXMgPSBzZWdtZW50LnNhbXBsZXMsXG4gICAgICBsb29rdXAgPSBzZWdtZW50Lmxvb2t1cCxcbiAgICAgIG1pbiA9IChzdGFydEluZGV4ID8gc2VnbWVudC5taW5MZW5ndGggOiBfbGFyZ2VOdW0pIHx8IF9sYXJnZU51bSxcbiAgICAgIHByZXZMZW5ndGggPSBzYW1wbGVzW3NhbXBsZXNJbmRleCArIGJlemllclF0eSAqIHJlc29sdXRpb24gLSAxXSxcbiAgICAgIGxlbmd0aCA9IHN0YXJ0SW5kZXggPyBzYW1wbGVzW3NhbXBsZXNJbmRleCAtIDFdIDogMCxcbiAgICAgIGksXG4gICAgICBqLFxuICAgICAgeDQsXG4gICAgICB4MyxcbiAgICAgIHgyLFxuICAgICAgeGQsXG4gICAgICB4ZDEsXG4gICAgICB5NCxcbiAgICAgIHkzLFxuICAgICAgeTIsXG4gICAgICB5ZCxcbiAgICAgIHlkMSxcbiAgICAgIGludixcbiAgICAgIHQsXG4gICAgICBsZW5ndGhJbmRleCxcbiAgICAgIGwsXG4gICAgICBzZWdMZW5ndGg7XG4gIHNhbXBsZXMubGVuZ3RoID0gbG9va3VwLmxlbmd0aCA9IDA7XG5cbiAgZm9yIChqID0gc3RhcnRJbmRleCArIDI7IGogPCBlbmRJbmRleDsgaiArPSA2KSB7XG4gICAgeDQgPSBzZWdtZW50W2ogKyA0XSAtIHgxO1xuICAgIHgzID0gc2VnbWVudFtqICsgMl0gLSB4MTtcbiAgICB4MiA9IHNlZ21lbnRbal0gLSB4MTtcbiAgICB5NCA9IHNlZ21lbnRbaiArIDVdIC0geTE7XG4gICAgeTMgPSBzZWdtZW50W2ogKyAzXSAtIHkxO1xuICAgIHkyID0gc2VnbWVudFtqICsgMV0gLSB5MTtcbiAgICB4ZCA9IHhkMSA9IHlkID0geWQxID0gMDtcblxuICAgIGlmIChfYWJzKHg0KSA8IC4wMSAmJiBfYWJzKHk0KSA8IC4wMSAmJiBfYWJzKHgyKSArIF9hYnMoeTIpIDwgLjAxKSB7XG4gICAgICAvL2R1bXAgcG9pbnRzIHRoYXQgYXJlIHN1ZmZpY2llbnRseSBjbG9zZSAoYmFzaWNhbGx5IHJpZ2h0IG9uIHRvcCBvZiBlYWNoIG90aGVyLCBtYWtpbmcgYSBiZXppZXIgc3VwZXIgdGlueSBvciAwIGxlbmd0aClcbiAgICAgIGlmIChzZWdtZW50Lmxlbmd0aCA+IDgpIHtcbiAgICAgICAgc2VnbWVudC5zcGxpY2UoaiwgNik7XG4gICAgICAgIGogLT0gNjtcbiAgICAgICAgZW5kSW5kZXggLT0gNjtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZm9yIChpID0gMTsgaSA8PSByZXNvbHV0aW9uOyBpKyspIHtcbiAgICAgICAgdCA9IGluYyAqIGk7XG4gICAgICAgIGludiA9IDEgLSB0O1xuICAgICAgICB4ZCA9IHhkMSAtICh4ZDEgPSAodCAqIHQgKiB4NCArIDMgKiBpbnYgKiAodCAqIHgzICsgaW52ICogeDIpKSAqIHQpO1xuICAgICAgICB5ZCA9IHlkMSAtICh5ZDEgPSAodCAqIHQgKiB5NCArIDMgKiBpbnYgKiAodCAqIHkzICsgaW52ICogeTIpKSAqIHQpO1xuICAgICAgICBsID0gX3NxcnQoeWQgKiB5ZCArIHhkICogeGQpO1xuXG4gICAgICAgIGlmIChsIDwgbWluKSB7XG4gICAgICAgICAgbWluID0gbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGxlbmd0aCArPSBsO1xuICAgICAgICBzYW1wbGVzW3NhbXBsZXNJbmRleCsrXSA9IGxlbmd0aDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB4MSArPSB4NDtcbiAgICB5MSArPSB5NDtcbiAgfVxuXG4gIGlmIChwcmV2TGVuZ3RoKSB7XG4gICAgcHJldkxlbmd0aCAtPSBsZW5ndGg7XG5cbiAgICBmb3IgKDsgc2FtcGxlc0luZGV4IDwgc2FtcGxlcy5sZW5ndGg7IHNhbXBsZXNJbmRleCsrKSB7XG4gICAgICBzYW1wbGVzW3NhbXBsZXNJbmRleF0gKz0gcHJldkxlbmd0aDtcbiAgICB9XG4gIH1cblxuICBpZiAoc2FtcGxlcy5sZW5ndGggJiYgbWluKSB7XG4gICAgc2VnbWVudC50b3RhbExlbmd0aCA9IHNlZ0xlbmd0aCA9IHNhbXBsZXNbc2FtcGxlcy5sZW5ndGggLSAxXSB8fCAwO1xuICAgIHNlZ21lbnQubWluTGVuZ3RoID0gbWluO1xuXG4gICAgaWYgKHNlZ0xlbmd0aCAvIG1pbiA8IDk5OTkpIHtcbiAgICAgIC8vIGlmIHRoZSBsb29rdXAgd291bGQgcmVxdWlyZSB0b28gbWFueSB2YWx1ZXMgKG1lbW9yeSBwcm9ibGVtKSwgd2Ugc2tpcCB0aGlzIGFuZCBpbnN0ZWFkIHdlIHVzZSBhIGxvb3AgdG8gbG9va3VwIHZhbHVlcyBkaXJlY3RseSBpbiB0aGUgc2FtcGxlcyBBcnJheVxuICAgICAgbCA9IGxlbmd0aEluZGV4ID0gMDtcblxuICAgICAgZm9yIChpID0gMDsgaSA8IHNlZ0xlbmd0aDsgaSArPSBtaW4pIHtcbiAgICAgICAgbG9va3VwW2wrK10gPSBzYW1wbGVzW2xlbmd0aEluZGV4XSA8IGkgPyArK2xlbmd0aEluZGV4IDogbGVuZ3RoSW5kZXg7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHNlZ21lbnQudG90YWxMZW5ndGggPSBzYW1wbGVzWzBdID0gMDtcbiAgfVxuXG4gIHJldHVybiBzdGFydEluZGV4ID8gbGVuZ3RoIC0gc2FtcGxlc1tzdGFydEluZGV4IC8gMiAtIDFdIDogbGVuZ3RoO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY2FjaGVSYXdQYXRoTWVhc3VyZW1lbnRzKHJhd1BhdGgsIHJlc29sdXRpb24pIHtcbiAgdmFyIHBhdGhMZW5ndGgsIHBvaW50cywgaTtcblxuICBmb3IgKGkgPSBwYXRoTGVuZ3RoID0gcG9pbnRzID0gMDsgaSA8IHJhd1BhdGgubGVuZ3RoOyBpKyspIHtcbiAgICByYXdQYXRoW2ldLnJlc29sdXRpb24gPSB+fnJlc29sdXRpb24gfHwgMTI7IC8vc3RlcHMgcGVyIEJlemllciBjdXJ2ZSAoYW5jaG9yLCAyIGNvbnRyb2wgcG9pbnRzLCB0byBhbmNob3IpXG5cbiAgICBwb2ludHMgKz0gcmF3UGF0aFtpXS5sZW5ndGg7XG4gICAgcGF0aExlbmd0aCArPSBtZWFzdXJlU2VnbWVudChyYXdQYXRoW2ldKTtcbiAgfVxuXG4gIHJhd1BhdGgudG90YWxQb2ludHMgPSBwb2ludHM7XG4gIHJhd1BhdGgudG90YWxMZW5ndGggPSBwYXRoTGVuZ3RoO1xuICByZXR1cm4gcmF3UGF0aDtcbn0gLy9kaXZpZGUgc2VnbWVudFtpXSBhdCBwb3NpdGlvbiB0ICh2YWx1ZSBiZXR3ZWVuIDAgYW5kIDEsIHByb2dyZXNzIGFsb25nIHRoYXQgcGFydGljdWxhciBjdWJpYyBiZXppZXIgc2VnbWVudCB0aGF0IHN0YXJ0cyBhdCBzZWdtZW50W2ldKS4gUmV0dXJucyBob3cgbWFueSBlbGVtZW50cyB3ZXJlIHNwbGljZWQgaW50byB0aGUgc2VnbWVudCBhcnJheSAoZWl0aGVyIDAgb3IgNilcblxuZXhwb3J0IGZ1bmN0aW9uIHN1YmRpdmlkZVNlZ21lbnQoc2VnbWVudCwgaSwgdCkge1xuICBpZiAodCA8PSAwIHx8IHQgPj0gMSkge1xuICAgIHJldHVybiAwO1xuICB9XG5cbiAgdmFyIGF4ID0gc2VnbWVudFtpXSxcbiAgICAgIGF5ID0gc2VnbWVudFtpICsgMV0sXG4gICAgICBjcDF4ID0gc2VnbWVudFtpICsgMl0sXG4gICAgICBjcDF5ID0gc2VnbWVudFtpICsgM10sXG4gICAgICBjcDJ4ID0gc2VnbWVudFtpICsgNF0sXG4gICAgICBjcDJ5ID0gc2VnbWVudFtpICsgNV0sXG4gICAgICBieCA9IHNlZ21lbnRbaSArIDZdLFxuICAgICAgYnkgPSBzZWdtZW50W2kgKyA3XSxcbiAgICAgIHgxYSA9IGF4ICsgKGNwMXggLSBheCkgKiB0LFxuICAgICAgeDIgPSBjcDF4ICsgKGNwMnggLSBjcDF4KSAqIHQsXG4gICAgICB5MWEgPSBheSArIChjcDF5IC0gYXkpICogdCxcbiAgICAgIHkyID0gY3AxeSArIChjcDJ5IC0gY3AxeSkgKiB0LFxuICAgICAgeDEgPSB4MWEgKyAoeDIgLSB4MWEpICogdCxcbiAgICAgIHkxID0geTFhICsgKHkyIC0geTFhKSAqIHQsXG4gICAgICB4MmEgPSBjcDJ4ICsgKGJ4IC0gY3AyeCkgKiB0LFxuICAgICAgeTJhID0gY3AyeSArIChieSAtIGNwMnkpICogdDtcbiAgeDIgKz0gKHgyYSAtIHgyKSAqIHQ7XG4gIHkyICs9ICh5MmEgLSB5MikgKiB0O1xuICBzZWdtZW50LnNwbGljZShpICsgMiwgNCwgX3JvdW5kKHgxYSksIC8vZmlyc3QgY29udHJvbCBwb2ludFxuICBfcm91bmQoeTFhKSwgX3JvdW5kKHgxKSwgLy9zZWNvbmQgY29udHJvbCBwb2ludFxuICBfcm91bmQoeTEpLCBfcm91bmQoeDEgKyAoeDIgLSB4MSkgKiB0KSwgLy9uZXcgZmFicmljYXRlZCBhbmNob3Igb24gbGluZVxuICBfcm91bmQoeTEgKyAoeTIgLSB5MSkgKiB0KSwgX3JvdW5kKHgyKSwgLy90aGlyZCBjb250cm9sIHBvaW50XG4gIF9yb3VuZCh5MiksIF9yb3VuZCh4MmEpLCAvL2ZvdXJ0aCBjb250cm9sIHBvaW50XG4gIF9yb3VuZCh5MmEpKTtcbiAgc2VnbWVudC5zYW1wbGVzICYmIHNlZ21lbnQuc2FtcGxlcy5zcGxpY2UoaSAvIDYgKiBzZWdtZW50LnJlc29sdXRpb24gfCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwKTtcbiAgcmV0dXJuIDY7XG59IC8vIHJldHVybnMgYW4gb2JqZWN0IHtwYXRoLCBzZWdtZW50LCBzZWdJbmRleCwgaSwgdH1cblxuZnVuY3Rpb24gZ2V0UHJvZ3Jlc3NEYXRhKHJhd1BhdGgsIHByb2dyZXNzLCBkZWNvcmF0ZWUsIHB1c2hUb05leHRJZkF0RW5kKSB7XG4gIGRlY29yYXRlZSA9IGRlY29yYXRlZSB8fCB7fTtcbiAgcmF3UGF0aC50b3RhbExlbmd0aCB8fCBjYWNoZVJhd1BhdGhNZWFzdXJlbWVudHMocmF3UGF0aCk7XG5cbiAgaWYgKHByb2dyZXNzIDwgMCB8fCBwcm9ncmVzcyA+IDEpIHtcbiAgICBwcm9ncmVzcyA9IF93cmFwUHJvZ3Jlc3MocHJvZ3Jlc3MpO1xuICB9XG5cbiAgdmFyIHNlZ0luZGV4ID0gMCxcbiAgICAgIHNlZ21lbnQgPSByYXdQYXRoWzBdLFxuICAgICAgc2FtcGxlcyxcbiAgICAgIHJlc29sdXRpb24sXG4gICAgICBsZW5ndGgsXG4gICAgICBtaW4sXG4gICAgICBtYXgsXG4gICAgICBpLFxuICAgICAgdDtcblxuICBpZiAoIXByb2dyZXNzKSB7XG4gICAgdCA9IGkgPSBzZWdJbmRleCA9IDA7XG4gICAgc2VnbWVudCA9IHJhd1BhdGhbMF07XG4gIH0gZWxzZSBpZiAocHJvZ3Jlc3MgPT09IDEpIHtcbiAgICB0ID0gMTtcbiAgICBzZWdJbmRleCA9IHJhd1BhdGgubGVuZ3RoIC0gMTtcbiAgICBzZWdtZW50ID0gcmF3UGF0aFtzZWdJbmRleF07XG4gICAgaSA9IHNlZ21lbnQubGVuZ3RoIC0gODtcbiAgfSBlbHNlIHtcbiAgICBpZiAocmF3UGF0aC5sZW5ndGggPiAxKSB7XG4gICAgICAvL3NwZWVkIG9wdGltaXphdGlvbjogbW9zdCBvZiB0aGUgdGltZSwgdGhlcmUncyBvbmx5IG9uZSBzZWdtZW50IHNvIHNraXAgdGhlIHJlY3Vyc2lvbi5cbiAgICAgIGxlbmd0aCA9IHJhd1BhdGgudG90YWxMZW5ndGggKiBwcm9ncmVzcztcbiAgICAgIG1heCA9IGkgPSAwO1xuXG4gICAgICB3aGlsZSAoKG1heCArPSByYXdQYXRoW2krK10udG90YWxMZW5ndGgpIDwgbGVuZ3RoKSB7XG4gICAgICAgIHNlZ0luZGV4ID0gaTtcbiAgICAgIH1cblxuICAgICAgc2VnbWVudCA9IHJhd1BhdGhbc2VnSW5kZXhdO1xuICAgICAgbWluID0gbWF4IC0gc2VnbWVudC50b3RhbExlbmd0aDtcbiAgICAgIHByb2dyZXNzID0gKGxlbmd0aCAtIG1pbikgLyAobWF4IC0gbWluKSB8fCAwO1xuICAgIH1cblxuICAgIHNhbXBsZXMgPSBzZWdtZW50LnNhbXBsZXM7XG4gICAgcmVzb2x1dGlvbiA9IHNlZ21lbnQucmVzb2x1dGlvbjsgLy9ob3cgbWFueSBzYW1wbGVzIHBlciBjdWJpYyBiZXppZXIgY2h1bmtcblxuICAgIGxlbmd0aCA9IHNlZ21lbnQudG90YWxMZW5ndGggKiBwcm9ncmVzcztcbiAgICBpID0gc2VnbWVudC5sb29rdXAubGVuZ3RoID8gc2VnbWVudC5sb29rdXBbfn4obGVuZ3RoIC8gc2VnbWVudC5taW5MZW5ndGgpXSB8fCAwIDogX2dldFNhbXBsZUluZGV4KHNhbXBsZXMsIGxlbmd0aCwgcHJvZ3Jlc3MpO1xuICAgIG1pbiA9IGkgPyBzYW1wbGVzW2kgLSAxXSA6IDA7XG4gICAgbWF4ID0gc2FtcGxlc1tpXTtcblxuICAgIGlmIChtYXggPCBsZW5ndGgpIHtcbiAgICAgIG1pbiA9IG1heDtcbiAgICAgIG1heCA9IHNhbXBsZXNbKytpXTtcbiAgICB9XG5cbiAgICB0ID0gMSAvIHJlc29sdXRpb24gKiAoKGxlbmd0aCAtIG1pbikgLyAobWF4IC0gbWluKSArIGkgJSByZXNvbHV0aW9uKTtcbiAgICBpID0gfn4oaSAvIHJlc29sdXRpb24pICogNjtcblxuICAgIGlmIChwdXNoVG9OZXh0SWZBdEVuZCAmJiB0ID09PSAxKSB7XG4gICAgICBpZiAoaSArIDYgPCBzZWdtZW50Lmxlbmd0aCkge1xuICAgICAgICBpICs9IDY7XG4gICAgICAgIHQgPSAwO1xuICAgICAgfSBlbHNlIGlmIChzZWdJbmRleCArIDEgPCByYXdQYXRoLmxlbmd0aCkge1xuICAgICAgICBpID0gdCA9IDA7XG4gICAgICAgIHNlZ21lbnQgPSByYXdQYXRoWysrc2VnSW5kZXhdO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGRlY29yYXRlZS50ID0gdDtcbiAgZGVjb3JhdGVlLmkgPSBpO1xuICBkZWNvcmF0ZWUucGF0aCA9IHJhd1BhdGg7XG4gIGRlY29yYXRlZS5zZWdtZW50ID0gc2VnbWVudDtcbiAgZGVjb3JhdGVlLnNlZ0luZGV4ID0gc2VnSW5kZXg7XG4gIHJldHVybiBkZWNvcmF0ZWU7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRQb3NpdGlvbk9uUGF0aChyYXdQYXRoLCBwcm9ncmVzcywgaW5jbHVkZUFuZ2xlLCBwb2ludCkge1xuICB2YXIgc2VnbWVudCA9IHJhd1BhdGhbMF0sXG4gICAgICByZXN1bHQgPSBwb2ludCB8fCB7fSxcbiAgICAgIHNhbXBsZXMsXG4gICAgICByZXNvbHV0aW9uLFxuICAgICAgbGVuZ3RoLFxuICAgICAgbWluLFxuICAgICAgbWF4LFxuICAgICAgaSxcbiAgICAgIHQsXG4gICAgICBhLFxuICAgICAgaW52O1xuXG4gIGlmIChwcm9ncmVzcyA8IDAgfHwgcHJvZ3Jlc3MgPiAxKSB7XG4gICAgcHJvZ3Jlc3MgPSBfd3JhcFByb2dyZXNzKHByb2dyZXNzKTtcbiAgfVxuXG4gIGlmIChyYXdQYXRoLmxlbmd0aCA+IDEpIHtcbiAgICAvL3NwZWVkIG9wdGltaXphdGlvbjogbW9zdCBvZiB0aGUgdGltZSwgdGhlcmUncyBvbmx5IG9uZSBzZWdtZW50IHNvIHNraXAgdGhlIHJlY3Vyc2lvbi5cbiAgICBsZW5ndGggPSByYXdQYXRoLnRvdGFsTGVuZ3RoICogcHJvZ3Jlc3M7XG4gICAgbWF4ID0gaSA9IDA7XG5cbiAgICB3aGlsZSAoKG1heCArPSByYXdQYXRoW2krK10udG90YWxMZW5ndGgpIDwgbGVuZ3RoKSB7XG4gICAgICBzZWdtZW50ID0gcmF3UGF0aFtpXTtcbiAgICB9XG5cbiAgICBtaW4gPSBtYXggLSBzZWdtZW50LnRvdGFsTGVuZ3RoO1xuICAgIHByb2dyZXNzID0gKGxlbmd0aCAtIG1pbikgLyAobWF4IC0gbWluKSB8fCAwO1xuICB9XG5cbiAgc2FtcGxlcyA9IHNlZ21lbnQuc2FtcGxlcztcbiAgcmVzb2x1dGlvbiA9IHNlZ21lbnQucmVzb2x1dGlvbjtcbiAgbGVuZ3RoID0gc2VnbWVudC50b3RhbExlbmd0aCAqIHByb2dyZXNzO1xuICBpID0gc2VnbWVudC5sb29rdXAubGVuZ3RoID8gc2VnbWVudC5sb29rdXBbcHJvZ3Jlc3MgPCAxID8gfn4obGVuZ3RoIC8gc2VnbWVudC5taW5MZW5ndGgpIDogc2VnbWVudC5sb29rdXAubGVuZ3RoIC0gMV0gfHwgMCA6IF9nZXRTYW1wbGVJbmRleChzYW1wbGVzLCBsZW5ndGgsIHByb2dyZXNzKTtcbiAgbWluID0gaSA/IHNhbXBsZXNbaSAtIDFdIDogMDtcbiAgbWF4ID0gc2FtcGxlc1tpXTtcblxuICBpZiAobWF4IDwgbGVuZ3RoKSB7XG4gICAgbWluID0gbWF4O1xuICAgIG1heCA9IHNhbXBsZXNbKytpXTtcbiAgfVxuXG4gIHQgPSAxIC8gcmVzb2x1dGlvbiAqICgobGVuZ3RoIC0gbWluKSAvIChtYXggLSBtaW4pICsgaSAlIHJlc29sdXRpb24pIHx8IDA7XG4gIGludiA9IDEgLSB0O1xuICBpID0gfn4oaSAvIHJlc29sdXRpb24pICogNjtcbiAgYSA9IHNlZ21lbnRbaV07XG4gIHJlc3VsdC54ID0gX3JvdW5kKCh0ICogdCAqIChzZWdtZW50W2kgKyA2XSAtIGEpICsgMyAqIGludiAqICh0ICogKHNlZ21lbnRbaSArIDRdIC0gYSkgKyBpbnYgKiAoc2VnbWVudFtpICsgMl0gLSBhKSkpICogdCArIGEpO1xuICByZXN1bHQueSA9IF9yb3VuZCgodCAqIHQgKiAoc2VnbWVudFtpICsgN10gLSAoYSA9IHNlZ21lbnRbaSArIDFdKSkgKyAzICogaW52ICogKHQgKiAoc2VnbWVudFtpICsgNV0gLSBhKSArIGludiAqIChzZWdtZW50W2kgKyAzXSAtIGEpKSkgKiB0ICsgYSk7XG5cbiAgaWYgKGluY2x1ZGVBbmdsZSkge1xuICAgIHJlc3VsdC5hbmdsZSA9IHNlZ21lbnQudG90YWxMZW5ndGggPyBnZXRSb3RhdGlvbkF0QmV6aWVyVChzZWdtZW50LCBpLCB0ID49IDEgPyAxIC0gMWUtOSA6IHQgPyB0IDogMWUtOSkgOiBzZWdtZW50LmFuZ2xlIHx8IDA7XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufSAvL2FwcGxpZXMgYSBtYXRyaXggdHJhbnNmb3JtIHRvIFJhd1BhdGggKG9yIGEgc2VnbWVudCBpbiBhIFJhd1BhdGgpIGFuZCByZXR1cm5zIHdoYXRldmVyIHdhcyBwYXNzZWQgaW4gKGl0IHRyYW5zZm9ybXMgdGhlIHZhbHVlcyBpbiB0aGUgYXJyYXkocyksIG5vdCBhIGNvcHkpLlxuXG5leHBvcnQgZnVuY3Rpb24gdHJhbnNmb3JtUmF3UGF0aChyYXdQYXRoLCBhLCBiLCBjLCBkLCB0eCwgdHkpIHtcbiAgdmFyIGogPSByYXdQYXRoLmxlbmd0aCxcbiAgICAgIHNlZ21lbnQsXG4gICAgICBsLFxuICAgICAgaSxcbiAgICAgIHgsXG4gICAgICB5O1xuXG4gIHdoaWxlICgtLWogPiAtMSkge1xuICAgIHNlZ21lbnQgPSByYXdQYXRoW2pdO1xuICAgIGwgPSBzZWdtZW50Lmxlbmd0aDtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBsOyBpICs9IDIpIHtcbiAgICAgIHggPSBzZWdtZW50W2ldO1xuICAgICAgeSA9IHNlZ21lbnRbaSArIDFdO1xuICAgICAgc2VnbWVudFtpXSA9IHggKiBhICsgeSAqIGMgKyB0eDtcbiAgICAgIHNlZ21lbnRbaSArIDFdID0geCAqIGIgKyB5ICogZCArIHR5O1xuICAgIH1cbiAgfVxuXG4gIHJhd1BhdGguX2RpcnR5ID0gMTtcbiAgcmV0dXJuIHJhd1BhdGg7XG59IC8vIHRyYW5zbGF0ZXMgU1ZHIGFyYyBkYXRhIGludG8gYSBzZWdtZW50IChjdWJpYyBiZXppZXJzKS4gQW5nbGUgaXMgaW4gZGVncmVlcy5cblxuZnVuY3Rpb24gYXJjVG9TZWdtZW50KGxhc3RYLCBsYXN0WSwgcngsIHJ5LCBhbmdsZSwgbGFyZ2VBcmNGbGFnLCBzd2VlcEZsYWcsIHgsIHkpIHtcbiAgaWYgKGxhc3RYID09PSB4ICYmIGxhc3RZID09PSB5KSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgcnggPSBfYWJzKHJ4KTtcbiAgcnkgPSBfYWJzKHJ5KTtcblxuICB2YXIgYW5nbGVSYWQgPSBhbmdsZSAlIDM2MCAqIF9ERUcyUkFELFxuICAgICAgY29zQW5nbGUgPSBfY29zKGFuZ2xlUmFkKSxcbiAgICAgIHNpbkFuZ2xlID0gX3NpbihhbmdsZVJhZCksXG4gICAgICBQSSA9IE1hdGguUEksXG4gICAgICBUV09QSSA9IFBJICogMixcbiAgICAgIGR4MiA9IChsYXN0WCAtIHgpIC8gMixcbiAgICAgIGR5MiA9IChsYXN0WSAtIHkpIC8gMixcbiAgICAgIHgxID0gY29zQW5nbGUgKiBkeDIgKyBzaW5BbmdsZSAqIGR5MixcbiAgICAgIHkxID0gLXNpbkFuZ2xlICogZHgyICsgY29zQW5nbGUgKiBkeTIsXG4gICAgICB4MV9zcSA9IHgxICogeDEsXG4gICAgICB5MV9zcSA9IHkxICogeTEsXG4gICAgICByYWRpaUNoZWNrID0geDFfc3EgLyAocnggKiByeCkgKyB5MV9zcSAvIChyeSAqIHJ5KTtcblxuICBpZiAocmFkaWlDaGVjayA+IDEpIHtcbiAgICByeCA9IF9zcXJ0KHJhZGlpQ2hlY2spICogcng7XG4gICAgcnkgPSBfc3FydChyYWRpaUNoZWNrKSAqIHJ5O1xuICB9XG5cbiAgdmFyIHJ4X3NxID0gcnggKiByeCxcbiAgICAgIHJ5X3NxID0gcnkgKiByeSxcbiAgICAgIHNxID0gKHJ4X3NxICogcnlfc3EgLSByeF9zcSAqIHkxX3NxIC0gcnlfc3EgKiB4MV9zcSkgLyAocnhfc3EgKiB5MV9zcSArIHJ5X3NxICogeDFfc3EpO1xuXG4gIGlmIChzcSA8IDApIHtcbiAgICBzcSA9IDA7XG4gIH1cblxuICB2YXIgY29lZiA9IChsYXJnZUFyY0ZsYWcgPT09IHN3ZWVwRmxhZyA/IC0xIDogMSkgKiBfc3FydChzcSksXG4gICAgICBjeDEgPSBjb2VmICogKHJ4ICogeTEgLyByeSksXG4gICAgICBjeTEgPSBjb2VmICogLShyeSAqIHgxIC8gcngpLFxuICAgICAgc3gyID0gKGxhc3RYICsgeCkgLyAyLFxuICAgICAgc3kyID0gKGxhc3RZICsgeSkgLyAyLFxuICAgICAgY3ggPSBzeDIgKyAoY29zQW5nbGUgKiBjeDEgLSBzaW5BbmdsZSAqIGN5MSksXG4gICAgICBjeSA9IHN5MiArIChzaW5BbmdsZSAqIGN4MSArIGNvc0FuZ2xlICogY3kxKSxcbiAgICAgIHV4ID0gKHgxIC0gY3gxKSAvIHJ4LFxuICAgICAgdXkgPSAoeTEgLSBjeTEpIC8gcnksXG4gICAgICB2eCA9ICgteDEgLSBjeDEpIC8gcngsXG4gICAgICB2eSA9ICgteTEgLSBjeTEpIC8gcnksXG4gICAgICB0ZW1wID0gdXggKiB1eCArIHV5ICogdXksXG4gICAgICBhbmdsZVN0YXJ0ID0gKHV5IDwgMCA/IC0xIDogMSkgKiBNYXRoLmFjb3ModXggLyBfc3FydCh0ZW1wKSksXG4gICAgICBhbmdsZUV4dGVudCA9ICh1eCAqIHZ5IC0gdXkgKiB2eCA8IDAgPyAtMSA6IDEpICogTWF0aC5hY29zKCh1eCAqIHZ4ICsgdXkgKiB2eSkgLyBfc3FydCh0ZW1wICogKHZ4ICogdnggKyB2eSAqIHZ5KSkpO1xuXG4gIGlzTmFOKGFuZ2xlRXh0ZW50KSAmJiAoYW5nbGVFeHRlbnQgPSBQSSk7IC8vcmFyZSBlZGdlIGNhc2UuIE1hdGguY29zKC0xKSBpcyBOYU4uXG5cbiAgaWYgKCFzd2VlcEZsYWcgJiYgYW5nbGVFeHRlbnQgPiAwKSB7XG4gICAgYW5nbGVFeHRlbnQgLT0gVFdPUEk7XG4gIH0gZWxzZSBpZiAoc3dlZXBGbGFnICYmIGFuZ2xlRXh0ZW50IDwgMCkge1xuICAgIGFuZ2xlRXh0ZW50ICs9IFRXT1BJO1xuICB9XG5cbiAgYW5nbGVTdGFydCAlPSBUV09QSTtcbiAgYW5nbGVFeHRlbnQgJT0gVFdPUEk7XG5cbiAgdmFyIHNlZ21lbnRzID0gTWF0aC5jZWlsKF9hYnMoYW5nbGVFeHRlbnQpIC8gKFRXT1BJIC8gNCkpLFxuICAgICAgcmF3UGF0aCA9IFtdLFxuICAgICAgYW5nbGVJbmNyZW1lbnQgPSBhbmdsZUV4dGVudCAvIHNlZ21lbnRzLFxuICAgICAgY29udHJvbExlbmd0aCA9IDQgLyAzICogX3NpbihhbmdsZUluY3JlbWVudCAvIDIpIC8gKDEgKyBfY29zKGFuZ2xlSW5jcmVtZW50IC8gMikpLFxuICAgICAgbWEgPSBjb3NBbmdsZSAqIHJ4LFxuICAgICAgbWIgPSBzaW5BbmdsZSAqIHJ4LFxuICAgICAgbWMgPSBzaW5BbmdsZSAqIC1yeSxcbiAgICAgIG1kID0gY29zQW5nbGUgKiByeSxcbiAgICAgIGk7XG5cbiAgZm9yIChpID0gMDsgaSA8IHNlZ21lbnRzOyBpKyspIHtcbiAgICBhbmdsZSA9IGFuZ2xlU3RhcnQgKyBpICogYW5nbGVJbmNyZW1lbnQ7XG4gICAgeDEgPSBfY29zKGFuZ2xlKTtcbiAgICB5MSA9IF9zaW4oYW5nbGUpO1xuICAgIHV4ID0gX2NvcyhhbmdsZSArPSBhbmdsZUluY3JlbWVudCk7XG4gICAgdXkgPSBfc2luKGFuZ2xlKTtcbiAgICByYXdQYXRoLnB1c2goeDEgLSBjb250cm9sTGVuZ3RoICogeTEsIHkxICsgY29udHJvbExlbmd0aCAqIHgxLCB1eCArIGNvbnRyb2xMZW5ndGggKiB1eSwgdXkgLSBjb250cm9sTGVuZ3RoICogdXgsIHV4LCB1eSk7XG4gIH0gLy9ub3cgdHJhbnNmb3JtIGFjY29yZGluZyB0byB0aGUgYWN0dWFsIHNpemUgb2YgdGhlIGVsbGlwc2UvYXJjICh0aGUgYmV6aWVycyB3ZXJlIG5vcmFtbGl6ZWQsIGJldHdlZW4gMCBhbmQgMSBvbiBhIGNpcmNsZSkuXG5cblxuICBmb3IgKGkgPSAwOyBpIDwgcmF3UGF0aC5sZW5ndGg7IGkgKz0gMikge1xuICAgIHgxID0gcmF3UGF0aFtpXTtcbiAgICB5MSA9IHJhd1BhdGhbaSArIDFdO1xuICAgIHJhd1BhdGhbaV0gPSB4MSAqIG1hICsgeTEgKiBtYyArIGN4O1xuICAgIHJhd1BhdGhbaSArIDFdID0geDEgKiBtYiArIHkxICogbWQgKyBjeTtcbiAgfVxuXG4gIHJhd1BhdGhbaSAtIDJdID0geDsgLy9hbHdheXMgc2V0IHRoZSBlbmQgdG8gZXhhY3RseSB3aGVyZSBpdCdzIHN1cHBvc2VkIHRvIGJlXG5cbiAgcmF3UGF0aFtpIC0gMV0gPSB5O1xuICByZXR1cm4gcmF3UGF0aDtcbn0gLy9TcGl0cyBiYWNrIGEgUmF3UGF0aCB3aXRoIGFic29sdXRlIGNvb3JkaW5hdGVzLiBFYWNoIHNlZ21lbnQgc3RhcnRzIHdpdGggYSBcIm1vdmVUb1wiIGNvbW1hbmQgKHggY29vcmRpbmF0ZSwgdGhlbiB5KSBhbmQgdGhlbiAyIGNvbnRyb2wgcG9pbnRzICh4LCB5LCB4LCB5KSwgdGhlbiBhbmNob3IuIFRoZSBnb2FsIGlzIHRvIG1pbmltaXplIG1lbW9yeSBhbmQgbWF4aW1pemUgc3BlZWQuXG5cblxuZXhwb3J0IGZ1bmN0aW9uIHN0cmluZ1RvUmF3UGF0aChkKSB7XG4gIHZhciBhID0gKGQgKyBcIlwiKS5yZXBsYWNlKF9zY2llbnRpZmljLCBmdW5jdGlvbiAobSkge1xuICAgIHZhciBuID0gK207XG4gICAgcmV0dXJuIG4gPCAwLjAwMDEgJiYgbiA+IC0wLjAwMDEgPyAwIDogbjtcbiAgfSkubWF0Y2goX3N2Z1BhdGhFeHApIHx8IFtdLFxuICAgICAgLy9zb21lIGF1dGhvcmluZyBwcm9ncmFtcyBzcGl0IG91dCB2ZXJ5IHNtYWxsIG51bWJlcnMgaW4gc2NpZW50aWZpYyBub3RhdGlvbiBsaWtlIFwiMWUtNVwiLCBzbyBtYWtlIHN1cmUgd2Ugcm91bmQgdGhhdCBkb3duIHRvIDAgZmlyc3QuXG4gIHBhdGggPSBbXSxcbiAgICAgIHJlbGF0aXZlWCA9IDAsXG4gICAgICByZWxhdGl2ZVkgPSAwLFxuICAgICAgdHdvVGhpcmRzID0gMiAvIDMsXG4gICAgICBlbGVtZW50cyA9IGEubGVuZ3RoLFxuICAgICAgcG9pbnRzID0gMCxcbiAgICAgIGVycm9yTWVzc2FnZSA9IFwiRVJST1I6IG1hbGZvcm1lZCBwYXRoOiBcIiArIGQsXG4gICAgICBpLFxuICAgICAgaixcbiAgICAgIHgsXG4gICAgICB5LFxuICAgICAgY29tbWFuZCxcbiAgICAgIGlzUmVsYXRpdmUsXG4gICAgICBzZWdtZW50LFxuICAgICAgc3RhcnRYLFxuICAgICAgc3RhcnRZLFxuICAgICAgZGlmWCxcbiAgICAgIGRpZlksXG4gICAgICBiZXppZXJzLFxuICAgICAgcHJldkNvbW1hbmQsXG4gICAgICBmbGFnMSxcbiAgICAgIGZsYWcyLFxuICAgICAgbGluZSA9IGZ1bmN0aW9uIGxpbmUoc3gsIHN5LCBleCwgZXkpIHtcbiAgICBkaWZYID0gKGV4IC0gc3gpIC8gMztcbiAgICBkaWZZID0gKGV5IC0gc3kpIC8gMztcbiAgICBzZWdtZW50LnB1c2goc3ggKyBkaWZYLCBzeSArIGRpZlksIGV4IC0gZGlmWCwgZXkgLSBkaWZZLCBleCwgZXkpO1xuICB9O1xuXG4gIGlmICghZCB8fCAhaXNOYU4oYVswXSkgfHwgaXNOYU4oYVsxXSkpIHtcbiAgICBjb25zb2xlLmxvZyhlcnJvck1lc3NhZ2UpO1xuICAgIHJldHVybiBwYXRoO1xuICB9XG5cbiAgZm9yIChpID0gMDsgaSA8IGVsZW1lbnRzOyBpKyspIHtcbiAgICBwcmV2Q29tbWFuZCA9IGNvbW1hbmQ7XG5cbiAgICBpZiAoaXNOYU4oYVtpXSkpIHtcbiAgICAgIGNvbW1hbmQgPSBhW2ldLnRvVXBwZXJDYXNlKCk7XG4gICAgICBpc1JlbGF0aXZlID0gY29tbWFuZCAhPT0gYVtpXTsgLy9sb3dlciBjYXNlIG1lYW5zIHJlbGF0aXZlXG4gICAgfSBlbHNlIHtcbiAgICAgIC8vY29tbWFuZHMgbGlrZSBcIkNcIiBjYW4gYmUgc3RydW5nIHRvZ2V0aGVyIHdpdGhvdXQgYW55IG5ldyBjb21tYW5kIGNoYXJhY3RlcnMgYmV0d2Vlbi5cbiAgICAgIGktLTtcbiAgICB9XG5cbiAgICB4ID0gK2FbaSArIDFdO1xuICAgIHkgPSArYVtpICsgMl07XG5cbiAgICBpZiAoaXNSZWxhdGl2ZSkge1xuICAgICAgeCArPSByZWxhdGl2ZVg7XG4gICAgICB5ICs9IHJlbGF0aXZlWTtcbiAgICB9XG5cbiAgICBpZiAoIWkpIHtcbiAgICAgIHN0YXJ0WCA9IHg7XG4gICAgICBzdGFydFkgPSB5O1xuICAgIH0gLy8gXCJNXCIgKG1vdmUpXG5cblxuICAgIGlmIChjb21tYW5kID09PSBcIk1cIikge1xuICAgICAgaWYgKHNlZ21lbnQpIHtcbiAgICAgICAgaWYgKHNlZ21lbnQubGVuZ3RoIDwgOCkge1xuICAgICAgICAgIC8vaWYgdGhlIHBhdGggZGF0YSB3YXMgZnVua3kgYW5kIGp1c3QgaGFkIGEgTSB3aXRoIG5vIGFjdHVhbCBkcmF3aW5nIGFueXdoZXJlLCBza2lwIGl0LlxuICAgICAgICAgIHBhdGgubGVuZ3RoIC09IDE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcG9pbnRzICs9IHNlZ21lbnQubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJlbGF0aXZlWCA9IHN0YXJ0WCA9IHg7XG4gICAgICByZWxhdGl2ZVkgPSBzdGFydFkgPSB5O1xuICAgICAgc2VnbWVudCA9IFt4LCB5XTtcbiAgICAgIHBhdGgucHVzaChzZWdtZW50KTtcbiAgICAgIGkgKz0gMjtcbiAgICAgIGNvbW1hbmQgPSBcIkxcIjsgLy9hbiBcIk1cIiB3aXRoIG1vcmUgdGhhbiAyIHZhbHVlcyBnZXRzIGludGVycHJldGVkIGFzIFwibGluZVRvXCIgY29tbWFuZHMgKFwiTFwiKS5cbiAgICAgIC8vIFwiQ1wiIChjdWJpYyBiZXppZXIpXG4gICAgfSBlbHNlIGlmIChjb21tYW5kID09PSBcIkNcIikge1xuICAgICAgaWYgKCFzZWdtZW50KSB7XG4gICAgICAgIHNlZ21lbnQgPSBbMCwgMF07XG4gICAgICB9XG5cbiAgICAgIGlmICghaXNSZWxhdGl2ZSkge1xuICAgICAgICByZWxhdGl2ZVggPSByZWxhdGl2ZVkgPSAwO1xuICAgICAgfSAvL25vdGU6IFwiKjFcIiBpcyBqdXN0IGEgZmFzdC9zaG9ydCB3YXkgdG8gY2FzdCB0aGUgdmFsdWUgYXMgYSBOdW1iZXIuIFdBQUFZIGZhc3RlciBpbiBDaHJvbWUsIHNsaWdodGx5IHNsb3dlciBpbiBGaXJlZm94LlxuXG5cbiAgICAgIHNlZ21lbnQucHVzaCh4LCB5LCByZWxhdGl2ZVggKyBhW2kgKyAzXSAqIDEsIHJlbGF0aXZlWSArIGFbaSArIDRdICogMSwgcmVsYXRpdmVYICs9IGFbaSArIDVdICogMSwgcmVsYXRpdmVZICs9IGFbaSArIDZdICogMSk7XG4gICAgICBpICs9IDY7IC8vIFwiU1wiIChjb250aW51YXRpb24gb2YgY3ViaWMgYmV6aWVyKVxuICAgIH0gZWxzZSBpZiAoY29tbWFuZCA9PT0gXCJTXCIpIHtcbiAgICAgIGRpZlggPSByZWxhdGl2ZVg7XG4gICAgICBkaWZZID0gcmVsYXRpdmVZO1xuXG4gICAgICBpZiAocHJldkNvbW1hbmQgPT09IFwiQ1wiIHx8IHByZXZDb21tYW5kID09PSBcIlNcIikge1xuICAgICAgICBkaWZYICs9IHJlbGF0aXZlWCAtIHNlZ21lbnRbc2VnbWVudC5sZW5ndGggLSA0XTtcbiAgICAgICAgZGlmWSArPSByZWxhdGl2ZVkgLSBzZWdtZW50W3NlZ21lbnQubGVuZ3RoIC0gM107XG4gICAgICB9XG5cbiAgICAgIGlmICghaXNSZWxhdGl2ZSkge1xuICAgICAgICByZWxhdGl2ZVggPSByZWxhdGl2ZVkgPSAwO1xuICAgICAgfVxuXG4gICAgICBzZWdtZW50LnB1c2goZGlmWCwgZGlmWSwgeCwgeSwgcmVsYXRpdmVYICs9IGFbaSArIDNdICogMSwgcmVsYXRpdmVZICs9IGFbaSArIDRdICogMSk7XG4gICAgICBpICs9IDQ7IC8vIFwiUVwiIChxdWFkcmF0aWMgYmV6aWVyKVxuICAgIH0gZWxzZSBpZiAoY29tbWFuZCA9PT0gXCJRXCIpIHtcbiAgICAgIGRpZlggPSByZWxhdGl2ZVggKyAoeCAtIHJlbGF0aXZlWCkgKiB0d29UaGlyZHM7XG4gICAgICBkaWZZID0gcmVsYXRpdmVZICsgKHkgLSByZWxhdGl2ZVkpICogdHdvVGhpcmRzO1xuXG4gICAgICBpZiAoIWlzUmVsYXRpdmUpIHtcbiAgICAgICAgcmVsYXRpdmVYID0gcmVsYXRpdmVZID0gMDtcbiAgICAgIH1cblxuICAgICAgcmVsYXRpdmVYICs9IGFbaSArIDNdICogMTtcbiAgICAgIHJlbGF0aXZlWSArPSBhW2kgKyA0XSAqIDE7XG4gICAgICBzZWdtZW50LnB1c2goZGlmWCwgZGlmWSwgcmVsYXRpdmVYICsgKHggLSByZWxhdGl2ZVgpICogdHdvVGhpcmRzLCByZWxhdGl2ZVkgKyAoeSAtIHJlbGF0aXZlWSkgKiB0d29UaGlyZHMsIHJlbGF0aXZlWCwgcmVsYXRpdmVZKTtcbiAgICAgIGkgKz0gNDsgLy8gXCJUXCIgKGNvbnRpbnVhdGlvbiBvZiBxdWFkcmF0aWMgYmV6aWVyKVxuICAgIH0gZWxzZSBpZiAoY29tbWFuZCA9PT0gXCJUXCIpIHtcbiAgICAgIGRpZlggPSByZWxhdGl2ZVggLSBzZWdtZW50W3NlZ21lbnQubGVuZ3RoIC0gNF07XG4gICAgICBkaWZZID0gcmVsYXRpdmVZIC0gc2VnbWVudFtzZWdtZW50Lmxlbmd0aCAtIDNdO1xuICAgICAgc2VnbWVudC5wdXNoKHJlbGF0aXZlWCArIGRpZlgsIHJlbGF0aXZlWSArIGRpZlksIHggKyAocmVsYXRpdmVYICsgZGlmWCAqIDEuNSAtIHgpICogdHdvVGhpcmRzLCB5ICsgKHJlbGF0aXZlWSArIGRpZlkgKiAxLjUgLSB5KSAqIHR3b1RoaXJkcywgcmVsYXRpdmVYID0geCwgcmVsYXRpdmVZID0geSk7XG4gICAgICBpICs9IDI7IC8vIFwiSFwiIChob3Jpem9udGFsIGxpbmUpXG4gICAgfSBlbHNlIGlmIChjb21tYW5kID09PSBcIkhcIikge1xuICAgICAgbGluZShyZWxhdGl2ZVgsIHJlbGF0aXZlWSwgcmVsYXRpdmVYID0geCwgcmVsYXRpdmVZKTtcbiAgICAgIGkgKz0gMTsgLy8gXCJWXCIgKHZlcnRpY2FsIGxpbmUpXG4gICAgfSBlbHNlIGlmIChjb21tYW5kID09PSBcIlZcIikge1xuICAgICAgLy9hZGp1c3QgdmFsdWVzIGJlY2F1c2UgdGhlIGZpcnN0IChhbmQgb25seSBvbmUpIGlzbid0IHggaW4gdGhpcyBjYXNlLCBpdCdzIHkuXG4gICAgICBsaW5lKHJlbGF0aXZlWCwgcmVsYXRpdmVZLCByZWxhdGl2ZVgsIHJlbGF0aXZlWSA9IHggKyAoaXNSZWxhdGl2ZSA/IHJlbGF0aXZlWSAtIHJlbGF0aXZlWCA6IDApKTtcbiAgICAgIGkgKz0gMTsgLy8gXCJMXCIgKGxpbmUpIG9yIFwiWlwiIChjbG9zZSlcbiAgICB9IGVsc2UgaWYgKGNvbW1hbmQgPT09IFwiTFwiIHx8IGNvbW1hbmQgPT09IFwiWlwiKSB7XG4gICAgICBpZiAoY29tbWFuZCA9PT0gXCJaXCIpIHtcbiAgICAgICAgeCA9IHN0YXJ0WDtcbiAgICAgICAgeSA9IHN0YXJ0WTtcbiAgICAgICAgc2VnbWVudC5jbG9zZWQgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAoY29tbWFuZCA9PT0gXCJMXCIgfHwgX2FicyhyZWxhdGl2ZVggLSB4KSA+IDAuNSB8fCBfYWJzKHJlbGF0aXZlWSAtIHkpID4gMC41KSB7XG4gICAgICAgIGxpbmUocmVsYXRpdmVYLCByZWxhdGl2ZVksIHgsIHkpO1xuXG4gICAgICAgIGlmIChjb21tYW5kID09PSBcIkxcIikge1xuICAgICAgICAgIGkgKz0gMjtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZWxhdGl2ZVggPSB4O1xuICAgICAgcmVsYXRpdmVZID0geTsgLy8gXCJBXCIgKGFyYylcbiAgICB9IGVsc2UgaWYgKGNvbW1hbmQgPT09IFwiQVwiKSB7XG4gICAgICBmbGFnMSA9IGFbaSArIDRdO1xuICAgICAgZmxhZzIgPSBhW2kgKyA1XTtcbiAgICAgIGRpZlggPSBhW2kgKyA2XTtcbiAgICAgIGRpZlkgPSBhW2kgKyA3XTtcbiAgICAgIGogPSA3O1xuXG4gICAgICBpZiAoZmxhZzEubGVuZ3RoID4gMSkge1xuICAgICAgICAvLyBmb3IgY2FzZXMgd2hlbiB0aGUgZmxhZ3MgYXJlIG1lcmdlZCwgbGlrZSBcImE4IDggMCAwMTggOFwiICh0aGUgMCBhbmQgMSBmbGFncyBhcmUgV0lUSCB0aGUgeCB2YWx1ZSBvZiA4LCBidXQgaXQgY291bGQgYWxzbyBiZSBcImE4IDggMCAwMS04IDhcIiBzbyBpdCBtYXkgaW5jbHVkZSB4IG9yIG5vdClcbiAgICAgICAgaWYgKGZsYWcxLmxlbmd0aCA8IDMpIHtcbiAgICAgICAgICBkaWZZID0gZGlmWDtcbiAgICAgICAgICBkaWZYID0gZmxhZzI7XG4gICAgICAgICAgai0tO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRpZlkgPSBmbGFnMjtcbiAgICAgICAgICBkaWZYID0gZmxhZzEuc3Vic3RyKDIpO1xuICAgICAgICAgIGogLT0gMjtcbiAgICAgICAgfVxuXG4gICAgICAgIGZsYWcyID0gZmxhZzEuY2hhckF0KDEpO1xuICAgICAgICBmbGFnMSA9IGZsYWcxLmNoYXJBdCgwKTtcbiAgICAgIH1cblxuICAgICAgYmV6aWVycyA9IGFyY1RvU2VnbWVudChyZWxhdGl2ZVgsIHJlbGF0aXZlWSwgK2FbaSArIDFdLCArYVtpICsgMl0sICthW2kgKyAzXSwgK2ZsYWcxLCArZmxhZzIsIChpc1JlbGF0aXZlID8gcmVsYXRpdmVYIDogMCkgKyBkaWZYICogMSwgKGlzUmVsYXRpdmUgPyByZWxhdGl2ZVkgOiAwKSArIGRpZlkgKiAxKTtcbiAgICAgIGkgKz0gajtcblxuICAgICAgaWYgKGJlemllcnMpIHtcbiAgICAgICAgZm9yIChqID0gMDsgaiA8IGJlemllcnMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICBzZWdtZW50LnB1c2goYmV6aWVyc1tqXSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmVsYXRpdmVYID0gc2VnbWVudFtzZWdtZW50Lmxlbmd0aCAtIDJdO1xuICAgICAgcmVsYXRpdmVZID0gc2VnbWVudFtzZWdtZW50Lmxlbmd0aCAtIDFdO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zb2xlLmxvZyhlcnJvck1lc3NhZ2UpO1xuICAgIH1cbiAgfVxuXG4gIGkgPSBzZWdtZW50Lmxlbmd0aDtcblxuICBpZiAoaSA8IDYpIHtcbiAgICAvL2luIGNhc2UgdGhlcmUncyBvZGQgU1ZHIGxpa2UgYSBNMCwwIGNvbW1hbmQgYXQgdGhlIHZlcnkgZW5kLlxuICAgIHBhdGgucG9wKCk7XG4gICAgaSA9IDA7XG4gIH0gZWxzZSBpZiAoc2VnbWVudFswXSA9PT0gc2VnbWVudFtpIC0gMl0gJiYgc2VnbWVudFsxXSA9PT0gc2VnbWVudFtpIC0gMV0pIHtcbiAgICBzZWdtZW50LmNsb3NlZCA9IHRydWU7XG4gIH1cblxuICBwYXRoLnRvdGFsUG9pbnRzID0gcG9pbnRzICsgaTtcbiAgcmV0dXJuIHBhdGg7XG59IC8vcG9wdWxhdGVzIHRoZSBwb2ludHMgYXJyYXkgaW4gYWx0ZXJuYXRpbmcgeC95IHZhbHVlcyAobGlrZSBbeCwgeSwgeCwgeS4uLl0gaW5zdGVhZCBvZiBpbmRpdmlkdWFsIHBvaW50IG9iamVjdHMgW3t4LCB5fSwge3gsIHl9Li4uXSB0byBjb25zZXJ2ZSBtZW1vcnkgYW5kIHN0YXkgaW4gbGluZSB3aXRoIGhvdyB3ZSdyZSBoYW5kbGluZyBzZWdtZW50IGFycmF5c1xuXG5leHBvcnQgZnVuY3Rpb24gYmV6aWVyVG9Qb2ludHMoeDEsIHkxLCB4MiwgeTIsIHgzLCB5MywgeDQsIHk0LCB0aHJlc2hvbGQsIHBvaW50cywgaW5kZXgpIHtcbiAgdmFyIHgxMiA9ICh4MSArIHgyKSAvIDIsXG4gICAgICB5MTIgPSAoeTEgKyB5MikgLyAyLFxuICAgICAgeDIzID0gKHgyICsgeDMpIC8gMixcbiAgICAgIHkyMyA9ICh5MiArIHkzKSAvIDIsXG4gICAgICB4MzQgPSAoeDMgKyB4NCkgLyAyLFxuICAgICAgeTM0ID0gKHkzICsgeTQpIC8gMixcbiAgICAgIHgxMjMgPSAoeDEyICsgeDIzKSAvIDIsXG4gICAgICB5MTIzID0gKHkxMiArIHkyMykgLyAyLFxuICAgICAgeDIzNCA9ICh4MjMgKyB4MzQpIC8gMixcbiAgICAgIHkyMzQgPSAoeTIzICsgeTM0KSAvIDIsXG4gICAgICB4MTIzNCA9ICh4MTIzICsgeDIzNCkgLyAyLFxuICAgICAgeTEyMzQgPSAoeTEyMyArIHkyMzQpIC8gMixcbiAgICAgIGR4ID0geDQgLSB4MSxcbiAgICAgIGR5ID0geTQgLSB5MSxcbiAgICAgIGQyID0gX2FicygoeDIgLSB4NCkgKiBkeSAtICh5MiAtIHk0KSAqIGR4KSxcbiAgICAgIGQzID0gX2FicygoeDMgLSB4NCkgKiBkeSAtICh5MyAtIHk0KSAqIGR4KSxcbiAgICAgIGxlbmd0aDtcblxuICBpZiAoIXBvaW50cykge1xuICAgIHBvaW50cyA9IFt4MSwgeTEsIHg0LCB5NF07XG4gICAgaW5kZXggPSAyO1xuICB9XG5cbiAgcG9pbnRzLnNwbGljZShpbmRleCB8fCBwb2ludHMubGVuZ3RoIC0gMiwgMCwgeDEyMzQsIHkxMjM0KTtcblxuICBpZiAoKGQyICsgZDMpICogKGQyICsgZDMpID4gdGhyZXNob2xkICogKGR4ICogZHggKyBkeSAqIGR5KSkge1xuICAgIGxlbmd0aCA9IHBvaW50cy5sZW5ndGg7XG4gICAgYmV6aWVyVG9Qb2ludHMoeDEsIHkxLCB4MTIsIHkxMiwgeDEyMywgeTEyMywgeDEyMzQsIHkxMjM0LCB0aHJlc2hvbGQsIHBvaW50cywgaW5kZXgpO1xuICAgIGJlemllclRvUG9pbnRzKHgxMjM0LCB5MTIzNCwgeDIzNCwgeTIzNCwgeDM0LCB5MzQsIHg0LCB5NCwgdGhyZXNob2xkLCBwb2ludHMsIGluZGV4ICsgMiArIChwb2ludHMubGVuZ3RoIC0gbGVuZ3RoKSk7XG4gIH1cblxuICByZXR1cm4gcG9pbnRzO1xufVxuLypcbmZ1bmN0aW9uIGdldEFuZ2xlQmV0d2VlblBvaW50cyh4MCwgeTAsIHgxLCB5MSwgeDIsIHkyKSB7IC8vYW5nbGUgYmV0d2VlbiAzIHBvaW50cyBpbiByYWRpYW5zXG5cdHZhciBkeDEgPSB4MSAtIHgwLFxuXHRcdGR5MSA9IHkxIC0geTAsXG5cdFx0ZHgyID0geDIgLSB4MSxcblx0XHRkeTIgPSB5MiAtIHkxLFxuXHRcdGR4MyA9IHgyIC0geDAsXG5cdFx0ZHkzID0geTIgLSB5MCxcblx0XHRhID0gZHgxICogZHgxICsgZHkxICogZHkxLFxuXHRcdGIgPSBkeDIgKiBkeDIgKyBkeTIgKiBkeTIsXG5cdFx0YyA9IGR4MyAqIGR4MyArIGR5MyAqIGR5Mztcblx0cmV0dXJuIE1hdGguYWNvcyggKGEgKyBiIC0gYykgLyBfc3FydCg0ICogYSAqIGIpICk7XG59LFxuKi9cbi8vcG9pbnRzVG9TZWdtZW50KCkgZG9lc24ndCBoYW5kbGUgZmxhdCBjb29yZGluYXRlcyAod2hlcmUgeSBpcyBhbHdheXMgMCkgdGhlIHdheSB3ZSBuZWVkICh0aGUgcmVzdWx0aW5nIGNvbnRyb2wgcG9pbnRzIGFyZSBhbHdheXMgcmlnaHQgb24gdG9wIG9mIHRoZSBhbmNob3JzKSwgc28gdGhpcyBmdW5jdGlvbiBiYXNpY2FsbHkgbWFrZXMgdGhlIGNvbnRyb2wgcG9pbnRzIGdvIGRpcmVjdGx5IHVwIGFuZCBkb3duLCB2YXJ5aW5nIGluIGxlbmd0aCBiYXNlZCBvbiB0aGUgY3VydmluZXNzIChtb3JlIGN1cnZ5LCBmdXJ0aGVyIGNvbnRyb2wgcG9pbnRzKVxuXG5leHBvcnQgZnVuY3Rpb24gZmxhdFBvaW50c1RvU2VnbWVudChwb2ludHMsIGN1cnZpbmVzcykge1xuICBpZiAoY3VydmluZXNzID09PSB2b2lkIDApIHtcbiAgICBjdXJ2aW5lc3MgPSAxO1xuICB9XG5cbiAgdmFyIHggPSBwb2ludHNbMF0sXG4gICAgICB5ID0gMCxcbiAgICAgIHNlZ21lbnQgPSBbeCwgeV0sXG4gICAgICBpID0gMjtcblxuICBmb3IgKDsgaSA8IHBvaW50cy5sZW5ndGg7IGkgKz0gMikge1xuICAgIHNlZ21lbnQucHVzaCh4LCB5LCBwb2ludHNbaV0sIHkgPSAocG9pbnRzW2ldIC0geCkgKiBjdXJ2aW5lc3MgLyAyLCB4ID0gcG9pbnRzW2ldLCAteSk7XG4gIH1cblxuICByZXR1cm4gc2VnbWVudDtcbn0gLy9wb2ludHMgaXMgYW4gYXJyYXkgb2YgeC95IHBvaW50cywgbGlrZSBbeCwgeSwgeCwgeSwgeCwgeV1cblxuZXhwb3J0IGZ1bmN0aW9uIHBvaW50c1RvU2VnbWVudChwb2ludHMsIGN1cnZpbmVzcykge1xuICAvL3BvaW50cyA9IHNpbXBsaWZ5UG9pbnRzKHBvaW50cywgdG9sZXJhbmNlKTtcbiAgX2Ficyhwb2ludHNbMF0gLSBwb2ludHNbMl0pIDwgMWUtNCAmJiBfYWJzKHBvaW50c1sxXSAtIHBvaW50c1szXSkgPCAxZS00ICYmIChwb2ludHMgPSBwb2ludHMuc2xpY2UoMikpOyAvLyBpZiB0aGUgZmlyc3QgdHdvIHBvaW50cyBhcmUgc3VwZXIgY2xvc2UsIGR1bXAgdGhlIGZpcnN0IG9uZS5cblxuICB2YXIgbCA9IHBvaW50cy5sZW5ndGggLSAyLFxuICAgICAgeCA9ICtwb2ludHNbMF0sXG4gICAgICB5ID0gK3BvaW50c1sxXSxcbiAgICAgIG5leHRYID0gK3BvaW50c1syXSxcbiAgICAgIG5leHRZID0gK3BvaW50c1szXSxcbiAgICAgIHNlZ21lbnQgPSBbeCwgeSwgeCwgeV0sXG4gICAgICBkeDIgPSBuZXh0WCAtIHgsXG4gICAgICBkeTIgPSBuZXh0WSAtIHksXG4gICAgICBjbG9zZWQgPSBNYXRoLmFicyhwb2ludHNbbF0gLSB4KSA8IDAuMDAxICYmIE1hdGguYWJzKHBvaW50c1tsICsgMV0gLSB5KSA8IDAuMDAxLFxuICAgICAgcHJldlgsXG4gICAgICBwcmV2WSxcbiAgICAgIGksXG4gICAgICBkeDEsXG4gICAgICBkeTEsXG4gICAgICByMSxcbiAgICAgIHIyLFxuICAgICAgcjMsXG4gICAgICB0bCxcbiAgICAgIG14MSxcbiAgICAgIG14MixcbiAgICAgIG14bSxcbiAgICAgIG15MSxcbiAgICAgIG15MixcbiAgICAgIG15bTtcblxuICBpZiAoY2xvc2VkKSB7XG4gICAgLy8gaWYgdGhlIHN0YXJ0IGFuZCBlbmQgcG9pbnRzIGFyZSBiYXNpY2FsbHkgb24gdG9wIG9mIGVhY2ggb3RoZXIsIGNsb3NlIHRoZSBzZWdtZW50IGJ5IGFkZGluZyB0aGUgMm5kIHBvaW50IHRvIHRoZSBlbmQsIGFuZCB0aGUgMm5kLXRvLWxhc3QgcG9pbnQgdG8gdGhlIGJlZ2lubmluZyAod2UnbGwgcmVtb3ZlIHRoZW0gYXQgdGhlIGVuZCwgYnV0IHRoaXMgYWxsb3dzIHRoZSBjdXJ2YXR1cmUgdG8gbG9vayBwZXJmZWN0KVxuICAgIHBvaW50cy5wdXNoKG5leHRYLCBuZXh0WSk7XG4gICAgbmV4dFggPSB4O1xuICAgIG5leHRZID0geTtcbiAgICB4ID0gcG9pbnRzW2wgLSAyXTtcbiAgICB5ID0gcG9pbnRzW2wgLSAxXTtcbiAgICBwb2ludHMudW5zaGlmdCh4LCB5KTtcbiAgICBsICs9IDQ7XG4gIH1cblxuICBjdXJ2aW5lc3MgPSBjdXJ2aW5lc3MgfHwgY3VydmluZXNzID09PSAwID8gK2N1cnZpbmVzcyA6IDE7XG5cbiAgZm9yIChpID0gMjsgaSA8IGw7IGkgKz0gMikge1xuICAgIHByZXZYID0geDtcbiAgICBwcmV2WSA9IHk7XG4gICAgeCA9IG5leHRYO1xuICAgIHkgPSBuZXh0WTtcbiAgICBuZXh0WCA9ICtwb2ludHNbaSArIDJdO1xuICAgIG5leHRZID0gK3BvaW50c1tpICsgM107XG5cbiAgICBpZiAoeCA9PT0gbmV4dFggJiYgeSA9PT0gbmV4dFkpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGR4MSA9IGR4MjtcbiAgICBkeTEgPSBkeTI7XG4gICAgZHgyID0gbmV4dFggLSB4O1xuICAgIGR5MiA9IG5leHRZIC0geTtcbiAgICByMSA9IF9zcXJ0KGR4MSAqIGR4MSArIGR5MSAqIGR5MSk7IC8vIHIxLCByMiwgYW5kIHIzIGNvcnJlbGF0ZSB4IGFuZCB5IChhbmQgeiBpbiB0aGUgZnV0dXJlKS4gQmFzaWNhbGx5IDJEIG9yIDNEIGh5cG90ZW51c2VcblxuICAgIHIyID0gX3NxcnQoZHgyICogZHgyICsgZHkyICogZHkyKTtcbiAgICByMyA9IF9zcXJ0KE1hdGgucG93KGR4MiAvIHIyICsgZHgxIC8gcjEsIDIpICsgTWF0aC5wb3coZHkyIC8gcjIgKyBkeTEgLyByMSwgMikpO1xuICAgIHRsID0gKHIxICsgcjIpICogY3VydmluZXNzICogMC4yNSAvIHIzO1xuICAgIG14MSA9IHggLSAoeCAtIHByZXZYKSAqIChyMSA/IHRsIC8gcjEgOiAwKTtcbiAgICBteDIgPSB4ICsgKG5leHRYIC0geCkgKiAocjIgPyB0bCAvIHIyIDogMCk7XG4gICAgbXhtID0geCAtIChteDEgKyAoKG14MiAtIG14MSkgKiAocjEgKiAzIC8gKHIxICsgcjIpICsgMC41KSAvIDQgfHwgMCkpO1xuICAgIG15MSA9IHkgLSAoeSAtIHByZXZZKSAqIChyMSA/IHRsIC8gcjEgOiAwKTtcbiAgICBteTIgPSB5ICsgKG5leHRZIC0geSkgKiAocjIgPyB0bCAvIHIyIDogMCk7XG4gICAgbXltID0geSAtIChteTEgKyAoKG15MiAtIG15MSkgKiAocjEgKiAzIC8gKHIxICsgcjIpICsgMC41KSAvIDQgfHwgMCkpO1xuXG4gICAgaWYgKHggIT09IHByZXZYIHx8IHkgIT09IHByZXZZKSB7XG4gICAgICBzZWdtZW50LnB1c2goX3JvdW5kKG14MSArIG14bSksIC8vIGZpcnN0IGNvbnRyb2wgcG9pbnRcbiAgICAgIF9yb3VuZChteTEgKyBteW0pLCBfcm91bmQoeCksIC8vIGFuY2hvclxuICAgICAgX3JvdW5kKHkpLCBfcm91bmQobXgyICsgbXhtKSwgLy8gc2Vjb25kIGNvbnRyb2wgcG9pbnRcbiAgICAgIF9yb3VuZChteTIgKyBteW0pKTtcbiAgICB9XG4gIH1cblxuICB4ICE9PSBuZXh0WCB8fCB5ICE9PSBuZXh0WSB8fCBzZWdtZW50Lmxlbmd0aCA8IDQgPyBzZWdtZW50LnB1c2goX3JvdW5kKG5leHRYKSwgX3JvdW5kKG5leHRZKSwgX3JvdW5kKG5leHRYKSwgX3JvdW5kKG5leHRZKSkgOiBzZWdtZW50Lmxlbmd0aCAtPSAyO1xuXG4gIGlmIChzZWdtZW50Lmxlbmd0aCA9PT0gMikge1xuICAgIC8vIG9ubHkgb25lIHBvaW50IVxuICAgIHNlZ21lbnQucHVzaCh4LCB5LCB4LCB5LCB4LCB5KTtcbiAgfSBlbHNlIGlmIChjbG9zZWQpIHtcbiAgICBzZWdtZW50LnNwbGljZSgwLCA2KTtcbiAgICBzZWdtZW50Lmxlbmd0aCA9IHNlZ21lbnQubGVuZ3RoIC0gNjtcbiAgfVxuXG4gIHJldHVybiBzZWdtZW50O1xufSAvL3JldHVybnMgdGhlIHNxdWFyZWQgZGlzdGFuY2UgYmV0d2VlbiBhbiB4L3kgY29vcmRpbmF0ZSBhbmQgYSBzZWdtZW50IGJldHdlZW4geDEveTEgYW5kIHgyL3kyXG5cbmZ1bmN0aW9uIHBvaW50VG9TZWdEaXN0KHgsIHksIHgxLCB5MSwgeDIsIHkyKSB7XG4gIHZhciBkeCA9IHgyIC0geDEsXG4gICAgICBkeSA9IHkyIC0geTEsXG4gICAgICB0O1xuXG4gIGlmIChkeCB8fCBkeSkge1xuICAgIHQgPSAoKHggLSB4MSkgKiBkeCArICh5IC0geTEpICogZHkpIC8gKGR4ICogZHggKyBkeSAqIGR5KTtcblxuICAgIGlmICh0ID4gMSkge1xuICAgICAgeDEgPSB4MjtcbiAgICAgIHkxID0geTI7XG4gICAgfSBlbHNlIGlmICh0ID4gMCkge1xuICAgICAgeDEgKz0gZHggKiB0O1xuICAgICAgeTEgKz0gZHkgKiB0O1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBNYXRoLnBvdyh4IC0geDEsIDIpICsgTWF0aC5wb3coeSAtIHkxLCAyKTtcbn1cblxuZnVuY3Rpb24gc2ltcGxpZnlTdGVwKHBvaW50cywgZmlyc3QsIGxhc3QsIHRvbGVyYW5jZSwgc2ltcGxpZmllZCkge1xuICB2YXIgbWF4U3FEaXN0ID0gdG9sZXJhbmNlLFxuICAgICAgZmlyc3RYID0gcG9pbnRzW2ZpcnN0XSxcbiAgICAgIGZpcnN0WSA9IHBvaW50c1tmaXJzdCArIDFdLFxuICAgICAgbGFzdFggPSBwb2ludHNbbGFzdF0sXG4gICAgICBsYXN0WSA9IHBvaW50c1tsYXN0ICsgMV0sXG4gICAgICBpbmRleCxcbiAgICAgIGksXG4gICAgICBkO1xuXG4gIGZvciAoaSA9IGZpcnN0ICsgMjsgaSA8IGxhc3Q7IGkgKz0gMikge1xuICAgIGQgPSBwb2ludFRvU2VnRGlzdChwb2ludHNbaV0sIHBvaW50c1tpICsgMV0sIGZpcnN0WCwgZmlyc3RZLCBsYXN0WCwgbGFzdFkpO1xuXG4gICAgaWYgKGQgPiBtYXhTcURpc3QpIHtcbiAgICAgIGluZGV4ID0gaTtcbiAgICAgIG1heFNxRGlzdCA9IGQ7XG4gICAgfVxuICB9XG5cbiAgaWYgKG1heFNxRGlzdCA+IHRvbGVyYW5jZSkge1xuICAgIGluZGV4IC0gZmlyc3QgPiAyICYmIHNpbXBsaWZ5U3RlcChwb2ludHMsIGZpcnN0LCBpbmRleCwgdG9sZXJhbmNlLCBzaW1wbGlmaWVkKTtcbiAgICBzaW1wbGlmaWVkLnB1c2gocG9pbnRzW2luZGV4XSwgcG9pbnRzW2luZGV4ICsgMV0pO1xuICAgIGxhc3QgLSBpbmRleCA+IDIgJiYgc2ltcGxpZnlTdGVwKHBvaW50cywgaW5kZXgsIGxhc3QsIHRvbGVyYW5jZSwgc2ltcGxpZmllZCk7XG4gIH1cbn0gLy9wb2ludHMgaXMgYW4gYXJyYXkgb2YgeC95IHZhbHVlcyBsaWtlIFt4LCB5LCB4LCB5LCB4LCB5XVxuXG5cbmV4cG9ydCBmdW5jdGlvbiBzaW1wbGlmeVBvaW50cyhwb2ludHMsIHRvbGVyYW5jZSkge1xuICB2YXIgcHJldlggPSBwYXJzZUZsb2F0KHBvaW50c1swXSksXG4gICAgICBwcmV2WSA9IHBhcnNlRmxvYXQocG9pbnRzWzFdKSxcbiAgICAgIHRlbXAgPSBbcHJldlgsIHByZXZZXSxcbiAgICAgIGwgPSBwb2ludHMubGVuZ3RoIC0gMixcbiAgICAgIGksXG4gICAgICB4LFxuICAgICAgeSxcbiAgICAgIGR4LFxuICAgICAgZHksXG4gICAgICByZXN1bHQsXG4gICAgICBsYXN0O1xuICB0b2xlcmFuY2UgPSBNYXRoLnBvdyh0b2xlcmFuY2UgfHwgMSwgMik7XG5cbiAgZm9yIChpID0gMjsgaSA8IGw7IGkgKz0gMikge1xuICAgIHggPSBwYXJzZUZsb2F0KHBvaW50c1tpXSk7XG4gICAgeSA9IHBhcnNlRmxvYXQocG9pbnRzW2kgKyAxXSk7XG4gICAgZHggPSBwcmV2WCAtIHg7XG4gICAgZHkgPSBwcmV2WSAtIHk7XG5cbiAgICBpZiAoZHggKiBkeCArIGR5ICogZHkgPiB0b2xlcmFuY2UpIHtcbiAgICAgIHRlbXAucHVzaCh4LCB5KTtcbiAgICAgIHByZXZYID0geDtcbiAgICAgIHByZXZZID0geTtcbiAgICB9XG4gIH1cblxuICB0ZW1wLnB1c2gocGFyc2VGbG9hdChwb2ludHNbbF0pLCBwYXJzZUZsb2F0KHBvaW50c1tsICsgMV0pKTtcbiAgbGFzdCA9IHRlbXAubGVuZ3RoIC0gMjtcbiAgcmVzdWx0ID0gW3RlbXBbMF0sIHRlbXBbMV1dO1xuICBzaW1wbGlmeVN0ZXAodGVtcCwgMCwgbGFzdCwgdG9sZXJhbmNlLCByZXN1bHQpO1xuICByZXN1bHQucHVzaCh0ZW1wW2xhc3RdLCB0ZW1wW2xhc3QgKyAxXSk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIGdldENsb3Nlc3RQcm9ncmVzc09uQmV6aWVyKGl0ZXJhdGlvbnMsIHB4LCBweSwgc3RhcnQsIGVuZCwgc2xpY2VzLCB4MCwgeTAsIHgxLCB5MSwgeDIsIHkyLCB4MywgeTMpIHtcbiAgdmFyIGluYyA9IChlbmQgLSBzdGFydCkgLyBzbGljZXMsXG4gICAgICBiZXN0ID0gMCxcbiAgICAgIHQgPSBzdGFydCxcbiAgICAgIHgsXG4gICAgICB5LFxuICAgICAgZCxcbiAgICAgIGR4LFxuICAgICAgZHksXG4gICAgICBpbnY7XG4gIF9iZXN0RGlzdGFuY2UgPSBfbGFyZ2VOdW07XG5cbiAgd2hpbGUgKHQgPD0gZW5kKSB7XG4gICAgaW52ID0gMSAtIHQ7XG4gICAgeCA9IGludiAqIGludiAqIGludiAqIHgwICsgMyAqIGludiAqIGludiAqIHQgKiB4MSArIDMgKiBpbnYgKiB0ICogdCAqIHgyICsgdCAqIHQgKiB0ICogeDM7XG4gICAgeSA9IGludiAqIGludiAqIGludiAqIHkwICsgMyAqIGludiAqIGludiAqIHQgKiB5MSArIDMgKiBpbnYgKiB0ICogdCAqIHkyICsgdCAqIHQgKiB0ICogeTM7XG4gICAgZHggPSB4IC0gcHg7XG4gICAgZHkgPSB5IC0gcHk7XG4gICAgZCA9IGR4ICogZHggKyBkeSAqIGR5O1xuXG4gICAgaWYgKGQgPCBfYmVzdERpc3RhbmNlKSB7XG4gICAgICBfYmVzdERpc3RhbmNlID0gZDtcbiAgICAgIGJlc3QgPSB0O1xuICAgIH1cblxuICAgIHQgKz0gaW5jO1xuICB9XG5cbiAgcmV0dXJuIGl0ZXJhdGlvbnMgPiAxID8gZ2V0Q2xvc2VzdFByb2dyZXNzT25CZXppZXIoaXRlcmF0aW9ucyAtIDEsIHB4LCBweSwgTWF0aC5tYXgoYmVzdCAtIGluYywgMCksIE1hdGgubWluKGJlc3QgKyBpbmMsIDEpLCBzbGljZXMsIHgwLCB5MCwgeDEsIHkxLCB4MiwgeTIsIHgzLCB5MykgOiBiZXN0O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0Q2xvc2VzdERhdGEocmF3UGF0aCwgeCwgeSwgc2xpY2VzKSB7XG4gIC8vcmV0dXJucyBhbiBvYmplY3Qgd2l0aCB0aGUgY2xvc2VzdCBqLCBpLCBhbmQgdCAoaiBpcyB0aGUgc2VnbWVudCBpbmRleCwgaSBpcyB0aGUgaW5kZXggb2YgdGhlIHBvaW50IGluIHRoYXQgc2VnbWVudCwgYW5kIHQgaXMgdGhlIHRpbWUvcHJvZ3Jlc3MgYWxvbmcgdGhhdCBiZXppZXIpXG4gIHZhciBjbG9zZXN0ID0ge1xuICAgIGo6IDAsXG4gICAgaTogMCxcbiAgICB0OiAwXG4gIH0sXG4gICAgICBiZXN0RGlzdGFuY2UgPSBfbGFyZ2VOdW0sXG4gICAgICBpLFxuICAgICAgaixcbiAgICAgIHQsXG4gICAgICBzZWdtZW50O1xuXG4gIGZvciAoaiA9IDA7IGogPCByYXdQYXRoLmxlbmd0aDsgaisrKSB7XG4gICAgc2VnbWVudCA9IHJhd1BhdGhbal07XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgc2VnbWVudC5sZW5ndGg7IGkgKz0gNikge1xuICAgICAgdCA9IGdldENsb3Nlc3RQcm9ncmVzc09uQmV6aWVyKDEsIHgsIHksIDAsIDEsIHNsaWNlcyB8fCAyMCwgc2VnbWVudFtpXSwgc2VnbWVudFtpICsgMV0sIHNlZ21lbnRbaSArIDJdLCBzZWdtZW50W2kgKyAzXSwgc2VnbWVudFtpICsgNF0sIHNlZ21lbnRbaSArIDVdLCBzZWdtZW50W2kgKyA2XSwgc2VnbWVudFtpICsgN10pO1xuXG4gICAgICBpZiAoYmVzdERpc3RhbmNlID4gX2Jlc3REaXN0YW5jZSkge1xuICAgICAgICBiZXN0RGlzdGFuY2UgPSBfYmVzdERpc3RhbmNlO1xuICAgICAgICBjbG9zZXN0LmogPSBqO1xuICAgICAgICBjbG9zZXN0LmkgPSBpO1xuICAgICAgICBjbG9zZXN0LnQgPSB0O1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBjbG9zZXN0O1xufSAvL3N1YmRpdmlkZSBhIFNlZ21lbnQgY2xvc2VzdCB0byBhIHNwZWNpZmljIHgseSBjb29yZGluYXRlXG5cbmV4cG9ydCBmdW5jdGlvbiBzdWJkaXZpZGVTZWdtZW50TmVhcih4LCB5LCBzZWdtZW50LCBzbGljZXMsIGl0ZXJhdGlvbnMpIHtcbiAgdmFyIGwgPSBzZWdtZW50Lmxlbmd0aCxcbiAgICAgIGJlc3REaXN0YW5jZSA9IF9sYXJnZU51bSxcbiAgICAgIGJlc3RUID0gMCxcbiAgICAgIGJlc3RTZWdtZW50SW5kZXggPSAwLFxuICAgICAgdCxcbiAgICAgIGk7XG4gIHNsaWNlcyA9IHNsaWNlcyB8fCAyMDtcbiAgaXRlcmF0aW9ucyA9IGl0ZXJhdGlvbnMgfHwgMztcblxuICBmb3IgKGkgPSAwOyBpIDwgbDsgaSArPSA2KSB7XG4gICAgdCA9IGdldENsb3Nlc3RQcm9ncmVzc09uQmV6aWVyKDEsIHgsIHksIDAsIDEsIHNsaWNlcywgc2VnbWVudFtpXSwgc2VnbWVudFtpICsgMV0sIHNlZ21lbnRbaSArIDJdLCBzZWdtZW50W2kgKyAzXSwgc2VnbWVudFtpICsgNF0sIHNlZ21lbnRbaSArIDVdLCBzZWdtZW50W2kgKyA2XSwgc2VnbWVudFtpICsgN10pO1xuXG4gICAgaWYgKGJlc3REaXN0YW5jZSA+IF9iZXN0RGlzdGFuY2UpIHtcbiAgICAgIGJlc3REaXN0YW5jZSA9IF9iZXN0RGlzdGFuY2U7XG4gICAgICBiZXN0VCA9IHQ7XG4gICAgICBiZXN0U2VnbWVudEluZGV4ID0gaTtcbiAgICB9XG4gIH1cblxuICB0ID0gZ2V0Q2xvc2VzdFByb2dyZXNzT25CZXppZXIoaXRlcmF0aW9ucywgeCwgeSwgYmVzdFQgLSAwLjA1LCBiZXN0VCArIDAuMDUsIHNsaWNlcywgc2VnbWVudFtiZXN0U2VnbWVudEluZGV4XSwgc2VnbWVudFtiZXN0U2VnbWVudEluZGV4ICsgMV0sIHNlZ21lbnRbYmVzdFNlZ21lbnRJbmRleCArIDJdLCBzZWdtZW50W2Jlc3RTZWdtZW50SW5kZXggKyAzXSwgc2VnbWVudFtiZXN0U2VnbWVudEluZGV4ICsgNF0sIHNlZ21lbnRbYmVzdFNlZ21lbnRJbmRleCArIDVdLCBzZWdtZW50W2Jlc3RTZWdtZW50SW5kZXggKyA2XSwgc2VnbWVudFtiZXN0U2VnbWVudEluZGV4ICsgN10pO1xuICBzdWJkaXZpZGVTZWdtZW50KHNlZ21lbnQsIGJlc3RTZWdtZW50SW5kZXgsIHQpO1xuICByZXR1cm4gYmVzdFNlZ21lbnRJbmRleCArIDY7XG59XG4vKlxuVGFrZXMgYW55IG9mIHRoZSBmb2xsb3dpbmcgYW5kIGNvbnZlcnRzIGl0IHRvIGFuIGFsbCBDdWJpYyBCZXppZXIgU1ZHIGRhdGEgc3RyaW5nOlxuLSBBIDxwYXRoPiBkYXRhIHN0cmluZyBsaWtlIFwiTTAsMCBMMiw0IHYyMCwxNSBIMTAwXCJcbi0gQSBSYXdQYXRoLCBsaWtlIFtbeCwgeSwgeCwgeSwgeCwgeSwgeCwgeV1bW3gsIHksIHgsIHksIHgsIHksIHgsIHldXVxuLSBBIFNlZ21lbnQsIGxpa2UgW3gsIHksIHgsIHksIHgsIHksIHgsIHldXG5cbk5vdGU6IGFsbCBudW1iZXJzIGFyZSByb3VuZGVkIGRvd24gdG8gdGhlIGNsb3Nlc3QgMC4wMDEgdG8gbWluaW1pemUgbWVtb3J5LCBtYXhpbWl6ZSBzcGVlZCwgYW5kIGF2b2lkIG9kZCBudW1iZXJzIGxpa2UgMWUtMTNcbiovXG5cbmV4cG9ydCBmdW5jdGlvbiByYXdQYXRoVG9TdHJpbmcocmF3UGF0aCkge1xuICBpZiAoX2lzTnVtYmVyKHJhd1BhdGhbMF0pKSB7XG4gICAgLy9pbiBjYXNlIGEgc2VnbWVudCBpcyBwYXNzZWQgaW4gaW5zdGVhZFxuICAgIHJhd1BhdGggPSBbcmF3UGF0aF07XG4gIH1cblxuICB2YXIgcmVzdWx0ID0gXCJcIixcbiAgICAgIGwgPSByYXdQYXRoLmxlbmd0aCxcbiAgICAgIHNsLFxuICAgICAgcyxcbiAgICAgIGksXG4gICAgICBzZWdtZW50O1xuXG4gIGZvciAocyA9IDA7IHMgPCBsOyBzKyspIHtcbiAgICBzZWdtZW50ID0gcmF3UGF0aFtzXTtcbiAgICByZXN1bHQgKz0gXCJNXCIgKyBfcm91bmQoc2VnbWVudFswXSkgKyBcIixcIiArIF9yb3VuZChzZWdtZW50WzFdKSArIFwiIENcIjtcbiAgICBzbCA9IHNlZ21lbnQubGVuZ3RoO1xuXG4gICAgZm9yIChpID0gMjsgaSA8IHNsOyBpKyspIHtcbiAgICAgIHJlc3VsdCArPSBfcm91bmQoc2VnbWVudFtpKytdKSArIFwiLFwiICsgX3JvdW5kKHNlZ21lbnRbaSsrXSkgKyBcIiBcIiArIF9yb3VuZChzZWdtZW50W2krK10pICsgXCIsXCIgKyBfcm91bmQoc2VnbWVudFtpKytdKSArIFwiIFwiICsgX3JvdW5kKHNlZ21lbnRbaSsrXSkgKyBcIixcIiArIF9yb3VuZChzZWdtZW50W2ldKSArIFwiIFwiO1xuICAgIH1cblxuICAgIGlmIChzZWdtZW50LmNsb3NlZCkge1xuICAgICAgcmVzdWx0ICs9IFwielwiO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59XG4vKlxuLy8gdGFrZXMgYSBzZWdtZW50IHdpdGggY29vcmRpbmF0ZXMgW3gsIHksIHgsIHksIC4uLl0gYW5kIGNvbnZlcnRzIHRoZSBjb250cm9sIHBvaW50cyBpbnRvIGFuZ2xlcyBhbmQgbGVuZ3RocyBbeCwgeSwgYW5nbGUsIGxlbmd0aCwgYW5nbGUsIGxlbmd0aCwgeCwgeSwgYW5nbGUsIGxlbmd0aCwgLi4uXSBzbyB0aGF0IGl0IGFuaW1hdGVzIG1vcmUgY2xlYW5seSBhbmQgYXZvaWRzIG9kZCBicmVha3Mva2lua3MuIEZvciBleGFtcGxlLCBpZiB5b3UgYW5pbWF0ZSBmcm9tIDEgbydjbG9jayB0byA2IG8nY2xvY2ssIGl0J2QganVzdCBnbyBkaXJlY3RseS9saW5lYXJseSByYXRoZXIgdGhhbiBhcm91bmQuIFNvIHRoZSBsZW5ndGggd291bGQgYmUgdmVyeSBzaG9ydCBpbiB0aGUgbWlkZGxlIG9mIHRoZSB0d2Vlbi5cbmV4cG9ydCBmdW5jdGlvbiBjcENvb3Jkc1RvQW5nbGVzKHNlZ21lbnQsIGNvcHkpIHtcblx0dmFyIHJlc3VsdCA9IGNvcHkgPyBzZWdtZW50LnNsaWNlKDApIDogc2VnbWVudCxcblx0XHR4LCB5LCBpO1xuXHRmb3IgKGkgPSAwOyBpIDwgc2VnbWVudC5sZW5ndGg7IGkrPTYpIHtcblx0XHR4ID0gc2VnbWVudFtpKzJdIC0gc2VnbWVudFtpXTtcblx0XHR5ID0gc2VnbWVudFtpKzNdIC0gc2VnbWVudFtpKzFdO1xuXHRcdHJlc3VsdFtpKzJdID0gTWF0aC5hdGFuMih5LCB4KTtcblx0XHRyZXN1bHRbaSszXSA9IE1hdGguc3FydCh4ICogeCArIHkgKiB5KTtcblx0XHR4ID0gc2VnbWVudFtpKzZdIC0gc2VnbWVudFtpKzRdO1xuXHRcdHkgPSBzZWdtZW50W2krN10gLSBzZWdtZW50W2krNV07XG5cdFx0cmVzdWx0W2krNF0gPSBNYXRoLmF0YW4yKHksIHgpO1xuXHRcdHJlc3VsdFtpKzVdID0gTWF0aC5zcXJ0KHggKiB4ICsgeSAqIHkpO1xuXHR9XG5cdHJldHVybiByZXN1bHQ7XG59XG5cbi8vIHRha2VzIGEgc2VnbWVudCB0aGF0IHdhcyBjb252ZXJ0ZWQgd2l0aCBjcENvb3Jkc1RvQW5nbGVzKCkgdG8gaGF2ZSBhbmdsZXMgYW5kIGxlbmd0aHMgaW5zdGVhZCBvZiBjb29yZGluYXRlcyBmb3IgdGhlIGNvbnRyb2wgcG9pbnRzLCBhbmQgY29udmVydHMgaXQgQkFDSyBpbnRvIGNvb3JkaW5hdGVzLlxuZXhwb3J0IGZ1bmN0aW9uIGNwQW5nbGVzVG9Db29yZHMoc2VnbWVudCwgY29weSkge1xuXHR2YXIgcmVzdWx0ID0gY29weSA/IHNlZ21lbnQuc2xpY2UoMCkgOiBzZWdtZW50LFxuXHRcdGxlbmd0aCA9IHNlZ21lbnQubGVuZ3RoLFxuXHRcdHJuZCA9IDEwMDAsXG5cdFx0YW5nbGUsIGwsIGksIGo7XG5cdGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7IGkrPTYpIHtcblx0XHRhbmdsZSA9IHNlZ21lbnRbaSsyXTtcblx0XHRsID0gc2VnbWVudFtpKzNdOyAvL2xlbmd0aFxuXHRcdHJlc3VsdFtpKzJdID0gKCgoc2VnbWVudFtpXSArIE1hdGguY29zKGFuZ2xlKSAqIGwpICogcm5kKSB8IDApIC8gcm5kO1xuXHRcdHJlc3VsdFtpKzNdID0gKCgoc2VnbWVudFtpKzFdICsgTWF0aC5zaW4oYW5nbGUpICogbCkgKiBybmQpIHwgMCkgLyBybmQ7XG5cdFx0YW5nbGUgPSBzZWdtZW50W2krNF07XG5cdFx0bCA9IHNlZ21lbnRbaSs1XTsgLy9sZW5ndGhcblx0XHRyZXN1bHRbaSs0XSA9ICgoKHNlZ21lbnRbaSs2XSAtIE1hdGguY29zKGFuZ2xlKSAqIGwpICogcm5kKSB8IDApIC8gcm5kO1xuXHRcdHJlc3VsdFtpKzVdID0gKCgoc2VnbWVudFtpKzddIC0gTWF0aC5zaW4oYW5nbGUpICogbCkgKiBybmQpIHwgMCkgLyBybmQ7XG5cdH1cblx0cmV0dXJuIHJlc3VsdDtcbn1cblxuLy9hZGRzIGFuIFwiaXNTbW9vdGhcIiBhcnJheSB0byBlYWNoIHNlZ21lbnQgYW5kIHBvcHVsYXRlcyBpdCB3aXRoIGEgYm9vbGVhbiB2YWx1ZSBpbmRpY2F0aW5nIHdoZXRoZXIgb3Igbm90IGl0J3Mgc21vb3RoICh0aGUgY29udHJvbCBwb2ludHMgaGF2ZSBiYXNpY2FsbHkgdGhlIHNhbWUgc2xvcGUpLiBGb3IgYW55IHNtb290aCBjb250cm9sIHBvaW50cywgaXQgY29udmVydHMgdGhlIGNvb3JkaW5hdGVzIGludG8gYW5nbGUgKHgsIGluIHJhZGlhbnMpIGFuZCBsZW5ndGggKHkpIGFuZCBwdXRzIHRoZW0gaW50byB0aGUgc2FtZSBpbmRleCB2YWx1ZSBpbiBhIHNtb290aERhdGEgYXJyYXkuXG5leHBvcnQgZnVuY3Rpb24gcG9wdWxhdGVTbW9vdGhEYXRhKHJhd1BhdGgpIHtcblx0bGV0IGogPSByYXdQYXRoLmxlbmd0aCxcblx0XHRzbW9vdGgsIHNlZ21lbnQsIHgsIHksIHgyLCB5MiwgaSwgbCwgYSwgYTIsIGlzU21vb3RoLCBzbW9vdGhEYXRhO1xuXHR3aGlsZSAoLS1qID4gLTEpIHtcblx0XHRzZWdtZW50ID0gcmF3UGF0aFtqXTtcblx0XHRpc1Ntb290aCA9IHNlZ21lbnQuaXNTbW9vdGggPSBzZWdtZW50LmlzU21vb3RoIHx8IFswLCAwLCAwLCAwXTtcblx0XHRzbW9vdGhEYXRhID0gc2VnbWVudC5zbW9vdGhEYXRhID0gc2VnbWVudC5zbW9vdGhEYXRhIHx8IFswLCAwLCAwLCAwXTtcblx0XHRpc1Ntb290aC5sZW5ndGggPSA0O1xuXHRcdGwgPSBzZWdtZW50Lmxlbmd0aCAtIDI7XG5cdFx0Zm9yIChpID0gNjsgaSA8IGw7IGkgKz0gNikge1xuXHRcdFx0eCA9IHNlZ21lbnRbaV0gLSBzZWdtZW50W2kgLSAyXTtcblx0XHRcdHkgPSBzZWdtZW50W2kgKyAxXSAtIHNlZ21lbnRbaSAtIDFdO1xuXHRcdFx0eDIgPSBzZWdtZW50W2kgKyAyXSAtIHNlZ21lbnRbaV07XG5cdFx0XHR5MiA9IHNlZ21lbnRbaSArIDNdIC0gc2VnbWVudFtpICsgMV07XG5cdFx0XHRhID0gX2F0YW4yKHksIHgpO1xuXHRcdFx0YTIgPSBfYXRhbjIoeTIsIHgyKTtcblx0XHRcdHNtb290aCA9IChNYXRoLmFicyhhIC0gYTIpIDwgMC4wOSk7XG5cdFx0XHRpZiAoc21vb3RoKSB7XG5cdFx0XHRcdHNtb290aERhdGFbaSAtIDJdID0gYTtcblx0XHRcdFx0c21vb3RoRGF0YVtpICsgMl0gPSBhMjtcblx0XHRcdFx0c21vb3RoRGF0YVtpIC0gMV0gPSBfc3FydCh4ICogeCArIHkgKiB5KTtcblx0XHRcdFx0c21vb3RoRGF0YVtpICsgM10gPSBfc3FydCh4MiAqIHgyICsgeTIgKiB5Mik7XG5cdFx0XHR9XG5cdFx0XHRpc1Ntb290aC5wdXNoKHNtb290aCwgc21vb3RoLCAwLCAwLCBzbW9vdGgsIHNtb290aCk7XG5cdFx0fVxuXHRcdC8vaWYgdGhlIGZpcnN0IGFuZCBsYXN0IHBvaW50cyBhcmUgaWRlbnRpY2FsLCBjaGVjayB0byBzZWUgaWYgdGhlcmUncyBhIHNtb290aCB0cmFuc2l0aW9uLiBXZSBtdXN0IGhhbmRsZSB0aGlzIGEgYml0IGRpZmZlcmVudGx5IGR1ZSB0byB0aGVpciBwb3NpdGlvbnMgaW4gdGhlIGFycmF5LlxuXHRcdGlmIChzZWdtZW50W2xdID09PSBzZWdtZW50WzBdICYmIHNlZ21lbnRbbCsxXSA9PT0gc2VnbWVudFsxXSkge1xuXHRcdFx0eCA9IHNlZ21lbnRbMF0gLSBzZWdtZW50W2wtMl07XG5cdFx0XHR5ID0gc2VnbWVudFsxXSAtIHNlZ21lbnRbbC0xXTtcblx0XHRcdHgyID0gc2VnbWVudFsyXSAtIHNlZ21lbnRbMF07XG5cdFx0XHR5MiA9IHNlZ21lbnRbM10gLSBzZWdtZW50WzFdO1xuXHRcdFx0YSA9IF9hdGFuMih5LCB4KTtcblx0XHRcdGEyID0gX2F0YW4yKHkyLCB4Mik7XG5cdFx0XHRpZiAoTWF0aC5hYnMoYSAtIGEyKSA8IDAuMDkpIHtcblx0XHRcdFx0c21vb3RoRGF0YVtsLTJdID0gYTtcblx0XHRcdFx0c21vb3RoRGF0YVsyXSA9IGEyO1xuXHRcdFx0XHRzbW9vdGhEYXRhW2wtMV0gPSBfc3FydCh4ICogeCArIHkgKiB5KTtcblx0XHRcdFx0c21vb3RoRGF0YVszXSA9IF9zcXJ0KHgyICogeDIgKyB5MiAqIHkyKTtcblx0XHRcdFx0aXNTbW9vdGhbbC0yXSA9IGlzU21vb3RoW2wtMV0gPSB0cnVlOyAvL2Rvbid0IGNoYW5nZSBpbmRleGVzIDIgYW5kIDMgYmVjYXVzZSB3ZSdsbCB0cmlnZ2VyIGV2ZXJ5dGhpbmcgZnJvbSB0aGUgRU5ELCBhbmQgdGhpcyB3aWxsIG9wdGltaXplIGZpbGUgc2l6ZSBhIGJpdC5cblx0XHRcdH1cblx0XHR9XG5cdH1cblx0cmV0dXJuIHJhd1BhdGg7XG59XG5leHBvcnQgZnVuY3Rpb24gcG9pbnRUb1NjcmVlbihzdmdFbGVtZW50LCBwb2ludCkge1xuXHRpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDIpIHsgLy9ieSBkZWZhdWx0LCB0YWtlIHRoZSBmaXJzdCBzZXQgb2YgY29vcmRpbmF0ZXMgaW4gdGhlIHBhdGggYXMgdGhlIHBvaW50XG5cdFx0bGV0IHJhd1BhdGggPSBnZXRSYXdQYXRoKHN2Z0VsZW1lbnQpO1xuXHRcdHBvaW50ID0gc3ZnRWxlbWVudC5vd25lclNWR0VsZW1lbnQuY3JlYXRlU1ZHUG9pbnQoKTtcblx0XHRwb2ludC54ID0gcmF3UGF0aFswXVswXTtcblx0XHRwb2ludC55ID0gcmF3UGF0aFswXVsxXTtcblx0fVxuXHRyZXR1cm4gcG9pbnQubWF0cml4VHJhbnNmb3JtKHN2Z0VsZW1lbnQuZ2V0U2NyZWVuQ1RNKCkpO1xufVxuXG4qLyIsIi8qIVxuICogTW90aW9uUGF0aFBsdWdpbiAzLjEwLjRcbiAqIGh0dHBzOi8vZ3JlZW5zb2NrLmNvbVxuICpcbiAqIEBsaWNlbnNlIENvcHlyaWdodCAyMDA4LTIwMjIsIEdyZWVuU29jay4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFN1YmplY3QgdG8gdGhlIHRlcm1zIGF0IGh0dHBzOi8vZ3JlZW5zb2NrLmNvbS9zdGFuZGFyZC1saWNlbnNlIG9yIGZvclxuICogQ2x1YiBHcmVlblNvY2sgbWVtYmVycywgdGhlIGFncmVlbWVudCBpc3N1ZWQgd2l0aCB0aGF0IG1lbWJlcnNoaXAuXG4gKiBAYXV0aG9yOiBKYWNrIERveWxlLCBqYWNrQGdyZWVuc29jay5jb21cbiovXG5cbi8qIGVzbGludC1kaXNhYmxlICovXG5pbXBvcnQgeyBnZXRSYXdQYXRoLCBjYWNoZVJhd1BhdGhNZWFzdXJlbWVudHMsIGdldFBvc2l0aW9uT25QYXRoLCBwb2ludHNUb1NlZ21lbnQsIGZsYXRQb2ludHNUb1NlZ21lbnQsIHNsaWNlUmF3UGF0aCwgc3RyaW5nVG9SYXdQYXRoLCByYXdQYXRoVG9TdHJpbmcsIHRyYW5zZm9ybVJhd1BhdGgsIGNvbnZlcnRUb1BhdGggYXMgX2NvbnZlcnRUb1BhdGggfSBmcm9tIFwiLi91dGlscy9wYXRocy5qc1wiO1xuaW1wb3J0IHsgZ2V0R2xvYmFsTWF0cml4IH0gZnJvbSBcIi4vdXRpbHMvbWF0cml4LmpzXCI7XG5cbnZhciBfeFByb3BzID0gXCJ4LHRyYW5zbGF0ZVgsbGVmdCxtYXJnaW5MZWZ0LHhQZXJjZW50XCIuc3BsaXQoXCIsXCIpLFxuICAgIF95UHJvcHMgPSBcInksdHJhbnNsYXRlWSx0b3AsbWFyZ2luVG9wLHlQZXJjZW50XCIuc3BsaXQoXCIsXCIpLFxuICAgIF9ERUcyUkFEID0gTWF0aC5QSSAvIDE4MCxcbiAgICBnc2FwLFxuICAgIFByb3BUd2VlbixcbiAgICBfZ2V0VW5pdCxcbiAgICBfdG9BcnJheSxcbiAgICBfZ2V0R1NBUCA9IGZ1bmN0aW9uIF9nZXRHU0FQKCkge1xuICByZXR1cm4gZ3NhcCB8fCB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmIChnc2FwID0gd2luZG93LmdzYXApICYmIGdzYXAucmVnaXN0ZXJQbHVnaW4gJiYgZ3NhcDtcbn0sXG4gICAgX3BvcHVsYXRlU2VnbWVudEZyb21BcnJheSA9IGZ1bmN0aW9uIF9wb3B1bGF0ZVNlZ21lbnRGcm9tQXJyYXkoc2VnbWVudCwgdmFsdWVzLCBwcm9wZXJ0eSwgbW9kZSkge1xuICAvL21vZGU6IDAgPSB4IGJ1dCBkb24ndCBmaWxsIHkgeWV0LCAxID0geSwgMiA9IHggYW5kIGZpbGwgeSB3aXRoIDAuXG4gIHZhciBsID0gdmFsdWVzLmxlbmd0aCxcbiAgICAgIHNpID0gbW9kZSA9PT0gMiA/IDAgOiBtb2RlLFxuICAgICAgaSA9IDAsXG4gICAgICB2O1xuXG4gIGZvciAoOyBpIDwgbDsgaSsrKSB7XG4gICAgc2VnbWVudFtzaV0gPSB2ID0gcGFyc2VGbG9hdCh2YWx1ZXNbaV1bcHJvcGVydHldKTtcbiAgICBtb2RlID09PSAyICYmIChzZWdtZW50W3NpICsgMV0gPSAwKTtcbiAgICBzaSArPSAyO1xuICB9XG5cbiAgcmV0dXJuIHNlZ21lbnQ7XG59LFxuICAgIF9nZXRQcm9wTnVtID0gZnVuY3Rpb24gX2dldFByb3BOdW0odGFyZ2V0LCBwcm9wLCB1bml0KSB7XG4gIHJldHVybiBwYXJzZUZsb2F0KHRhcmdldC5fZ3NhcC5nZXQodGFyZ2V0LCBwcm9wLCB1bml0IHx8IFwicHhcIikpIHx8IDA7XG59LFxuICAgIF9yZWxhdGl2aXplID0gZnVuY3Rpb24gX3JlbGF0aXZpemUoc2VnbWVudCkge1xuICB2YXIgeCA9IHNlZ21lbnRbMF0sXG4gICAgICB5ID0gc2VnbWVudFsxXSxcbiAgICAgIGk7XG5cbiAgZm9yIChpID0gMjsgaSA8IHNlZ21lbnQubGVuZ3RoOyBpICs9IDIpIHtcbiAgICB4ID0gc2VnbWVudFtpXSArPSB4O1xuICAgIHkgPSBzZWdtZW50W2kgKyAxXSArPSB5O1xuICB9XG59LFxuICAgIC8vIGZlZWQgaW4gYW4gYXJyYXkgb2YgcXVhZHJhdGljIGJlemllciBwb2ludHMgbGlrZSBbe3g6IDAsIHk6IDB9LCAuLi5dIGFuZCBpdCdsbCBjb252ZXJ0IGl0IHRvIGN1YmljIGJlemllclxuLy8gX3F1YWRUb0N1YmljID0gcG9pbnRzID0+IHtcbi8vIFx0bGV0IGN1YmljID0gW10sXG4vLyBcdFx0bCA9IHBvaW50cy5sZW5ndGggLSAxLFxuLy8gXHRcdGkgPSAxLFxuLy8gXHRcdGEsIGIsIGM7XG4vLyBcdGZvciAoOyBpIDwgbDsgaSs9Mikge1xuLy8gXHRcdGEgPSBwb2ludHNbaS0xXTtcbi8vIFx0XHRiID0gcG9pbnRzW2ldO1xuLy8gXHRcdGMgPSBwb2ludHNbaSsxXTtcbi8vIFx0XHRjdWJpYy5wdXNoKGEsIHt4OiAoMiAqIGIueCArIGEueCkgLyAzLCB5OiAoMiAqIGIueSArIGEueSkgLyAzfSwge3g6ICgyICogYi54ICsgYy54KSAvIDMsIHk6ICgyICogYi55ICsgYy55KSAvIDN9KTtcbi8vIFx0fVxuLy8gXHRjdWJpYy5wdXNoKHBvaW50c1tsXSk7XG4vLyBcdHJldHVybiBjdWJpYztcbi8vIH0sXG5fc2VnbWVudFRvUmF3UGF0aCA9IGZ1bmN0aW9uIF9zZWdtZW50VG9SYXdQYXRoKHBsdWdpbiwgc2VnbWVudCwgdGFyZ2V0LCB4LCB5LCBzbGljZXIsIHZhcnMsIHVuaXRYLCB1bml0WSkge1xuICBpZiAodmFycy50eXBlID09PSBcImN1YmljXCIpIHtcbiAgICBzZWdtZW50ID0gW3NlZ21lbnRdO1xuICB9IGVsc2Uge1xuICAgIHZhcnMuZnJvbUN1cnJlbnQgIT09IGZhbHNlICYmIHNlZ21lbnQudW5zaGlmdChfZ2V0UHJvcE51bSh0YXJnZXQsIHgsIHVuaXRYKSwgeSA/IF9nZXRQcm9wTnVtKHRhcmdldCwgeSwgdW5pdFkpIDogMCk7XG4gICAgdmFycy5yZWxhdGl2ZSAmJiBfcmVsYXRpdml6ZShzZWdtZW50KTtcbiAgICB2YXIgcG9pbnRGdW5jID0geSA/IHBvaW50c1RvU2VnbWVudCA6IGZsYXRQb2ludHNUb1NlZ21lbnQ7XG4gICAgc2VnbWVudCA9IFtwb2ludEZ1bmMoc2VnbWVudCwgdmFycy5jdXJ2aW5lc3MpXTtcbiAgfVxuXG4gIHNlZ21lbnQgPSBzbGljZXIoX2FsaWduKHNlZ21lbnQsIHRhcmdldCwgdmFycykpO1xuXG4gIF9hZGREaW1lbnNpb25hbFByb3BUd2VlbihwbHVnaW4sIHRhcmdldCwgeCwgc2VnbWVudCwgXCJ4XCIsIHVuaXRYKTtcblxuICB5ICYmIF9hZGREaW1lbnNpb25hbFByb3BUd2VlbihwbHVnaW4sIHRhcmdldCwgeSwgc2VnbWVudCwgXCJ5XCIsIHVuaXRZKTtcbiAgcmV0dXJuIGNhY2hlUmF3UGF0aE1lYXN1cmVtZW50cyhzZWdtZW50LCB2YXJzLnJlc29sdXRpb24gfHwgKHZhcnMuY3VydmluZXNzID09PSAwID8gMjAgOiAxMikpOyAvL3doZW4gY3VydmluZXNzIGlzIDAsIGl0IGNyZWF0ZXMgY29udHJvbCBwb2ludHMgcmlnaHQgb24gdG9wIG9mIHRoZSBhbmNob3JzIHdoaWNoIG1ha2VzIGl0IG1vcmUgc2Vuc2l0aXZlIHRvIHJlc29sdXRpb24sIHRodXMgd2UgY2hhbmdlIHRoZSBkZWZhdWx0IGFjY29yZGluZ2x5LlxufSxcbiAgICBfZW1wdHlGdW5jID0gZnVuY3Rpb24gX2VtcHR5RnVuYyh2KSB7XG4gIHJldHVybiB2O1xufSxcbiAgICBfbnVtRXhwID0gL1stK1xcLl0qXFxkK1xcLj8oPzplLXxlXFwrKT9cXGQqL2csXG4gICAgX29yaWdpblRvUG9pbnQgPSBmdW5jdGlvbiBfb3JpZ2luVG9Qb2ludChlbGVtZW50LCBvcmlnaW4sIHBhcmVudE1hdHJpeCkge1xuICAvLyBvcmlnaW4gaXMgYW4gYXJyYXkgb2Ygbm9ybWFsaXplZCB2YWx1ZXMgKDAtMSkgaW4gcmVsYXRpb24gdG8gdGhlIHdpZHRoL2hlaWdodCwgc28gWzAuNSwgMC41XSB3b3VsZCBiZSB0aGUgY2VudGVyLiBJdCBjYW4gYWxzbyBiZSBcImF1dG9cIiBpbiB3aGljaCBjYXNlIGl0IHdpbGwgYmUgdGhlIHRvcCBsZWZ0IHVubGVzcyBpdCdzIGEgPHBhdGg+LCB3aGVuIGl0IHdpbGwgc3RhcnQgYXQgdGhlIGJlZ2lubmluZyBvZiB0aGUgcGF0aCBpdHNlbGYuXG4gIHZhciBtID0gZ2V0R2xvYmFsTWF0cml4KGVsZW1lbnQpLFxuICAgICAgeCA9IDAsXG4gICAgICB5ID0gMCxcbiAgICAgIHN2ZztcblxuICBpZiAoKGVsZW1lbnQudGFnTmFtZSArIFwiXCIpLnRvTG93ZXJDYXNlKCkgPT09IFwic3ZnXCIpIHtcbiAgICBzdmcgPSBlbGVtZW50LnZpZXdCb3guYmFzZVZhbDtcbiAgICBzdmcud2lkdGggfHwgKHN2ZyA9IHtcbiAgICAgIHdpZHRoOiArZWxlbWVudC5nZXRBdHRyaWJ1dGUoXCJ3aWR0aFwiKSxcbiAgICAgIGhlaWdodDogK2VsZW1lbnQuZ2V0QXR0cmlidXRlKFwiaGVpZ2h0XCIpXG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgc3ZnID0gb3JpZ2luICYmIGVsZW1lbnQuZ2V0QkJveCAmJiBlbGVtZW50LmdldEJCb3goKTtcbiAgfVxuXG4gIGlmIChvcmlnaW4gJiYgb3JpZ2luICE9PSBcImF1dG9cIikge1xuICAgIHggPSBvcmlnaW4ucHVzaCA/IG9yaWdpblswXSAqIChzdmcgPyBzdmcud2lkdGggOiBlbGVtZW50Lm9mZnNldFdpZHRoIHx8IDApIDogb3JpZ2luLng7XG4gICAgeSA9IG9yaWdpbi5wdXNoID8gb3JpZ2luWzFdICogKHN2ZyA/IHN2Zy5oZWlnaHQgOiBlbGVtZW50Lm9mZnNldEhlaWdodCB8fCAwKSA6IG9yaWdpbi55O1xuICB9XG5cbiAgcmV0dXJuIHBhcmVudE1hdHJpeC5hcHBseSh4IHx8IHkgPyBtLmFwcGx5KHtcbiAgICB4OiB4LFxuICAgIHk6IHlcbiAgfSkgOiB7XG4gICAgeDogbS5lLFxuICAgIHk6IG0uZlxuICB9KTtcbn0sXG4gICAgX2dldEFsaWduTWF0cml4ID0gZnVuY3Rpb24gX2dldEFsaWduTWF0cml4KGZyb21FbGVtZW50LCB0b0VsZW1lbnQsIGZyb21PcmlnaW4sIHRvT3JpZ2luKSB7XG4gIHZhciBwYXJlbnRNYXRyaXggPSBnZXRHbG9iYWxNYXRyaXgoZnJvbUVsZW1lbnQucGFyZW50Tm9kZSwgdHJ1ZSwgdHJ1ZSksXG4gICAgICBtID0gcGFyZW50TWF0cml4LmNsb25lKCkubXVsdGlwbHkoZ2V0R2xvYmFsTWF0cml4KHRvRWxlbWVudCkpLFxuICAgICAgZnJvbVBvaW50ID0gX29yaWdpblRvUG9pbnQoZnJvbUVsZW1lbnQsIGZyb21PcmlnaW4sIHBhcmVudE1hdHJpeCksXG4gICAgICBfb3JpZ2luVG9Qb2ludDIgPSBfb3JpZ2luVG9Qb2ludCh0b0VsZW1lbnQsIHRvT3JpZ2luLCBwYXJlbnRNYXRyaXgpLFxuICAgICAgeCA9IF9vcmlnaW5Ub1BvaW50Mi54LFxuICAgICAgeSA9IF9vcmlnaW5Ub1BvaW50Mi55LFxuICAgICAgcDtcblxuICBtLmUgPSBtLmYgPSAwO1xuXG4gIGlmICh0b09yaWdpbiA9PT0gXCJhdXRvXCIgJiYgdG9FbGVtZW50LmdldFRvdGFsTGVuZ3RoICYmIHRvRWxlbWVudC50YWdOYW1lLnRvTG93ZXJDYXNlKCkgPT09IFwicGF0aFwiKSB7XG4gICAgcCA9IHRvRWxlbWVudC5nZXRBdHRyaWJ1dGUoXCJkXCIpLm1hdGNoKF9udW1FeHApIHx8IFtdO1xuICAgIHAgPSBtLmFwcGx5KHtcbiAgICAgIHg6ICtwWzBdLFxuICAgICAgeTogK3BbMV1cbiAgICB9KTtcbiAgICB4ICs9IHAueDtcbiAgICB5ICs9IHAueTtcbiAgfVxuXG4gIGlmIChwIHx8IHRvRWxlbWVudC5nZXRCQm94ICYmIGZyb21FbGVtZW50LmdldEJCb3ggJiYgdG9FbGVtZW50Lm93bmVyU1ZHRWxlbWVudCA9PT0gZnJvbUVsZW1lbnQub3duZXJTVkdFbGVtZW50KSB7XG4gICAgcCA9IG0uYXBwbHkodG9FbGVtZW50LmdldEJCb3goKSk7XG4gICAgeCAtPSBwLng7XG4gICAgeSAtPSBwLnk7XG4gIH1cblxuICBtLmUgPSB4IC0gZnJvbVBvaW50Lng7XG4gIG0uZiA9IHkgLSBmcm9tUG9pbnQueTtcbiAgcmV0dXJuIG07XG59LFxuICAgIF9hbGlnbiA9IGZ1bmN0aW9uIF9hbGlnbihyYXdQYXRoLCB0YXJnZXQsIF9yZWYpIHtcbiAgdmFyIGFsaWduID0gX3JlZi5hbGlnbixcbiAgICAgIG1hdHJpeCA9IF9yZWYubWF0cml4LFxuICAgICAgb2Zmc2V0WCA9IF9yZWYub2Zmc2V0WCxcbiAgICAgIG9mZnNldFkgPSBfcmVmLm9mZnNldFksXG4gICAgICBhbGlnbk9yaWdpbiA9IF9yZWYuYWxpZ25PcmlnaW47XG5cbiAgdmFyIHggPSByYXdQYXRoWzBdWzBdLFxuICAgICAgeSA9IHJhd1BhdGhbMF1bMV0sXG4gICAgICBjdXJYID0gX2dldFByb3BOdW0odGFyZ2V0LCBcInhcIiksXG4gICAgICBjdXJZID0gX2dldFByb3BOdW0odGFyZ2V0LCBcInlcIiksXG4gICAgICBhbGlnblRhcmdldCxcbiAgICAgIG0sXG4gICAgICBwO1xuXG4gIGlmICghcmF3UGF0aCB8fCAhcmF3UGF0aC5sZW5ndGgpIHtcbiAgICByZXR1cm4gZ2V0UmF3UGF0aChcIk0wLDBMMCwwXCIpO1xuICB9XG5cbiAgaWYgKGFsaWduKSB7XG4gICAgaWYgKGFsaWduID09PSBcInNlbGZcIiB8fCAoYWxpZ25UYXJnZXQgPSBfdG9BcnJheShhbGlnbilbMF0gfHwgdGFyZ2V0KSA9PT0gdGFyZ2V0KSB7XG4gICAgICB0cmFuc2Zvcm1SYXdQYXRoKHJhd1BhdGgsIDEsIDAsIDAsIDEsIGN1clggLSB4LCBjdXJZIC0geSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChhbGlnbk9yaWdpbiAmJiBhbGlnbk9yaWdpblsyXSAhPT0gZmFsc2UpIHtcbiAgICAgICAgZ3NhcC5zZXQodGFyZ2V0LCB7XG4gICAgICAgICAgdHJhbnNmb3JtT3JpZ2luOiBhbGlnbk9yaWdpblswXSAqIDEwMCArIFwiJSBcIiArIGFsaWduT3JpZ2luWzFdICogMTAwICsgXCIlXCJcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhbGlnbk9yaWdpbiA9IFtfZ2V0UHJvcE51bSh0YXJnZXQsIFwieFBlcmNlbnRcIikgLyAtMTAwLCBfZ2V0UHJvcE51bSh0YXJnZXQsIFwieVBlcmNlbnRcIikgLyAtMTAwXTtcbiAgICAgIH1cblxuICAgICAgbSA9IF9nZXRBbGlnbk1hdHJpeCh0YXJnZXQsIGFsaWduVGFyZ2V0LCBhbGlnbk9yaWdpbiwgXCJhdXRvXCIpO1xuICAgICAgcCA9IG0uYXBwbHkoe1xuICAgICAgICB4OiB4LFxuICAgICAgICB5OiB5XG4gICAgICB9KTtcbiAgICAgIHRyYW5zZm9ybVJhd1BhdGgocmF3UGF0aCwgbS5hLCBtLmIsIG0uYywgbS5kLCBjdXJYICsgbS5lIC0gKHAueCAtIG0uZSksIGN1clkgKyBtLmYgLSAocC55IC0gbS5mKSk7XG4gICAgfVxuICB9XG5cbiAgaWYgKG1hdHJpeCkge1xuICAgIHRyYW5zZm9ybVJhd1BhdGgocmF3UGF0aCwgbWF0cml4LmEsIG1hdHJpeC5iLCBtYXRyaXguYywgbWF0cml4LmQsIG1hdHJpeC5lLCBtYXRyaXguZik7XG4gIH0gZWxzZSBpZiAob2Zmc2V0WCB8fCBvZmZzZXRZKSB7XG4gICAgdHJhbnNmb3JtUmF3UGF0aChyYXdQYXRoLCAxLCAwLCAwLCAxLCBvZmZzZXRYIHx8IDAsIG9mZnNldFkgfHwgMCk7XG4gIH1cblxuICByZXR1cm4gcmF3UGF0aDtcbn0sXG4gICAgX2FkZERpbWVuc2lvbmFsUHJvcFR3ZWVuID0gZnVuY3Rpb24gX2FkZERpbWVuc2lvbmFsUHJvcFR3ZWVuKHBsdWdpbiwgdGFyZ2V0LCBwcm9wZXJ0eSwgcmF3UGF0aCwgcGF0aFByb3BlcnR5LCBmb3JjZVVuaXQpIHtcbiAgdmFyIGNhY2hlID0gdGFyZ2V0Ll9nc2FwLFxuICAgICAgaGFybmVzcyA9IGNhY2hlLmhhcm5lc3MsXG4gICAgICBhbGlhcyA9IGhhcm5lc3MgJiYgaGFybmVzcy5hbGlhc2VzICYmIGhhcm5lc3MuYWxpYXNlc1twcm9wZXJ0eV0sXG4gICAgICBwcm9wID0gYWxpYXMgJiYgYWxpYXMuaW5kZXhPZihcIixcIikgPCAwID8gYWxpYXMgOiBwcm9wZXJ0eSxcbiAgICAgIHB0ID0gcGx1Z2luLl9wdCA9IG5ldyBQcm9wVHdlZW4ocGx1Z2luLl9wdCwgdGFyZ2V0LCBwcm9wLCAwLCAwLCBfZW1wdHlGdW5jLCAwLCBjYWNoZS5zZXQodGFyZ2V0LCBwcm9wLCBwbHVnaW4pKTtcbiAgcHQudSA9IF9nZXRVbml0KGNhY2hlLmdldCh0YXJnZXQsIHByb3AsIGZvcmNlVW5pdCkpIHx8IDA7XG4gIHB0LnBhdGggPSByYXdQYXRoO1xuICBwdC5wcCA9IHBhdGhQcm9wZXJ0eTtcblxuICBwbHVnaW4uX3Byb3BzLnB1c2gocHJvcCk7XG59LFxuICAgIF9zbGljZU1vZGlmaWVyID0gZnVuY3Rpb24gX3NsaWNlTW9kaWZpZXIoc3RhcnQsIGVuZCkge1xuICByZXR1cm4gZnVuY3Rpb24gKHJhd1BhdGgpIHtcbiAgICByZXR1cm4gc3RhcnQgfHwgZW5kICE9PSAxID8gc2xpY2VSYXdQYXRoKHJhd1BhdGgsIHN0YXJ0LCBlbmQpIDogcmF3UGF0aDtcbiAgfTtcbn07XG5cbmV4cG9ydCB2YXIgTW90aW9uUGF0aFBsdWdpbiA9IHtcbiAgdmVyc2lvbjogXCIzLjEwLjRcIixcbiAgbmFtZTogXCJtb3Rpb25QYXRoXCIsXG4gIHJlZ2lzdGVyOiBmdW5jdGlvbiByZWdpc3Rlcihjb3JlLCBQbHVnaW4sIHByb3BUd2Vlbikge1xuICAgIGdzYXAgPSBjb3JlO1xuICAgIF9nZXRVbml0ID0gZ3NhcC51dGlscy5nZXRVbml0O1xuICAgIF90b0FycmF5ID0gZ3NhcC51dGlscy50b0FycmF5O1xuICAgIFByb3BUd2VlbiA9IHByb3BUd2VlbjtcbiAgfSxcbiAgaW5pdDogZnVuY3Rpb24gaW5pdCh0YXJnZXQsIHZhcnMpIHtcbiAgICBpZiAoIWdzYXApIHtcbiAgICAgIGNvbnNvbGUud2FybihcIlBsZWFzZSBnc2FwLnJlZ2lzdGVyUGx1Z2luKE1vdGlvblBhdGhQbHVnaW4pXCIpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGlmICghKHR5cGVvZiB2YXJzID09PSBcIm9iamVjdFwiICYmICF2YXJzLnN0eWxlKSB8fCAhdmFycy5wYXRoKSB7XG4gICAgICB2YXJzID0ge1xuICAgICAgICBwYXRoOiB2YXJzXG4gICAgICB9O1xuICAgIH1cblxuICAgIHZhciByYXdQYXRocyA9IFtdLFxuICAgICAgICBfdmFycyA9IHZhcnMsXG4gICAgICAgIHBhdGggPSBfdmFycy5wYXRoLFxuICAgICAgICBhdXRvUm90YXRlID0gX3ZhcnMuYXV0b1JvdGF0ZSxcbiAgICAgICAgdW5pdFggPSBfdmFycy51bml0WCxcbiAgICAgICAgdW5pdFkgPSBfdmFycy51bml0WSxcbiAgICAgICAgeCA9IF92YXJzLngsXG4gICAgICAgIHkgPSBfdmFycy55LFxuICAgICAgICBmaXJzdE9iaiA9IHBhdGhbMF0sXG4gICAgICAgIHNsaWNlciA9IF9zbGljZU1vZGlmaWVyKHZhcnMuc3RhcnQsIFwiZW5kXCIgaW4gdmFycyA/IHZhcnMuZW5kIDogMSksXG4gICAgICAgIHJhd1BhdGgsXG4gICAgICAgIHA7XG5cbiAgICB0aGlzLnJhd1BhdGhzID0gcmF3UGF0aHM7XG4gICAgdGhpcy50YXJnZXQgPSB0YXJnZXQ7XG5cbiAgICBpZiAodGhpcy5yb3RhdGUgPSBhdXRvUm90YXRlIHx8IGF1dG9Sb3RhdGUgPT09IDApIHtcbiAgICAgIC8vZ2V0IHRoZSByb3RhdGlvbmFsIGRhdGEgRklSU1Qgc28gdGhhdCB0aGUgc2V0VHJhbnNmb3JtKCkgbWV0aG9kIGlzIGNhbGxlZCBpbiB0aGUgY29ycmVjdCBvcmRlciBpbiB0aGUgcmVuZGVyKCkgbG9vcCAtIHJvdGF0aW9uIGdldHMgc2V0IGxhc3QuXG4gICAgICB0aGlzLnJPZmZzZXQgPSBwYXJzZUZsb2F0KGF1dG9Sb3RhdGUpIHx8IDA7XG4gICAgICB0aGlzLnJhZGlhbnMgPSAhIXZhcnMudXNlUmFkaWFucztcbiAgICAgIHRoaXMuclByb3AgPSB2YXJzLnJvdGF0aW9uIHx8IFwicm90YXRpb25cIjsgLy8gcm90YXRpb24gcHJvcGVydHlcblxuICAgICAgdGhpcy5yU2V0ID0gdGFyZ2V0Ll9nc2FwLnNldCh0YXJnZXQsIHRoaXMuclByb3AsIHRoaXMpOyAvLyByb3RhdGlvbiBzZXR0ZXJcblxuICAgICAgdGhpcy5ydSA9IF9nZXRVbml0KHRhcmdldC5fZ3NhcC5nZXQodGFyZ2V0LCB0aGlzLnJQcm9wKSkgfHwgMDsgLy8gcm90YXRpb24gdW5pdHNcbiAgICB9XG5cbiAgICBpZiAoQXJyYXkuaXNBcnJheShwYXRoKSAmJiAhKFwiY2xvc2VkXCIgaW4gcGF0aCkgJiYgdHlwZW9mIGZpcnN0T2JqICE9PSBcIm51bWJlclwiKSB7XG4gICAgICBmb3IgKHAgaW4gZmlyc3RPYmopIHtcbiAgICAgICAgaWYgKCF4ICYmIH5feFByb3BzLmluZGV4T2YocCkpIHtcbiAgICAgICAgICB4ID0gcDtcbiAgICAgICAgfSBlbHNlIGlmICgheSAmJiB+X3lQcm9wcy5pbmRleE9mKHApKSB7XG4gICAgICAgICAgeSA9IHA7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHggJiYgeSkge1xuICAgICAgICAvL2NvcnJlbGF0ZWQgdmFsdWVzXG4gICAgICAgIHJhd1BhdGhzLnB1c2goX3NlZ21lbnRUb1Jhd1BhdGgodGhpcywgX3BvcHVsYXRlU2VnbWVudEZyb21BcnJheShfcG9wdWxhdGVTZWdtZW50RnJvbUFycmF5KFtdLCBwYXRoLCB4LCAwKSwgcGF0aCwgeSwgMSksIHRhcmdldCwgeCwgeSwgc2xpY2VyLCB2YXJzLCB1bml0WCB8fCBfZ2V0VW5pdChwYXRoWzBdW3hdKSwgdW5pdFkgfHwgX2dldFVuaXQocGF0aFswXVt5XSkpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHggPSB5ID0gMDtcbiAgICAgIH1cblxuICAgICAgZm9yIChwIGluIGZpcnN0T2JqKSB7XG4gICAgICAgIHAgIT09IHggJiYgcCAhPT0geSAmJiByYXdQYXRocy5wdXNoKF9zZWdtZW50VG9SYXdQYXRoKHRoaXMsIF9wb3B1bGF0ZVNlZ21lbnRGcm9tQXJyYXkoW10sIHBhdGgsIHAsIDIpLCB0YXJnZXQsIHAsIDAsIHNsaWNlciwgdmFycywgX2dldFVuaXQocGF0aFswXVtwXSkpKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcmF3UGF0aCA9IHNsaWNlcihfYWxpZ24oZ2V0UmF3UGF0aCh2YXJzLnBhdGgpLCB0YXJnZXQsIHZhcnMpKTtcbiAgICAgIGNhY2hlUmF3UGF0aE1lYXN1cmVtZW50cyhyYXdQYXRoLCB2YXJzLnJlc29sdXRpb24pO1xuICAgICAgcmF3UGF0aHMucHVzaChyYXdQYXRoKTtcblxuICAgICAgX2FkZERpbWVuc2lvbmFsUHJvcFR3ZWVuKHRoaXMsIHRhcmdldCwgdmFycy54IHx8IFwieFwiLCByYXdQYXRoLCBcInhcIiwgdmFycy51bml0WCB8fCBcInB4XCIpO1xuXG4gICAgICBfYWRkRGltZW5zaW9uYWxQcm9wVHdlZW4odGhpcywgdGFyZ2V0LCB2YXJzLnkgfHwgXCJ5XCIsIHJhd1BhdGgsIFwieVwiLCB2YXJzLnVuaXRZIHx8IFwicHhcIik7XG4gICAgfVxuICB9LFxuICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlcihyYXRpbywgZGF0YSkge1xuICAgIHZhciByYXdQYXRocyA9IGRhdGEucmF3UGF0aHMsXG4gICAgICAgIGkgPSByYXdQYXRocy5sZW5ndGgsXG4gICAgICAgIHB0ID0gZGF0YS5fcHQ7XG5cbiAgICBpZiAocmF0aW8gPiAxKSB7XG4gICAgICByYXRpbyA9IDE7XG4gICAgfSBlbHNlIGlmIChyYXRpbyA8IDApIHtcbiAgICAgIHJhdGlvID0gMDtcbiAgICB9XG5cbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICBnZXRQb3NpdGlvbk9uUGF0aChyYXdQYXRoc1tpXSwgcmF0aW8sICFpICYmIGRhdGEucm90YXRlLCByYXdQYXRoc1tpXSk7XG4gICAgfVxuXG4gICAgd2hpbGUgKHB0KSB7XG4gICAgICBwdC5zZXQocHQudCwgcHQucCwgcHQucGF0aFtwdC5wcF0gKyBwdC51LCBwdC5kLCByYXRpbyk7XG4gICAgICBwdCA9IHB0Ll9uZXh0O1xuICAgIH1cblxuICAgIGRhdGEucm90YXRlICYmIGRhdGEuclNldChkYXRhLnRhcmdldCwgZGF0YS5yUHJvcCwgcmF3UGF0aHNbMF0uYW5nbGUgKiAoZGF0YS5yYWRpYW5zID8gX0RFRzJSQUQgOiAxKSArIGRhdGEuck9mZnNldCArIGRhdGEucnUsIGRhdGEsIHJhdGlvKTtcbiAgfSxcbiAgZ2V0TGVuZ3RoOiBmdW5jdGlvbiBnZXRMZW5ndGgocGF0aCkge1xuICAgIHJldHVybiBjYWNoZVJhd1BhdGhNZWFzdXJlbWVudHMoZ2V0UmF3UGF0aChwYXRoKSkudG90YWxMZW5ndGg7XG4gIH0sXG4gIHNsaWNlUmF3UGF0aDogc2xpY2VSYXdQYXRoLFxuICBnZXRSYXdQYXRoOiBnZXRSYXdQYXRoLFxuICBwb2ludHNUb1NlZ21lbnQ6IHBvaW50c1RvU2VnbWVudCxcbiAgc3RyaW5nVG9SYXdQYXRoOiBzdHJpbmdUb1Jhd1BhdGgsXG4gIHJhd1BhdGhUb1N0cmluZzogcmF3UGF0aFRvU3RyaW5nLFxuICB0cmFuc2Zvcm1SYXdQYXRoOiB0cmFuc2Zvcm1SYXdQYXRoLFxuICBnZXRHbG9iYWxNYXRyaXg6IGdldEdsb2JhbE1hdHJpeCxcbiAgZ2V0UG9zaXRpb25PblBhdGg6IGdldFBvc2l0aW9uT25QYXRoLFxuICBjYWNoZVJhd1BhdGhNZWFzdXJlbWVudHM6IGNhY2hlUmF3UGF0aE1lYXN1cmVtZW50cyxcbiAgY29udmVydFRvUGF0aDogZnVuY3Rpb24gY29udmVydFRvUGF0aCh0YXJnZXRzLCBzd2FwKSB7XG4gICAgcmV0dXJuIF90b0FycmF5KHRhcmdldHMpLm1hcChmdW5jdGlvbiAodGFyZ2V0KSB7XG4gICAgICByZXR1cm4gX2NvbnZlcnRUb1BhdGgodGFyZ2V0LCBzd2FwICE9PSBmYWxzZSk7XG4gICAgfSk7XG4gIH0sXG4gIGNvbnZlcnRDb29yZGluYXRlczogZnVuY3Rpb24gY29udmVydENvb3JkaW5hdGVzKGZyb21FbGVtZW50LCB0b0VsZW1lbnQsIHBvaW50KSB7XG4gICAgdmFyIG0gPSBnZXRHbG9iYWxNYXRyaXgodG9FbGVtZW50LCB0cnVlLCB0cnVlKS5tdWx0aXBseShnZXRHbG9iYWxNYXRyaXgoZnJvbUVsZW1lbnQpKTtcbiAgICByZXR1cm4gcG9pbnQgPyBtLmFwcGx5KHBvaW50KSA6IG07XG4gIH0sXG4gIGdldEFsaWduTWF0cml4OiBfZ2V0QWxpZ25NYXRyaXgsXG4gIGdldFJlbGF0aXZlUG9zaXRpb246IGZ1bmN0aW9uIGdldFJlbGF0aXZlUG9zaXRpb24oZnJvbUVsZW1lbnQsIHRvRWxlbWVudCwgZnJvbU9yaWdpbiwgdG9PcmlnaW4pIHtcbiAgICB2YXIgbSA9IF9nZXRBbGlnbk1hdHJpeChmcm9tRWxlbWVudCwgdG9FbGVtZW50LCBmcm9tT3JpZ2luLCB0b09yaWdpbik7XG5cbiAgICByZXR1cm4ge1xuICAgICAgeDogbS5lLFxuICAgICAgeTogbS5mXG4gICAgfTtcbiAgfSxcbiAgYXJyYXlUb1Jhd1BhdGg6IGZ1bmN0aW9uIGFycmF5VG9SYXdQYXRoKHZhbHVlLCB2YXJzKSB7XG4gICAgdmFycyA9IHZhcnMgfHwge307XG5cbiAgICB2YXIgc2VnbWVudCA9IF9wb3B1bGF0ZVNlZ21lbnRGcm9tQXJyYXkoX3BvcHVsYXRlU2VnbWVudEZyb21BcnJheShbXSwgdmFsdWUsIHZhcnMueCB8fCBcInhcIiwgMCksIHZhbHVlLCB2YXJzLnkgfHwgXCJ5XCIsIDEpO1xuXG4gICAgdmFycy5yZWxhdGl2ZSAmJiBfcmVsYXRpdml6ZShzZWdtZW50KTtcbiAgICByZXR1cm4gW3ZhcnMudHlwZSA9PT0gXCJjdWJpY1wiID8gc2VnbWVudCA6IHBvaW50c1RvU2VnbWVudChzZWdtZW50LCB2YXJzLmN1cnZpbmVzcyldO1xuICB9XG59O1xuX2dldEdTQVAoKSAmJiBnc2FwLnJlZ2lzdGVyUGx1Z2luKE1vdGlvblBhdGhQbHVnaW4pO1xuZXhwb3J0IHsgTW90aW9uUGF0aFBsdWdpbiBhcyBkZWZhdWx0IH07IiwiZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfVxuXG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfVxuXG4vKiFcbiAqIE9ic2VydmVyIDMuMTAuNFxuICogaHR0cHM6Ly9ncmVlbnNvY2suY29tXG4gKlxuICogQGxpY2Vuc2UgQ29weXJpZ2h0IDIwMDgtMjAyMiwgR3JlZW5Tb2NrLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogU3ViamVjdCB0byB0aGUgdGVybXMgYXQgaHR0cHM6Ly9ncmVlbnNvY2suY29tL3N0YW5kYXJkLWxpY2Vuc2Ugb3IgZm9yXG4gKiBDbHViIEdyZWVuU29jayBtZW1iZXJzLCB0aGUgYWdyZWVtZW50IGlzc3VlZCB3aXRoIHRoYXQgbWVtYmVyc2hpcC5cbiAqIEBhdXRob3I6IEphY2sgRG95bGUsIGphY2tAZ3JlZW5zb2NrLmNvbVxuKi9cblxuLyogZXNsaW50LWRpc2FibGUgKi9cbnZhciBnc2FwLFxuICAgIF9jb3JlSW5pdHRlZCxcbiAgICBfY2xhbXAsXG4gICAgX3dpbixcbiAgICBfZG9jLFxuICAgIF9kb2NFbCxcbiAgICBfYm9keSxcbiAgICBfaXNUb3VjaCxcbiAgICBfcG9pbnRlclR5cGUsXG4gICAgU2Nyb2xsVHJpZ2dlcixcbiAgICBfcm9vdCxcbiAgICBfbm9ybWFsaXplcixcbiAgICBfZXZlbnRUeXBlcyxcbiAgICBfZ2V0R1NBUCA9IGZ1bmN0aW9uIF9nZXRHU0FQKCkge1xuICByZXR1cm4gZ3NhcCB8fCB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmIChnc2FwID0gd2luZG93LmdzYXApICYmIGdzYXAucmVnaXN0ZXJQbHVnaW4gJiYgZ3NhcDtcbn0sXG4gICAgX3Bhc3NUaHJvdWdoID0gZnVuY3Rpb24gX3Bhc3NUaHJvdWdoKHApIHtcbiAgcmV0dXJuIHA7XG59LFxuICAgIF9zdGFydHVwID0gMSxcbiAgICBfb2JzZXJ2ZXJzID0gW10sXG4gICAgX3Njcm9sbGVycyA9IFtdLFxuICAgIF9wcm94aWVzID0gW10sXG4gICAgX2dldFRpbWUgPSBEYXRlLm5vdyxcbiAgICBfYnJpZGdlID0gZnVuY3Rpb24gX2JyaWRnZShuYW1lLCB2YWx1ZSkge1xuICByZXR1cm4gdmFsdWU7XG59LFxuICAgIF9pbnRlZ3JhdGUgPSBmdW5jdGlvbiBfaW50ZWdyYXRlKCkge1xuICB2YXIgY29yZSA9IFNjcm9sbFRyaWdnZXIuY29yZSxcbiAgICAgIGRhdGEgPSBjb3JlLmJyaWRnZSB8fCB7fSxcbiAgICAgIHNjcm9sbGVycyA9IGNvcmUuX3Njcm9sbGVycyxcbiAgICAgIHByb3hpZXMgPSBjb3JlLl9wcm94aWVzO1xuICBzY3JvbGxlcnMucHVzaC5hcHBseShzY3JvbGxlcnMsIF9zY3JvbGxlcnMpO1xuICBwcm94aWVzLnB1c2guYXBwbHkocHJveGllcywgX3Byb3hpZXMpO1xuICBfc2Nyb2xsZXJzID0gc2Nyb2xsZXJzO1xuICBfcHJveGllcyA9IHByb3hpZXM7XG5cbiAgX2JyaWRnZSA9IGZ1bmN0aW9uIF9icmlkZ2UobmFtZSwgdmFsdWUpIHtcbiAgICByZXR1cm4gZGF0YVtuYW1lXSh2YWx1ZSk7XG4gIH07XG59LFxuICAgIF9nZXRQcm94eVByb3AgPSBmdW5jdGlvbiBfZ2V0UHJveHlQcm9wKGVsZW1lbnQsIHByb3BlcnR5KSB7XG4gIHJldHVybiB+X3Byb3hpZXMuaW5kZXhPZihlbGVtZW50KSAmJiBfcHJveGllc1tfcHJveGllcy5pbmRleE9mKGVsZW1lbnQpICsgMV1bcHJvcGVydHldO1xufSxcbiAgICBfaXNWaWV3cG9ydCA9IGZ1bmN0aW9uIF9pc1ZpZXdwb3J0KGVsKSB7XG4gIHJldHVybiAhIX5fcm9vdC5pbmRleE9mKGVsKTtcbn0sXG4gICAgX2FkZExpc3RlbmVyID0gZnVuY3Rpb24gX2FkZExpc3RlbmVyKGVsZW1lbnQsIHR5cGUsIGZ1bmMsIG5vblBhc3NpdmUsIGNhcHR1cmUpIHtcbiAgcmV0dXJuIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCBmdW5jLCB7XG4gICAgcGFzc2l2ZTogIW5vblBhc3NpdmUsXG4gICAgY2FwdHVyZTogISFjYXB0dXJlXG4gIH0pO1xufSxcbiAgICBfcmVtb3ZlTGlzdGVuZXIgPSBmdW5jdGlvbiBfcmVtb3ZlTGlzdGVuZXIoZWxlbWVudCwgdHlwZSwgZnVuYywgY2FwdHVyZSkge1xuICByZXR1cm4gZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKHR5cGUsIGZ1bmMsICEhY2FwdHVyZSk7XG59LFxuICAgIF9zY3JvbGxMZWZ0ID0gXCJzY3JvbGxMZWZ0XCIsXG4gICAgX3Njcm9sbFRvcCA9IFwic2Nyb2xsVG9wXCIsXG4gICAgX29uU2Nyb2xsID0gZnVuY3Rpb24gX29uU2Nyb2xsKCkge1xuICByZXR1cm4gX25vcm1hbGl6ZXIgJiYgX25vcm1hbGl6ZXIuaXNQcmVzc2VkIHx8IF9zY3JvbGxlcnMuY2FjaGUrKztcbn0sXG4gICAgX3Njcm9sbENhY2hlRnVuYyA9IGZ1bmN0aW9uIF9zY3JvbGxDYWNoZUZ1bmMoZiwgZG9Ob3RDYWNoZSkge1xuICB2YXIgY2FjaGluZ0Z1bmMgPSBmdW5jdGlvbiBjYWNoaW5nRnVuYyh2YWx1ZSkge1xuICAgIC8vIHNpbmNlIHJlYWRpbmcgdGhlIHNjcm9sbFRvcC9zY3JvbGxMZWZ0L3BhZ2VPZmZzZXRZL3BhZ2VPZmZzZXRYIGNhbiB0cmlnZ2VyIGEgbGF5b3V0LCB0aGlzIGZ1bmN0aW9uIGFsbG93cyB1cyB0byBjYWNoZSB0aGUgdmFsdWUgc28gaXQgb25seSBnZXRzIHJlYWQgZnJlc2ggYWZ0ZXIgYSBcInNjcm9sbFwiIGV2ZW50IGZpcmVzIChvciB3aGlsZSB3ZSdyZSByZWZyZXNoaW5nIGJlY2F1c2UgdGhhdCBjYW4gbGVuZ3RoZW4gdGhlIHBhZ2UgYW5kIGFsdGVyIHRoZSBzY3JvbGwgcG9zaXRpb24pLiB3aGVuIFwic29mdFwiIGlzIHRydWUsIHRoYXQgbWVhbnMgZG9uJ3QgYWN0dWFsbHkgc2V0IHRoZSBzY3JvbGwsIGJ1dCBjYWNoZSB0aGUgbmV3IHZhbHVlIGluc3RlYWQgKHVzZWZ1bCBpbiBTY3JvbGxTbW9vdGhlcilcbiAgICBpZiAodmFsdWUgfHwgdmFsdWUgPT09IDApIHtcbiAgICAgIF9zdGFydHVwICYmIChfd2luLmhpc3Rvcnkuc2Nyb2xsUmVzdG9yYXRpb24gPSBcIm1hbnVhbFwiKTsgLy8gb3RoZXJ3aXNlIHRoZSBuZXcgcG9zaXRpb24gd2lsbCBnZXQgb3ZlcndyaXR0ZW4gYnkgdGhlIGJyb3dzZXIgb25sb2FkLlxuXG4gICAgICB2YXIgaXNOb3JtYWxpemluZyA9IF9ub3JtYWxpemVyICYmIF9ub3JtYWxpemVyLmlzUHJlc3NlZDtcbiAgICAgIHZhbHVlID0gY2FjaGluZ0Z1bmMudiA9IE1hdGgucm91bmQodmFsdWUpIHx8IChfbm9ybWFsaXplciAmJiBfbm9ybWFsaXplci5pT1MgPyAxIDogMCk7IC8vVE9ETzogaU9TIEJ1ZzogaWYgeW91IGFsbG93IGl0IHRvIGdvIHRvIDAsIFNhZmFyaSBjYW4gc3RhcnQgdG8gcmVwb3J0IHN1cGVyIHN0cmFuZ2UgKHdpbGRseSBpbmFjY3VyYXRlKSB0b3VjaCBwb3NpdGlvbnMhXG5cbiAgICAgIGYodmFsdWUpO1xuICAgICAgY2FjaGluZ0Z1bmMuY2FjaGVJRCA9IF9zY3JvbGxlcnMuY2FjaGU7XG4gICAgICBpc05vcm1hbGl6aW5nICYmIF9icmlkZ2UoXCJzc1wiLCB2YWx1ZSk7IC8vIHNldCBzY3JvbGwgKG5vdGlmeSBTY3JvbGxUcmlnZ2VyIHNvIGl0IGNhbiBkaXNwYXRjaCBhIFwic2Nyb2xsU3RhcnRcIiBldmVudCBpZiBuZWNlc3NhcnlcbiAgICB9IGVsc2UgaWYgKGRvTm90Q2FjaGUgfHwgX3Njcm9sbGVycy5jYWNoZSAhPT0gY2FjaGluZ0Z1bmMuY2FjaGVJRCB8fCBfYnJpZGdlKFwicmVmXCIpKSB7XG4gICAgICBjYWNoaW5nRnVuYy5jYWNoZUlEID0gX3Njcm9sbGVycy5jYWNoZTtcbiAgICAgIGNhY2hpbmdGdW5jLnYgPSBmKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNhY2hpbmdGdW5jLnYgKyBjYWNoaW5nRnVuYy5vZmZzZXQ7XG4gIH07XG5cbiAgY2FjaGluZ0Z1bmMub2Zmc2V0ID0gMDtcbiAgcmV0dXJuIGYgJiYgY2FjaGluZ0Z1bmM7XG59LFxuICAgIF9ob3Jpem9udGFsID0ge1xuICBzOiBfc2Nyb2xsTGVmdCxcbiAgcDogXCJsZWZ0XCIsXG4gIHAyOiBcIkxlZnRcIixcbiAgb3M6IFwicmlnaHRcIixcbiAgb3MyOiBcIlJpZ2h0XCIsXG4gIGQ6IFwid2lkdGhcIixcbiAgZDI6IFwiV2lkdGhcIixcbiAgYTogXCJ4XCIsXG4gIHNjOiBfc2Nyb2xsQ2FjaGVGdW5jKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gX3dpbi5zY3JvbGxUbyh2YWx1ZSwgX3ZlcnRpY2FsLnNjKCkpIDogX3dpbi5wYWdlWE9mZnNldCB8fCBfZG9jW19zY3JvbGxMZWZ0XSB8fCBfZG9jRWxbX3Njcm9sbExlZnRdIHx8IF9ib2R5W19zY3JvbGxMZWZ0XSB8fCAwO1xuICB9KVxufSxcbiAgICBfdmVydGljYWwgPSB7XG4gIHM6IF9zY3JvbGxUb3AsXG4gIHA6IFwidG9wXCIsXG4gIHAyOiBcIlRvcFwiLFxuICBvczogXCJib3R0b21cIixcbiAgb3MyOiBcIkJvdHRvbVwiLFxuICBkOiBcImhlaWdodFwiLFxuICBkMjogXCJIZWlnaHRcIixcbiAgYTogXCJ5XCIsXG4gIG9wOiBfaG9yaXpvbnRhbCxcbiAgc2M6IF9zY3JvbGxDYWNoZUZ1bmMoZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyBfd2luLnNjcm9sbFRvKF9ob3Jpem9udGFsLnNjKCksIHZhbHVlKSA6IF93aW4ucGFnZVlPZmZzZXQgfHwgX2RvY1tfc2Nyb2xsVG9wXSB8fCBfZG9jRWxbX3Njcm9sbFRvcF0gfHwgX2JvZHlbX3Njcm9sbFRvcF0gfHwgMDtcbiAgfSlcbn0sXG4gICAgX2dldFRhcmdldCA9IGZ1bmN0aW9uIF9nZXRUYXJnZXQodCkge1xuICByZXR1cm4gZ3NhcC51dGlscy50b0FycmF5KHQpWzBdIHx8ICh0eXBlb2YgdCA9PT0gXCJzdHJpbmdcIiAmJiBnc2FwLmNvbmZpZygpLm51bGxUYXJnZXRXYXJuICE9PSBmYWxzZSA/IGNvbnNvbGUud2FybihcIkVsZW1lbnQgbm90IGZvdW5kOlwiLCB0KSA6IG51bGwpO1xufSxcbiAgICBfZ2V0U2Nyb2xsRnVuYyA9IGZ1bmN0aW9uIF9nZXRTY3JvbGxGdW5jKGVsZW1lbnQsIF9yZWYpIHtcbiAgdmFyIHMgPSBfcmVmLnMsXG4gICAgICBzYyA9IF9yZWYuc2M7XG5cbiAgLy8gd2Ugc3RvcmUgdGhlIHNjcm9sbGVyIGZ1bmN0aW9ucyBpbiBhIGFsdGVybmF0aW5nIHNlcXVlbmNlZCBBcnJheSBsaWtlIFtlbGVtZW50LCB2ZXJ0aWNhbFNjcm9sbEZ1bmMsIGhvcml6b250YWxTY3JvbGxGdW5jLCAuLi5dIHNvIHRoYXQgd2UgY2FuIG1pbmltaXplIG1lbW9yeSwgbWF4aW1pemUgcGVyZm9ybWFuY2UsIGFuZCB3ZSBhbHNvIHJlY29yZCB0aGUgbGFzdCBwb3NpdGlvbiBhcyBhIFwiLnJlY1wiIHByb3BlcnR5IGluIG9yZGVyIHRvIHJldmVydCB0byB0aGF0IGFmdGVyIHJlZnJlc2hpbmcgdG8gZW5zdXJlIHRoaW5ncyBkb24ndCBzaGlmdCBhcm91bmQuXG4gIHZhciBpID0gX3Njcm9sbGVycy5pbmRleE9mKGVsZW1lbnQpLFxuICAgICAgb2Zmc2V0ID0gc2MgPT09IF92ZXJ0aWNhbC5zYyA/IDEgOiAyO1xuXG4gICF+aSAmJiAoaSA9IF9zY3JvbGxlcnMucHVzaChlbGVtZW50KSAtIDEpO1xuICByZXR1cm4gX3Njcm9sbGVyc1tpICsgb2Zmc2V0XSB8fCAoX3Njcm9sbGVyc1tpICsgb2Zmc2V0XSA9IF9zY3JvbGxDYWNoZUZ1bmMoX2dldFByb3h5UHJvcChlbGVtZW50LCBzKSwgdHJ1ZSkgfHwgKF9pc1ZpZXdwb3J0KGVsZW1lbnQpID8gc2MgOiBfc2Nyb2xsQ2FjaGVGdW5jKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gZWxlbWVudFtzXSA9IHZhbHVlIDogZWxlbWVudFtzXTtcbiAgfSkpKTtcbn0sXG4gICAgX2dldFZlbG9jaXR5UHJvcCA9IGZ1bmN0aW9uIF9nZXRWZWxvY2l0eVByb3AodmFsdWUsIG1pblRpbWVSZWZyZXNoLCB1c2VEZWx0YSkge1xuICB2YXIgdjEgPSB2YWx1ZSxcbiAgICAgIHYyID0gdmFsdWUsXG4gICAgICB0MSA9IF9nZXRUaW1lKCksXG4gICAgICB0MiA9IHQxLFxuICAgICAgbWluID0gbWluVGltZVJlZnJlc2ggfHwgNTAsXG4gICAgICBkcm9wVG9aZXJvVGltZSA9IE1hdGgubWF4KDUwMCwgbWluICogMyksXG4gICAgICB1cGRhdGUgPSBmdW5jdGlvbiB1cGRhdGUodmFsdWUsIGZvcmNlKSB7XG4gICAgdmFyIHQgPSBfZ2V0VGltZSgpO1xuXG4gICAgaWYgKGZvcmNlIHx8IHQgLSB0MSA+IG1pbikge1xuICAgICAgdjIgPSB2MTtcbiAgICAgIHYxID0gdmFsdWU7XG4gICAgICB0MiA9IHQxO1xuICAgICAgdDEgPSB0O1xuICAgIH0gZWxzZSBpZiAodXNlRGVsdGEpIHtcbiAgICAgIHYxICs9IHZhbHVlO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBub3QgdG90YWxseSBuZWNlc3NhcnksIGJ1dCBtYWtlcyBpdCBhIGJpdCBtb3JlIGFjY3VyYXRlIGJ5IGFkanVzdGluZyB0aGUgdjEgdmFsdWUgYWNjb3JkaW5nIHRvIHRoZSBuZXcgc2xvcGUuIFRoaXMgd2F5IHdlJ3JlIG5vdCBqdXN0IGlnbm9yaW5nIHRoZSBpbmNvbWluZyBkYXRhLiBSZW1vdmluZyBmb3Igbm93IGJlY2F1c2UgaXQgZG9lc24ndCBzZWVtIHRvIG1ha2UgbXVjaCBwcmFjdGljYWwgZGlmZmVyZW5jZSBhbmQgaXQncyBwcm9iYWJseSBub3Qgd29ydGggdGhlIGtiLlxuICAgICAgdjEgPSB2MiArICh2YWx1ZSAtIHYyKSAvICh0IC0gdDIpICogKHQxIC0gdDIpO1xuICAgIH1cbiAgfSxcbiAgICAgIHJlc2V0ID0gZnVuY3Rpb24gcmVzZXQoKSB7XG4gICAgdjIgPSB2MSA9IHVzZURlbHRhID8gMCA6IHYxO1xuICAgIHQyID0gdDEgPSAwO1xuICB9LFxuICAgICAgZ2V0VmVsb2NpdHkgPSBmdW5jdGlvbiBnZXRWZWxvY2l0eShsYXRlc3RWYWx1ZSkge1xuICAgIHZhciB0T2xkID0gdDIsXG4gICAgICAgIHZPbGQgPSB2MixcbiAgICAgICAgdCA9IF9nZXRUaW1lKCk7XG5cbiAgICAobGF0ZXN0VmFsdWUgfHwgbGF0ZXN0VmFsdWUgPT09IDApICYmIGxhdGVzdFZhbHVlICE9PSB2MSAmJiB1cGRhdGUobGF0ZXN0VmFsdWUpO1xuICAgIHJldHVybiB0MSA9PT0gdDIgfHwgdCAtIHQyID4gZHJvcFRvWmVyb1RpbWUgPyAwIDogKHYxICsgKHVzZURlbHRhID8gdk9sZCA6IC12T2xkKSkgLyAoKHVzZURlbHRhID8gdCA6IHQxKSAtIHRPbGQpICogMTAwMDtcbiAgfTtcblxuICByZXR1cm4ge1xuICAgIHVwZGF0ZTogdXBkYXRlLFxuICAgIHJlc2V0OiByZXNldCxcbiAgICBnZXRWZWxvY2l0eTogZ2V0VmVsb2NpdHlcbiAgfTtcbn0sXG4gICAgX2dldEV2ZW50ID0gZnVuY3Rpb24gX2dldEV2ZW50KGUsIHByZXZlbnREZWZhdWx0KSB7XG4gIHByZXZlbnREZWZhdWx0ICYmICFlLl9nc2FwQWxsb3cgJiYgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICByZXR1cm4gZS5jaGFuZ2VkVG91Y2hlcyA/IGUuY2hhbmdlZFRvdWNoZXNbMF0gOiBlO1xufSxcbiAgICBfZ2V0QWJzb2x1dGVNYXggPSBmdW5jdGlvbiBfZ2V0QWJzb2x1dGVNYXgoYSkge1xuICB2YXIgbWF4ID0gTWF0aC5tYXguYXBwbHkoTWF0aCwgYSksXG4gICAgICBtaW4gPSBNYXRoLm1pbi5hcHBseShNYXRoLCBhKTtcbiAgcmV0dXJuIE1hdGguYWJzKG1heCkgPj0gTWF0aC5hYnMobWluKSA/IG1heCA6IG1pbjtcbn0sXG4gICAgX3NldFNjcm9sbFRyaWdnZXIgPSBmdW5jdGlvbiBfc2V0U2Nyb2xsVHJpZ2dlcigpIHtcbiAgU2Nyb2xsVHJpZ2dlciA9IGdzYXAuY29yZS5nbG9iYWxzKCkuU2Nyb2xsVHJpZ2dlcjtcbiAgU2Nyb2xsVHJpZ2dlciAmJiBTY3JvbGxUcmlnZ2VyLmNvcmUgJiYgX2ludGVncmF0ZSgpO1xufSxcbiAgICBfaW5pdENvcmUgPSBmdW5jdGlvbiBfaW5pdENvcmUoY29yZSkge1xuICBnc2FwID0gY29yZSB8fCBfZ2V0R1NBUCgpO1xuXG4gIGlmIChnc2FwICYmIHR5cGVvZiBkb2N1bWVudCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBkb2N1bWVudC5ib2R5KSB7XG4gICAgX3dpbiA9IHdpbmRvdztcbiAgICBfZG9jID0gZG9jdW1lbnQ7XG4gICAgX2RvY0VsID0gX2RvYy5kb2N1bWVudEVsZW1lbnQ7XG4gICAgX2JvZHkgPSBfZG9jLmJvZHk7XG4gICAgX3Jvb3QgPSBbX3dpbiwgX2RvYywgX2RvY0VsLCBfYm9keV07XG4gICAgX2NsYW1wID0gZ3NhcC51dGlscy5jbGFtcDtcbiAgICBfcG9pbnRlclR5cGUgPSBcIm9ucG9pbnRlcmVudGVyXCIgaW4gX2JvZHkgPyBcInBvaW50ZXJcIiA6IFwibW91c2VcIjsgLy8gaXNUb3VjaCBpcyAwIGlmIG5vIHRvdWNoLCAxIGlmIE9OTFkgdG91Y2gsIGFuZCAyIGlmIGl0IGNhbiBhY2NvbW1vZGF0ZSB0b3VjaCBidXQgYWxzbyBvdGhlciB0eXBlcyBsaWtlIG1vdXNlL3BvaW50ZXIuXG5cbiAgICBfaXNUb3VjaCA9IE9ic2VydmVyLmlzVG91Y2ggPSBfd2luLm1hdGNoTWVkaWEgJiYgX3dpbi5tYXRjaE1lZGlhKFwiKGhvdmVyOiBub25lKSwgKHBvaW50ZXI6IGNvYXJzZSlcIikubWF0Y2hlcyA/IDEgOiBcIm9udG91Y2hzdGFydFwiIGluIF93aW4gfHwgbmF2aWdhdG9yLm1heFRvdWNoUG9pbnRzID4gMCB8fCBuYXZpZ2F0b3IubXNNYXhUb3VjaFBvaW50cyA+IDAgPyAyIDogMDtcbiAgICBfZXZlbnRUeXBlcyA9IE9ic2VydmVyLmV2ZW50VHlwZXMgPSAoXCJvbnRvdWNoc3RhcnRcIiBpbiBfZG9jRWwgPyBcInRvdWNoc3RhcnQsdG91Y2htb3ZlLHRvdWNoY2FuY2VsLHRvdWNoZW5kXCIgOiAhKFwib25wb2ludGVyZG93blwiIGluIF9kb2NFbCkgPyBcIm1vdXNlZG93bixtb3VzZW1vdmUsbW91c2V1cCxtb3VzZXVwXCIgOiBcInBvaW50ZXJkb3duLHBvaW50ZXJtb3ZlLHBvaW50ZXJjYW5jZWwscG9pbnRlcnVwXCIpLnNwbGl0KFwiLFwiKTtcbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBfc3RhcnR1cCA9IDA7XG4gICAgfSwgNTAwKTtcblxuICAgIF9zZXRTY3JvbGxUcmlnZ2VyKCk7XG5cbiAgICBfY29yZUluaXR0ZWQgPSAxO1xuICB9XG5cbiAgcmV0dXJuIF9jb3JlSW5pdHRlZDtcbn07XG5cbl9ob3Jpem9udGFsLm9wID0gX3ZlcnRpY2FsO1xuX3Njcm9sbGVycy5jYWNoZSA9IDA7XG5leHBvcnQgdmFyIE9ic2VydmVyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gT2JzZXJ2ZXIodmFycykge1xuICAgIHRoaXMuaW5pdCh2YXJzKTtcbiAgfVxuXG4gIHZhciBfcHJvdG8gPSBPYnNlcnZlci5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLmluaXQgPSBmdW5jdGlvbiBpbml0KHZhcnMpIHtcbiAgICBfY29yZUluaXR0ZWQgfHwgX2luaXRDb3JlKGdzYXApIHx8IGNvbnNvbGUud2FybihcIlBsZWFzZSBnc2FwLnJlZ2lzdGVyUGx1Z2luKE9ic2VydmVyKVwiKTtcbiAgICBTY3JvbGxUcmlnZ2VyIHx8IF9zZXRTY3JvbGxUcmlnZ2VyKCk7XG4gICAgdmFyIHRvbGVyYW5jZSA9IHZhcnMudG9sZXJhbmNlLFxuICAgICAgICBkcmFnTWluaW11bSA9IHZhcnMuZHJhZ01pbmltdW0sXG4gICAgICAgIHR5cGUgPSB2YXJzLnR5cGUsXG4gICAgICAgIHRhcmdldCA9IHZhcnMudGFyZ2V0LFxuICAgICAgICBsaW5lSGVpZ2h0ID0gdmFycy5saW5lSGVpZ2h0LFxuICAgICAgICBkZWJvdW5jZSA9IHZhcnMuZGVib3VuY2UsXG4gICAgICAgIHByZXZlbnREZWZhdWx0ID0gdmFycy5wcmV2ZW50RGVmYXVsdCxcbiAgICAgICAgb25TdG9wID0gdmFycy5vblN0b3AsXG4gICAgICAgIG9uU3RvcERlbGF5ID0gdmFycy5vblN0b3BEZWxheSxcbiAgICAgICAgaWdub3JlID0gdmFycy5pZ25vcmUsXG4gICAgICAgIHdoZWVsU3BlZWQgPSB2YXJzLndoZWVsU3BlZWQsXG4gICAgICAgIGV2ZW50ID0gdmFycy5ldmVudCxcbiAgICAgICAgb25EcmFnU3RhcnQgPSB2YXJzLm9uRHJhZ1N0YXJ0LFxuICAgICAgICBvbkRyYWdFbmQgPSB2YXJzLm9uRHJhZ0VuZCxcbiAgICAgICAgb25EcmFnID0gdmFycy5vbkRyYWcsXG4gICAgICAgIG9uUHJlc3MgPSB2YXJzLm9uUHJlc3MsXG4gICAgICAgIG9uUmVsZWFzZSA9IHZhcnMub25SZWxlYXNlLFxuICAgICAgICBvblJpZ2h0ID0gdmFycy5vblJpZ2h0LFxuICAgICAgICBvbkxlZnQgPSB2YXJzLm9uTGVmdCxcbiAgICAgICAgb25VcCA9IHZhcnMub25VcCxcbiAgICAgICAgb25Eb3duID0gdmFycy5vbkRvd24sXG4gICAgICAgIG9uQ2hhbmdlWCA9IHZhcnMub25DaGFuZ2VYLFxuICAgICAgICBvbkNoYW5nZVkgPSB2YXJzLm9uQ2hhbmdlWSxcbiAgICAgICAgb25DaGFuZ2UgPSB2YXJzLm9uQ2hhbmdlLFxuICAgICAgICBvblRvZ2dsZVggPSB2YXJzLm9uVG9nZ2xlWCxcbiAgICAgICAgb25Ub2dnbGVZID0gdmFycy5vblRvZ2dsZVksXG4gICAgICAgIG9uSG92ZXIgPSB2YXJzLm9uSG92ZXIsXG4gICAgICAgIG9uSG92ZXJFbmQgPSB2YXJzLm9uSG92ZXJFbmQsXG4gICAgICAgIG9uTW92ZSA9IHZhcnMub25Nb3ZlLFxuICAgICAgICBpZ25vcmVDaGVjayA9IHZhcnMuaWdub3JlQ2hlY2ssXG4gICAgICAgIGlzTm9ybWFsaXplciA9IHZhcnMuaXNOb3JtYWxpemVyLFxuICAgICAgICBvbkdlc3R1cmVTdGFydCA9IHZhcnMub25HZXN0dXJlU3RhcnQsXG4gICAgICAgIG9uR2VzdHVyZUVuZCA9IHZhcnMub25HZXN0dXJlRW5kLFxuICAgICAgICBvbldoZWVsID0gdmFycy5vbldoZWVsLFxuICAgICAgICBvbkVuYWJsZSA9IHZhcnMub25FbmFibGUsXG4gICAgICAgIG9uRGlzYWJsZSA9IHZhcnMub25EaXNhYmxlLFxuICAgICAgICBvbkNsaWNrID0gdmFycy5vbkNsaWNrLFxuICAgICAgICBzY3JvbGxTcGVlZCA9IHZhcnMuc2Nyb2xsU3BlZWQsXG4gICAgICAgIGNhcHR1cmUgPSB2YXJzLmNhcHR1cmUsXG4gICAgICAgIGFsbG93Q2xpY2tzID0gdmFycy5hbGxvd0NsaWNrcyxcbiAgICAgICAgbG9ja0F4aXMgPSB2YXJzLmxvY2tBeGlzLFxuICAgICAgICBvbkxvY2tBeGlzID0gdmFycy5vbkxvY2tBeGlzO1xuICAgIHRoaXMudGFyZ2V0ID0gdGFyZ2V0ID0gX2dldFRhcmdldCh0YXJnZXQpIHx8IF9kb2NFbDtcbiAgICB0aGlzLnZhcnMgPSB2YXJzO1xuICAgIGlnbm9yZSAmJiAoaWdub3JlID0gZ3NhcC51dGlscy50b0FycmF5KGlnbm9yZSkpO1xuICAgIHRvbGVyYW5jZSA9IHRvbGVyYW5jZSB8fCAwO1xuICAgIGRyYWdNaW5pbXVtID0gZHJhZ01pbmltdW0gfHwgMDtcbiAgICB3aGVlbFNwZWVkID0gd2hlZWxTcGVlZCB8fCAxO1xuICAgIHNjcm9sbFNwZWVkID0gc2Nyb2xsU3BlZWQgfHwgMTtcbiAgICB0eXBlID0gdHlwZSB8fCBcIndoZWVsLHRvdWNoLHBvaW50ZXJcIjtcbiAgICBkZWJvdW5jZSA9IGRlYm91bmNlICE9PSBmYWxzZTtcbiAgICBsaW5lSGVpZ2h0IHx8IChsaW5lSGVpZ2h0ID0gcGFyc2VGbG9hdChfd2luLmdldENvbXB1dGVkU3R5bGUoX2JvZHkpLmxpbmVIZWlnaHQpIHx8IDIyKTsgLy8gbm90ZTogYnJvd3NlciBtYXkgcmVwb3J0IFwibm9ybWFsXCIsIHNvIGRlZmF1bHQgdG8gMjIuXG5cbiAgICB2YXIgaWQsXG4gICAgICAgIG9uU3RvcERlbGF5ZWRDYWxsLFxuICAgICAgICBkcmFnZ2VkLFxuICAgICAgICBtb3ZlZCxcbiAgICAgICAgd2hlZWxlZCxcbiAgICAgICAgbG9ja2VkLFxuICAgICAgICBheGlzLFxuICAgICAgICBzZWxmID0gdGhpcyxcbiAgICAgICAgcHJldkRlbHRhWCA9IDAsXG4gICAgICAgIHByZXZEZWx0YVkgPSAwLFxuICAgICAgICBzY3JvbGxGdW5jWCA9IF9nZXRTY3JvbGxGdW5jKHRhcmdldCwgX2hvcml6b250YWwpLFxuICAgICAgICBzY3JvbGxGdW5jWSA9IF9nZXRTY3JvbGxGdW5jKHRhcmdldCwgX3ZlcnRpY2FsKSxcbiAgICAgICAgc2Nyb2xsWCA9IHNjcm9sbEZ1bmNYKCksXG4gICAgICAgIHNjcm9sbFkgPSBzY3JvbGxGdW5jWSgpLFxuICAgICAgICBsaW1pdFRvVG91Y2ggPSB+dHlwZS5pbmRleE9mKFwidG91Y2hcIikgJiYgIX50eXBlLmluZGV4T2YoXCJwb2ludGVyXCIpICYmIF9ldmVudFR5cGVzWzBdID09PSBcInBvaW50ZXJkb3duXCIsXG4gICAgICAgIC8vIGZvciBkZXZpY2VzIHRoYXQgYWNjb21tb2RhdGUgbW91c2UgZXZlbnRzIGFuZCB0b3VjaCBldmVudHMsIHdlIG5lZWQgdG8gZGlzdGluZ3Vpc2guXG4gICAgaXNWaWV3cG9ydCA9IF9pc1ZpZXdwb3J0KHRhcmdldCksXG4gICAgICAgIG93bmVyRG9jID0gdGFyZ2V0Lm93bmVyRG9jdW1lbnQgfHwgX2RvYyxcbiAgICAgICAgZGVsdGFYID0gWzAsIDAsIDBdLFxuICAgICAgICAvLyB3aGVlbCwgc2Nyb2xsLCBwb2ludGVyL3RvdWNoXG4gICAgZGVsdGFZID0gWzAsIDAsIDBdLFxuICAgICAgICBvbkNsaWNrVGltZSA9IDAsXG4gICAgICAgIGNsaWNrQ2FwdHVyZSA9IGZ1bmN0aW9uIGNsaWNrQ2FwdHVyZSgpIHtcbiAgICAgIHJldHVybiBvbkNsaWNrVGltZSA9IF9nZXRUaW1lKCk7XG4gICAgfSxcbiAgICAgICAgX2lnbm9yZUNoZWNrID0gZnVuY3Rpb24gX2lnbm9yZUNoZWNrKGUsIGlzUG9pbnRlck9yVG91Y2gpIHtcbiAgICAgIHJldHVybiAoc2VsZi5ldmVudCA9IGUpICYmIGlnbm9yZSAmJiB+aWdub3JlLmluZGV4T2YoZS50YXJnZXQpIHx8IGlzUG9pbnRlck9yVG91Y2ggJiYgbGltaXRUb1RvdWNoICYmIGUucG9pbnRlclR5cGUgIT09IFwidG91Y2hcIiB8fCBpZ25vcmVDaGVjayAmJiBpZ25vcmVDaGVjayhlLCBpc1BvaW50ZXJPclRvdWNoKTtcbiAgICB9LFxuICAgICAgICBvblN0b3BGdW5jID0gZnVuY3Rpb24gb25TdG9wRnVuYygpIHtcbiAgICAgIHNlbGYuX3Z4LnJlc2V0KCk7XG5cbiAgICAgIHNlbGYuX3Z5LnJlc2V0KCk7XG5cbiAgICAgIG9uU3RvcERlbGF5ZWRDYWxsLnBhdXNlKCk7XG4gICAgICBvblN0b3AgJiYgb25TdG9wKHNlbGYpO1xuICAgIH0sXG4gICAgICAgIHVwZGF0ZSA9IGZ1bmN0aW9uIHVwZGF0ZSgpIHtcbiAgICAgIHZhciBkeCA9IHNlbGYuZGVsdGFYID0gX2dldEFic29sdXRlTWF4KGRlbHRhWCksXG4gICAgICAgICAgZHkgPSBzZWxmLmRlbHRhWSA9IF9nZXRBYnNvbHV0ZU1heChkZWx0YVkpLFxuICAgICAgICAgIGNoYW5nZWRYID0gTWF0aC5hYnMoZHgpID49IHRvbGVyYW5jZSxcbiAgICAgICAgICBjaGFuZ2VkWSA9IE1hdGguYWJzKGR5KSA+PSB0b2xlcmFuY2U7XG5cbiAgICAgIG9uQ2hhbmdlICYmIChjaGFuZ2VkWCB8fCBjaGFuZ2VkWSkgJiYgb25DaGFuZ2Uoc2VsZiwgZHgsIGR5LCBkZWx0YVgsIGRlbHRhWSk7IC8vIGluIFNjcm9sbFRyaWdnZXIubm9ybWFsaXplU2Nyb2xsKCksIHdlIG5lZWQgdG8ga25vdyBpZiBpdCB3YXMgdG91Y2gvcG9pbnRlciBzbyB3ZSBuZWVkIGFjY2VzcyB0byB0aGUgZGVsdGFYL2RlbHRhWSBBcnJheXMgYmVmb3JlIHdlIGNsZWFyIHRoZW0gb3V0LlxuXG4gICAgICBpZiAoY2hhbmdlZFgpIHtcbiAgICAgICAgb25SaWdodCAmJiBzZWxmLmRlbHRhWCA+IDAgJiYgb25SaWdodChzZWxmKTtcbiAgICAgICAgb25MZWZ0ICYmIHNlbGYuZGVsdGFYIDwgMCAmJiBvbkxlZnQoc2VsZik7XG4gICAgICAgIG9uQ2hhbmdlWCAmJiBvbkNoYW5nZVgoc2VsZik7XG4gICAgICAgIG9uVG9nZ2xlWCAmJiBzZWxmLmRlbHRhWCA8IDAgIT09IHByZXZEZWx0YVggPCAwICYmIG9uVG9nZ2xlWChzZWxmKTtcbiAgICAgICAgcHJldkRlbHRhWCA9IHNlbGYuZGVsdGFYO1xuICAgICAgICBkZWx0YVhbMF0gPSBkZWx0YVhbMV0gPSBkZWx0YVhbMl0gPSAwO1xuICAgICAgfVxuXG4gICAgICBpZiAoY2hhbmdlZFkpIHtcbiAgICAgICAgb25Eb3duICYmIHNlbGYuZGVsdGFZID4gMCAmJiBvbkRvd24oc2VsZik7XG4gICAgICAgIG9uVXAgJiYgc2VsZi5kZWx0YVkgPCAwICYmIG9uVXAoc2VsZik7XG4gICAgICAgIG9uQ2hhbmdlWSAmJiBvbkNoYW5nZVkoc2VsZik7XG4gICAgICAgIG9uVG9nZ2xlWSAmJiBzZWxmLmRlbHRhWSA8IDAgIT09IHByZXZEZWx0YVkgPCAwICYmIG9uVG9nZ2xlWShzZWxmKTtcbiAgICAgICAgcHJldkRlbHRhWSA9IHNlbGYuZGVsdGFZO1xuICAgICAgICBkZWx0YVlbMF0gPSBkZWx0YVlbMV0gPSBkZWx0YVlbMl0gPSAwO1xuICAgICAgfVxuXG4gICAgICBpZiAobW92ZWQgfHwgZHJhZ2dlZCkge1xuICAgICAgICBvbk1vdmUgJiYgb25Nb3ZlKHNlbGYpO1xuICAgICAgICBvbkxvY2tBeGlzICYmIGxvY2tlZCAmJiBvbkxvY2tBeGlzKHNlbGYpO1xuXG4gICAgICAgIGlmIChkcmFnZ2VkKSB7XG4gICAgICAgICAgb25EcmFnKHNlbGYpO1xuICAgICAgICAgIGRyYWdnZWQgPSBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIG1vdmVkID0gbG9ja2VkID0gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIGlmICh3aGVlbGVkKSB7XG4gICAgICAgIG9uV2hlZWwoc2VsZik7XG4gICAgICAgIHdoZWVsZWQgPSBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgaWQgPSAwO1xuICAgIH0sXG4gICAgICAgIG9uRGVsdGEgPSBmdW5jdGlvbiBvbkRlbHRhKHgsIHksIGluZGV4KSB7XG4gICAgICBkZWx0YVhbaW5kZXhdICs9IHg7XG4gICAgICBkZWx0YVlbaW5kZXhdICs9IHk7XG5cbiAgICAgIHNlbGYuX3Z4LnVwZGF0ZSh4KTtcblxuICAgICAgc2VsZi5fdnkudXBkYXRlKHkpO1xuXG4gICAgICBkZWJvdW5jZSA/IGlkIHx8IChpZCA9IHJlcXVlc3RBbmltYXRpb25GcmFtZSh1cGRhdGUpKSA6IHVwZGF0ZSgpO1xuICAgIH0sXG4gICAgICAgIG9uVG91Y2hPclBvaW50ZXJEZWx0YSA9IGZ1bmN0aW9uIG9uVG91Y2hPclBvaW50ZXJEZWx0YSh4LCB5KSB7XG4gICAgICBpZiAoYXhpcyAhPT0gXCJ5XCIpIHtcbiAgICAgICAgZGVsdGFYWzJdICs9IHg7XG5cbiAgICAgICAgc2VsZi5fdngudXBkYXRlKHgsIHRydWUpOyAvLyB1cGRhdGUgdGhlIHZlbG9jaXR5IGFzIGZyZXF1ZW50bHkgYXMgcG9zc2libGUgaW5zdGVhZCBvZiBpbiB0aGUgZGVib3VuY2VkIGZ1bmN0aW9uIHNvIHRoYXQgdmVyeSBxdWljayB0b3VjaC1zY3JvbGxzIChmbGlja3MpIGZlZWwgbmF0dXJhbC4gSWYgaXQncyB0aGUgbW91c2UvdG91Y2gvcG9pbnRlciwgZm9yY2UgaXQgc28gdGhhdCB3ZSBnZXQgc25hcHB5L2FjY3VyYXRlIG1vbWVudHVtIHNjcm9sbC5cblxuICAgICAgfVxuXG4gICAgICBpZiAoYXhpcyAhPT0gXCJ4XCIpIHtcbiAgICAgICAgZGVsdGFZWzJdICs9IHk7XG5cbiAgICAgICAgc2VsZi5fdnkudXBkYXRlKHksIHRydWUpO1xuICAgICAgfVxuXG4gICAgICBpZiAobG9ja0F4aXMgJiYgIWF4aXMpIHtcbiAgICAgICAgc2VsZi5heGlzID0gYXhpcyA9IE1hdGguYWJzKHgpID4gTWF0aC5hYnMoeSkgPyBcInhcIiA6IFwieVwiO1xuICAgICAgICBsb2NrZWQgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICBkZWJvdW5jZSA/IGlkIHx8IChpZCA9IHJlcXVlc3RBbmltYXRpb25GcmFtZSh1cGRhdGUpKSA6IHVwZGF0ZSgpO1xuICAgIH0sXG4gICAgICAgIF9vbkRyYWcgPSBmdW5jdGlvbiBfb25EcmFnKGUpIHtcbiAgICAgIGlmIChfaWdub3JlQ2hlY2soZSwgMSkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBlID0gX2dldEV2ZW50KGUsIHByZXZlbnREZWZhdWx0KTtcbiAgICAgIHZhciB4ID0gZS5jbGllbnRYLFxuICAgICAgICAgIHkgPSBlLmNsaWVudFksXG4gICAgICAgICAgZHggPSB4IC0gc2VsZi54LFxuICAgICAgICAgIGR5ID0geSAtIHNlbGYueSxcbiAgICAgICAgICBpc0RyYWdnaW5nID0gc2VsZi5pc0RyYWdnaW5nO1xuICAgICAgc2VsZi54ID0geDtcbiAgICAgIHNlbGYueSA9IHk7XG5cbiAgICAgIGlmIChpc0RyYWdnaW5nIHx8IE1hdGguYWJzKHNlbGYuc3RhcnRYIC0geCkgPj0gZHJhZ01pbmltdW0gfHwgTWF0aC5hYnMoc2VsZi5zdGFydFkgLSB5KSA+PSBkcmFnTWluaW11bSkge1xuICAgICAgICBvbkRyYWcgJiYgKGRyYWdnZWQgPSB0cnVlKTtcbiAgICAgICAgaXNEcmFnZ2luZyB8fCAoc2VsZi5pc0RyYWdnaW5nID0gdHJ1ZSk7XG4gICAgICAgIG9uVG91Y2hPclBvaW50ZXJEZWx0YShkeCwgZHkpO1xuICAgICAgICBpc0RyYWdnaW5nIHx8IG9uRHJhZ1N0YXJ0ICYmIG9uRHJhZ1N0YXJ0KHNlbGYpO1xuICAgICAgfVxuICAgIH0sXG4gICAgICAgIF9vblByZXNzID0gc2VsZi5vblByZXNzID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgIGlmIChfaWdub3JlQ2hlY2soZSwgMSkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBzZWxmLmF4aXMgPSBheGlzID0gbnVsbDtcbiAgICAgIG9uU3RvcERlbGF5ZWRDYWxsLnBhdXNlKCk7XG4gICAgICBzZWxmLmlzUHJlc3NlZCA9IHRydWU7XG4gICAgICBlID0gX2dldEV2ZW50KGUpOyAvLyBub3RlOiBtYXkgbmVlZCB0byBwcmV2ZW50RGVmYXVsdCg/KSBXb24ndCBzaWRlLXNjcm9sbCBvbiBpT1MgU2FmYXJpIGlmIHdlIGRvLCB0aG91Z2guXG5cbiAgICAgIHByZXZEZWx0YVggPSBwcmV2RGVsdGFZID0gMDtcbiAgICAgIHNlbGYuc3RhcnRYID0gc2VsZi54ID0gZS5jbGllbnRYO1xuICAgICAgc2VsZi5zdGFydFkgPSBzZWxmLnkgPSBlLmNsaWVudFk7XG5cbiAgICAgIHNlbGYuX3Z4LnJlc2V0KCk7IC8vIG90aGVyd2lzZSB0aGUgdDIgbWF5IGJlIHN0YWxlIGlmIHRoZSB1c2VyIHRvdWNoZXMgYW5kIGZsaWNrcyBzdXBlciBmYXN0IGFuZCByZWxlYXNlcyBpbiBsZXNzIHRoYW4gMiByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgdGlja3MsIGNhdXNpbmcgdmVsb2NpdHkgdG8gYmUgMC5cblxuXG4gICAgICBzZWxmLl92eS5yZXNldCgpO1xuXG4gICAgICBfYWRkTGlzdGVuZXIoaXNOb3JtYWxpemVyID8gdGFyZ2V0IDogb3duZXJEb2MsIF9ldmVudFR5cGVzWzFdLCBfb25EcmFnLCBwcmV2ZW50RGVmYXVsdCwgdHJ1ZSk7XG5cbiAgICAgIHNlbGYuZGVsdGFYID0gc2VsZi5kZWx0YVkgPSAwO1xuICAgICAgb25QcmVzcyAmJiBvblByZXNzKHNlbGYpO1xuICAgIH0sXG4gICAgICAgIF9vblJlbGVhc2UgPSBmdW5jdGlvbiBfb25SZWxlYXNlKGUpIHtcbiAgICAgIGlmIChfaWdub3JlQ2hlY2soZSwgMSkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBfcmVtb3ZlTGlzdGVuZXIoaXNOb3JtYWxpemVyID8gdGFyZ2V0IDogb3duZXJEb2MsIF9ldmVudFR5cGVzWzFdLCBfb25EcmFnLCB0cnVlKTtcblxuICAgICAgdmFyIHdhc0RyYWdnaW5nID0gc2VsZi5pc0RyYWdnaW5nICYmIChNYXRoLmFicyhzZWxmLnggLSBzZWxmLnN0YXJ0WCkgPiAzIHx8IE1hdGguYWJzKHNlbGYueSAtIHNlbGYuc3RhcnRZKSA+IDMpLFxuICAgICAgICAgIC8vIHNvbWUgdG91Y2ggZGV2aWNlcyBuZWVkIHNvbWUgd2lnZ2xlIHJvb20gaW4gdGVybXMgb2Ygc2Vuc2luZyBjbGlja3MgLSB0aGUgZmluZ2VyIG1heSBtb3ZlIGEgZmV3IHBpeGVscy5cbiAgICAgIGV2ZW50RGF0YSA9IF9nZXRFdmVudChlKTtcblxuICAgICAgaWYgKCF3YXNEcmFnZ2luZykge1xuICAgICAgICBzZWxmLl92eC5yZXNldCgpO1xuXG4gICAgICAgIHNlbGYuX3Z5LnJlc2V0KCk7XG5cbiAgICAgICAgaWYgKHByZXZlbnREZWZhdWx0ICYmIGFsbG93Q2xpY2tzKSB7XG4gICAgICAgICAgZ3NhcC5kZWxheWVkQ2FsbCgwLjA4LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAvLyBzb21lIGJyb3dzZXJzIChsaWtlIEZpcmVmb3gpIHdvbid0IHRydXN0IHNjcmlwdC1nZW5lcmF0ZWQgY2xpY2tzLCBzbyBpZiB0aGUgdXNlciB0cmllcyB0byBjbGljayBvbiBhIHZpZGVvIHRvIHBsYXkgaXQsIGZvciBleGFtcGxlLCBpdCBzaW1wbHkgd29uJ3Qgd29yay4gU2luY2UgYSByZWd1bGFyIFwiY2xpY2tcIiBldmVudCB3aWxsIG1vc3QgbGlrZWx5IGJlIGdlbmVyYXRlZCBhbnl3YXkgKG9uZSB0aGF0IGhhcyBpdHMgaXNUcnVzdGVkIGZsYWcgc2V0IHRvIHRydWUpLCB3ZSBtdXN0IHNsaWdodGx5IGRlbGF5IG91ciBzY3JpcHQtZ2VuZXJhdGVkIGNsaWNrIHNvIHRoYXQgdGhlIFwicmVhbFwiL3RydXN0ZWQgb25lIGlzIHByaW9yaXRpemVkLiBSZW1lbWJlciwgd2hlbiB0aGVyZSBhcmUgZHVwbGljYXRlIGV2ZW50cyBpbiBxdWljayBzdWNjZXNzaW9uLCB3ZSBzdXBwcmVzcyBhbGwgYnV0IHRoZSBmaXJzdCBvbmUuIFNvbWUgYnJvd3NlcnMgZG9uJ3QgZXZlbiB0cmlnZ2VyIHRoZSBcInJlYWxcIiBvbmUgYXQgYWxsLCBzbyBvdXIgc3ludGhldGljIG9uZSBpcyBhIHNhZmV0eSB2YWx2ZSB0aGF0IGVuc3VyZXMgdGhhdCBubyBtYXR0ZXIgd2hhdCwgYSBjbGljayBldmVudCBkb2VzIGdldCBkaXNwYXRjaGVkLlxuICAgICAgICAgICAgaWYgKF9nZXRUaW1lKCkgLSBvbkNsaWNrVGltZSA+IDMwMCAmJiAhZS5kZWZhdWx0UHJldmVudGVkKSB7XG4gICAgICAgICAgICAgIGlmIChlLnRhcmdldC5jbGljaykge1xuICAgICAgICAgICAgICAgIC8vc29tZSBicm93c2VycyAobGlrZSBtb2JpbGUgU2FmYXJpKSBkb24ndCBwcm9wZXJseSB0cmlnZ2VyIHRoZSBjbGljayBldmVudFxuICAgICAgICAgICAgICAgIGUudGFyZ2V0LmNsaWNrKCk7XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAob3duZXJEb2MuY3JlYXRlRXZlbnQpIHtcbiAgICAgICAgICAgICAgICB2YXIgc3ludGhldGljRXZlbnQgPSBvd25lckRvYy5jcmVhdGVFdmVudChcIk1vdXNlRXZlbnRzXCIpO1xuICAgICAgICAgICAgICAgIHN5bnRoZXRpY0V2ZW50LmluaXRNb3VzZUV2ZW50KFwiY2xpY2tcIiwgdHJ1ZSwgdHJ1ZSwgX3dpbiwgMSwgZXZlbnREYXRhLnNjcmVlblgsIGV2ZW50RGF0YS5zY3JlZW5ZLCBldmVudERhdGEuY2xpZW50WCwgZXZlbnREYXRhLmNsaWVudFksIGZhbHNlLCBmYWxzZSwgZmFsc2UsIGZhbHNlLCAwLCBudWxsKTtcbiAgICAgICAgICAgICAgICBlLnRhcmdldC5kaXNwYXRjaEV2ZW50KHN5bnRoZXRpY0V2ZW50KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHNlbGYuaXNEcmFnZ2luZyA9IHNlbGYuaXNHZXN0dXJpbmcgPSBzZWxmLmlzUHJlc3NlZCA9IGZhbHNlO1xuICAgICAgb25TdG9wICYmICFpc05vcm1hbGl6ZXIgJiYgb25TdG9wRGVsYXllZENhbGwucmVzdGFydCh0cnVlKTtcbiAgICAgIG9uRHJhZ0VuZCAmJiB3YXNEcmFnZ2luZyAmJiBvbkRyYWdFbmQoc2VsZik7XG4gICAgICBvblJlbGVhc2UgJiYgb25SZWxlYXNlKHNlbGYsIHdhc0RyYWdnaW5nKTtcbiAgICB9LFxuICAgICAgICBfb25HZXN0dXJlU3RhcnQgPSBmdW5jdGlvbiBfb25HZXN0dXJlU3RhcnQoZSkge1xuICAgICAgcmV0dXJuIGUudG91Y2hlcyAmJiBlLnRvdWNoZXMubGVuZ3RoID4gMSAmJiAoc2VsZi5pc0dlc3R1cmluZyA9IHRydWUpICYmIG9uR2VzdHVyZVN0YXJ0KGUsIHNlbGYuaXNEcmFnZ2luZyk7XG4gICAgfSxcbiAgICAgICAgX29uR2VzdHVyZUVuZCA9IGZ1bmN0aW9uIF9vbkdlc3R1cmVFbmQoKSB7XG4gICAgICByZXR1cm4gKHNlbGYuaXNHZXN0dXJpbmcgPSBmYWxzZSkgfHwgb25HZXN0dXJlRW5kKHNlbGYpO1xuICAgIH0sXG4gICAgICAgIG9uU2Nyb2xsID0gZnVuY3Rpb24gb25TY3JvbGwoZSkge1xuICAgICAgaWYgKF9pZ25vcmVDaGVjayhlKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciB4ID0gc2Nyb2xsRnVuY1goKSxcbiAgICAgICAgICB5ID0gc2Nyb2xsRnVuY1koKTtcbiAgICAgIG9uRGVsdGEoKHggLSBzY3JvbGxYKSAqIHNjcm9sbFNwZWVkLCAoeSAtIHNjcm9sbFkpICogc2Nyb2xsU3BlZWQsIDEpO1xuICAgICAgc2Nyb2xsWCA9IHg7XG4gICAgICBzY3JvbGxZID0geTtcbiAgICAgIG9uU3RvcCAmJiBvblN0b3BEZWxheWVkQ2FsbC5yZXN0YXJ0KHRydWUpO1xuICAgIH0sXG4gICAgICAgIF9vbldoZWVsID0gZnVuY3Rpb24gX29uV2hlZWwoZSkge1xuICAgICAgaWYgKF9pZ25vcmVDaGVjayhlKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGUgPSBfZ2V0RXZlbnQoZSwgcHJldmVudERlZmF1bHQpO1xuICAgICAgb25XaGVlbCAmJiAod2hlZWxlZCA9IHRydWUpO1xuICAgICAgdmFyIG11bHRpcGxpZXIgPSAoZS5kZWx0YU1vZGUgPT09IDEgPyBsaW5lSGVpZ2h0IDogZS5kZWx0YU1vZGUgPT09IDIgPyBfd2luLmlubmVySGVpZ2h0IDogMSkgKiB3aGVlbFNwZWVkO1xuICAgICAgb25EZWx0YShlLmRlbHRhWCAqIG11bHRpcGxpZXIsIGUuZGVsdGFZICogbXVsdGlwbGllciwgMCk7XG4gICAgICBvblN0b3AgJiYgIWlzTm9ybWFsaXplciAmJiBvblN0b3BEZWxheWVkQ2FsbC5yZXN0YXJ0KHRydWUpO1xuICAgIH0sXG4gICAgICAgIF9vbk1vdmUgPSBmdW5jdGlvbiBfb25Nb3ZlKGUpIHtcbiAgICAgIGlmIChfaWdub3JlQ2hlY2soZSkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgeCA9IGUuY2xpZW50WCxcbiAgICAgICAgICB5ID0gZS5jbGllbnRZLFxuICAgICAgICAgIGR4ID0geCAtIHNlbGYueCxcbiAgICAgICAgICBkeSA9IHkgLSBzZWxmLnk7XG4gICAgICBzZWxmLnggPSB4O1xuICAgICAgc2VsZi55ID0geTtcbiAgICAgIG1vdmVkID0gdHJ1ZTtcbiAgICAgIChkeCB8fCBkeSkgJiYgb25Ub3VjaE9yUG9pbnRlckRlbHRhKGR4LCBkeSk7XG4gICAgfSxcbiAgICAgICAgX29uSG92ZXIgPSBmdW5jdGlvbiBfb25Ib3ZlcihlKSB7XG4gICAgICBzZWxmLmV2ZW50ID0gZTtcbiAgICAgIG9uSG92ZXIoc2VsZik7XG4gICAgfSxcbiAgICAgICAgX29uSG92ZXJFbmQgPSBmdW5jdGlvbiBfb25Ib3ZlckVuZChlKSB7XG4gICAgICBzZWxmLmV2ZW50ID0gZTtcbiAgICAgIG9uSG92ZXJFbmQoc2VsZik7XG4gICAgfSxcbiAgICAgICAgX29uQ2xpY2sgPSBmdW5jdGlvbiBfb25DbGljayhlKSB7XG4gICAgICByZXR1cm4gX2lnbm9yZUNoZWNrKGUpIHx8IF9nZXRFdmVudChlLCBwcmV2ZW50RGVmYXVsdCkgJiYgb25DbGljayhzZWxmKTtcbiAgICB9O1xuXG4gICAgb25TdG9wRGVsYXllZENhbGwgPSBzZWxmLl9kYyA9IGdzYXAuZGVsYXllZENhbGwob25TdG9wRGVsYXkgfHwgMC4yNSwgb25TdG9wRnVuYykucGF1c2UoKTtcbiAgICBzZWxmLmRlbHRhWCA9IHNlbGYuZGVsdGFZID0gMDtcbiAgICBzZWxmLl92eCA9IF9nZXRWZWxvY2l0eVByb3AoMCwgNTAsIHRydWUpO1xuICAgIHNlbGYuX3Z5ID0gX2dldFZlbG9jaXR5UHJvcCgwLCA1MCwgdHJ1ZSk7XG4gICAgc2VsZi5zY3JvbGxYID0gc2Nyb2xsRnVuY1g7XG4gICAgc2VsZi5zY3JvbGxZID0gc2Nyb2xsRnVuY1k7XG4gICAgc2VsZi5pc0RyYWdnaW5nID0gc2VsZi5pc0dlc3R1cmluZyA9IHNlbGYuaXNQcmVzc2VkID0gZmFsc2U7XG5cbiAgICBzZWxmLmVuYWJsZSA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICBpZiAoIXNlbGYuaXNFbmFibGVkKSB7XG4gICAgICAgIF9hZGRMaXN0ZW5lcihpc1ZpZXdwb3J0ID8gb3duZXJEb2MgOiB0YXJnZXQsIFwic2Nyb2xsXCIsIF9vblNjcm9sbCk7XG5cbiAgICAgICAgdHlwZS5pbmRleE9mKFwic2Nyb2xsXCIpID49IDAgJiYgX2FkZExpc3RlbmVyKGlzVmlld3BvcnQgPyBvd25lckRvYyA6IHRhcmdldCwgXCJzY3JvbGxcIiwgb25TY3JvbGwsIHByZXZlbnREZWZhdWx0LCBjYXB0dXJlKTtcbiAgICAgICAgdHlwZS5pbmRleE9mKFwid2hlZWxcIikgPj0gMCAmJiBfYWRkTGlzdGVuZXIodGFyZ2V0LCBcIndoZWVsXCIsIF9vbldoZWVsLCBwcmV2ZW50RGVmYXVsdCwgY2FwdHVyZSk7XG5cbiAgICAgICAgaWYgKHR5cGUuaW5kZXhPZihcInRvdWNoXCIpID49IDAgJiYgX2lzVG91Y2ggfHwgdHlwZS5pbmRleE9mKFwicG9pbnRlclwiKSA+PSAwKSB7XG4gICAgICAgICAgX2FkZExpc3RlbmVyKHRhcmdldCwgX2V2ZW50VHlwZXNbMF0sIF9vblByZXNzLCBwcmV2ZW50RGVmYXVsdCwgY2FwdHVyZSk7XG5cbiAgICAgICAgICBfYWRkTGlzdGVuZXIob3duZXJEb2MsIF9ldmVudFR5cGVzWzJdLCBfb25SZWxlYXNlKTtcblxuICAgICAgICAgIF9hZGRMaXN0ZW5lcihvd25lckRvYywgX2V2ZW50VHlwZXNbM10sIF9vblJlbGVhc2UpO1xuXG4gICAgICAgICAgYWxsb3dDbGlja3MgJiYgX2FkZExpc3RlbmVyKHRhcmdldCwgXCJjbGlja1wiLCBjbGlja0NhcHR1cmUsIGZhbHNlLCB0cnVlKTtcbiAgICAgICAgICBvbkNsaWNrICYmIF9hZGRMaXN0ZW5lcih0YXJnZXQsIFwiY2xpY2tcIiwgX29uQ2xpY2spO1xuICAgICAgICAgIG9uR2VzdHVyZVN0YXJ0ICYmIF9hZGRMaXN0ZW5lcihvd25lckRvYywgXCJnZXN0dXJlc3RhcnRcIiwgX29uR2VzdHVyZVN0YXJ0KTtcbiAgICAgICAgICBvbkdlc3R1cmVFbmQgJiYgX2FkZExpc3RlbmVyKG93bmVyRG9jLCBcImdlc3R1cmVlbmRcIiwgX29uR2VzdHVyZUVuZCk7XG4gICAgICAgICAgb25Ib3ZlciAmJiBfYWRkTGlzdGVuZXIodGFyZ2V0LCBfcG9pbnRlclR5cGUgKyBcImVudGVyXCIsIF9vbkhvdmVyKTtcbiAgICAgICAgICBvbkhvdmVyRW5kICYmIF9hZGRMaXN0ZW5lcih0YXJnZXQsIF9wb2ludGVyVHlwZSArIFwibGVhdmVcIiwgX29uSG92ZXJFbmQpO1xuICAgICAgICAgIG9uTW92ZSAmJiBfYWRkTGlzdGVuZXIodGFyZ2V0LCBfcG9pbnRlclR5cGUgKyBcIm1vdmVcIiwgX29uTW92ZSk7XG4gICAgICAgIH1cblxuICAgICAgICBzZWxmLmlzRW5hYmxlZCA9IHRydWU7XG4gICAgICAgIGUgJiYgZS50eXBlICYmIF9vblByZXNzKGUpO1xuICAgICAgICBvbkVuYWJsZSAmJiBvbkVuYWJsZShzZWxmKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfTtcblxuICAgIHNlbGYuZGlzYWJsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChzZWxmLmlzRW5hYmxlZCkge1xuICAgICAgICAvLyBvbmx5IHJlbW92ZSB0aGUgX29uU2Nyb2xsIGxpc3RlbmVyIGlmIHRoZXJlIGFyZW4ndCBhbnkgb3RoZXJzIHRoYXQgcmVseSBvbiB0aGUgZnVuY3Rpb25hbGl0eS5cbiAgICAgICAgX29ic2VydmVycy5maWx0ZXIoZnVuY3Rpb24gKG8pIHtcbiAgICAgICAgICByZXR1cm4gbyAhPT0gc2VsZiAmJiBfaXNWaWV3cG9ydChvLnRhcmdldCk7XG4gICAgICAgIH0pLmxlbmd0aCB8fCBfcmVtb3ZlTGlzdGVuZXIoaXNWaWV3cG9ydCA/IG93bmVyRG9jIDogdGFyZ2V0LCBcInNjcm9sbFwiLCBfb25TY3JvbGwpO1xuXG4gICAgICAgIGlmIChzZWxmLmlzUHJlc3NlZCkge1xuICAgICAgICAgIHNlbGYuX3Z4LnJlc2V0KCk7XG5cbiAgICAgICAgICBzZWxmLl92eS5yZXNldCgpO1xuXG4gICAgICAgICAgX3JlbW92ZUxpc3RlbmVyKGlzTm9ybWFsaXplciA/IHRhcmdldCA6IG93bmVyRG9jLCBfZXZlbnRUeXBlc1sxXSwgX29uRHJhZywgdHJ1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICBfcmVtb3ZlTGlzdGVuZXIoaXNWaWV3cG9ydCA/IG93bmVyRG9jIDogdGFyZ2V0LCBcInNjcm9sbFwiLCBvblNjcm9sbCwgY2FwdHVyZSk7XG5cbiAgICAgICAgX3JlbW92ZUxpc3RlbmVyKHRhcmdldCwgXCJ3aGVlbFwiLCBfb25XaGVlbCwgY2FwdHVyZSk7XG5cbiAgICAgICAgX3JlbW92ZUxpc3RlbmVyKHRhcmdldCwgX2V2ZW50VHlwZXNbMF0sIF9vblByZXNzLCBjYXB0dXJlKTtcblxuICAgICAgICBfcmVtb3ZlTGlzdGVuZXIob3duZXJEb2MsIF9ldmVudFR5cGVzWzJdLCBfb25SZWxlYXNlKTtcblxuICAgICAgICBfcmVtb3ZlTGlzdGVuZXIob3duZXJEb2MsIF9ldmVudFR5cGVzWzNdLCBfb25SZWxlYXNlKTtcblxuICAgICAgICBfcmVtb3ZlTGlzdGVuZXIodGFyZ2V0LCBcImNsaWNrXCIsIGNsaWNrQ2FwdHVyZSwgdHJ1ZSk7XG5cbiAgICAgICAgX3JlbW92ZUxpc3RlbmVyKHRhcmdldCwgXCJjbGlja1wiLCBfb25DbGljayk7XG5cbiAgICAgICAgX3JlbW92ZUxpc3RlbmVyKG93bmVyRG9jLCBcImdlc3R1cmVzdGFydFwiLCBfb25HZXN0dXJlU3RhcnQpO1xuXG4gICAgICAgIF9yZW1vdmVMaXN0ZW5lcihvd25lckRvYywgXCJnZXN0dXJlZW5kXCIsIF9vbkdlc3R1cmVFbmQpO1xuXG4gICAgICAgIF9yZW1vdmVMaXN0ZW5lcih0YXJnZXQsIF9wb2ludGVyVHlwZSArIFwiZW50ZXJcIiwgX29uSG92ZXIpO1xuXG4gICAgICAgIF9yZW1vdmVMaXN0ZW5lcih0YXJnZXQsIF9wb2ludGVyVHlwZSArIFwibGVhdmVcIiwgX29uSG92ZXJFbmQpO1xuXG4gICAgICAgIF9yZW1vdmVMaXN0ZW5lcih0YXJnZXQsIF9wb2ludGVyVHlwZSArIFwibW92ZVwiLCBfb25Nb3ZlKTtcblxuICAgICAgICBzZWxmLmlzRW5hYmxlZCA9IHNlbGYuaXNQcmVzc2VkID0gc2VsZi5pc0RyYWdnaW5nID0gZmFsc2U7XG4gICAgICAgIG9uRGlzYWJsZSAmJiBvbkRpc2FibGUoc2VsZik7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHNlbGYua2lsbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHNlbGYuZGlzYWJsZSgpO1xuXG4gICAgICB2YXIgaSA9IF9vYnNlcnZlcnMuaW5kZXhPZihzZWxmKTtcblxuICAgICAgaSA+PSAwICYmIF9vYnNlcnZlcnMuc3BsaWNlKGksIDEpO1xuICAgICAgX25vcm1hbGl6ZXIgPT09IHNlbGYgJiYgKF9ub3JtYWxpemVyID0gMCk7XG4gICAgfTtcblxuICAgIF9vYnNlcnZlcnMucHVzaChzZWxmKTtcblxuICAgIGlzTm9ybWFsaXplciAmJiBfaXNWaWV3cG9ydCh0YXJnZXQpICYmIChfbm9ybWFsaXplciA9IHNlbGYpO1xuICAgIHNlbGYuZW5hYmxlKGV2ZW50KTtcbiAgfTtcblxuICBfY3JlYXRlQ2xhc3MoT2JzZXJ2ZXIsIFt7XG4gICAga2V5OiBcInZlbG9jaXR5WFwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3Z4LmdldFZlbG9jaXR5KCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInZlbG9jaXR5WVwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3Z5LmdldFZlbG9jaXR5KCk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIE9ic2VydmVyO1xufSgpO1xuT2JzZXJ2ZXIudmVyc2lvbiA9IFwiMy4xMC40XCI7XG5cbk9ic2VydmVyLmNyZWF0ZSA9IGZ1bmN0aW9uICh2YXJzKSB7XG4gIHJldHVybiBuZXcgT2JzZXJ2ZXIodmFycyk7XG59O1xuXG5PYnNlcnZlci5yZWdpc3RlciA9IF9pbml0Q29yZTtcblxuT2JzZXJ2ZXIuZ2V0QWxsID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gX29ic2VydmVycy5zbGljZSgpO1xufTtcblxuT2JzZXJ2ZXIuZ2V0QnlJZCA9IGZ1bmN0aW9uIChpZCkge1xuICByZXR1cm4gX29ic2VydmVycy5maWx0ZXIoZnVuY3Rpb24gKG8pIHtcbiAgICByZXR1cm4gby52YXJzLmlkID09PSBpZDtcbiAgfSlbMF07XG59O1xuXG5fZ2V0R1NBUCgpICYmIGdzYXAucmVnaXN0ZXJQbHVnaW4oT2JzZXJ2ZXIpO1xuZXhwb3J0IHsgT2JzZXJ2ZXIgYXMgZGVmYXVsdCwgX2lzVmlld3BvcnQsIF9zY3JvbGxlcnMsIF9nZXRTY3JvbGxGdW5jLCBfZ2V0UHJveHlQcm9wLCBfcHJveGllcywgX2dldFZlbG9jaXR5UHJvcCwgX3ZlcnRpY2FsLCBfaG9yaXpvbnRhbCwgX2dldFRhcmdldCB9OyIsIi8qIVxuICogU2Nyb2xsVHJpZ2dlciAzLjEwLjRcbiAqIGh0dHBzOi8vZ3JlZW5zb2NrLmNvbVxuICpcbiAqIEBsaWNlbnNlIENvcHlyaWdodCAyMDA4LTIwMjIsIEdyZWVuU29jay4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFN1YmplY3QgdG8gdGhlIHRlcm1zIGF0IGh0dHBzOi8vZ3JlZW5zb2NrLmNvbS9zdGFuZGFyZC1saWNlbnNlIG9yIGZvclxuICogQ2x1YiBHcmVlblNvY2sgbWVtYmVycywgdGhlIGFncmVlbWVudCBpc3N1ZWQgd2l0aCB0aGF0IG1lbWJlcnNoaXAuXG4gKiBAYXV0aG9yOiBKYWNrIERveWxlLCBqYWNrQGdyZWVuc29jay5jb21cbiovXG5cbi8qIGVzbGludC1kaXNhYmxlICovXG5pbXBvcnQgeyBPYnNlcnZlciwgX2dldFRhcmdldCwgX3ZlcnRpY2FsLCBfaG9yaXpvbnRhbCwgX3Njcm9sbGVycywgX3Byb3hpZXMsIF9nZXRTY3JvbGxGdW5jLCBfZ2V0UHJveHlQcm9wLCBfZ2V0VmVsb2NpdHlQcm9wIH0gZnJvbSBcIi4vT2JzZXJ2ZXIuanNcIjtcblxudmFyIGdzYXAsXG4gICAgX2NvcmVJbml0dGVkLFxuICAgIF93aW4sXG4gICAgX2RvYyxcbiAgICBfZG9jRWwsXG4gICAgX2JvZHksXG4gICAgX3Jvb3QsXG4gICAgX3Jlc2l6ZURlbGF5LFxuICAgIF90b0FycmF5LFxuICAgIF9jbGFtcCxcbiAgICBfdGltZTIsXG4gICAgX3N5bmNJbnRlcnZhbCxcbiAgICBfcmVmcmVzaGluZyxcbiAgICBfcG9pbnRlcklzRG93bixcbiAgICBfdHJhbnNmb3JtUHJvcCxcbiAgICBfaSxcbiAgICBfcHJldldpZHRoLFxuICAgIF9wcmV2SGVpZ2h0LFxuICAgIF9hdXRvUmVmcmVzaCxcbiAgICBfc29ydCxcbiAgICBfc3VwcHJlc3NPdmVyd3JpdGVzLFxuICAgIF9pZ25vcmVSZXNpemUsXG4gICAgX25vcm1hbGl6ZXIsXG4gICAgX2lnbm9yZU1vYmlsZVJlc2l6ZSxcbiAgICBfYmFzZVNjcmVlbkhlaWdodCxcbiAgICBfYmFzZVNjcmVlbldpZHRoLFxuICAgIF9maXhJT1NCdWcsXG4gICAgX2xpbWl0Q2FsbGJhY2tzLFxuICAgIC8vIGlmIHRydWUsIHdlJ2xsIG9ubHkgdHJpZ2dlciBjYWxsYmFja3MgaWYgdGhlIGFjdGl2ZSBzdGF0ZSB0b2dnbGVzLCBzbyBpZiB5b3Ugc2Nyb2xsIGltbWVkaWF0ZWx5IHBhc3QgYm90aCB0aGUgc3RhcnQgYW5kIGVuZCBwb3NpdGlvbnMgb2YgYSBTY3JvbGxUcmlnZ2VyICh0aHVzIGluYWN0aXZlIHRvIGluYWN0aXZlKSwgbmVpdGhlciBpdHMgb25FbnRlciBub3Igb25MZWF2ZSB3aWxsIGJlIGNhbGxlZC4gVGhpcyBpcyB1c2VmdWwgZHVyaW5nIHN0YXJ0dXAuXG5fc3RhcnR1cCA9IDEsXG4gICAgX2dldFRpbWUgPSBEYXRlLm5vdyxcbiAgICBfdGltZTEgPSBfZ2V0VGltZSgpLFxuICAgIF9sYXN0U2Nyb2xsVGltZSA9IDAsXG4gICAgX2VuYWJsZWQgPSAwLFxuICAgIF9wb2ludGVyRG93bkhhbmRsZXIgPSBmdW5jdGlvbiBfcG9pbnRlckRvd25IYW5kbGVyKCkge1xuICByZXR1cm4gX3BvaW50ZXJJc0Rvd24gPSAxO1xufSxcbiAgICBfcG9pbnRlclVwSGFuZGxlciA9IGZ1bmN0aW9uIF9wb2ludGVyVXBIYW5kbGVyKCkge1xuICByZXR1cm4gX3BvaW50ZXJJc0Rvd24gPSAwO1xufSxcbiAgICBfcGFzc1Rocm91Z2ggPSBmdW5jdGlvbiBfcGFzc1Rocm91Z2godikge1xuICByZXR1cm4gdjtcbn0sXG4gICAgX3JvdW5kID0gZnVuY3Rpb24gX3JvdW5kKHZhbHVlKSB7XG4gIHJldHVybiBNYXRoLnJvdW5kKHZhbHVlICogMTAwMDAwKSAvIDEwMDAwMCB8fCAwO1xufSxcbiAgICBfd2luZG93RXhpc3RzID0gZnVuY3Rpb24gX3dpbmRvd0V4aXN0cygpIHtcbiAgcmV0dXJuIHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCI7XG59LFxuICAgIF9nZXRHU0FQID0gZnVuY3Rpb24gX2dldEdTQVAoKSB7XG4gIHJldHVybiBnc2FwIHx8IF93aW5kb3dFeGlzdHMoKSAmJiAoZ3NhcCA9IHdpbmRvdy5nc2FwKSAmJiBnc2FwLnJlZ2lzdGVyUGx1Z2luICYmIGdzYXA7XG59LFxuICAgIF9pc1ZpZXdwb3J0ID0gZnVuY3Rpb24gX2lzVmlld3BvcnQoZSkge1xuICByZXR1cm4gISF+X3Jvb3QuaW5kZXhPZihlKTtcbn0sXG4gICAgX2dldEJvdW5kc0Z1bmMgPSBmdW5jdGlvbiBfZ2V0Qm91bmRzRnVuYyhlbGVtZW50KSB7XG4gIHJldHVybiBfZ2V0UHJveHlQcm9wKGVsZW1lbnQsIFwiZ2V0Qm91bmRpbmdDbGllbnRSZWN0XCIpIHx8IChfaXNWaWV3cG9ydChlbGVtZW50KSA/IGZ1bmN0aW9uICgpIHtcbiAgICBfd2luT2Zmc2V0cy53aWR0aCA9IF93aW4uaW5uZXJXaWR0aDtcbiAgICBfd2luT2Zmc2V0cy5oZWlnaHQgPSBfd2luLmlubmVySGVpZ2h0O1xuICAgIHJldHVybiBfd2luT2Zmc2V0cztcbiAgfSA6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX2dldEJvdW5kcyhlbGVtZW50KTtcbiAgfSk7XG59LFxuICAgIF9nZXRTaXplRnVuYyA9IGZ1bmN0aW9uIF9nZXRTaXplRnVuYyhzY3JvbGxlciwgaXNWaWV3cG9ydCwgX3JlZikge1xuICB2YXIgZCA9IF9yZWYuZCxcbiAgICAgIGQyID0gX3JlZi5kMixcbiAgICAgIGEgPSBfcmVmLmE7XG4gIHJldHVybiAoYSA9IF9nZXRQcm94eVByb3Aoc2Nyb2xsZXIsIFwiZ2V0Qm91bmRpbmdDbGllbnRSZWN0XCIpKSA/IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gYSgpW2RdO1xuICB9IDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiAoaXNWaWV3cG9ydCA/IF93aW5bXCJpbm5lclwiICsgZDJdIDogc2Nyb2xsZXJbXCJjbGllbnRcIiArIGQyXSkgfHwgMDtcbiAgfTtcbn0sXG4gICAgX2dldE9mZnNldHNGdW5jID0gZnVuY3Rpb24gX2dldE9mZnNldHNGdW5jKGVsZW1lbnQsIGlzVmlld3BvcnQpIHtcbiAgcmV0dXJuICFpc1ZpZXdwb3J0IHx8IH5fcHJveGllcy5pbmRleE9mKGVsZW1lbnQpID8gX2dldEJvdW5kc0Z1bmMoZWxlbWVudCkgOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF93aW5PZmZzZXRzO1xuICB9O1xufSxcbiAgICBfbWF4U2Nyb2xsID0gZnVuY3Rpb24gX21heFNjcm9sbChlbGVtZW50LCBfcmVmMikge1xuICB2YXIgcyA9IF9yZWYyLnMsXG4gICAgICBkMiA9IF9yZWYyLmQyLFxuICAgICAgZCA9IF9yZWYyLmQsXG4gICAgICBhID0gX3JlZjIuYTtcbiAgcmV0dXJuIChzID0gXCJzY3JvbGxcIiArIGQyKSAmJiAoYSA9IF9nZXRQcm94eVByb3AoZWxlbWVudCwgcykpID8gYSgpIC0gX2dldEJvdW5kc0Z1bmMoZWxlbWVudCkoKVtkXSA6IF9pc1ZpZXdwb3J0KGVsZW1lbnQpID8gKF9kb2NFbFtzXSB8fCBfYm9keVtzXSkgLSAoX3dpbltcImlubmVyXCIgKyBkMl0gfHwgX2RvY0VsW1wiY2xpZW50XCIgKyBkMl0gfHwgX2JvZHlbXCJjbGllbnRcIiArIGQyXSkgOiBlbGVtZW50W3NdIC0gZWxlbWVudFtcIm9mZnNldFwiICsgZDJdO1xufSxcbiAgICBfaXRlcmF0ZUF1dG9SZWZyZXNoID0gZnVuY3Rpb24gX2l0ZXJhdGVBdXRvUmVmcmVzaChmdW5jLCBldmVudHMpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBfYXV0b1JlZnJlc2gubGVuZ3RoOyBpICs9IDMpIHtcbiAgICAoIWV2ZW50cyB8fCB+ZXZlbnRzLmluZGV4T2YoX2F1dG9SZWZyZXNoW2kgKyAxXSkpICYmIGZ1bmMoX2F1dG9SZWZyZXNoW2ldLCBfYXV0b1JlZnJlc2hbaSArIDFdLCBfYXV0b1JlZnJlc2hbaSArIDJdKTtcbiAgfVxufSxcbiAgICBfaXNTdHJpbmcgPSBmdW5jdGlvbiBfaXNTdHJpbmcodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIjtcbn0sXG4gICAgX2lzRnVuY3Rpb24gPSBmdW5jdGlvbiBfaXNGdW5jdGlvbih2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSBcImZ1bmN0aW9uXCI7XG59LFxuICAgIF9pc051bWJlciA9IGZ1bmN0aW9uIF9pc051bWJlcih2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSBcIm51bWJlclwiO1xufSxcbiAgICBfaXNPYmplY3QgPSBmdW5jdGlvbiBfaXNPYmplY3QodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIjtcbn0sXG4gICAgX2NhbGxJZkZ1bmMgPSBmdW5jdGlvbiBfY2FsbElmRnVuYyh2YWx1ZSkge1xuICByZXR1cm4gX2lzRnVuY3Rpb24odmFsdWUpICYmIHZhbHVlKCk7XG59LFxuICAgIF9jb21iaW5lRnVuYyA9IGZ1bmN0aW9uIF9jb21iaW5lRnVuYyhmMSwgZjIpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcmVzdWx0MSA9IF9jYWxsSWZGdW5jKGYxKSxcbiAgICAgICAgcmVzdWx0MiA9IF9jYWxsSWZGdW5jKGYyKTtcblxuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICBfY2FsbElmRnVuYyhyZXN1bHQxKTtcblxuICAgICAgX2NhbGxJZkZ1bmMocmVzdWx0Mik7XG4gICAgfTtcbiAgfTtcbn0sXG4gICAgX2VuZEFuaW1hdGlvbiA9IGZ1bmN0aW9uIF9lbmRBbmltYXRpb24oYW5pbWF0aW9uLCByZXZlcnNlZCwgcGF1c2UpIHtcbiAgcmV0dXJuIGFuaW1hdGlvbiAmJiBhbmltYXRpb24ucHJvZ3Jlc3MocmV2ZXJzZWQgPyAwIDogMSkgJiYgcGF1c2UgJiYgYW5pbWF0aW9uLnBhdXNlKCk7XG59LFxuICAgIF9jYWxsYmFjayA9IGZ1bmN0aW9uIF9jYWxsYmFjayhzZWxmLCBmdW5jKSB7XG4gIGlmIChzZWxmLmVuYWJsZWQpIHtcbiAgICB2YXIgcmVzdWx0ID0gZnVuYyhzZWxmKTtcbiAgICByZXN1bHQgJiYgcmVzdWx0LnRvdGFsVGltZSAmJiAoc2VsZi5jYWxsYmFja0FuaW1hdGlvbiA9IHJlc3VsdCk7XG4gIH1cbn0sXG4gICAgX2FicyA9IE1hdGguYWJzLFxuICAgIF9zY3JvbGxMZWZ0ID0gXCJzY3JvbGxMZWZ0XCIsXG4gICAgX3Njcm9sbFRvcCA9IFwic2Nyb2xsVG9wXCIsXG4gICAgX2xlZnQgPSBcImxlZnRcIixcbiAgICBfdG9wID0gXCJ0b3BcIixcbiAgICBfcmlnaHQgPSBcInJpZ2h0XCIsXG4gICAgX2JvdHRvbSA9IFwiYm90dG9tXCIsXG4gICAgX3dpZHRoID0gXCJ3aWR0aFwiLFxuICAgIF9oZWlnaHQgPSBcImhlaWdodFwiLFxuICAgIF9SaWdodCA9IFwiUmlnaHRcIixcbiAgICBfTGVmdCA9IFwiTGVmdFwiLFxuICAgIF9Ub3AgPSBcIlRvcFwiLFxuICAgIF9Cb3R0b20gPSBcIkJvdHRvbVwiLFxuICAgIF9wYWRkaW5nID0gXCJwYWRkaW5nXCIsXG4gICAgX21hcmdpbiA9IFwibWFyZ2luXCIsXG4gICAgX1dpZHRoID0gXCJXaWR0aFwiLFxuICAgIF9IZWlnaHQgPSBcIkhlaWdodFwiLFxuICAgIF9weCA9IFwicHhcIixcbiAgICBfZ2V0Q29tcHV0ZWRTdHlsZSA9IGZ1bmN0aW9uIF9nZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpIHtcbiAgcmV0dXJuIF93aW4uZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KTtcbn0sXG4gICAgX21ha2VQb3NpdGlvbmFibGUgPSBmdW5jdGlvbiBfbWFrZVBvc2l0aW9uYWJsZShlbGVtZW50KSB7XG4gIC8vIGlmIHRoZSBlbGVtZW50IGFscmVhZHkgaGFzIHBvc2l0aW9uOiBhYnNvbHV0ZSBvciBmaXhlZCwgbGVhdmUgdGhhdCwgb3RoZXJ3aXNlIG1ha2UgaXQgcG9zaXRpb246IHJlbGF0aXZlXG4gIHZhciBwb3NpdGlvbiA9IF9nZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpLnBvc2l0aW9uO1xuXG4gIGVsZW1lbnQuc3R5bGUucG9zaXRpb24gPSBwb3NpdGlvbiA9PT0gXCJhYnNvbHV0ZVwiIHx8IHBvc2l0aW9uID09PSBcImZpeGVkXCIgPyBwb3NpdGlvbiA6IFwicmVsYXRpdmVcIjtcbn0sXG4gICAgX3NldERlZmF1bHRzID0gZnVuY3Rpb24gX3NldERlZmF1bHRzKG9iaiwgZGVmYXVsdHMpIHtcbiAgZm9yICh2YXIgcCBpbiBkZWZhdWx0cykge1xuICAgIHAgaW4gb2JqIHx8IChvYmpbcF0gPSBkZWZhdWx0c1twXSk7XG4gIH1cblxuICByZXR1cm4gb2JqO1xufSxcbiAgICBfZ2V0Qm91bmRzID0gZnVuY3Rpb24gX2dldEJvdW5kcyhlbGVtZW50LCB3aXRob3V0VHJhbnNmb3Jtcykge1xuICB2YXIgdHdlZW4gPSB3aXRob3V0VHJhbnNmb3JtcyAmJiBfZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KVtfdHJhbnNmb3JtUHJvcF0gIT09IFwibWF0cml4KDEsIDAsIDAsIDEsIDAsIDApXCIgJiYgZ3NhcC50byhlbGVtZW50LCB7XG4gICAgeDogMCxcbiAgICB5OiAwLFxuICAgIHhQZXJjZW50OiAwLFxuICAgIHlQZXJjZW50OiAwLFxuICAgIHJvdGF0aW9uOiAwLFxuICAgIHJvdGF0aW9uWDogMCxcbiAgICByb3RhdGlvblk6IDAsXG4gICAgc2NhbGU6IDEsXG4gICAgc2tld1g6IDAsXG4gICAgc2tld1k6IDBcbiAgfSkucHJvZ3Jlc3MoMSksXG4gICAgICBib3VuZHMgPSBlbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICB0d2VlbiAmJiB0d2Vlbi5wcm9ncmVzcygwKS5raWxsKCk7XG4gIHJldHVybiBib3VuZHM7XG59LFxuICAgIF9nZXRTaXplID0gZnVuY3Rpb24gX2dldFNpemUoZWxlbWVudCwgX3JlZjMpIHtcbiAgdmFyIGQyID0gX3JlZjMuZDI7XG4gIHJldHVybiBlbGVtZW50W1wib2Zmc2V0XCIgKyBkMl0gfHwgZWxlbWVudFtcImNsaWVudFwiICsgZDJdIHx8IDA7XG59LFxuICAgIF9nZXRMYWJlbFJhdGlvQXJyYXkgPSBmdW5jdGlvbiBfZ2V0TGFiZWxSYXRpb0FycmF5KHRpbWVsaW5lKSB7XG4gIHZhciBhID0gW10sXG4gICAgICBsYWJlbHMgPSB0aW1lbGluZS5sYWJlbHMsXG4gICAgICBkdXJhdGlvbiA9IHRpbWVsaW5lLmR1cmF0aW9uKCksXG4gICAgICBwO1xuXG4gIGZvciAocCBpbiBsYWJlbHMpIHtcbiAgICBhLnB1c2gobGFiZWxzW3BdIC8gZHVyYXRpb24pO1xuICB9XG5cbiAgcmV0dXJuIGE7XG59LFxuICAgIF9nZXRDbG9zZXN0TGFiZWwgPSBmdW5jdGlvbiBfZ2V0Q2xvc2VzdExhYmVsKGFuaW1hdGlvbikge1xuICByZXR1cm4gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgcmV0dXJuIGdzYXAudXRpbHMuc25hcChfZ2V0TGFiZWxSYXRpb0FycmF5KGFuaW1hdGlvbiksIHZhbHVlKTtcbiAgfTtcbn0sXG4gICAgX3NuYXBEaXJlY3Rpb25hbCA9IGZ1bmN0aW9uIF9zbmFwRGlyZWN0aW9uYWwoc25hcEluY3JlbWVudE9yQXJyYXkpIHtcbiAgdmFyIHNuYXAgPSBnc2FwLnV0aWxzLnNuYXAoc25hcEluY3JlbWVudE9yQXJyYXkpLFxuICAgICAgYSA9IEFycmF5LmlzQXJyYXkoc25hcEluY3JlbWVudE9yQXJyYXkpICYmIHNuYXBJbmNyZW1lbnRPckFycmF5LnNsaWNlKDApLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICByZXR1cm4gYSAtIGI7XG4gIH0pO1xuICByZXR1cm4gYSA/IGZ1bmN0aW9uICh2YWx1ZSwgZGlyZWN0aW9uLCB0aHJlc2hvbGQpIHtcbiAgICBpZiAodGhyZXNob2xkID09PSB2b2lkIDApIHtcbiAgICAgIHRocmVzaG9sZCA9IDFlLTM7XG4gICAgfVxuXG4gICAgdmFyIGk7XG5cbiAgICBpZiAoIWRpcmVjdGlvbikge1xuICAgICAgcmV0dXJuIHNuYXAodmFsdWUpO1xuICAgIH1cblxuICAgIGlmIChkaXJlY3Rpb24gPiAwKSB7XG4gICAgICB2YWx1ZSAtPSB0aHJlc2hvbGQ7IC8vIHRvIGF2b2lkIHJvdW5kaW5nIGVycm9ycy4gSWYgd2UncmUgdG9vIHN0cmljdCwgaXQgbWlnaHQgc25hcCBmb3J3YXJkLCB0aGVuIGltbWVkaWF0ZWx5IGFnYWluLCBhbmQgYWdhaW4uXG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChhW2ldID49IHZhbHVlKSB7XG4gICAgICAgICAgcmV0dXJuIGFbaV07XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGFbaSAtIDFdO1xuICAgIH0gZWxzZSB7XG4gICAgICBpID0gYS5sZW5ndGg7XG4gICAgICB2YWx1ZSArPSB0aHJlc2hvbGQ7XG5cbiAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgaWYgKGFbaV0gPD0gdmFsdWUpIHtcbiAgICAgICAgICByZXR1cm4gYVtpXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBhWzBdO1xuICB9IDogZnVuY3Rpb24gKHZhbHVlLCBkaXJlY3Rpb24sIHRocmVzaG9sZCkge1xuICAgIGlmICh0aHJlc2hvbGQgPT09IHZvaWQgMCkge1xuICAgICAgdGhyZXNob2xkID0gMWUtMztcbiAgICB9XG5cbiAgICB2YXIgc25hcHBlZCA9IHNuYXAodmFsdWUpO1xuICAgIHJldHVybiAhZGlyZWN0aW9uIHx8IE1hdGguYWJzKHNuYXBwZWQgLSB2YWx1ZSkgPCB0aHJlc2hvbGQgfHwgc25hcHBlZCAtIHZhbHVlIDwgMCA9PT0gZGlyZWN0aW9uIDwgMCA/IHNuYXBwZWQgOiBzbmFwKGRpcmVjdGlvbiA8IDAgPyB2YWx1ZSAtIHNuYXBJbmNyZW1lbnRPckFycmF5IDogdmFsdWUgKyBzbmFwSW5jcmVtZW50T3JBcnJheSk7XG4gIH07XG59LFxuICAgIF9nZXRMYWJlbEF0RGlyZWN0aW9uID0gZnVuY3Rpb24gX2dldExhYmVsQXREaXJlY3Rpb24odGltZWxpbmUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICh2YWx1ZSwgc3QpIHtcbiAgICByZXR1cm4gX3NuYXBEaXJlY3Rpb25hbChfZ2V0TGFiZWxSYXRpb0FycmF5KHRpbWVsaW5lKSkodmFsdWUsIHN0LmRpcmVjdGlvbik7XG4gIH07XG59LFxuICAgIF9tdWx0aUxpc3RlbmVyID0gZnVuY3Rpb24gX211bHRpTGlzdGVuZXIoZnVuYywgZWxlbWVudCwgdHlwZXMsIGNhbGxiYWNrKSB7XG4gIHJldHVybiB0eXBlcy5zcGxpdChcIixcIikuZm9yRWFjaChmdW5jdGlvbiAodHlwZSkge1xuICAgIHJldHVybiBmdW5jKGVsZW1lbnQsIHR5cGUsIGNhbGxiYWNrKTtcbiAgfSk7XG59LFxuICAgIF9hZGRMaXN0ZW5lciA9IGZ1bmN0aW9uIF9hZGRMaXN0ZW5lcihlbGVtZW50LCB0eXBlLCBmdW5jLCBub25QYXNzaXZlLCBjYXB0dXJlKSB7XG4gIHJldHVybiBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIodHlwZSwgZnVuYywge1xuICAgIHBhc3NpdmU6ICFub25QYXNzaXZlLFxuICAgIGNhcHR1cmU6ICEhY2FwdHVyZVxuICB9KTtcbn0sXG4gICAgX3JlbW92ZUxpc3RlbmVyID0gZnVuY3Rpb24gX3JlbW92ZUxpc3RlbmVyKGVsZW1lbnQsIHR5cGUsIGZ1bmMsIGNhcHR1cmUpIHtcbiAgcmV0dXJuIGVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcih0eXBlLCBmdW5jLCAhIWNhcHR1cmUpO1xufSxcbiAgICBfd2hlZWxMaXN0ZW5lciA9IGZ1bmN0aW9uIF93aGVlbExpc3RlbmVyKGZ1bmMsIGVsLCBzY3JvbGxGdW5jKSB7XG4gIHJldHVybiBzY3JvbGxGdW5jICYmIHNjcm9sbEZ1bmMud2hlZWxIYW5kbGVyICYmIGZ1bmMoZWwsIFwid2hlZWxcIiwgc2Nyb2xsRnVuYyk7XG59LFxuICAgIF9tYXJrZXJEZWZhdWx0cyA9IHtcbiAgc3RhcnRDb2xvcjogXCJncmVlblwiLFxuICBlbmRDb2xvcjogXCJyZWRcIixcbiAgaW5kZW50OiAwLFxuICBmb250U2l6ZTogXCIxNnB4XCIsXG4gIGZvbnRXZWlnaHQ6IFwibm9ybWFsXCJcbn0sXG4gICAgX2RlZmF1bHRzID0ge1xuICB0b2dnbGVBY3Rpb25zOiBcInBsYXlcIixcbiAgYW50aWNpcGF0ZVBpbjogMFxufSxcbiAgICBfa2V5d29yZHMgPSB7XG4gIHRvcDogMCxcbiAgbGVmdDogMCxcbiAgY2VudGVyOiAwLjUsXG4gIGJvdHRvbTogMSxcbiAgcmlnaHQ6IDFcbn0sXG4gICAgX29mZnNldFRvUHggPSBmdW5jdGlvbiBfb2Zmc2V0VG9QeCh2YWx1ZSwgc2l6ZSkge1xuICBpZiAoX2lzU3RyaW5nKHZhbHVlKSkge1xuICAgIHZhciBlcUluZGV4ID0gdmFsdWUuaW5kZXhPZihcIj1cIiksXG4gICAgICAgIHJlbGF0aXZlID0gfmVxSW5kZXggPyArKHZhbHVlLmNoYXJBdChlcUluZGV4IC0gMSkgKyAxKSAqIHBhcnNlRmxvYXQodmFsdWUuc3Vic3RyKGVxSW5kZXggKyAxKSkgOiAwO1xuXG4gICAgaWYgKH5lcUluZGV4KSB7XG4gICAgICB2YWx1ZS5pbmRleE9mKFwiJVwiKSA+IGVxSW5kZXggJiYgKHJlbGF0aXZlICo9IHNpemUgLyAxMDApO1xuICAgICAgdmFsdWUgPSB2YWx1ZS5zdWJzdHIoMCwgZXFJbmRleCAtIDEpO1xuICAgIH1cblxuICAgIHZhbHVlID0gcmVsYXRpdmUgKyAodmFsdWUgaW4gX2tleXdvcmRzID8gX2tleXdvcmRzW3ZhbHVlXSAqIHNpemUgOiB+dmFsdWUuaW5kZXhPZihcIiVcIikgPyBwYXJzZUZsb2F0KHZhbHVlKSAqIHNpemUgLyAxMDAgOiBwYXJzZUZsb2F0KHZhbHVlKSB8fCAwKTtcbiAgfVxuXG4gIHJldHVybiB2YWx1ZTtcbn0sXG4gICAgX2NyZWF0ZU1hcmtlciA9IGZ1bmN0aW9uIF9jcmVhdGVNYXJrZXIodHlwZSwgbmFtZSwgY29udGFpbmVyLCBkaXJlY3Rpb24sIF9yZWY0LCBvZmZzZXQsIG1hdGNoV2lkdGhFbCwgY29udGFpbmVyQW5pbWF0aW9uKSB7XG4gIHZhciBzdGFydENvbG9yID0gX3JlZjQuc3RhcnRDb2xvcixcbiAgICAgIGVuZENvbG9yID0gX3JlZjQuZW5kQ29sb3IsXG4gICAgICBmb250U2l6ZSA9IF9yZWY0LmZvbnRTaXplLFxuICAgICAgaW5kZW50ID0gX3JlZjQuaW5kZW50LFxuICAgICAgZm9udFdlaWdodCA9IF9yZWY0LmZvbnRXZWlnaHQ7XG5cbiAgdmFyIGUgPSBfZG9jLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiksXG4gICAgICB1c2VGaXhlZFBvc2l0aW9uID0gX2lzVmlld3BvcnQoY29udGFpbmVyKSB8fCBfZ2V0UHJveHlQcm9wKGNvbnRhaW5lciwgXCJwaW5UeXBlXCIpID09PSBcImZpeGVkXCIsXG4gICAgICBpc1Njcm9sbGVyID0gdHlwZS5pbmRleE9mKFwic2Nyb2xsZXJcIikgIT09IC0xLFxuICAgICAgcGFyZW50ID0gdXNlRml4ZWRQb3NpdGlvbiA/IF9ib2R5IDogY29udGFpbmVyLFxuICAgICAgaXNTdGFydCA9IHR5cGUuaW5kZXhPZihcInN0YXJ0XCIpICE9PSAtMSxcbiAgICAgIGNvbG9yID0gaXNTdGFydCA/IHN0YXJ0Q29sb3IgOiBlbmRDb2xvcixcbiAgICAgIGNzcyA9IFwiYm9yZGVyLWNvbG9yOlwiICsgY29sb3IgKyBcIjtmb250LXNpemU6XCIgKyBmb250U2l6ZSArIFwiO2NvbG9yOlwiICsgY29sb3IgKyBcIjtmb250LXdlaWdodDpcIiArIGZvbnRXZWlnaHQgKyBcIjtwb2ludGVyLWV2ZW50czpub25lO3doaXRlLXNwYWNlOm5vd3JhcDtmb250LWZhbWlseTpzYW5zLXNlcmlmLEFyaWFsO3otaW5kZXg6MTAwMDtwYWRkaW5nOjRweCA4cHg7Ym9yZGVyLXdpZHRoOjA7Ym9yZGVyLXN0eWxlOnNvbGlkO1wiO1xuXG4gIGNzcyArPSBcInBvc2l0aW9uOlwiICsgKChpc1Njcm9sbGVyIHx8IGNvbnRhaW5lckFuaW1hdGlvbikgJiYgdXNlRml4ZWRQb3NpdGlvbiA/IFwiZml4ZWQ7XCIgOiBcImFic29sdXRlO1wiKTtcbiAgKGlzU2Nyb2xsZXIgfHwgY29udGFpbmVyQW5pbWF0aW9uIHx8ICF1c2VGaXhlZFBvc2l0aW9uKSAmJiAoY3NzICs9IChkaXJlY3Rpb24gPT09IF92ZXJ0aWNhbCA/IF9yaWdodCA6IF9ib3R0b20pICsgXCI6XCIgKyAob2Zmc2V0ICsgcGFyc2VGbG9hdChpbmRlbnQpKSArIFwicHg7XCIpO1xuICBtYXRjaFdpZHRoRWwgJiYgKGNzcyArPSBcImJveC1zaXppbmc6Ym9yZGVyLWJveDt0ZXh0LWFsaWduOmxlZnQ7d2lkdGg6XCIgKyBtYXRjaFdpZHRoRWwub2Zmc2V0V2lkdGggKyBcInB4O1wiKTtcbiAgZS5faXNTdGFydCA9IGlzU3RhcnQ7XG4gIGUuc2V0QXR0cmlidXRlKFwiY2xhc3NcIiwgXCJnc2FwLW1hcmtlci1cIiArIHR5cGUgKyAobmFtZSA/IFwiIG1hcmtlci1cIiArIG5hbWUgOiBcIlwiKSk7XG4gIGUuc3R5bGUuY3NzVGV4dCA9IGNzcztcbiAgZS5pbm5lclRleHQgPSBuYW1lIHx8IG5hbWUgPT09IDAgPyB0eXBlICsgXCItXCIgKyBuYW1lIDogdHlwZTtcbiAgcGFyZW50LmNoaWxkcmVuWzBdID8gcGFyZW50Lmluc2VydEJlZm9yZShlLCBwYXJlbnQuY2hpbGRyZW5bMF0pIDogcGFyZW50LmFwcGVuZENoaWxkKGUpO1xuICBlLl9vZmZzZXQgPSBlW1wib2Zmc2V0XCIgKyBkaXJlY3Rpb24ub3AuZDJdO1xuXG4gIF9wb3NpdGlvbk1hcmtlcihlLCAwLCBkaXJlY3Rpb24sIGlzU3RhcnQpO1xuXG4gIHJldHVybiBlO1xufSxcbiAgICBfcG9zaXRpb25NYXJrZXIgPSBmdW5jdGlvbiBfcG9zaXRpb25NYXJrZXIobWFya2VyLCBzdGFydCwgZGlyZWN0aW9uLCBmbGlwcGVkKSB7XG4gIHZhciB2YXJzID0ge1xuICAgIGRpc3BsYXk6IFwiYmxvY2tcIlxuICB9LFxuICAgICAgc2lkZSA9IGRpcmVjdGlvbltmbGlwcGVkID8gXCJvczJcIiA6IFwicDJcIl0sXG4gICAgICBvcHBvc2l0ZVNpZGUgPSBkaXJlY3Rpb25bZmxpcHBlZCA/IFwicDJcIiA6IFwib3MyXCJdO1xuICBtYXJrZXIuX2lzRmxpcHBlZCA9IGZsaXBwZWQ7XG4gIHZhcnNbZGlyZWN0aW9uLmEgKyBcIlBlcmNlbnRcIl0gPSBmbGlwcGVkID8gLTEwMCA6IDA7XG4gIHZhcnNbZGlyZWN0aW9uLmFdID0gZmxpcHBlZCA/IFwiMXB4XCIgOiAwO1xuICB2YXJzW1wiYm9yZGVyXCIgKyBzaWRlICsgX1dpZHRoXSA9IDE7XG4gIHZhcnNbXCJib3JkZXJcIiArIG9wcG9zaXRlU2lkZSArIF9XaWR0aF0gPSAwO1xuICB2YXJzW2RpcmVjdGlvbi5wXSA9IHN0YXJ0ICsgXCJweFwiO1xuICBnc2FwLnNldChtYXJrZXIsIHZhcnMpO1xufSxcbiAgICBfdHJpZ2dlcnMgPSBbXSxcbiAgICBfaWRzID0ge30sXG4gICAgX3JhZklELFxuICAgIF9zeW5jID0gZnVuY3Rpb24gX3N5bmMoKSB7XG4gIHJldHVybiBfZ2V0VGltZSgpIC0gX2xhc3RTY3JvbGxUaW1lID4gMzQgJiYgX3VwZGF0ZUFsbCgpO1xufSxcbiAgICBfb25TY3JvbGwgPSBmdW5jdGlvbiBfb25TY3JvbGwoKSB7XG4gIC8vIHByZXZpb3VzbHksIHdlIHRyaWVkIHRvIG9wdGltaXplIHBlcmZvcm1hbmNlIGJ5IGJhdGNoaW5nL2RlZmVycmluZyB0byB0aGUgbmV4dCByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKSwgYnV0IGRpc2NvdmVyZWQgdGhhdCBTYWZhcmkgaGFzIGEgZmV3IGJ1Z3MgdGhhdCBtYWtlIHRoaXMgdW53b3JrYWJsZSAoZXNwZWNpYWxseSBvbiBpT1MpLiBTZWUgaHR0cHM6Ly9jb2RlcGVuLmlvL0dyZWVuU29jay9wZW4vMTZjNDM1YjEyZWYwOWMzODEyNTIwNDgxOGU3YjQ1ZmM/ZWRpdG9ycz0wMDEwIGFuZCBodHRwczovL2NvZGVwZW4uaW8vR3JlZW5Tb2NrL3Blbi9Kak94WXBRLzNkZDY1Y2NlYzVhNjBmMWQ4NjJjMzU1ZDg0ZDE0NTYyP2VkaXRvcnM9MDAxMCBhbmQgaHR0cHM6Ly9jb2RlcGVuLmlvL0dyZWVuU29jay9wZW4vRXhiclBOYS8wODdjZWYxOTdkYzM1NDQ1YTA5NTFlODkzNWM0MTUwMz9lZGl0b3JzPTAwMTBcbiAgaWYgKCFfbm9ybWFsaXplciB8fCAhX25vcm1hbGl6ZXIuaXNQcmVzc2VkIHx8IF9ub3JtYWxpemVyLnN0YXJ0WCA+IF9ib2R5LmNsaWVudFdpZHRoKSB7XG4gICAgLy8gaWYgdGhlIHVzZXIgaXMgZHJhZ2dpbmcgdGhlIHNjcm9sbGJhciwgYWxsb3cgaXQuXG4gICAgX3Njcm9sbGVycy5jYWNoZSsrO1xuICAgIF9yYWZJRCB8fCAoX3JhZklEID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKF91cGRhdGVBbGwpKTtcbiAgICBfbGFzdFNjcm9sbFRpbWUgfHwgX2Rpc3BhdGNoKFwic2Nyb2xsU3RhcnRcIik7XG4gICAgX2xhc3RTY3JvbGxUaW1lID0gX2dldFRpbWUoKTtcbiAgfVxufSxcbiAgICBfc2V0QmFzZURpbWVuc2lvbnMgPSBmdW5jdGlvbiBfc2V0QmFzZURpbWVuc2lvbnMoKSB7XG4gIF9iYXNlU2NyZWVuV2lkdGggPSBfd2luLmlubmVyV2lkdGg7XG4gIF9iYXNlU2NyZWVuSGVpZ2h0ID0gX3dpbi5pbm5lckhlaWdodDtcbn0sXG4gICAgX29uUmVzaXplID0gZnVuY3Rpb24gX29uUmVzaXplKCkge1xuICBfc2Nyb2xsZXJzLmNhY2hlKys7XG4gICFfcmVmcmVzaGluZyAmJiAhX2lnbm9yZVJlc2l6ZSAmJiAhX2RvYy5mdWxsc2NyZWVuRWxlbWVudCAmJiAhX2RvYy53ZWJraXRGdWxsc2NyZWVuRWxlbWVudCAmJiAoIV9pZ25vcmVNb2JpbGVSZXNpemUgfHwgX2Jhc2VTY3JlZW5XaWR0aCAhPT0gX3dpbi5pbm5lcldpZHRoIHx8IE1hdGguYWJzKF93aW4uaW5uZXJIZWlnaHQgLSBfYmFzZVNjcmVlbkhlaWdodCkgPiBfd2luLmlubmVySGVpZ2h0ICogMC4yNSkgJiYgX3Jlc2l6ZURlbGF5LnJlc3RhcnQodHJ1ZSk7XG59LFxuICAgIC8vIGlnbm9yZSByZXNpemVzIHRyaWdnZXJlZCBieSByZWZyZXNoKClcbl9saXN0ZW5lcnMgPSB7fSxcbiAgICBfZW1wdHlBcnJheSA9IFtdLFxuICAgIF9tZWRpYSA9IFtdLFxuICAgIF9jcmVhdGluZ01lZGlhLFxuICAgIC8vIHdoZW4gU2Nyb2xsVHJpZ2dlci5tYXRjaE1lZGlhKCkgaXMgY2FsbGVkLCB3ZSByZWNvcmQgdGhlIGN1cnJlbnQgbWVkaWEga2V5IGhlcmUgKGxpa2UgXCIobWluLXdpZHRoOiA4MDBweClcIikgc28gdGhhdCB3ZSBjYW4gYXNzaWduIGl0IHRvIGV2ZXJ5dGhpbmcgdGhhdCdzIGNyZWF0ZWQgZHVyaW5nIHRoYXQgY2FsbC4gVGhlbiB3ZSBjYW4gcmV2ZXJ0IGp1c3QgdGhvc2Ugd2hlbiBuZWNlc3NhcnkuIEluIHRoZSBTY3JvbGxUcmlnZ2VyJ3MgaW5pdCgpIGNhbGwsIHRoZSBfY3JlYXRpbmdNZWRpYSBpcyByZWNvcmRlZCBhcyBhIFwibWVkaWFcIiBwcm9wZXJ0eSBvbiB0aGUgaW5zdGFuY2UuXG5fbGFzdE1lZGlhVGljayxcbiAgICBfb25NZWRpYUNoYW5nZSA9IGZ1bmN0aW9uIF9vbk1lZGlhQ2hhbmdlKGUpIHtcbiAgdmFyIHRpY2sgPSBnc2FwLnRpY2tlci5mcmFtZSxcbiAgICAgIG1hdGNoZXMgPSBbXSxcbiAgICAgIGkgPSAwLFxuICAgICAgaW5kZXg7XG5cbiAgaWYgKF9sYXN0TWVkaWFUaWNrICE9PSB0aWNrIHx8IF9zdGFydHVwKSB7XG4gICAgX3JldmVydEFsbCgpO1xuXG4gICAgZm9yICg7IGkgPCBfbWVkaWEubGVuZ3RoOyBpICs9IDQpIHtcbiAgICAgIGluZGV4ID0gX3dpbi5tYXRjaE1lZGlhKF9tZWRpYVtpXSkubWF0Y2hlcztcblxuICAgICAgaWYgKGluZGV4ICE9PSBfbWVkaWFbaSArIDNdKSB7XG4gICAgICAgIC8vIG5vdGU6IHNvbWUgYnJvd3NlcnMgZmlyZSB0aGUgbWF0Y2hNZWRpYSBldmVudCBtdWx0aXBsZSB0aW1lcywgbGlrZSB3aGVuIGdvaW5nIGZ1bGwgc2NyZWVuLCBzbyB3ZSBzaG91bGRuJ3QgY2FsbCB0aGUgZnVuY3Rpb24gbXVsdGlwbGUgdGltZXMuIENoZWNrIHRvIHNlZSBpZiBpdCdzIGFscmVhZHkgbWF0Y2hlZC5cbiAgICAgICAgX21lZGlhW2kgKyAzXSA9IGluZGV4O1xuICAgICAgICBpbmRleCA/IG1hdGNoZXMucHVzaChpKSA6IF9yZXZlcnRBbGwoMSwgX21lZGlhW2ldKSB8fCBfaXNGdW5jdGlvbihfbWVkaWFbaSArIDJdKSAmJiBfbWVkaWFbaSArIDJdKCk7IC8vIEZpcmVmb3ggZG9lc24ndCB1cGRhdGUgdGhlIFwibWF0Y2hlc1wiIHByb3BlcnR5IG9mIHRoZSBNZWRpYVF1ZXJ5TGlzdCBvYmplY3QgY29ycmVjdGx5IC0gaXQgb25seSBkb2VzIHNvIGFzIGl0IGNhbGxzIGl0cyBjaGFuZ2UgaGFuZGxlciAtIHNvIHdlIG11c3QgcmUtY3JlYXRlIGEgbWVkaWEgcXVlcnkgaGVyZSB0byBlbnN1cmUgaXQncyBhY2N1cmF0ZS5cbiAgICAgIH1cbiAgICB9XG5cbiAgICBfcmV2ZXJ0UmVjb3JkZWQoKTsgLy8gaW4gY2FzZSBraWxsaW5nL3JldmVydGluZyBhbnkgb2YgdGhlIGFuaW1hdGlvbnMgYWN0dWFsbHkgYWRkZWQgaW5saW5lIHN0eWxlcyBiYWNrLlxuXG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgbWF0Y2hlcy5sZW5ndGg7IGkrKykge1xuICAgICAgaW5kZXggPSBtYXRjaGVzW2ldO1xuICAgICAgX2NyZWF0aW5nTWVkaWEgPSBfbWVkaWFbaW5kZXhdO1xuICAgICAgX21lZGlhW2luZGV4ICsgMl0gPSBfbWVkaWFbaW5kZXggKyAxXShlKTtcbiAgICB9XG5cbiAgICBfY3JlYXRpbmdNZWRpYSA9IDA7XG4gICAgX2NvcmVJbml0dGVkICYmIF9yZWZyZXNoQWxsKDAsIDEpO1xuICAgIF9sYXN0TWVkaWFUaWNrID0gdGljaztcblxuICAgIF9kaXNwYXRjaChcIm1hdGNoTWVkaWFcIik7XG4gIH1cbn0sXG4gICAgX3NvZnRSZWZyZXNoID0gZnVuY3Rpb24gX3NvZnRSZWZyZXNoKCkge1xuICByZXR1cm4gX3JlbW92ZUxpc3RlbmVyKFNjcm9sbFRyaWdnZXIsIFwic2Nyb2xsRW5kXCIsIF9zb2Z0UmVmcmVzaCkgfHwgX3JlZnJlc2hBbGwodHJ1ZSk7XG59LFxuICAgIF9kaXNwYXRjaCA9IGZ1bmN0aW9uIF9kaXNwYXRjaCh0eXBlKSB7XG4gIHJldHVybiBfbGlzdGVuZXJzW3R5cGVdICYmIF9saXN0ZW5lcnNbdHlwZV0ubWFwKGZ1bmN0aW9uIChmKSB7XG4gICAgcmV0dXJuIGYoKTtcbiAgfSkgfHwgX2VtcHR5QXJyYXk7XG59LFxuICAgIF9zYXZlZFN0eWxlcyA9IFtdLFxuICAgIC8vIHdoZW4gU2Nyb2xsVHJpZ2dlci5zYXZlU3R5bGVzKCkgaXMgY2FsbGVkLCB0aGUgaW5saW5lIHN0eWxlcyBhcmUgcmVjb3JkZWQgaW4gdGhpcyBBcnJheSBpbiBhIHNlcXVlbnRpYWwgZm9ybWF0IGxpa2UgW2VsZW1lbnQsIGNzc1RleHQsIGdzQ2FjaGUsIG1lZGlhXS4gVGhpcyBrZWVwcyBpdCB2ZXJ5IG1lbW9yeS1lZmZpY2llbnQgYW5kIGZhc3QgdG8gaXRlcmF0ZSB0aHJvdWdoLlxuX3JldmVydFJlY29yZGVkID0gZnVuY3Rpb24gX3JldmVydFJlY29yZGVkKG1lZGlhKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgX3NhdmVkU3R5bGVzLmxlbmd0aDsgaSArPSA1KSB7XG4gICAgaWYgKCFtZWRpYSB8fCBfc2F2ZWRTdHlsZXNbaSArIDRdID09PSBtZWRpYSkge1xuICAgICAgX3NhdmVkU3R5bGVzW2ldLnN0eWxlLmNzc1RleHQgPSBfc2F2ZWRTdHlsZXNbaSArIDFdO1xuICAgICAgX3NhdmVkU3R5bGVzW2ldLmdldEJCb3ggJiYgX3NhdmVkU3R5bGVzW2ldLnNldEF0dHJpYnV0ZShcInRyYW5zZm9ybVwiLCBfc2F2ZWRTdHlsZXNbaSArIDJdIHx8IFwiXCIpO1xuICAgICAgX3NhdmVkU3R5bGVzW2kgKyAzXS51bmNhY2hlID0gMTtcbiAgICB9XG4gIH1cbn0sXG4gICAgX3JldmVydEFsbCA9IGZ1bmN0aW9uIF9yZXZlcnRBbGwoa2lsbCwgbWVkaWEpIHtcbiAgdmFyIHRyaWdnZXI7XG5cbiAgZm9yIChfaSA9IDA7IF9pIDwgX3RyaWdnZXJzLmxlbmd0aDsgX2krKykge1xuICAgIHRyaWdnZXIgPSBfdHJpZ2dlcnNbX2ldO1xuXG4gICAgaWYgKCFtZWRpYSB8fCB0cmlnZ2VyLm1lZGlhID09PSBtZWRpYSkge1xuICAgICAgaWYgKGtpbGwpIHtcbiAgICAgICAgdHJpZ2dlci5raWxsKDEpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdHJpZ2dlci5yZXZlcnQoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBtZWRpYSAmJiBfcmV2ZXJ0UmVjb3JkZWQobWVkaWEpO1xuICBtZWRpYSB8fCBfZGlzcGF0Y2goXCJyZXZlcnRcIik7XG59LFxuICAgIF9jbGVhclNjcm9sbE1lbW9yeSA9IGZ1bmN0aW9uIF9jbGVhclNjcm9sbE1lbW9yeSgpIHtcbiAgcmV0dXJuIF9zY3JvbGxlcnMuY2FjaGUrKyAmJiBfc2Nyb2xsZXJzLmZvckVhY2goZnVuY3Rpb24gKG9iaikge1xuICAgIHJldHVybiB0eXBlb2Ygb2JqID09PSBcImZ1bmN0aW9uXCIgJiYgKG9iai5yZWMgPSAwKTtcbiAgfSk7XG59LFxuICAgIC8vIHplcm8tb3V0IGFsbCB0aGUgcmVjb3JkZWQgc2Nyb2xsIHBvc2l0aW9ucy4gRG9uJ3QgdXNlIF90cmlnZ2VycyBiZWNhdXNlIGlmLCBmb3IgZXhhbXBsZSwgLm1hdGNoTWVkaWEoKSBpcyB1c2VkIHRvIGNyZWF0ZSBzb21lIFNjcm9sbFRyaWdnZXJzIGFuZCB0aGVuIHRoZSB1c2VyIHJlc2l6ZXMgYW5kIGl0IHJlbW92ZXMgQUxMIFNjcm9sbFRyaWdnZXJzLCBhbmQgdGhlbiBnbyBiYWNrIHRvIGEgc2l6ZSB3aGVyZSB0aGVyZSBhcmUgU2Nyb2xsVHJpZ2dlcnMsIGl0IHdvdWxkIGhhdmUga2VwdCB0aGUgcG9zaXRpb24ocykgc2F2ZWQgZnJvbSB0aGUgaW5pdGlhbCBzdGF0ZS5cbl9yZWZyZXNoaW5nQWxsLFxuICAgIF9yZWZyZXNoSUQgPSAwLFxuICAgIF9yZWZyZXNoQWxsID0gZnVuY3Rpb24gX3JlZnJlc2hBbGwoZm9yY2UsIHNraXBSZXZlcnQpIHtcbiAgaWYgKF9sYXN0U2Nyb2xsVGltZSAmJiAhZm9yY2UpIHtcbiAgICBfYWRkTGlzdGVuZXIoU2Nyb2xsVHJpZ2dlciwgXCJzY3JvbGxFbmRcIiwgX3NvZnRSZWZyZXNoKTtcblxuICAgIHJldHVybjtcbiAgfVxuXG4gIF9yZWZyZXNoaW5nQWxsID0gdHJ1ZTtcblxuICB2YXIgcmVmcmVzaEluaXRzID0gX2Rpc3BhdGNoKFwicmVmcmVzaEluaXRcIik7XG5cbiAgX3NvcnQgJiYgU2Nyb2xsVHJpZ2dlci5zb3J0KCk7XG4gIHNraXBSZXZlcnQgfHwgX3JldmVydEFsbCgpO1xuXG4gIF90cmlnZ2Vycy5zbGljZSgwKS5mb3JFYWNoKGZ1bmN0aW9uICh0KSB7XG4gICAgcmV0dXJuIHQucmVmcmVzaCgpO1xuICB9KTsgLy8gZG9uJ3QgbG9vcCB3aXRoIF9pIGJlY2F1c2UgZHVyaW5nIGEgcmVmcmVzaCgpIHNvbWVvbmUgY291bGQgY2FsbCBTY3JvbGxUcmlnZ2VyLnVwZGF0ZSgpIHdoaWNoIHdvdWxkIGl0ZXJhdGUgdGhyb3VnaCBfaSByZXN1bHRpbmcgaW4gYSBza2lwLlxuXG5cbiAgX3RyaWdnZXJzLmZvckVhY2goZnVuY3Rpb24gKHQpIHtcbiAgICByZXR1cm4gdC52YXJzLmVuZCA9PT0gXCJtYXhcIiAmJiB0LnNldFBvc2l0aW9ucyh0LnN0YXJ0LCBfbWF4U2Nyb2xsKHQuc2Nyb2xsZXIsIHQuX2RpcikpO1xuICB9KTsgLy8gdGhlIHNjcm9sbGVyJ3MgbWF4IHNjcm9sbCBwb3NpdGlvbiBtYXkgY2hhbmdlIGFmdGVyIGFsbCB0aGUgU2Nyb2xsVHJpZ2dlcnMgcmVmcmVzaGVkIChsaWtlIHBpbm5pbmcgY291bGQgcHVzaCBpdCBkb3duKSwgc28gd2UgbmVlZCB0byBsb29wIGJhY2sgYW5kIGNvcnJlY3QgYW55IHdpdGggZW5kOiBcIm1heFwiLlxuXG5cbiAgcmVmcmVzaEluaXRzLmZvckVhY2goZnVuY3Rpb24gKHJlc3VsdCkge1xuICAgIHJldHVybiByZXN1bHQgJiYgcmVzdWx0LnJlbmRlciAmJiByZXN1bHQucmVuZGVyKC0xKTtcbiAgfSk7IC8vIGlmIHRoZSBvblJlZnJlc2hJbml0KCkgcmV0dXJucyBhbiBhbmltYXRpb24gKHR5cGljYWxseSBhIGdzYXAuc2V0KCkpLCByZXZlcnQgaXQuIFRoaXMgbWFrZXMgaXQgZWFzeSB0byBwdXQgdGhpbmdzIGluIGEgY2VydGFpbiBzcG90IGJlZm9yZSByZWZyZXNoaW5nIGZvciBtZWFzdXJlbWVudCBwdXJwb3NlcywgYW5kIHRoZW4gcHV0IHRoaW5ncyBiYWNrLlxuXG4gIF9jbGVhclNjcm9sbE1lbW9yeSgpO1xuXG4gIF9yZXNpemVEZWxheS5wYXVzZSgpO1xuXG4gIF9yZWZyZXNoSUQrKztcbiAgX3JlZnJlc2hpbmdBbGwgPSBmYWxzZTtcblxuICBfZGlzcGF0Y2goXCJyZWZyZXNoXCIpO1xufSxcbiAgICBfbGFzdFNjcm9sbCA9IDAsXG4gICAgX2RpcmVjdGlvbiA9IDEsXG4gICAgX3ByaW1hcnksXG4gICAgX3VwZGF0ZUFsbCA9IGZ1bmN0aW9uIF91cGRhdGVBbGwoKSB7XG4gIGlmICghX3JlZnJlc2hpbmdBbGwpIHtcbiAgICBTY3JvbGxUcmlnZ2VyLmlzVXBkYXRpbmcgPSB0cnVlO1xuICAgIF9wcmltYXJ5ICYmIF9wcmltYXJ5LnVwZGF0ZSgwKTsgLy8gU2Nyb2xsU21vb3RoZXIgdXNlcnMgcmVmcmVzaFByaW9yaXR5IC05OTk5IHRvIGJlY29tZSB0aGUgcHJpbWFyeSB0aGF0IGdldHMgdXBkYXRlZCBiZWZvcmUgYWxsIG90aGVycyBiZWNhdXNlIGl0IGFmZmVjdHMgdGhlIHNjcm9sbCBwb3NpdGlvbi5cblxuICAgIHZhciBsID0gX3RyaWdnZXJzLmxlbmd0aCxcbiAgICAgICAgdGltZSA9IF9nZXRUaW1lKCksXG4gICAgICAgIHJlY29yZFZlbG9jaXR5ID0gdGltZSAtIF90aW1lMSA+PSA1MCxcbiAgICAgICAgc2Nyb2xsID0gbCAmJiBfdHJpZ2dlcnNbMF0uc2Nyb2xsKCk7XG5cbiAgICBfZGlyZWN0aW9uID0gX2xhc3RTY3JvbGwgPiBzY3JvbGwgPyAtMSA6IDE7XG4gICAgX2xhc3RTY3JvbGwgPSBzY3JvbGw7XG5cbiAgICBpZiAocmVjb3JkVmVsb2NpdHkpIHtcbiAgICAgIGlmIChfbGFzdFNjcm9sbFRpbWUgJiYgIV9wb2ludGVySXNEb3duICYmIHRpbWUgLSBfbGFzdFNjcm9sbFRpbWUgPiAyMDApIHtcbiAgICAgICAgX2xhc3RTY3JvbGxUaW1lID0gMDtcblxuICAgICAgICBfZGlzcGF0Y2goXCJzY3JvbGxFbmRcIik7XG4gICAgICB9XG5cbiAgICAgIF90aW1lMiA9IF90aW1lMTtcbiAgICAgIF90aW1lMSA9IHRpbWU7XG4gICAgfVxuXG4gICAgaWYgKF9kaXJlY3Rpb24gPCAwKSB7XG4gICAgICBfaSA9IGw7XG5cbiAgICAgIHdoaWxlIChfaS0tID4gMCkge1xuICAgICAgICBfdHJpZ2dlcnNbX2ldICYmIF90cmlnZ2Vyc1tfaV0udXBkYXRlKDAsIHJlY29yZFZlbG9jaXR5KTtcbiAgICAgIH1cblxuICAgICAgX2RpcmVjdGlvbiA9IDE7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvciAoX2kgPSAwOyBfaSA8IGw7IF9pKyspIHtcbiAgICAgICAgX3RyaWdnZXJzW19pXSAmJiBfdHJpZ2dlcnNbX2ldLnVwZGF0ZSgwLCByZWNvcmRWZWxvY2l0eSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgU2Nyb2xsVHJpZ2dlci5pc1VwZGF0aW5nID0gZmFsc2U7XG4gIH1cblxuICBfcmFmSUQgPSAwO1xufSxcbiAgICBfcHJvcE5hbWVzVG9Db3B5ID0gW19sZWZ0LCBfdG9wLCBfYm90dG9tLCBfcmlnaHQsIF9tYXJnaW4gKyBfQm90dG9tLCBfbWFyZ2luICsgX1JpZ2h0LCBfbWFyZ2luICsgX1RvcCwgX21hcmdpbiArIF9MZWZ0LCBcImRpc3BsYXlcIiwgXCJmbGV4U2hyaW5rXCIsIFwiZmxvYXRcIiwgXCJ6SW5kZXhcIiwgXCJncmlkQ29sdW1uU3RhcnRcIiwgXCJncmlkQ29sdW1uRW5kXCIsIFwiZ3JpZFJvd1N0YXJ0XCIsIFwiZ3JpZFJvd0VuZFwiLCBcImdyaWRBcmVhXCIsIFwianVzdGlmeVNlbGZcIiwgXCJhbGlnblNlbGZcIiwgXCJwbGFjZVNlbGZcIiwgXCJvcmRlclwiXSxcbiAgICBfc3RhdGVQcm9wcyA9IF9wcm9wTmFtZXNUb0NvcHkuY29uY2F0KFtfd2lkdGgsIF9oZWlnaHQsIFwiYm94U2l6aW5nXCIsIFwibWF4XCIgKyBfV2lkdGgsIFwibWF4XCIgKyBfSGVpZ2h0LCBcInBvc2l0aW9uXCIsIF9tYXJnaW4sIF9wYWRkaW5nLCBfcGFkZGluZyArIF9Ub3AsIF9wYWRkaW5nICsgX1JpZ2h0LCBfcGFkZGluZyArIF9Cb3R0b20sIF9wYWRkaW5nICsgX0xlZnRdKSxcbiAgICBfc3dhcFBpbk91dCA9IGZ1bmN0aW9uIF9zd2FwUGluT3V0KHBpbiwgc3BhY2VyLCBzdGF0ZSkge1xuICBfc2V0U3RhdGUoc3RhdGUpO1xuXG4gIHZhciBjYWNoZSA9IHBpbi5fZ3NhcDtcblxuICBpZiAoY2FjaGUuc3BhY2VySXNOYXRpdmUpIHtcbiAgICBfc2V0U3RhdGUoY2FjaGUuc3BhY2VyU3RhdGUpO1xuICB9IGVsc2UgaWYgKHBpbi5wYXJlbnROb2RlID09PSBzcGFjZXIpIHtcbiAgICB2YXIgcGFyZW50ID0gc3BhY2VyLnBhcmVudE5vZGU7XG5cbiAgICBpZiAocGFyZW50KSB7XG4gICAgICBwYXJlbnQuaW5zZXJ0QmVmb3JlKHBpbiwgc3BhY2VyKTtcbiAgICAgIHBhcmVudC5yZW1vdmVDaGlsZChzcGFjZXIpO1xuICAgIH1cbiAgfVxufSxcbiAgICBfc3dhcFBpbkluID0gZnVuY3Rpb24gX3N3YXBQaW5JbihwaW4sIHNwYWNlciwgY3MsIHNwYWNlclN0YXRlKSB7XG4gIGlmIChwaW4ucGFyZW50Tm9kZSAhPT0gc3BhY2VyKSB7XG4gICAgdmFyIGkgPSBfcHJvcE5hbWVzVG9Db3B5Lmxlbmd0aCxcbiAgICAgICAgc3BhY2VyU3R5bGUgPSBzcGFjZXIuc3R5bGUsXG4gICAgICAgIHBpblN0eWxlID0gcGluLnN0eWxlLFxuICAgICAgICBwO1xuXG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgcCA9IF9wcm9wTmFtZXNUb0NvcHlbaV07XG4gICAgICBzcGFjZXJTdHlsZVtwXSA9IGNzW3BdO1xuICAgIH1cblxuICAgIHNwYWNlclN0eWxlLnBvc2l0aW9uID0gY3MucG9zaXRpb24gPT09IFwiYWJzb2x1dGVcIiA/IFwiYWJzb2x1dGVcIiA6IFwicmVsYXRpdmVcIjtcbiAgICBjcy5kaXNwbGF5ID09PSBcImlubGluZVwiICYmIChzcGFjZXJTdHlsZS5kaXNwbGF5ID0gXCJpbmxpbmUtYmxvY2tcIik7XG4gICAgcGluU3R5bGVbX2JvdHRvbV0gPSBwaW5TdHlsZVtfcmlnaHRdID0gc3BhY2VyU3R5bGUuZmxleEJhc2lzID0gXCJhdXRvXCI7XG4gICAgc3BhY2VyU3R5bGUub3ZlcmZsb3cgPSBcInZpc2libGVcIjtcbiAgICBzcGFjZXJTdHlsZS5ib3hTaXppbmcgPSBcImJvcmRlci1ib3hcIjtcbiAgICBzcGFjZXJTdHlsZVtfd2lkdGhdID0gX2dldFNpemUocGluLCBfaG9yaXpvbnRhbCkgKyBfcHg7XG4gICAgc3BhY2VyU3R5bGVbX2hlaWdodF0gPSBfZ2V0U2l6ZShwaW4sIF92ZXJ0aWNhbCkgKyBfcHg7XG4gICAgc3BhY2VyU3R5bGVbX3BhZGRpbmddID0gcGluU3R5bGVbX21hcmdpbl0gPSBwaW5TdHlsZVtfdG9wXSA9IHBpblN0eWxlW19sZWZ0XSA9IFwiMFwiO1xuXG4gICAgX3NldFN0YXRlKHNwYWNlclN0YXRlKTtcblxuICAgIHBpblN0eWxlW193aWR0aF0gPSBwaW5TdHlsZVtcIm1heFwiICsgX1dpZHRoXSA9IGNzW193aWR0aF07XG4gICAgcGluU3R5bGVbX2hlaWdodF0gPSBwaW5TdHlsZVtcIm1heFwiICsgX0hlaWdodF0gPSBjc1tfaGVpZ2h0XTtcbiAgICBwaW5TdHlsZVtfcGFkZGluZ10gPSBjc1tfcGFkZGluZ107XG4gICAgcGluLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKHNwYWNlciwgcGluKTtcbiAgICBzcGFjZXIuYXBwZW5kQ2hpbGQocGluKTtcbiAgfVxufSxcbiAgICBfY2Fwc0V4cCA9IC8oW0EtWl0pL2csXG4gICAgX3NldFN0YXRlID0gZnVuY3Rpb24gX3NldFN0YXRlKHN0YXRlKSB7XG4gIGlmIChzdGF0ZSkge1xuICAgIHZhciBzdHlsZSA9IHN0YXRlLnQuc3R5bGUsXG4gICAgICAgIGwgPSBzdGF0ZS5sZW5ndGgsXG4gICAgICAgIGkgPSAwLFxuICAgICAgICBwLFxuICAgICAgICB2YWx1ZTtcbiAgICAoc3RhdGUudC5fZ3NhcCB8fCBnc2FwLmNvcmUuZ2V0Q2FjaGUoc3RhdGUudCkpLnVuY2FjaGUgPSAxOyAvLyBvdGhlcndpc2UgdHJhbnNmb3JtcyBtYXkgYmUgb2ZmXG5cbiAgICBmb3IgKDsgaSA8IGw7IGkgKz0gMikge1xuICAgICAgdmFsdWUgPSBzdGF0ZVtpICsgMV07XG4gICAgICBwID0gc3RhdGVbaV07XG5cbiAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICBzdHlsZVtwXSA9IHZhbHVlO1xuICAgICAgfSBlbHNlIGlmIChzdHlsZVtwXSkge1xuICAgICAgICBzdHlsZS5yZW1vdmVQcm9wZXJ0eShwLnJlcGxhY2UoX2NhcHNFeHAsIFwiLSQxXCIpLnRvTG93ZXJDYXNlKCkpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufSxcbiAgICBfZ2V0U3RhdGUgPSBmdW5jdGlvbiBfZ2V0U3RhdGUoZWxlbWVudCkge1xuICAvLyByZXR1cm5zIGFuIEFycmF5IHdpdGggYWx0ZXJuYXRpbmcgdmFsdWVzIGxpa2UgW3Byb3BlcnR5LCB2YWx1ZSwgcHJvcGVydHksIHZhbHVlXSBhbmQgYSBcInRcIiBwcm9wZXJ0eSBwb2ludGluZyB0byB0aGUgdGFyZ2V0IChlbGVtZW50KS4gTWFrZXMgaXQgZmFzdCBhbmQgY2hlYXAuXG4gIHZhciBsID0gX3N0YXRlUHJvcHMubGVuZ3RoLFxuICAgICAgc3R5bGUgPSBlbGVtZW50LnN0eWxlLFxuICAgICAgc3RhdGUgPSBbXSxcbiAgICAgIGkgPSAwO1xuXG4gIGZvciAoOyBpIDwgbDsgaSsrKSB7XG4gICAgc3RhdGUucHVzaChfc3RhdGVQcm9wc1tpXSwgc3R5bGVbX3N0YXRlUHJvcHNbaV1dKTtcbiAgfVxuXG4gIHN0YXRlLnQgPSBlbGVtZW50O1xuICByZXR1cm4gc3RhdGU7XG59LFxuICAgIF9jb3B5U3RhdGUgPSBmdW5jdGlvbiBfY29weVN0YXRlKHN0YXRlLCBvdmVycmlkZSwgb21pdE9mZnNldHMpIHtcbiAgdmFyIHJlc3VsdCA9IFtdLFxuICAgICAgbCA9IHN0YXRlLmxlbmd0aCxcbiAgICAgIGkgPSBvbWl0T2Zmc2V0cyA/IDggOiAwLFxuICAgICAgLy8gc2tpcCB0b3AsIGxlZnQsIHJpZ2h0LCBib3R0b20gaWYgb21pdE9mZnNldHMgaXMgdHJ1ZVxuICBwO1xuXG4gIGZvciAoOyBpIDwgbDsgaSArPSAyKSB7XG4gICAgcCA9IHN0YXRlW2ldO1xuICAgIHJlc3VsdC5wdXNoKHAsIHAgaW4gb3ZlcnJpZGUgPyBvdmVycmlkZVtwXSA6IHN0YXRlW2kgKyAxXSk7XG4gIH1cblxuICByZXN1bHQudCA9IHN0YXRlLnQ7XG4gIHJldHVybiByZXN1bHQ7XG59LFxuICAgIF93aW5PZmZzZXRzID0ge1xuICBsZWZ0OiAwLFxuICB0b3A6IDBcbn0sXG4gICAgLy8gLy8gcG90ZW50aWFsIGZ1dHVyZSBmZWF0dXJlICg/KSBBbGxvdyB1c2VycyB0byBjYWxjdWxhdGUgd2hlcmUgYSB0cmlnZ2VyIGhpdHMgKHNjcm9sbCBwb3NpdGlvbikgbGlrZSBnZXRTY3JvbGxQb3NpdGlvbihcIiNpZFwiLCBcInRvcCBib3R0b21cIilcbi8vIF9nZXRTY3JvbGxQb3NpdGlvbiA9ICh0cmlnZ2VyLCBwb3NpdGlvbiwge3Njcm9sbGVyLCBjb250YWluZXJBbmltYXRpb24sIGhvcml6b250YWx9KSA9PiB7XG4vLyBcdHNjcm9sbGVyID0gX2dldFRhcmdldChzY3JvbGxlciB8fCBfd2luKTtcbi8vIFx0bGV0IGRpcmVjdGlvbiA9IGhvcml6b250YWwgPyBfaG9yaXpvbnRhbCA6IF92ZXJ0aWNhbCxcbi8vIFx0XHRpc1ZpZXdwb3J0ID0gX2lzVmlld3BvcnQoc2Nyb2xsZXIpO1xuLy8gXHRfZ2V0U2l6ZUZ1bmMoc2Nyb2xsZXIsIGlzVmlld3BvcnQsIGRpcmVjdGlvbik7XG4vLyBcdHJldHVybiBfcGFyc2VQb3NpdGlvbihwb3NpdGlvbiwgX2dldFRhcmdldCh0cmlnZ2VyKSwgX2dldFNpemVGdW5jKHNjcm9sbGVyLCBpc1ZpZXdwb3J0LCBkaXJlY3Rpb24pKCksIGRpcmVjdGlvbiwgX2dldFNjcm9sbEZ1bmMoc2Nyb2xsZXIsIGRpcmVjdGlvbikoKSwgMCwgMCwgMCwgX2dldE9mZnNldHNGdW5jKHNjcm9sbGVyLCBpc1ZpZXdwb3J0KSgpLCBpc1ZpZXdwb3J0ID8gMCA6IHBhcnNlRmxvYXQoX2dldENvbXB1dGVkU3R5bGUoc2Nyb2xsZXIpW1wiYm9yZGVyXCIgKyBkaXJlY3Rpb24ucDIgKyBfV2lkdGhdKSB8fCAwLCAwLCBjb250YWluZXJBbmltYXRpb24gPyBjb250YWluZXJBbmltYXRpb24uZHVyYXRpb24oKSA6IF9tYXhTY3JvbGwoc2Nyb2xsZXIpLCBjb250YWluZXJBbmltYXRpb24pO1xuLy8gfSxcbl9wYXJzZVBvc2l0aW9uID0gZnVuY3Rpb24gX3BhcnNlUG9zaXRpb24odmFsdWUsIHRyaWdnZXIsIHNjcm9sbGVyU2l6ZSwgZGlyZWN0aW9uLCBzY3JvbGwsIG1hcmtlciwgbWFya2VyU2Nyb2xsZXIsIHNlbGYsIHNjcm9sbGVyQm91bmRzLCBib3JkZXJXaWR0aCwgdXNlRml4ZWRQb3NpdGlvbiwgc2Nyb2xsZXJNYXgsIGNvbnRhaW5lckFuaW1hdGlvbikge1xuICBfaXNGdW5jdGlvbih2YWx1ZSkgJiYgKHZhbHVlID0gdmFsdWUoc2VsZikpO1xuXG4gIGlmIChfaXNTdHJpbmcodmFsdWUpICYmIHZhbHVlLnN1YnN0cigwLCAzKSA9PT0gXCJtYXhcIikge1xuICAgIHZhbHVlID0gc2Nyb2xsZXJNYXggKyAodmFsdWUuY2hhckF0KDQpID09PSBcIj1cIiA/IF9vZmZzZXRUb1B4KFwiMFwiICsgdmFsdWUuc3Vic3RyKDMpLCBzY3JvbGxlclNpemUpIDogMCk7XG4gIH1cblxuICB2YXIgdGltZSA9IGNvbnRhaW5lckFuaW1hdGlvbiA/IGNvbnRhaW5lckFuaW1hdGlvbi50aW1lKCkgOiAwLFxuICAgICAgcDEsXG4gICAgICBwMixcbiAgICAgIGVsZW1lbnQ7XG4gIGNvbnRhaW5lckFuaW1hdGlvbiAmJiBjb250YWluZXJBbmltYXRpb24uc2VlaygwKTtcblxuICBpZiAoIV9pc051bWJlcih2YWx1ZSkpIHtcbiAgICBfaXNGdW5jdGlvbih0cmlnZ2VyKSAmJiAodHJpZ2dlciA9IHRyaWdnZXIoc2VsZikpO1xuICAgIHZhciBvZmZzZXRzID0gdmFsdWUuc3BsaXQoXCIgXCIpLFxuICAgICAgICBib3VuZHMsXG4gICAgICAgIGxvY2FsT2Zmc2V0LFxuICAgICAgICBnbG9iYWxPZmZzZXQsXG4gICAgICAgIGRpc3BsYXk7XG4gICAgZWxlbWVudCA9IF9nZXRUYXJnZXQodHJpZ2dlcikgfHwgX2JvZHk7XG4gICAgYm91bmRzID0gX2dldEJvdW5kcyhlbGVtZW50KSB8fCB7fTtcblxuICAgIGlmICgoIWJvdW5kcyB8fCAhYm91bmRzLmxlZnQgJiYgIWJvdW5kcy50b3ApICYmIF9nZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpLmRpc3BsYXkgPT09IFwibm9uZVwiKSB7XG4gICAgICAvLyBpZiBkaXNwbGF5IGlzIFwibm9uZVwiLCBpdCB3b24ndCByZXBvcnQgZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkgcHJvcGVybHlcbiAgICAgIGRpc3BsYXkgPSBlbGVtZW50LnN0eWxlLmRpc3BsYXk7XG4gICAgICBlbGVtZW50LnN0eWxlLmRpc3BsYXkgPSBcImJsb2NrXCI7XG4gICAgICBib3VuZHMgPSBfZ2V0Qm91bmRzKGVsZW1lbnQpO1xuICAgICAgZGlzcGxheSA/IGVsZW1lbnQuc3R5bGUuZGlzcGxheSA9IGRpc3BsYXkgOiBlbGVtZW50LnN0eWxlLnJlbW92ZVByb3BlcnR5KFwiZGlzcGxheVwiKTtcbiAgICB9XG5cbiAgICBsb2NhbE9mZnNldCA9IF9vZmZzZXRUb1B4KG9mZnNldHNbMF0sIGJvdW5kc1tkaXJlY3Rpb24uZF0pO1xuICAgIGdsb2JhbE9mZnNldCA9IF9vZmZzZXRUb1B4KG9mZnNldHNbMV0gfHwgXCIwXCIsIHNjcm9sbGVyU2l6ZSk7XG4gICAgdmFsdWUgPSBib3VuZHNbZGlyZWN0aW9uLnBdIC0gc2Nyb2xsZXJCb3VuZHNbZGlyZWN0aW9uLnBdIC0gYm9yZGVyV2lkdGggKyBsb2NhbE9mZnNldCArIHNjcm9sbCAtIGdsb2JhbE9mZnNldDtcbiAgICBtYXJrZXJTY3JvbGxlciAmJiBfcG9zaXRpb25NYXJrZXIobWFya2VyU2Nyb2xsZXIsIGdsb2JhbE9mZnNldCwgZGlyZWN0aW9uLCBzY3JvbGxlclNpemUgLSBnbG9iYWxPZmZzZXQgPCAyMCB8fCBtYXJrZXJTY3JvbGxlci5faXNTdGFydCAmJiBnbG9iYWxPZmZzZXQgPiAyMCk7XG4gICAgc2Nyb2xsZXJTaXplIC09IHNjcm9sbGVyU2l6ZSAtIGdsb2JhbE9mZnNldDsgLy8gYWRqdXN0IGZvciB0aGUgbWFya2VyXG4gIH0gZWxzZSBpZiAobWFya2VyU2Nyb2xsZXIpIHtcbiAgICBfcG9zaXRpb25NYXJrZXIobWFya2VyU2Nyb2xsZXIsIHNjcm9sbGVyU2l6ZSwgZGlyZWN0aW9uLCB0cnVlKTtcbiAgfVxuXG4gIGlmIChtYXJrZXIpIHtcbiAgICB2YXIgcG9zaXRpb24gPSB2YWx1ZSArIHNjcm9sbGVyU2l6ZSxcbiAgICAgICAgaXNTdGFydCA9IG1hcmtlci5faXNTdGFydDtcbiAgICBwMSA9IFwic2Nyb2xsXCIgKyBkaXJlY3Rpb24uZDI7XG5cbiAgICBfcG9zaXRpb25NYXJrZXIobWFya2VyLCBwb3NpdGlvbiwgZGlyZWN0aW9uLCBpc1N0YXJ0ICYmIHBvc2l0aW9uID4gMjAgfHwgIWlzU3RhcnQgJiYgKHVzZUZpeGVkUG9zaXRpb24gPyBNYXRoLm1heChfYm9keVtwMV0sIF9kb2NFbFtwMV0pIDogbWFya2VyLnBhcmVudE5vZGVbcDFdKSA8PSBwb3NpdGlvbiArIDEpO1xuXG4gICAgaWYgKHVzZUZpeGVkUG9zaXRpb24pIHtcbiAgICAgIHNjcm9sbGVyQm91bmRzID0gX2dldEJvdW5kcyhtYXJrZXJTY3JvbGxlcik7XG4gICAgICB1c2VGaXhlZFBvc2l0aW9uICYmIChtYXJrZXIuc3R5bGVbZGlyZWN0aW9uLm9wLnBdID0gc2Nyb2xsZXJCb3VuZHNbZGlyZWN0aW9uLm9wLnBdIC0gZGlyZWN0aW9uLm9wLm0gLSBtYXJrZXIuX29mZnNldCArIF9weCk7XG4gICAgfVxuICB9XG5cbiAgaWYgKGNvbnRhaW5lckFuaW1hdGlvbiAmJiBlbGVtZW50KSB7XG4gICAgcDEgPSBfZ2V0Qm91bmRzKGVsZW1lbnQpO1xuICAgIGNvbnRhaW5lckFuaW1hdGlvbi5zZWVrKHNjcm9sbGVyTWF4KTtcbiAgICBwMiA9IF9nZXRCb3VuZHMoZWxlbWVudCk7XG4gICAgY29udGFpbmVyQW5pbWF0aW9uLl9jYVNjcm9sbERpc3QgPSBwMVtkaXJlY3Rpb24ucF0gLSBwMltkaXJlY3Rpb24ucF07XG4gICAgdmFsdWUgPSB2YWx1ZSAvIGNvbnRhaW5lckFuaW1hdGlvbi5fY2FTY3JvbGxEaXN0ICogc2Nyb2xsZXJNYXg7XG4gIH1cblxuICBjb250YWluZXJBbmltYXRpb24gJiYgY29udGFpbmVyQW5pbWF0aW9uLnNlZWsodGltZSk7XG4gIHJldHVybiBjb250YWluZXJBbmltYXRpb24gPyB2YWx1ZSA6IE1hdGgucm91bmQodmFsdWUpO1xufSxcbiAgICBfcHJlZml4RXhwID0gLyh3ZWJraXR8bW96fGxlbmd0aHxjc3NUZXh0fGluc2V0KS9pLFxuICAgIF9yZXBhcmVudCA9IGZ1bmN0aW9uIF9yZXBhcmVudChlbGVtZW50LCBwYXJlbnQsIHRvcCwgbGVmdCkge1xuICBpZiAoZWxlbWVudC5wYXJlbnROb2RlICE9PSBwYXJlbnQpIHtcbiAgICB2YXIgc3R5bGUgPSBlbGVtZW50LnN0eWxlLFxuICAgICAgICBwLFxuICAgICAgICBjcztcblxuICAgIGlmIChwYXJlbnQgPT09IF9ib2R5KSB7XG4gICAgICBlbGVtZW50Ll9zdE9yaWcgPSBzdHlsZS5jc3NUZXh0OyAvLyByZWNvcmQgb3JpZ2luYWwgaW5saW5lIHN0eWxlcyBzbyB3ZSBjYW4gcmV2ZXJ0IHRoZW0gbGF0ZXJcblxuICAgICAgY3MgPSBfZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KTtcblxuICAgICAgZm9yIChwIGluIGNzKSB7XG4gICAgICAgIC8vIG11c3QgY29weSBhbGwgcmVsZXZhbnQgc3R5bGVzIHRvIGVuc3VyZSB0aGF0IG5vdGhpbmcgY2hhbmdlcyB2aXN1YWxseSB3aGVuIHdlIHJlcGFyZW50IHRvIHRoZSA8Ym9keT4uIFNraXAgdGhlIHZlbmRvciBwcmVmaXhlZCBvbmVzLlxuICAgICAgICBpZiAoIStwICYmICFfcHJlZml4RXhwLnRlc3QocCkgJiYgY3NbcF0gJiYgdHlwZW9mIHN0eWxlW3BdID09PSBcInN0cmluZ1wiICYmIHAgIT09IFwiMFwiKSB7XG4gICAgICAgICAgc3R5bGVbcF0gPSBjc1twXTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBzdHlsZS50b3AgPSB0b3A7XG4gICAgICBzdHlsZS5sZWZ0ID0gbGVmdDtcbiAgICB9IGVsc2Uge1xuICAgICAgc3R5bGUuY3NzVGV4dCA9IGVsZW1lbnQuX3N0T3JpZztcbiAgICB9XG5cbiAgICBnc2FwLmNvcmUuZ2V0Q2FjaGUoZWxlbWVudCkudW5jYWNoZSA9IDE7XG4gICAgcGFyZW50LmFwcGVuZENoaWxkKGVsZW1lbnQpO1xuICB9XG59LFxuICAgIC8vIF9tZXJnZUFuaW1hdGlvbnMgPSBhbmltYXRpb25zID0+IHtcbi8vIFx0bGV0IHRsID0gZ3NhcC50aW1lbGluZSh7c21vb3RoQ2hpbGRUaW1pbmc6IHRydWV9KS5zdGFydFRpbWUoTWF0aC5taW4oLi4uYW5pbWF0aW9ucy5tYXAoYSA9PiBhLmdsb2JhbFRpbWUoMCkpKSk7XG4vLyBcdGFuaW1hdGlvbnMuZm9yRWFjaChhID0+IHtsZXQgdGltZSA9IGEudG90YWxUaW1lKCk7IHRsLmFkZChhKTsgYS50b3RhbFRpbWUodGltZSk7IH0pO1xuLy8gXHR0bC5zbW9vdGhDaGlsZFRpbWluZyA9IGZhbHNlO1xuLy8gXHRyZXR1cm4gdGw7XG4vLyB9LFxuLy8gcmV0dXJucyBhIGZ1bmN0aW9uIHRoYXQgY2FuIGJlIHVzZWQgdG8gdHdlZW4gdGhlIHNjcm9sbCBwb3NpdGlvbiBpbiB0aGUgZGlyZWN0aW9uIHByb3ZpZGVkLCBhbmQgd2hlbiBkb2luZyBzbyBpdCdsbCBhZGQgYSAudHdlZW4gcHJvcGVydHkgdG8gdGhlIEZVTkNUSU9OIGl0c2VsZiwgYW5kIHJlbW92ZSBpdCB3aGVuIHRoZSB0d2VlbiBjb21wbGV0ZXMgb3IgZ2V0cyBraWxsZWQuIFRoaXMgZ2l2ZXMgdXMgYSB3YXkgdG8gaGF2ZSBtdWx0aXBsZSBTY3JvbGxUcmlnZ2VycyB1c2UgYSBjZW50cmFsIGZ1bmN0aW9uIGZvciBhbnkgZ2l2ZW4gc2Nyb2xsZXIgYW5kIHNlZSBpZiB0aGVyZSdzIGEgc2Nyb2xsIHR3ZWVuIHJ1bm5pbmcgKHdoaWNoIHdvdWxkIGFmZmVjdCBpZi9ob3cgdGhpbmdzIGdldCB1cGRhdGVkKVxuX2dldFR3ZWVuQ3JlYXRvciA9IGZ1bmN0aW9uIF9nZXRUd2VlbkNyZWF0b3Ioc2Nyb2xsZXIsIGRpcmVjdGlvbikge1xuICB2YXIgZ2V0U2Nyb2xsID0gX2dldFNjcm9sbEZ1bmMoc2Nyb2xsZXIsIGRpcmVjdGlvbiksXG4gICAgICBwcm9wID0gXCJfc2Nyb2xsXCIgKyBkaXJlY3Rpb24ucDIsXG4gICAgICAvLyBhZGQgYSB0d2VlbmFibGUgcHJvcGVydHkgdG8gdGhlIHNjcm9sbGVyIHRoYXQncyBhIGdldHRlci9zZXR0ZXIgZnVuY3Rpb24sIGxpa2UgX3Njcm9sbFRvcCBvciBfc2Nyb2xsTGVmdC4gVGhpcyB3YXksIGlmIHNvbWVvbmUgZG9lcyBnc2FwLmtpbGxUd2VlbnNPZihzY3JvbGxlcikgaXQnbGwga2lsbCB0aGUgc2Nyb2xsIHR3ZWVuLlxuICBsYXN0U2Nyb2xsMSxcbiAgICAgIGxhc3RTY3JvbGwyLFxuICAgICAgZ2V0VHdlZW4gPSBmdW5jdGlvbiBnZXRUd2VlbihzY3JvbGxUbywgdmFycywgaW5pdGlhbFZhbHVlLCBjaGFuZ2UxLCBjaGFuZ2UyKSB7XG4gICAgdmFyIHR3ZWVuID0gZ2V0VHdlZW4udHdlZW4sXG4gICAgICAgIG9uQ29tcGxldGUgPSB2YXJzLm9uQ29tcGxldGUsXG4gICAgICAgIG1vZGlmaWVycyA9IHt9O1xuICAgIGluaXRpYWxWYWx1ZSA9IGluaXRpYWxWYWx1ZSB8fCBnZXRTY3JvbGwoKTtcbiAgICBjaGFuZ2UyID0gY2hhbmdlMSAmJiBjaGFuZ2UyIHx8IDA7IC8vIGlmIGNoYW5nZTEgaXMgMCwgd2Ugc2V0IHRoYXQgdG8gdGhlIGRpZmZlcmVuY2UgYW5kIGlnbm9yZSBjaGFuZ2UyLiBPdGhlcndpc2UsIHRoZXJlIHdvdWxkIGJlIGEgY29tcG91bmQgZWZmZWN0LlxuXG4gICAgY2hhbmdlMSA9IGNoYW5nZTEgfHwgc2Nyb2xsVG8gLSBpbml0aWFsVmFsdWU7XG4gICAgdHdlZW4gJiYgdHdlZW4ua2lsbCgpO1xuICAgIGxhc3RTY3JvbGwxID0gTWF0aC5yb3VuZChpbml0aWFsVmFsdWUpO1xuICAgIHZhcnNbcHJvcF0gPSBzY3JvbGxUbztcbiAgICB2YXJzLm1vZGlmaWVycyA9IG1vZGlmaWVycztcblxuICAgIG1vZGlmaWVyc1twcm9wXSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgdmFsdWUgPSBfcm91bmQoZ2V0U2Nyb2xsKCkpOyAvLyByb3VuZCBiZWNhdXNlIGluIHNvbWUgW3ZlcnkgdW5jb21tb25dIFdpbmRvd3MgZW52aXJvbm1lbnRzLCBpdCBjYW4gZ2V0IHJlcG9ydGVkIHdpdGggZGVjaW1hbHMgZXZlbiB0aG91Z2ggaXQgd2FzIHNldCB3aXRob3V0LlxuXG4gICAgICBpZiAodmFsdWUgIT09IGxhc3RTY3JvbGwxICYmIHZhbHVlICE9PSBsYXN0U2Nyb2xsMiAmJiBNYXRoLmFicyh2YWx1ZSAtIGxhc3RTY3JvbGwxKSA+IDIgJiYgTWF0aC5hYnModmFsdWUgLSBsYXN0U2Nyb2xsMikgPiAyKSB7XG4gICAgICAgIC8vIGlmIHRoZSB1c2VyIHNjcm9sbHMsIGtpbGwgdGhlIHR3ZWVuLiBpT1MgU2FmYXJpIGludGVybWl0dGVudGx5IG1pc3JlcG9ydHMgdGhlIHNjcm9sbCBwb3NpdGlvbiwgaXQgbWF5IGJlIHRoZSBtb3N0IHJlY2VudGx5LXNldCBvbmUgb3IgdGhlIG9uZSBiZWZvcmUgdGhhdCEgV2hlbiBTYWZhcmkgaXMgem9vbWVkIChDTUQtKyksIGl0IG9mdGVuIG1pc3JlcG9ydHMgYXMgMSBwaXhlbCBvZmYgdG9vISBTbyBpZiB3ZSBzZXQgdGhlIHNjcm9sbCBwb3NpdGlvbiB0byAxMjUsIGZvciBleGFtcGxlLCBpdCdsbCBhY3R1YWxseSByZXBvcnQgaXQgYXMgMTI0LlxuICAgICAgICB0d2Vlbi5raWxsKCk7XG4gICAgICAgIGdldFR3ZWVuLnR3ZWVuID0gMDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhbHVlID0gaW5pdGlhbFZhbHVlICsgY2hhbmdlMSAqIHR3ZWVuLnJhdGlvICsgY2hhbmdlMiAqIHR3ZWVuLnJhdGlvICogdHdlZW4ucmF0aW87XG4gICAgICB9XG5cbiAgICAgIGxhc3RTY3JvbGwyID0gbGFzdFNjcm9sbDE7XG4gICAgICByZXR1cm4gbGFzdFNjcm9sbDEgPSBfcm91bmQodmFsdWUpO1xuICAgIH07XG5cbiAgICB2YXJzLm9uQ29tcGxldGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBnZXRUd2Vlbi50d2VlbiA9IDA7XG4gICAgICBvbkNvbXBsZXRlICYmIG9uQ29tcGxldGUuY2FsbCh0d2Vlbik7XG4gICAgfTtcblxuICAgIHR3ZWVuID0gZ2V0VHdlZW4udHdlZW4gPSBnc2FwLnRvKHNjcm9sbGVyLCB2YXJzKTtcbiAgICByZXR1cm4gdHdlZW47XG4gIH07XG5cbiAgc2Nyb2xsZXJbcHJvcF0gPSBnZXRTY3JvbGw7XG5cbiAgZ2V0U2Nyb2xsLndoZWVsSGFuZGxlciA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gZ2V0VHdlZW4udHdlZW4gJiYgZ2V0VHdlZW4udHdlZW4ua2lsbCgpICYmIChnZXRUd2Vlbi50d2VlbiA9IDApO1xuICB9O1xuXG4gIF9hZGRMaXN0ZW5lcihzY3JvbGxlciwgXCJ3aGVlbFwiLCBnZXRTY3JvbGwud2hlZWxIYW5kbGVyKTsgLy8gV2luZG93cyBtYWNoaW5lcyBoYW5kbGUgbW91c2V3aGVlbCBzY3JvbGxpbmcgaW4gY2h1bmtzIChsaWtlIFwiMyBsaW5lcyBwZXIgc2Nyb2xsXCIpIG1lYW5pbmcgdGhlIHR5cGljYWwgc3RyYXRlZ3kgZm9yIGNhbmNlbGxpbmcgdGhlIHNjcm9sbCBpc24ndCBhcyBzZW5zaXRpdmUuIEl0J3MgbXVjaCBtb3JlIGxpa2VseSB0byBtYXRjaCBvbmUgb2YgdGhlIHByZXZpb3VzIDIgc2Nyb2xsIGV2ZW50IHBvc2l0aW9ucy4gU28gd2Uga2lsbCBhbnkgc25hcHBpbmcgYXMgc29vbiBhcyB0aGVyZSdzIGEgd2hlZWwgZXZlbnQuXG5cblxuICByZXR1cm4gZ2V0VHdlZW47XG59O1xuXG5leHBvcnQgdmFyIFNjcm9sbFRyaWdnZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBTY3JvbGxUcmlnZ2VyKHZhcnMsIGFuaW1hdGlvbikge1xuICAgIF9jb3JlSW5pdHRlZCB8fCBTY3JvbGxUcmlnZ2VyLnJlZ2lzdGVyKGdzYXApIHx8IGNvbnNvbGUud2FybihcIlBsZWFzZSBnc2FwLnJlZ2lzdGVyUGx1Z2luKFNjcm9sbFRyaWdnZXIpXCIpO1xuICAgIHRoaXMuaW5pdCh2YXJzLCBhbmltYXRpb24pO1xuICB9XG5cbiAgdmFyIF9wcm90byA9IFNjcm9sbFRyaWdnZXIucHJvdG90eXBlO1xuXG4gIF9wcm90by5pbml0ID0gZnVuY3Rpb24gaW5pdCh2YXJzLCBhbmltYXRpb24pIHtcbiAgICB0aGlzLnByb2dyZXNzID0gdGhpcy5zdGFydCA9IDA7XG4gICAgdGhpcy52YXJzICYmIHRoaXMua2lsbCh0cnVlLCB0cnVlKTsgLy8gaW4gY2FzZSBpdCdzIGJlaW5nIGluaXR0ZWQgYWdhaW5cblxuICAgIGlmICghX2VuYWJsZWQpIHtcbiAgICAgIHRoaXMudXBkYXRlID0gdGhpcy5yZWZyZXNoID0gdGhpcy5raWxsID0gX3Bhc3NUaHJvdWdoO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhcnMgPSBfc2V0RGVmYXVsdHMoX2lzU3RyaW5nKHZhcnMpIHx8IF9pc051bWJlcih2YXJzKSB8fCB2YXJzLm5vZGVUeXBlID8ge1xuICAgICAgdHJpZ2dlcjogdmFyc1xuICAgIH0gOiB2YXJzLCBfZGVmYXVsdHMpO1xuXG4gICAgdmFyIF92YXJzID0gdmFycyxcbiAgICAgICAgb25VcGRhdGUgPSBfdmFycy5vblVwZGF0ZSxcbiAgICAgICAgdG9nZ2xlQ2xhc3MgPSBfdmFycy50b2dnbGVDbGFzcyxcbiAgICAgICAgaWQgPSBfdmFycy5pZCxcbiAgICAgICAgb25Ub2dnbGUgPSBfdmFycy5vblRvZ2dsZSxcbiAgICAgICAgb25SZWZyZXNoID0gX3ZhcnMub25SZWZyZXNoLFxuICAgICAgICBzY3J1YiA9IF92YXJzLnNjcnViLFxuICAgICAgICB0cmlnZ2VyID0gX3ZhcnMudHJpZ2dlcixcbiAgICAgICAgcGluID0gX3ZhcnMucGluLFxuICAgICAgICBwaW5TcGFjaW5nID0gX3ZhcnMucGluU3BhY2luZyxcbiAgICAgICAgaW52YWxpZGF0ZU9uUmVmcmVzaCA9IF92YXJzLmludmFsaWRhdGVPblJlZnJlc2gsXG4gICAgICAgIGFudGljaXBhdGVQaW4gPSBfdmFycy5hbnRpY2lwYXRlUGluLFxuICAgICAgICBvblNjcnViQ29tcGxldGUgPSBfdmFycy5vblNjcnViQ29tcGxldGUsXG4gICAgICAgIG9uU25hcENvbXBsZXRlID0gX3ZhcnMub25TbmFwQ29tcGxldGUsXG4gICAgICAgIG9uY2UgPSBfdmFycy5vbmNlLFxuICAgICAgICBzbmFwID0gX3ZhcnMuc25hcCxcbiAgICAgICAgcGluUmVwYXJlbnQgPSBfdmFycy5waW5SZXBhcmVudCxcbiAgICAgICAgcGluU3BhY2VyID0gX3ZhcnMucGluU3BhY2VyLFxuICAgICAgICBjb250YWluZXJBbmltYXRpb24gPSBfdmFycy5jb250YWluZXJBbmltYXRpb24sXG4gICAgICAgIGZhc3RTY3JvbGxFbmQgPSBfdmFycy5mYXN0U2Nyb2xsRW5kLFxuICAgICAgICBwcmV2ZW50T3ZlcmxhcHMgPSBfdmFycy5wcmV2ZW50T3ZlcmxhcHMsXG4gICAgICAgIGRpcmVjdGlvbiA9IHZhcnMuaG9yaXpvbnRhbCB8fCB2YXJzLmNvbnRhaW5lckFuaW1hdGlvbiAmJiB2YXJzLmhvcml6b250YWwgIT09IGZhbHNlID8gX2hvcml6b250YWwgOiBfdmVydGljYWwsXG4gICAgICAgIGlzVG9nZ2xlID0gIXNjcnViICYmIHNjcnViICE9PSAwLFxuICAgICAgICBzY3JvbGxlciA9IF9nZXRUYXJnZXQodmFycy5zY3JvbGxlciB8fCBfd2luKSxcbiAgICAgICAgc2Nyb2xsZXJDYWNoZSA9IGdzYXAuY29yZS5nZXRDYWNoZShzY3JvbGxlciksXG4gICAgICAgIGlzVmlld3BvcnQgPSBfaXNWaWV3cG9ydChzY3JvbGxlciksXG4gICAgICAgIHVzZUZpeGVkUG9zaXRpb24gPSAoXCJwaW5UeXBlXCIgaW4gdmFycyA/IHZhcnMucGluVHlwZSA6IF9nZXRQcm94eVByb3Aoc2Nyb2xsZXIsIFwicGluVHlwZVwiKSB8fCBpc1ZpZXdwb3J0ICYmIFwiZml4ZWRcIikgPT09IFwiZml4ZWRcIixcbiAgICAgICAgY2FsbGJhY2tzID0gW3ZhcnMub25FbnRlciwgdmFycy5vbkxlYXZlLCB2YXJzLm9uRW50ZXJCYWNrLCB2YXJzLm9uTGVhdmVCYWNrXSxcbiAgICAgICAgdG9nZ2xlQWN0aW9ucyA9IGlzVG9nZ2xlICYmIHZhcnMudG9nZ2xlQWN0aW9ucy5zcGxpdChcIiBcIiksXG4gICAgICAgIG1hcmtlcnMgPSBcIm1hcmtlcnNcIiBpbiB2YXJzID8gdmFycy5tYXJrZXJzIDogX2RlZmF1bHRzLm1hcmtlcnMsXG4gICAgICAgIGJvcmRlcldpZHRoID0gaXNWaWV3cG9ydCA/IDAgOiBwYXJzZUZsb2F0KF9nZXRDb21wdXRlZFN0eWxlKHNjcm9sbGVyKVtcImJvcmRlclwiICsgZGlyZWN0aW9uLnAyICsgX1dpZHRoXSkgfHwgMCxcbiAgICAgICAgc2VsZiA9IHRoaXMsXG4gICAgICAgIG9uUmVmcmVzaEluaXQgPSB2YXJzLm9uUmVmcmVzaEluaXQgJiYgZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHZhcnMub25SZWZyZXNoSW5pdChzZWxmKTtcbiAgICB9LFxuICAgICAgICBnZXRTY3JvbGxlclNpemUgPSBfZ2V0U2l6ZUZ1bmMoc2Nyb2xsZXIsIGlzVmlld3BvcnQsIGRpcmVjdGlvbiksXG4gICAgICAgIGdldFNjcm9sbGVyT2Zmc2V0cyA9IF9nZXRPZmZzZXRzRnVuYyhzY3JvbGxlciwgaXNWaWV3cG9ydCksXG4gICAgICAgIGxhc3RTbmFwID0gMCxcbiAgICAgICAgbGFzdFJlZnJlc2ggPSAwLFxuICAgICAgICBzY3JvbGxGdW5jID0gX2dldFNjcm9sbEZ1bmMoc2Nyb2xsZXIsIGRpcmVjdGlvbiksXG4gICAgICAgIHR3ZWVuVG8sXG4gICAgICAgIHBpbkNhY2hlLFxuICAgICAgICBzbmFwRnVuYyxcbiAgICAgICAgc2Nyb2xsMSxcbiAgICAgICAgc2Nyb2xsMixcbiAgICAgICAgc3RhcnQsXG4gICAgICAgIGVuZCxcbiAgICAgICAgbWFya2VyU3RhcnQsXG4gICAgICAgIG1hcmtlckVuZCxcbiAgICAgICAgbWFya2VyU3RhcnRUcmlnZ2VyLFxuICAgICAgICBtYXJrZXJFbmRUcmlnZ2VyLFxuICAgICAgICBtYXJrZXJWYXJzLFxuICAgICAgICBjaGFuZ2UsXG4gICAgICAgIHBpbk9yaWdpbmFsU3RhdGUsXG4gICAgICAgIHBpbkFjdGl2ZVN0YXRlLFxuICAgICAgICBwaW5TdGF0ZSxcbiAgICAgICAgc3BhY2VyLFxuICAgICAgICBvZmZzZXQsXG4gICAgICAgIHBpbkdldHRlcixcbiAgICAgICAgcGluU2V0dGVyLFxuICAgICAgICBwaW5TdGFydCxcbiAgICAgICAgcGluQ2hhbmdlLFxuICAgICAgICBzcGFjaW5nU3RhcnQsXG4gICAgICAgIHNwYWNlclN0YXRlLFxuICAgICAgICBtYXJrZXJTdGFydFNldHRlcixcbiAgICAgICAgbWFya2VyRW5kU2V0dGVyLFxuICAgICAgICBjcyxcbiAgICAgICAgc25hcDEsXG4gICAgICAgIHNuYXAyLFxuICAgICAgICBzY3J1YlR3ZWVuLFxuICAgICAgICBzY3J1YlNtb290aCxcbiAgICAgICAgc25hcER1ckNsYW1wLFxuICAgICAgICBzbmFwRGVsYXllZENhbGwsXG4gICAgICAgIHByZXZQcm9ncmVzcyxcbiAgICAgICAgcHJldlNjcm9sbCxcbiAgICAgICAgcHJldkFuaW1Qcm9ncmVzcyxcbiAgICAgICAgY2FNYXJrZXJTZXR0ZXIsXG4gICAgICAgIGN1c3RvbVJldmVydFJldHVybjtcblxuICAgIHNlbGYubWVkaWEgPSBfY3JlYXRpbmdNZWRpYTtcbiAgICBzZWxmLl9kaXIgPSBkaXJlY3Rpb247XG4gICAgYW50aWNpcGF0ZVBpbiAqPSA0NTtcbiAgICBzZWxmLnNjcm9sbGVyID0gc2Nyb2xsZXI7XG4gICAgc2VsZi5zY3JvbGwgPSBjb250YWluZXJBbmltYXRpb24gPyBjb250YWluZXJBbmltYXRpb24udGltZS5iaW5kKGNvbnRhaW5lckFuaW1hdGlvbikgOiBzY3JvbGxGdW5jO1xuICAgIHNjcm9sbDEgPSBzY3JvbGxGdW5jKCk7XG4gICAgc2VsZi52YXJzID0gdmFycztcbiAgICBhbmltYXRpb24gPSBhbmltYXRpb24gfHwgdmFycy5hbmltYXRpb247XG5cbiAgICBpZiAoXCJyZWZyZXNoUHJpb3JpdHlcIiBpbiB2YXJzKSB7XG4gICAgICBfc29ydCA9IDE7XG4gICAgICB2YXJzLnJlZnJlc2hQcmlvcml0eSA9PT0gLTk5OTkgJiYgKF9wcmltYXJ5ID0gc2VsZik7IC8vIHVzZWQgYnkgU2Nyb2xsU21vb3RoZXJcbiAgICB9XG5cbiAgICBzY3JvbGxlckNhY2hlLnR3ZWVuU2Nyb2xsID0gc2Nyb2xsZXJDYWNoZS50d2VlblNjcm9sbCB8fCB7XG4gICAgICB0b3A6IF9nZXRUd2VlbkNyZWF0b3Ioc2Nyb2xsZXIsIF92ZXJ0aWNhbCksXG4gICAgICBsZWZ0OiBfZ2V0VHdlZW5DcmVhdG9yKHNjcm9sbGVyLCBfaG9yaXpvbnRhbClcbiAgICB9O1xuICAgIHNlbGYudHdlZW5UbyA9IHR3ZWVuVG8gPSBzY3JvbGxlckNhY2hlLnR3ZWVuU2Nyb2xsW2RpcmVjdGlvbi5wXTtcblxuICAgIHNlbGYuc2NydWJEdXJhdGlvbiA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgc2NydWJTbW9vdGggPSBfaXNOdW1iZXIodmFsdWUpICYmIHZhbHVlO1xuXG4gICAgICBpZiAoIXNjcnViU21vb3RoKSB7XG4gICAgICAgIHNjcnViVHdlZW4gJiYgc2NydWJUd2Vlbi5wcm9ncmVzcygxKS5raWxsKCk7XG4gICAgICAgIHNjcnViVHdlZW4gPSAwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2NydWJUd2VlbiA/IHNjcnViVHdlZW4uZHVyYXRpb24odmFsdWUpIDogc2NydWJUd2VlbiA9IGdzYXAudG8oYW5pbWF0aW9uLCB7XG4gICAgICAgICAgZWFzZTogXCJleHBvXCIsXG4gICAgICAgICAgdG90YWxQcm9ncmVzczogXCIrPTAuMDAxXCIsXG4gICAgICAgICAgZHVyYXRpb246IHNjcnViU21vb3RoLFxuICAgICAgICAgIHBhdXNlZDogdHJ1ZSxcbiAgICAgICAgICBvbkNvbXBsZXRlOiBmdW5jdGlvbiBvbkNvbXBsZXRlKCkge1xuICAgICAgICAgICAgcmV0dXJuIG9uU2NydWJDb21wbGV0ZSAmJiBvblNjcnViQ29tcGxldGUoc2VsZik7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgaWYgKGFuaW1hdGlvbikge1xuICAgICAgYW5pbWF0aW9uLnZhcnMubGF6eSA9IGZhbHNlO1xuICAgICAgYW5pbWF0aW9uLl9pbml0dGVkIHx8IGFuaW1hdGlvbi52YXJzLmltbWVkaWF0ZVJlbmRlciAhPT0gZmFsc2UgJiYgdmFycy5pbW1lZGlhdGVSZW5kZXIgIT09IGZhbHNlICYmIGFuaW1hdGlvbi5yZW5kZXIoMCwgdHJ1ZSwgdHJ1ZSk7XG4gICAgICBzZWxmLmFuaW1hdGlvbiA9IGFuaW1hdGlvbi5wYXVzZSgpO1xuICAgICAgYW5pbWF0aW9uLnNjcm9sbFRyaWdnZXIgPSBzZWxmO1xuICAgICAgc2VsZi5zY3J1YkR1cmF0aW9uKHNjcnViKTtcbiAgICAgIHNuYXAxID0gMDtcbiAgICAgIGlkIHx8IChpZCA9IGFuaW1hdGlvbi52YXJzLmlkKTtcbiAgICB9XG5cbiAgICBfdHJpZ2dlcnMucHVzaChzZWxmKTtcblxuICAgIGlmIChzbmFwKSB7XG4gICAgICBpZiAoIV9pc09iamVjdChzbmFwKSB8fCBzbmFwLnB1c2gpIHtcbiAgICAgICAgc25hcCA9IHtcbiAgICAgICAgICBzbmFwVG86IHNuYXBcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgXCJzY3JvbGxCZWhhdmlvclwiIGluIF9ib2R5LnN0eWxlICYmIGdzYXAuc2V0KGlzVmlld3BvcnQgPyBbX2JvZHksIF9kb2NFbF0gOiBzY3JvbGxlciwge1xuICAgICAgICBzY3JvbGxCZWhhdmlvcjogXCJhdXRvXCJcbiAgICAgIH0pOyAvLyBzbW9vdGggc2Nyb2xsaW5nIGRvZXNuJ3Qgd29yayB3aXRoIHNuYXAuXG5cbiAgICAgIHNuYXBGdW5jID0gX2lzRnVuY3Rpb24oc25hcC5zbmFwVG8pID8gc25hcC5zbmFwVG8gOiBzbmFwLnNuYXBUbyA9PT0gXCJsYWJlbHNcIiA/IF9nZXRDbG9zZXN0TGFiZWwoYW5pbWF0aW9uKSA6IHNuYXAuc25hcFRvID09PSBcImxhYmVsc0RpcmVjdGlvbmFsXCIgPyBfZ2V0TGFiZWxBdERpcmVjdGlvbihhbmltYXRpb24pIDogc25hcC5kaXJlY3Rpb25hbCAhPT0gZmFsc2UgPyBmdW5jdGlvbiAodmFsdWUsIHN0KSB7XG4gICAgICAgIHJldHVybiBfc25hcERpcmVjdGlvbmFsKHNuYXAuc25hcFRvKSh2YWx1ZSwgX2dldFRpbWUoKSAtIGxhc3RSZWZyZXNoIDwgNTAwID8gMCA6IHN0LmRpcmVjdGlvbik7XG4gICAgICB9IDogZ3NhcC51dGlscy5zbmFwKHNuYXAuc25hcFRvKTtcbiAgICAgIHNuYXBEdXJDbGFtcCA9IHNuYXAuZHVyYXRpb24gfHwge1xuICAgICAgICBtaW46IDAuMSxcbiAgICAgICAgbWF4OiAyXG4gICAgICB9O1xuICAgICAgc25hcER1ckNsYW1wID0gX2lzT2JqZWN0KHNuYXBEdXJDbGFtcCkgPyBfY2xhbXAoc25hcER1ckNsYW1wLm1pbiwgc25hcER1ckNsYW1wLm1heCkgOiBfY2xhbXAoc25hcER1ckNsYW1wLCBzbmFwRHVyQ2xhbXApO1xuICAgICAgc25hcERlbGF5ZWRDYWxsID0gZ3NhcC5kZWxheWVkQ2FsbChzbmFwLmRlbGF5IHx8IHNjcnViU21vb3RoIC8gMiB8fCAwLjEsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHNjcm9sbCA9IHNjcm9sbEZ1bmMoKSxcbiAgICAgICAgICAgIHJlZnJlc2hlZFJlY2VudGx5ID0gX2dldFRpbWUoKSAtIGxhc3RSZWZyZXNoIDwgNTAwLFxuICAgICAgICAgICAgdHdlZW4gPSB0d2VlblRvLnR3ZWVuO1xuXG4gICAgICAgIGlmICgocmVmcmVzaGVkUmVjZW50bHkgfHwgTWF0aC5hYnMoc2VsZi5nZXRWZWxvY2l0eSgpKSA8IDEwKSAmJiAhdHdlZW4gJiYgIV9wb2ludGVySXNEb3duICYmIGxhc3RTbmFwICE9PSBzY3JvbGwpIHtcbiAgICAgICAgICB2YXIgcHJvZ3Jlc3MgPSAoc2Nyb2xsIC0gc3RhcnQpIC8gY2hhbmdlLFxuICAgICAgICAgICAgICB0b3RhbFByb2dyZXNzID0gYW5pbWF0aW9uICYmICFpc1RvZ2dsZSA/IGFuaW1hdGlvbi50b3RhbFByb2dyZXNzKCkgOiBwcm9ncmVzcyxcbiAgICAgICAgICAgICAgdmVsb2NpdHkgPSByZWZyZXNoZWRSZWNlbnRseSA/IDAgOiAodG90YWxQcm9ncmVzcyAtIHNuYXAyKSAvIChfZ2V0VGltZSgpIC0gX3RpbWUyKSAqIDEwMDAgfHwgMCxcbiAgICAgICAgICAgICAgY2hhbmdlMSA9IGdzYXAudXRpbHMuY2xhbXAoLXByb2dyZXNzLCAxIC0gcHJvZ3Jlc3MsIF9hYnModmVsb2NpdHkgLyAyKSAqIHZlbG9jaXR5IC8gMC4xODUpLFxuICAgICAgICAgICAgICBuYXR1cmFsRW5kID0gcHJvZ3Jlc3MgKyAoc25hcC5pbmVydGlhID09PSBmYWxzZSA/IDAgOiBjaGFuZ2UxKSxcbiAgICAgICAgICAgICAgZW5kVmFsdWUgPSBfY2xhbXAoMCwgMSwgc25hcEZ1bmMobmF0dXJhbEVuZCwgc2VsZikpLFxuICAgICAgICAgICAgICBlbmRTY3JvbGwgPSBNYXRoLnJvdW5kKHN0YXJ0ICsgZW5kVmFsdWUgKiBjaGFuZ2UpLFxuICAgICAgICAgICAgICBfc25hcCA9IHNuYXAsXG4gICAgICAgICAgICAgIG9uU3RhcnQgPSBfc25hcC5vblN0YXJ0LFxuICAgICAgICAgICAgICBfb25JbnRlcnJ1cHQgPSBfc25hcC5vbkludGVycnVwdCxcbiAgICAgICAgICAgICAgX29uQ29tcGxldGUgPSBfc25hcC5vbkNvbXBsZXRlO1xuXG4gICAgICAgICAgaWYgKHNjcm9sbCA8PSBlbmQgJiYgc2Nyb2xsID49IHN0YXJ0ICYmIGVuZFNjcm9sbCAhPT0gc2Nyb2xsKSB7XG4gICAgICAgICAgICBpZiAodHdlZW4gJiYgIXR3ZWVuLl9pbml0dGVkICYmIHR3ZWVuLmRhdGEgPD0gX2FicyhlbmRTY3JvbGwgLSBzY3JvbGwpKSB7XG4gICAgICAgICAgICAgIC8vIHRoZXJlJ3MgYW4gb3ZlcmxhcHBpbmcgc25hcCEgU28gd2UgbXVzdCBmaWd1cmUgb3V0IHdoaWNoIG9uZSBpcyBjbG9zZXIgYW5kIGxldCB0aGF0IHR3ZWVuIGxpdmUuXG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHNuYXAuaW5lcnRpYSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgY2hhbmdlMSA9IGVuZFZhbHVlIC0gcHJvZ3Jlc3M7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHR3ZWVuVG8oZW5kU2Nyb2xsLCB7XG4gICAgICAgICAgICAgIGR1cmF0aW9uOiBzbmFwRHVyQ2xhbXAoX2FicyhNYXRoLm1heChfYWJzKG5hdHVyYWxFbmQgLSB0b3RhbFByb2dyZXNzKSwgX2FicyhlbmRWYWx1ZSAtIHRvdGFsUHJvZ3Jlc3MpKSAqIDAuMTg1IC8gdmVsb2NpdHkgLyAwLjA1IHx8IDApKSxcbiAgICAgICAgICAgICAgZWFzZTogc25hcC5lYXNlIHx8IFwicG93ZXIzXCIsXG4gICAgICAgICAgICAgIGRhdGE6IF9hYnMoZW5kU2Nyb2xsIC0gc2Nyb2xsKSxcbiAgICAgICAgICAgICAgLy8gcmVjb3JkIHRoZSBkaXN0YW5jZSBzbyB0aGF0IGlmIGFub3RoZXIgc25hcCB0d2VlbiBvY2N1cnMgKGNvbmZsaWN0KSB3ZSBjYW4gcHJpb3JpdGl6ZSB0aGUgY2xvc2VzdCBzbmFwLlxuICAgICAgICAgICAgICBvbkludGVycnVwdDogZnVuY3Rpb24gb25JbnRlcnJ1cHQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNuYXBEZWxheWVkQ2FsbC5yZXN0YXJ0KHRydWUpICYmIF9vbkludGVycnVwdCAmJiBfb25JbnRlcnJ1cHQoc2VsZik7XG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIG9uQ29tcGxldGU6IGZ1bmN0aW9uIG9uQ29tcGxldGUoKSB7XG4gICAgICAgICAgICAgICAgc2VsZi51cGRhdGUoKTtcbiAgICAgICAgICAgICAgICBsYXN0U25hcCA9IHNjcm9sbEZ1bmMoKTtcbiAgICAgICAgICAgICAgICBzbmFwMSA9IHNuYXAyID0gYW5pbWF0aW9uICYmICFpc1RvZ2dsZSA/IGFuaW1hdGlvbi50b3RhbFByb2dyZXNzKCkgOiBzZWxmLnByb2dyZXNzO1xuICAgICAgICAgICAgICAgIG9uU25hcENvbXBsZXRlICYmIG9uU25hcENvbXBsZXRlKHNlbGYpO1xuICAgICAgICAgICAgICAgIF9vbkNvbXBsZXRlICYmIF9vbkNvbXBsZXRlKHNlbGYpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCBzY3JvbGwsIGNoYW5nZTEgKiBjaGFuZ2UsIGVuZFNjcm9sbCAtIHNjcm9sbCAtIGNoYW5nZTEgKiBjaGFuZ2UpO1xuICAgICAgICAgICAgb25TdGFydCAmJiBvblN0YXJ0KHNlbGYsIHR3ZWVuVG8udHdlZW4pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChzZWxmLmlzQWN0aXZlICYmIGxhc3RTbmFwICE9PSBzY3JvbGwpIHtcbiAgICAgICAgICBzbmFwRGVsYXllZENhbGwucmVzdGFydCh0cnVlKTtcbiAgICAgICAgfVxuICAgICAgfSkucGF1c2UoKTtcbiAgICB9XG5cbiAgICBpZCAmJiAoX2lkc1tpZF0gPSBzZWxmKTtcbiAgICB0cmlnZ2VyID0gc2VsZi50cmlnZ2VyID0gX2dldFRhcmdldCh0cmlnZ2VyIHx8IHBpbik7IC8vIGlmIGEgdHJpZ2dlciBoYXMgc29tZSBraW5kIG9mIHNjcm9sbC1yZWxhdGVkIGVmZmVjdCBhcHBsaWVkIHRoYXQgY291bGQgY29udGFtaW5hdGUgdGhlIFwieVwiIG9yIFwieFwiIHBvc2l0aW9uIChsaWtlIGEgU2Nyb2xsU21vb3RoZXIgZWZmZWN0KSwgd2UgbmVlZGVkIGEgd2F5IHRvIHRlbXBvcmFyaWx5IHJldmVydCBpdCwgc28gd2UgdXNlIHRoZSBzdFJldmVydCBwcm9wZXJ0eSBvZiB0aGUgZ3NDYWNoZS4gSXQgY2FuIHJldHVybiBhbm90aGVyIGZ1bmN0aW9uIHRoYXQgd2UnbGwgY2FsbCBhdCB0aGUgZW5kIHNvIGl0IGNhbiByZXR1cm4gdG8gaXRzIG5vcm1hbCBzdGF0ZS5cblxuICAgIGN1c3RvbVJldmVydFJldHVybiA9IHRyaWdnZXIgJiYgdHJpZ2dlci5fZ3NhcCAmJiB0cmlnZ2VyLl9nc2FwLnN0UmV2ZXJ0O1xuICAgIGN1c3RvbVJldmVydFJldHVybiAmJiAoY3VzdG9tUmV2ZXJ0UmV0dXJuID0gY3VzdG9tUmV2ZXJ0UmV0dXJuKHNlbGYpKTtcbiAgICBwaW4gPSBwaW4gPT09IHRydWUgPyB0cmlnZ2VyIDogX2dldFRhcmdldChwaW4pO1xuICAgIF9pc1N0cmluZyh0b2dnbGVDbGFzcykgJiYgKHRvZ2dsZUNsYXNzID0ge1xuICAgICAgdGFyZ2V0czogdHJpZ2dlcixcbiAgICAgIGNsYXNzTmFtZTogdG9nZ2xlQ2xhc3NcbiAgICB9KTtcblxuICAgIGlmIChwaW4pIHtcbiAgICAgIHBpblNwYWNpbmcgPT09IGZhbHNlIHx8IHBpblNwYWNpbmcgPT09IF9tYXJnaW4gfHwgKHBpblNwYWNpbmcgPSAhcGluU3BhY2luZyAmJiBfZ2V0Q29tcHV0ZWRTdHlsZShwaW4ucGFyZW50Tm9kZSkuZGlzcGxheSA9PT0gXCJmbGV4XCIgPyBmYWxzZSA6IF9wYWRkaW5nKTsgLy8gaWYgdGhlIHBhcmVudCBpcyBkaXNwbGF5OiBmbGV4LCBkb24ndCBhcHBseSBwaW5TcGFjaW5nIGJ5IGRlZmF1bHQuXG5cbiAgICAgIHNlbGYucGluID0gcGluO1xuICAgICAgdmFycy5mb3JjZTNEICE9PSBmYWxzZSAmJiBnc2FwLnNldChwaW4sIHtcbiAgICAgICAgZm9yY2UzRDogdHJ1ZVxuICAgICAgfSk7XG4gICAgICBwaW5DYWNoZSA9IGdzYXAuY29yZS5nZXRDYWNoZShwaW4pO1xuXG4gICAgICBpZiAoIXBpbkNhY2hlLnNwYWNlcikge1xuICAgICAgICAvLyByZWNvcmQgdGhlIHNwYWNlciBhbmQgcGluT3JpZ2luYWxTdGF0ZSBvbiB0aGUgY2FjaGUgaW4gY2FzZSBzb21lb25lIHRyaWVzIHBpbm5pbmcgdGhlIHNhbWUgZWxlbWVudCB3aXRoIE1VTFRJUExFIFNjcm9sbFRyaWdnZXJzIC0gd2UgZG9uJ3Qgd2FudCB0byBoYXZlIG11bHRpcGxlIHNwYWNlcnMgb3IgcmVjb3JkIHRoZSBcIm9yaWdpbmFsXCIgcGluIHN0YXRlIGFmdGVyIGl0IGhhcyBhbHJlYWR5IGJlZW4gYWZmZWN0ZWQgYnkgYW5vdGhlciBTY3JvbGxUcmlnZ2VyLlxuICAgICAgICBpZiAocGluU3BhY2VyKSB7XG4gICAgICAgICAgcGluU3BhY2VyID0gX2dldFRhcmdldChwaW5TcGFjZXIpO1xuICAgICAgICAgIHBpblNwYWNlciAmJiAhcGluU3BhY2VyLm5vZGVUeXBlICYmIChwaW5TcGFjZXIgPSBwaW5TcGFjZXIuY3VycmVudCB8fCBwaW5TcGFjZXIubmF0aXZlRWxlbWVudCk7IC8vIGZvciBSZWFjdCAmIEFuZ3VsYXJcblxuICAgICAgICAgIHBpbkNhY2hlLnNwYWNlcklzTmF0aXZlID0gISFwaW5TcGFjZXI7XG4gICAgICAgICAgcGluU3BhY2VyICYmIChwaW5DYWNoZS5zcGFjZXJTdGF0ZSA9IF9nZXRTdGF0ZShwaW5TcGFjZXIpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHBpbkNhY2hlLnNwYWNlciA9IHNwYWNlciA9IHBpblNwYWNlciB8fCBfZG9jLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgIHNwYWNlci5jbGFzc0xpc3QuYWRkKFwicGluLXNwYWNlclwiKTtcbiAgICAgICAgaWQgJiYgc3BhY2VyLmNsYXNzTGlzdC5hZGQoXCJwaW4tc3BhY2VyLVwiICsgaWQpO1xuICAgICAgICBwaW5DYWNoZS5waW5TdGF0ZSA9IHBpbk9yaWdpbmFsU3RhdGUgPSBfZ2V0U3RhdGUocGluKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBpbk9yaWdpbmFsU3RhdGUgPSBwaW5DYWNoZS5waW5TdGF0ZTtcbiAgICAgIH1cblxuICAgICAgc2VsZi5zcGFjZXIgPSBzcGFjZXIgPSBwaW5DYWNoZS5zcGFjZXI7XG4gICAgICBjcyA9IF9nZXRDb21wdXRlZFN0eWxlKHBpbik7XG4gICAgICBzcGFjaW5nU3RhcnQgPSBjc1twaW5TcGFjaW5nICsgZGlyZWN0aW9uLm9zMl07XG4gICAgICBwaW5HZXR0ZXIgPSBnc2FwLmdldFByb3BlcnR5KHBpbik7XG4gICAgICBwaW5TZXR0ZXIgPSBnc2FwLnF1aWNrU2V0dGVyKHBpbiwgZGlyZWN0aW9uLmEsIF9weCk7IC8vIHBpbi5maXJzdENoaWxkICYmICFfbWF4U2Nyb2xsKHBpbiwgZGlyZWN0aW9uKSAmJiAocGluLnN0eWxlLm92ZXJmbG93ID0gXCJoaWRkZW5cIik7IC8vIHByb3RlY3RzIGZyb20gY29sbGFwc2luZyBtYXJnaW5zLCBidXQgY2FuIGhhdmUgdW5pbnRlbmRlZCBjb25zZXF1ZW5jZXMgYXMgZGVtb25zdHJhdGVkIGhlcmU6IGh0dHBzOi8vY29kZXBlbi5pby9HcmVlblNvY2svcGVuLzFlNDJjN2E3M2JmYTQwOWQyY2YxZTE4NGU3YTQyNDhkIHNvIGl0IHdhcyByZW1vdmVkIGluIGZhdm9yIG9mIGp1c3QgdGVsbGluZyBwZW9wbGUgdG8gc2V0IHVwIHRoZWlyIENTUyB0byBhdm9pZCB0aGUgY29sbGFwc2luZyBtYXJnaW5zIChvdmVyZmxvdzogaGlkZGVuIHwgYXV0byBpcyBqdXN0IG9uZSBvcHRpb24uIEFub3RoZXIgaXMgYm9yZGVyLXRvcDogMXB4IHNvbGlkIHRyYW5zcGFyZW50KS5cblxuICAgICAgX3N3YXBQaW5JbihwaW4sIHNwYWNlciwgY3MpO1xuXG4gICAgICBwaW5TdGF0ZSA9IF9nZXRTdGF0ZShwaW4pO1xuICAgIH1cblxuICAgIGlmIChtYXJrZXJzKSB7XG4gICAgICBtYXJrZXJWYXJzID0gX2lzT2JqZWN0KG1hcmtlcnMpID8gX3NldERlZmF1bHRzKG1hcmtlcnMsIF9tYXJrZXJEZWZhdWx0cykgOiBfbWFya2VyRGVmYXVsdHM7XG4gICAgICBtYXJrZXJTdGFydFRyaWdnZXIgPSBfY3JlYXRlTWFya2VyKFwic2Nyb2xsZXItc3RhcnRcIiwgaWQsIHNjcm9sbGVyLCBkaXJlY3Rpb24sIG1hcmtlclZhcnMsIDApO1xuICAgICAgbWFya2VyRW5kVHJpZ2dlciA9IF9jcmVhdGVNYXJrZXIoXCJzY3JvbGxlci1lbmRcIiwgaWQsIHNjcm9sbGVyLCBkaXJlY3Rpb24sIG1hcmtlclZhcnMsIDAsIG1hcmtlclN0YXJ0VHJpZ2dlcik7XG4gICAgICBvZmZzZXQgPSBtYXJrZXJTdGFydFRyaWdnZXJbXCJvZmZzZXRcIiArIGRpcmVjdGlvbi5vcC5kMl07XG5cbiAgICAgIHZhciBjb250ZW50ID0gX2dldFRhcmdldChfZ2V0UHJveHlQcm9wKHNjcm9sbGVyLCBcImNvbnRlbnRcIikgfHwgc2Nyb2xsZXIpO1xuXG4gICAgICBtYXJrZXJTdGFydCA9IHRoaXMubWFya2VyU3RhcnQgPSBfY3JlYXRlTWFya2VyKFwic3RhcnRcIiwgaWQsIGNvbnRlbnQsIGRpcmVjdGlvbiwgbWFya2VyVmFycywgb2Zmc2V0LCAwLCBjb250YWluZXJBbmltYXRpb24pO1xuICAgICAgbWFya2VyRW5kID0gdGhpcy5tYXJrZXJFbmQgPSBfY3JlYXRlTWFya2VyKFwiZW5kXCIsIGlkLCBjb250ZW50LCBkaXJlY3Rpb24sIG1hcmtlclZhcnMsIG9mZnNldCwgMCwgY29udGFpbmVyQW5pbWF0aW9uKTtcbiAgICAgIGNvbnRhaW5lckFuaW1hdGlvbiAmJiAoY2FNYXJrZXJTZXR0ZXIgPSBnc2FwLnF1aWNrU2V0dGVyKFttYXJrZXJTdGFydCwgbWFya2VyRW5kXSwgZGlyZWN0aW9uLmEsIF9weCkpO1xuXG4gICAgICBpZiAoIXVzZUZpeGVkUG9zaXRpb24gJiYgIShfcHJveGllcy5sZW5ndGggJiYgX2dldFByb3h5UHJvcChzY3JvbGxlciwgXCJmaXhlZE1hcmtlcnNcIikgPT09IHRydWUpKSB7XG4gICAgICAgIF9tYWtlUG9zaXRpb25hYmxlKGlzVmlld3BvcnQgPyBfYm9keSA6IHNjcm9sbGVyKTtcblxuICAgICAgICBnc2FwLnNldChbbWFya2VyU3RhcnRUcmlnZ2VyLCBtYXJrZXJFbmRUcmlnZ2VyXSwge1xuICAgICAgICAgIGZvcmNlM0Q6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIG1hcmtlclN0YXJ0U2V0dGVyID0gZ3NhcC5xdWlja1NldHRlcihtYXJrZXJTdGFydFRyaWdnZXIsIGRpcmVjdGlvbi5hLCBfcHgpO1xuICAgICAgICBtYXJrZXJFbmRTZXR0ZXIgPSBnc2FwLnF1aWNrU2V0dGVyKG1hcmtlckVuZFRyaWdnZXIsIGRpcmVjdGlvbi5hLCBfcHgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChjb250YWluZXJBbmltYXRpb24pIHtcbiAgICAgIHZhciBvbGRPblVwZGF0ZSA9IGNvbnRhaW5lckFuaW1hdGlvbi52YXJzLm9uVXBkYXRlLFxuICAgICAgICAgIG9sZFBhcmFtcyA9IGNvbnRhaW5lckFuaW1hdGlvbi52YXJzLm9uVXBkYXRlUGFyYW1zO1xuICAgICAgY29udGFpbmVyQW5pbWF0aW9uLmV2ZW50Q2FsbGJhY2soXCJvblVwZGF0ZVwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHNlbGYudXBkYXRlKDAsIDAsIDEpO1xuICAgICAgICBvbGRPblVwZGF0ZSAmJiBvbGRPblVwZGF0ZS5hcHBseShvbGRQYXJhbXMgfHwgW10pO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgc2VsZi5wcmV2aW91cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBfdHJpZ2dlcnNbX3RyaWdnZXJzLmluZGV4T2Yoc2VsZikgLSAxXTtcbiAgICB9O1xuXG4gICAgc2VsZi5uZXh0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIF90cmlnZ2Vyc1tfdHJpZ2dlcnMuaW5kZXhPZihzZWxmKSArIDFdO1xuICAgIH07XG5cbiAgICBzZWxmLnJldmVydCA9IGZ1bmN0aW9uIChyZXZlcnQpIHtcbiAgICAgIHZhciByID0gcmV2ZXJ0ICE9PSBmYWxzZSB8fCAhc2VsZi5lbmFibGVkLFxuICAgICAgICAgIHByZXZSZWZyZXNoaW5nID0gX3JlZnJlc2hpbmc7XG5cbiAgICAgIGlmIChyICE9PSBzZWxmLmlzUmV2ZXJ0ZWQpIHtcbiAgICAgICAgaWYgKHIpIHtcbiAgICAgICAgICBzZWxmLnNjcm9sbC5yZWMgfHwgIV9yZWZyZXNoaW5nIHx8ICFfcmVmcmVzaGluZ0FsbCB8fCAoc2VsZi5zY3JvbGwucmVjID0gc2Nyb2xsRnVuYygpKTtcbiAgICAgICAgICBwcmV2U2Nyb2xsID0gTWF0aC5tYXgoc2Nyb2xsRnVuYygpLCBzZWxmLnNjcm9sbC5yZWMgfHwgMCk7IC8vIHJlY29yZCB0aGUgc2Nyb2xsIHNvIHdlIGNhbiByZXZlcnQgbGF0ZXIgKHJlcG9zaXRpb25pbmcvcGlubmluZyB0aGluZ3MgY2FuIGFmZmVjdCBzY3JvbGwgcG9zaXRpb24pLiBJbiB0aGUgc3RhdGljIHJlZnJlc2goKSBtZXRob2QsIHdlIGZpcnN0IHJlY29yZCBhbGwgdGhlIHNjcm9sbCBwb3NpdGlvbnMgYXMgYSByZWZlcmVuY2UuXG5cbiAgICAgICAgICBwcmV2UHJvZ3Jlc3MgPSBzZWxmLnByb2dyZXNzO1xuICAgICAgICAgIHByZXZBbmltUHJvZ3Jlc3MgPSBhbmltYXRpb24gJiYgYW5pbWF0aW9uLnByb2dyZXNzKCk7XG4gICAgICAgIH1cblxuICAgICAgICBtYXJrZXJTdGFydCAmJiBbbWFya2VyU3RhcnQsIG1hcmtlckVuZCwgbWFya2VyU3RhcnRUcmlnZ2VyLCBtYXJrZXJFbmRUcmlnZ2VyXS5mb3JFYWNoKGZ1bmN0aW9uIChtKSB7XG4gICAgICAgICAgcmV0dXJuIG0uc3R5bGUuZGlzcGxheSA9IHIgPyBcIm5vbmVcIiA6IFwiYmxvY2tcIjtcbiAgICAgICAgfSk7XG4gICAgICAgIHIgJiYgKF9yZWZyZXNoaW5nID0gMSk7XG4gICAgICAgIHNlbGYudXBkYXRlKHIpOyAvLyBtYWtlIHN1cmUgdGhlIHBpbiBpcyBiYWNrIGluIGl0cyBvcmlnaW5hbCBwb3NpdGlvbiBzbyB0aGF0IGFsbCB0aGUgbWVhc3VyZW1lbnRzIGFyZSBjb3JyZWN0LlxuXG4gICAgICAgIF9yZWZyZXNoaW5nID0gcHJldlJlZnJlc2hpbmc7XG4gICAgICAgIHBpbiAmJiAociA/IF9zd2FwUGluT3V0KHBpbiwgc3BhY2VyLCBwaW5PcmlnaW5hbFN0YXRlKSA6ICghcGluUmVwYXJlbnQgfHwgIXNlbGYuaXNBY3RpdmUpICYmIF9zd2FwUGluSW4ocGluLCBzcGFjZXIsIF9nZXRDb21wdXRlZFN0eWxlKHBpbiksIHNwYWNlclN0YXRlKSk7XG4gICAgICAgIHNlbGYuaXNSZXZlcnRlZCA9IHI7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHNlbGYucmVmcmVzaCA9IGZ1bmN0aW9uIChzb2Z0LCBmb3JjZSkge1xuICAgICAgaWYgKChfcmVmcmVzaGluZyB8fCAhc2VsZi5lbmFibGVkKSAmJiAhZm9yY2UpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAocGluICYmIHNvZnQgJiYgX2xhc3RTY3JvbGxUaW1lKSB7XG4gICAgICAgIF9hZGRMaXN0ZW5lcihTY3JvbGxUcmlnZ2VyLCBcInNjcm9sbEVuZFwiLCBfc29mdFJlZnJlc2gpO1xuXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgIV9yZWZyZXNoaW5nQWxsICYmIG9uUmVmcmVzaEluaXQgJiYgb25SZWZyZXNoSW5pdChzZWxmKTtcbiAgICAgIF9yZWZyZXNoaW5nID0gMTtcbiAgICAgIGxhc3RSZWZyZXNoID0gX2dldFRpbWUoKTtcblxuICAgICAgaWYgKHR3ZWVuVG8udHdlZW4pIHtcbiAgICAgICAgdHdlZW5Uby50d2Vlbi5raWxsKCk7XG4gICAgICAgIHR3ZWVuVG8udHdlZW4gPSAwO1xuICAgICAgfVxuXG4gICAgICBzY3J1YlR3ZWVuICYmIHNjcnViVHdlZW4ucGF1c2UoKTtcbiAgICAgIGludmFsaWRhdGVPblJlZnJlc2ggJiYgYW5pbWF0aW9uICYmIGFuaW1hdGlvbi50aW1lKC0wLjAxLCB0cnVlKS5pbnZhbGlkYXRlKCk7XG4gICAgICBzZWxmLmlzUmV2ZXJ0ZWQgfHwgc2VsZi5yZXZlcnQoKTtcblxuICAgICAgdmFyIHNpemUgPSBnZXRTY3JvbGxlclNpemUoKSxcbiAgICAgICAgICBzY3JvbGxlckJvdW5kcyA9IGdldFNjcm9sbGVyT2Zmc2V0cygpLFxuICAgICAgICAgIG1heCA9IGNvbnRhaW5lckFuaW1hdGlvbiA/IGNvbnRhaW5lckFuaW1hdGlvbi5kdXJhdGlvbigpIDogX21heFNjcm9sbChzY3JvbGxlciwgZGlyZWN0aW9uKSxcbiAgICAgICAgICBvZmZzZXQgPSAwLFxuICAgICAgICAgIG90aGVyUGluT2Zmc2V0ID0gMCxcbiAgICAgICAgICBwYXJzZWRFbmQgPSB2YXJzLmVuZCxcbiAgICAgICAgICBwYXJzZWRFbmRUcmlnZ2VyID0gdmFycy5lbmRUcmlnZ2VyIHx8IHRyaWdnZXIsXG4gICAgICAgICAgcGFyc2VkU3RhcnQgPSB2YXJzLnN0YXJ0IHx8ICh2YXJzLnN0YXJ0ID09PSAwIHx8ICF0cmlnZ2VyID8gMCA6IHBpbiA/IFwiMCAwXCIgOiBcIjAgMTAwJVwiKSxcbiAgICAgICAgICBwaW5uZWRDb250YWluZXIgPSBzZWxmLnBpbm5lZENvbnRhaW5lciA9IHZhcnMucGlubmVkQ29udGFpbmVyICYmIF9nZXRUYXJnZXQodmFycy5waW5uZWRDb250YWluZXIpLFxuICAgICAgICAgIHRyaWdnZXJJbmRleCA9IHRyaWdnZXIgJiYgTWF0aC5tYXgoMCwgX3RyaWdnZXJzLmluZGV4T2Yoc2VsZikpIHx8IDAsXG4gICAgICAgICAgaSA9IHRyaWdnZXJJbmRleCxcbiAgICAgICAgICBjcyxcbiAgICAgICAgICBib3VuZHMsXG4gICAgICAgICAgc2Nyb2xsLFxuICAgICAgICAgIGlzVmVydGljYWwsXG4gICAgICAgICAgb3ZlcnJpZGUsXG4gICAgICAgICAgY3VyVHJpZ2dlcixcbiAgICAgICAgICBjdXJQaW4sXG4gICAgICAgICAgb3Bwb3NpdGVTY3JvbGwsXG4gICAgICAgICAgaW5pdHRlZCxcbiAgICAgICAgICByZXZlcnRlZFBpbnM7XG5cbiAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgLy8gdXNlciBtaWdodCB0cnkgdG8gcGluIHRoZSBzYW1lIGVsZW1lbnQgbW9yZSB0aGFuIG9uY2UsIHNvIHdlIG11c3QgZmluZCBhbnkgcHJpb3IgdHJpZ2dlcnMgd2l0aCB0aGUgc2FtZSBwaW4sIHJldmVydCB0aGVtLCBhbmQgZGV0ZXJtaW5lIGhvdyBsb25nIHRoZXkncmUgcGlubmluZyBzbyB0aGF0IHdlIGNhbiBvZmZzZXQgdGhpbmdzIGFwcHJvcHJpYXRlbHkuIE1ha2Ugc3VyZSB3ZSByZXZlcnQgZnJvbSBsYXN0IHRvIGZpcnN0IHNvIHRoYXQgdGhpbmdzIFwicmV3aW5kXCIgcHJvcGVybHkuXG4gICAgICAgIGN1clRyaWdnZXIgPSBfdHJpZ2dlcnNbaV07XG4gICAgICAgIGN1clRyaWdnZXIuZW5kIHx8IGN1clRyaWdnZXIucmVmcmVzaCgwLCAxKSB8fCAoX3JlZnJlc2hpbmcgPSAxKTsgLy8gaWYgaXQncyBhIHRpbWVsaW5lLWJhc2VkIHRyaWdnZXIgdGhhdCBoYXNuJ3QgYmVlbiBmdWxseSBpbml0aWFsaXplZCB5ZXQgYmVjYXVzZSBpdCdzIHdhaXRpbmcgZm9yIDEgdGljaywganVzdCBmb3JjZSB0aGUgcmVmcmVzaCgpIGhlcmUsIG90aGVyd2lzZSBpZiBpdCBjb250YWlucyBhIHBpbiB0aGF0J3Mgc3VwcG9zZWQgdG8gYWZmZWN0IG90aGVyIFNjcm9sbFRyaWdnZXJzIGZ1cnRoZXIgZG93biB0aGUgcGFnZSwgdGhleSB3b24ndCBiZSBhZGp1c3RlZCBwcm9wZXJseS5cblxuICAgICAgICBjdXJQaW4gPSBjdXJUcmlnZ2VyLnBpbjtcblxuICAgICAgICBpZiAoY3VyUGluICYmIChjdXJQaW4gPT09IHRyaWdnZXIgfHwgY3VyUGluID09PSBwaW4pICYmICFjdXJUcmlnZ2VyLmlzUmV2ZXJ0ZWQpIHtcbiAgICAgICAgICByZXZlcnRlZFBpbnMgfHwgKHJldmVydGVkUGlucyA9IFtdKTtcbiAgICAgICAgICByZXZlcnRlZFBpbnMudW5zaGlmdChjdXJUcmlnZ2VyKTsgLy8gd2UnbGwgcmV2ZXJ0IGZyb20gZmlyc3QgdG8gbGFzdCB0byBtYWtlIHN1cmUgdGhpbmdzIHJlYWNoIHRoZWlyIGVuZCBzdGF0ZSBwcm9wZXJseVxuXG4gICAgICAgICAgY3VyVHJpZ2dlci5yZXZlcnQoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjdXJUcmlnZ2VyICE9PSBfdHJpZ2dlcnNbaV0pIHtcbiAgICAgICAgICAvLyBpbiBjYXNlIGl0IGdvdCByZW1vdmVkLlxuICAgICAgICAgIHRyaWdnZXJJbmRleC0tO1xuICAgICAgICAgIGktLTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBfaXNGdW5jdGlvbihwYXJzZWRTdGFydCkgJiYgKHBhcnNlZFN0YXJ0ID0gcGFyc2VkU3RhcnQoc2VsZikpO1xuICAgICAgc3RhcnQgPSBfcGFyc2VQb3NpdGlvbihwYXJzZWRTdGFydCwgdHJpZ2dlciwgc2l6ZSwgZGlyZWN0aW9uLCBzY3JvbGxGdW5jKCksIG1hcmtlclN0YXJ0LCBtYXJrZXJTdGFydFRyaWdnZXIsIHNlbGYsIHNjcm9sbGVyQm91bmRzLCBib3JkZXJXaWR0aCwgdXNlRml4ZWRQb3NpdGlvbiwgbWF4LCBjb250YWluZXJBbmltYXRpb24pIHx8IChwaW4gPyAtMC4wMDEgOiAwKTtcbiAgICAgIF9pc0Z1bmN0aW9uKHBhcnNlZEVuZCkgJiYgKHBhcnNlZEVuZCA9IHBhcnNlZEVuZChzZWxmKSk7XG5cbiAgICAgIGlmIChfaXNTdHJpbmcocGFyc2VkRW5kKSAmJiAhcGFyc2VkRW5kLmluZGV4T2YoXCIrPVwiKSkge1xuICAgICAgICBpZiAofnBhcnNlZEVuZC5pbmRleE9mKFwiIFwiKSkge1xuICAgICAgICAgIHBhcnNlZEVuZCA9IChfaXNTdHJpbmcocGFyc2VkU3RhcnQpID8gcGFyc2VkU3RhcnQuc3BsaXQoXCIgXCIpWzBdIDogXCJcIikgKyBwYXJzZWRFbmQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb2Zmc2V0ID0gX29mZnNldFRvUHgocGFyc2VkRW5kLnN1YnN0cigyKSwgc2l6ZSk7XG4gICAgICAgICAgcGFyc2VkRW5kID0gX2lzU3RyaW5nKHBhcnNlZFN0YXJ0KSA/IHBhcnNlZFN0YXJ0IDogc3RhcnQgKyBvZmZzZXQ7IC8vIF9wYXJzZVBvc2l0aW9uIHdvbid0IGZhY3RvciBpbiB0aGUgb2Zmc2V0IGlmIHRoZSBzdGFydCBpcyBhIG51bWJlciwgc28gZG8gaXQgaGVyZS5cblxuICAgICAgICAgIHBhcnNlZEVuZFRyaWdnZXIgPSB0cmlnZ2VyO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGVuZCA9IE1hdGgubWF4KHN0YXJ0LCBfcGFyc2VQb3NpdGlvbihwYXJzZWRFbmQgfHwgKHBhcnNlZEVuZFRyaWdnZXIgPyBcIjEwMCUgMFwiIDogbWF4KSwgcGFyc2VkRW5kVHJpZ2dlciwgc2l6ZSwgZGlyZWN0aW9uLCBzY3JvbGxGdW5jKCkgKyBvZmZzZXQsIG1hcmtlckVuZCwgbWFya2VyRW5kVHJpZ2dlciwgc2VsZiwgc2Nyb2xsZXJCb3VuZHMsIGJvcmRlcldpZHRoLCB1c2VGaXhlZFBvc2l0aW9uLCBtYXgsIGNvbnRhaW5lckFuaW1hdGlvbikpIHx8IC0wLjAwMTtcbiAgICAgIGNoYW5nZSA9IGVuZCAtIHN0YXJ0IHx8IChzdGFydCAtPSAwLjAxKSAmJiAwLjAwMTtcbiAgICAgIG9mZnNldCA9IDA7XG4gICAgICBpID0gdHJpZ2dlckluZGV4O1xuXG4gICAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgIGN1clRyaWdnZXIgPSBfdHJpZ2dlcnNbaV07XG4gICAgICAgIGN1clBpbiA9IGN1clRyaWdnZXIucGluO1xuXG4gICAgICAgIGlmIChjdXJQaW4gJiYgY3VyVHJpZ2dlci5zdGFydCAtIGN1clRyaWdnZXIuX3BpblB1c2ggPCBzdGFydCAmJiAhY29udGFpbmVyQW5pbWF0aW9uICYmIGN1clRyaWdnZXIuZW5kID4gMCkge1xuICAgICAgICAgIGNzID0gY3VyVHJpZ2dlci5lbmQgLSBjdXJUcmlnZ2VyLnN0YXJ0O1xuXG4gICAgICAgICAgaWYgKChjdXJQaW4gPT09IHRyaWdnZXIgfHwgY3VyUGluID09PSBwaW5uZWRDb250YWluZXIpICYmICFfaXNOdW1iZXIocGFyc2VkU3RhcnQpKSB7XG4gICAgICAgICAgICAvLyBudW1lcmljIHN0YXJ0IHZhbHVlcyBzaG91bGRuJ3QgYmUgb2Zmc2V0IGF0IGFsbCAtIHRyZWF0IHRoZW0gYXMgYWJzb2x1dGVcbiAgICAgICAgICAgIG9mZnNldCArPSBjcyAqICgxIC0gY3VyVHJpZ2dlci5wcm9ncmVzcyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY3VyUGluID09PSBwaW4gJiYgKG90aGVyUGluT2Zmc2V0ICs9IGNzKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBzdGFydCArPSBvZmZzZXQ7XG4gICAgICBlbmQgKz0gb2Zmc2V0O1xuICAgICAgc2VsZi5fcGluUHVzaCA9IG90aGVyUGluT2Zmc2V0O1xuXG4gICAgICBpZiAobWFya2VyU3RhcnQgJiYgb2Zmc2V0KSB7XG4gICAgICAgIC8vIG9mZnNldCB0aGUgbWFya2VycyBpZiBuZWNlc3NhcnlcbiAgICAgICAgY3MgPSB7fTtcbiAgICAgICAgY3NbZGlyZWN0aW9uLmFdID0gXCIrPVwiICsgb2Zmc2V0O1xuICAgICAgICBwaW5uZWRDb250YWluZXIgJiYgKGNzW2RpcmVjdGlvbi5wXSA9IFwiLT1cIiArIHNjcm9sbEZ1bmMoKSk7XG4gICAgICAgIGdzYXAuc2V0KFttYXJrZXJTdGFydCwgbWFya2VyRW5kXSwgY3MpO1xuICAgICAgfVxuXG4gICAgICBpZiAocGluKSB7XG4gICAgICAgIGNzID0gX2dldENvbXB1dGVkU3R5bGUocGluKTtcbiAgICAgICAgaXNWZXJ0aWNhbCA9IGRpcmVjdGlvbiA9PT0gX3ZlcnRpY2FsO1xuICAgICAgICBzY3JvbGwgPSBzY3JvbGxGdW5jKCk7IC8vIHJlY2FsY3VsYXRlIGJlY2F1c2UgdGhlIHRyaWdnZXJzIGNhbiBhZmZlY3QgdGhlIHNjcm9sbFxuXG4gICAgICAgIHBpblN0YXJ0ID0gcGFyc2VGbG9hdChwaW5HZXR0ZXIoZGlyZWN0aW9uLmEpKSArIG90aGVyUGluT2Zmc2V0O1xuICAgICAgICAhbWF4ICYmIGVuZCA+IDEgJiYgKChpc1ZpZXdwb3J0ID8gX2JvZHkgOiBzY3JvbGxlcikuc3R5bGVbXCJvdmVyZmxvdy1cIiArIGRpcmVjdGlvbi5hXSA9IFwic2Nyb2xsXCIpOyAvLyBtYWtlcyBzdXJlIHRoZSBzY3JvbGxlciBoYXMgYSBzY3JvbGxiYXIsIG90aGVyd2lzZSBpZiBzb21ldGhpbmcgaGFzIHdpZHRoOiAxMDAlLCBmb3IgZXhhbXBsZSwgaXQgd291bGQgYmUgdG9vIGJpZyAoZXhjbHVkZSB0aGUgc2Nyb2xsYmFyKS4gU2VlIGh0dHBzOi8vZ3JlZW5zb2NrLmNvbS9mb3J1bXMvdG9waWMvMjUxODItc2Nyb2xsdHJpZ2dlci13aWR0aC1vZi1wYWdlLWluY3JlYXNlLXdoZXJlLW1hcmtlcnMtYXJlLXNldC10by1mYWxzZS9cblxuICAgICAgICBfc3dhcFBpbkluKHBpbiwgc3BhY2VyLCBjcyk7XG5cbiAgICAgICAgcGluU3RhdGUgPSBfZ2V0U3RhdGUocGluKTsgLy8gdHJhbnNmb3JtcyB3aWxsIGludGVyZmVyZSB3aXRoIHRoZSB0b3AvbGVmdC9yaWdodC9ib3R0b20gcGxhY2VtZW50LCBzbyByZW1vdmUgdGhlbSB0ZW1wb3JhcmlseS4gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkgZmFjdG9ycyBpbiB0cmFuc2Zvcm1zLlxuXG4gICAgICAgIGJvdW5kcyA9IF9nZXRCb3VuZHMocGluLCB0cnVlKTtcbiAgICAgICAgb3Bwb3NpdGVTY3JvbGwgPSB1c2VGaXhlZFBvc2l0aW9uICYmIF9nZXRTY3JvbGxGdW5jKHNjcm9sbGVyLCBpc1ZlcnRpY2FsID8gX2hvcml6b250YWwgOiBfdmVydGljYWwpKCk7XG5cbiAgICAgICAgaWYgKHBpblNwYWNpbmcpIHtcbiAgICAgICAgICBzcGFjZXJTdGF0ZSA9IFtwaW5TcGFjaW5nICsgZGlyZWN0aW9uLm9zMiwgY2hhbmdlICsgb3RoZXJQaW5PZmZzZXQgKyBfcHhdO1xuICAgICAgICAgIHNwYWNlclN0YXRlLnQgPSBzcGFjZXI7XG4gICAgICAgICAgaSA9IHBpblNwYWNpbmcgPT09IF9wYWRkaW5nID8gX2dldFNpemUocGluLCBkaXJlY3Rpb24pICsgY2hhbmdlICsgb3RoZXJQaW5PZmZzZXQgOiAwO1xuICAgICAgICAgIGkgJiYgc3BhY2VyU3RhdGUucHVzaChkaXJlY3Rpb24uZCwgaSArIF9weCk7IC8vIGZvciBib3gtc2l6aW5nOiBib3JkZXItYm94IChtdXN0IGluY2x1ZGUgcGFkZGluZykuXG5cbiAgICAgICAgICBfc2V0U3RhdGUoc3BhY2VyU3RhdGUpO1xuXG4gICAgICAgICAgdXNlRml4ZWRQb3NpdGlvbiAmJiBzY3JvbGxGdW5jKHByZXZTY3JvbGwpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHVzZUZpeGVkUG9zaXRpb24pIHtcbiAgICAgICAgICBvdmVycmlkZSA9IHtcbiAgICAgICAgICAgIHRvcDogYm91bmRzLnRvcCArIChpc1ZlcnRpY2FsID8gc2Nyb2xsIC0gc3RhcnQgOiBvcHBvc2l0ZVNjcm9sbCkgKyBfcHgsXG4gICAgICAgICAgICBsZWZ0OiBib3VuZHMubGVmdCArIChpc1ZlcnRpY2FsID8gb3Bwb3NpdGVTY3JvbGwgOiBzY3JvbGwgLSBzdGFydCkgKyBfcHgsXG4gICAgICAgICAgICBib3hTaXppbmc6IFwiYm9yZGVyLWJveFwiLFxuICAgICAgICAgICAgcG9zaXRpb246IFwiZml4ZWRcIlxuICAgICAgICAgIH07XG4gICAgICAgICAgb3ZlcnJpZGVbX3dpZHRoXSA9IG92ZXJyaWRlW1wibWF4XCIgKyBfV2lkdGhdID0gTWF0aC5jZWlsKGJvdW5kcy53aWR0aCkgKyBfcHg7XG4gICAgICAgICAgb3ZlcnJpZGVbX2hlaWdodF0gPSBvdmVycmlkZVtcIm1heFwiICsgX0hlaWdodF0gPSBNYXRoLmNlaWwoYm91bmRzLmhlaWdodCkgKyBfcHg7XG4gICAgICAgICAgb3ZlcnJpZGVbX21hcmdpbl0gPSBvdmVycmlkZVtfbWFyZ2luICsgX1RvcF0gPSBvdmVycmlkZVtfbWFyZ2luICsgX1JpZ2h0XSA9IG92ZXJyaWRlW19tYXJnaW4gKyBfQm90dG9tXSA9IG92ZXJyaWRlW19tYXJnaW4gKyBfTGVmdF0gPSBcIjBcIjtcbiAgICAgICAgICBvdmVycmlkZVtfcGFkZGluZ10gPSBjc1tfcGFkZGluZ107XG4gICAgICAgICAgb3ZlcnJpZGVbX3BhZGRpbmcgKyBfVG9wXSA9IGNzW19wYWRkaW5nICsgX1RvcF07XG4gICAgICAgICAgb3ZlcnJpZGVbX3BhZGRpbmcgKyBfUmlnaHRdID0gY3NbX3BhZGRpbmcgKyBfUmlnaHRdO1xuICAgICAgICAgIG92ZXJyaWRlW19wYWRkaW5nICsgX0JvdHRvbV0gPSBjc1tfcGFkZGluZyArIF9Cb3R0b21dO1xuICAgICAgICAgIG92ZXJyaWRlW19wYWRkaW5nICsgX0xlZnRdID0gY3NbX3BhZGRpbmcgKyBfTGVmdF07XG4gICAgICAgICAgcGluQWN0aXZlU3RhdGUgPSBfY29weVN0YXRlKHBpbk9yaWdpbmFsU3RhdGUsIG92ZXJyaWRlLCBwaW5SZXBhcmVudCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYW5pbWF0aW9uKSB7XG4gICAgICAgICAgLy8gdGhlIGFuaW1hdGlvbiBtaWdodCBiZSBhZmZlY3RpbmcgdGhlIHRyYW5zZm9ybSwgc28gd2UgbXVzdCBqdW1wIHRvIHRoZSBlbmQsIGNoZWNrIHRoZSB2YWx1ZSwgYW5kIGNvbXBlbnNhdGUgYWNjb3JkaW5nbHkuIE90aGVyd2lzZSwgd2hlbiBpdCBiZWNvbWVzIHVucGlubmVkLCB0aGUgcGluU2V0dGVyKCkgd2lsbCBnZXQgc2V0IHRvIGEgdmFsdWUgdGhhdCBkb2Vzbid0IGluY2x1ZGUgd2hhdGV2ZXIgdGhlIGFuaW1hdGlvbiBkaWQuXG4gICAgICAgICAgaW5pdHRlZCA9IGFuaW1hdGlvbi5faW5pdHRlZDsgLy8gaWYgbm90LCB3ZSBtdXN0IGludmFsaWRhdGUoKSBhZnRlciB0aGlzIHN0ZXAsIG90aGVyd2lzZSBpdCBjb3VsZCBsb2NrIGluIHN0YXJ0aW5nIHZhbHVlcyBwcmVtYXR1cmVseS5cblxuICAgICAgICAgIF9zdXBwcmVzc092ZXJ3cml0ZXMoMSk7XG5cbiAgICAgICAgICBhbmltYXRpb24ucmVuZGVyKGFuaW1hdGlvbi5kdXJhdGlvbigpLCB0cnVlLCB0cnVlKTtcbiAgICAgICAgICBwaW5DaGFuZ2UgPSBwaW5HZXR0ZXIoZGlyZWN0aW9uLmEpIC0gcGluU3RhcnQgKyBjaGFuZ2UgKyBvdGhlclBpbk9mZnNldDtcbiAgICAgICAgICBjaGFuZ2UgIT09IHBpbkNoYW5nZSAmJiB1c2VGaXhlZFBvc2l0aW9uICYmIHBpbkFjdGl2ZVN0YXRlLnNwbGljZShwaW5BY3RpdmVTdGF0ZS5sZW5ndGggLSAyLCAyKTsgLy8gdHJhbnNmb3JtIGlzIHRoZSBsYXN0IHByb3BlcnR5L3ZhbHVlIHNldCBpbiB0aGUgc3RhdGUgQXJyYXkuIFNpbmNlIHRoZSBhbmltYXRpb24gaXMgY29udHJvbGxpbmcgdGhhdCwgd2Ugc2hvdWxkIG9taXQgaXQuXG5cbiAgICAgICAgICBhbmltYXRpb24ucmVuZGVyKDAsIHRydWUsIHRydWUpO1xuICAgICAgICAgIGluaXR0ZWQgfHwgYW5pbWF0aW9uLmludmFsaWRhdGUoKTtcblxuICAgICAgICAgIF9zdXBwcmVzc092ZXJ3cml0ZXMoMCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcGluQ2hhbmdlID0gY2hhbmdlO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHRyaWdnZXIgJiYgc2Nyb2xsRnVuYygpICYmICFjb250YWluZXJBbmltYXRpb24pIHtcbiAgICAgICAgLy8gaXQgbWF5IGJlIElOU0lERSBhIHBpbm5lZCBlbGVtZW50LCBzbyB3YWxrIHVwIHRoZSB0cmVlIGFuZCBsb29rIGZvciBhbnkgZWxlbWVudHMgd2l0aCBfcGluT2Zmc2V0IHRvIGNvbXBlbnNhdGUgYmVjYXVzZSBhbnl0aGluZyB3aXRoIHBpblNwYWNpbmcgdGhhdCdzIGFscmVhZHkgc2Nyb2xsZWQgd291bGQgdGhyb3cgb2ZmIHRoZSBtZWFzdXJlbWVudHMgaW4gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KClcbiAgICAgICAgYm91bmRzID0gdHJpZ2dlci5wYXJlbnROb2RlO1xuXG4gICAgICAgIHdoaWxlIChib3VuZHMgJiYgYm91bmRzICE9PSBfYm9keSkge1xuICAgICAgICAgIGlmIChib3VuZHMuX3Bpbk9mZnNldCkge1xuICAgICAgICAgICAgc3RhcnQgLT0gYm91bmRzLl9waW5PZmZzZXQ7XG4gICAgICAgICAgICBlbmQgLT0gYm91bmRzLl9waW5PZmZzZXQ7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYm91bmRzID0gYm91bmRzLnBhcmVudE5vZGU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV2ZXJ0ZWRQaW5zICYmIHJldmVydGVkUGlucy5mb3JFYWNoKGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIHJldHVybiB0LnJldmVydChmYWxzZSk7XG4gICAgICB9KTtcbiAgICAgIHNlbGYuc3RhcnQgPSBzdGFydDtcbiAgICAgIHNlbGYuZW5kID0gZW5kO1xuICAgICAgc2Nyb2xsMSA9IHNjcm9sbDIgPSBzY3JvbGxGdW5jKCk7IC8vIHJlc2V0IHZlbG9jaXR5XG5cbiAgICAgIGlmICghY29udGFpbmVyQW5pbWF0aW9uKSB7XG4gICAgICAgIHNjcm9sbDEgPCBwcmV2U2Nyb2xsICYmIHNjcm9sbEZ1bmMocHJldlNjcm9sbCk7XG4gICAgICAgIHNlbGYuc2Nyb2xsLnJlYyA9IDA7XG4gICAgICB9XG5cbiAgICAgIHNlbGYucmV2ZXJ0KGZhbHNlKTtcblxuICAgICAgaWYgKHNuYXBEZWxheWVkQ2FsbCkge1xuICAgICAgICBsYXN0U25hcCA9IC0xO1xuICAgICAgICBzZWxmLmlzQWN0aXZlICYmIHNjcm9sbEZ1bmMoc3RhcnQgKyBjaGFuZ2UgKiBwcmV2UHJvZ3Jlc3MpOyAvLyBqdXN0IHNvIHNuYXBwaW5nIGdldHMgcmUtZW5hYmxlZCwgY2xlYXIgb3V0IGFueSByZWNvcmRlZCBsYXN0IHZhbHVlXG5cbiAgICAgICAgc25hcERlbGF5ZWRDYWxsLnJlc3RhcnQodHJ1ZSk7XG4gICAgICB9XG5cbiAgICAgIF9yZWZyZXNoaW5nID0gMDtcbiAgICAgIGFuaW1hdGlvbiAmJiBpc1RvZ2dsZSAmJiAoYW5pbWF0aW9uLl9pbml0dGVkIHx8IHByZXZBbmltUHJvZ3Jlc3MpICYmIGFuaW1hdGlvbi5wcm9ncmVzcygpICE9PSBwcmV2QW5pbVByb2dyZXNzICYmIGFuaW1hdGlvbi5wcm9ncmVzcyhwcmV2QW5pbVByb2dyZXNzLCB0cnVlKS5yZW5kZXIoYW5pbWF0aW9uLnRpbWUoKSwgdHJ1ZSwgdHJ1ZSk7IC8vIG11c3QgZm9yY2UgYSByZS1yZW5kZXIgYmVjYXVzZSBpZiBzYXZlU3R5bGVzKCkgd2FzIHVzZWQgb24gdGhlIHRhcmdldChzKSwgdGhlIHN0eWxlcyBjb3VsZCBoYXZlIGJlZW4gd2lwZWQgb3V0IGR1cmluZyB0aGUgcmVmcmVzaCgpLlxuXG4gICAgICBpZiAocHJldlByb2dyZXNzICE9PSBzZWxmLnByb2dyZXNzIHx8IGNvbnRhaW5lckFuaW1hdGlvbikge1xuICAgICAgICAvLyBlbnN1cmVzIHRoYXQgdGhlIGRpcmVjdGlvbiBpcyBzZXQgcHJvcGVybHkgKHdoZW4gcmVmcmVzaGluZywgcHJvZ3Jlc3MgaXMgc2V0IGJhY2sgdG8gMCBpbml0aWFsbHksIHRoZW4gYmFjayBhZ2FpbiB0byB3aGVyZXZlciBpdCBuZWVkcyB0byBiZSkgYW5kIHRoYXQgY2FsbGJhY2tzIGFyZSB0cmlnZ2VyZWQuXG4gICAgICAgIGFuaW1hdGlvbiAmJiAhaXNUb2dnbGUgJiYgYW5pbWF0aW9uLnRvdGFsUHJvZ3Jlc3MocHJldlByb2dyZXNzLCB0cnVlKTsgLy8gdG8gYXZvaWQgaXNzdWVzIHdoZXJlIGFuaW1hdGlvbiBjYWxsYmFja3MgbGlrZSBvblN0YXJ0IGFyZW4ndCB0cmlnZ2VyZWQuXG5cbiAgICAgICAgc2VsZi5wcm9ncmVzcyA9IHByZXZQcm9ncmVzcztcbiAgICAgICAgc2VsZi51cGRhdGUoMCwgMCwgMSk7XG4gICAgICB9XG5cbiAgICAgIHBpbiAmJiBwaW5TcGFjaW5nICYmIChzcGFjZXIuX3Bpbk9mZnNldCA9IE1hdGgucm91bmQoc2VsZi5wcm9ncmVzcyAqIHBpbkNoYW5nZSkpOyAvL1x0XHRcdHNjcnViVHdlZW4gJiYgc2NydWJUd2Vlbi5pbnZhbGlkYXRlKCk7XG5cbiAgICAgIG9uUmVmcmVzaCAmJiBvblJlZnJlc2goc2VsZik7XG4gICAgfTtcblxuICAgIHNlbGYuZ2V0VmVsb2NpdHkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gKHNjcm9sbEZ1bmMoKSAtIHNjcm9sbDIpIC8gKF9nZXRUaW1lKCkgLSBfdGltZTIpICogMTAwMCB8fCAwO1xuICAgIH07XG5cbiAgICBzZWxmLmVuZEFuaW1hdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIF9lbmRBbmltYXRpb24oc2VsZi5jYWxsYmFja0FuaW1hdGlvbik7XG5cbiAgICAgIGlmIChhbmltYXRpb24pIHtcbiAgICAgICAgc2NydWJUd2VlbiA/IHNjcnViVHdlZW4ucHJvZ3Jlc3MoMSkgOiAhYW5pbWF0aW9uLnBhdXNlZCgpID8gX2VuZEFuaW1hdGlvbihhbmltYXRpb24sIGFuaW1hdGlvbi5yZXZlcnNlZCgpKSA6IGlzVG9nZ2xlIHx8IF9lbmRBbmltYXRpb24oYW5pbWF0aW9uLCBzZWxmLmRpcmVjdGlvbiA8IDAsIDEpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBzZWxmLmxhYmVsVG9TY3JvbGwgPSBmdW5jdGlvbiAobGFiZWwpIHtcbiAgICAgIHJldHVybiBhbmltYXRpb24gJiYgYW5pbWF0aW9uLmxhYmVscyAmJiAoc3RhcnQgfHwgc2VsZi5yZWZyZXNoKCkgfHwgc3RhcnQpICsgYW5pbWF0aW9uLmxhYmVsc1tsYWJlbF0gLyBhbmltYXRpb24uZHVyYXRpb24oKSAqIGNoYW5nZSB8fCAwO1xuICAgIH07XG5cbiAgICBzZWxmLmdldFRyYWlsaW5nID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgIHZhciBpID0gX3RyaWdnZXJzLmluZGV4T2Yoc2VsZiksXG4gICAgICAgICAgYSA9IHNlbGYuZGlyZWN0aW9uID4gMCA/IF90cmlnZ2Vycy5zbGljZSgwLCBpKS5yZXZlcnNlKCkgOiBfdHJpZ2dlcnMuc2xpY2UoaSArIDEpO1xuXG4gICAgICByZXR1cm4gKF9pc1N0cmluZyhuYW1lKSA/IGEuZmlsdGVyKGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIHJldHVybiB0LnZhcnMucHJldmVudE92ZXJsYXBzID09PSBuYW1lO1xuICAgICAgfSkgOiBhKS5maWx0ZXIoZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgcmV0dXJuIHNlbGYuZGlyZWN0aW9uID4gMCA/IHQuZW5kIDw9IHN0YXJ0IDogdC5zdGFydCA+PSBlbmQ7XG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgc2VsZi51cGRhdGUgPSBmdW5jdGlvbiAocmVzZXQsIHJlY29yZFZlbG9jaXR5LCBmb3JjZUZha2UpIHtcbiAgICAgIGlmIChjb250YWluZXJBbmltYXRpb24gJiYgIWZvcmNlRmFrZSAmJiAhcmVzZXQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgc2Nyb2xsID0gc2VsZi5zY3JvbGwoKSxcbiAgICAgICAgICBwID0gcmVzZXQgPyAwIDogKHNjcm9sbCAtIHN0YXJ0KSAvIGNoYW5nZSxcbiAgICAgICAgICBjbGlwcGVkID0gcCA8IDAgPyAwIDogcCA+IDEgPyAxIDogcCB8fCAwLFxuICAgICAgICAgIHByZXZQcm9ncmVzcyA9IHNlbGYucHJvZ3Jlc3MsXG4gICAgICAgICAgaXNBY3RpdmUsXG4gICAgICAgICAgd2FzQWN0aXZlLFxuICAgICAgICAgIHRvZ2dsZVN0YXRlLFxuICAgICAgICAgIGFjdGlvbixcbiAgICAgICAgICBzdGF0ZUNoYW5nZWQsXG4gICAgICAgICAgdG9nZ2xlZCxcbiAgICAgICAgICBpc0F0TWF4LFxuICAgICAgICAgIGlzVGFraW5nQWN0aW9uO1xuXG4gICAgICBpZiAocmVjb3JkVmVsb2NpdHkpIHtcbiAgICAgICAgc2Nyb2xsMiA9IHNjcm9sbDE7XG4gICAgICAgIHNjcm9sbDEgPSBjb250YWluZXJBbmltYXRpb24gPyBzY3JvbGxGdW5jKCkgOiBzY3JvbGw7XG5cbiAgICAgICAgaWYgKHNuYXApIHtcbiAgICAgICAgICBzbmFwMiA9IHNuYXAxO1xuICAgICAgICAgIHNuYXAxID0gYW5pbWF0aW9uICYmICFpc1RvZ2dsZSA/IGFuaW1hdGlvbi50b3RhbFByb2dyZXNzKCkgOiBjbGlwcGVkO1xuICAgICAgICB9XG4gICAgICB9IC8vIGFudGljaXBhdGUgdGhlIHBpbm5pbmcgYSBmZXcgdGlja3MgYWhlYWQgb2YgdGltZSBiYXNlZCBvbiB2ZWxvY2l0eSB0byBhdm9pZCBhIHZpc3VhbCBnbGl0Y2ggZHVlIHRvIHRoZSBmYWN0IHRoYXQgbW9zdCBicm93c2VycyBkbyBzY3JvbGxpbmcgb24gYSBzZXBhcmF0ZSB0aHJlYWQgKG5vdCBzeW5jZWQgd2l0aCByZXF1ZXN0QW5pbWF0aW9uRnJhbWUpLlxuXG5cbiAgICAgIGFudGljaXBhdGVQaW4gJiYgIWNsaXBwZWQgJiYgcGluICYmICFfcmVmcmVzaGluZyAmJiAhX3N0YXJ0dXAgJiYgX2xhc3RTY3JvbGxUaW1lICYmIHN0YXJ0IDwgc2Nyb2xsICsgKHNjcm9sbCAtIHNjcm9sbDIpIC8gKF9nZXRUaW1lKCkgLSBfdGltZTIpICogYW50aWNpcGF0ZVBpbiAmJiAoY2xpcHBlZCA9IDAuMDAwMSk7XG5cbiAgICAgIGlmIChjbGlwcGVkICE9PSBwcmV2UHJvZ3Jlc3MgJiYgc2VsZi5lbmFibGVkKSB7XG4gICAgICAgIGlzQWN0aXZlID0gc2VsZi5pc0FjdGl2ZSA9ICEhY2xpcHBlZCAmJiBjbGlwcGVkIDwgMTtcbiAgICAgICAgd2FzQWN0aXZlID0gISFwcmV2UHJvZ3Jlc3MgJiYgcHJldlByb2dyZXNzIDwgMTtcbiAgICAgICAgdG9nZ2xlZCA9IGlzQWN0aXZlICE9PSB3YXNBY3RpdmU7XG4gICAgICAgIHN0YXRlQ2hhbmdlZCA9IHRvZ2dsZWQgfHwgISFjbGlwcGVkICE9PSAhIXByZXZQcm9ncmVzczsgLy8gY291bGQgZ28gZnJvbSBzdGFydCBhbGwgdGhlIHdheSB0byBlbmQsIHRodXMgaXQgZGlkbid0IHRvZ2dsZSBidXQgaXQgZGlkIGNoYW5nZSBzdGF0ZSBpbiBhIHNlbnNlIChtYXkgbmVlZCB0byBmaXJlIGEgY2FsbGJhY2spXG5cbiAgICAgICAgc2VsZi5kaXJlY3Rpb24gPSBjbGlwcGVkID4gcHJldlByb2dyZXNzID8gMSA6IC0xO1xuICAgICAgICBzZWxmLnByb2dyZXNzID0gY2xpcHBlZDtcblxuICAgICAgICBpZiAoc3RhdGVDaGFuZ2VkICYmICFfcmVmcmVzaGluZykge1xuICAgICAgICAgIHRvZ2dsZVN0YXRlID0gY2xpcHBlZCAmJiAhcHJldlByb2dyZXNzID8gMCA6IGNsaXBwZWQgPT09IDEgPyAxIDogcHJldlByb2dyZXNzID09PSAxID8gMiA6IDM7IC8vIDAgPSBlbnRlciwgMSA9IGxlYXZlLCAyID0gZW50ZXJCYWNrLCAzID0gbGVhdmVCYWNrICh3ZSBwcmlvcml0aXplIHRoZSBGSVJTVCBlbmNvdW50ZXIsIHRodXMgaWYgeW91IHNjcm9sbCByZWFsbHkgZmFzdCBwYXN0IHRoZSBvbkVudGVyIGFuZCBvbkxlYXZlIGluIG9uZSB0aWNrLCBpdCdkIHByaW9yaXRpemUgb25FbnRlci5cblxuICAgICAgICAgIGlmIChpc1RvZ2dsZSkge1xuICAgICAgICAgICAgYWN0aW9uID0gIXRvZ2dsZWQgJiYgdG9nZ2xlQWN0aW9uc1t0b2dnbGVTdGF0ZSArIDFdICE9PSBcIm5vbmVcIiAmJiB0b2dnbGVBY3Rpb25zW3RvZ2dsZVN0YXRlICsgMV0gfHwgdG9nZ2xlQWN0aW9uc1t0b2dnbGVTdGF0ZV07IC8vIGlmIGl0IGRpZG4ndCB0b2dnbGUsIHRoYXQgbWVhbnMgaXQgc2hvdCByaWdodCBwYXN0IGFuZCBzaW5jZSB3ZSBwcmlvcml0aXplIHRoZSBcImVudGVyXCIgYWN0aW9uLCB3ZSBzaG91bGQgc3dpdGNoIHRvIHRoZSBcImxlYXZlXCIgaW4gdGhpcyBjYXNlIChidXQgb25seSBpZiBvbmUgaXMgZGVmaW5lZClcblxuICAgICAgICAgICAgaXNUYWtpbmdBY3Rpb24gPSBhbmltYXRpb24gJiYgKGFjdGlvbiA9PT0gXCJjb21wbGV0ZVwiIHx8IGFjdGlvbiA9PT0gXCJyZXNldFwiIHx8IGFjdGlvbiBpbiBhbmltYXRpb24pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHByZXZlbnRPdmVybGFwcyAmJiAodG9nZ2xlZCB8fCBpc1Rha2luZ0FjdGlvbikgJiYgKGlzVGFraW5nQWN0aW9uIHx8IHNjcnViIHx8ICFhbmltYXRpb24pICYmIChfaXNGdW5jdGlvbihwcmV2ZW50T3ZlcmxhcHMpID8gcHJldmVudE92ZXJsYXBzKHNlbGYpIDogc2VsZi5nZXRUcmFpbGluZyhwcmV2ZW50T3ZlcmxhcHMpLmZvckVhY2goZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICByZXR1cm4gdC5lbmRBbmltYXRpb24oKTtcbiAgICAgICAgfSkpO1xuXG4gICAgICAgIGlmICghaXNUb2dnbGUpIHtcbiAgICAgICAgICBpZiAoc2NydWJUd2VlbiAmJiAhX3JlZnJlc2hpbmcgJiYgIV9zdGFydHVwKSB7XG4gICAgICAgICAgICAoY29udGFpbmVyQW5pbWF0aW9uIHx8IF9wcmltYXJ5ICYmIF9wcmltYXJ5ICE9PSBzZWxmKSAmJiBzY3J1YlR3ZWVuLnJlbmRlcihzY3J1YlR3ZWVuLl9kcC5fdGltZSAtIHNjcnViVHdlZW4uX3N0YXJ0KTsgLy8gaWYgdGhlcmUncyBhIHNjcnViIG9uIGJvdGggdGhlIGNvbnRhaW5lciBhbmltYXRpb24gYW5kIHRoaXMgb25lIChvciBhIFNjcm9sbFNtb290aGVyKSwgdGhlIHVwZGF0ZSBvcmRlciB3b3VsZCBjYXVzZSB0aGlzIG9uZSBub3QgdG8gaGF2ZSByZW5kZXJlZCB5ZXQsIHNvIGl0IHdvdWxkbid0IG1ha2UgYW55IHByb2dyZXNzIGJlZm9yZSB3ZSAucmVzdGFydCgpIGl0IGhlYWRpbmcgdG93YXJkIHRoZSBuZXcgcHJvZ3Jlc3Mgc28gaXQnZCBhcHBlYXIgc3R1Y2sgdGh1cyB3ZSBmb3JjZSBhIHJlbmRlciBoZXJlLlxuXG4gICAgICAgICAgICBpZiAoc2NydWJUd2Vlbi5yZXNldFRvKSB7XG4gICAgICAgICAgICAgIHNjcnViVHdlZW4ucmVzZXRUbyhcInRvdGFsUHJvZ3Jlc3NcIiwgY2xpcHBlZCwgYW5pbWF0aW9uLl90VGltZSAvIGFuaW1hdGlvbi5fdER1cik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAvLyBsZWdhY3kgc3VwcG9ydCAoY291cnRlc3kpLCBiZWZvcmUgMy4xMC4wXG4gICAgICAgICAgICAgIHNjcnViVHdlZW4udmFycy50b3RhbFByb2dyZXNzID0gY2xpcHBlZDtcbiAgICAgICAgICAgICAgc2NydWJUd2Vlbi5pbnZhbGlkYXRlKCkucmVzdGFydCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSBpZiAoYW5pbWF0aW9uKSB7XG4gICAgICAgICAgICBhbmltYXRpb24udG90YWxQcm9ncmVzcyhjbGlwcGVkLCAhIV9yZWZyZXNoaW5nKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocGluKSB7XG4gICAgICAgICAgcmVzZXQgJiYgcGluU3BhY2luZyAmJiAoc3BhY2VyLnN0eWxlW3BpblNwYWNpbmcgKyBkaXJlY3Rpb24ub3MyXSA9IHNwYWNpbmdTdGFydCk7XG5cbiAgICAgICAgICBpZiAoIXVzZUZpeGVkUG9zaXRpb24pIHtcbiAgICAgICAgICAgIHBpblNldHRlcihfcm91bmQocGluU3RhcnQgKyBwaW5DaGFuZ2UgKiBjbGlwcGVkKSk7XG4gICAgICAgICAgfSBlbHNlIGlmIChzdGF0ZUNoYW5nZWQpIHtcbiAgICAgICAgICAgIGlzQXRNYXggPSAhcmVzZXQgJiYgY2xpcHBlZCA+IHByZXZQcm9ncmVzcyAmJiBlbmQgKyAxID4gc2Nyb2xsICYmIHNjcm9sbCArIDEgPj0gX21heFNjcm9sbChzY3JvbGxlciwgZGlyZWN0aW9uKTsgLy8gaWYgaXQncyBhdCB0aGUgVkVSWSBlbmQgb2YgdGhlIHBhZ2UsIGRvbid0IHN3aXRjaCBhd2F5IGZyb20gcG9zaXRpb246IGZpeGVkIGJlY2F1c2UgaXQncyBwb2ludGxlc3MgYW5kIGl0IGNvdWxkIGNhdXNlIGEgYnJpZWYgZmxhc2ggd2hlbiB0aGUgdXNlciBzY3JvbGxzIGJhY2sgdXAgKHdoZW4gaXQgZ2V0cyBwaW5uZWQgYWdhaW4pXG5cbiAgICAgICAgICAgIGlmIChwaW5SZXBhcmVudCkge1xuICAgICAgICAgICAgICBpZiAoIXJlc2V0ICYmIChpc0FjdGl2ZSB8fCBpc0F0TWF4KSkge1xuICAgICAgICAgICAgICAgIHZhciBib3VuZHMgPSBfZ2V0Qm91bmRzKHBpbiwgdHJ1ZSksXG4gICAgICAgICAgICAgICAgICAgIF9vZmZzZXQgPSBzY3JvbGwgLSBzdGFydDtcblxuICAgICAgICAgICAgICAgIF9yZXBhcmVudChwaW4sIF9ib2R5LCBib3VuZHMudG9wICsgKGRpcmVjdGlvbiA9PT0gX3ZlcnRpY2FsID8gX29mZnNldCA6IDApICsgX3B4LCBib3VuZHMubGVmdCArIChkaXJlY3Rpb24gPT09IF92ZXJ0aWNhbCA/IDAgOiBfb2Zmc2V0KSArIF9weCk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgX3JlcGFyZW50KHBpbiwgc3BhY2VyKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBfc2V0U3RhdGUoaXNBY3RpdmUgfHwgaXNBdE1heCA/IHBpbkFjdGl2ZVN0YXRlIDogcGluU3RhdGUpO1xuXG4gICAgICAgICAgICBwaW5DaGFuZ2UgIT09IGNoYW5nZSAmJiBjbGlwcGVkIDwgMSAmJiBpc0FjdGl2ZSB8fCBwaW5TZXR0ZXIocGluU3RhcnQgKyAoY2xpcHBlZCA9PT0gMSAmJiAhaXNBdE1heCA/IHBpbkNoYW5nZSA6IDApKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBzbmFwICYmICF0d2VlblRvLnR3ZWVuICYmICFfcmVmcmVzaGluZyAmJiAhX3N0YXJ0dXAgJiYgc25hcERlbGF5ZWRDYWxsLnJlc3RhcnQodHJ1ZSk7XG4gICAgICAgIHRvZ2dsZUNsYXNzICYmICh0b2dnbGVkIHx8IG9uY2UgJiYgY2xpcHBlZCAmJiAoY2xpcHBlZCA8IDEgfHwgIV9saW1pdENhbGxiYWNrcykpICYmIF90b0FycmF5KHRvZ2dsZUNsYXNzLnRhcmdldHMpLmZvckVhY2goZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgICAgcmV0dXJuIGVsLmNsYXNzTGlzdFtpc0FjdGl2ZSB8fCBvbmNlID8gXCJhZGRcIiA6IFwicmVtb3ZlXCJdKHRvZ2dsZUNsYXNzLmNsYXNzTmFtZSk7XG4gICAgICAgIH0pOyAvLyBjbGFzc2VzIGNvdWxkIGFmZmVjdCBwb3NpdGlvbmluZywgc28gZG8gaXQgZXZlbiBpZiByZXNldCBvciByZWZyZXNoaW5nIGlzIHRydWUuXG5cbiAgICAgICAgb25VcGRhdGUgJiYgIWlzVG9nZ2xlICYmICFyZXNldCAmJiBvblVwZGF0ZShzZWxmKTtcblxuICAgICAgICBpZiAoc3RhdGVDaGFuZ2VkICYmICFfcmVmcmVzaGluZykge1xuICAgICAgICAgIGlmIChpc1RvZ2dsZSkge1xuICAgICAgICAgICAgaWYgKGlzVGFraW5nQWN0aW9uKSB7XG4gICAgICAgICAgICAgIGlmIChhY3Rpb24gPT09IFwiY29tcGxldGVcIikge1xuICAgICAgICAgICAgICAgIGFuaW1hdGlvbi5wYXVzZSgpLnRvdGFsUHJvZ3Jlc3MoMSk7XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAoYWN0aW9uID09PSBcInJlc2V0XCIpIHtcbiAgICAgICAgICAgICAgICBhbmltYXRpb24ucmVzdGFydCh0cnVlKS5wYXVzZSgpO1xuICAgICAgICAgICAgICB9IGVsc2UgaWYgKGFjdGlvbiA9PT0gXCJyZXN0YXJ0XCIpIHtcbiAgICAgICAgICAgICAgICBhbmltYXRpb24ucmVzdGFydCh0cnVlKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBhbmltYXRpb25bYWN0aW9uXSgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG9uVXBkYXRlICYmIG9uVXBkYXRlKHNlbGYpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICh0b2dnbGVkIHx8ICFfbGltaXRDYWxsYmFja3MpIHtcbiAgICAgICAgICAgIC8vIG9uIHN0YXJ0dXAsIHRoZSBwYWdlIGNvdWxkIGJlIHNjcm9sbGVkIGFuZCB3ZSBkb24ndCB3YW50IHRvIGZpcmUgY2FsbGJhY2tzIHRoYXQgZGlkbid0IHRvZ2dsZS4gRm9yIGV4YW1wbGUgb25FbnRlciBzaG91bGRuJ3QgZmlyZSBpZiB0aGUgU2Nyb2xsVHJpZ2dlciBpc24ndCBhY3R1YWxseSBlbnRlcmVkLlxuICAgICAgICAgICAgb25Ub2dnbGUgJiYgdG9nZ2xlZCAmJiBfY2FsbGJhY2soc2VsZiwgb25Ub2dnbGUpO1xuICAgICAgICAgICAgY2FsbGJhY2tzW3RvZ2dsZVN0YXRlXSAmJiBfY2FsbGJhY2soc2VsZiwgY2FsbGJhY2tzW3RvZ2dsZVN0YXRlXSk7XG4gICAgICAgICAgICBvbmNlICYmIChjbGlwcGVkID09PSAxID8gc2VsZi5raWxsKGZhbHNlLCAxKSA6IGNhbGxiYWNrc1t0b2dnbGVTdGF0ZV0gPSAwKTsgLy8gYSBjYWxsYmFjayBzaG91bGRuJ3QgYmUgY2FsbGVkIGFnYWluIGlmIG9uY2UgaXMgdHJ1ZS5cblxuICAgICAgICAgICAgaWYgKCF0b2dnbGVkKSB7XG4gICAgICAgICAgICAgIC8vIGl0J3MgcG9zc2libGUgdG8gZ28gY29tcGxldGVseSBwYXN0LCBsaWtlIGZyb20gYmVmb3JlIHRoZSBzdGFydCB0byBhZnRlciB0aGUgZW5kIChvciB2aWNlLXZlcnNhKSBpbiB3aGljaCBjYXNlIEJPVEggY2FsbGJhY2tzIHNob3VsZCBiZSBmaXJlZCBpbiB0aGF0IG9yZGVyXG4gICAgICAgICAgICAgIHRvZ2dsZVN0YXRlID0gY2xpcHBlZCA9PT0gMSA/IDEgOiAzO1xuICAgICAgICAgICAgICBjYWxsYmFja3NbdG9nZ2xlU3RhdGVdICYmIF9jYWxsYmFjayhzZWxmLCBjYWxsYmFja3NbdG9nZ2xlU3RhdGVdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoZmFzdFNjcm9sbEVuZCAmJiAhaXNBY3RpdmUgJiYgTWF0aC5hYnMoc2VsZi5nZXRWZWxvY2l0eSgpKSA+IChfaXNOdW1iZXIoZmFzdFNjcm9sbEVuZCkgPyBmYXN0U2Nyb2xsRW5kIDogMjUwMCkpIHtcbiAgICAgICAgICAgIF9lbmRBbmltYXRpb24oc2VsZi5jYWxsYmFja0FuaW1hdGlvbik7XG5cbiAgICAgICAgICAgIHNjcnViVHdlZW4gPyBzY3J1YlR3ZWVuLnByb2dyZXNzKDEpIDogX2VuZEFuaW1hdGlvbihhbmltYXRpb24sICFjbGlwcGVkLCAxKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoaXNUb2dnbGUgJiYgb25VcGRhdGUgJiYgIV9yZWZyZXNoaW5nKSB7XG4gICAgICAgICAgb25VcGRhdGUoc2VsZik7XG4gICAgICAgIH1cbiAgICAgIH0gLy8gdXBkYXRlIGFic29sdXRlbHktcG9zaXRpb25lZCBtYXJrZXJzIChvbmx5IGlmIHRoZSBzY3JvbGxlciBpc24ndCB0aGUgdmlld3BvcnQpXG5cblxuICAgICAgaWYgKG1hcmtlckVuZFNldHRlcikge1xuICAgICAgICB2YXIgbiA9IGNvbnRhaW5lckFuaW1hdGlvbiA/IHNjcm9sbCAvIGNvbnRhaW5lckFuaW1hdGlvbi5kdXJhdGlvbigpICogKGNvbnRhaW5lckFuaW1hdGlvbi5fY2FTY3JvbGxEaXN0IHx8IDApIDogc2Nyb2xsO1xuICAgICAgICBtYXJrZXJTdGFydFNldHRlcihuICsgKG1hcmtlclN0YXJ0VHJpZ2dlci5faXNGbGlwcGVkID8gMSA6IDApKTtcbiAgICAgICAgbWFya2VyRW5kU2V0dGVyKG4pO1xuICAgICAgfVxuXG4gICAgICBjYU1hcmtlclNldHRlciAmJiBjYU1hcmtlclNldHRlcigtc2Nyb2xsIC8gY29udGFpbmVyQW5pbWF0aW9uLmR1cmF0aW9uKCkgKiAoY29udGFpbmVyQW5pbWF0aW9uLl9jYVNjcm9sbERpc3QgfHwgMCkpO1xuICAgIH07XG5cbiAgICBzZWxmLmVuYWJsZSA9IGZ1bmN0aW9uIChyZXNldCwgcmVmcmVzaCkge1xuICAgICAgaWYgKCFzZWxmLmVuYWJsZWQpIHtcbiAgICAgICAgc2VsZi5lbmFibGVkID0gdHJ1ZTtcblxuICAgICAgICBfYWRkTGlzdGVuZXIoc2Nyb2xsZXIsIFwicmVzaXplXCIsIF9vblJlc2l6ZSk7XG5cbiAgICAgICAgX2FkZExpc3RlbmVyKGlzVmlld3BvcnQgPyBfZG9jIDogc2Nyb2xsZXIsIFwic2Nyb2xsXCIsIF9vblNjcm9sbCk7XG5cbiAgICAgICAgb25SZWZyZXNoSW5pdCAmJiBfYWRkTGlzdGVuZXIoU2Nyb2xsVHJpZ2dlciwgXCJyZWZyZXNoSW5pdFwiLCBvblJlZnJlc2hJbml0KTtcblxuICAgICAgICBpZiAocmVzZXQgIT09IGZhbHNlKSB7XG4gICAgICAgICAgc2VsZi5wcm9ncmVzcyA9IHByZXZQcm9ncmVzcyA9IDA7XG4gICAgICAgICAgc2Nyb2xsMSA9IHNjcm9sbDIgPSBsYXN0U25hcCA9IHNjcm9sbEZ1bmMoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlZnJlc2ggIT09IGZhbHNlICYmIHNlbGYucmVmcmVzaCgpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBzZWxmLmdldFR3ZWVuID0gZnVuY3Rpb24gKHNuYXApIHtcbiAgICAgIHJldHVybiBzbmFwICYmIHR3ZWVuVG8gPyB0d2VlblRvLnR3ZWVuIDogc2NydWJUd2VlbjtcbiAgICB9O1xuXG4gICAgc2VsZi5zZXRQb3NpdGlvbnMgPSBmdW5jdGlvbiAobmV3U3RhcnQsIG5ld0VuZCkge1xuICAgICAgLy8gZG9lc24ndCBwZXJzaXN0IGFmdGVyIHJlZnJlc2goKSEgSW50ZW5kZWQgdG8gYmUgYSB3YXkgdG8gb3ZlcnJpZGUgdmFsdWVzIHRoYXQgd2VyZSBzZXQgZHVyaW5nIHJlZnJlc2goKSwgbGlrZSB5b3UgY291bGQgc2V0IGl0IGluIG9uUmVmcmVzaCgpXG4gICAgICBpZiAocGluKSB7XG4gICAgICAgIHBpblN0YXJ0ICs9IG5ld1N0YXJ0IC0gc3RhcnQ7XG4gICAgICAgIHBpbkNoYW5nZSArPSBuZXdFbmQgLSBuZXdTdGFydCAtIGNoYW5nZTtcbiAgICAgIH1cblxuICAgICAgc2VsZi5zdGFydCA9IHN0YXJ0ID0gbmV3U3RhcnQ7XG4gICAgICBzZWxmLmVuZCA9IGVuZCA9IG5ld0VuZDtcbiAgICAgIGNoYW5nZSA9IG5ld0VuZCAtIG5ld1N0YXJ0O1xuICAgICAgc2VsZi51cGRhdGUoKTtcbiAgICB9O1xuXG4gICAgc2VsZi5kaXNhYmxlID0gZnVuY3Rpb24gKHJlc2V0LCBhbGxvd0FuaW1hdGlvbikge1xuICAgICAgaWYgKHNlbGYuZW5hYmxlZCkge1xuICAgICAgICByZXNldCAhPT0gZmFsc2UgJiYgc2VsZi5yZXZlcnQoKTtcbiAgICAgICAgc2VsZi5lbmFibGVkID0gc2VsZi5pc0FjdGl2ZSA9IGZhbHNlO1xuICAgICAgICBhbGxvd0FuaW1hdGlvbiB8fCBzY3J1YlR3ZWVuICYmIHNjcnViVHdlZW4ucGF1c2UoKTtcbiAgICAgICAgcHJldlNjcm9sbCA9IDA7XG4gICAgICAgIHBpbkNhY2hlICYmIChwaW5DYWNoZS51bmNhY2hlID0gMSk7XG4gICAgICAgIG9uUmVmcmVzaEluaXQgJiYgX3JlbW92ZUxpc3RlbmVyKFNjcm9sbFRyaWdnZXIsIFwicmVmcmVzaEluaXRcIiwgb25SZWZyZXNoSW5pdCk7XG5cbiAgICAgICAgaWYgKHNuYXBEZWxheWVkQ2FsbCkge1xuICAgICAgICAgIHNuYXBEZWxheWVkQ2FsbC5wYXVzZSgpO1xuICAgICAgICAgIHR3ZWVuVG8udHdlZW4gJiYgdHdlZW5Uby50d2Vlbi5raWxsKCkgJiYgKHR3ZWVuVG8udHdlZW4gPSAwKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghaXNWaWV3cG9ydCkge1xuICAgICAgICAgIHZhciBpID0gX3RyaWdnZXJzLmxlbmd0aDtcblxuICAgICAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgICAgIGlmIChfdHJpZ2dlcnNbaV0uc2Nyb2xsZXIgPT09IHNjcm9sbGVyICYmIF90cmlnZ2Vyc1tpXSAhPT0gc2VsZikge1xuICAgICAgICAgICAgICByZXR1cm47IC8vZG9uJ3QgcmVtb3ZlIHRoZSBsaXN0ZW5lcnMgaWYgdGhlcmUgYXJlIHN0aWxsIG90aGVyIHRyaWdnZXJzIHJlZmVyZW5jaW5nIGl0LlxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIF9yZW1vdmVMaXN0ZW5lcihzY3JvbGxlciwgXCJyZXNpemVcIiwgX29uUmVzaXplKTtcblxuICAgICAgICAgIF9yZW1vdmVMaXN0ZW5lcihzY3JvbGxlciwgXCJzY3JvbGxcIiwgX29uU2Nyb2xsKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG5cbiAgICBzZWxmLmtpbGwgPSBmdW5jdGlvbiAocmV2ZXJ0LCBhbGxvd0FuaW1hdGlvbikge1xuICAgICAgc2VsZi5kaXNhYmxlKHJldmVydCwgYWxsb3dBbmltYXRpb24pO1xuICAgICAgc2NydWJUd2VlbiAmJiAhYWxsb3dBbmltYXRpb24gJiYgc2NydWJUd2Vlbi5raWxsKCk7XG4gICAgICBpZCAmJiBkZWxldGUgX2lkc1tpZF07XG5cbiAgICAgIHZhciBpID0gX3RyaWdnZXJzLmluZGV4T2Yoc2VsZik7XG5cbiAgICAgIGkgPj0gMCAmJiBfdHJpZ2dlcnMuc3BsaWNlKGksIDEpO1xuICAgICAgaSA9PT0gX2kgJiYgX2RpcmVjdGlvbiA+IDAgJiYgX2ktLTsgLy8gaWYgd2UncmUgaW4gdGhlIG1pZGRsZSBvZiBhIHJlZnJlc2goKSBvciB1cGRhdGUoKSwgc3BsaWNpbmcgd291bGQgY2F1c2Ugc2tpcHMgaW4gdGhlIGluZGV4LCBzbyBhZGp1c3QuLi5cbiAgICAgIC8vIGlmIG5vIG90aGVyIFNjcm9sbFRyaWdnZXIgaW5zdGFuY2VzIG9mIHRoZSBzYW1lIHNjcm9sbGVyIGFyZSBmb3VuZCwgd2lwZSBvdXQgYW55IHJlY29yZGVkIHNjcm9sbCBwb3NpdGlvbi4gT3RoZXJ3aXNlLCBpbiBhIHNpbmdsZSBwYWdlIGFwcGxpY2F0aW9uLCBmb3IgZXhhbXBsZSwgaXQgY291bGQgbWFpbnRhaW4gc2Nyb2xsIHBvc2l0aW9uIHdoZW4gaXQgcmVhbGx5IHNob3VsZG4ndC5cblxuICAgICAgaSA9IDA7XG5cbiAgICAgIF90cmlnZ2Vycy5mb3JFYWNoKGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIHJldHVybiB0LnNjcm9sbGVyID09PSBzZWxmLnNjcm9sbGVyICYmIChpID0gMSk7XG4gICAgICB9KTtcblxuICAgICAgaSB8fCAoc2VsZi5zY3JvbGwucmVjID0gMCk7XG5cbiAgICAgIGlmIChhbmltYXRpb24pIHtcbiAgICAgICAgYW5pbWF0aW9uLnNjcm9sbFRyaWdnZXIgPSBudWxsO1xuICAgICAgICByZXZlcnQgJiYgYW5pbWF0aW9uLnJlbmRlcigtMSk7XG4gICAgICAgIGFsbG93QW5pbWF0aW9uIHx8IGFuaW1hdGlvbi5raWxsKCk7XG4gICAgICB9XG5cbiAgICAgIG1hcmtlclN0YXJ0ICYmIFttYXJrZXJTdGFydCwgbWFya2VyRW5kLCBtYXJrZXJTdGFydFRyaWdnZXIsIG1hcmtlckVuZFRyaWdnZXJdLmZvckVhY2goZnVuY3Rpb24gKG0pIHtcbiAgICAgICAgcmV0dXJuIG0ucGFyZW50Tm9kZSAmJiBtLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQobSk7XG4gICAgICB9KTtcbiAgICAgIF9wcmltYXJ5ID09PSBzZWxmICYmIChfcHJpbWFyeSA9IDApO1xuXG4gICAgICBpZiAocGluKSB7XG4gICAgICAgIHBpbkNhY2hlICYmIChwaW5DYWNoZS51bmNhY2hlID0gMSk7XG4gICAgICAgIGkgPSAwO1xuXG4gICAgICAgIF90cmlnZ2Vycy5mb3JFYWNoKGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgcmV0dXJuIHQucGluID09PSBwaW4gJiYgaSsrO1xuICAgICAgICB9KTtcblxuICAgICAgICBpIHx8IChwaW5DYWNoZS5zcGFjZXIgPSAwKTsgLy8gaWYgdGhlcmUgYXJlbid0IGFueSBtb3JlIFNjcm9sbFRyaWdnZXJzIHdpdGggdGhlIHNhbWUgcGluLCByZW1vdmUgdGhlIHNwYWNlciwgb3RoZXJ3aXNlIGl0IGNvdWxkIGJlIGNvbnRhbWluYXRlZCB3aXRoIG9sZC9zdGFsZSB2YWx1ZXMgaWYgdGhlIHVzZXIgcmUtY3JlYXRlcyBhIFNjcm9sbFRyaWdnZXIgZm9yIHRoZSBzYW1lIGVsZW1lbnQuXG4gICAgICB9XG5cbiAgICAgIHZhcnMub25LaWxsICYmIHZhcnMub25LaWxsKHNlbGYpO1xuICAgIH07XG5cbiAgICBzZWxmLmVuYWJsZShmYWxzZSwgZmFsc2UpO1xuICAgIGN1c3RvbVJldmVydFJldHVybiAmJiBjdXN0b21SZXZlcnRSZXR1cm4oc2VsZik7XG4gICAgIWFuaW1hdGlvbiB8fCAhYW5pbWF0aW9uLmFkZCB8fCBjaGFuZ2UgPyBzZWxmLnJlZnJlc2goKSA6IGdzYXAuZGVsYXllZENhbGwoMC4wMSwgZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHN0YXJ0IHx8IGVuZCB8fCBzZWxmLnJlZnJlc2goKTtcbiAgICB9KSAmJiAoY2hhbmdlID0gMC4wMSkgJiYgKHN0YXJ0ID0gZW5kID0gMCk7IC8vIGlmIHRoZSBhbmltYXRpb24gaXMgYSB0aW1lbGluZSwgaXQgbWF5IG5vdCBoYXZlIGJlZW4gcG9wdWxhdGVkIHlldCwgc28gaXQgd291bGRuJ3QgcmVuZGVyIGF0IHRoZSBwcm9wZXIgcGxhY2Ugb24gdGhlIGZpcnN0IHJlZnJlc2goKSwgdGh1cyB3ZSBzaG91bGQgc2NoZWR1bGUgb25lIGZvciB0aGUgbmV4dCB0aWNrLiBJZiBcImNoYW5nZVwiIGlzIGRlZmluZWQsIHdlIGtub3cgaXQgbXVzdCBiZSByZS1lbmFibGluZywgdGh1cyB3ZSBjYW4gcmVmcmVzaCgpIHJpZ2h0IGF3YXkuXG4gIH07XG5cbiAgU2Nyb2xsVHJpZ2dlci5yZWdpc3RlciA9IGZ1bmN0aW9uIHJlZ2lzdGVyKGNvcmUpIHtcbiAgICBpZiAoIV9jb3JlSW5pdHRlZCkge1xuICAgICAgZ3NhcCA9IGNvcmUgfHwgX2dldEdTQVAoKTtcbiAgICAgIF93aW5kb3dFeGlzdHMoKSAmJiB3aW5kb3cuZG9jdW1lbnQgJiYgU2Nyb2xsVHJpZ2dlci5lbmFibGUoKTtcbiAgICAgIF9jb3JlSW5pdHRlZCA9IF9lbmFibGVkO1xuICAgIH1cblxuICAgIHJldHVybiBfY29yZUluaXR0ZWQ7XG4gIH07XG5cbiAgU2Nyb2xsVHJpZ2dlci5kZWZhdWx0cyA9IGZ1bmN0aW9uIGRlZmF1bHRzKGNvbmZpZykge1xuICAgIGlmIChjb25maWcpIHtcbiAgICAgIGZvciAodmFyIHAgaW4gY29uZmlnKSB7XG4gICAgICAgIF9kZWZhdWx0c1twXSA9IGNvbmZpZ1twXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gX2RlZmF1bHRzO1xuICB9O1xuXG4gIFNjcm9sbFRyaWdnZXIuZGlzYWJsZSA9IGZ1bmN0aW9uIGRpc2FibGUocmVzZXQsIGtpbGwpIHtcbiAgICBfZW5hYmxlZCA9IDA7XG5cbiAgICBfdHJpZ2dlcnMuZm9yRWFjaChmdW5jdGlvbiAodHJpZ2dlcikge1xuICAgICAgcmV0dXJuIHRyaWdnZXJba2lsbCA/IFwia2lsbFwiIDogXCJkaXNhYmxlXCJdKHJlc2V0KTtcbiAgICB9KTtcblxuICAgIF9yZW1vdmVMaXN0ZW5lcihfd2luLCBcIndoZWVsXCIsIF9vblNjcm9sbCk7XG5cbiAgICBfcmVtb3ZlTGlzdGVuZXIoX2RvYywgXCJzY3JvbGxcIiwgX29uU2Nyb2xsKTtcblxuICAgIGNsZWFySW50ZXJ2YWwoX3N5bmNJbnRlcnZhbCk7XG5cbiAgICBfcmVtb3ZlTGlzdGVuZXIoX2RvYywgXCJ0b3VjaGNhbmNlbFwiLCBfcGFzc1Rocm91Z2gpO1xuXG4gICAgX3JlbW92ZUxpc3RlbmVyKF9ib2R5LCBcInRvdWNoc3RhcnRcIiwgX3Bhc3NUaHJvdWdoKTtcblxuICAgIF9tdWx0aUxpc3RlbmVyKF9yZW1vdmVMaXN0ZW5lciwgX2RvYywgXCJwb2ludGVyZG93bix0b3VjaHN0YXJ0LG1vdXNlZG93blwiLCBfcG9pbnRlckRvd25IYW5kbGVyKTtcblxuICAgIF9tdWx0aUxpc3RlbmVyKF9yZW1vdmVMaXN0ZW5lciwgX2RvYywgXCJwb2ludGVydXAsdG91Y2hlbmQsbW91c2V1cFwiLCBfcG9pbnRlclVwSGFuZGxlcik7XG5cbiAgICBfcmVzaXplRGVsYXkua2lsbCgpO1xuXG4gICAgX2l0ZXJhdGVBdXRvUmVmcmVzaChfcmVtb3ZlTGlzdGVuZXIpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBfc2Nyb2xsZXJzLmxlbmd0aDsgaSArPSAzKSB7XG4gICAgICBfd2hlZWxMaXN0ZW5lcihfcmVtb3ZlTGlzdGVuZXIsIF9zY3JvbGxlcnNbaV0sIF9zY3JvbGxlcnNbaSArIDFdKTtcblxuICAgICAgX3doZWVsTGlzdGVuZXIoX3JlbW92ZUxpc3RlbmVyLCBfc2Nyb2xsZXJzW2ldLCBfc2Nyb2xsZXJzW2kgKyAyXSk7XG4gICAgfVxuICB9O1xuXG4gIFNjcm9sbFRyaWdnZXIuZW5hYmxlID0gZnVuY3Rpb24gZW5hYmxlKCkge1xuICAgIF93aW4gPSB3aW5kb3c7XG4gICAgX2RvYyA9IGRvY3VtZW50O1xuICAgIF9kb2NFbCA9IF9kb2MuZG9jdW1lbnRFbGVtZW50O1xuICAgIF9ib2R5ID0gX2RvYy5ib2R5O1xuXG4gICAgaWYgKGdzYXApIHtcbiAgICAgIF90b0FycmF5ID0gZ3NhcC51dGlscy50b0FycmF5O1xuICAgICAgX2NsYW1wID0gZ3NhcC51dGlscy5jbGFtcDtcbiAgICAgIF9zdXBwcmVzc092ZXJ3cml0ZXMgPSBnc2FwLmNvcmUuc3VwcHJlc3NPdmVyd3JpdGVzIHx8IF9wYXNzVGhyb3VnaDtcbiAgICAgIGdzYXAuY29yZS5nbG9iYWxzKFwiU2Nyb2xsVHJpZ2dlclwiLCBTY3JvbGxUcmlnZ2VyKTsgLy8gbXVzdCByZWdpc3RlciB0aGUgZ2xvYmFsIG1hbnVhbGx5IGJlY2F1c2UgaW4gSW50ZXJuZXQgRXhwbG9yZXIsIGZ1bmN0aW9ucyAoY2xhc3NlcykgZG9uJ3QgaGF2ZSBhIFwibmFtZVwiIHByb3BlcnR5LlxuXG4gICAgICBpZiAoX2JvZHkpIHtcbiAgICAgICAgX2VuYWJsZWQgPSAxO1xuICAgICAgICBPYnNlcnZlci5yZWdpc3Rlcihnc2FwKTsgLy8gaXNUb3VjaCBpcyAwIGlmIG5vIHRvdWNoLCAxIGlmIE9OTFkgdG91Y2gsIGFuZCAyIGlmIGl0IGNhbiBhY2NvbW1vZGF0ZSB0b3VjaCBidXQgYWxzbyBvdGhlciB0eXBlcyBsaWtlIG1vdXNlL3BvaW50ZXIuXG5cbiAgICAgICAgU2Nyb2xsVHJpZ2dlci5pc1RvdWNoID0gT2JzZXJ2ZXIuaXNUb3VjaDtcbiAgICAgICAgX2ZpeElPU0J1ZyA9IE9ic2VydmVyLmlzVG91Y2ggJiYgLyhpUGFkfGlQaG9uZXxpUG9kfE1hYykvZy50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpOyAvLyBzaW5jZSAyMDE3LCBpT1MgaGFzIGhhZCBhIGJ1ZyB0aGF0IGNhdXNlcyBldmVudC5jbGllbnRYL1kgdG8gYmUgaW5hY2N1cmF0ZSB3aGVuIGEgc2Nyb2xsIG9jY3VycywgdGh1cyB3ZSBtdXN0IGFsdGVybmF0ZSBpZ25vcmluZyBldmVyeSBvdGhlciB0b3VjaG1vdmUgZXZlbnQgdG8gd29yayBhcm91bmQgaXQuIFNlZSBodHRwczovL2J1Z3Mud2Via2l0Lm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTgxOTU0IGFuZCBodHRwczovL2NvZGVwZW4uaW8vR3JlZW5Tb2NrL3Blbi9FeGJyUE5hLzA4N2NlZjE5N2RjMzU0NDVhMDk1MWU4OTM1YzQxNTAzXG5cbiAgICAgICAgX2FkZExpc3RlbmVyKF93aW4sIFwid2hlZWxcIiwgX29uU2Nyb2xsKTsgLy8gbW9zdGx5IGZvciAzcmQgcGFydHkgc21vb3RoIHNjcm9sbGluZyBsaWJyYXJpZXMuXG5cblxuICAgICAgICBfcm9vdCA9IFtfd2luLCBfZG9jLCBfZG9jRWwsIF9ib2R5XTtcbiAgICAgICAgU2Nyb2xsVHJpZ2dlci5tYXRjaE1lZGlhKHtcbiAgICAgICAgICAvLyB3aGVuIG9yaWVudGF0aW9uIGNoYW5nZXMsIHdlIHNob3VsZCB0YWtlIG5ldyBiYXNlIG1lYXN1cmVtZW50cyBmb3IgdGhlIGlnbm9yZU1vYmlsZVJlc2l6ZSBmZWF0dXJlLlxuICAgICAgICAgIFwiKG9yaWVudGF0aW9uOiBwb3J0cmFpdClcIjogZnVuY3Rpb24gb3JpZW50YXRpb25Qb3J0cmFpdCgpIHtcbiAgICAgICAgICAgIF9zZXRCYXNlRGltZW5zaW9ucygpO1xuXG4gICAgICAgICAgICByZXR1cm4gX3NldEJhc2VEaW1lbnNpb25zO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgX2FkZExpc3RlbmVyKF9kb2MsIFwic2Nyb2xsXCIsIF9vblNjcm9sbCk7IC8vIHNvbWUgYnJvd3NlcnMgKGxpa2UgQ2hyb21lKSwgdGhlIHdpbmRvdyBzdG9wcyBkaXNwYXRjaGluZyBzY3JvbGwgZXZlbnRzIG9uIHRoZSB3aW5kb3cgaWYgeW91IHNjcm9sbCByZWFsbHkgZmFzdCwgYnV0IGl0J3MgY29uc2lzdGVudCBvbiB0aGUgZG9jdW1lbnQhXG5cblxuICAgICAgICB2YXIgYm9keVN0eWxlID0gX2JvZHkuc3R5bGUsXG4gICAgICAgICAgICBib3JkZXIgPSBib2R5U3R5bGUuYm9yZGVyVG9wU3R5bGUsXG4gICAgICAgICAgICBib3VuZHMsXG4gICAgICAgICAgICBpO1xuICAgICAgICBib2R5U3R5bGUuYm9yZGVyVG9wU3R5bGUgPSBcInNvbGlkXCI7IC8vIHdvcmtzIGFyb3VuZCBhbiBpc3N1ZSB3aGVyZSBhIG1hcmdpbiBvZiBhIGNoaWxkIGVsZW1lbnQgY291bGQgdGhyb3cgb2ZmIHRoZSBib3VuZHMgb2YgdGhlIF9ib2R5LCBtYWtpbmcgaXQgc2VlbSBsaWtlIHRoZXJlJ3MgYSBtYXJnaW4gd2hlbiB0aGVyZSBhY3R1YWxseSBpc24ndC4gVGhlIGJvcmRlciBlbnN1cmVzIHRoYXQgdGhlIGJvdW5kcyBhcmUgYWNjdXJhdGUuXG5cbiAgICAgICAgYm91bmRzID0gX2dldEJvdW5kcyhfYm9keSk7XG4gICAgICAgIF92ZXJ0aWNhbC5tID0gTWF0aC5yb3VuZChib3VuZHMudG9wICsgX3ZlcnRpY2FsLnNjKCkpIHx8IDA7IC8vIGFjY29tbW9kYXRlIHRoZSBvZmZzZXQgb2YgdGhlIDxib2R5PiBjYXVzZWQgYnkgbWFyZ2lucyBhbmQvb3IgcGFkZGluZ1xuXG4gICAgICAgIF9ob3Jpem9udGFsLm0gPSBNYXRoLnJvdW5kKGJvdW5kcy5sZWZ0ICsgX2hvcml6b250YWwuc2MoKSkgfHwgMDtcbiAgICAgICAgYm9yZGVyID8gYm9keVN0eWxlLmJvcmRlclRvcFN0eWxlID0gYm9yZGVyIDogYm9keVN0eWxlLnJlbW92ZVByb3BlcnR5KFwiYm9yZGVyLXRvcC1zdHlsZVwiKTsgLy8gVE9ETzogKD8pIG1heWJlIG1vdmUgdG8gbGV2ZXJhZ2luZyB0aGUgdmVsb2NpdHkgbWVjaGFuaXNtIGluIE9ic2VydmVyIGFuZCBza2lwIGludGVydmFscy5cblxuICAgICAgICBfc3luY0ludGVydmFsID0gc2V0SW50ZXJ2YWwoX3N5bmMsIDI1MCk7XG4gICAgICAgIGdzYXAuZGVsYXllZENhbGwoMC41LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIF9zdGFydHVwID0gMDtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgX2FkZExpc3RlbmVyKF9kb2MsIFwidG91Y2hjYW5jZWxcIiwgX3Bhc3NUaHJvdWdoKTsgLy8gc29tZSBvbGRlciBBbmRyb2lkIGRldmljZXMgaW50ZXJtaXR0ZW50bHkgc3RvcCBkaXNwYXRjaGluZyBcInRvdWNobW92ZVwiIGV2ZW50cyBpZiB3ZSBkb24ndCBsaXN0ZW4gZm9yIFwidG91Y2hjYW5jZWxcIiBvbiB0aGUgZG9jdW1lbnQuXG5cblxuICAgICAgICBfYWRkTGlzdGVuZXIoX2JvZHksIFwidG91Y2hzdGFydFwiLCBfcGFzc1Rocm91Z2gpOyAvL3dvcmtzIGFyb3VuZCBTYWZhcmkgYnVnOiBodHRwczovL2dyZWVuc29jay5jb20vZm9ydW1zL3RvcGljLzIxNDUwLWRyYWdnYWJsZS1pbi1pZnJhbWUtb24tbW9iaWxlLWlzLWJ1Z2d5L1xuXG5cbiAgICAgICAgX211bHRpTGlzdGVuZXIoX2FkZExpc3RlbmVyLCBfZG9jLCBcInBvaW50ZXJkb3duLHRvdWNoc3RhcnQsbW91c2Vkb3duXCIsIF9wb2ludGVyRG93bkhhbmRsZXIpO1xuXG4gICAgICAgIF9tdWx0aUxpc3RlbmVyKF9hZGRMaXN0ZW5lciwgX2RvYywgXCJwb2ludGVydXAsdG91Y2hlbmQsbW91c2V1cFwiLCBfcG9pbnRlclVwSGFuZGxlcik7XG5cbiAgICAgICAgX3RyYW5zZm9ybVByb3AgPSBnc2FwLnV0aWxzLmNoZWNrUHJlZml4KFwidHJhbnNmb3JtXCIpO1xuXG4gICAgICAgIF9zdGF0ZVByb3BzLnB1c2goX3RyYW5zZm9ybVByb3ApO1xuXG4gICAgICAgIF9jb3JlSW5pdHRlZCA9IF9nZXRUaW1lKCk7XG4gICAgICAgIF9yZXNpemVEZWxheSA9IGdzYXAuZGVsYXllZENhbGwoMC4yLCBfcmVmcmVzaEFsbCkucGF1c2UoKTtcbiAgICAgICAgX2F1dG9SZWZyZXNoID0gW19kb2MsIFwidmlzaWJpbGl0eWNoYW5nZVwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdmFyIHcgPSBfd2luLmlubmVyV2lkdGgsXG4gICAgICAgICAgICAgIGggPSBfd2luLmlubmVySGVpZ2h0O1xuXG4gICAgICAgICAgaWYgKF9kb2MuaGlkZGVuKSB7XG4gICAgICAgICAgICBfcHJldldpZHRoID0gdztcbiAgICAgICAgICAgIF9wcmV2SGVpZ2h0ID0gaDtcbiAgICAgICAgICB9IGVsc2UgaWYgKF9wcmV2V2lkdGggIT09IHcgfHwgX3ByZXZIZWlnaHQgIT09IGgpIHtcbiAgICAgICAgICAgIF9vblJlc2l6ZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwgX2RvYywgXCJET01Db250ZW50TG9hZGVkXCIsIF9yZWZyZXNoQWxsLCBfd2luLCBcImxvYWRcIiwgX3JlZnJlc2hBbGwsIF93aW4sIFwicmVzaXplXCIsIF9vblJlc2l6ZV07XG5cbiAgICAgICAgX2l0ZXJhdGVBdXRvUmVmcmVzaChfYWRkTGlzdGVuZXIpO1xuXG4gICAgICAgIF90cmlnZ2Vycy5mb3JFYWNoKGZ1bmN0aW9uICh0cmlnZ2VyKSB7XG4gICAgICAgICAgcmV0dXJuIHRyaWdnZXIuZW5hYmxlKDAsIDEpO1xuICAgICAgICB9KTtcblxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgX3Njcm9sbGVycy5sZW5ndGg7IGkgKz0gMykge1xuICAgICAgICAgIF93aGVlbExpc3RlbmVyKF9yZW1vdmVMaXN0ZW5lciwgX3Njcm9sbGVyc1tpXSwgX3Njcm9sbGVyc1tpICsgMV0pO1xuXG4gICAgICAgICAgX3doZWVsTGlzdGVuZXIoX3JlbW92ZUxpc3RlbmVyLCBfc2Nyb2xsZXJzW2ldLCBfc2Nyb2xsZXJzW2kgKyAyXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgU2Nyb2xsVHJpZ2dlci5jb25maWcgPSBmdW5jdGlvbiBjb25maWcodmFycykge1xuICAgIFwibGltaXRDYWxsYmFja3NcIiBpbiB2YXJzICYmIChfbGltaXRDYWxsYmFja3MgPSAhIXZhcnMubGltaXRDYWxsYmFja3MpO1xuICAgIHZhciBtcyA9IHZhcnMuc3luY0ludGVydmFsO1xuICAgIG1zICYmIGNsZWFySW50ZXJ2YWwoX3N5bmNJbnRlcnZhbCkgfHwgKF9zeW5jSW50ZXJ2YWwgPSBtcykgJiYgc2V0SW50ZXJ2YWwoX3N5bmMsIG1zKTtcbiAgICBcImlnbm9yZU1vYmlsZVJlc2l6ZVwiIGluIHZhcnMgJiYgKF9pZ25vcmVNb2JpbGVSZXNpemUgPSBTY3JvbGxUcmlnZ2VyLmlzVG91Y2ggPT09IDEgJiYgdmFycy5pZ25vcmVNb2JpbGVSZXNpemUpO1xuXG4gICAgaWYgKFwiYXV0b1JlZnJlc2hFdmVudHNcIiBpbiB2YXJzKSB7XG4gICAgICBfaXRlcmF0ZUF1dG9SZWZyZXNoKF9yZW1vdmVMaXN0ZW5lcikgfHwgX2l0ZXJhdGVBdXRvUmVmcmVzaChfYWRkTGlzdGVuZXIsIHZhcnMuYXV0b1JlZnJlc2hFdmVudHMgfHwgXCJub25lXCIpO1xuICAgICAgX2lnbm9yZVJlc2l6ZSA9ICh2YXJzLmF1dG9SZWZyZXNoRXZlbnRzICsgXCJcIikuaW5kZXhPZihcInJlc2l6ZVwiKSA9PT0gLTE7XG4gICAgfVxuICB9O1xuXG4gIFNjcm9sbFRyaWdnZXIuc2Nyb2xsZXJQcm94eSA9IGZ1bmN0aW9uIHNjcm9sbGVyUHJveHkodGFyZ2V0LCB2YXJzKSB7XG4gICAgdmFyIHQgPSBfZ2V0VGFyZ2V0KHRhcmdldCksXG4gICAgICAgIGkgPSBfc2Nyb2xsZXJzLmluZGV4T2YodCksXG4gICAgICAgIGlzVmlld3BvcnQgPSBfaXNWaWV3cG9ydCh0KTtcblxuICAgIGlmICh+aSkge1xuICAgICAgX3Njcm9sbGVycy5zcGxpY2UoaSwgaXNWaWV3cG9ydCA/IDYgOiAyKTtcbiAgICB9XG5cbiAgICBpZiAodmFycykge1xuICAgICAgaXNWaWV3cG9ydCA/IF9wcm94aWVzLnVuc2hpZnQoX3dpbiwgdmFycywgX2JvZHksIHZhcnMsIF9kb2NFbCwgdmFycykgOiBfcHJveGllcy51bnNoaWZ0KHQsIHZhcnMpO1xuICAgIH1cbiAgfTtcblxuICBTY3JvbGxUcmlnZ2VyLm1hdGNoTWVkaWEgPSBmdW5jdGlvbiBtYXRjaE1lZGlhKHZhcnMpIHtcbiAgICAvLyBfbWVkaWEgaXMgcG9wdWxhdGVkIGluIHRoZSBmb2xsb3dpbmcgb3JkZXI6IG1lZGlhUXVlcnlTdHJpbmcsIG9uTWF0Y2gsIG9uVW5tYXRjaCwgaXNNYXRjaGVkLiBTbyBpZiB0aGVyZSBhcmUgdHdvIG1lZGlhIHF1ZXJpZXMsIHRoZSBBcnJheSB3b3VsZCBoYXZlIGEgbGVuZ3RoIG9mIDhcbiAgICB2YXIgbXEsIHAsIGksIGZ1bmMsIHJlc3VsdDtcblxuICAgIGZvciAocCBpbiB2YXJzKSB7XG4gICAgICBpID0gX21lZGlhLmluZGV4T2YocCk7XG4gICAgICBmdW5jID0gdmFyc1twXTtcbiAgICAgIF9jcmVhdGluZ01lZGlhID0gcDtcblxuICAgICAgaWYgKHAgPT09IFwiYWxsXCIpIHtcbiAgICAgICAgZnVuYygpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbXEgPSBfd2luLm1hdGNoTWVkaWEocCk7XG5cbiAgICAgICAgaWYgKG1xKSB7XG4gICAgICAgICAgbXEubWF0Y2hlcyAmJiAocmVzdWx0ID0gZnVuYygpKTtcblxuICAgICAgICAgIGlmICh+aSkge1xuICAgICAgICAgICAgX21lZGlhW2kgKyAxXSA9IF9jb21iaW5lRnVuYyhfbWVkaWFbaSArIDFdLCBmdW5jKTtcbiAgICAgICAgICAgIF9tZWRpYVtpICsgMl0gPSBfY29tYmluZUZ1bmMoX21lZGlhW2kgKyAyXSwgcmVzdWx0KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaSA9IF9tZWRpYS5sZW5ndGg7XG5cbiAgICAgICAgICAgIF9tZWRpYS5wdXNoKHAsIGZ1bmMsIHJlc3VsdCk7XG5cbiAgICAgICAgICAgIG1xLmFkZExpc3RlbmVyID8gbXEuYWRkTGlzdGVuZXIoX29uTWVkaWFDaGFuZ2UpIDogbXEuYWRkRXZlbnRMaXN0ZW5lcihcImNoYW5nZVwiLCBfb25NZWRpYUNoYW5nZSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgX21lZGlhW2kgKyAzXSA9IG1xLm1hdGNoZXM7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgX2NyZWF0aW5nTWVkaWEgPSAwO1xuICAgIH1cblxuICAgIHJldHVybiBfbWVkaWE7XG4gIH07XG5cbiAgU2Nyb2xsVHJpZ2dlci5jbGVhck1hdGNoTWVkaWEgPSBmdW5jdGlvbiBjbGVhck1hdGNoTWVkaWEocXVlcnkpIHtcbiAgICBxdWVyeSB8fCAoX21lZGlhLmxlbmd0aCA9IDApO1xuICAgIHF1ZXJ5ID0gX21lZGlhLmluZGV4T2YocXVlcnkpO1xuICAgIHF1ZXJ5ID49IDAgJiYgX21lZGlhLnNwbGljZShxdWVyeSwgNCk7XG4gIH07XG5cbiAgU2Nyb2xsVHJpZ2dlci5pc0luVmlld3BvcnQgPSBmdW5jdGlvbiBpc0luVmlld3BvcnQoZWxlbWVudCwgcmF0aW8sIGhvcml6b250YWwpIHtcbiAgICB2YXIgYm91bmRzID0gKF9pc1N0cmluZyhlbGVtZW50KSA/IF9nZXRUYXJnZXQoZWxlbWVudCkgOiBlbGVtZW50KS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSxcbiAgICAgICAgb2Zmc2V0ID0gYm91bmRzW2hvcml6b250YWwgPyBfd2lkdGggOiBfaGVpZ2h0XSAqIHJhdGlvIHx8IDA7XG4gICAgcmV0dXJuIGhvcml6b250YWwgPyBib3VuZHMucmlnaHQgLSBvZmZzZXQgPiAwICYmIGJvdW5kcy5sZWZ0ICsgb2Zmc2V0IDwgX3dpbi5pbm5lcldpZHRoIDogYm91bmRzLmJvdHRvbSAtIG9mZnNldCA+IDAgJiYgYm91bmRzLnRvcCArIG9mZnNldCA8IF93aW4uaW5uZXJIZWlnaHQ7XG4gIH07XG5cbiAgU2Nyb2xsVHJpZ2dlci5wb3NpdGlvbkluVmlld3BvcnQgPSBmdW5jdGlvbiBwb3NpdGlvbkluVmlld3BvcnQoZWxlbWVudCwgcmVmZXJlbmNlUG9pbnQsIGhvcml6b250YWwpIHtcbiAgICBfaXNTdHJpbmcoZWxlbWVudCkgJiYgKGVsZW1lbnQgPSBfZ2V0VGFyZ2V0KGVsZW1lbnQpKTtcbiAgICB2YXIgYm91bmRzID0gZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSxcbiAgICAgICAgc2l6ZSA9IGJvdW5kc1tob3Jpem9udGFsID8gX3dpZHRoIDogX2hlaWdodF0sXG4gICAgICAgIG9mZnNldCA9IHJlZmVyZW5jZVBvaW50ID09IG51bGwgPyBzaXplIC8gMiA6IHJlZmVyZW5jZVBvaW50IGluIF9rZXl3b3JkcyA/IF9rZXl3b3Jkc1tyZWZlcmVuY2VQb2ludF0gKiBzaXplIDogfnJlZmVyZW5jZVBvaW50LmluZGV4T2YoXCIlXCIpID8gcGFyc2VGbG9hdChyZWZlcmVuY2VQb2ludCkgKiBzaXplIC8gMTAwIDogcGFyc2VGbG9hdChyZWZlcmVuY2VQb2ludCkgfHwgMDtcbiAgICByZXR1cm4gaG9yaXpvbnRhbCA/IChib3VuZHMubGVmdCArIG9mZnNldCkgLyBfd2luLmlubmVyV2lkdGggOiAoYm91bmRzLnRvcCArIG9mZnNldCkgLyBfd2luLmlubmVySGVpZ2h0O1xuICB9O1xuXG4gIHJldHVybiBTY3JvbGxUcmlnZ2VyO1xufSgpO1xuU2Nyb2xsVHJpZ2dlci52ZXJzaW9uID0gXCIzLjEwLjRcIjtcblxuU2Nyb2xsVHJpZ2dlci5zYXZlU3R5bGVzID0gZnVuY3Rpb24gKHRhcmdldHMpIHtcbiAgcmV0dXJuIHRhcmdldHMgPyBfdG9BcnJheSh0YXJnZXRzKS5mb3JFYWNoKGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgICAvLyBzYXZlZCBzdHlsZXMgYXJlIHJlY29yZGVkIGluIGEgY29uc2VjdXRpdmUgYWx0ZXJuYXRpbmcgQXJyYXksIGxpa2UgW2VsZW1lbnQsIGNzc1RleHQsIHRyYW5zZm9ybSBhdHRyaWJ1dGUsIGNhY2hlLCBtYXRjaE1lZGlhLCAuLi5dXG4gICAgaWYgKHRhcmdldCAmJiB0YXJnZXQuc3R5bGUpIHtcbiAgICAgIHZhciBpID0gX3NhdmVkU3R5bGVzLmluZGV4T2YodGFyZ2V0KTtcblxuICAgICAgaSA+PSAwICYmIF9zYXZlZFN0eWxlcy5zcGxpY2UoaSwgNSk7XG5cbiAgICAgIF9zYXZlZFN0eWxlcy5wdXNoKHRhcmdldCwgdGFyZ2V0LnN0eWxlLmNzc1RleHQsIHRhcmdldC5nZXRCQm94ICYmIHRhcmdldC5nZXRBdHRyaWJ1dGUoXCJ0cmFuc2Zvcm1cIiksIGdzYXAuY29yZS5nZXRDYWNoZSh0YXJnZXQpLCBfY3JlYXRpbmdNZWRpYSk7XG4gICAgfVxuICB9KSA6IF9zYXZlZFN0eWxlcztcbn07XG5cblNjcm9sbFRyaWdnZXIucmV2ZXJ0ID0gZnVuY3Rpb24gKHNvZnQsIG1lZGlhKSB7XG4gIHJldHVybiBfcmV2ZXJ0QWxsKCFzb2Z0LCBtZWRpYSk7XG59O1xuXG5TY3JvbGxUcmlnZ2VyLmNyZWF0ZSA9IGZ1bmN0aW9uICh2YXJzLCBhbmltYXRpb24pIHtcbiAgcmV0dXJuIG5ldyBTY3JvbGxUcmlnZ2VyKHZhcnMsIGFuaW1hdGlvbik7XG59O1xuXG5TY3JvbGxUcmlnZ2VyLnJlZnJlc2ggPSBmdW5jdGlvbiAoc2FmZSkge1xuICByZXR1cm4gc2FmZSA/IF9vblJlc2l6ZSgpIDogKF9jb3JlSW5pdHRlZCB8fCBTY3JvbGxUcmlnZ2VyLnJlZ2lzdGVyKCkpICYmIF9yZWZyZXNoQWxsKHRydWUpO1xufTtcblxuU2Nyb2xsVHJpZ2dlci51cGRhdGUgPSBfdXBkYXRlQWxsO1xuU2Nyb2xsVHJpZ2dlci5jbGVhclNjcm9sbE1lbW9yeSA9IF9jbGVhclNjcm9sbE1lbW9yeTtcblxuU2Nyb2xsVHJpZ2dlci5tYXhTY3JvbGwgPSBmdW5jdGlvbiAoZWxlbWVudCwgaG9yaXpvbnRhbCkge1xuICByZXR1cm4gX21heFNjcm9sbChlbGVtZW50LCBob3Jpem9udGFsID8gX2hvcml6b250YWwgOiBfdmVydGljYWwpO1xufTtcblxuU2Nyb2xsVHJpZ2dlci5nZXRTY3JvbGxGdW5jID0gZnVuY3Rpb24gKGVsZW1lbnQsIGhvcml6b250YWwpIHtcbiAgcmV0dXJuIF9nZXRTY3JvbGxGdW5jKF9nZXRUYXJnZXQoZWxlbWVudCksIGhvcml6b250YWwgPyBfaG9yaXpvbnRhbCA6IF92ZXJ0aWNhbCk7XG59O1xuXG5TY3JvbGxUcmlnZ2VyLmdldEJ5SWQgPSBmdW5jdGlvbiAoaWQpIHtcbiAgcmV0dXJuIF9pZHNbaWRdO1xufTtcblxuU2Nyb2xsVHJpZ2dlci5nZXRBbGwgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBfdHJpZ2dlcnMuZmlsdGVyKGZ1bmN0aW9uICh0KSB7XG4gICAgcmV0dXJuIHQudmFycy5pZCAhPT0gXCJTY3JvbGxTbW9vdGhlclwiO1xuICB9KTtcbn07IC8vIGl0J3MgY29tbW9uIGZvciBwZW9wbGUgdG8gU2Nyb2xsVHJpZ2dlci5nZXRBbGwodCA9PiB0LmtpbGwoKSkgb24gcGFnZSByb3V0ZXMsIGZvciBleGFtcGxlLCBhbmQgd2UgZG9uJ3Qgd2FudCBpdCB0byBydWluIHNtb290aCBzY3JvbGxpbmcgYnkga2lsbGluZyB0aGUgbWFpbiBTY3JvbGxTbW9vdGhlciBvbmUuXG5cblxuU2Nyb2xsVHJpZ2dlci5pc1Njcm9sbGluZyA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuICEhX2xhc3RTY3JvbGxUaW1lO1xufTtcblxuU2Nyb2xsVHJpZ2dlci5zbmFwRGlyZWN0aW9uYWwgPSBfc25hcERpcmVjdGlvbmFsO1xuXG5TY3JvbGxUcmlnZ2VyLmFkZEV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbiAodHlwZSwgY2FsbGJhY2spIHtcbiAgdmFyIGEgPSBfbGlzdGVuZXJzW3R5cGVdIHx8IChfbGlzdGVuZXJzW3R5cGVdID0gW10pO1xuICB+YS5pbmRleE9mKGNhbGxiYWNrKSB8fCBhLnB1c2goY2FsbGJhY2spO1xufTtcblxuU2Nyb2xsVHJpZ2dlci5yZW1vdmVFdmVudExpc3RlbmVyID0gZnVuY3Rpb24gKHR5cGUsIGNhbGxiYWNrKSB7XG4gIHZhciBhID0gX2xpc3RlbmVyc1t0eXBlXSxcbiAgICAgIGkgPSBhICYmIGEuaW5kZXhPZihjYWxsYmFjayk7XG4gIGkgPj0gMCAmJiBhLnNwbGljZShpLCAxKTtcbn07XG5cblNjcm9sbFRyaWdnZXIuYmF0Y2ggPSBmdW5jdGlvbiAodGFyZ2V0cywgdmFycykge1xuICB2YXIgcmVzdWx0ID0gW10sXG4gICAgICB2YXJzQ29weSA9IHt9LFxuICAgICAgaW50ZXJ2YWwgPSB2YXJzLmludGVydmFsIHx8IDAuMDE2LFxuICAgICAgYmF0Y2hNYXggPSB2YXJzLmJhdGNoTWF4IHx8IDFlOSxcbiAgICAgIHByb3h5Q2FsbGJhY2sgPSBmdW5jdGlvbiBwcm94eUNhbGxiYWNrKHR5cGUsIGNhbGxiYWNrKSB7XG4gICAgdmFyIGVsZW1lbnRzID0gW10sXG4gICAgICAgIHRyaWdnZXJzID0gW10sXG4gICAgICAgIGRlbGF5ID0gZ3NhcC5kZWxheWVkQ2FsbChpbnRlcnZhbCwgZnVuY3Rpb24gKCkge1xuICAgICAgY2FsbGJhY2soZWxlbWVudHMsIHRyaWdnZXJzKTtcbiAgICAgIGVsZW1lbnRzID0gW107XG4gICAgICB0cmlnZ2VycyA9IFtdO1xuICAgIH0pLnBhdXNlKCk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChzZWxmKSB7XG4gICAgICBlbGVtZW50cy5sZW5ndGggfHwgZGVsYXkucmVzdGFydCh0cnVlKTtcbiAgICAgIGVsZW1lbnRzLnB1c2goc2VsZi50cmlnZ2VyKTtcbiAgICAgIHRyaWdnZXJzLnB1c2goc2VsZik7XG4gICAgICBiYXRjaE1heCA8PSBlbGVtZW50cy5sZW5ndGggJiYgZGVsYXkucHJvZ3Jlc3MoMSk7XG4gICAgfTtcbiAgfSxcbiAgICAgIHA7XG5cbiAgZm9yIChwIGluIHZhcnMpIHtcbiAgICB2YXJzQ29weVtwXSA9IHAuc3Vic3RyKDAsIDIpID09PSBcIm9uXCIgJiYgX2lzRnVuY3Rpb24odmFyc1twXSkgJiYgcCAhPT0gXCJvblJlZnJlc2hJbml0XCIgPyBwcm94eUNhbGxiYWNrKHAsIHZhcnNbcF0pIDogdmFyc1twXTtcbiAgfVxuXG4gIGlmIChfaXNGdW5jdGlvbihiYXRjaE1heCkpIHtcbiAgICBiYXRjaE1heCA9IGJhdGNoTWF4KCk7XG5cbiAgICBfYWRkTGlzdGVuZXIoU2Nyb2xsVHJpZ2dlciwgXCJyZWZyZXNoXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBiYXRjaE1heCA9IHZhcnMuYmF0Y2hNYXgoKTtcbiAgICB9KTtcbiAgfVxuXG4gIF90b0FycmF5KHRhcmdldHMpLmZvckVhY2goZnVuY3Rpb24gKHRhcmdldCkge1xuICAgIHZhciBjb25maWcgPSB7fTtcblxuICAgIGZvciAocCBpbiB2YXJzQ29weSkge1xuICAgICAgY29uZmlnW3BdID0gdmFyc0NvcHlbcF07XG4gICAgfVxuXG4gICAgY29uZmlnLnRyaWdnZXIgPSB0YXJnZXQ7XG4gICAgcmVzdWx0LnB1c2goU2Nyb2xsVHJpZ2dlci5jcmVhdGUoY29uZmlnKSk7XG4gIH0pO1xuXG4gIHJldHVybiByZXN1bHQ7XG59OyAvLyB0byByZWR1Y2UgZmlsZSBzaXplLiBjbGFtcHMgdGhlIHNjcm9sbCBhbmQgYWxzbyByZXR1cm5zIGEgZHVyYXRpb24gbXVsdGlwbGllciBzbyB0aGF0IGlmIHRoZSBzY3JvbGwgZ2V0cyBjaG9wcGVkIHNob3J0ZXIsIHRoZSBkdXJhdGlvbiBnZXRzIGN1cnRhaWxlZCBhcyB3ZWxsIChvdGhlcndpc2UgaWYgeW91J3JlIHZlcnkgY2xvc2UgdG8gdGhlIHRvcCBvZiB0aGUgcGFnZSwgZm9yIGV4YW1wbGUsIGFuZCBzd2lwZSB1cCByZWFsbHkgZmFzdCwgaXQnbGwgc3VkZGVubHkgc2xvdyBkb3duIGFuZCB0YWtlIGEgbG9uZyB0aW1lIHRvIHJlYWNoIHRoZSB0b3ApLlxuXG5cbnZhciBfY2xhbXBTY3JvbGxBbmRHZXREdXJhdGlvbk11bHRpcGxpZXIgPSBmdW5jdGlvbiBfY2xhbXBTY3JvbGxBbmRHZXREdXJhdGlvbk11bHRpcGxpZXIoc2Nyb2xsRnVuYywgY3VycmVudCwgZW5kLCBtYXgpIHtcbiAgY3VycmVudCA+IG1heCA/IHNjcm9sbEZ1bmMobWF4KSA6IGN1cnJlbnQgPCAwICYmIHNjcm9sbEZ1bmMoMCk7XG4gIHJldHVybiBlbmQgPiBtYXggPyAobWF4IC0gY3VycmVudCkgLyAoZW5kIC0gY3VycmVudCkgOiBlbmQgPCAwID8gY3VycmVudCAvIChjdXJyZW50IC0gZW5kKSA6IDE7XG59LFxuICAgIF9hbGxvd05hdGl2ZVBhbm5pbmcgPSBmdW5jdGlvbiBfYWxsb3dOYXRpdmVQYW5uaW5nKHRhcmdldCwgZGlyZWN0aW9uKSB7XG4gIGlmIChkaXJlY3Rpb24gPT09IHRydWUpIHtcbiAgICB0YXJnZXQuc3R5bGUucmVtb3ZlUHJvcGVydHkoXCJ0b3VjaC1hY3Rpb25cIik7XG4gIH0gZWxzZSB7XG4gICAgdGFyZ2V0LnN0eWxlLnRvdWNoQWN0aW9uID0gZGlyZWN0aW9uID09PSB0cnVlID8gXCJhdXRvXCIgOiBkaXJlY3Rpb24gPyBcInBhbi1cIiArIGRpcmVjdGlvbiArIChPYnNlcnZlci5pc1RvdWNoID8gXCIgcGluY2gtem9vbVwiIDogXCJcIikgOiBcIm5vbmVcIjsgLy8gbm90ZTogRmlyZWZveCBkb2Vzbid0IHN1cHBvcnQgaXQgcGluY2gtem9vbSBwcm9wZXJseSwgYXQgbGVhc3QgaW4gYWRkaXRpb24gdG8gYSBwYW4teCBvciBwYW4teS5cbiAgfVxuXG4gIHRhcmdldCA9PT0gX2RvY0VsICYmIF9hbGxvd05hdGl2ZVBhbm5pbmcoX2JvZHksIGRpcmVjdGlvbik7XG59LFxuICAgIF9vdmVyZmxvdyA9IHtcbiAgYXV0bzogMSxcbiAgc2Nyb2xsOiAxXG59LFxuICAgIF9uZXN0ZWRTY3JvbGwgPSBmdW5jdGlvbiBfbmVzdGVkU2Nyb2xsKF9yZWY1KSB7XG4gIHZhciBldmVudCA9IF9yZWY1LmV2ZW50LFxuICAgICAgdGFyZ2V0ID0gX3JlZjUudGFyZ2V0LFxuICAgICAgYXhpcyA9IF9yZWY1LmF4aXM7XG5cbiAgdmFyIG5vZGUgPSAoZXZlbnQuY2hhbmdlZFRvdWNoZXMgPyBldmVudC5jaGFuZ2VkVG91Y2hlc1swXSA6IGV2ZW50KS50YXJnZXQsXG4gICAgICBjYWNoZSA9IG5vZGUuX2dzYXAgfHwgZ3NhcC5jb3JlLmdldENhY2hlKG5vZGUpLFxuICAgICAgdGltZSA9IF9nZXRUaW1lKCksXG4gICAgICBjcztcblxuICBpZiAoIWNhY2hlLl9pc1Njcm9sbFQgfHwgdGltZSAtIGNhY2hlLl9pc1Njcm9sbFQgPiAyMDAwKSB7XG4gICAgLy8gY2FjaGUgZm9yIDIgc2Vjb25kcyB0byBpbXByb3ZlIHBlcmZvcm1hbmNlLlxuICAgIHdoaWxlIChub2RlICYmIG5vZGUuc2Nyb2xsSGVpZ2h0IDw9IG5vZGUuY2xpZW50SGVpZ2h0KSB7XG4gICAgICBub2RlID0gbm9kZS5wYXJlbnROb2RlO1xuICAgIH1cblxuICAgIGNhY2hlLl9pc1Njcm9sbCA9IG5vZGUgJiYgIV9pc1ZpZXdwb3J0KG5vZGUpICYmIG5vZGUgIT09IHRhcmdldCAmJiAoX292ZXJmbG93WyhjcyA9IF9nZXRDb21wdXRlZFN0eWxlKG5vZGUpKS5vdmVyZmxvd1ldIHx8IF9vdmVyZmxvd1tjcy5vdmVyZmxvd1hdKTtcbiAgICBjYWNoZS5faXNTY3JvbGxUID0gdGltZTtcbiAgfVxuXG4gIChjYWNoZS5faXNTY3JvbGwgfHwgYXhpcyA9PT0gXCJ4XCIpICYmIChldmVudC5fZ3NhcEFsbG93ID0gdHJ1ZSk7XG59LFxuICAgIC8vIGNhcHR1cmUgZXZlbnRzIG9uIHNjcm9sbGFibGUgZWxlbWVudHMgSU5TSURFIHRoZSA8Ym9keT4gYW5kIGFsbG93IHRob3NlIGJ5IGNhbGxpbmcgc3RvcFByb3BhZ2F0aW9uKCkgd2hlbiB3ZSBmaW5kIGEgc2Nyb2xsYWJsZSBhbmNlc3RvclxuX2lucHV0T2JzZXJ2ZXIgPSBmdW5jdGlvbiBfaW5wdXRPYnNlcnZlcih0YXJnZXQsIHR5cGUsIGlucHV0cywgbmVzdGVkKSB7XG4gIHJldHVybiBPYnNlcnZlci5jcmVhdGUoe1xuICAgIHRhcmdldDogdGFyZ2V0LFxuICAgIGNhcHR1cmU6IHRydWUsXG4gICAgZGVib3VuY2U6IGZhbHNlLFxuICAgIGxvY2tBeGlzOiB0cnVlLFxuICAgIHR5cGU6IHR5cGUsXG4gICAgb25XaGVlbDogbmVzdGVkID0gbmVzdGVkICYmIF9uZXN0ZWRTY3JvbGwsXG4gICAgb25QcmVzczogbmVzdGVkLFxuICAgIG9uRHJhZzogbmVzdGVkLFxuICAgIG9uU2Nyb2xsOiBuZXN0ZWQsXG4gICAgb25FbmFibGU6IGZ1bmN0aW9uIG9uRW5hYmxlKCkge1xuICAgICAgcmV0dXJuIGlucHV0cyAmJiBfYWRkTGlzdGVuZXIoX2RvYywgT2JzZXJ2ZXIuZXZlbnRUeXBlc1swXSwgX2NhcHR1cmVJbnB1dHMsIGZhbHNlLCB0cnVlKTtcbiAgICB9LFxuICAgIG9uRGlzYWJsZTogZnVuY3Rpb24gb25EaXNhYmxlKCkge1xuICAgICAgcmV0dXJuIF9yZW1vdmVMaXN0ZW5lcihfZG9jLCBPYnNlcnZlci5ldmVudFR5cGVzWzBdLCBfY2FwdHVyZUlucHV0cywgdHJ1ZSk7XG4gICAgfVxuICB9KTtcbn0sXG4gICAgX2lucHV0RXhwID0gLyhpbnB1dHxsYWJlbHxzZWxlY3R8dGV4dGFyZWEpL2ksXG4gICAgX2lucHV0SXNGb2N1c2VkLFxuICAgIF9jYXB0dXJlSW5wdXRzID0gZnVuY3Rpb24gX2NhcHR1cmVJbnB1dHMoZSkge1xuICB2YXIgaXNJbnB1dCA9IF9pbnB1dEV4cC50ZXN0KGUudGFyZ2V0LnRhZ05hbWUpO1xuXG4gIGlmIChpc0lucHV0IHx8IF9pbnB1dElzRm9jdXNlZCkge1xuICAgIGUuX2dzYXBBbGxvdyA9IHRydWU7XG4gICAgX2lucHV0SXNGb2N1c2VkID0gaXNJbnB1dDtcbiAgfVxufSxcbiAgICBfZ2V0U2Nyb2xsTm9ybWFsaXplciA9IGZ1bmN0aW9uIF9nZXRTY3JvbGxOb3JtYWxpemVyKHZhcnMpIHtcbiAgX2lzT2JqZWN0KHZhcnMpIHx8ICh2YXJzID0ge30pO1xuICB2YXJzLnByZXZlbnREZWZhdWx0ID0gdmFycy5pc05vcm1hbGl6ZXIgPSB2YXJzLmFsbG93Q2xpY2tzID0gdHJ1ZTtcbiAgdmFycy50eXBlIHx8ICh2YXJzLnR5cGUgPSBcIndoZWVsLHRvdWNoXCIpO1xuICB2YXJzLmRlYm91bmNlID0gISF2YXJzLmRlYm91bmNlO1xuICB2YXJzLmlkID0gdmFycy5pZCB8fCBcIm5vcm1hbGl6ZXJcIjtcblxuICB2YXIgX3ZhcnMyID0gdmFycyxcbiAgICAgIG5vcm1hbGl6ZVNjcm9sbFggPSBfdmFyczIubm9ybWFsaXplU2Nyb2xsWCxcbiAgICAgIG1vbWVudHVtID0gX3ZhcnMyLm1vbWVudHVtLFxuICAgICAgYWxsb3dOZXN0ZWRTY3JvbGwgPSBfdmFyczIuYWxsb3dOZXN0ZWRTY3JvbGwsXG4gICAgICBzZWxmLFxuICAgICAgbWF4WSxcbiAgICAgIHRhcmdldCA9IF9nZXRUYXJnZXQodmFycy50YXJnZXQpIHx8IF9kb2NFbCxcbiAgICAgIHNtb290aGVyID0gZ3NhcC5jb3JlLmdsb2JhbHMoKS5TY3JvbGxTbW9vdGhlcixcbiAgICAgIGNvbnRlbnQgPSBfZml4SU9TQnVnICYmICh2YXJzLmNvbnRlbnQgJiYgX2dldFRhcmdldCh2YXJzLmNvbnRlbnQpIHx8IHNtb290aGVyICYmIHNtb290aGVyLmdldCgpICYmIHNtb290aGVyLmdldCgpLmNvbnRlbnQoKSksXG4gICAgICBzY3JvbGxGdW5jWSA9IF9nZXRTY3JvbGxGdW5jKHRhcmdldCwgX3ZlcnRpY2FsKSxcbiAgICAgIHNjcm9sbEZ1bmNYID0gX2dldFNjcm9sbEZ1bmModGFyZ2V0LCBfaG9yaXpvbnRhbCksXG4gICAgICBzY2FsZSA9IDEsXG4gICAgICBpbml0aWFsU2NhbGUgPSAoT2JzZXJ2ZXIuaXNUb3VjaCAmJiBfd2luLnZpc3VhbFZpZXdwb3J0ID8gX3dpbi52aXN1YWxWaWV3cG9ydC5zY2FsZSAqIF93aW4udmlzdWFsVmlld3BvcnQud2lkdGggOiBfd2luLm91dGVyV2lkdGgpIC8gX3dpbi5pbm5lcldpZHRoLFxuICAgICAgd2hlZWxSZWZyZXNoID0gMCxcbiAgICAgIHJlc29sdmVNb21lbnR1bUR1cmF0aW9uID0gX2lzRnVuY3Rpb24obW9tZW50dW0pID8gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBtb21lbnR1bShzZWxmKTtcbiAgfSA6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gbW9tZW50dW0gfHwgMi44O1xuICB9LFxuICAgICAgc2tpcFRvdWNoTW92ZSxcbiAgICAgIGxhc3RSZWZyZXNoSUQsXG4gICAgICBpbnB1dE9ic2VydmVyID0gX2lucHV0T2JzZXJ2ZXIodGFyZ2V0LCB2YXJzLnR5cGUsIHRydWUsIGFsbG93TmVzdGVkU2Nyb2xsKSxcbiAgICAgIHJlc3VtZVRvdWNoTW92ZSA9IGZ1bmN0aW9uIHJlc3VtZVRvdWNoTW92ZSgpIHtcbiAgICByZXR1cm4gc2tpcFRvdWNoTW92ZSA9IGZhbHNlO1xuICB9LFxuICAgICAgc2Nyb2xsQ2xhbXBYID0gX3Bhc3NUaHJvdWdoLFxuICAgICAgc2Nyb2xsQ2xhbXBZID0gX3Bhc3NUaHJvdWdoLFxuICAgICAgdXBkYXRlQ2xhbXBzID0gZnVuY3Rpb24gdXBkYXRlQ2xhbXBzKCkge1xuICAgIG1heFkgPSBfbWF4U2Nyb2xsKHRhcmdldCwgX3ZlcnRpY2FsKTtcbiAgICBzY3JvbGxDbGFtcFkgPSBfY2xhbXAoX2ZpeElPU0J1ZyA/IDEgOiAwLCBtYXhZKTtcbiAgICBub3JtYWxpemVTY3JvbGxYICYmIChzY3JvbGxDbGFtcFggPSBfY2xhbXAoMCwgX21heFNjcm9sbCh0YXJnZXQsIF9ob3Jpem9udGFsKSkpO1xuICAgIGxhc3RSZWZyZXNoSUQgPSBfcmVmcmVzaElEO1xuICB9LFxuICAgICAgaWdub3JlRHJhZyA9IGZ1bmN0aW9uIGlnbm9yZURyYWcoKSB7XG4gICAgaWYgKHNraXBUb3VjaE1vdmUpIHtcbiAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZShyZXN1bWVUb3VjaE1vdmUpOyAvLyB3ZSBNVVNUIHdhaXQgZm9yIGEgcmVxdWVzdEFuaW1hdGlvbkZyYW1lLCBvdGhlcndpc2UgaU9TIHdpbGwgbWlzcmVwb3J0IHRoZSB2YWx1ZS5cblxuICAgICAgdmFyIG9mZnNldCA9IF9yb3VuZChzZWxmLmRlbHRhWSAvIDIpLFxuICAgICAgICAgIHNjcm9sbCA9IHNjcm9sbENsYW1wWShzY3JvbGxGdW5jWS52IC0gb2Zmc2V0KTtcblxuICAgICAgaWYgKGNvbnRlbnQgJiYgc2Nyb2xsICE9PSBzY3JvbGxGdW5jWS52ICsgc2Nyb2xsRnVuY1kub2Zmc2V0KSB7XG4gICAgICAgIHNjcm9sbEZ1bmNZLm9mZnNldCA9IHNjcm9sbCAtIHNjcm9sbEZ1bmNZLnY7XG4gICAgICAgIGNvbnRlbnQuc3R5bGUudHJhbnNmb3JtID0gXCJ0cmFuc2xhdGVZKFwiICsgLXNjcm9sbEZ1bmNZLm9mZnNldCArIFwicHgpXCI7XG4gICAgICAgIGNvbnRlbnQuX2dzYXAgJiYgKGNvbnRlbnQuX2dzYXAueSA9IC1zY3JvbGxGdW5jWS5vZmZzZXQgKyBcInB4XCIpO1xuICAgICAgICBzY3JvbGxGdW5jWS5jYWNoZUlEID0gX3Njcm9sbGVycy5jYWNoZTtcblxuICAgICAgICBfdXBkYXRlQWxsKCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGlmIChjb250ZW50KSB7XG4gICAgICBjb250ZW50LnN0eWxlLnRyYW5zZm9ybSA9IFwidHJhbnNsYXRlWSgwcHgpXCI7XG4gICAgICBzY3JvbGxGdW5jWS5vZmZzZXQgPSBzY3JvbGxGdW5jWS5jYWNoZUlEID0gMDtcbiAgICAgIGNvbnRlbnQuX2dzYXAgJiYgKGNvbnRlbnQuX2dzYXAueSA9IFwiMHB4XCIpO1xuICAgIH1cblxuICAgIHNraXBUb3VjaE1vdmUgPSB0cnVlO1xuICB9LFxuICAgICAgdHdlZW4sXG4gICAgICBzdGFydFNjcm9sbFgsXG4gICAgICBzdGFydFNjcm9sbFksXG4gICAgICBvblN0b3BEZWxheWVkQ2FsbCxcbiAgICAgIG9uUmVzaXplID0gZnVuY3Rpb24gb25SZXNpemUoKSB7XG4gICAgLy8gaWYgdGhlIHdpbmRvdyByZXNpemVzLCBsaWtlIG9uIGFuIGlQaG9uZSB3aGljaCBBcHBsZSBGT1JDRVMgdGhlIGFkZHJlc3MgYmFyIHRvIHNob3cvaGlkZSBldmVuIGlmIHdlIGV2ZW50LnByZXZlbnREZWZhdWx0KCksIGl0IG1heSBiZSBzY3JvbGxpbmcgdG9vIGZhciBub3cgdGhhdCB0aGUgYWRkcmVzcyBiYXIgaXMgc2hvd2luZywgc28gd2UgbXVzdCBkeW5hbWljYWxseSBhZGp1c3QgdGhlIG1vbWVudHVtIHR3ZWVuLlxuICAgIHVwZGF0ZUNsYW1wcygpO1xuXG4gICAgaWYgKHR3ZWVuLmlzQWN0aXZlKCkgJiYgdHdlZW4udmFycy5zY3JvbGxZID4gbWF4WSkge1xuICAgICAgc2Nyb2xsRnVuY1koKSA+IG1heFkgPyB0d2Vlbi5wcm9ncmVzcygxKSAmJiBzY3JvbGxGdW5jWShtYXhZKSA6IHR3ZWVuLnJlc2V0VG8oXCJzY3JvbGxZXCIsIG1heFkpO1xuICAgIH1cbiAgfTtcblxuICB2YXJzLmlnbm9yZUNoZWNrID0gZnVuY3Rpb24gKGUpIHtcbiAgICByZXR1cm4gX2ZpeElPU0J1ZyAmJiBlLnR5cGUgPT09IFwidG91Y2htb3ZlXCIgJiYgaWdub3JlRHJhZyhlKSB8fCBzY2FsZSA+IDEuMDUgJiYgZS50eXBlICE9PSBcInRvdWNoc3RhcnRcIiB8fCBzZWxmLmlzR2VzdHVyaW5nIHx8IGUudG91Y2hlcyAmJiBlLnRvdWNoZXMubGVuZ3RoID4gMTtcbiAgfTtcblxuICB2YXJzLm9uUHJlc3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHByZXZTY2FsZSA9IHNjYWxlO1xuICAgIHNjYWxlID0gX3JvdW5kKChfd2luLnZpc3VhbFZpZXdwb3J0ICYmIF93aW4udmlzdWFsVmlld3BvcnQuc2NhbGUgfHwgMSkgLyBpbml0aWFsU2NhbGUpO1xuICAgIHR3ZWVuLnBhdXNlKCk7XG4gICAgcHJldlNjYWxlICE9PSBzY2FsZSAmJiBfYWxsb3dOYXRpdmVQYW5uaW5nKHRhcmdldCwgc2NhbGUgPiAxLjAxID8gdHJ1ZSA6IG5vcm1hbGl6ZVNjcm9sbFggPyBmYWxzZSA6IFwieFwiKTtcbiAgICBza2lwVG91Y2hNb3ZlID0gZmFsc2U7XG4gICAgc3RhcnRTY3JvbGxYID0gc2Nyb2xsRnVuY1goKTtcbiAgICBzdGFydFNjcm9sbFkgPSBzY3JvbGxGdW5jWSgpO1xuICAgIHVwZGF0ZUNsYW1wcygpO1xuICAgIGxhc3RSZWZyZXNoSUQgPSBfcmVmcmVzaElEO1xuICB9O1xuXG4gIHZhcnMub25SZWxlYXNlID0gdmFycy5vbkdlc3R1cmVTdGFydCA9IGZ1bmN0aW9uIChzZWxmLCB3YXNEcmFnZ2luZykge1xuICAgIGlmIChjb250ZW50KSB7XG4gICAgICBjb250ZW50LnN0eWxlLnRyYW5zZm9ybSA9IFwidHJhbnNsYXRlWSgwcHgpXCI7XG4gICAgICBzY3JvbGxGdW5jWS5vZmZzZXQgPSBzY3JvbGxGdW5jWS5jYWNoZUlEID0gMDtcbiAgICAgIGNvbnRlbnQuX2dzYXAgJiYgKGNvbnRlbnQuX2dzYXAueSA9IFwiMHB4XCIpO1xuICAgIH1cblxuICAgIGlmICghd2FzRHJhZ2dpbmcpIHtcbiAgICAgIG9uU3RvcERlbGF5ZWRDYWxsLnJlc3RhcnQodHJ1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIF9zY3JvbGxlcnMuY2FjaGUrKzsgLy8gbWFrZSBzdXJlIHdlJ3JlIHB1bGxpbmcgdGhlIG5vbi1jYWNoZWQgdmFsdWVcbiAgICAgIC8vIGFsdGVybmF0ZSBhbGdvcml0aG06IGR1clggPSBNYXRoLm1pbig2LCBNYXRoLmFicyhzZWxmLnZlbG9jaXR5WCAvIDgwMCkpLFx0ZHVyID0gTWF0aC5tYXgoZHVyWCwgTWF0aC5taW4oNiwgTWF0aC5hYnMoc2VsZi52ZWxvY2l0eVkgLyA4MDApKSk7IGR1ciA9IGR1ciAqICgwLjQgKyAoMSAtIF9wb3dlcjRJbihkdXIgLyA2KSkgKiAwLjYpKSAqIChtb21lbnR1bVNwZWVkIHx8IDEpXG5cbiAgICAgIHZhciBkdXIgPSByZXNvbHZlTW9tZW50dW1EdXJhdGlvbigpLFxuICAgICAgICAgIGN1cnJlbnRTY3JvbGwsXG4gICAgICAgICAgZW5kU2Nyb2xsO1xuXG4gICAgICBpZiAobm9ybWFsaXplU2Nyb2xsWCkge1xuICAgICAgICBjdXJyZW50U2Nyb2xsID0gc2Nyb2xsRnVuY1goKTtcbiAgICAgICAgZW5kU2Nyb2xsID0gY3VycmVudFNjcm9sbCArIGR1ciAqIDAuMDUgKiAtc2VsZi52ZWxvY2l0eVggLyAwLjIyNzsgLy8gdGhlIGNvbnN0YW50IC4yMjcgaXMgZnJvbSBwb3dlcjQoMC4wNSkuIHZlbG9jaXR5IGlzIGludmVydGVkIGJlY2F1c2Ugc2Nyb2xsaW5nIGdvZXMgaW4gdGhlIG9wcG9zaXRlIGRpcmVjdGlvbi5cblxuICAgICAgICBkdXIgKj0gX2NsYW1wU2Nyb2xsQW5kR2V0RHVyYXRpb25NdWx0aXBsaWVyKHNjcm9sbEZ1bmNYLCBjdXJyZW50U2Nyb2xsLCBlbmRTY3JvbGwsIF9tYXhTY3JvbGwodGFyZ2V0LCBfaG9yaXpvbnRhbCkpO1xuICAgICAgICB0d2Vlbi52YXJzLnNjcm9sbFggPSBzY3JvbGxDbGFtcFgoZW5kU2Nyb2xsKTtcbiAgICAgIH1cblxuICAgICAgY3VycmVudFNjcm9sbCA9IHNjcm9sbEZ1bmNZKCk7XG4gICAgICBlbmRTY3JvbGwgPSBjdXJyZW50U2Nyb2xsICsgZHVyICogMC4wNSAqIC1zZWxmLnZlbG9jaXR5WSAvIDAuMjI3OyAvLyB0aGUgY29uc3RhbnQgLjIyNyBpcyBmcm9tIHBvd2VyNCgwLjA1KVxuXG4gICAgICBkdXIgKj0gX2NsYW1wU2Nyb2xsQW5kR2V0RHVyYXRpb25NdWx0aXBsaWVyKHNjcm9sbEZ1bmNZLCBjdXJyZW50U2Nyb2xsLCBlbmRTY3JvbGwsIF9tYXhTY3JvbGwodGFyZ2V0LCBfdmVydGljYWwpKTtcbiAgICAgIHR3ZWVuLnZhcnMuc2Nyb2xsWSA9IHNjcm9sbENsYW1wWShlbmRTY3JvbGwpO1xuICAgICAgdHdlZW4uaW52YWxpZGF0ZSgpLmR1cmF0aW9uKGR1cikucGxheSgwLjAxKTtcblxuICAgICAgaWYgKF9maXhJT1NCdWcgJiYgdHdlZW4udmFycy5zY3JvbGxZID49IG1heFkgfHwgY3VycmVudFNjcm9sbCA+PSBtYXhZIC0gMSkge1xuICAgICAgICAvLyBpT1MgYnVnOiBpdCdsbCBzaG93IHRoZSBhZGRyZXNzIGJhciBidXQgTk9UIGZpcmUgdGhlIHdpbmRvdyBcInJlc2l6ZVwiIGV2ZW50IHVudGlsIHRoZSBhbmltYXRpb24gaXMgZG9uZSBidXQgd2UgbXVzdCBwcm90ZWN0IGFnYWluc3Qgb3ZlcnNob290IHNvIHdlIGxldmVyYWdlIGFuIG9uVXBkYXRlIHRvIGRvIHNvLlxuICAgICAgICBnc2FwLnRvKHt9LCB7XG4gICAgICAgICAgb25VcGRhdGU6IG9uUmVzaXplLFxuICAgICAgICAgIGR1cmF0aW9uOiBkdXJcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIHZhcnMub25XaGVlbCA9IGZ1bmN0aW9uICgpIHtcbiAgICB0d2Vlbi5fdHMgJiYgdHdlZW4ucGF1c2UoKTtcblxuICAgIGlmIChfZ2V0VGltZSgpIC0gd2hlZWxSZWZyZXNoID4gMTAwMCkge1xuICAgICAgLy8gYWZ0ZXIgMSBzZWNvbmQsIHJlZnJlc2ggdGhlIGNsYW1wcyBvdGhlcndpc2UgdGhhdCdsbCBvbmx5IGhhcHBlbiB3aGVuIFNjcm9sbFRyaWdnZXIucmVmcmVzaCgpIGlzIGNhbGxlZCBvciBmb3IgdG91Y2gtc2Nyb2xsaW5nLlxuICAgICAgbGFzdFJlZnJlc2hJRCA9IDA7XG4gICAgICB3aGVlbFJlZnJlc2ggPSBfZ2V0VGltZSgpO1xuICAgIH1cbiAgfTtcblxuICB2YXJzLm9uQ2hhbmdlID0gZnVuY3Rpb24gKHNlbGYsIGR4LCBkeSwgeEFycmF5LCB5QXJyYXkpIHtcbiAgICBfcmVmcmVzaElEICE9PSBsYXN0UmVmcmVzaElEICYmIHVwZGF0ZUNsYW1wcygpO1xuICAgIGR4ICYmIG5vcm1hbGl6ZVNjcm9sbFggJiYgc2Nyb2xsRnVuY1goc2Nyb2xsQ2xhbXBYKHhBcnJheVsyXSA9PT0gZHggPyBzdGFydFNjcm9sbFggKyAoc2VsZi5zdGFydFggLSBzZWxmLngpIDogc2Nyb2xsRnVuY1goKSArIGR4IC0geEFycmF5WzFdKSk7IC8vIGZvciBtb3JlIHByZWNpc2lvbiwgd2UgdHJhY2sgcG9pbnRlci90b3VjaCBtb3ZlbWVudCBmcm9tIHRoZSBzdGFydCwgb3RoZXJ3aXNlIGl0J2xsIGRyaWZ0LlxuXG4gICAgZHkgJiYgc2Nyb2xsRnVuY1koc2Nyb2xsQ2xhbXBZKHlBcnJheVsyXSA9PT0gZHkgPyBzdGFydFNjcm9sbFkgKyAoc2VsZi5zdGFydFkgLSBzZWxmLnkpIDogc2Nyb2xsRnVuY1koKSArIGR5IC0geUFycmF5WzFdKSk7XG5cbiAgICBfdXBkYXRlQWxsKCk7XG4gIH07XG5cbiAgdmFycy5vbkVuYWJsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBfYWxsb3dOYXRpdmVQYW5uaW5nKHRhcmdldCwgbm9ybWFsaXplU2Nyb2xsWCA/IGZhbHNlIDogXCJ4XCIpO1xuXG4gICAgX2FkZExpc3RlbmVyKF93aW4sIFwicmVzaXplXCIsIG9uUmVzaXplKTtcblxuICAgIGlucHV0T2JzZXJ2ZXIuZW5hYmxlKCk7XG4gIH07XG5cbiAgdmFycy5vbkRpc2FibGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgX2FsbG93TmF0aXZlUGFubmluZyh0YXJnZXQsIHRydWUpO1xuXG4gICAgX3JlbW92ZUxpc3RlbmVyKF93aW4sIFwicmVzaXplXCIsIG9uUmVzaXplKTtcblxuICAgIGlucHV0T2JzZXJ2ZXIua2lsbCgpO1xuICB9O1xuXG4gIHNlbGYgPSBuZXcgT2JzZXJ2ZXIodmFycyk7XG4gIHNlbGYuaU9TID0gX2ZpeElPU0J1ZzsgLy8gdXNlZCBpbiB0aGUgT2JzZXJ2ZXIgZ2V0Q2FjaGVkU2Nyb2xsKCkgZnVuY3Rpb24gdG8gd29yayBhcm91bmQgYW4gaU9TIGJ1ZyB0aGF0IHdyZWFrcyBoYXZvYyB3aXRoIFRvdWNoRXZlbnQuY2xpZW50WSBpZiB3ZSBhbGxvdyBzY3JvbGwgdG8gZ28gYWxsIHRoZSB3YXkgYmFjayB0byAwLlxuXG4gIF9maXhJT1NCdWcgJiYgIXNjcm9sbEZ1bmNZKCkgJiYgc2Nyb2xsRnVuY1koMSk7IC8vIGlPUyBidWcgY2F1c2VzIGV2ZW50LmNsaWVudFkgdmFsdWVzIHRvIGZyZWFrIG91dCAod2lsZGx5IGluYWNjdXJhdGUpIGlmIHRoZSBzY3JvbGwgcG9zaXRpb24gaXMgZXhhY3RseSAwLlxuXG4gIG9uU3RvcERlbGF5ZWRDYWxsID0gc2VsZi5fZGM7XG4gIHR3ZWVuID0gZ3NhcC50byhzZWxmLCB7XG4gICAgZWFzZTogXCJwb3dlcjRcIixcbiAgICBwYXVzZWQ6IHRydWUsXG4gICAgc2Nyb2xsWDogbm9ybWFsaXplU2Nyb2xsWCA/IFwiKz0wLjFcIiA6IFwiKz0wXCIsXG4gICAgc2Nyb2xsWTogXCIrPTAuMVwiLFxuICAgIG9uQ29tcGxldGU6IG9uU3RvcERlbGF5ZWRDYWxsLnZhcnMub25Db21wbGV0ZVxuICB9KTtcbiAgcmV0dXJuIHNlbGY7XG59O1xuXG5TY3JvbGxUcmlnZ2VyLnNvcnQgPSBmdW5jdGlvbiAoZnVuYykge1xuICByZXR1cm4gX3RyaWdnZXJzLnNvcnQoZnVuYyB8fCBmdW5jdGlvbiAoYSwgYikge1xuICAgIHJldHVybiAoYS52YXJzLnJlZnJlc2hQcmlvcml0eSB8fCAwKSAqIC0xZTYgKyBhLnN0YXJ0IC0gKGIuc3RhcnQgKyAoYi52YXJzLnJlZnJlc2hQcmlvcml0eSB8fCAwKSAqIC0xZTYpO1xuICB9KTtcbn07XG5cblNjcm9sbFRyaWdnZXIub2JzZXJ2ZSA9IGZ1bmN0aW9uICh2YXJzKSB7XG4gIHJldHVybiBuZXcgT2JzZXJ2ZXIodmFycyk7XG59O1xuXG5TY3JvbGxUcmlnZ2VyLm5vcm1hbGl6ZVNjcm9sbCA9IGZ1bmN0aW9uICh2YXJzKSB7XG4gIGlmICh0eXBlb2YgdmFycyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHJldHVybiBfbm9ybWFsaXplcjtcbiAgfVxuXG4gIGlmICh2YXJzID09PSB0cnVlICYmIF9ub3JtYWxpemVyKSB7XG4gICAgcmV0dXJuIF9ub3JtYWxpemVyLmVuYWJsZSgpO1xuICB9XG5cbiAgaWYgKHZhcnMgPT09IGZhbHNlKSB7XG4gICAgcmV0dXJuIF9ub3JtYWxpemVyICYmIF9ub3JtYWxpemVyLmtpbGwoKTtcbiAgfVxuXG4gIHZhciBub3JtYWxpemVyID0gdmFycyBpbnN0YW5jZW9mIE9ic2VydmVyID8gdmFycyA6IF9nZXRTY3JvbGxOb3JtYWxpemVyKHZhcnMpO1xuICBfbm9ybWFsaXplciAmJiBfbm9ybWFsaXplci50YXJnZXQgPT09IG5vcm1hbGl6ZXIudGFyZ2V0ICYmIF9ub3JtYWxpemVyLmtpbGwoKTtcbiAgX2lzVmlld3BvcnQobm9ybWFsaXplci50YXJnZXQpICYmIChfbm9ybWFsaXplciA9IG5vcm1hbGl6ZXIpO1xuICByZXR1cm4gbm9ybWFsaXplcjtcbn07XG5cblNjcm9sbFRyaWdnZXIuY29yZSA9IHtcbiAgLy8gc21hbGxlciBmaWxlIHNpemUgd2F5IHRvIGxldmVyYWdlIGluIFNjcm9sbFNtb290aGVyIGFuZCBPYnNlcnZlclxuICBfZ2V0VmVsb2NpdHlQcm9wOiBfZ2V0VmVsb2NpdHlQcm9wLFxuICBfaW5wdXRPYnNlcnZlcjogX2lucHV0T2JzZXJ2ZXIsXG4gIF9zY3JvbGxlcnM6IF9zY3JvbGxlcnMsXG4gIF9wcm94aWVzOiBfcHJveGllcyxcbiAgYnJpZGdlOiB7XG4gICAgLy8gd2hlbiBub3JtYWxpemVTY3JvbGwgc2V0cyB0aGUgc2Nyb2xsIHBvc2l0aW9uIChzcyA9IHNldFNjcm9sbClcbiAgICBzczogZnVuY3Rpb24gc3MoKSB7XG4gICAgICBfbGFzdFNjcm9sbFRpbWUgfHwgX2Rpc3BhdGNoKFwic2Nyb2xsU3RhcnRcIik7XG4gICAgICBfbGFzdFNjcm9sbFRpbWUgPSBfZ2V0VGltZSgpO1xuICAgIH0sXG4gICAgLy8gYSB3YXkgdG8gZ2V0IHRoZSBfcmVmcmVzaGluZyB2YWx1ZSBpbiBPYnNlcnZlclxuICAgIHJlZjogZnVuY3Rpb24gcmVmKCkge1xuICAgICAgcmV0dXJuIF9yZWZyZXNoaW5nO1xuICAgIH1cbiAgfVxufTtcbl9nZXRHU0FQKCkgJiYgZ3NhcC5yZWdpc3RlclBsdWdpbihTY3JvbGxUcmlnZ2VyKTtcbmV4cG9ydCB7IFNjcm9sbFRyaWdnZXIgYXMgZGVmYXVsdCB9OyIsImZ1bmN0aW9uIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZikgeyBpZiAoc2VsZiA9PT0gdm9pZCAwKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gc2VsZjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHNMb29zZShzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MucHJvdG90eXBlKTsgc3ViQ2xhc3MucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gc3ViQ2xhc3M7IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxuLyohXG4gKiBHU0FQIDMuMTAuNFxuICogaHR0cHM6Ly9ncmVlbnNvY2suY29tXG4gKlxuICogQGxpY2Vuc2UgQ29weXJpZ2h0IDIwMDgtMjAyMiwgR3JlZW5Tb2NrLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogU3ViamVjdCB0byB0aGUgdGVybXMgYXQgaHR0cHM6Ly9ncmVlbnNvY2suY29tL3N0YW5kYXJkLWxpY2Vuc2Ugb3IgZm9yXG4gKiBDbHViIEdyZWVuU29jayBtZW1iZXJzLCB0aGUgYWdyZWVtZW50IGlzc3VlZCB3aXRoIHRoYXQgbWVtYmVyc2hpcC5cbiAqIEBhdXRob3I6IEphY2sgRG95bGUsIGphY2tAZ3JlZW5zb2NrLmNvbVxuKi9cblxuLyogZXNsaW50LWRpc2FibGUgKi9cbnZhciBfY29uZmlnID0ge1xuICBhdXRvU2xlZXA6IDEyMCxcbiAgZm9yY2UzRDogXCJhdXRvXCIsXG4gIG51bGxUYXJnZXRXYXJuOiAxLFxuICB1bml0czoge1xuICAgIGxpbmVIZWlnaHQ6IFwiXCJcbiAgfVxufSxcbiAgICBfZGVmYXVsdHMgPSB7XG4gIGR1cmF0aW9uOiAuNSxcbiAgb3ZlcndyaXRlOiBmYWxzZSxcbiAgZGVsYXk6IDBcbn0sXG4gICAgX3N1cHByZXNzT3ZlcndyaXRlcyxcbiAgICBfYmlnTnVtID0gMWU4LFxuICAgIF90aW55TnVtID0gMSAvIF9iaWdOdW0sXG4gICAgXzJQSSA9IE1hdGguUEkgKiAyLFxuICAgIF9IQUxGX1BJID0gXzJQSSAvIDQsXG4gICAgX2dzSUQgPSAwLFxuICAgIF9zcXJ0ID0gTWF0aC5zcXJ0LFxuICAgIF9jb3MgPSBNYXRoLmNvcyxcbiAgICBfc2luID0gTWF0aC5zaW4sXG4gICAgX2lzU3RyaW5nID0gZnVuY3Rpb24gX2lzU3RyaW5nKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCI7XG59LFxuICAgIF9pc0Z1bmN0aW9uID0gZnVuY3Rpb24gX2lzRnVuY3Rpb24odmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gXCJmdW5jdGlvblwiO1xufSxcbiAgICBfaXNOdW1iZXIgPSBmdW5jdGlvbiBfaXNOdW1iZXIodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gXCJudW1iZXJcIjtcbn0sXG4gICAgX2lzVW5kZWZpbmVkID0gZnVuY3Rpb24gX2lzVW5kZWZpbmVkKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09IFwidW5kZWZpbmVkXCI7XG59LFxuICAgIF9pc09iamVjdCA9IGZ1bmN0aW9uIF9pc09iamVjdCh2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiO1xufSxcbiAgICBfaXNOb3RGYWxzZSA9IGZ1bmN0aW9uIF9pc05vdEZhbHNlKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSAhPT0gZmFsc2U7XG59LFxuICAgIF93aW5kb3dFeGlzdHMgPSBmdW5jdGlvbiBfd2luZG93RXhpc3RzKCkge1xuICByZXR1cm4gdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIjtcbn0sXG4gICAgX2lzRnVuY09yU3RyaW5nID0gZnVuY3Rpb24gX2lzRnVuY09yU3RyaW5nKHZhbHVlKSB7XG4gIHJldHVybiBfaXNGdW5jdGlvbih2YWx1ZSkgfHwgX2lzU3RyaW5nKHZhbHVlKTtcbn0sXG4gICAgX2lzVHlwZWRBcnJheSA9IHR5cGVvZiBBcnJheUJ1ZmZlciA9PT0gXCJmdW5jdGlvblwiICYmIEFycmF5QnVmZmVyLmlzVmlldyB8fCBmdW5jdGlvbiAoKSB7fSxcbiAgICAvLyBub3RlOiBJRTEwIGhhcyBBcnJheUJ1ZmZlciwgYnV0IE5PVCBBcnJheUJ1ZmZlci5pc1ZpZXcoKS5cbl9pc0FycmF5ID0gQXJyYXkuaXNBcnJheSxcbiAgICBfc3RyaWN0TnVtRXhwID0gLyg/Oi0/XFwuP1xcZHxcXC4pKy9naSxcbiAgICAvL29ubHkgbnVtYmVycyAoaW5jbHVkaW5nIG5lZ2F0aXZlcyBhbmQgZGVjaW1hbHMpIGJ1dCBOT1QgcmVsYXRpdmUgdmFsdWVzLlxuX251bUV4cCA9IC9bLSs9Ll0qXFxkK1suZVxcLStdKlxcZCpbZVxcLStdKlxcZCovZyxcbiAgICAvL2ZpbmRzIGFueSBudW1iZXJzLCBpbmNsdWRpbmcgb25lcyB0aGF0IHN0YXJ0IHdpdGggKz0gb3IgLT0sIG5lZ2F0aXZlIG51bWJlcnMsIGFuZCBvbmVzIGluIHNjaWVudGlmaWMgbm90YXRpb24gbGlrZSAxZS04LlxuX251bVdpdGhVbml0RXhwID0gL1stKz0uXSpcXGQrWy5lLV0qXFxkKlthLXolXSovZyxcbiAgICBfY29tcGxleFN0cmluZ051bUV4cCA9IC9bLSs9Ll0qXFxkK1xcLj9cXGQqKD86ZS18ZVxcKyk/XFxkKi9naSxcbiAgICAvL2R1cGxpY2F0ZSBzbyB0aGF0IHdoaWxlIHdlJ3JlIGxvb3BpbmcgdGhyb3VnaCBtYXRjaGVzIGZyb20gZXhlYygpLCBpdCBkb2Vzbid0IGNvbnRhbWluYXRlIHRoZSBsYXN0SW5kZXggb2YgX251bUV4cCB3aGljaCB3ZSB1c2UgdG8gc2VhcmNoIGZvciBjb2xvcnMgdG9vLlxuX3JlbEV4cCA9IC9bKy1dPS0/Wy5cXGRdKy8sXG4gICAgX2RlbGltaXRlZFZhbHVlRXhwID0gL1teLCdcIlxcW1xcXVxcc10rL2dpLFxuICAgIC8vIHByZXZpb3VzbHkgL1sjXFwtKy5dKlxcYlthLXpcXGRcXC09KyUuXSsvZ2kgYnV0IGRpZG4ndCBjYXRjaCBzcGVjaWFsIGNoYXJhY3RlcnMuXG5fdW5pdEV4cCA9IC9eWytcXC09ZVxcc1xcZF0qXFxkK1suXFxkXSooW2Etel0qfCUpXFxzKiQvaSxcbiAgICBfZ2xvYmFsVGltZWxpbmUsXG4gICAgX3dpbixcbiAgICBfY29yZUluaXR0ZWQsXG4gICAgX2RvYyxcbiAgICBfZ2xvYmFscyA9IHt9LFxuICAgIF9pbnN0YWxsU2NvcGUgPSB7fSxcbiAgICBfY29yZVJlYWR5LFxuICAgIF9pbnN0YWxsID0gZnVuY3Rpb24gX2luc3RhbGwoc2NvcGUpIHtcbiAgcmV0dXJuIChfaW5zdGFsbFNjb3BlID0gX21lcmdlKHNjb3BlLCBfZ2xvYmFscykpICYmIGdzYXA7XG59LFxuICAgIF9taXNzaW5nUGx1Z2luID0gZnVuY3Rpb24gX21pc3NpbmdQbHVnaW4ocHJvcGVydHksIHZhbHVlKSB7XG4gIHJldHVybiBjb25zb2xlLndhcm4oXCJJbnZhbGlkIHByb3BlcnR5XCIsIHByb3BlcnR5LCBcInNldCB0b1wiLCB2YWx1ZSwgXCJNaXNzaW5nIHBsdWdpbj8gZ3NhcC5yZWdpc3RlclBsdWdpbigpXCIpO1xufSxcbiAgICBfd2FybiA9IGZ1bmN0aW9uIF93YXJuKG1lc3NhZ2UsIHN1cHByZXNzKSB7XG4gIHJldHVybiAhc3VwcHJlc3MgJiYgY29uc29sZS53YXJuKG1lc3NhZ2UpO1xufSxcbiAgICBfYWRkR2xvYmFsID0gZnVuY3Rpb24gX2FkZEdsb2JhbChuYW1lLCBvYmopIHtcbiAgcmV0dXJuIG5hbWUgJiYgKF9nbG9iYWxzW25hbWVdID0gb2JqKSAmJiBfaW5zdGFsbFNjb3BlICYmIChfaW5zdGFsbFNjb3BlW25hbWVdID0gb2JqKSB8fCBfZ2xvYmFscztcbn0sXG4gICAgX2VtcHR5RnVuYyA9IGZ1bmN0aW9uIF9lbXB0eUZ1bmMoKSB7XG4gIHJldHVybiAwO1xufSxcbiAgICBfcmVzZXJ2ZWRQcm9wcyA9IHt9LFxuICAgIF9sYXp5VHdlZW5zID0gW10sXG4gICAgX2xhenlMb29rdXAgPSB7fSxcbiAgICBfbGFzdFJlbmRlcmVkRnJhbWUsXG4gICAgX3BsdWdpbnMgPSB7fSxcbiAgICBfZWZmZWN0cyA9IHt9LFxuICAgIF9uZXh0R0NGcmFtZSA9IDMwLFxuICAgIF9oYXJuZXNzUGx1Z2lucyA9IFtdLFxuICAgIF9jYWxsYmFja05hbWVzID0gXCJcIixcbiAgICBfaGFybmVzcyA9IGZ1bmN0aW9uIF9oYXJuZXNzKHRhcmdldHMpIHtcbiAgdmFyIHRhcmdldCA9IHRhcmdldHNbMF0sXG4gICAgICBoYXJuZXNzUGx1Z2luLFxuICAgICAgaTtcbiAgX2lzT2JqZWN0KHRhcmdldCkgfHwgX2lzRnVuY3Rpb24odGFyZ2V0KSB8fCAodGFyZ2V0cyA9IFt0YXJnZXRzXSk7XG5cbiAgaWYgKCEoaGFybmVzc1BsdWdpbiA9ICh0YXJnZXQuX2dzYXAgfHwge30pLmhhcm5lc3MpKSB7XG4gICAgLy8gZmluZCB0aGUgZmlyc3QgdGFyZ2V0IHdpdGggYSBoYXJuZXNzLiBXZSBhc3N1bWUgdGFyZ2V0cyBwYXNzZWQgaW50byBhbiBhbmltYXRpb24gd2lsbCBiZSBvZiBzaW1pbGFyIHR5cGUsIG1lYW5pbmcgdGhlIHNhbWUga2luZCBvZiBoYXJuZXNzIGNhbiBiZSB1c2VkIGZvciB0aGVtIGFsbCAocGVyZm9ybWFuY2Ugb3B0aW1pemF0aW9uKVxuICAgIGkgPSBfaGFybmVzc1BsdWdpbnMubGVuZ3RoO1xuXG4gICAgd2hpbGUgKGktLSAmJiAhX2hhcm5lc3NQbHVnaW5zW2ldLnRhcmdldFRlc3QodGFyZ2V0KSkge31cblxuICAgIGhhcm5lc3NQbHVnaW4gPSBfaGFybmVzc1BsdWdpbnNbaV07XG4gIH1cblxuICBpID0gdGFyZ2V0cy5sZW5ndGg7XG5cbiAgd2hpbGUgKGktLSkge1xuICAgIHRhcmdldHNbaV0gJiYgKHRhcmdldHNbaV0uX2dzYXAgfHwgKHRhcmdldHNbaV0uX2dzYXAgPSBuZXcgR1NDYWNoZSh0YXJnZXRzW2ldLCBoYXJuZXNzUGx1Z2luKSkpIHx8IHRhcmdldHMuc3BsaWNlKGksIDEpO1xuICB9XG5cbiAgcmV0dXJuIHRhcmdldHM7XG59LFxuICAgIF9nZXRDYWNoZSA9IGZ1bmN0aW9uIF9nZXRDYWNoZSh0YXJnZXQpIHtcbiAgcmV0dXJuIHRhcmdldC5fZ3NhcCB8fCBfaGFybmVzcyh0b0FycmF5KHRhcmdldCkpWzBdLl9nc2FwO1xufSxcbiAgICBfZ2V0UHJvcGVydHkgPSBmdW5jdGlvbiBfZ2V0UHJvcGVydHkodGFyZ2V0LCBwcm9wZXJ0eSwgdikge1xuICByZXR1cm4gKHYgPSB0YXJnZXRbcHJvcGVydHldKSAmJiBfaXNGdW5jdGlvbih2KSA/IHRhcmdldFtwcm9wZXJ0eV0oKSA6IF9pc1VuZGVmaW5lZCh2KSAmJiB0YXJnZXQuZ2V0QXR0cmlidXRlICYmIHRhcmdldC5nZXRBdHRyaWJ1dGUocHJvcGVydHkpIHx8IHY7XG59LFxuICAgIF9mb3JFYWNoTmFtZSA9IGZ1bmN0aW9uIF9mb3JFYWNoTmFtZShuYW1lcywgZnVuYykge1xuICByZXR1cm4gKG5hbWVzID0gbmFtZXMuc3BsaXQoXCIsXCIpKS5mb3JFYWNoKGZ1bmMpIHx8IG5hbWVzO1xufSxcbiAgICAvL3NwbGl0IGEgY29tbWEtZGVsaW1pdGVkIGxpc3Qgb2YgbmFtZXMgaW50byBhbiBhcnJheSwgdGhlbiBydW4gYSBmb3JFYWNoKCkgZnVuY3Rpb24gYW5kIHJldHVybiB0aGUgc3BsaXQgYXJyYXkgKHRoaXMgaXMganVzdCBhIHdheSB0byBjb25zb2xpZGF0ZS9zaG9ydGVuIHNvbWUgY29kZSkuXG5fcm91bmQgPSBmdW5jdGlvbiBfcm91bmQodmFsdWUpIHtcbiAgcmV0dXJuIE1hdGgucm91bmQodmFsdWUgKiAxMDAwMDApIC8gMTAwMDAwIHx8IDA7XG59LFxuICAgIF9yb3VuZFByZWNpc2UgPSBmdW5jdGlvbiBfcm91bmRQcmVjaXNlKHZhbHVlKSB7XG4gIHJldHVybiBNYXRoLnJvdW5kKHZhbHVlICogMTAwMDAwMDApIC8gMTAwMDAwMDAgfHwgMDtcbn0sXG4gICAgLy8gaW5jcmVhc2VkIHByZWNpc2lvbiBtb3N0bHkgZm9yIHRpbWluZyB2YWx1ZXMuXG5fcGFyc2VSZWxhdGl2ZSA9IGZ1bmN0aW9uIF9wYXJzZVJlbGF0aXZlKHN0YXJ0LCB2YWx1ZSkge1xuICB2YXIgb3BlcmF0b3IgPSB2YWx1ZS5jaGFyQXQoMCksXG4gICAgICBlbmQgPSBwYXJzZUZsb2F0KHZhbHVlLnN1YnN0cigyKSk7XG4gIHN0YXJ0ID0gcGFyc2VGbG9hdChzdGFydCk7XG4gIHJldHVybiBvcGVyYXRvciA9PT0gXCIrXCIgPyBzdGFydCArIGVuZCA6IG9wZXJhdG9yID09PSBcIi1cIiA/IHN0YXJ0IC0gZW5kIDogb3BlcmF0b3IgPT09IFwiKlwiID8gc3RhcnQgKiBlbmQgOiBzdGFydCAvIGVuZDtcbn0sXG4gICAgX2FycmF5Q29udGFpbnNBbnkgPSBmdW5jdGlvbiBfYXJyYXlDb250YWluc0FueSh0b1NlYXJjaCwgdG9GaW5kKSB7XG4gIC8vc2VhcmNoZXMgb25lIGFycmF5IHRvIGZpbmQgbWF0Y2hlcyBmb3IgYW55IG9mIHRoZSBpdGVtcyBpbiB0aGUgdG9GaW5kIGFycmF5LiBBcyBzb29uIGFzIG9uZSBpcyBmb3VuZCwgaXQgcmV0dXJucyB0cnVlLiBJdCBkb2VzIE5PVCByZXR1cm4gYWxsIHRoZSBtYXRjaGVzOyBpdCdzIHNpbXBseSBhIGJvb2xlYW4gc2VhcmNoLlxuICB2YXIgbCA9IHRvRmluZC5sZW5ndGgsXG4gICAgICBpID0gMDtcblxuICBmb3IgKDsgdG9TZWFyY2guaW5kZXhPZih0b0ZpbmRbaV0pIDwgMCAmJiArK2kgPCBsOykge31cblxuICByZXR1cm4gaSA8IGw7XG59LFxuICAgIF9sYXp5UmVuZGVyID0gZnVuY3Rpb24gX2xhenlSZW5kZXIoKSB7XG4gIHZhciBsID0gX2xhenlUd2VlbnMubGVuZ3RoLFxuICAgICAgYSA9IF9sYXp5VHdlZW5zLnNsaWNlKDApLFxuICAgICAgaSxcbiAgICAgIHR3ZWVuO1xuXG4gIF9sYXp5TG9va3VwID0ge307XG4gIF9sYXp5VHdlZW5zLmxlbmd0aCA9IDA7XG5cbiAgZm9yIChpID0gMDsgaSA8IGw7IGkrKykge1xuICAgIHR3ZWVuID0gYVtpXTtcbiAgICB0d2VlbiAmJiB0d2Vlbi5fbGF6eSAmJiAodHdlZW4ucmVuZGVyKHR3ZWVuLl9sYXp5WzBdLCB0d2Vlbi5fbGF6eVsxXSwgdHJ1ZSkuX2xhenkgPSAwKTtcbiAgfVxufSxcbiAgICBfbGF6eVNhZmVSZW5kZXIgPSBmdW5jdGlvbiBfbGF6eVNhZmVSZW5kZXIoYW5pbWF0aW9uLCB0aW1lLCBzdXBwcmVzc0V2ZW50cywgZm9yY2UpIHtcbiAgX2xhenlUd2VlbnMubGVuZ3RoICYmIF9sYXp5UmVuZGVyKCk7XG4gIGFuaW1hdGlvbi5yZW5kZXIodGltZSwgc3VwcHJlc3NFdmVudHMsIGZvcmNlKTtcbiAgX2xhenlUd2VlbnMubGVuZ3RoICYmIF9sYXp5UmVuZGVyKCk7IC8vaW4gY2FzZSByZW5kZXJpbmcgY2F1c2VkIGFueSB0d2VlbnMgdG8gbGF6eS1pbml0LCB3ZSBzaG91bGQgcmVuZGVyIHRoZW0gYmVjYXVzZSB0eXBpY2FsbHkgd2hlbiBzb21lb25lIGNhbGxzIHNlZWsoKSBvciB0aW1lKCkgb3IgcHJvZ3Jlc3MoKSwgdGhleSBleHBlY3QgYW4gaW1tZWRpYXRlIHJlbmRlci5cbn0sXG4gICAgX251bWVyaWNJZlBvc3NpYmxlID0gZnVuY3Rpb24gX251bWVyaWNJZlBvc3NpYmxlKHZhbHVlKSB7XG4gIHZhciBuID0gcGFyc2VGbG9hdCh2YWx1ZSk7XG4gIHJldHVybiAobiB8fCBuID09PSAwKSAmJiAodmFsdWUgKyBcIlwiKS5tYXRjaChfZGVsaW1pdGVkVmFsdWVFeHApLmxlbmd0aCA8IDIgPyBuIDogX2lzU3RyaW5nKHZhbHVlKSA/IHZhbHVlLnRyaW0oKSA6IHZhbHVlO1xufSxcbiAgICBfcGFzc1Rocm91Z2ggPSBmdW5jdGlvbiBfcGFzc1Rocm91Z2gocCkge1xuICByZXR1cm4gcDtcbn0sXG4gICAgX3NldERlZmF1bHRzID0gZnVuY3Rpb24gX3NldERlZmF1bHRzKG9iaiwgZGVmYXVsdHMpIHtcbiAgZm9yICh2YXIgcCBpbiBkZWZhdWx0cykge1xuICAgIHAgaW4gb2JqIHx8IChvYmpbcF0gPSBkZWZhdWx0c1twXSk7XG4gIH1cblxuICByZXR1cm4gb2JqO1xufSxcbiAgICBfc2V0S2V5ZnJhbWVEZWZhdWx0cyA9IGZ1bmN0aW9uIF9zZXRLZXlmcmFtZURlZmF1bHRzKGV4Y2x1ZGVEdXJhdGlvbikge1xuICByZXR1cm4gZnVuY3Rpb24gKG9iaiwgZGVmYXVsdHMpIHtcbiAgICBmb3IgKHZhciBwIGluIGRlZmF1bHRzKSB7XG4gICAgICBwIGluIG9iaiB8fCBwID09PSBcImR1cmF0aW9uXCIgJiYgZXhjbHVkZUR1cmF0aW9uIHx8IHAgPT09IFwiZWFzZVwiIHx8IChvYmpbcF0gPSBkZWZhdWx0c1twXSk7XG4gICAgfVxuICB9O1xufSxcbiAgICBfbWVyZ2UgPSBmdW5jdGlvbiBfbWVyZ2UoYmFzZSwgdG9NZXJnZSkge1xuICBmb3IgKHZhciBwIGluIHRvTWVyZ2UpIHtcbiAgICBiYXNlW3BdID0gdG9NZXJnZVtwXTtcbiAgfVxuXG4gIHJldHVybiBiYXNlO1xufSxcbiAgICBfbWVyZ2VEZWVwID0gZnVuY3Rpb24gX21lcmdlRGVlcChiYXNlLCB0b01lcmdlKSB7XG4gIGZvciAodmFyIHAgaW4gdG9NZXJnZSkge1xuICAgIHAgIT09IFwiX19wcm90b19fXCIgJiYgcCAhPT0gXCJjb25zdHJ1Y3RvclwiICYmIHAgIT09IFwicHJvdG90eXBlXCIgJiYgKGJhc2VbcF0gPSBfaXNPYmplY3QodG9NZXJnZVtwXSkgPyBfbWVyZ2VEZWVwKGJhc2VbcF0gfHwgKGJhc2VbcF0gPSB7fSksIHRvTWVyZ2VbcF0pIDogdG9NZXJnZVtwXSk7XG4gIH1cblxuICByZXR1cm4gYmFzZTtcbn0sXG4gICAgX2NvcHlFeGNsdWRpbmcgPSBmdW5jdGlvbiBfY29weUV4Y2x1ZGluZyhvYmosIGV4Y2x1ZGluZykge1xuICB2YXIgY29weSA9IHt9LFxuICAgICAgcDtcblxuICBmb3IgKHAgaW4gb2JqKSB7XG4gICAgcCBpbiBleGNsdWRpbmcgfHwgKGNvcHlbcF0gPSBvYmpbcF0pO1xuICB9XG5cbiAgcmV0dXJuIGNvcHk7XG59LFxuICAgIF9pbmhlcml0RGVmYXVsdHMgPSBmdW5jdGlvbiBfaW5oZXJpdERlZmF1bHRzKHZhcnMpIHtcbiAgdmFyIHBhcmVudCA9IHZhcnMucGFyZW50IHx8IF9nbG9iYWxUaW1lbGluZSxcbiAgICAgIGZ1bmMgPSB2YXJzLmtleWZyYW1lcyA/IF9zZXRLZXlmcmFtZURlZmF1bHRzKF9pc0FycmF5KHZhcnMua2V5ZnJhbWVzKSkgOiBfc2V0RGVmYXVsdHM7XG5cbiAgaWYgKF9pc05vdEZhbHNlKHZhcnMuaW5oZXJpdCkpIHtcbiAgICB3aGlsZSAocGFyZW50KSB7XG4gICAgICBmdW5jKHZhcnMsIHBhcmVudC52YXJzLmRlZmF1bHRzKTtcbiAgICAgIHBhcmVudCA9IHBhcmVudC5wYXJlbnQgfHwgcGFyZW50Ll9kcDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdmFycztcbn0sXG4gICAgX2FycmF5c01hdGNoID0gZnVuY3Rpb24gX2FycmF5c01hdGNoKGExLCBhMikge1xuICB2YXIgaSA9IGExLmxlbmd0aCxcbiAgICAgIG1hdGNoID0gaSA9PT0gYTIubGVuZ3RoO1xuXG4gIHdoaWxlIChtYXRjaCAmJiBpLS0gJiYgYTFbaV0gPT09IGEyW2ldKSB7fVxuXG4gIHJldHVybiBpIDwgMDtcbn0sXG4gICAgX2FkZExpbmtlZExpc3RJdGVtID0gZnVuY3Rpb24gX2FkZExpbmtlZExpc3RJdGVtKHBhcmVudCwgY2hpbGQsIGZpcnN0UHJvcCwgbGFzdFByb3AsIHNvcnRCeSkge1xuICBpZiAoZmlyc3RQcm9wID09PSB2b2lkIDApIHtcbiAgICBmaXJzdFByb3AgPSBcIl9maXJzdFwiO1xuICB9XG5cbiAgaWYgKGxhc3RQcm9wID09PSB2b2lkIDApIHtcbiAgICBsYXN0UHJvcCA9IFwiX2xhc3RcIjtcbiAgfVxuXG4gIHZhciBwcmV2ID0gcGFyZW50W2xhc3RQcm9wXSxcbiAgICAgIHQ7XG5cbiAgaWYgKHNvcnRCeSkge1xuICAgIHQgPSBjaGlsZFtzb3J0QnldO1xuXG4gICAgd2hpbGUgKHByZXYgJiYgcHJldltzb3J0QnldID4gdCkge1xuICAgICAgcHJldiA9IHByZXYuX3ByZXY7XG4gICAgfVxuICB9XG5cbiAgaWYgKHByZXYpIHtcbiAgICBjaGlsZC5fbmV4dCA9IHByZXYuX25leHQ7XG4gICAgcHJldi5fbmV4dCA9IGNoaWxkO1xuICB9IGVsc2Uge1xuICAgIGNoaWxkLl9uZXh0ID0gcGFyZW50W2ZpcnN0UHJvcF07XG4gICAgcGFyZW50W2ZpcnN0UHJvcF0gPSBjaGlsZDtcbiAgfVxuXG4gIGlmIChjaGlsZC5fbmV4dCkge1xuICAgIGNoaWxkLl9uZXh0Ll9wcmV2ID0gY2hpbGQ7XG4gIH0gZWxzZSB7XG4gICAgcGFyZW50W2xhc3RQcm9wXSA9IGNoaWxkO1xuICB9XG5cbiAgY2hpbGQuX3ByZXYgPSBwcmV2O1xuICBjaGlsZC5wYXJlbnQgPSBjaGlsZC5fZHAgPSBwYXJlbnQ7XG4gIHJldHVybiBjaGlsZDtcbn0sXG4gICAgX3JlbW92ZUxpbmtlZExpc3RJdGVtID0gZnVuY3Rpb24gX3JlbW92ZUxpbmtlZExpc3RJdGVtKHBhcmVudCwgY2hpbGQsIGZpcnN0UHJvcCwgbGFzdFByb3ApIHtcbiAgaWYgKGZpcnN0UHJvcCA9PT0gdm9pZCAwKSB7XG4gICAgZmlyc3RQcm9wID0gXCJfZmlyc3RcIjtcbiAgfVxuXG4gIGlmIChsYXN0UHJvcCA9PT0gdm9pZCAwKSB7XG4gICAgbGFzdFByb3AgPSBcIl9sYXN0XCI7XG4gIH1cblxuICB2YXIgcHJldiA9IGNoaWxkLl9wcmV2LFxuICAgICAgbmV4dCA9IGNoaWxkLl9uZXh0O1xuXG4gIGlmIChwcmV2KSB7XG4gICAgcHJldi5fbmV4dCA9IG5leHQ7XG4gIH0gZWxzZSBpZiAocGFyZW50W2ZpcnN0UHJvcF0gPT09IGNoaWxkKSB7XG4gICAgcGFyZW50W2ZpcnN0UHJvcF0gPSBuZXh0O1xuICB9XG5cbiAgaWYgKG5leHQpIHtcbiAgICBuZXh0Ll9wcmV2ID0gcHJldjtcbiAgfSBlbHNlIGlmIChwYXJlbnRbbGFzdFByb3BdID09PSBjaGlsZCkge1xuICAgIHBhcmVudFtsYXN0UHJvcF0gPSBwcmV2O1xuICB9XG5cbiAgY2hpbGQuX25leHQgPSBjaGlsZC5fcHJldiA9IGNoaWxkLnBhcmVudCA9IG51bGw7IC8vIGRvbid0IGRlbGV0ZSB0aGUgX2RwIGp1c3Qgc28gd2UgY2FuIHJldmVydCBpZiBuZWNlc3NhcnkuIEJ1dCBwYXJlbnQgc2hvdWxkIGJlIG51bGwgdG8gaW5kaWNhdGUgdGhlIGl0ZW0gaXNuJ3QgaW4gYSBsaW5rZWQgbGlzdC5cbn0sXG4gICAgX3JlbW92ZUZyb21QYXJlbnQgPSBmdW5jdGlvbiBfcmVtb3ZlRnJvbVBhcmVudChjaGlsZCwgb25seUlmUGFyZW50SGFzQXV0b1JlbW92ZSkge1xuICBjaGlsZC5wYXJlbnQgJiYgKCFvbmx5SWZQYXJlbnRIYXNBdXRvUmVtb3ZlIHx8IGNoaWxkLnBhcmVudC5hdXRvUmVtb3ZlQ2hpbGRyZW4pICYmIGNoaWxkLnBhcmVudC5yZW1vdmUoY2hpbGQpO1xuICBjaGlsZC5fYWN0ID0gMDtcbn0sXG4gICAgX3VuY2FjaGUgPSBmdW5jdGlvbiBfdW5jYWNoZShhbmltYXRpb24sIGNoaWxkKSB7XG4gIGlmIChhbmltYXRpb24gJiYgKCFjaGlsZCB8fCBjaGlsZC5fZW5kID4gYW5pbWF0aW9uLl9kdXIgfHwgY2hpbGQuX3N0YXJ0IDwgMCkpIHtcbiAgICAvLyBwZXJmb3JtYW5jZSBvcHRpbWl6YXRpb246IGlmIGEgY2hpbGQgYW5pbWF0aW9uIGlzIHBhc3NlZCBpbiB3ZSBzaG91bGQgb25seSB1bmNhY2hlIGlmIHRoYXQgY2hpbGQgRVhURU5EUyB0aGUgYW5pbWF0aW9uIChpdHMgZW5kIHRpbWUgaXMgYmV5b25kIHRoZSBlbmQpXG4gICAgdmFyIGEgPSBhbmltYXRpb247XG5cbiAgICB3aGlsZSAoYSkge1xuICAgICAgYS5fZGlydHkgPSAxO1xuICAgICAgYSA9IGEucGFyZW50O1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBhbmltYXRpb247XG59LFxuICAgIF9yZWNhY2hlQW5jZXN0b3JzID0gZnVuY3Rpb24gX3JlY2FjaGVBbmNlc3RvcnMoYW5pbWF0aW9uKSB7XG4gIHZhciBwYXJlbnQgPSBhbmltYXRpb24ucGFyZW50O1xuXG4gIHdoaWxlIChwYXJlbnQgJiYgcGFyZW50LnBhcmVudCkge1xuICAgIC8vc29tZXRpbWVzIHdlIG11c3QgZm9yY2UgYSByZS1zb3J0IG9mIGFsbCBjaGlsZHJlbiBhbmQgdXBkYXRlIHRoZSBkdXJhdGlvbi90b3RhbER1cmF0aW9uIG9mIGFsbCBhbmNlc3RvciB0aW1lbGluZXMgaW1tZWRpYXRlbHkgaW4gY2FzZSwgZm9yIGV4YW1wbGUsIGluIHRoZSBtaWRkbGUgb2YgYSByZW5kZXIgbG9vcCwgb25lIHR3ZWVuIGFsdGVycyBhbm90aGVyIHR3ZWVuJ3MgdGltZVNjYWxlIHdoaWNoIHNob3ZlcyBpdHMgc3RhcnRUaW1lIGJlZm9yZSAwLCBmb3JjaW5nIHRoZSBwYXJlbnQgdGltZWxpbmUgdG8gc2hpZnQgYXJvdW5kIGFuZCBzaGlmdENoaWxkcmVuKCkgd2hpY2ggY291bGQgYWZmZWN0IHRoYXQgbmV4dCB0d2VlbidzIHJlbmRlciAoc3RhcnRUaW1lKS4gRG9lc24ndCBtYXR0ZXIgZm9yIHRoZSByb290IHRpbWVsaW5lIHRob3VnaC5cbiAgICBwYXJlbnQuX2RpcnR5ID0gMTtcbiAgICBwYXJlbnQudG90YWxEdXJhdGlvbigpO1xuICAgIHBhcmVudCA9IHBhcmVudC5wYXJlbnQ7XG4gIH1cblxuICByZXR1cm4gYW5pbWF0aW9uO1xufSxcbiAgICBfaGFzTm9QYXVzZWRBbmNlc3RvcnMgPSBmdW5jdGlvbiBfaGFzTm9QYXVzZWRBbmNlc3RvcnMoYW5pbWF0aW9uKSB7XG4gIHJldHVybiAhYW5pbWF0aW9uIHx8IGFuaW1hdGlvbi5fdHMgJiYgX2hhc05vUGF1c2VkQW5jZXN0b3JzKGFuaW1hdGlvbi5wYXJlbnQpO1xufSxcbiAgICBfZWxhcHNlZEN5Y2xlRHVyYXRpb24gPSBmdW5jdGlvbiBfZWxhcHNlZEN5Y2xlRHVyYXRpb24oYW5pbWF0aW9uKSB7XG4gIHJldHVybiBhbmltYXRpb24uX3JlcGVhdCA/IF9hbmltYXRpb25DeWNsZShhbmltYXRpb24uX3RUaW1lLCBhbmltYXRpb24gPSBhbmltYXRpb24uZHVyYXRpb24oKSArIGFuaW1hdGlvbi5fckRlbGF5KSAqIGFuaW1hdGlvbiA6IDA7XG59LFxuICAgIC8vIGZlZWQgaW4gdGhlIHRvdGFsVGltZSBhbmQgY3ljbGVEdXJhdGlvbiBhbmQgaXQnbGwgcmV0dXJuIHRoZSBjeWNsZSAoaXRlcmF0aW9uIG1pbnVzIDEpIGFuZCBpZiB0aGUgcGxheWhlYWQgaXMgZXhhY3RseSBhdCB0aGUgdmVyeSBFTkQsIGl0IHdpbGwgTk9UIGJ1bXAgdXAgdG8gdGhlIG5leHQgY3ljbGUuXG5fYW5pbWF0aW9uQ3ljbGUgPSBmdW5jdGlvbiBfYW5pbWF0aW9uQ3ljbGUodFRpbWUsIGN5Y2xlRHVyYXRpb24pIHtcbiAgdmFyIHdob2xlID0gTWF0aC5mbG9vcih0VGltZSAvPSBjeWNsZUR1cmF0aW9uKTtcbiAgcmV0dXJuIHRUaW1lICYmIHdob2xlID09PSB0VGltZSA/IHdob2xlIC0gMSA6IHdob2xlO1xufSxcbiAgICBfcGFyZW50VG9DaGlsZFRvdGFsVGltZSA9IGZ1bmN0aW9uIF9wYXJlbnRUb0NoaWxkVG90YWxUaW1lKHBhcmVudFRpbWUsIGNoaWxkKSB7XG4gIHJldHVybiAocGFyZW50VGltZSAtIGNoaWxkLl9zdGFydCkgKiBjaGlsZC5fdHMgKyAoY2hpbGQuX3RzID49IDAgPyAwIDogY2hpbGQuX2RpcnR5ID8gY2hpbGQudG90YWxEdXJhdGlvbigpIDogY2hpbGQuX3REdXIpO1xufSxcbiAgICBfc2V0RW5kID0gZnVuY3Rpb24gX3NldEVuZChhbmltYXRpb24pIHtcbiAgcmV0dXJuIGFuaW1hdGlvbi5fZW5kID0gX3JvdW5kUHJlY2lzZShhbmltYXRpb24uX3N0YXJ0ICsgKGFuaW1hdGlvbi5fdER1ciAvIE1hdGguYWJzKGFuaW1hdGlvbi5fdHMgfHwgYW5pbWF0aW9uLl9ydHMgfHwgX3RpbnlOdW0pIHx8IDApKTtcbn0sXG4gICAgX2FsaWduUGxheWhlYWQgPSBmdW5jdGlvbiBfYWxpZ25QbGF5aGVhZChhbmltYXRpb24sIHRvdGFsVGltZSkge1xuICAvLyBhZGp1c3RzIHRoZSBhbmltYXRpb24ncyBfc3RhcnQgYW5kIF9lbmQgYWNjb3JkaW5nIHRvIHRoZSBwcm92aWRlZCB0b3RhbFRpbWUgKG9ubHkgaWYgdGhlIHBhcmVudCdzIHNtb290aENoaWxkVGltaW5nIGlzIHRydWUgYW5kIHRoZSBhbmltYXRpb24gaXNuJ3QgcGF1c2VkKS4gSXQgZG9lc24ndCBkbyBhbnkgcmVuZGVyaW5nIG9yIGZvcmNpbmcgdGhpbmdzIGJhY2sgaW50byBwYXJlbnQgdGltZWxpbmVzLCBldGMuIC0gdGhhdCdzIHdoYXQgdG90YWxUaW1lKCkgaXMgZm9yLlxuICB2YXIgcGFyZW50ID0gYW5pbWF0aW9uLl9kcDtcblxuICBpZiAocGFyZW50ICYmIHBhcmVudC5zbW9vdGhDaGlsZFRpbWluZyAmJiBhbmltYXRpb24uX3RzKSB7XG4gICAgYW5pbWF0aW9uLl9zdGFydCA9IF9yb3VuZFByZWNpc2UocGFyZW50Ll90aW1lIC0gKGFuaW1hdGlvbi5fdHMgPiAwID8gdG90YWxUaW1lIC8gYW5pbWF0aW9uLl90cyA6ICgoYW5pbWF0aW9uLl9kaXJ0eSA/IGFuaW1hdGlvbi50b3RhbER1cmF0aW9uKCkgOiBhbmltYXRpb24uX3REdXIpIC0gdG90YWxUaW1lKSAvIC1hbmltYXRpb24uX3RzKSk7XG5cbiAgICBfc2V0RW5kKGFuaW1hdGlvbik7XG5cbiAgICBwYXJlbnQuX2RpcnR5IHx8IF91bmNhY2hlKHBhcmVudCwgYW5pbWF0aW9uKTsgLy9mb3IgcGVyZm9ybWFuY2UgaW1wcm92ZW1lbnQuIElmIHRoZSBwYXJlbnQncyBjYWNoZSBpcyBhbHJlYWR5IGRpcnR5LCBpdCBhbHJlYWR5IHRvb2sgY2FyZSBvZiBtYXJraW5nIHRoZSBhbmNlc3RvcnMgYXMgZGlydHkgdG9vLCBzbyBza2lwIHRoZSBmdW5jdGlvbiBjYWxsIGhlcmUuXG4gIH1cblxuICByZXR1cm4gYW5pbWF0aW9uO1xufSxcblxuLypcbl90b3RhbFRpbWVUb1RpbWUgPSAoY2xhbXBlZFRvdGFsVGltZSwgZHVyYXRpb24sIHJlcGVhdCwgcmVwZWF0RGVsYXksIHlveW8pID0+IHtcblx0bGV0IGN5Y2xlRHVyYXRpb24gPSBkdXJhdGlvbiArIHJlcGVhdERlbGF5LFxuXHRcdHRpbWUgPSBfcm91bmQoY2xhbXBlZFRvdGFsVGltZSAlIGN5Y2xlRHVyYXRpb24pO1xuXHRpZiAodGltZSA+IGR1cmF0aW9uKSB7XG5cdFx0dGltZSA9IGR1cmF0aW9uO1xuXHR9XG5cdHJldHVybiAoeW95byAmJiAofn4oY2xhbXBlZFRvdGFsVGltZSAvIGN5Y2xlRHVyYXRpb24pICYgMSkpID8gZHVyYXRpb24gLSB0aW1lIDogdGltZTtcbn0sXG4qL1xuX3Bvc3RBZGRDaGVja3MgPSBmdW5jdGlvbiBfcG9zdEFkZENoZWNrcyh0aW1lbGluZSwgY2hpbGQpIHtcbiAgdmFyIHQ7XG5cbiAgaWYgKGNoaWxkLl90aW1lIHx8IGNoaWxkLl9pbml0dGVkICYmICFjaGlsZC5fZHVyKSB7XG4gICAgLy9pbiBjYXNlLCBmb3IgZXhhbXBsZSwgdGhlIF9zdGFydCBpcyBtb3ZlZCBvbiBhIHR3ZWVuIHRoYXQgaGFzIGFscmVhZHkgcmVuZGVyZWQuIEltYWdpbmUgaXQncyBhdCBpdHMgZW5kIHN0YXRlLCB0aGVuIHRoZSBzdGFydFRpbWUgaXMgbW92ZWQgV0FZIGxhdGVyIChhZnRlciB0aGUgZW5kIG9mIHRoaXMgdGltZWxpbmUpLCBpdCBzaG91bGQgcmVuZGVyIGF0IGl0cyBiZWdpbm5pbmcuXG4gICAgdCA9IF9wYXJlbnRUb0NoaWxkVG90YWxUaW1lKHRpbWVsaW5lLnJhd1RpbWUoKSwgY2hpbGQpO1xuXG4gICAgaWYgKCFjaGlsZC5fZHVyIHx8IF9jbGFtcCgwLCBjaGlsZC50b3RhbER1cmF0aW9uKCksIHQpIC0gY2hpbGQuX3RUaW1lID4gX3RpbnlOdW0pIHtcbiAgICAgIGNoaWxkLnJlbmRlcih0LCB0cnVlKTtcbiAgICB9XG4gIH0gLy9pZiB0aGUgdGltZWxpbmUgaGFzIGFscmVhZHkgZW5kZWQgYnV0IHRoZSBpbnNlcnRlZCB0d2Vlbi90aW1lbGluZSBleHRlbmRzIHRoZSBkdXJhdGlvbiwgd2Ugc2hvdWxkIGVuYWJsZSB0aGlzIHRpbWVsaW5lIGFnYWluIHNvIHRoYXQgaXQgcmVuZGVycyBwcm9wZXJseS4gV2Ugc2hvdWxkIGFsc28gYWxpZ24gdGhlIHBsYXloZWFkIHdpdGggdGhlIHBhcmVudCB0aW1lbGluZSdzIHdoZW4gYXBwcm9wcmlhdGUuXG5cblxuICBpZiAoX3VuY2FjaGUodGltZWxpbmUsIGNoaWxkKS5fZHAgJiYgdGltZWxpbmUuX2luaXR0ZWQgJiYgdGltZWxpbmUuX3RpbWUgPj0gdGltZWxpbmUuX2R1ciAmJiB0aW1lbGluZS5fdHMpIHtcbiAgICAvL2luIGNhc2UgYW55IG9mIHRoZSBhbmNlc3RvcnMgaGFkIGNvbXBsZXRlZCBidXQgc2hvdWxkIG5vdyBiZSBlbmFibGVkLi4uXG4gICAgaWYgKHRpbWVsaW5lLl9kdXIgPCB0aW1lbGluZS5kdXJhdGlvbigpKSB7XG4gICAgICB0ID0gdGltZWxpbmU7XG5cbiAgICAgIHdoaWxlICh0Ll9kcCkge1xuICAgICAgICB0LnJhd1RpbWUoKSA+PSAwICYmIHQudG90YWxUaW1lKHQuX3RUaW1lKTsgLy9tb3ZlcyB0aGUgdGltZWxpbmUgKHNoaWZ0cyBpdHMgc3RhcnRUaW1lKSBpZiBuZWNlc3NhcnksIGFuZCBhbHNvIGVuYWJsZXMgaXQuIElmIGl0J3MgY3VycmVudGx5IHplcm8sIHRob3VnaCwgaXQgbWF5IG5vdCBiZSBzY2hlZHVsZWQgdG8gcmVuZGVyIHVudGlsIGxhdGVyIHNvIHRoZXJlJ3Mgbm8gbmVlZCB0byBmb3JjZSBpdCB0byBhbGlnbiB3aXRoIHRoZSBjdXJyZW50IHBsYXloZWFkIHBvc2l0aW9uLiBPbmx5IG1vdmUgdG8gY2F0Y2ggdXAgd2l0aCB0aGUgcGxheWhlYWQuXG5cbiAgICAgICAgdCA9IHQuX2RwO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRpbWVsaW5lLl96VGltZSA9IC1fdGlueU51bTsgLy8gaGVscHMgZW5zdXJlIHRoYXQgdGhlIG5leHQgcmVuZGVyKCkgd2lsbCBiZSBmb3JjZWQgKGNyb3NzaW5nU3RhcnQgPSB0cnVlIGluIHJlbmRlcigpKSwgZXZlbiBpZiB0aGUgZHVyYXRpb24gaGFzbid0IGNoYW5nZWQgKHdlJ3JlIGFkZGluZyBhIGNoaWxkIHdoaWNoIHdvdWxkIG5lZWQgdG8gZ2V0IHJlbmRlcmVkKS4gRGVmaW5pdGVseSBhbiBlZGdlIGNhc2UuIE5vdGU6IHdlIE1VU1QgZG8gdGhpcyBBRlRFUiB0aGUgbG9vcCBhYm92ZSB3aGVyZSB0aGUgdG90YWxUaW1lKCkgbWlnaHQgdHJpZ2dlciBhIHJlbmRlcigpIGJlY2F1c2UgdGhpcyBfYWRkVG9UaW1lbGluZSgpIG1ldGhvZCBnZXRzIGNhbGxlZCBmcm9tIHRoZSBBbmltYXRpb24gY29uc3RydWN0b3IsIEJFRk9SRSB0d2VlbnMgZXZlbiByZWNvcmQgdGhlaXIgdGFyZ2V0cywgZXRjLiBzbyB3ZSB3b3VsZG4ndCB3YW50IHRoaW5ncyB0byBnZXQgdHJpZ2dlcmVkIGluIHRoZSB3cm9uZyBvcmRlci5cbiAgfVxufSxcbiAgICBfYWRkVG9UaW1lbGluZSA9IGZ1bmN0aW9uIF9hZGRUb1RpbWVsaW5lKHRpbWVsaW5lLCBjaGlsZCwgcG9zaXRpb24sIHNraXBDaGVja3MpIHtcbiAgY2hpbGQucGFyZW50ICYmIF9yZW1vdmVGcm9tUGFyZW50KGNoaWxkKTtcbiAgY2hpbGQuX3N0YXJ0ID0gX3JvdW5kUHJlY2lzZSgoX2lzTnVtYmVyKHBvc2l0aW9uKSA/IHBvc2l0aW9uIDogcG9zaXRpb24gfHwgdGltZWxpbmUgIT09IF9nbG9iYWxUaW1lbGluZSA/IF9wYXJzZVBvc2l0aW9uKHRpbWVsaW5lLCBwb3NpdGlvbiwgY2hpbGQpIDogdGltZWxpbmUuX3RpbWUpICsgY2hpbGQuX2RlbGF5KTtcbiAgY2hpbGQuX2VuZCA9IF9yb3VuZFByZWNpc2UoY2hpbGQuX3N0YXJ0ICsgKGNoaWxkLnRvdGFsRHVyYXRpb24oKSAvIE1hdGguYWJzKGNoaWxkLnRpbWVTY2FsZSgpKSB8fCAwKSk7XG5cbiAgX2FkZExpbmtlZExpc3RJdGVtKHRpbWVsaW5lLCBjaGlsZCwgXCJfZmlyc3RcIiwgXCJfbGFzdFwiLCB0aW1lbGluZS5fc29ydCA/IFwiX3N0YXJ0XCIgOiAwKTtcblxuICBfaXNGcm9tT3JGcm9tU3RhcnQoY2hpbGQpIHx8ICh0aW1lbGluZS5fcmVjZW50ID0gY2hpbGQpO1xuICBza2lwQ2hlY2tzIHx8IF9wb3N0QWRkQ2hlY2tzKHRpbWVsaW5lLCBjaGlsZCk7XG4gIHJldHVybiB0aW1lbGluZTtcbn0sXG4gICAgX3Njcm9sbFRyaWdnZXIgPSBmdW5jdGlvbiBfc2Nyb2xsVHJpZ2dlcihhbmltYXRpb24sIHRyaWdnZXIpIHtcbiAgcmV0dXJuIChfZ2xvYmFscy5TY3JvbGxUcmlnZ2VyIHx8IF9taXNzaW5nUGx1Z2luKFwic2Nyb2xsVHJpZ2dlclwiLCB0cmlnZ2VyKSkgJiYgX2dsb2JhbHMuU2Nyb2xsVHJpZ2dlci5jcmVhdGUodHJpZ2dlciwgYW5pbWF0aW9uKTtcbn0sXG4gICAgX2F0dGVtcHRJbml0VHdlZW4gPSBmdW5jdGlvbiBfYXR0ZW1wdEluaXRUd2Vlbih0d2VlbiwgdG90YWxUaW1lLCBmb3JjZSwgc3VwcHJlc3NFdmVudHMpIHtcbiAgX2luaXRUd2Vlbih0d2VlbiwgdG90YWxUaW1lKTtcblxuICBpZiAoIXR3ZWVuLl9pbml0dGVkKSB7XG4gICAgcmV0dXJuIDE7XG4gIH1cblxuICBpZiAoIWZvcmNlICYmIHR3ZWVuLl9wdCAmJiAodHdlZW4uX2R1ciAmJiB0d2Vlbi52YXJzLmxhenkgIT09IGZhbHNlIHx8ICF0d2Vlbi5fZHVyICYmIHR3ZWVuLnZhcnMubGF6eSkgJiYgX2xhc3RSZW5kZXJlZEZyYW1lICE9PSBfdGlja2VyLmZyYW1lKSB7XG4gICAgX2xhenlUd2VlbnMucHVzaCh0d2Vlbik7XG5cbiAgICB0d2Vlbi5fbGF6eSA9IFt0b3RhbFRpbWUsIHN1cHByZXNzRXZlbnRzXTtcbiAgICByZXR1cm4gMTtcbiAgfVxufSxcbiAgICBfcGFyZW50UGxheWhlYWRJc0JlZm9yZVN0YXJ0ID0gZnVuY3Rpb24gX3BhcmVudFBsYXloZWFkSXNCZWZvcmVTdGFydChfcmVmKSB7XG4gIHZhciBwYXJlbnQgPSBfcmVmLnBhcmVudDtcbiAgcmV0dXJuIHBhcmVudCAmJiBwYXJlbnQuX3RzICYmIHBhcmVudC5faW5pdHRlZCAmJiAhcGFyZW50Ll9sb2NrICYmIChwYXJlbnQucmF3VGltZSgpIDwgMCB8fCBfcGFyZW50UGxheWhlYWRJc0JlZm9yZVN0YXJ0KHBhcmVudCkpO1xufSxcbiAgICAvLyBjaGVjayBwYXJlbnQncyBfbG9jayBiZWNhdXNlIHdoZW4gYSB0aW1lbGluZSByZXBlYXRzL3lveW9zIGFuZCBkb2VzIGl0cyBhcnRpZmljaWFsIHdyYXBwaW5nLCB3ZSBzaG91bGRuJ3QgZm9yY2UgdGhlIHJhdGlvIGJhY2sgdG8gMFxuX2lzRnJvbU9yRnJvbVN0YXJ0ID0gZnVuY3Rpb24gX2lzRnJvbU9yRnJvbVN0YXJ0KF9yZWYyKSB7XG4gIHZhciBkYXRhID0gX3JlZjIuZGF0YTtcbiAgcmV0dXJuIGRhdGEgPT09IFwiaXNGcm9tU3RhcnRcIiB8fCBkYXRhID09PSBcImlzU3RhcnRcIjtcbn0sXG4gICAgX3JlbmRlclplcm9EdXJhdGlvblR3ZWVuID0gZnVuY3Rpb24gX3JlbmRlclplcm9EdXJhdGlvblR3ZWVuKHR3ZWVuLCB0b3RhbFRpbWUsIHN1cHByZXNzRXZlbnRzLCBmb3JjZSkge1xuICB2YXIgcHJldlJhdGlvID0gdHdlZW4ucmF0aW8sXG4gICAgICByYXRpbyA9IHRvdGFsVGltZSA8IDAgfHwgIXRvdGFsVGltZSAmJiAoIXR3ZWVuLl9zdGFydCAmJiBfcGFyZW50UGxheWhlYWRJc0JlZm9yZVN0YXJ0KHR3ZWVuKSAmJiAhKCF0d2Vlbi5faW5pdHRlZCAmJiBfaXNGcm9tT3JGcm9tU3RhcnQodHdlZW4pKSB8fCAodHdlZW4uX3RzIDwgMCB8fCB0d2Vlbi5fZHAuX3RzIDwgMCkgJiYgIV9pc0Zyb21PckZyb21TdGFydCh0d2VlbikpID8gMCA6IDEsXG4gICAgICAvLyBpZiB0aGUgdHdlZW4gb3IgaXRzIHBhcmVudCBpcyByZXZlcnNlZCBhbmQgdGhlIHRvdGFsVGltZSBpcyAwLCB3ZSBzaG91bGQgZ28gdG8gYSByYXRpbyBvZiAwLiBFZGdlIGNhc2U6IGlmIGEgZnJvbSgpIG9yIGZyb21UbygpIHN0YWdnZXIgdHdlZW4gaXMgcGxhY2VkIGxhdGVyIGluIGEgdGltZWxpbmUsIHRoZSBcInN0YXJ0QXRcIiB6ZXJvLWR1cmF0aW9uIHR3ZWVuIGNvdWxkIGluaXRpYWxseSByZW5kZXIgYXQgYSB0aW1lIHdoZW4gdGhlIHBhcmVudCB0aW1lbGluZSdzIHBsYXloZWFkIGlzIHRlY2huaWNhbGx5IEJFRk9SRSB3aGVyZSB0aGlzIHR3ZWVuIGlzLCBzbyBtYWtlIHN1cmUgdGhhdCBhbnkgXCJmcm9tXCIgYW5kIFwiZnJvbVRvXCIgc3RhcnRBdCB0d2VlbnMgYXJlIHJlbmRlcmVkIHRoZSBmaXJzdCB0aW1lIGF0IGEgcmF0aW8gb2YgMS5cbiAgcmVwZWF0RGVsYXkgPSB0d2Vlbi5fckRlbGF5LFxuICAgICAgdFRpbWUgPSAwLFxuICAgICAgcHQsXG4gICAgICBpdGVyYXRpb24sXG4gICAgICBwcmV2SXRlcmF0aW9uO1xuXG4gIGlmIChyZXBlYXREZWxheSAmJiB0d2Vlbi5fcmVwZWF0KSB7XG4gICAgLy8gaW4gY2FzZSB0aGVyZSdzIGEgemVyby1kdXJhdGlvbiB0d2VlbiB0aGF0IGhhcyBhIHJlcGVhdCB3aXRoIGEgcmVwZWF0RGVsYXlcbiAgICB0VGltZSA9IF9jbGFtcCgwLCB0d2Vlbi5fdER1ciwgdG90YWxUaW1lKTtcbiAgICBpdGVyYXRpb24gPSBfYW5pbWF0aW9uQ3ljbGUodFRpbWUsIHJlcGVhdERlbGF5KTtcbiAgICB0d2Vlbi5feW95byAmJiBpdGVyYXRpb24gJiAxICYmIChyYXRpbyA9IDEgLSByYXRpbyk7XG5cbiAgICBpZiAoaXRlcmF0aW9uICE9PSBfYW5pbWF0aW9uQ3ljbGUodHdlZW4uX3RUaW1lLCByZXBlYXREZWxheSkpIHtcbiAgICAgIC8vIGlmIGl0ZXJhdGlvbiBjaGFuZ2VkXG4gICAgICBwcmV2UmF0aW8gPSAxIC0gcmF0aW87XG4gICAgICB0d2Vlbi52YXJzLnJlcGVhdFJlZnJlc2ggJiYgdHdlZW4uX2luaXR0ZWQgJiYgdHdlZW4uaW52YWxpZGF0ZSgpO1xuICAgIH1cbiAgfVxuXG4gIGlmIChyYXRpbyAhPT0gcHJldlJhdGlvIHx8IGZvcmNlIHx8IHR3ZWVuLl96VGltZSA9PT0gX3RpbnlOdW0gfHwgIXRvdGFsVGltZSAmJiB0d2Vlbi5felRpbWUpIHtcbiAgICBpZiAoIXR3ZWVuLl9pbml0dGVkICYmIF9hdHRlbXB0SW5pdFR3ZWVuKHR3ZWVuLCB0b3RhbFRpbWUsIGZvcmNlLCBzdXBwcmVzc0V2ZW50cykpIHtcbiAgICAgIC8vIGlmIHdlIHJlbmRlciB0aGUgdmVyeSBiZWdpbm5pbmcgKHRpbWUgPT0gMCkgb2YgYSBmcm9tVG8oKSwgd2UgbXVzdCBmb3JjZSB0aGUgcmVuZGVyIChub3JtYWwgdHdlZW5zIHdvdWxkbid0IG5lZWQgdG8gcmVuZGVyIGF0IGEgdGltZSBvZiAwIHdoZW4gdGhlIHByZXZUaW1lIHdhcyBhbHNvIDApLiBUaGlzIGlzIGFsc28gbWFuZGF0b3J5IHRvIG1ha2Ugc3VyZSBvdmVyd3JpdGluZyBraWNrcyBpbiBpbW1lZGlhdGVseS5cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBwcmV2SXRlcmF0aW9uID0gdHdlZW4uX3pUaW1lO1xuICAgIHR3ZWVuLl96VGltZSA9IHRvdGFsVGltZSB8fCAoc3VwcHJlc3NFdmVudHMgPyBfdGlueU51bSA6IDApOyAvLyB3aGVuIHRoZSBwbGF5aGVhZCBhcnJpdmVzIGF0IEVYQUNUTFkgdGltZSAwIChyaWdodCBvbiB0b3ApIG9mIGEgemVyby1kdXJhdGlvbiB0d2Vlbiwgd2UgbmVlZCB0byBkaXNjZXJuIGlmIGV2ZW50cyBhcmUgc3VwcHJlc3NlZCBzbyB0aGF0IHdoZW4gdGhlIHBsYXloZWFkIG1vdmVzIGFnYWluIChuZXh0IHRpbWUpLCBpdCdsbCB0cmlnZ2VyIHRoZSBjYWxsYmFjay4gSWYgZXZlbnRzIGFyZSBOT1Qgc3VwcHJlc3NlZCwgb2J2aW91c2x5IHRoZSBjYWxsYmFjayB3b3VsZCBiZSB0cmlnZ2VyZWQgaW4gdGhpcyByZW5kZXIuIEJhc2ljYWxseSwgdGhlIGNhbGxiYWNrIHNob3VsZCBmaXJlIGVpdGhlciB3aGVuIHRoZSBwbGF5aGVhZCBBUlJJVkVTIG9yIExFQVZFUyB0aGlzIGV4YWN0IHNwb3QsIG5vdCBib3RoLiBJbWFnaW5lIGRvaW5nIGEgdGltZWxpbmUuc2VlaygwKSBhbmQgdGhlcmUncyBhIGNhbGxiYWNrIHRoYXQgc2l0cyBhdCAwLiBTaW5jZSBldmVudHMgYXJlIHN1cHByZXNzZWQgb24gdGhhdCBzZWVrKCkgYnkgZGVmYXVsdCwgbm90aGluZyB3aWxsIGZpcmUsIGJ1dCB3aGVuIHRoZSBwbGF5aGVhZCBtb3ZlcyBvZmYgb2YgdGhhdCBwb3NpdGlvbiwgdGhlIGNhbGxiYWNrIHNob3VsZCBmaXJlLiBUaGlzIGJlaGF2aW9yIGlzIHdoYXQgcGVvcGxlIGludHVpdGl2ZWx5IGV4cGVjdC5cblxuICAgIHN1cHByZXNzRXZlbnRzIHx8IChzdXBwcmVzc0V2ZW50cyA9IHRvdGFsVGltZSAmJiAhcHJldkl0ZXJhdGlvbik7IC8vIGlmIGl0IHdhcyByZW5kZXJlZCBwcmV2aW91c2x5IGF0IGV4YWN0bHkgMCAoX3pUaW1lKSBhbmQgbm93IHRoZSBwbGF5aGVhZCBpcyBtb3ZpbmcgYXdheSwgRE9OJ1QgZmlyZSBjYWxsYmFja3Mgb3RoZXJ3aXNlIHRoZXknbGwgc2VlbSBsaWtlIGR1cGxpY2F0ZXMuXG5cbiAgICB0d2Vlbi5yYXRpbyA9IHJhdGlvO1xuICAgIHR3ZWVuLl9mcm9tICYmIChyYXRpbyA9IDEgLSByYXRpbyk7XG4gICAgdHdlZW4uX3RpbWUgPSAwO1xuICAgIHR3ZWVuLl90VGltZSA9IHRUaW1lO1xuICAgIHB0ID0gdHdlZW4uX3B0O1xuXG4gICAgd2hpbGUgKHB0KSB7XG4gICAgICBwdC5yKHJhdGlvLCBwdC5kKTtcbiAgICAgIHB0ID0gcHQuX25leHQ7XG4gICAgfVxuXG4gICAgdHdlZW4uX3N0YXJ0QXQgJiYgdG90YWxUaW1lIDwgMCAmJiB0d2Vlbi5fc3RhcnRBdC5yZW5kZXIodG90YWxUaW1lLCB0cnVlLCB0cnVlKTtcbiAgICB0d2Vlbi5fb25VcGRhdGUgJiYgIXN1cHByZXNzRXZlbnRzICYmIF9jYWxsYmFjayh0d2VlbiwgXCJvblVwZGF0ZVwiKTtcbiAgICB0VGltZSAmJiB0d2Vlbi5fcmVwZWF0ICYmICFzdXBwcmVzc0V2ZW50cyAmJiB0d2Vlbi5wYXJlbnQgJiYgX2NhbGxiYWNrKHR3ZWVuLCBcIm9uUmVwZWF0XCIpO1xuXG4gICAgaWYgKCh0b3RhbFRpbWUgPj0gdHdlZW4uX3REdXIgfHwgdG90YWxUaW1lIDwgMCkgJiYgdHdlZW4ucmF0aW8gPT09IHJhdGlvKSB7XG4gICAgICByYXRpbyAmJiBfcmVtb3ZlRnJvbVBhcmVudCh0d2VlbiwgMSk7XG5cbiAgICAgIGlmICghc3VwcHJlc3NFdmVudHMpIHtcbiAgICAgICAgX2NhbGxiYWNrKHR3ZWVuLCByYXRpbyA/IFwib25Db21wbGV0ZVwiIDogXCJvblJldmVyc2VDb21wbGV0ZVwiLCB0cnVlKTtcblxuICAgICAgICB0d2Vlbi5fcHJvbSAmJiB0d2Vlbi5fcHJvbSgpO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIGlmICghdHdlZW4uX3pUaW1lKSB7XG4gICAgdHdlZW4uX3pUaW1lID0gdG90YWxUaW1lO1xuICB9XG59LFxuICAgIF9maW5kTmV4dFBhdXNlVHdlZW4gPSBmdW5jdGlvbiBfZmluZE5leHRQYXVzZVR3ZWVuKGFuaW1hdGlvbiwgcHJldlRpbWUsIHRpbWUpIHtcbiAgdmFyIGNoaWxkO1xuXG4gIGlmICh0aW1lID4gcHJldlRpbWUpIHtcbiAgICBjaGlsZCA9IGFuaW1hdGlvbi5fZmlyc3Q7XG5cbiAgICB3aGlsZSAoY2hpbGQgJiYgY2hpbGQuX3N0YXJ0IDw9IHRpbWUpIHtcbiAgICAgIGlmIChjaGlsZC5kYXRhID09PSBcImlzUGF1c2VcIiAmJiBjaGlsZC5fc3RhcnQgPiBwcmV2VGltZSkge1xuICAgICAgICByZXR1cm4gY2hpbGQ7XG4gICAgICB9XG5cbiAgICAgIGNoaWxkID0gY2hpbGQuX25leHQ7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGNoaWxkID0gYW5pbWF0aW9uLl9sYXN0O1xuXG4gICAgd2hpbGUgKGNoaWxkICYmIGNoaWxkLl9zdGFydCA+PSB0aW1lKSB7XG4gICAgICBpZiAoY2hpbGQuZGF0YSA9PT0gXCJpc1BhdXNlXCIgJiYgY2hpbGQuX3N0YXJ0IDwgcHJldlRpbWUpIHtcbiAgICAgICAgcmV0dXJuIGNoaWxkO1xuICAgICAgfVxuXG4gICAgICBjaGlsZCA9IGNoaWxkLl9wcmV2O1xuICAgIH1cbiAgfVxufSxcbiAgICBfc2V0RHVyYXRpb24gPSBmdW5jdGlvbiBfc2V0RHVyYXRpb24oYW5pbWF0aW9uLCBkdXJhdGlvbiwgc2tpcFVuY2FjaGUsIGxlYXZlUGxheWhlYWQpIHtcbiAgdmFyIHJlcGVhdCA9IGFuaW1hdGlvbi5fcmVwZWF0LFxuICAgICAgZHVyID0gX3JvdW5kUHJlY2lzZShkdXJhdGlvbikgfHwgMCxcbiAgICAgIHRvdGFsUHJvZ3Jlc3MgPSBhbmltYXRpb24uX3RUaW1lIC8gYW5pbWF0aW9uLl90RHVyO1xuICB0b3RhbFByb2dyZXNzICYmICFsZWF2ZVBsYXloZWFkICYmIChhbmltYXRpb24uX3RpbWUgKj0gZHVyIC8gYW5pbWF0aW9uLl9kdXIpO1xuICBhbmltYXRpb24uX2R1ciA9IGR1cjtcbiAgYW5pbWF0aW9uLl90RHVyID0gIXJlcGVhdCA/IGR1ciA6IHJlcGVhdCA8IDAgPyAxZTEwIDogX3JvdW5kUHJlY2lzZShkdXIgKiAocmVwZWF0ICsgMSkgKyBhbmltYXRpb24uX3JEZWxheSAqIHJlcGVhdCk7XG4gIHRvdGFsUHJvZ3Jlc3MgPiAwICYmICFsZWF2ZVBsYXloZWFkID8gX2FsaWduUGxheWhlYWQoYW5pbWF0aW9uLCBhbmltYXRpb24uX3RUaW1lID0gYW5pbWF0aW9uLl90RHVyICogdG90YWxQcm9ncmVzcykgOiBhbmltYXRpb24ucGFyZW50ICYmIF9zZXRFbmQoYW5pbWF0aW9uKTtcbiAgc2tpcFVuY2FjaGUgfHwgX3VuY2FjaGUoYW5pbWF0aW9uLnBhcmVudCwgYW5pbWF0aW9uKTtcbiAgcmV0dXJuIGFuaW1hdGlvbjtcbn0sXG4gICAgX29uVXBkYXRlVG90YWxEdXJhdGlvbiA9IGZ1bmN0aW9uIF9vblVwZGF0ZVRvdGFsRHVyYXRpb24oYW5pbWF0aW9uKSB7XG4gIHJldHVybiBhbmltYXRpb24gaW5zdGFuY2VvZiBUaW1lbGluZSA/IF91bmNhY2hlKGFuaW1hdGlvbikgOiBfc2V0RHVyYXRpb24oYW5pbWF0aW9uLCBhbmltYXRpb24uX2R1cik7XG59LFxuICAgIF96ZXJvUG9zaXRpb24gPSB7XG4gIF9zdGFydDogMCxcbiAgZW5kVGltZTogX2VtcHR5RnVuYyxcbiAgdG90YWxEdXJhdGlvbjogX2VtcHR5RnVuY1xufSxcbiAgICBfcGFyc2VQb3NpdGlvbiA9IGZ1bmN0aW9uIF9wYXJzZVBvc2l0aW9uKGFuaW1hdGlvbiwgcG9zaXRpb24sIHBlcmNlbnRBbmltYXRpb24pIHtcbiAgdmFyIGxhYmVscyA9IGFuaW1hdGlvbi5sYWJlbHMsXG4gICAgICByZWNlbnQgPSBhbmltYXRpb24uX3JlY2VudCB8fCBfemVyb1Bvc2l0aW9uLFxuICAgICAgY2xpcHBlZER1cmF0aW9uID0gYW5pbWF0aW9uLmR1cmF0aW9uKCkgPj0gX2JpZ051bSA/IHJlY2VudC5lbmRUaW1lKGZhbHNlKSA6IGFuaW1hdGlvbi5fZHVyLFxuICAgICAgLy9pbiBjYXNlIHRoZXJlJ3MgYSBjaGlsZCB0aGF0IGluZmluaXRlbHkgcmVwZWF0cywgdXNlcnMgYWxtb3N0IG5ldmVyIGludGVuZCBmb3IgdGhlIGluc2VydGlvbiBwb2ludCBvZiBhIG5ldyBjaGlsZCB0byBiZSBiYXNlZCBvbiBhIFNVUEVSIGxvbmcgdmFsdWUgbGlrZSB0aGF0IHNvIHdlIGNsaXAgaXQgYW5kIGFzc3VtZSB0aGUgbW9zdCByZWNlbnRseS1hZGRlZCBjaGlsZCdzIGVuZFRpbWUgc2hvdWxkIGJlIHVzZWQgaW5zdGVhZC5cbiAgaSxcbiAgICAgIG9mZnNldCxcbiAgICAgIGlzUGVyY2VudDtcblxuICBpZiAoX2lzU3RyaW5nKHBvc2l0aW9uKSAmJiAoaXNOYU4ocG9zaXRpb24pIHx8IHBvc2l0aW9uIGluIGxhYmVscykpIHtcbiAgICAvL2lmIHRoZSBzdHJpbmcgaXMgYSBudW1iZXIgbGlrZSBcIjFcIiwgY2hlY2sgdG8gc2VlIGlmIHRoZXJlJ3MgYSBsYWJlbCB3aXRoIHRoYXQgbmFtZSwgb3RoZXJ3aXNlIGludGVycHJldCBpdCBhcyBhIG51bWJlciAoYWJzb2x1dGUgdmFsdWUpLlxuICAgIG9mZnNldCA9IHBvc2l0aW9uLmNoYXJBdCgwKTtcbiAgICBpc1BlcmNlbnQgPSBwb3NpdGlvbi5zdWJzdHIoLTEpID09PSBcIiVcIjtcbiAgICBpID0gcG9zaXRpb24uaW5kZXhPZihcIj1cIik7XG5cbiAgICBpZiAob2Zmc2V0ID09PSBcIjxcIiB8fCBvZmZzZXQgPT09IFwiPlwiKSB7XG4gICAgICBpID49IDAgJiYgKHBvc2l0aW9uID0gcG9zaXRpb24ucmVwbGFjZSgvPS8sIFwiXCIpKTtcbiAgICAgIHJldHVybiAob2Zmc2V0ID09PSBcIjxcIiA/IHJlY2VudC5fc3RhcnQgOiByZWNlbnQuZW5kVGltZShyZWNlbnQuX3JlcGVhdCA+PSAwKSkgKyAocGFyc2VGbG9hdChwb3NpdGlvbi5zdWJzdHIoMSkpIHx8IDApICogKGlzUGVyY2VudCA/IChpIDwgMCA/IHJlY2VudCA6IHBlcmNlbnRBbmltYXRpb24pLnRvdGFsRHVyYXRpb24oKSAvIDEwMCA6IDEpO1xuICAgIH1cblxuICAgIGlmIChpIDwgMCkge1xuICAgICAgcG9zaXRpb24gaW4gbGFiZWxzIHx8IChsYWJlbHNbcG9zaXRpb25dID0gY2xpcHBlZER1cmF0aW9uKTtcbiAgICAgIHJldHVybiBsYWJlbHNbcG9zaXRpb25dO1xuICAgIH1cblxuICAgIG9mZnNldCA9IHBhcnNlRmxvYXQocG9zaXRpb24uY2hhckF0KGkgLSAxKSArIHBvc2l0aW9uLnN1YnN0cihpICsgMSkpO1xuXG4gICAgaWYgKGlzUGVyY2VudCAmJiBwZXJjZW50QW5pbWF0aW9uKSB7XG4gICAgICBvZmZzZXQgPSBvZmZzZXQgLyAxMDAgKiAoX2lzQXJyYXkocGVyY2VudEFuaW1hdGlvbikgPyBwZXJjZW50QW5pbWF0aW9uWzBdIDogcGVyY2VudEFuaW1hdGlvbikudG90YWxEdXJhdGlvbigpO1xuICAgIH1cblxuICAgIHJldHVybiBpID4gMSA/IF9wYXJzZVBvc2l0aW9uKGFuaW1hdGlvbiwgcG9zaXRpb24uc3Vic3RyKDAsIGkgLSAxKSwgcGVyY2VudEFuaW1hdGlvbikgKyBvZmZzZXQgOiBjbGlwcGVkRHVyYXRpb24gKyBvZmZzZXQ7XG4gIH1cblxuICByZXR1cm4gcG9zaXRpb24gPT0gbnVsbCA/IGNsaXBwZWREdXJhdGlvbiA6ICtwb3NpdGlvbjtcbn0sXG4gICAgX2NyZWF0ZVR3ZWVuVHlwZSA9IGZ1bmN0aW9uIF9jcmVhdGVUd2VlblR5cGUodHlwZSwgcGFyYW1zLCB0aW1lbGluZSkge1xuICB2YXIgaXNMZWdhY3kgPSBfaXNOdW1iZXIocGFyYW1zWzFdKSxcbiAgICAgIHZhcnNJbmRleCA9IChpc0xlZ2FjeSA/IDIgOiAxKSArICh0eXBlIDwgMiA/IDAgOiAxKSxcbiAgICAgIHZhcnMgPSBwYXJhbXNbdmFyc0luZGV4XSxcbiAgICAgIGlyVmFycyxcbiAgICAgIHBhcmVudDtcblxuICBpc0xlZ2FjeSAmJiAodmFycy5kdXJhdGlvbiA9IHBhcmFtc1sxXSk7XG4gIHZhcnMucGFyZW50ID0gdGltZWxpbmU7XG5cbiAgaWYgKHR5cGUpIHtcbiAgICBpclZhcnMgPSB2YXJzO1xuICAgIHBhcmVudCA9IHRpbWVsaW5lO1xuXG4gICAgd2hpbGUgKHBhcmVudCAmJiAhKFwiaW1tZWRpYXRlUmVuZGVyXCIgaW4gaXJWYXJzKSkge1xuICAgICAgLy8gaW5oZXJpdGFuY2UgaGFzbid0IGhhcHBlbmVkIHlldCwgYnV0IHNvbWVvbmUgbWF5IGhhdmUgc2V0IGEgZGVmYXVsdCBpbiBhbiBhbmNlc3RvciB0aW1lbGluZS4gV2UgY291bGQgZG8gdmFycy5pbW1lZGlhdGVSZW5kZXIgPSBfaXNOb3RGYWxzZShfaW5oZXJpdERlZmF1bHRzKHZhcnMpLmltbWVkaWF0ZVJlbmRlcikgYnV0IHRoYXQnZCBleGFjdCBhIHNsaWdodCBwZXJmb3JtYW5jZSBwZW5hbHR5IGJlY2F1c2UgX2luaGVyaXREZWZhdWx0cygpIGFsc28gcnVucyBpbiB0aGUgVHdlZW4gY29uc3RydWN0b3IuIFdlJ3JlIHBheWluZyBhIHNtYWxsIGtiIHByaWNlIGhlcmUgdG8gZ2FpbiBzcGVlZC5cbiAgICAgIGlyVmFycyA9IHBhcmVudC52YXJzLmRlZmF1bHRzIHx8IHt9O1xuICAgICAgcGFyZW50ID0gX2lzTm90RmFsc2UocGFyZW50LnZhcnMuaW5oZXJpdCkgJiYgcGFyZW50LnBhcmVudDtcbiAgICB9XG5cbiAgICB2YXJzLmltbWVkaWF0ZVJlbmRlciA9IF9pc05vdEZhbHNlKGlyVmFycy5pbW1lZGlhdGVSZW5kZXIpO1xuICAgIHR5cGUgPCAyID8gdmFycy5ydW5CYWNrd2FyZHMgPSAxIDogdmFycy5zdGFydEF0ID0gcGFyYW1zW3ZhcnNJbmRleCAtIDFdOyAvLyBcImZyb21cIiB2YXJzXG4gIH1cblxuICByZXR1cm4gbmV3IFR3ZWVuKHBhcmFtc1swXSwgdmFycywgcGFyYW1zW3ZhcnNJbmRleCArIDFdKTtcbn0sXG4gICAgX2NvbmRpdGlvbmFsUmV0dXJuID0gZnVuY3Rpb24gX2NvbmRpdGlvbmFsUmV0dXJuKHZhbHVlLCBmdW5jKSB7XG4gIHJldHVybiB2YWx1ZSB8fCB2YWx1ZSA9PT0gMCA/IGZ1bmModmFsdWUpIDogZnVuYztcbn0sXG4gICAgX2NsYW1wID0gZnVuY3Rpb24gX2NsYW1wKG1pbiwgbWF4LCB2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgPCBtaW4gPyBtaW4gOiB2YWx1ZSA+IG1heCA/IG1heCA6IHZhbHVlO1xufSxcbiAgICBnZXRVbml0ID0gZnVuY3Rpb24gZ2V0VW5pdCh2YWx1ZSwgdikge1xuICByZXR1cm4gIV9pc1N0cmluZyh2YWx1ZSkgfHwgISh2ID0gX3VuaXRFeHAuZXhlYyh2YWx1ZSkpID8gXCJcIiA6IHZbMV07XG59LFxuICAgIC8vIG5vdGU6IHByb3RlY3QgYWdhaW5zdCBwYWRkZWQgbnVtYmVycyBhcyBzdHJpbmdzLCBsaWtlIFwiMTAwLjEwMFwiLiBUaGF0IHNob3VsZG4ndCByZXR1cm4gXCIwMFwiIGFzIHRoZSB1bml0LiBJZiBpdCdzIG51bWVyaWMsIHJldHVybiBubyB1bml0LlxuY2xhbXAgPSBmdW5jdGlvbiBjbGFtcChtaW4sIG1heCwgdmFsdWUpIHtcbiAgcmV0dXJuIF9jb25kaXRpb25hbFJldHVybih2YWx1ZSwgZnVuY3Rpb24gKHYpIHtcbiAgICByZXR1cm4gX2NsYW1wKG1pbiwgbWF4LCB2KTtcbiAgfSk7XG59LFxuICAgIF9zbGljZSA9IFtdLnNsaWNlLFxuICAgIF9pc0FycmF5TGlrZSA9IGZ1bmN0aW9uIF9pc0FycmF5TGlrZSh2YWx1ZSwgbm9uRW1wdHkpIHtcbiAgcmV0dXJuIHZhbHVlICYmIF9pc09iamVjdCh2YWx1ZSkgJiYgXCJsZW5ndGhcIiBpbiB2YWx1ZSAmJiAoIW5vbkVtcHR5ICYmICF2YWx1ZS5sZW5ndGggfHwgdmFsdWUubGVuZ3RoIC0gMSBpbiB2YWx1ZSAmJiBfaXNPYmplY3QodmFsdWVbMF0pKSAmJiAhdmFsdWUubm9kZVR5cGUgJiYgdmFsdWUgIT09IF93aW47XG59LFxuICAgIF9mbGF0dGVuID0gZnVuY3Rpb24gX2ZsYXR0ZW4oYXIsIGxlYXZlU3RyaW5ncywgYWNjdW11bGF0b3IpIHtcbiAgaWYgKGFjY3VtdWxhdG9yID09PSB2b2lkIDApIHtcbiAgICBhY2N1bXVsYXRvciA9IFtdO1xuICB9XG5cbiAgcmV0dXJuIGFyLmZvckVhY2goZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgdmFyIF9hY2N1bXVsYXRvcjtcblxuICAgIHJldHVybiBfaXNTdHJpbmcodmFsdWUpICYmICFsZWF2ZVN0cmluZ3MgfHwgX2lzQXJyYXlMaWtlKHZhbHVlLCAxKSA/IChfYWNjdW11bGF0b3IgPSBhY2N1bXVsYXRvcikucHVzaC5hcHBseShfYWNjdW11bGF0b3IsIHRvQXJyYXkodmFsdWUpKSA6IGFjY3VtdWxhdG9yLnB1c2godmFsdWUpO1xuICB9KSB8fCBhY2N1bXVsYXRvcjtcbn0sXG4gICAgLy90YWtlcyBhbnkgdmFsdWUgYW5kIHJldHVybnMgYW4gYXJyYXkuIElmIGl0J3MgYSBzdHJpbmcgKGFuZCBsZWF2ZVN0cmluZ3MgaXNuJ3QgdHJ1ZSksIGl0J2xsIHVzZSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCkgYW5kIGNvbnZlcnQgdGhhdCB0byBhbiBhcnJheS4gSXQnbGwgYWxzbyBhY2NlcHQgaXRlcmFibGVzIGxpa2UgalF1ZXJ5IG9iamVjdHMuXG50b0FycmF5ID0gZnVuY3Rpb24gdG9BcnJheSh2YWx1ZSwgc2NvcGUsIGxlYXZlU3RyaW5ncykge1xuICByZXR1cm4gX2lzU3RyaW5nKHZhbHVlKSAmJiAhbGVhdmVTdHJpbmdzICYmIChfY29yZUluaXR0ZWQgfHwgIV93YWtlKCkpID8gX3NsaWNlLmNhbGwoKHNjb3BlIHx8IF9kb2MpLnF1ZXJ5U2VsZWN0b3JBbGwodmFsdWUpLCAwKSA6IF9pc0FycmF5KHZhbHVlKSA/IF9mbGF0dGVuKHZhbHVlLCBsZWF2ZVN0cmluZ3MpIDogX2lzQXJyYXlMaWtlKHZhbHVlKSA/IF9zbGljZS5jYWxsKHZhbHVlLCAwKSA6IHZhbHVlID8gW3ZhbHVlXSA6IFtdO1xufSxcbiAgICBzZWxlY3RvciA9IGZ1bmN0aW9uIHNlbGVjdG9yKHZhbHVlKSB7XG4gIHZhbHVlID0gdG9BcnJheSh2YWx1ZSlbMF0gfHwgX3dhcm4oXCJJbnZhbGlkIHNjb3BlXCIpIHx8IHt9O1xuICByZXR1cm4gZnVuY3Rpb24gKHYpIHtcbiAgICB2YXIgZWwgPSB2YWx1ZS5jdXJyZW50IHx8IHZhbHVlLm5hdGl2ZUVsZW1lbnQgfHwgdmFsdWU7XG4gICAgcmV0dXJuIHRvQXJyYXkodiwgZWwucXVlcnlTZWxlY3RvckFsbCA/IGVsIDogZWwgPT09IHZhbHVlID8gX3dhcm4oXCJJbnZhbGlkIHNjb3BlXCIpIHx8IF9kb2MuY3JlYXRlRWxlbWVudChcImRpdlwiKSA6IHZhbHVlKTtcbiAgfTtcbn0sXG4gICAgc2h1ZmZsZSA9IGZ1bmN0aW9uIHNodWZmbGUoYSkge1xuICByZXR1cm4gYS5zb3J0KGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gLjUgLSBNYXRoLnJhbmRvbSgpO1xuICB9KTtcbn0sXG4gICAgLy8gYWx0ZXJuYXRpdmUgdGhhdCdzIGEgYml0IGZhc3RlciBhbmQgbW9yZSByZWxpYWJseSBkaXZlcnNlIGJ1dCBiaWdnZXI6ICAgZm9yIChsZXQgaiwgdiwgaSA9IGEubGVuZ3RoOyBpOyBqID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogaSksIHYgPSBhWy0taV0sIGFbaV0gPSBhW2pdLCBhW2pdID0gdik7IHJldHVybiBhO1xuLy9mb3IgZGlzdHJpYnV0aW5nIHZhbHVlcyBhY3Jvc3MgYW4gYXJyYXkuIENhbiBhY2NlcHQgYSBudW1iZXIsIGEgZnVuY3Rpb24gb3IgKG1vc3QgY29tbW9ubHkpIGEgZnVuY3Rpb24gd2hpY2ggY2FuIGNvbnRhaW4gdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOiB7YmFzZSwgYW1vdW50LCBmcm9tLCBlYXNlLCBncmlkLCBheGlzLCBsZW5ndGgsIGVhY2h9LiBSZXR1cm5zIGEgZnVuY3Rpb24gdGhhdCBleHBlY3RzIHRoZSBmb2xsb3dpbmcgcGFyYW1ldGVyczogaW5kZXgsIHRhcmdldCwgYXJyYXkuIFJlY29nbml6ZXMgdGhlIGZvbGxvd2luZ1xuZGlzdHJpYnV0ZSA9IGZ1bmN0aW9uIGRpc3RyaWJ1dGUodikge1xuICBpZiAoX2lzRnVuY3Rpb24odikpIHtcbiAgICByZXR1cm4gdjtcbiAgfVxuXG4gIHZhciB2YXJzID0gX2lzT2JqZWN0KHYpID8gdiA6IHtcbiAgICBlYWNoOiB2XG4gIH0sXG4gICAgICAvL246MSBpcyBqdXN0IHRvIGluZGljYXRlIHYgd2FzIGEgbnVtYmVyOyB3ZSBsZXZlcmFnZSB0aGF0IGxhdGVyIHRvIHNldCB2IGFjY29yZGluZyB0byB0aGUgbGVuZ3RoIHdlIGdldC4gSWYgYSBudW1iZXIgaXMgcGFzc2VkIGluLCB3ZSB0cmVhdCBpdCBsaWtlIHRoZSBvbGQgc3RhZ2dlciB2YWx1ZSB3aGVyZSAwLjEsIGZvciBleGFtcGxlLCB3b3VsZCBtZWFuIHRoYXQgdGhpbmdzIHdvdWxkIGJlIGRpc3RyaWJ1dGVkIHdpdGggMC4xIGJldHdlZW4gZWFjaCBlbGVtZW50IGluIHRoZSBhcnJheSByYXRoZXIgdGhhbiBhIHRvdGFsIFwiYW1vdW50XCIgdGhhdCdzIGNodW5rZWQgb3V0IGFtb25nIHRoZW0gYWxsLlxuICBlYXNlID0gX3BhcnNlRWFzZSh2YXJzLmVhc2UpLFxuICAgICAgZnJvbSA9IHZhcnMuZnJvbSB8fCAwLFxuICAgICAgYmFzZSA9IHBhcnNlRmxvYXQodmFycy5iYXNlKSB8fCAwLFxuICAgICAgY2FjaGUgPSB7fSxcbiAgICAgIGlzRGVjaW1hbCA9IGZyb20gPiAwICYmIGZyb20gPCAxLFxuICAgICAgcmF0aW9zID0gaXNOYU4oZnJvbSkgfHwgaXNEZWNpbWFsLFxuICAgICAgYXhpcyA9IHZhcnMuYXhpcyxcbiAgICAgIHJhdGlvWCA9IGZyb20sXG4gICAgICByYXRpb1kgPSBmcm9tO1xuXG4gIGlmIChfaXNTdHJpbmcoZnJvbSkpIHtcbiAgICByYXRpb1ggPSByYXRpb1kgPSB7XG4gICAgICBjZW50ZXI6IC41LFxuICAgICAgZWRnZXM6IC41LFxuICAgICAgZW5kOiAxXG4gICAgfVtmcm9tXSB8fCAwO1xuICB9IGVsc2UgaWYgKCFpc0RlY2ltYWwgJiYgcmF0aW9zKSB7XG4gICAgcmF0aW9YID0gZnJvbVswXTtcbiAgICByYXRpb1kgPSBmcm9tWzFdO1xuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIChpLCB0YXJnZXQsIGEpIHtcbiAgICB2YXIgbCA9IChhIHx8IHZhcnMpLmxlbmd0aCxcbiAgICAgICAgZGlzdGFuY2VzID0gY2FjaGVbbF0sXG4gICAgICAgIG9yaWdpblgsXG4gICAgICAgIG9yaWdpblksXG4gICAgICAgIHgsXG4gICAgICAgIHksXG4gICAgICAgIGQsXG4gICAgICAgIGosXG4gICAgICAgIG1heCxcbiAgICAgICAgbWluLFxuICAgICAgICB3cmFwQXQ7XG5cbiAgICBpZiAoIWRpc3RhbmNlcykge1xuICAgICAgd3JhcEF0ID0gdmFycy5ncmlkID09PSBcImF1dG9cIiA/IDAgOiAodmFycy5ncmlkIHx8IFsxLCBfYmlnTnVtXSlbMV07XG5cbiAgICAgIGlmICghd3JhcEF0KSB7XG4gICAgICAgIG1heCA9IC1fYmlnTnVtO1xuXG4gICAgICAgIHdoaWxlIChtYXggPCAobWF4ID0gYVt3cmFwQXQrK10uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkubGVmdCkgJiYgd3JhcEF0IDwgbCkge31cblxuICAgICAgICB3cmFwQXQtLTtcbiAgICAgIH1cblxuICAgICAgZGlzdGFuY2VzID0gY2FjaGVbbF0gPSBbXTtcbiAgICAgIG9yaWdpblggPSByYXRpb3MgPyBNYXRoLm1pbih3cmFwQXQsIGwpICogcmF0aW9YIC0gLjUgOiBmcm9tICUgd3JhcEF0O1xuICAgICAgb3JpZ2luWSA9IHdyYXBBdCA9PT0gX2JpZ051bSA/IDAgOiByYXRpb3MgPyBsICogcmF0aW9ZIC8gd3JhcEF0IC0gLjUgOiBmcm9tIC8gd3JhcEF0IHwgMDtcbiAgICAgIG1heCA9IDA7XG4gICAgICBtaW4gPSBfYmlnTnVtO1xuXG4gICAgICBmb3IgKGogPSAwOyBqIDwgbDsgaisrKSB7XG4gICAgICAgIHggPSBqICUgd3JhcEF0IC0gb3JpZ2luWDtcbiAgICAgICAgeSA9IG9yaWdpblkgLSAoaiAvIHdyYXBBdCB8IDApO1xuICAgICAgICBkaXN0YW5jZXNbal0gPSBkID0gIWF4aXMgPyBfc3FydCh4ICogeCArIHkgKiB5KSA6IE1hdGguYWJzKGF4aXMgPT09IFwieVwiID8geSA6IHgpO1xuICAgICAgICBkID4gbWF4ICYmIChtYXggPSBkKTtcbiAgICAgICAgZCA8IG1pbiAmJiAobWluID0gZCk7XG4gICAgICB9XG5cbiAgICAgIGZyb20gPT09IFwicmFuZG9tXCIgJiYgc2h1ZmZsZShkaXN0YW5jZXMpO1xuICAgICAgZGlzdGFuY2VzLm1heCA9IG1heCAtIG1pbjtcbiAgICAgIGRpc3RhbmNlcy5taW4gPSBtaW47XG4gICAgICBkaXN0YW5jZXMudiA9IGwgPSAocGFyc2VGbG9hdCh2YXJzLmFtb3VudCkgfHwgcGFyc2VGbG9hdCh2YXJzLmVhY2gpICogKHdyYXBBdCA+IGwgPyBsIC0gMSA6ICFheGlzID8gTWF0aC5tYXgod3JhcEF0LCBsIC8gd3JhcEF0KSA6IGF4aXMgPT09IFwieVwiID8gbCAvIHdyYXBBdCA6IHdyYXBBdCkgfHwgMCkgKiAoZnJvbSA9PT0gXCJlZGdlc1wiID8gLTEgOiAxKTtcbiAgICAgIGRpc3RhbmNlcy5iID0gbCA8IDAgPyBiYXNlIC0gbCA6IGJhc2U7XG4gICAgICBkaXN0YW5jZXMudSA9IGdldFVuaXQodmFycy5hbW91bnQgfHwgdmFycy5lYWNoKSB8fCAwOyAvL3VuaXRcblxuICAgICAgZWFzZSA9IGVhc2UgJiYgbCA8IDAgPyBfaW52ZXJ0RWFzZShlYXNlKSA6IGVhc2U7XG4gICAgfVxuXG4gICAgbCA9IChkaXN0YW5jZXNbaV0gLSBkaXN0YW5jZXMubWluKSAvIGRpc3RhbmNlcy5tYXggfHwgMDtcbiAgICByZXR1cm4gX3JvdW5kUHJlY2lzZShkaXN0YW5jZXMuYiArIChlYXNlID8gZWFzZShsKSA6IGwpICogZGlzdGFuY2VzLnYpICsgZGlzdGFuY2VzLnU7IC8vcm91bmQgaW4gb3JkZXIgdG8gd29yayBhcm91bmQgZmxvYXRpbmcgcG9pbnQgZXJyb3JzXG4gIH07XG59LFxuICAgIF9yb3VuZE1vZGlmaWVyID0gZnVuY3Rpb24gX3JvdW5kTW9kaWZpZXIodikge1xuICAvL3Bhc3MgaW4gMC4xIGdldCBhIGZ1bmN0aW9uIHRoYXQnbGwgcm91bmQgdG8gdGhlIG5lYXJlc3QgdGVudGgsIG9yIDUgdG8gcm91bmQgdG8gdGhlIGNsb3Nlc3QgNSwgb3IgMC4wMDEgdG8gdGhlIGNsb3Nlc3QgMTAwMHRoLCBldGMuXG4gIHZhciBwID0gTWF0aC5wb3coMTAsICgodiArIFwiXCIpLnNwbGl0KFwiLlwiKVsxXSB8fCBcIlwiKS5sZW5ndGgpOyAvL3RvIGF2b2lkIGZsb2F0aW5nIHBvaW50IG1hdGggZXJyb3JzIChsaWtlIDI0ICogMC4xID09IDIuNDAwMDAwMDAwMDAwMDAwNCksIHdlIGNob3Agb2ZmIGF0IGEgc3BlY2lmaWMgbnVtYmVyIG9mIGRlY2ltYWwgcGxhY2VzIChtdWNoIGZhc3RlciB0aGFuIHRvRml4ZWQoKSlcblxuICByZXR1cm4gZnVuY3Rpb24gKHJhdykge1xuICAgIHZhciBuID0gTWF0aC5yb3VuZChwYXJzZUZsb2F0KHJhdykgLyB2KSAqIHYgKiBwO1xuICAgIHJldHVybiAobiAtIG4gJSAxKSAvIHAgKyAoX2lzTnVtYmVyKHJhdykgPyAwIDogZ2V0VW5pdChyYXcpKTsgLy8gbiAtIG4gJSAxIHJlcGxhY2VzIE1hdGguZmxvb3IoKSBpbiBvcmRlciB0byBoYW5kbGUgbmVnYXRpdmUgdmFsdWVzIHByb3Blcmx5LiBGb3IgZXhhbXBsZSwgTWF0aC5mbG9vcigtMTUwLjAwMDAwMDAwMDAwMDAzKSBpcyAxNTEhXG4gIH07XG59LFxuICAgIHNuYXAgPSBmdW5jdGlvbiBzbmFwKHNuYXBUbywgdmFsdWUpIHtcbiAgdmFyIGlzQXJyYXkgPSBfaXNBcnJheShzbmFwVG8pLFxuICAgICAgcmFkaXVzLFxuICAgICAgaXMyRDtcblxuICBpZiAoIWlzQXJyYXkgJiYgX2lzT2JqZWN0KHNuYXBUbykpIHtcbiAgICByYWRpdXMgPSBpc0FycmF5ID0gc25hcFRvLnJhZGl1cyB8fCBfYmlnTnVtO1xuXG4gICAgaWYgKHNuYXBUby52YWx1ZXMpIHtcbiAgICAgIHNuYXBUbyA9IHRvQXJyYXkoc25hcFRvLnZhbHVlcyk7XG5cbiAgICAgIGlmIChpczJEID0gIV9pc051bWJlcihzbmFwVG9bMF0pKSB7XG4gICAgICAgIHJhZGl1cyAqPSByYWRpdXM7IC8vcGVyZm9ybWFuY2Ugb3B0aW1pemF0aW9uIHNvIHdlIGRvbid0IGhhdmUgdG8gTWF0aC5zcXJ0KCkgaW4gdGhlIGxvb3AuXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHNuYXBUbyA9IF9yb3VuZE1vZGlmaWVyKHNuYXBUby5pbmNyZW1lbnQpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBfY29uZGl0aW9uYWxSZXR1cm4odmFsdWUsICFpc0FycmF5ID8gX3JvdW5kTW9kaWZpZXIoc25hcFRvKSA6IF9pc0Z1bmN0aW9uKHNuYXBUbykgPyBmdW5jdGlvbiAocmF3KSB7XG4gICAgaXMyRCA9IHNuYXBUbyhyYXcpO1xuICAgIHJldHVybiBNYXRoLmFicyhpczJEIC0gcmF3KSA8PSByYWRpdXMgPyBpczJEIDogcmF3O1xuICB9IDogZnVuY3Rpb24gKHJhdykge1xuICAgIHZhciB4ID0gcGFyc2VGbG9hdChpczJEID8gcmF3LnggOiByYXcpLFxuICAgICAgICB5ID0gcGFyc2VGbG9hdChpczJEID8gcmF3LnkgOiAwKSxcbiAgICAgICAgbWluID0gX2JpZ051bSxcbiAgICAgICAgY2xvc2VzdCA9IDAsXG4gICAgICAgIGkgPSBzbmFwVG8ubGVuZ3RoLFxuICAgICAgICBkeCxcbiAgICAgICAgZHk7XG5cbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICBpZiAoaXMyRCkge1xuICAgICAgICBkeCA9IHNuYXBUb1tpXS54IC0geDtcbiAgICAgICAgZHkgPSBzbmFwVG9baV0ueSAtIHk7XG4gICAgICAgIGR4ID0gZHggKiBkeCArIGR5ICogZHk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkeCA9IE1hdGguYWJzKHNuYXBUb1tpXSAtIHgpO1xuICAgICAgfVxuXG4gICAgICBpZiAoZHggPCBtaW4pIHtcbiAgICAgICAgbWluID0gZHg7XG4gICAgICAgIGNsb3Nlc3QgPSBpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNsb3Nlc3QgPSAhcmFkaXVzIHx8IG1pbiA8PSByYWRpdXMgPyBzbmFwVG9bY2xvc2VzdF0gOiByYXc7XG4gICAgcmV0dXJuIGlzMkQgfHwgY2xvc2VzdCA9PT0gcmF3IHx8IF9pc051bWJlcihyYXcpID8gY2xvc2VzdCA6IGNsb3Nlc3QgKyBnZXRVbml0KHJhdyk7XG4gIH0pO1xufSxcbiAgICByYW5kb20gPSBmdW5jdGlvbiByYW5kb20obWluLCBtYXgsIHJvdW5kaW5nSW5jcmVtZW50LCByZXR1cm5GdW5jdGlvbikge1xuICByZXR1cm4gX2NvbmRpdGlvbmFsUmV0dXJuKF9pc0FycmF5KG1pbikgPyAhbWF4IDogcm91bmRpbmdJbmNyZW1lbnQgPT09IHRydWUgPyAhIShyb3VuZGluZ0luY3JlbWVudCA9IDApIDogIXJldHVybkZ1bmN0aW9uLCBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF9pc0FycmF5KG1pbikgPyBtaW5bfn4oTWF0aC5yYW5kb20oKSAqIG1pbi5sZW5ndGgpXSA6IChyb3VuZGluZ0luY3JlbWVudCA9IHJvdW5kaW5nSW5jcmVtZW50IHx8IDFlLTUpICYmIChyZXR1cm5GdW5jdGlvbiA9IHJvdW5kaW5nSW5jcmVtZW50IDwgMSA/IE1hdGgucG93KDEwLCAocm91bmRpbmdJbmNyZW1lbnQgKyBcIlwiKS5sZW5ndGggLSAyKSA6IDEpICYmIE1hdGguZmxvb3IoTWF0aC5yb3VuZCgobWluIC0gcm91bmRpbmdJbmNyZW1lbnQgLyAyICsgTWF0aC5yYW5kb20oKSAqIChtYXggLSBtaW4gKyByb3VuZGluZ0luY3JlbWVudCAqIC45OSkpIC8gcm91bmRpbmdJbmNyZW1lbnQpICogcm91bmRpbmdJbmNyZW1lbnQgKiByZXR1cm5GdW5jdGlvbikgLyByZXR1cm5GdW5jdGlvbjtcbiAgfSk7XG59LFxuICAgIHBpcGUgPSBmdW5jdGlvbiBwaXBlKCkge1xuICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgZnVuY3Rpb25zID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgIGZ1bmN0aW9uc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICByZXR1cm4gZnVuY3Rpb25zLnJlZHVjZShmdW5jdGlvbiAodiwgZikge1xuICAgICAgcmV0dXJuIGYodik7XG4gICAgfSwgdmFsdWUpO1xuICB9O1xufSxcbiAgICB1bml0aXplID0gZnVuY3Rpb24gdW5pdGl6ZShmdW5jLCB1bml0KSB7XG4gIHJldHVybiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICByZXR1cm4gZnVuYyhwYXJzZUZsb2F0KHZhbHVlKSkgKyAodW5pdCB8fCBnZXRVbml0KHZhbHVlKSk7XG4gIH07XG59LFxuICAgIG5vcm1hbGl6ZSA9IGZ1bmN0aW9uIG5vcm1hbGl6ZShtaW4sIG1heCwgdmFsdWUpIHtcbiAgcmV0dXJuIG1hcFJhbmdlKG1pbiwgbWF4LCAwLCAxLCB2YWx1ZSk7XG59LFxuICAgIF93cmFwQXJyYXkgPSBmdW5jdGlvbiBfd3JhcEFycmF5KGEsIHdyYXBwZXIsIHZhbHVlKSB7XG4gIHJldHVybiBfY29uZGl0aW9uYWxSZXR1cm4odmFsdWUsIGZ1bmN0aW9uIChpbmRleCkge1xuICAgIHJldHVybiBhW35+d3JhcHBlcihpbmRleCldO1xuICB9KTtcbn0sXG4gICAgd3JhcCA9IGZ1bmN0aW9uIHdyYXAobWluLCBtYXgsIHZhbHVlKSB7XG4gIC8vIE5PVEU6IHdyYXAoKSBDQU5OT1QgYmUgYW4gYXJyb3cgZnVuY3Rpb24hIEEgdmVyeSBvZGQgY29tcGlsaW5nIGJ1ZyBjYXVzZXMgcHJvYmxlbXMgKHVucmVsYXRlZCB0byBHU0FQKS5cbiAgdmFyIHJhbmdlID0gbWF4IC0gbWluO1xuICByZXR1cm4gX2lzQXJyYXkobWluKSA/IF93cmFwQXJyYXkobWluLCB3cmFwKDAsIG1pbi5sZW5ndGgpLCBtYXgpIDogX2NvbmRpdGlvbmFsUmV0dXJuKHZhbHVlLCBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICByZXR1cm4gKHJhbmdlICsgKHZhbHVlIC0gbWluKSAlIHJhbmdlKSAlIHJhbmdlICsgbWluO1xuICB9KTtcbn0sXG4gICAgd3JhcFlveW8gPSBmdW5jdGlvbiB3cmFwWW95byhtaW4sIG1heCwgdmFsdWUpIHtcbiAgdmFyIHJhbmdlID0gbWF4IC0gbWluLFxuICAgICAgdG90YWwgPSByYW5nZSAqIDI7XG4gIHJldHVybiBfaXNBcnJheShtaW4pID8gX3dyYXBBcnJheShtaW4sIHdyYXBZb3lvKDAsIG1pbi5sZW5ndGggLSAxKSwgbWF4KSA6IF9jb25kaXRpb25hbFJldHVybih2YWx1ZSwgZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgdmFsdWUgPSAodG90YWwgKyAodmFsdWUgLSBtaW4pICUgdG90YWwpICUgdG90YWwgfHwgMDtcbiAgICByZXR1cm4gbWluICsgKHZhbHVlID4gcmFuZ2UgPyB0b3RhbCAtIHZhbHVlIDogdmFsdWUpO1xuICB9KTtcbn0sXG4gICAgX3JlcGxhY2VSYW5kb20gPSBmdW5jdGlvbiBfcmVwbGFjZVJhbmRvbSh2YWx1ZSkge1xuICAvL3JlcGxhY2VzIGFsbCBvY2N1cnJlbmNlcyBvZiByYW5kb20oLi4uKSBpbiBhIHN0cmluZyB3aXRoIHRoZSBjYWxjdWxhdGVkIHJhbmRvbSB2YWx1ZS4gY2FuIGJlIGEgcmFuZ2UgbGlrZSByYW5kb20oLTEwMCwgMTAwLCA1KSBvciBhbiBhcnJheSBsaWtlIHJhbmRvbShbMCwgMTAwLCA1MDBdKVxuICB2YXIgcHJldiA9IDAsXG4gICAgICBzID0gXCJcIixcbiAgICAgIGksXG4gICAgICBudW1zLFxuICAgICAgZW5kLFxuICAgICAgaXNBcnJheTtcblxuICB3aGlsZSAofihpID0gdmFsdWUuaW5kZXhPZihcInJhbmRvbShcIiwgcHJldikpKSB7XG4gICAgZW5kID0gdmFsdWUuaW5kZXhPZihcIilcIiwgaSk7XG4gICAgaXNBcnJheSA9IHZhbHVlLmNoYXJBdChpICsgNykgPT09IFwiW1wiO1xuICAgIG51bXMgPSB2YWx1ZS5zdWJzdHIoaSArIDcsIGVuZCAtIGkgLSA3KS5tYXRjaChpc0FycmF5ID8gX2RlbGltaXRlZFZhbHVlRXhwIDogX3N0cmljdE51bUV4cCk7XG4gICAgcyArPSB2YWx1ZS5zdWJzdHIocHJldiwgaSAtIHByZXYpICsgcmFuZG9tKGlzQXJyYXkgPyBudW1zIDogK251bXNbMF0sIGlzQXJyYXkgPyAwIDogK251bXNbMV0sICtudW1zWzJdIHx8IDFlLTUpO1xuICAgIHByZXYgPSBlbmQgKyAxO1xuICB9XG5cbiAgcmV0dXJuIHMgKyB2YWx1ZS5zdWJzdHIocHJldiwgdmFsdWUubGVuZ3RoIC0gcHJldik7XG59LFxuICAgIG1hcFJhbmdlID0gZnVuY3Rpb24gbWFwUmFuZ2UoaW5NaW4sIGluTWF4LCBvdXRNaW4sIG91dE1heCwgdmFsdWUpIHtcbiAgdmFyIGluUmFuZ2UgPSBpbk1heCAtIGluTWluLFxuICAgICAgb3V0UmFuZ2UgPSBvdXRNYXggLSBvdXRNaW47XG4gIHJldHVybiBfY29uZGl0aW9uYWxSZXR1cm4odmFsdWUsIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIHJldHVybiBvdXRNaW4gKyAoKHZhbHVlIC0gaW5NaW4pIC8gaW5SYW5nZSAqIG91dFJhbmdlIHx8IDApO1xuICB9KTtcbn0sXG4gICAgaW50ZXJwb2xhdGUgPSBmdW5jdGlvbiBpbnRlcnBvbGF0ZShzdGFydCwgZW5kLCBwcm9ncmVzcywgbXV0YXRlKSB7XG4gIHZhciBmdW5jID0gaXNOYU4oc3RhcnQgKyBlbmQpID8gMCA6IGZ1bmN0aW9uIChwKSB7XG4gICAgcmV0dXJuICgxIC0gcCkgKiBzdGFydCArIHAgKiBlbmQ7XG4gIH07XG5cbiAgaWYgKCFmdW5jKSB7XG4gICAgdmFyIGlzU3RyaW5nID0gX2lzU3RyaW5nKHN0YXJ0KSxcbiAgICAgICAgbWFzdGVyID0ge30sXG4gICAgICAgIHAsXG4gICAgICAgIGksXG4gICAgICAgIGludGVycG9sYXRvcnMsXG4gICAgICAgIGwsXG4gICAgICAgIGlsO1xuXG4gICAgcHJvZ3Jlc3MgPT09IHRydWUgJiYgKG11dGF0ZSA9IDEpICYmIChwcm9ncmVzcyA9IG51bGwpO1xuXG4gICAgaWYgKGlzU3RyaW5nKSB7XG4gICAgICBzdGFydCA9IHtcbiAgICAgICAgcDogc3RhcnRcbiAgICAgIH07XG4gICAgICBlbmQgPSB7XG4gICAgICAgIHA6IGVuZFxuICAgICAgfTtcbiAgICB9IGVsc2UgaWYgKF9pc0FycmF5KHN0YXJ0KSAmJiAhX2lzQXJyYXkoZW5kKSkge1xuICAgICAgaW50ZXJwb2xhdG9ycyA9IFtdO1xuICAgICAgbCA9IHN0YXJ0Lmxlbmd0aDtcbiAgICAgIGlsID0gbCAtIDI7XG5cbiAgICAgIGZvciAoaSA9IDE7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgaW50ZXJwb2xhdG9ycy5wdXNoKGludGVycG9sYXRlKHN0YXJ0W2kgLSAxXSwgc3RhcnRbaV0pKTsgLy9idWlsZCB0aGUgaW50ZXJwb2xhdG9ycyB1cCBmcm9udCBhcyBhIHBlcmZvcm1hbmNlIG9wdGltaXphdGlvbiBzbyB0aGF0IHdoZW4gdGhlIGZ1bmN0aW9uIGlzIGNhbGxlZCBtYW55IHRpbWVzLCBpdCBjYW4ganVzdCByZXVzZSB0aGVtLlxuICAgICAgfVxuXG4gICAgICBsLS07XG5cbiAgICAgIGZ1bmMgPSBmdW5jdGlvbiBmdW5jKHApIHtcbiAgICAgICAgcCAqPSBsO1xuICAgICAgICB2YXIgaSA9IE1hdGgubWluKGlsLCB+fnApO1xuICAgICAgICByZXR1cm4gaW50ZXJwb2xhdG9yc1tpXShwIC0gaSk7XG4gICAgICB9O1xuXG4gICAgICBwcm9ncmVzcyA9IGVuZDtcbiAgICB9IGVsc2UgaWYgKCFtdXRhdGUpIHtcbiAgICAgIHN0YXJ0ID0gX21lcmdlKF9pc0FycmF5KHN0YXJ0KSA/IFtdIDoge30sIHN0YXJ0KTtcbiAgICB9XG5cbiAgICBpZiAoIWludGVycG9sYXRvcnMpIHtcbiAgICAgIGZvciAocCBpbiBlbmQpIHtcbiAgICAgICAgX2FkZFByb3BUd2Vlbi5jYWxsKG1hc3Rlciwgc3RhcnQsIHAsIFwiZ2V0XCIsIGVuZFtwXSk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmMgPSBmdW5jdGlvbiBmdW5jKHApIHtcbiAgICAgICAgcmV0dXJuIF9yZW5kZXJQcm9wVHdlZW5zKHAsIG1hc3RlcikgfHwgKGlzU3RyaW5nID8gc3RhcnQucCA6IHN0YXJ0KTtcbiAgICAgIH07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIF9jb25kaXRpb25hbFJldHVybihwcm9ncmVzcywgZnVuYyk7XG59LFxuICAgIF9nZXRMYWJlbEluRGlyZWN0aW9uID0gZnVuY3Rpb24gX2dldExhYmVsSW5EaXJlY3Rpb24odGltZWxpbmUsIGZyb21UaW1lLCBiYWNrd2FyZCkge1xuICAvL3VzZWQgZm9yIG5leHRMYWJlbCgpIGFuZCBwcmV2aW91c0xhYmVsKClcbiAgdmFyIGxhYmVscyA9IHRpbWVsaW5lLmxhYmVscyxcbiAgICAgIG1pbiA9IF9iaWdOdW0sXG4gICAgICBwLFxuICAgICAgZGlzdGFuY2UsXG4gICAgICBsYWJlbDtcblxuICBmb3IgKHAgaW4gbGFiZWxzKSB7XG4gICAgZGlzdGFuY2UgPSBsYWJlbHNbcF0gLSBmcm9tVGltZTtcblxuICAgIGlmIChkaXN0YW5jZSA8IDAgPT09ICEhYmFja3dhcmQgJiYgZGlzdGFuY2UgJiYgbWluID4gKGRpc3RhbmNlID0gTWF0aC5hYnMoZGlzdGFuY2UpKSkge1xuICAgICAgbGFiZWwgPSBwO1xuICAgICAgbWluID0gZGlzdGFuY2U7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGxhYmVsO1xufSxcbiAgICBfY2FsbGJhY2sgPSBmdW5jdGlvbiBfY2FsbGJhY2soYW5pbWF0aW9uLCB0eXBlLCBleGVjdXRlTGF6eUZpcnN0KSB7XG4gIHZhciB2ID0gYW5pbWF0aW9uLnZhcnMsXG4gICAgICBjYWxsYmFjayA9IHZbdHlwZV0sXG4gICAgICBwYXJhbXMsXG4gICAgICBzY29wZTtcblxuICBpZiAoIWNhbGxiYWNrKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgcGFyYW1zID0gdlt0eXBlICsgXCJQYXJhbXNcIl07XG4gIHNjb3BlID0gdi5jYWxsYmFja1Njb3BlIHx8IGFuaW1hdGlvbjtcbiAgZXhlY3V0ZUxhenlGaXJzdCAmJiBfbGF6eVR3ZWVucy5sZW5ndGggJiYgX2xhenlSZW5kZXIoKTsgLy9pbiBjYXNlIHJlbmRlcmluZyBjYXVzZWQgYW55IHR3ZWVucyB0byBsYXp5LWluaXQsIHdlIHNob3VsZCByZW5kZXIgdGhlbSBiZWNhdXNlIHR5cGljYWxseSB3aGVuIGEgdGltZWxpbmUgZmluaXNoZXMsIHVzZXJzIGV4cGVjdCB0aGluZ3MgdG8gaGF2ZSByZW5kZXJlZCBmdWxseS4gSW1hZ2luZSBhbiBvblVwZGF0ZSBvbiBhIHRpbWVsaW5lIHRoYXQgcmVwb3J0cy9jaGVja3MgdHdlZW5lZCB2YWx1ZXMuXG5cbiAgcmV0dXJuIHBhcmFtcyA/IGNhbGxiYWNrLmFwcGx5KHNjb3BlLCBwYXJhbXMpIDogY2FsbGJhY2suY2FsbChzY29wZSk7XG59LFxuICAgIF9pbnRlcnJ1cHQgPSBmdW5jdGlvbiBfaW50ZXJydXB0KGFuaW1hdGlvbikge1xuICBfcmVtb3ZlRnJvbVBhcmVudChhbmltYXRpb24pO1xuXG4gIGFuaW1hdGlvbi5zY3JvbGxUcmlnZ2VyICYmIGFuaW1hdGlvbi5zY3JvbGxUcmlnZ2VyLmtpbGwoZmFsc2UpO1xuICBhbmltYXRpb24ucHJvZ3Jlc3MoKSA8IDEgJiYgX2NhbGxiYWNrKGFuaW1hdGlvbiwgXCJvbkludGVycnVwdFwiKTtcbiAgcmV0dXJuIGFuaW1hdGlvbjtcbn0sXG4gICAgX3F1aWNrVHdlZW4sXG4gICAgX2NyZWF0ZVBsdWdpbiA9IGZ1bmN0aW9uIF9jcmVhdGVQbHVnaW4oY29uZmlnKSB7XG4gIGNvbmZpZyA9ICFjb25maWcubmFtZSAmJiBjb25maWdbXCJkZWZhdWx0XCJdIHx8IGNvbmZpZzsgLy9VTUQgcGFja2FnaW5nIHdyYXBzIHRoaW5ncyBvZGRseSwgc28gZm9yIGV4YW1wbGUgTW90aW9uUGF0aEhlbHBlciBiZWNvbWVzIHtNb3Rpb25QYXRoSGVscGVyOk1vdGlvblBhdGhIZWxwZXIsIGRlZmF1bHQ6TW90aW9uUGF0aEhlbHBlcn0uXG5cbiAgdmFyIG5hbWUgPSBjb25maWcubmFtZSxcbiAgICAgIGlzRnVuYyA9IF9pc0Z1bmN0aW9uKGNvbmZpZyksXG4gICAgICBQbHVnaW4gPSBuYW1lICYmICFpc0Z1bmMgJiYgY29uZmlnLmluaXQgPyBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5fcHJvcHMgPSBbXTtcbiAgfSA6IGNvbmZpZyxcbiAgICAgIC8vaW4gY2FzZSBzb21lb25lIHBhc3NlcyBpbiBhbiBvYmplY3QgdGhhdCdzIG5vdCBhIHBsdWdpbiwgbGlrZSBDdXN0b21FYXNlXG4gIGluc3RhbmNlRGVmYXVsdHMgPSB7XG4gICAgaW5pdDogX2VtcHR5RnVuYyxcbiAgICByZW5kZXI6IF9yZW5kZXJQcm9wVHdlZW5zLFxuICAgIGFkZDogX2FkZFByb3BUd2VlbixcbiAgICBraWxsOiBfa2lsbFByb3BUd2VlbnNPZixcbiAgICBtb2RpZmllcjogX2FkZFBsdWdpbk1vZGlmaWVyLFxuICAgIHJhd1ZhcnM6IDBcbiAgfSxcbiAgICAgIHN0YXRpY3MgPSB7XG4gICAgdGFyZ2V0VGVzdDogMCxcbiAgICBnZXQ6IDAsXG4gICAgZ2V0U2V0dGVyOiBfZ2V0U2V0dGVyLFxuICAgIGFsaWFzZXM6IHt9LFxuICAgIHJlZ2lzdGVyOiAwXG4gIH07XG5cbiAgX3dha2UoKTtcblxuICBpZiAoY29uZmlnICE9PSBQbHVnaW4pIHtcbiAgICBpZiAoX3BsdWdpbnNbbmFtZV0pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBfc2V0RGVmYXVsdHMoUGx1Z2luLCBfc2V0RGVmYXVsdHMoX2NvcHlFeGNsdWRpbmcoY29uZmlnLCBpbnN0YW5jZURlZmF1bHRzKSwgc3RhdGljcykpOyAvL3N0YXRpYyBtZXRob2RzXG5cblxuICAgIF9tZXJnZShQbHVnaW4ucHJvdG90eXBlLCBfbWVyZ2UoaW5zdGFuY2VEZWZhdWx0cywgX2NvcHlFeGNsdWRpbmcoY29uZmlnLCBzdGF0aWNzKSkpOyAvL2luc3RhbmNlIG1ldGhvZHNcblxuXG4gICAgX3BsdWdpbnNbUGx1Z2luLnByb3AgPSBuYW1lXSA9IFBsdWdpbjtcblxuICAgIGlmIChjb25maWcudGFyZ2V0VGVzdCkge1xuICAgICAgX2hhcm5lc3NQbHVnaW5zLnB1c2goUGx1Z2luKTtcblxuICAgICAgX3Jlc2VydmVkUHJvcHNbbmFtZV0gPSAxO1xuICAgIH1cblxuICAgIG5hbWUgPSAobmFtZSA9PT0gXCJjc3NcIiA/IFwiQ1NTXCIgOiBuYW1lLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgbmFtZS5zdWJzdHIoMSkpICsgXCJQbHVnaW5cIjsgLy9mb3IgdGhlIGdsb2JhbCBuYW1lLiBcIm1vdGlvblBhdGhcIiBzaG91bGQgYmVjb21lIE1vdGlvblBhdGhQbHVnaW5cbiAgfVxuXG4gIF9hZGRHbG9iYWwobmFtZSwgUGx1Z2luKTtcblxuICBjb25maWcucmVnaXN0ZXIgJiYgY29uZmlnLnJlZ2lzdGVyKGdzYXAsIFBsdWdpbiwgUHJvcFR3ZWVuKTtcbn0sXG5cbi8qXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogQ09MT1JTXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICovXG5fMjU1ID0gMjU1LFxuICAgIF9jb2xvckxvb2t1cCA9IHtcbiAgYXF1YTogWzAsIF8yNTUsIF8yNTVdLFxuICBsaW1lOiBbMCwgXzI1NSwgMF0sXG4gIHNpbHZlcjogWzE5MiwgMTkyLCAxOTJdLFxuICBibGFjazogWzAsIDAsIDBdLFxuICBtYXJvb246IFsxMjgsIDAsIDBdLFxuICB0ZWFsOiBbMCwgMTI4LCAxMjhdLFxuICBibHVlOiBbMCwgMCwgXzI1NV0sXG4gIG5hdnk6IFswLCAwLCAxMjhdLFxuICB3aGl0ZTogW18yNTUsIF8yNTUsIF8yNTVdLFxuICBvbGl2ZTogWzEyOCwgMTI4LCAwXSxcbiAgeWVsbG93OiBbXzI1NSwgXzI1NSwgMF0sXG4gIG9yYW5nZTogW18yNTUsIDE2NSwgMF0sXG4gIGdyYXk6IFsxMjgsIDEyOCwgMTI4XSxcbiAgcHVycGxlOiBbMTI4LCAwLCAxMjhdLFxuICBncmVlbjogWzAsIDEyOCwgMF0sXG4gIHJlZDogW18yNTUsIDAsIDBdLFxuICBwaW5rOiBbXzI1NSwgMTkyLCAyMDNdLFxuICBjeWFuOiBbMCwgXzI1NSwgXzI1NV0sXG4gIHRyYW5zcGFyZW50OiBbXzI1NSwgXzI1NSwgXzI1NSwgMF1cbn0sXG4gICAgLy8gcG9zc2libGUgZnV0dXJlIGlkZWEgdG8gcmVwbGFjZSB0aGUgaGFyZC1jb2RlZCBjb2xvciBuYW1lIHZhbHVlcyAtIHB1dCB0aGlzIGluIHRoZSB0aWNrZXIud2FrZSgpIHdoZXJlIHdlIHNldCB0aGUgX2RvYzpcbi8vIGxldCBjdHggPSBfZG9jLmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIikuZ2V0Q29udGV4dChcIjJkXCIpO1xuLy8gX2ZvckVhY2hOYW1lKFwiYXF1YSxsaW1lLHNpbHZlcixibGFjayxtYXJvb24sdGVhbCxibHVlLG5hdnksd2hpdGUsb2xpdmUseWVsbG93LG9yYW5nZSxncmF5LHB1cnBsZSxncmVlbixyZWQscGluayxjeWFuXCIsIGNvbG9yID0+IHtjdHguZmlsbFN0eWxlID0gY29sb3I7IF9jb2xvckxvb2t1cFtjb2xvcl0gPSBzcGxpdENvbG9yKGN0eC5maWxsU3R5bGUpfSk7XG5faHVlID0gZnVuY3Rpb24gX2h1ZShoLCBtMSwgbTIpIHtcbiAgaCArPSBoIDwgMCA/IDEgOiBoID4gMSA/IC0xIDogMDtcbiAgcmV0dXJuIChoICogNiA8IDEgPyBtMSArIChtMiAtIG0xKSAqIGggKiA2IDogaCA8IC41ID8gbTIgOiBoICogMyA8IDIgPyBtMSArIChtMiAtIG0xKSAqICgyIC8gMyAtIGgpICogNiA6IG0xKSAqIF8yNTUgKyAuNSB8IDA7XG59LFxuICAgIHNwbGl0Q29sb3IgPSBmdW5jdGlvbiBzcGxpdENvbG9yKHYsIHRvSFNMLCBmb3JjZUFscGhhKSB7XG4gIHZhciBhID0gIXYgPyBfY29sb3JMb29rdXAuYmxhY2sgOiBfaXNOdW1iZXIodikgPyBbdiA+PiAxNiwgdiA+PiA4ICYgXzI1NSwgdiAmIF8yNTVdIDogMCxcbiAgICAgIHIsXG4gICAgICBnLFxuICAgICAgYixcbiAgICAgIGgsXG4gICAgICBzLFxuICAgICAgbCxcbiAgICAgIG1heCxcbiAgICAgIG1pbixcbiAgICAgIGQsXG4gICAgICB3YXNIU0w7XG5cbiAgaWYgKCFhKSB7XG4gICAgaWYgKHYuc3Vic3RyKC0xKSA9PT0gXCIsXCIpIHtcbiAgICAgIC8vc29tZXRpbWVzIGEgdHJhaWxpbmcgY29tbWEgaXMgaW5jbHVkZWQgYW5kIHdlIHNob3VsZCBjaG9wIGl0IG9mZiAodHlwaWNhbGx5IGZyb20gYSBjb21tYS1kZWxpbWl0ZWQgbGlzdCBvZiB2YWx1ZXMgbGlrZSBhIHRleHRTaGFkb3c6XCIycHggMnB4IDJweCBibHVlLCA1cHggNXB4IDVweCByZ2IoMjU1LDAsMClcIiAtIGluIHRoaXMgZXhhbXBsZSBcImJsdWUsXCIgaGFzIGEgdHJhaWxpbmcgY29tbWEuIFdlIGNvdWxkIHN0cmlwIGl0IG91dCBpbnNpZGUgcGFyc2VDb21wbGV4KCkgYnV0IHdlJ2QgbmVlZCB0byBkbyBpdCB0byB0aGUgYmVnaW5uaW5nIGFuZCBlbmRpbmcgdmFsdWVzIHBsdXMgaXQgd291bGRuJ3QgcHJvdmlkZSBwcm90ZWN0aW9uIGZyb20gb3RoZXIgcG90ZW50aWFsIHNjZW5hcmlvcyBsaWtlIGlmIHRoZSB1c2VyIHBhc3NlcyBpbiBhIHNpbWlsYXIgdmFsdWUuXG4gICAgICB2ID0gdi5zdWJzdHIoMCwgdi5sZW5ndGggLSAxKTtcbiAgICB9XG5cbiAgICBpZiAoX2NvbG9yTG9va3VwW3ZdKSB7XG4gICAgICBhID0gX2NvbG9yTG9va3VwW3ZdO1xuICAgIH0gZWxzZSBpZiAodi5jaGFyQXQoMCkgPT09IFwiI1wiKSB7XG4gICAgICBpZiAodi5sZW5ndGggPCA2KSB7XG4gICAgICAgIC8vZm9yIHNob3J0aGFuZCBsaWtlICM5RjAgb3IgIzlGMEYgKGNvdWxkIGhhdmUgYWxwaGEpXG4gICAgICAgIHIgPSB2LmNoYXJBdCgxKTtcbiAgICAgICAgZyA9IHYuY2hhckF0KDIpO1xuICAgICAgICBiID0gdi5jaGFyQXQoMyk7XG4gICAgICAgIHYgPSBcIiNcIiArIHIgKyByICsgZyArIGcgKyBiICsgYiArICh2Lmxlbmd0aCA9PT0gNSA/IHYuY2hhckF0KDQpICsgdi5jaGFyQXQoNCkgOiBcIlwiKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHYubGVuZ3RoID09PSA5KSB7XG4gICAgICAgIC8vIGhleCB3aXRoIGFscGhhLCBsaWtlICNmZDVlNTNmZlxuICAgICAgICBhID0gcGFyc2VJbnQodi5zdWJzdHIoMSwgNiksIDE2KTtcbiAgICAgICAgcmV0dXJuIFthID4+IDE2LCBhID4+IDggJiBfMjU1LCBhICYgXzI1NSwgcGFyc2VJbnQodi5zdWJzdHIoNyksIDE2KSAvIDI1NV07XG4gICAgICB9XG5cbiAgICAgIHYgPSBwYXJzZUludCh2LnN1YnN0cigxKSwgMTYpO1xuICAgICAgYSA9IFt2ID4+IDE2LCB2ID4+IDggJiBfMjU1LCB2ICYgXzI1NV07XG4gICAgfSBlbHNlIGlmICh2LnN1YnN0cigwLCAzKSA9PT0gXCJoc2xcIikge1xuICAgICAgYSA9IHdhc0hTTCA9IHYubWF0Y2goX3N0cmljdE51bUV4cCk7XG5cbiAgICAgIGlmICghdG9IU0wpIHtcbiAgICAgICAgaCA9ICthWzBdICUgMzYwIC8gMzYwO1xuICAgICAgICBzID0gK2FbMV0gLyAxMDA7XG4gICAgICAgIGwgPSArYVsyXSAvIDEwMDtcbiAgICAgICAgZyA9IGwgPD0gLjUgPyBsICogKHMgKyAxKSA6IGwgKyBzIC0gbCAqIHM7XG4gICAgICAgIHIgPSBsICogMiAtIGc7XG4gICAgICAgIGEubGVuZ3RoID4gMyAmJiAoYVszXSAqPSAxKTsgLy9jYXN0IGFzIG51bWJlclxuXG4gICAgICAgIGFbMF0gPSBfaHVlKGggKyAxIC8gMywgciwgZyk7XG4gICAgICAgIGFbMV0gPSBfaHVlKGgsIHIsIGcpO1xuICAgICAgICBhWzJdID0gX2h1ZShoIC0gMSAvIDMsIHIsIGcpO1xuICAgICAgfSBlbHNlIGlmICh+di5pbmRleE9mKFwiPVwiKSkge1xuICAgICAgICAvL2lmIHJlbGF0aXZlIHZhbHVlcyBhcmUgZm91bmQsIGp1c3QgcmV0dXJuIHRoZSByYXcgc3RyaW5ncyB3aXRoIHRoZSByZWxhdGl2ZSBwcmVmaXhlcyBpbiBwbGFjZS5cbiAgICAgICAgYSA9IHYubWF0Y2goX251bUV4cCk7XG4gICAgICAgIGZvcmNlQWxwaGEgJiYgYS5sZW5ndGggPCA0ICYmIChhWzNdID0gMSk7XG4gICAgICAgIHJldHVybiBhO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBhID0gdi5tYXRjaChfc3RyaWN0TnVtRXhwKSB8fCBfY29sb3JMb29rdXAudHJhbnNwYXJlbnQ7XG4gICAgfVxuXG4gICAgYSA9IGEubWFwKE51bWJlcik7XG4gIH1cblxuICBpZiAodG9IU0wgJiYgIXdhc0hTTCkge1xuICAgIHIgPSBhWzBdIC8gXzI1NTtcbiAgICBnID0gYVsxXSAvIF8yNTU7XG4gICAgYiA9IGFbMl0gLyBfMjU1O1xuICAgIG1heCA9IE1hdGgubWF4KHIsIGcsIGIpO1xuICAgIG1pbiA9IE1hdGgubWluKHIsIGcsIGIpO1xuICAgIGwgPSAobWF4ICsgbWluKSAvIDI7XG5cbiAgICBpZiAobWF4ID09PSBtaW4pIHtcbiAgICAgIGggPSBzID0gMDtcbiAgICB9IGVsc2Uge1xuICAgICAgZCA9IG1heCAtIG1pbjtcbiAgICAgIHMgPSBsID4gMC41ID8gZCAvICgyIC0gbWF4IC0gbWluKSA6IGQgLyAobWF4ICsgbWluKTtcbiAgICAgIGggPSBtYXggPT09IHIgPyAoZyAtIGIpIC8gZCArIChnIDwgYiA/IDYgOiAwKSA6IG1heCA9PT0gZyA/IChiIC0gcikgLyBkICsgMiA6IChyIC0gZykgLyBkICsgNDtcbiAgICAgIGggKj0gNjA7XG4gICAgfVxuXG4gICAgYVswXSA9IH5+KGggKyAuNSk7XG4gICAgYVsxXSA9IH5+KHMgKiAxMDAgKyAuNSk7XG4gICAgYVsyXSA9IH5+KGwgKiAxMDAgKyAuNSk7XG4gIH1cblxuICBmb3JjZUFscGhhICYmIGEubGVuZ3RoIDwgNCAmJiAoYVszXSA9IDEpO1xuICByZXR1cm4gYTtcbn0sXG4gICAgX2NvbG9yT3JkZXJEYXRhID0gZnVuY3Rpb24gX2NvbG9yT3JkZXJEYXRhKHYpIHtcbiAgLy8gc3RyaXBzIG91dCB0aGUgY29sb3JzIGZyb20gdGhlIHN0cmluZywgZmluZHMgYWxsIHRoZSBudW1lcmljIHNsb3RzICh3aXRoIHVuaXRzKSBhbmQgcmV0dXJucyBhbiBhcnJheSBvZiB0aG9zZS4gVGhlIEFycmF5IGFsc28gaGFzIGEgXCJjXCIgcHJvcGVydHkgd2hpY2ggaXMgYW4gQXJyYXkgb2YgdGhlIGluZGV4IHZhbHVlcyB3aGVyZSB0aGUgY29sb3JzIGJlbG9uZy4gVGhpcyBpcyB0byBoZWxwIHdvcmsgYXJvdW5kIGlzc3VlcyB3aGVyZSB0aGVyZSdzIGEgbWlzLW1hdGNoZWQgb3JkZXIgb2YgY29sb3IvbnVtZXJpYyBkYXRhIGxpa2UgZHJvcC1zaGFkb3coI2YwMCAwcHggMXB4IDJweCkgYW5kIGRyb3Atc2hhZG93KDB4IDFweCAycHggI2YwMCkuIFRoaXMgaXMgYmFzaWNhbGx5IGEgaGVscGVyIGZ1bmN0aW9uIHVzZWQgaW4gX2Zvcm1hdENvbG9ycygpXG4gIHZhciB2YWx1ZXMgPSBbXSxcbiAgICAgIGMgPSBbXSxcbiAgICAgIGkgPSAtMTtcbiAgdi5zcGxpdChfY29sb3JFeHApLmZvckVhY2goZnVuY3Rpb24gKHYpIHtcbiAgICB2YXIgYSA9IHYubWF0Y2goX251bVdpdGhVbml0RXhwKSB8fCBbXTtcbiAgICB2YWx1ZXMucHVzaC5hcHBseSh2YWx1ZXMsIGEpO1xuICAgIGMucHVzaChpICs9IGEubGVuZ3RoICsgMSk7XG4gIH0pO1xuICB2YWx1ZXMuYyA9IGM7XG4gIHJldHVybiB2YWx1ZXM7XG59LFxuICAgIF9mb3JtYXRDb2xvcnMgPSBmdW5jdGlvbiBfZm9ybWF0Q29sb3JzKHMsIHRvSFNMLCBvcmRlck1hdGNoRGF0YSkge1xuICB2YXIgcmVzdWx0ID0gXCJcIixcbiAgICAgIGNvbG9ycyA9IChzICsgcmVzdWx0KS5tYXRjaChfY29sb3JFeHApLFxuICAgICAgdHlwZSA9IHRvSFNMID8gXCJoc2xhKFwiIDogXCJyZ2JhKFwiLFxuICAgICAgaSA9IDAsXG4gICAgICBjLFxuICAgICAgc2hlbGwsXG4gICAgICBkLFxuICAgICAgbDtcblxuICBpZiAoIWNvbG9ycykge1xuICAgIHJldHVybiBzO1xuICB9XG5cbiAgY29sb3JzID0gY29sb3JzLm1hcChmdW5jdGlvbiAoY29sb3IpIHtcbiAgICByZXR1cm4gKGNvbG9yID0gc3BsaXRDb2xvcihjb2xvciwgdG9IU0wsIDEpKSAmJiB0eXBlICsgKHRvSFNMID8gY29sb3JbMF0gKyBcIixcIiArIGNvbG9yWzFdICsgXCIlLFwiICsgY29sb3JbMl0gKyBcIiUsXCIgKyBjb2xvclszXSA6IGNvbG9yLmpvaW4oXCIsXCIpKSArIFwiKVwiO1xuICB9KTtcblxuICBpZiAob3JkZXJNYXRjaERhdGEpIHtcbiAgICBkID0gX2NvbG9yT3JkZXJEYXRhKHMpO1xuICAgIGMgPSBvcmRlck1hdGNoRGF0YS5jO1xuXG4gICAgaWYgKGMuam9pbihyZXN1bHQpICE9PSBkLmMuam9pbihyZXN1bHQpKSB7XG4gICAgICBzaGVsbCA9IHMucmVwbGFjZShfY29sb3JFeHAsIFwiMVwiKS5zcGxpdChfbnVtV2l0aFVuaXRFeHApO1xuICAgICAgbCA9IHNoZWxsLmxlbmd0aCAtIDE7XG5cbiAgICAgIGZvciAoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIHJlc3VsdCArPSBzaGVsbFtpXSArICh+Yy5pbmRleE9mKGkpID8gY29sb3JzLnNoaWZ0KCkgfHwgdHlwZSArIFwiMCwwLDAsMClcIiA6IChkLmxlbmd0aCA/IGQgOiBjb2xvcnMubGVuZ3RoID8gY29sb3JzIDogb3JkZXJNYXRjaERhdGEpLnNoaWZ0KCkpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmICghc2hlbGwpIHtcbiAgICBzaGVsbCA9IHMuc3BsaXQoX2NvbG9yRXhwKTtcbiAgICBsID0gc2hlbGwubGVuZ3RoIC0gMTtcblxuICAgIGZvciAoOyBpIDwgbDsgaSsrKSB7XG4gICAgICByZXN1bHQgKz0gc2hlbGxbaV0gKyBjb2xvcnNbaV07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJlc3VsdCArIHNoZWxsW2xdO1xufSxcbiAgICBfY29sb3JFeHAgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBzID0gXCIoPzpcXFxcYig/Oig/OnJnYnxyZ2JhfGhzbHxoc2xhKVxcXFwoLis/XFxcXCkpfFxcXFxCIyg/OlswLTlhLWZdezMsNH0pezEsMn1cXFxcYlwiLFxuICAgICAgLy93ZSdsbCBkeW5hbWljYWxseSBidWlsZCB0aGlzIFJlZ3VsYXIgRXhwcmVzc2lvbiB0byBjb25zZXJ2ZSBmaWxlIHNpemUuIEFmdGVyIGJ1aWxkaW5nIGl0LCBpdCB3aWxsIGJlIGFibGUgdG8gZmluZCByZ2IoKSwgcmdiYSgpLCAjIChoZXhhZGVjaW1hbCksIGFuZCBuYW1lZCBjb2xvciB2YWx1ZXMgbGlrZSByZWQsIGJsdWUsIHB1cnBsZSwgZXRjLixcbiAgcDtcblxuICBmb3IgKHAgaW4gX2NvbG9yTG9va3VwKSB7XG4gICAgcyArPSBcInxcIiArIHAgKyBcIlxcXFxiXCI7XG4gIH1cblxuICByZXR1cm4gbmV3IFJlZ0V4cChzICsgXCIpXCIsIFwiZ2lcIik7XG59KCksXG4gICAgX2hzbEV4cCA9IC9oc2xbYV0/XFwoLyxcbiAgICBfY29sb3JTdHJpbmdGaWx0ZXIgPSBmdW5jdGlvbiBfY29sb3JTdHJpbmdGaWx0ZXIoYSkge1xuICB2YXIgY29tYmluZWQgPSBhLmpvaW4oXCIgXCIpLFxuICAgICAgdG9IU0w7XG4gIF9jb2xvckV4cC5sYXN0SW5kZXggPSAwO1xuXG4gIGlmIChfY29sb3JFeHAudGVzdChjb21iaW5lZCkpIHtcbiAgICB0b0hTTCA9IF9oc2xFeHAudGVzdChjb21iaW5lZCk7XG4gICAgYVsxXSA9IF9mb3JtYXRDb2xvcnMoYVsxXSwgdG9IU0wpO1xuICAgIGFbMF0gPSBfZm9ybWF0Q29sb3JzKGFbMF0sIHRvSFNMLCBfY29sb3JPcmRlckRhdGEoYVsxXSkpOyAvLyBtYWtlIHN1cmUgdGhlIG9yZGVyIG9mIG51bWJlcnMvY29sb3JzIG1hdGNoIHdpdGggdGhlIEVORCB2YWx1ZS5cblxuICAgIHJldHVybiB0cnVlO1xuICB9XG59LFxuXG4vKlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIFRJQ0tFUlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqL1xuX3RpY2tlckFjdGl2ZSxcbiAgICBfdGlja2VyID0gZnVuY3Rpb24gKCkge1xuICB2YXIgX2dldFRpbWUgPSBEYXRlLm5vdyxcbiAgICAgIF9sYWdUaHJlc2hvbGQgPSA1MDAsXG4gICAgICBfYWRqdXN0ZWRMYWcgPSAzMyxcbiAgICAgIF9zdGFydFRpbWUgPSBfZ2V0VGltZSgpLFxuICAgICAgX2xhc3RVcGRhdGUgPSBfc3RhcnRUaW1lLFxuICAgICAgX2dhcCA9IDEwMDAgLyAyNDAsXG4gICAgICBfbmV4dFRpbWUgPSBfZ2FwLFxuICAgICAgX2xpc3RlbmVycyA9IFtdLFxuICAgICAgX2lkLFxuICAgICAgX3JlcSxcbiAgICAgIF9yYWYsXG4gICAgICBfc2VsZixcbiAgICAgIF9kZWx0YSxcbiAgICAgIF9pLFxuICAgICAgX3RpY2sgPSBmdW5jdGlvbiBfdGljayh2KSB7XG4gICAgdmFyIGVsYXBzZWQgPSBfZ2V0VGltZSgpIC0gX2xhc3RVcGRhdGUsXG4gICAgICAgIG1hbnVhbCA9IHYgPT09IHRydWUsXG4gICAgICAgIG92ZXJsYXAsXG4gICAgICAgIGRpc3BhdGNoLFxuICAgICAgICB0aW1lLFxuICAgICAgICBmcmFtZTtcblxuICAgIGVsYXBzZWQgPiBfbGFnVGhyZXNob2xkICYmIChfc3RhcnRUaW1lICs9IGVsYXBzZWQgLSBfYWRqdXN0ZWRMYWcpO1xuICAgIF9sYXN0VXBkYXRlICs9IGVsYXBzZWQ7XG4gICAgdGltZSA9IF9sYXN0VXBkYXRlIC0gX3N0YXJ0VGltZTtcbiAgICBvdmVybGFwID0gdGltZSAtIF9uZXh0VGltZTtcblxuICAgIGlmIChvdmVybGFwID4gMCB8fCBtYW51YWwpIHtcbiAgICAgIGZyYW1lID0gKytfc2VsZi5mcmFtZTtcbiAgICAgIF9kZWx0YSA9IHRpbWUgLSBfc2VsZi50aW1lICogMTAwMDtcbiAgICAgIF9zZWxmLnRpbWUgPSB0aW1lID0gdGltZSAvIDEwMDA7XG4gICAgICBfbmV4dFRpbWUgKz0gb3ZlcmxhcCArIChvdmVybGFwID49IF9nYXAgPyA0IDogX2dhcCAtIG92ZXJsYXApO1xuICAgICAgZGlzcGF0Y2ggPSAxO1xuICAgIH1cblxuICAgIG1hbnVhbCB8fCAoX2lkID0gX3JlcShfdGljaykpOyAvL21ha2Ugc3VyZSB0aGUgcmVxdWVzdCBpcyBtYWRlIGJlZm9yZSB3ZSBkaXNwYXRjaCB0aGUgXCJ0aWNrXCIgZXZlbnQgc28gdGhhdCB0aW1pbmcgaXMgbWFpbnRhaW5lZC4gT3RoZXJ3aXNlLCBpZiBwcm9jZXNzaW5nIHRoZSBcInRpY2tcIiByZXF1aXJlcyBhIGJ1bmNoIG9mIHRpbWUgKGxpa2UgMTVtcykgYW5kIHdlJ3JlIHVzaW5nIGEgc2V0VGltZW91dCgpIHRoYXQncyBiYXNlZCBvbiAxNi43bXMsIGl0J2QgdGVjaG5pY2FsbHkgdGFrZSAzMS43bXMgYmV0d2VlbiBmcmFtZXMgb3RoZXJ3aXNlLlxuXG4gICAgaWYgKGRpc3BhdGNoKSB7XG4gICAgICBmb3IgKF9pID0gMDsgX2kgPCBfbGlzdGVuZXJzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAvLyB1c2UgX2kgYW5kIGNoZWNrIF9saXN0ZW5lcnMubGVuZ3RoIGluc3RlYWQgb2YgYSB2YXJpYWJsZSBiZWNhdXNlIGEgbGlzdGVuZXIgY291bGQgZ2V0IHJlbW92ZWQgZHVyaW5nIHRoZSBsb29wLCBhbmQgaWYgdGhhdCBoYXBwZW5zIHRvIGFuIGVsZW1lbnQgbGVzcyB0aGFuIHRoZSBjdXJyZW50IGluZGV4LCBpdCdkIHRocm93IHRoaW5ncyBvZmYgaW4gdGhlIGxvb3AuXG4gICAgICAgIF9saXN0ZW5lcnNbX2ldKHRpbWUsIF9kZWx0YSwgZnJhbWUsIHYpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBfc2VsZiA9IHtcbiAgICB0aW1lOiAwLFxuICAgIGZyYW1lOiAwLFxuICAgIHRpY2s6IGZ1bmN0aW9uIHRpY2soKSB7XG4gICAgICBfdGljayh0cnVlKTtcbiAgICB9LFxuICAgIGRlbHRhUmF0aW86IGZ1bmN0aW9uIGRlbHRhUmF0aW8oZnBzKSB7XG4gICAgICByZXR1cm4gX2RlbHRhIC8gKDEwMDAgLyAoZnBzIHx8IDYwKSk7XG4gICAgfSxcbiAgICB3YWtlOiBmdW5jdGlvbiB3YWtlKCkge1xuICAgICAgaWYgKF9jb3JlUmVhZHkpIHtcbiAgICAgICAgaWYgKCFfY29yZUluaXR0ZWQgJiYgX3dpbmRvd0V4aXN0cygpKSB7XG4gICAgICAgICAgX3dpbiA9IF9jb3JlSW5pdHRlZCA9IHdpbmRvdztcbiAgICAgICAgICBfZG9jID0gX3dpbi5kb2N1bWVudCB8fCB7fTtcbiAgICAgICAgICBfZ2xvYmFscy5nc2FwID0gZ3NhcDtcbiAgICAgICAgICAoX3dpbi5nc2FwVmVyc2lvbnMgfHwgKF93aW4uZ3NhcFZlcnNpb25zID0gW10pKS5wdXNoKGdzYXAudmVyc2lvbik7XG5cbiAgICAgICAgICBfaW5zdGFsbChfaW5zdGFsbFNjb3BlIHx8IF93aW4uR3JlZW5Tb2NrR2xvYmFscyB8fCAhX3dpbi5nc2FwICYmIF93aW4gfHwge30pO1xuXG4gICAgICAgICAgX3JhZiA9IF93aW4ucmVxdWVzdEFuaW1hdGlvbkZyYW1lO1xuICAgICAgICB9XG5cbiAgICAgICAgX2lkICYmIF9zZWxmLnNsZWVwKCk7XG5cbiAgICAgICAgX3JlcSA9IF9yYWYgfHwgZnVuY3Rpb24gKGYpIHtcbiAgICAgICAgICByZXR1cm4gc2V0VGltZW91dChmLCBfbmV4dFRpbWUgLSBfc2VsZi50aW1lICogMTAwMCArIDEgfCAwKTtcbiAgICAgICAgfTtcblxuICAgICAgICBfdGlja2VyQWN0aXZlID0gMTtcblxuICAgICAgICBfdGljaygyKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHNsZWVwOiBmdW5jdGlvbiBzbGVlcCgpIHtcbiAgICAgIChfcmFmID8gX3dpbi5jYW5jZWxBbmltYXRpb25GcmFtZSA6IGNsZWFyVGltZW91dCkoX2lkKTtcbiAgICAgIF90aWNrZXJBY3RpdmUgPSAwO1xuICAgICAgX3JlcSA9IF9lbXB0eUZ1bmM7XG4gICAgfSxcbiAgICBsYWdTbW9vdGhpbmc6IGZ1bmN0aW9uIGxhZ1Ntb290aGluZyh0aHJlc2hvbGQsIGFkanVzdGVkTGFnKSB7XG4gICAgICBfbGFnVGhyZXNob2xkID0gdGhyZXNob2xkIHx8IDEgLyBfdGlueU51bTsgLy96ZXJvIHNob3VsZCBiZSBpbnRlcnByZXRlZCBhcyBiYXNpY2FsbHkgdW5saW1pdGVkXG5cbiAgICAgIF9hZGp1c3RlZExhZyA9IE1hdGgubWluKGFkanVzdGVkTGFnLCBfbGFnVGhyZXNob2xkLCAwKTtcbiAgICB9LFxuICAgIGZwczogZnVuY3Rpb24gZnBzKF9mcHMpIHtcbiAgICAgIF9nYXAgPSAxMDAwIC8gKF9mcHMgfHwgMjQwKTtcbiAgICAgIF9uZXh0VGltZSA9IF9zZWxmLnRpbWUgKiAxMDAwICsgX2dhcDtcbiAgICB9LFxuICAgIGFkZDogZnVuY3Rpb24gYWRkKGNhbGxiYWNrLCBvbmNlLCBwcmlvcml0aXplKSB7XG4gICAgICB2YXIgZnVuYyA9IG9uY2UgPyBmdW5jdGlvbiAodCwgZCwgZiwgdikge1xuICAgICAgICBjYWxsYmFjayh0LCBkLCBmLCB2KTtcblxuICAgICAgICBfc2VsZi5yZW1vdmUoZnVuYyk7XG4gICAgICB9IDogY2FsbGJhY2s7XG5cbiAgICAgIF9zZWxmLnJlbW92ZShjYWxsYmFjayk7XG5cbiAgICAgIF9saXN0ZW5lcnNbcHJpb3JpdGl6ZSA/IFwidW5zaGlmdFwiIDogXCJwdXNoXCJdKGZ1bmMpO1xuXG4gICAgICBfd2FrZSgpO1xuXG4gICAgICByZXR1cm4gZnVuYztcbiAgICB9LFxuICAgIHJlbW92ZTogZnVuY3Rpb24gcmVtb3ZlKGNhbGxiYWNrLCBpKSB7XG4gICAgICB+KGkgPSBfbGlzdGVuZXJzLmluZGV4T2YoY2FsbGJhY2spKSAmJiBfbGlzdGVuZXJzLnNwbGljZShpLCAxKSAmJiBfaSA+PSBpICYmIF9pLS07XG4gICAgfSxcbiAgICBfbGlzdGVuZXJzOiBfbGlzdGVuZXJzXG4gIH07XG4gIHJldHVybiBfc2VsZjtcbn0oKSxcbiAgICBfd2FrZSA9IGZ1bmN0aW9uIF93YWtlKCkge1xuICByZXR1cm4gIV90aWNrZXJBY3RpdmUgJiYgX3RpY2tlci53YWtlKCk7XG59LFxuICAgIC8vYWxzbyBlbnN1cmVzIHRoZSBjb3JlIGNsYXNzZXMgYXJlIGluaXRpYWxpemVkLlxuXG4vKlxuKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4qIEVBU0lOR1xuKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4qL1xuX2Vhc2VNYXAgPSB7fSxcbiAgICBfY3VzdG9tRWFzZUV4cCA9IC9eW1xcZC5cXC1NXVtcXGQuXFwtLFxcc10vLFxuICAgIF9xdW90ZXNFeHAgPSAvW1wiJ10vZyxcbiAgICBfcGFyc2VPYmplY3RJblN0cmluZyA9IGZ1bmN0aW9uIF9wYXJzZU9iamVjdEluU3RyaW5nKHZhbHVlKSB7XG4gIC8vdGFrZXMgYSBzdHJpbmcgbGlrZSBcInt3aWdnbGVzOjEwLCB0eXBlOmFudGljaXBhdGV9KVwiIGFuZCB0dXJucyBpdCBpbnRvIGEgcmVhbCBvYmplY3QuIE5vdGljZSBpdCBlbmRzIGluIFwiKVwiIGFuZCBpbmNsdWRlcyB0aGUge30gd3JhcHBlcnMuIFRoaXMgaXMgYmVjYXVzZSB3ZSBvbmx5IHVzZSB0aGlzIGZ1bmN0aW9uIGZvciBwYXJzaW5nIGVhc2UgY29uZmlncyBhbmQgcHJpb3JpdGl6ZWQgb3B0aW1pemF0aW9uIHJhdGhlciB0aGFuIHJldXNhYmlsaXR5LlxuICB2YXIgb2JqID0ge30sXG4gICAgICBzcGxpdCA9IHZhbHVlLnN1YnN0cigxLCB2YWx1ZS5sZW5ndGggLSAzKS5zcGxpdChcIjpcIiksXG4gICAgICBrZXkgPSBzcGxpdFswXSxcbiAgICAgIGkgPSAxLFxuICAgICAgbCA9IHNwbGl0Lmxlbmd0aCxcbiAgICAgIGluZGV4LFxuICAgICAgdmFsLFxuICAgICAgcGFyc2VkVmFsO1xuXG4gIGZvciAoOyBpIDwgbDsgaSsrKSB7XG4gICAgdmFsID0gc3BsaXRbaV07XG4gICAgaW5kZXggPSBpICE9PSBsIC0gMSA/IHZhbC5sYXN0SW5kZXhPZihcIixcIikgOiB2YWwubGVuZ3RoO1xuICAgIHBhcnNlZFZhbCA9IHZhbC5zdWJzdHIoMCwgaW5kZXgpO1xuICAgIG9ialtrZXldID0gaXNOYU4ocGFyc2VkVmFsKSA/IHBhcnNlZFZhbC5yZXBsYWNlKF9xdW90ZXNFeHAsIFwiXCIpLnRyaW0oKSA6ICtwYXJzZWRWYWw7XG4gICAga2V5ID0gdmFsLnN1YnN0cihpbmRleCArIDEpLnRyaW0oKTtcbiAgfVxuXG4gIHJldHVybiBvYmo7XG59LFxuICAgIF92YWx1ZUluUGFyZW50aGVzZXMgPSBmdW5jdGlvbiBfdmFsdWVJblBhcmVudGhlc2VzKHZhbHVlKSB7XG4gIHZhciBvcGVuID0gdmFsdWUuaW5kZXhPZihcIihcIikgKyAxLFxuICAgICAgY2xvc2UgPSB2YWx1ZS5pbmRleE9mKFwiKVwiKSxcbiAgICAgIG5lc3RlZCA9IHZhbHVlLmluZGV4T2YoXCIoXCIsIG9wZW4pO1xuICByZXR1cm4gdmFsdWUuc3Vic3RyaW5nKG9wZW4sIH5uZXN0ZWQgJiYgbmVzdGVkIDwgY2xvc2UgPyB2YWx1ZS5pbmRleE9mKFwiKVwiLCBjbG9zZSArIDEpIDogY2xvc2UpO1xufSxcbiAgICBfY29uZmlnRWFzZUZyb21TdHJpbmcgPSBmdW5jdGlvbiBfY29uZmlnRWFzZUZyb21TdHJpbmcobmFtZSkge1xuICAvL25hbWUgY2FuIGJlIGEgc3RyaW5nIGxpa2UgXCJlbGFzdGljLm91dCgxLDAuNSlcIiwgYW5kIHBhc3MgaW4gX2Vhc2VNYXAgYXMgb2JqIGFuZCBpdCdsbCBwYXJzZSBpdCBvdXQgYW5kIGNhbGwgdGhlIGFjdHVhbCBmdW5jdGlvbiBsaWtlIF9lYXNlTWFwLkVsYXN0aWMuZWFzZU91dC5jb25maWcoMSwwLjUpLiBJdCB3aWxsIGFsc28gcGFyc2UgY3VzdG9tIGVhc2Ugc3RyaW5ncyBhcyBsb25nIGFzIEN1c3RvbUVhc2UgaXMgbG9hZGVkIGFuZCByZWdpc3RlcmVkIChpbnRlcm5hbGx5IGFzIF9lYXNlTWFwLl9DRSkuXG4gIHZhciBzcGxpdCA9IChuYW1lICsgXCJcIikuc3BsaXQoXCIoXCIpLFxuICAgICAgZWFzZSA9IF9lYXNlTWFwW3NwbGl0WzBdXTtcbiAgcmV0dXJuIGVhc2UgJiYgc3BsaXQubGVuZ3RoID4gMSAmJiBlYXNlLmNvbmZpZyA/IGVhc2UuY29uZmlnLmFwcGx5KG51bGwsIH5uYW1lLmluZGV4T2YoXCJ7XCIpID8gW19wYXJzZU9iamVjdEluU3RyaW5nKHNwbGl0WzFdKV0gOiBfdmFsdWVJblBhcmVudGhlc2VzKG5hbWUpLnNwbGl0KFwiLFwiKS5tYXAoX251bWVyaWNJZlBvc3NpYmxlKSkgOiBfZWFzZU1hcC5fQ0UgJiYgX2N1c3RvbUVhc2VFeHAudGVzdChuYW1lKSA/IF9lYXNlTWFwLl9DRShcIlwiLCBuYW1lKSA6IGVhc2U7XG59LFxuICAgIF9pbnZlcnRFYXNlID0gZnVuY3Rpb24gX2ludmVydEVhc2UoZWFzZSkge1xuICByZXR1cm4gZnVuY3Rpb24gKHApIHtcbiAgICByZXR1cm4gMSAtIGVhc2UoMSAtIHApO1xuICB9O1xufSxcbiAgICAvLyBhbGxvdyB5b3lvRWFzZSB0byBiZSBzZXQgaW4gY2hpbGRyZW4gYW5kIGhhdmUgdGhvc2UgYWZmZWN0ZWQgd2hlbiB0aGUgcGFyZW50L2FuY2VzdG9yIHRpbWVsaW5lIHlveW9zLlxuX3Byb3BhZ2F0ZVlveW9FYXNlID0gZnVuY3Rpb24gX3Byb3BhZ2F0ZVlveW9FYXNlKHRpbWVsaW5lLCBpc1lveW8pIHtcbiAgdmFyIGNoaWxkID0gdGltZWxpbmUuX2ZpcnN0LFxuICAgICAgZWFzZTtcblxuICB3aGlsZSAoY2hpbGQpIHtcbiAgICBpZiAoY2hpbGQgaW5zdGFuY2VvZiBUaW1lbGluZSkge1xuICAgICAgX3Byb3BhZ2F0ZVlveW9FYXNlKGNoaWxkLCBpc1lveW8pO1xuICAgIH0gZWxzZSBpZiAoY2hpbGQudmFycy55b3lvRWFzZSAmJiAoIWNoaWxkLl95b3lvIHx8ICFjaGlsZC5fcmVwZWF0KSAmJiBjaGlsZC5feW95byAhPT0gaXNZb3lvKSB7XG4gICAgICBpZiAoY2hpbGQudGltZWxpbmUpIHtcbiAgICAgICAgX3Byb3BhZ2F0ZVlveW9FYXNlKGNoaWxkLnRpbWVsaW5lLCBpc1lveW8pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZWFzZSA9IGNoaWxkLl9lYXNlO1xuICAgICAgICBjaGlsZC5fZWFzZSA9IGNoaWxkLl95RWFzZTtcbiAgICAgICAgY2hpbGQuX3lFYXNlID0gZWFzZTtcbiAgICAgICAgY2hpbGQuX3lveW8gPSBpc1lveW87XG4gICAgICB9XG4gICAgfVxuXG4gICAgY2hpbGQgPSBjaGlsZC5fbmV4dDtcbiAgfVxufSxcbiAgICBfcGFyc2VFYXNlID0gZnVuY3Rpb24gX3BhcnNlRWFzZShlYXNlLCBkZWZhdWx0RWFzZSkge1xuICByZXR1cm4gIWVhc2UgPyBkZWZhdWx0RWFzZSA6IChfaXNGdW5jdGlvbihlYXNlKSA/IGVhc2UgOiBfZWFzZU1hcFtlYXNlXSB8fCBfY29uZmlnRWFzZUZyb21TdHJpbmcoZWFzZSkpIHx8IGRlZmF1bHRFYXNlO1xufSxcbiAgICBfaW5zZXJ0RWFzZSA9IGZ1bmN0aW9uIF9pbnNlcnRFYXNlKG5hbWVzLCBlYXNlSW4sIGVhc2VPdXQsIGVhc2VJbk91dCkge1xuICBpZiAoZWFzZU91dCA9PT0gdm9pZCAwKSB7XG4gICAgZWFzZU91dCA9IGZ1bmN0aW9uIGVhc2VPdXQocCkge1xuICAgICAgcmV0dXJuIDEgLSBlYXNlSW4oMSAtIHApO1xuICAgIH07XG4gIH1cblxuICBpZiAoZWFzZUluT3V0ID09PSB2b2lkIDApIHtcbiAgICBlYXNlSW5PdXQgPSBmdW5jdGlvbiBlYXNlSW5PdXQocCkge1xuICAgICAgcmV0dXJuIHAgPCAuNSA/IGVhc2VJbihwICogMikgLyAyIDogMSAtIGVhc2VJbigoMSAtIHApICogMikgLyAyO1xuICAgIH07XG4gIH1cblxuICB2YXIgZWFzZSA9IHtcbiAgICBlYXNlSW46IGVhc2VJbixcbiAgICBlYXNlT3V0OiBlYXNlT3V0LFxuICAgIGVhc2VJbk91dDogZWFzZUluT3V0XG4gIH0sXG4gICAgICBsb3dlcmNhc2VOYW1lO1xuXG4gIF9mb3JFYWNoTmFtZShuYW1lcywgZnVuY3Rpb24gKG5hbWUpIHtcbiAgICBfZWFzZU1hcFtuYW1lXSA9IF9nbG9iYWxzW25hbWVdID0gZWFzZTtcbiAgICBfZWFzZU1hcFtsb3dlcmNhc2VOYW1lID0gbmFtZS50b0xvd2VyQ2FzZSgpXSA9IGVhc2VPdXQ7XG5cbiAgICBmb3IgKHZhciBwIGluIGVhc2UpIHtcbiAgICAgIF9lYXNlTWFwW2xvd2VyY2FzZU5hbWUgKyAocCA9PT0gXCJlYXNlSW5cIiA/IFwiLmluXCIgOiBwID09PSBcImVhc2VPdXRcIiA/IFwiLm91dFwiIDogXCIuaW5PdXRcIildID0gX2Vhc2VNYXBbbmFtZSArIFwiLlwiICsgcF0gPSBlYXNlW3BdO1xuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIGVhc2U7XG59LFxuICAgIF9lYXNlSW5PdXRGcm9tT3V0ID0gZnVuY3Rpb24gX2Vhc2VJbk91dEZyb21PdXQoZWFzZU91dCkge1xuICByZXR1cm4gZnVuY3Rpb24gKHApIHtcbiAgICByZXR1cm4gcCA8IC41ID8gKDEgLSBlYXNlT3V0KDEgLSBwICogMikpIC8gMiA6IC41ICsgZWFzZU91dCgocCAtIC41KSAqIDIpIC8gMjtcbiAgfTtcbn0sXG4gICAgX2NvbmZpZ0VsYXN0aWMgPSBmdW5jdGlvbiBfY29uZmlnRWxhc3RpYyh0eXBlLCBhbXBsaXR1ZGUsIHBlcmlvZCkge1xuICB2YXIgcDEgPSBhbXBsaXR1ZGUgPj0gMSA/IGFtcGxpdHVkZSA6IDEsXG4gICAgICAvL25vdGU6IGlmIGFtcGxpdHVkZSBpcyA8IDEsIHdlIHNpbXBseSBhZGp1c3QgdGhlIHBlcmlvZCBmb3IgYSBtb3JlIG5hdHVyYWwgZmVlbC4gT3RoZXJ3aXNlIHRoZSBtYXRoIGRvZXNuJ3Qgd29yayByaWdodCBhbmQgdGhlIGN1cnZlIHN0YXJ0cyBhdCAxLlxuICBwMiA9IChwZXJpb2QgfHwgKHR5cGUgPyAuMyA6IC40NSkpIC8gKGFtcGxpdHVkZSA8IDEgPyBhbXBsaXR1ZGUgOiAxKSxcbiAgICAgIHAzID0gcDIgLyBfMlBJICogKE1hdGguYXNpbigxIC8gcDEpIHx8IDApLFxuICAgICAgZWFzZU91dCA9IGZ1bmN0aW9uIGVhc2VPdXQocCkge1xuICAgIHJldHVybiBwID09PSAxID8gMSA6IHAxICogTWF0aC5wb3coMiwgLTEwICogcCkgKiBfc2luKChwIC0gcDMpICogcDIpICsgMTtcbiAgfSxcbiAgICAgIGVhc2UgPSB0eXBlID09PSBcIm91dFwiID8gZWFzZU91dCA6IHR5cGUgPT09IFwiaW5cIiA/IGZ1bmN0aW9uIChwKSB7XG4gICAgcmV0dXJuIDEgLSBlYXNlT3V0KDEgLSBwKTtcbiAgfSA6IF9lYXNlSW5PdXRGcm9tT3V0KGVhc2VPdXQpO1xuXG4gIHAyID0gXzJQSSAvIHAyOyAvL3ByZWNhbGN1bGF0ZSB0byBvcHRpbWl6ZVxuXG4gIGVhc2UuY29uZmlnID0gZnVuY3Rpb24gKGFtcGxpdHVkZSwgcGVyaW9kKSB7XG4gICAgcmV0dXJuIF9jb25maWdFbGFzdGljKHR5cGUsIGFtcGxpdHVkZSwgcGVyaW9kKTtcbiAgfTtcblxuICByZXR1cm4gZWFzZTtcbn0sXG4gICAgX2NvbmZpZ0JhY2sgPSBmdW5jdGlvbiBfY29uZmlnQmFjayh0eXBlLCBvdmVyc2hvb3QpIHtcbiAgaWYgKG92ZXJzaG9vdCA9PT0gdm9pZCAwKSB7XG4gICAgb3ZlcnNob290ID0gMS43MDE1ODtcbiAgfVxuXG4gIHZhciBlYXNlT3V0ID0gZnVuY3Rpb24gZWFzZU91dChwKSB7XG4gICAgcmV0dXJuIHAgPyAtLXAgKiBwICogKChvdmVyc2hvb3QgKyAxKSAqIHAgKyBvdmVyc2hvb3QpICsgMSA6IDA7XG4gIH0sXG4gICAgICBlYXNlID0gdHlwZSA9PT0gXCJvdXRcIiA/IGVhc2VPdXQgOiB0eXBlID09PSBcImluXCIgPyBmdW5jdGlvbiAocCkge1xuICAgIHJldHVybiAxIC0gZWFzZU91dCgxIC0gcCk7XG4gIH0gOiBfZWFzZUluT3V0RnJvbU91dChlYXNlT3V0KTtcblxuICBlYXNlLmNvbmZpZyA9IGZ1bmN0aW9uIChvdmVyc2hvb3QpIHtcbiAgICByZXR1cm4gX2NvbmZpZ0JhY2sodHlwZSwgb3ZlcnNob290KTtcbiAgfTtcblxuICByZXR1cm4gZWFzZTtcbn07IC8vIGEgY2hlYXBlciAoa2IgYW5kIGNwdSkgYnV0IG1vcmUgbWlsZCB3YXkgdG8gZ2V0IGEgcGFyYW1ldGVyaXplZCB3ZWlnaHRlZCBlYXNlIGJ5IGZlZWRpbmcgaW4gYSB2YWx1ZSBiZXR3ZWVuIC0xIChlYXNlSW4pIGFuZCAxIChlYXNlT3V0KSB3aGVyZSAwIGlzIGxpbmVhci5cbi8vIF93ZWlnaHRlZEVhc2UgPSByYXRpbyA9PiB7XG4vLyBcdGxldCB5ID0gMC41ICsgcmF0aW8gLyAyO1xuLy8gXHRyZXR1cm4gcCA9PiAoMiAqICgxIC0gcCkgKiBwICogeSArIHAgKiBwKTtcbi8vIH0sXG4vLyBhIHN0cm9uZ2VyIChidXQgbW9yZSBleHBlbnNpdmUga2IvY3B1KSBwYXJhbWV0ZXJpemVkIHdlaWdodGVkIGVhc2UgdGhhdCBsZXRzIHlvdSBmZWVkIGluIGEgdmFsdWUgYmV0d2VlbiAtMSAoZWFzZUluKSBhbmQgMSAoZWFzZU91dCkgd2hlcmUgMCBpcyBsaW5lYXIuXG4vLyBfd2VpZ2h0ZWRFYXNlU3Ryb25nID0gcmF0aW8gPT4ge1xuLy8gXHRyYXRpbyA9IC41ICsgcmF0aW8gLyAyO1xuLy8gXHRsZXQgbyA9IDEgLyAzICogKHJhdGlvIDwgLjUgPyByYXRpbyA6IDEgLSByYXRpbyksXG4vLyBcdFx0YiA9IHJhdGlvIC0gbyxcbi8vIFx0XHRjID0gcmF0aW8gKyBvO1xuLy8gXHRyZXR1cm4gcCA9PiBwID09PSAxID8gcCA6IDMgKiBiICogKDEgLSBwKSAqICgxIC0gcCkgKiBwICsgMyAqIGMgKiAoMSAtIHApICogcCAqIHAgKyBwICogcCAqIHA7XG4vLyB9O1xuXG5cbl9mb3JFYWNoTmFtZShcIkxpbmVhcixRdWFkLEN1YmljLFF1YXJ0LFF1aW50LFN0cm9uZ1wiLCBmdW5jdGlvbiAobmFtZSwgaSkge1xuICB2YXIgcG93ZXIgPSBpIDwgNSA/IGkgKyAxIDogaTtcblxuICBfaW5zZXJ0RWFzZShuYW1lICsgXCIsUG93ZXJcIiArIChwb3dlciAtIDEpLCBpID8gZnVuY3Rpb24gKHApIHtcbiAgICByZXR1cm4gTWF0aC5wb3cocCwgcG93ZXIpO1xuICB9IDogZnVuY3Rpb24gKHApIHtcbiAgICByZXR1cm4gcDtcbiAgfSwgZnVuY3Rpb24gKHApIHtcbiAgICByZXR1cm4gMSAtIE1hdGgucG93KDEgLSBwLCBwb3dlcik7XG4gIH0sIGZ1bmN0aW9uIChwKSB7XG4gICAgcmV0dXJuIHAgPCAuNSA/IE1hdGgucG93KHAgKiAyLCBwb3dlcikgLyAyIDogMSAtIE1hdGgucG93KCgxIC0gcCkgKiAyLCBwb3dlcikgLyAyO1xuICB9KTtcbn0pO1xuXG5fZWFzZU1hcC5MaW5lYXIuZWFzZU5vbmUgPSBfZWFzZU1hcC5ub25lID0gX2Vhc2VNYXAuTGluZWFyLmVhc2VJbjtcblxuX2luc2VydEVhc2UoXCJFbGFzdGljXCIsIF9jb25maWdFbGFzdGljKFwiaW5cIiksIF9jb25maWdFbGFzdGljKFwib3V0XCIpLCBfY29uZmlnRWxhc3RpYygpKTtcblxuKGZ1bmN0aW9uIChuLCBjKSB7XG4gIHZhciBuMSA9IDEgLyBjLFxuICAgICAgbjIgPSAyICogbjEsXG4gICAgICBuMyA9IDIuNSAqIG4xLFxuICAgICAgZWFzZU91dCA9IGZ1bmN0aW9uIGVhc2VPdXQocCkge1xuICAgIHJldHVybiBwIDwgbjEgPyBuICogcCAqIHAgOiBwIDwgbjIgPyBuICogTWF0aC5wb3cocCAtIDEuNSAvIGMsIDIpICsgLjc1IDogcCA8IG4zID8gbiAqIChwIC09IDIuMjUgLyBjKSAqIHAgKyAuOTM3NSA6IG4gKiBNYXRoLnBvdyhwIC0gMi42MjUgLyBjLCAyKSArIC45ODQzNzU7XG4gIH07XG5cbiAgX2luc2VydEVhc2UoXCJCb3VuY2VcIiwgZnVuY3Rpb24gKHApIHtcbiAgICByZXR1cm4gMSAtIGVhc2VPdXQoMSAtIHApO1xuICB9LCBlYXNlT3V0KTtcbn0pKDcuNTYyNSwgMi43NSk7XG5cbl9pbnNlcnRFYXNlKFwiRXhwb1wiLCBmdW5jdGlvbiAocCkge1xuICByZXR1cm4gcCA/IE1hdGgucG93KDIsIDEwICogKHAgLSAxKSkgOiAwO1xufSk7XG5cbl9pbnNlcnRFYXNlKFwiQ2lyY1wiLCBmdW5jdGlvbiAocCkge1xuICByZXR1cm4gLShfc3FydCgxIC0gcCAqIHApIC0gMSk7XG59KTtcblxuX2luc2VydEVhc2UoXCJTaW5lXCIsIGZ1bmN0aW9uIChwKSB7XG4gIHJldHVybiBwID09PSAxID8gMSA6IC1fY29zKHAgKiBfSEFMRl9QSSkgKyAxO1xufSk7XG5cbl9pbnNlcnRFYXNlKFwiQmFja1wiLCBfY29uZmlnQmFjayhcImluXCIpLCBfY29uZmlnQmFjayhcIm91dFwiKSwgX2NvbmZpZ0JhY2soKSk7XG5cbl9lYXNlTWFwLlN0ZXBwZWRFYXNlID0gX2Vhc2VNYXAuc3RlcHMgPSBfZ2xvYmFscy5TdGVwcGVkRWFzZSA9IHtcbiAgY29uZmlnOiBmdW5jdGlvbiBjb25maWcoc3RlcHMsIGltbWVkaWF0ZVN0YXJ0KSB7XG4gICAgaWYgKHN0ZXBzID09PSB2b2lkIDApIHtcbiAgICAgIHN0ZXBzID0gMTtcbiAgICB9XG5cbiAgICB2YXIgcDEgPSAxIC8gc3RlcHMsXG4gICAgICAgIHAyID0gc3RlcHMgKyAoaW1tZWRpYXRlU3RhcnQgPyAwIDogMSksXG4gICAgICAgIHAzID0gaW1tZWRpYXRlU3RhcnQgPyAxIDogMCxcbiAgICAgICAgbWF4ID0gMSAtIF90aW55TnVtO1xuICAgIHJldHVybiBmdW5jdGlvbiAocCkge1xuICAgICAgcmV0dXJuICgocDIgKiBfY2xhbXAoMCwgbWF4LCBwKSB8IDApICsgcDMpICogcDE7XG4gICAgfTtcbiAgfVxufTtcbl9kZWZhdWx0cy5lYXNlID0gX2Vhc2VNYXBbXCJxdWFkLm91dFwiXTtcblxuX2ZvckVhY2hOYW1lKFwib25Db21wbGV0ZSxvblVwZGF0ZSxvblN0YXJ0LG9uUmVwZWF0LG9uUmV2ZXJzZUNvbXBsZXRlLG9uSW50ZXJydXB0XCIsIGZ1bmN0aW9uIChuYW1lKSB7XG4gIHJldHVybiBfY2FsbGJhY2tOYW1lcyArPSBuYW1lICsgXCIsXCIgKyBuYW1lICsgXCJQYXJhbXMsXCI7XG59KTtcbi8qXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogQ0FDSEVcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKi9cblxuXG5leHBvcnQgdmFyIEdTQ2FjaGUgPSBmdW5jdGlvbiBHU0NhY2hlKHRhcmdldCwgaGFybmVzcykge1xuICB0aGlzLmlkID0gX2dzSUQrKztcbiAgdGFyZ2V0Ll9nc2FwID0gdGhpcztcbiAgdGhpcy50YXJnZXQgPSB0YXJnZXQ7XG4gIHRoaXMuaGFybmVzcyA9IGhhcm5lc3M7XG4gIHRoaXMuZ2V0ID0gaGFybmVzcyA/IGhhcm5lc3MuZ2V0IDogX2dldFByb3BlcnR5O1xuICB0aGlzLnNldCA9IGhhcm5lc3MgPyBoYXJuZXNzLmdldFNldHRlciA6IF9nZXRTZXR0ZXI7XG59O1xuLypcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBBTklNQVRJT05cbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKi9cblxuZXhwb3J0IHZhciBBbmltYXRpb24gPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBBbmltYXRpb24odmFycykge1xuICAgIHRoaXMudmFycyA9IHZhcnM7XG4gICAgdGhpcy5fZGVsYXkgPSArdmFycy5kZWxheSB8fCAwO1xuXG4gICAgaWYgKHRoaXMuX3JlcGVhdCA9IHZhcnMucmVwZWF0ID09PSBJbmZpbml0eSA/IC0yIDogdmFycy5yZXBlYXQgfHwgMCkge1xuICAgICAgLy8gVE9ETzogcmVwZWF0OiBJbmZpbml0eSBvbiBhIHRpbWVsaW5lJ3MgY2hpbGRyZW4gbXVzdCBmbGFnIHRoYXQgdGltZWxpbmUgaW50ZXJuYWxseSBhbmQgYWZmZWN0IGl0cyB0b3RhbER1cmF0aW9uLCBvdGhlcndpc2UgaXQnbGwgc3RvcCBpbiB0aGUgbmVnYXRpdmUgZGlyZWN0aW9uIHdoZW4gcmVhY2hpbmcgdGhlIHN0YXJ0LlxuICAgICAgdGhpcy5fckRlbGF5ID0gdmFycy5yZXBlYXREZWxheSB8fCAwO1xuICAgICAgdGhpcy5feW95byA9ICEhdmFycy55b3lvIHx8ICEhdmFycy55b3lvRWFzZTtcbiAgICB9XG5cbiAgICB0aGlzLl90cyA9IDE7XG5cbiAgICBfc2V0RHVyYXRpb24odGhpcywgK3ZhcnMuZHVyYXRpb24sIDEsIDEpO1xuXG4gICAgdGhpcy5kYXRhID0gdmFycy5kYXRhO1xuICAgIF90aWNrZXJBY3RpdmUgfHwgX3RpY2tlci53YWtlKCk7XG4gIH1cblxuICB2YXIgX3Byb3RvID0gQW5pbWF0aW9uLnByb3RvdHlwZTtcblxuICBfcHJvdG8uZGVsYXkgPSBmdW5jdGlvbiBkZWxheSh2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSB8fCB2YWx1ZSA9PT0gMCkge1xuICAgICAgdGhpcy5wYXJlbnQgJiYgdGhpcy5wYXJlbnQuc21vb3RoQ2hpbGRUaW1pbmcgJiYgdGhpcy5zdGFydFRpbWUodGhpcy5fc3RhcnQgKyB2YWx1ZSAtIHRoaXMuX2RlbGF5KTtcbiAgICAgIHRoaXMuX2RlbGF5ID0gdmFsdWU7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5fZGVsYXk7XG4gIH07XG5cbiAgX3Byb3RvLmR1cmF0aW9uID0gZnVuY3Rpb24gZHVyYXRpb24odmFsdWUpIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IHRoaXMudG90YWxEdXJhdGlvbih0aGlzLl9yZXBlYXQgPiAwID8gdmFsdWUgKyAodmFsdWUgKyB0aGlzLl9yRGVsYXkpICogdGhpcy5fcmVwZWF0IDogdmFsdWUpIDogdGhpcy50b3RhbER1cmF0aW9uKCkgJiYgdGhpcy5fZHVyO1xuICB9O1xuXG4gIF9wcm90by50b3RhbER1cmF0aW9uID0gZnVuY3Rpb24gdG90YWxEdXJhdGlvbih2YWx1ZSkge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3REdXI7XG4gICAgfVxuXG4gICAgdGhpcy5fZGlydHkgPSAwO1xuICAgIHJldHVybiBfc2V0RHVyYXRpb24odGhpcywgdGhpcy5fcmVwZWF0IDwgMCA/IHZhbHVlIDogKHZhbHVlIC0gdGhpcy5fcmVwZWF0ICogdGhpcy5fckRlbGF5KSAvICh0aGlzLl9yZXBlYXQgKyAxKSk7XG4gIH07XG5cbiAgX3Byb3RvLnRvdGFsVGltZSA9IGZ1bmN0aW9uIHRvdGFsVGltZShfdG90YWxUaW1lLCBzdXBwcmVzc0V2ZW50cykge1xuICAgIF93YWtlKCk7XG5cbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiB0aGlzLl90VGltZTtcbiAgICB9XG5cbiAgICB2YXIgcGFyZW50ID0gdGhpcy5fZHA7XG5cbiAgICBpZiAocGFyZW50ICYmIHBhcmVudC5zbW9vdGhDaGlsZFRpbWluZyAmJiB0aGlzLl90cykge1xuICAgICAgX2FsaWduUGxheWhlYWQodGhpcywgX3RvdGFsVGltZSk7XG5cbiAgICAgICFwYXJlbnQuX2RwIHx8IHBhcmVudC5wYXJlbnQgfHwgX3Bvc3RBZGRDaGVja3MocGFyZW50LCB0aGlzKTsgLy8gZWRnZSBjYXNlOiBpZiB0aGlzIGlzIGEgY2hpbGQgb2YgYSB0aW1lbGluZSB0aGF0IGFscmVhZHkgY29tcGxldGVkLCBmb3IgZXhhbXBsZSwgd2UgbXVzdCByZS1hY3RpdmF0ZSB0aGUgcGFyZW50LlxuICAgICAgLy9pbiBjYXNlIGFueSBvZiB0aGUgYW5jZXN0b3IgdGltZWxpbmVzIGhhZCBjb21wbGV0ZWQgYnV0IHNob3VsZCBub3cgYmUgZW5hYmxlZCwgd2Ugc2hvdWxkIHJlc2V0IHRoZWlyIHRvdGFsVGltZSgpIHdoaWNoIHdpbGwgYWxzbyBlbnN1cmUgdGhhdCB0aGV5J3JlIGxpbmVkIHVwIHByb3Blcmx5IGFuZCBlbmFibGVkLiBTa2lwIGZvciBhbmltYXRpb25zIHRoYXQgYXJlIG9uIHRoZSByb290ICh3YXN0ZWZ1bCkuIEV4YW1wbGU6IGEgVGltZWxpbmVMaXRlLmV4cG9ydFJvb3QoKSBpcyBwZXJmb3JtZWQgd2hlbiB0aGVyZSdzIGEgcGF1c2VkIHR3ZWVuIG9uIHRoZSByb290LCB0aGUgZXhwb3J0IHdpbGwgbm90IGNvbXBsZXRlIHVudGlsIHRoYXQgdHdlZW4gaXMgdW5wYXVzZWQsIGJ1dCBpbWFnaW5lIGEgY2hpbGQgZ2V0cyByZXN0YXJ0ZWQgbGF0ZXIsIGFmdGVyIGFsbCBbdW5wYXVzZWRdIHR3ZWVucyBoYXZlIGNvbXBsZXRlZC4gVGhlIHN0YXJ0IG9mIHRoYXQgY2hpbGQgd291bGQgZ2V0IHB1c2hlZCBvdXQsIGJ1dCBvbmUgb2YgdGhlIGFuY2VzdG9ycyBtYXkgaGF2ZSBjb21wbGV0ZWQuXG5cbiAgICAgIHdoaWxlIChwYXJlbnQgJiYgcGFyZW50LnBhcmVudCkge1xuICAgICAgICBpZiAocGFyZW50LnBhcmVudC5fdGltZSAhPT0gcGFyZW50Ll9zdGFydCArIChwYXJlbnQuX3RzID49IDAgPyBwYXJlbnQuX3RUaW1lIC8gcGFyZW50Ll90cyA6IChwYXJlbnQudG90YWxEdXJhdGlvbigpIC0gcGFyZW50Ll90VGltZSkgLyAtcGFyZW50Ll90cykpIHtcbiAgICAgICAgICBwYXJlbnQudG90YWxUaW1lKHBhcmVudC5fdFRpbWUsIHRydWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgcGFyZW50ID0gcGFyZW50LnBhcmVudDtcbiAgICAgIH1cblxuICAgICAgaWYgKCF0aGlzLnBhcmVudCAmJiB0aGlzLl9kcC5hdXRvUmVtb3ZlQ2hpbGRyZW4gJiYgKHRoaXMuX3RzID4gMCAmJiBfdG90YWxUaW1lIDwgdGhpcy5fdER1ciB8fCB0aGlzLl90cyA8IDAgJiYgX3RvdGFsVGltZSA+IDAgfHwgIXRoaXMuX3REdXIgJiYgIV90b3RhbFRpbWUpKSB7XG4gICAgICAgIC8vaWYgdGhlIGFuaW1hdGlvbiBkb2Vzbid0IGhhdmUgYSBwYXJlbnQsIHB1dCBpdCBiYWNrIGludG8gaXRzIGxhc3QgcGFyZW50IChyZWNvcmRlZCBhcyBfZHAgZm9yIGV4YWN0bHkgY2FzZXMgbGlrZSB0aGlzKS4gTGltaXQgdG8gcGFyZW50cyB3aXRoIGF1dG9SZW1vdmVDaGlsZHJlbiAobGlrZSBnbG9iYWxUaW1lbGluZSkgc28gdGhhdCBpZiB0aGUgdXNlciBtYW51YWxseSByZW1vdmVzIGFuIGFuaW1hdGlvbiBmcm9tIGEgdGltZWxpbmUgYW5kIHRoZW4gYWx0ZXJzIGl0cyBwbGF5aGVhZCwgaXQgZG9lc24ndCBnZXQgYWRkZWQgYmFjayBpbi5cbiAgICAgICAgX2FkZFRvVGltZWxpbmUodGhpcy5fZHAsIHRoaXMsIHRoaXMuX3N0YXJ0IC0gdGhpcy5fZGVsYXkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0aGlzLl90VGltZSAhPT0gX3RvdGFsVGltZSB8fCAhdGhpcy5fZHVyICYmICFzdXBwcmVzc0V2ZW50cyB8fCB0aGlzLl9pbml0dGVkICYmIE1hdGguYWJzKHRoaXMuX3pUaW1lKSA9PT0gX3RpbnlOdW0gfHwgIV90b3RhbFRpbWUgJiYgIXRoaXMuX2luaXR0ZWQgJiYgKHRoaXMuYWRkIHx8IHRoaXMuX3B0TG9va3VwKSkge1xuICAgICAgLy8gY2hlY2sgZm9yIF9wdExvb2t1cCBvbiBhIFR3ZWVuIGluc3RhbmNlIHRvIGVuc3VyZSBpdCBoYXMgYWN0dWFsbHkgZmluaXNoZWQgYmVpbmcgaW5zdGFudGlhdGVkLCBvdGhlcndpc2UgaWYgdGhpcy5yZXZlcnNlKCkgZ2V0cyBjYWxsZWQgaW4gdGhlIEFuaW1hdGlvbiBjb25zdHJ1Y3RvciwgaXQgY291bGQgdHJpZ2dlciBhIHJlbmRlcigpIGhlcmUgZXZlbiB0aG91Z2ggdGhlIF90YXJnZXRzIHdlcmVuJ3QgcG9wdWxhdGVkLCB0aHVzIHdoZW4gX2luaXQoKSBpcyBjYWxsZWQgdGhlcmUgd29uJ3QgYmUgYW55IFByb3BUd2VlbnMgKGl0J2xsIGFjdCBsaWtlIHRoZSB0d2VlbiBpcyBub24tZnVuY3Rpb25hbClcbiAgICAgIHRoaXMuX3RzIHx8ICh0aGlzLl9wVGltZSA9IF90b3RhbFRpbWUpOyAvLyBvdGhlcndpc2UsIGlmIGFuIGFuaW1hdGlvbiBpcyBwYXVzZWQsIHRoZW4gdGhlIHBsYXloZWFkIGlzIG1vdmVkIGJhY2sgdG8gemVybywgdGhlbiByZXN1bWVkLCBpdCdkIHJldmVydCBiYWNrIHRvIHRoZSBvcmlnaW5hbCB0aW1lIGF0IHRoZSBwYXVzZVxuICAgICAgLy9pZiAoIXRoaXMuX2xvY2spIHsgLy8gYXZvaWQgZW5kbGVzcyByZWN1cnNpb24gKG5vdCBzdXJlIHdlIG5lZWQgdGhpcyB5ZXQgb3IgaWYgaXQncyB3b3J0aCB0aGUgcGVyZm9ybWFuY2UgaGl0KVxuICAgICAgLy8gICB0aGlzLl9sb2NrID0gMTtcblxuICAgICAgX2xhenlTYWZlUmVuZGVyKHRoaXMsIF90b3RhbFRpbWUsIHN1cHByZXNzRXZlbnRzKTsgLy8gICB0aGlzLl9sb2NrID0gMDtcbiAgICAgIC8vfVxuXG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgX3Byb3RvLnRpbWUgPSBmdW5jdGlvbiB0aW1lKHZhbHVlLCBzdXBwcmVzc0V2ZW50cykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gdGhpcy50b3RhbFRpbWUoTWF0aC5taW4odGhpcy50b3RhbER1cmF0aW9uKCksIHZhbHVlICsgX2VsYXBzZWRDeWNsZUR1cmF0aW9uKHRoaXMpKSAlICh0aGlzLl9kdXIgKyB0aGlzLl9yRGVsYXkpIHx8ICh2YWx1ZSA/IHRoaXMuX2R1ciA6IDApLCBzdXBwcmVzc0V2ZW50cykgOiB0aGlzLl90aW1lOyAvLyBub3RlOiBpZiB0aGUgbW9kdWx1cyByZXN1bHRzIGluIDAsIHRoZSBwbGF5aGVhZCBjb3VsZCBiZSBleGFjdGx5IGF0IHRoZSBlbmQgb3IgdGhlIGJlZ2lubmluZywgYW5kIHdlIGFsd2F5cyBkZWZlciB0byB0aGUgRU5EIHdpdGggYSBub24temVybyB2YWx1ZSwgb3RoZXJ3aXNlIGlmIHlvdSBzZXQgdGhlIHRpbWUoKSB0byB0aGUgdmVyeSBlbmQgKGR1cmF0aW9uKCkpLCBpdCB3b3VsZCByZW5kZXIgYXQgdGhlIFNUQVJUIVxuICB9O1xuXG4gIF9wcm90by50b3RhbFByb2dyZXNzID0gZnVuY3Rpb24gdG90YWxQcm9ncmVzcyh2YWx1ZSwgc3VwcHJlc3NFdmVudHMpIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IHRoaXMudG90YWxUaW1lKHRoaXMudG90YWxEdXJhdGlvbigpICogdmFsdWUsIHN1cHByZXNzRXZlbnRzKSA6IHRoaXMudG90YWxEdXJhdGlvbigpID8gTWF0aC5taW4oMSwgdGhpcy5fdFRpbWUgLyB0aGlzLl90RHVyKSA6IHRoaXMucmF0aW87XG4gIH07XG5cbiAgX3Byb3RvLnByb2dyZXNzID0gZnVuY3Rpb24gcHJvZ3Jlc3ModmFsdWUsIHN1cHByZXNzRXZlbnRzKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyB0aGlzLnRvdGFsVGltZSh0aGlzLmR1cmF0aW9uKCkgKiAodGhpcy5feW95byAmJiAhKHRoaXMuaXRlcmF0aW9uKCkgJiAxKSA/IDEgLSB2YWx1ZSA6IHZhbHVlKSArIF9lbGFwc2VkQ3ljbGVEdXJhdGlvbih0aGlzKSwgc3VwcHJlc3NFdmVudHMpIDogdGhpcy5kdXJhdGlvbigpID8gTWF0aC5taW4oMSwgdGhpcy5fdGltZSAvIHRoaXMuX2R1cikgOiB0aGlzLnJhdGlvO1xuICB9O1xuXG4gIF9wcm90by5pdGVyYXRpb24gPSBmdW5jdGlvbiBpdGVyYXRpb24odmFsdWUsIHN1cHByZXNzRXZlbnRzKSB7XG4gICAgdmFyIGN5Y2xlRHVyYXRpb24gPSB0aGlzLmR1cmF0aW9uKCkgKyB0aGlzLl9yRGVsYXk7XG5cbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IHRoaXMudG90YWxUaW1lKHRoaXMuX3RpbWUgKyAodmFsdWUgLSAxKSAqIGN5Y2xlRHVyYXRpb24sIHN1cHByZXNzRXZlbnRzKSA6IHRoaXMuX3JlcGVhdCA/IF9hbmltYXRpb25DeWNsZSh0aGlzLl90VGltZSwgY3ljbGVEdXJhdGlvbikgKyAxIDogMTtcbiAgfSAvLyBwb3RlbnRpYWwgZnV0dXJlIGFkZGl0aW9uOlxuICAvLyBpc1BsYXlpbmdCYWNrd2FyZHMoKSB7XG4gIC8vIFx0bGV0IGFuaW1hdGlvbiA9IHRoaXMsXG4gIC8vIFx0XHRvcmllbnRhdGlvbiA9IDE7IC8vIDEgPSBmb3J3YXJkLCAtMSA9IGJhY2t3YXJkXG4gIC8vIFx0d2hpbGUgKGFuaW1hdGlvbikge1xuICAvLyBcdFx0b3JpZW50YXRpb24gKj0gYW5pbWF0aW9uLnJldmVyc2VkKCkgfHwgKGFuaW1hdGlvbi5yZXBlYXQoKSAmJiAhKGFuaW1hdGlvbi5pdGVyYXRpb24oKSAmIDEpKSA/IC0xIDogMTtcbiAgLy8gXHRcdGFuaW1hdGlvbiA9IGFuaW1hdGlvbi5wYXJlbnQ7XG4gIC8vIFx0fVxuICAvLyBcdHJldHVybiBvcmllbnRhdGlvbiA8IDA7XG4gIC8vIH1cbiAgO1xuXG4gIF9wcm90by50aW1lU2NhbGUgPSBmdW5jdGlvbiB0aW1lU2NhbGUodmFsdWUpIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9ydHMgPT09IC1fdGlueU51bSA/IDAgOiB0aGlzLl9ydHM7IC8vIHJlY29yZGVkIHRpbWVTY2FsZS4gU3BlY2lhbCBjYXNlOiBpZiBzb21lb25lIGNhbGxzIHJldmVyc2UoKSBvbiBhbiBhbmltYXRpb24gd2l0aCB0aW1lU2NhbGUgb2YgMCwgd2UgYXNzaWduIGl0IC1fdGlueU51bSB0byByZW1lbWJlciBpdCdzIHJldmVyc2VkLlxuICAgIH1cblxuICAgIGlmICh0aGlzLl9ydHMgPT09IHZhbHVlKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICB2YXIgdFRpbWUgPSB0aGlzLnBhcmVudCAmJiB0aGlzLl90cyA/IF9wYXJlbnRUb0NoaWxkVG90YWxUaW1lKHRoaXMucGFyZW50Ll90aW1lLCB0aGlzKSA6IHRoaXMuX3RUaW1lOyAvLyBtYWtlIHN1cmUgdG8gZG8gdGhlIHBhcmVudFRvQ2hpbGRUb3RhbFRpbWUoKSBCRUZPUkUgc2V0dGluZyB0aGUgbmV3IF90cyBiZWNhdXNlIHRoZSBvbGQgb25lIG11c3QgYmUgdXNlZCBpbiB0aGF0IGNhbGN1bGF0aW9uLlxuICAgIC8vIGZ1dHVyZSBhZGRpdGlvbj8gVXAgc2lkZTogZmFzdCBhbmQgbWluaW1hbCBmaWxlIHNpemUuIERvd24gc2lkZTogb25seSB3b3JrcyBvbiB0aGlzIGFuaW1hdGlvbjsgaWYgYSB0aW1lbGluZSBpcyByZXZlcnNlZCwgZm9yIGV4YW1wbGUsIGl0cyBjaGlsZHJlbnMnIG9uUmV2ZXJzZSB3b3VsZG4ndCBnZXQgY2FsbGVkLlxuICAgIC8vKCt2YWx1ZSA8IDAgJiYgdGhpcy5fcnRzID49IDApICYmIF9jYWxsYmFjayh0aGlzLCBcIm9uUmV2ZXJzZVwiLCB0cnVlKTtcbiAgICAvLyBwcmlvcml0aXplIHJlbmRlcmluZyB3aGVyZSB0aGUgcGFyZW50J3MgcGxheWhlYWQgbGluZXMgdXAgaW5zdGVhZCBvZiB0aGlzLl90VGltZSBiZWNhdXNlIHRoZXJlIGNvdWxkIGJlIGEgdHdlZW4gdGhhdCdzIGFuaW1hdGluZyBhbm90aGVyIHR3ZWVuJ3MgdGltZVNjYWxlIGluIHRoZSBzYW1lIHJlbmRlcmluZyBsb29wIChzYW1lIHBhcmVudCksIHRodXMgaWYgdGhlIHRpbWVTY2FsZSB0d2VlbiByZW5kZXJzIGZpcnN0LCBpdCB3b3VsZCBhbHRlciBfc3RhcnQgQkVGT1JFIF90VGltZSB3YXMgc2V0IG9uIHRoYXQgdGljayAoaW4gdGhlIHJlbmRlcmluZyBsb29wKSwgZWZmZWN0aXZlbHkgZnJlZXppbmcgaXQgdW50aWwgdGhlIHRpbWVTY2FsZSB0d2VlbiBmaW5pc2hlcy5cblxuICAgIHRoaXMuX3J0cyA9ICt2YWx1ZSB8fCAwO1xuICAgIHRoaXMuX3RzID0gdGhpcy5fcHMgfHwgdmFsdWUgPT09IC1fdGlueU51bSA/IDAgOiB0aGlzLl9ydHM7IC8vIF90cyBpcyB0aGUgZnVuY3Rpb25hbCB0aW1lU2NhbGUgd2hpY2ggd291bGQgYmUgMCBpZiB0aGUgYW5pbWF0aW9uIGlzIHBhdXNlZC5cblxuICAgIHRoaXMudG90YWxUaW1lKF9jbGFtcCgtdGhpcy5fZGVsYXksIHRoaXMuX3REdXIsIHRUaW1lKSwgdHJ1ZSk7XG5cbiAgICBfc2V0RW5kKHRoaXMpOyAvLyBpZiBwYXJlbnQuc21vb3RoQ2hpbGRUaW1pbmcgd2FzIGZhbHNlLCB0aGUgZW5kIHRpbWUgZGlkbid0IGdldCB1cGRhdGVkIGluIHRoZSBfYWxpZ25QbGF5aGVhZCgpIG1ldGhvZCwgc28gZG8gaXQgaGVyZS5cblxuXG4gICAgcmV0dXJuIF9yZWNhY2hlQW5jZXN0b3JzKHRoaXMpO1xuICB9O1xuXG4gIF9wcm90by5wYXVzZWQgPSBmdW5jdGlvbiBwYXVzZWQodmFsdWUpIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9wcztcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fcHMgIT09IHZhbHVlKSB7XG4gICAgICB0aGlzLl9wcyA9IHZhbHVlO1xuXG4gICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgdGhpcy5fcFRpbWUgPSB0aGlzLl90VGltZSB8fCBNYXRoLm1heCgtdGhpcy5fZGVsYXksIHRoaXMucmF3VGltZSgpKTsgLy8gaWYgdGhlIHBhdXNlIG9jY3VycyBkdXJpbmcgdGhlIGRlbGF5IHBoYXNlLCBtYWtlIHN1cmUgdGhhdCdzIGZhY3RvcmVkIGluIHdoZW4gcmVzdW1pbmcuXG5cbiAgICAgICAgdGhpcy5fdHMgPSB0aGlzLl9hY3QgPSAwOyAvLyBfdHMgaXMgdGhlIGZ1bmN0aW9uYWwgdGltZVNjYWxlLCBzbyBhIHBhdXNlZCB0d2VlbiB3b3VsZCBlZmZlY3RpdmVseSBoYXZlIGEgdGltZVNjYWxlIG9mIDAuIFdlIHJlY29yZCB0aGUgXCJyZWFsXCIgdGltZVNjYWxlIGFzIF9ydHMgKHJlY29yZGVkIHRpbWUgc2NhbGUpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBfd2FrZSgpO1xuXG4gICAgICAgIHRoaXMuX3RzID0gdGhpcy5fcnRzOyAvL29ubHkgZGVmZXIgdG8gX3BUaW1lIChwYXVzZVRpbWUpIGlmIHRUaW1lIGlzIHplcm8uIFJlbWVtYmVyLCBzb21lb25lIGNvdWxkIHBhdXNlKCkgYW4gYW5pbWF0aW9uLCB0aGVuIHNjcnViIHRoZSBwbGF5aGVhZCBhbmQgcmVzdW1lKCkuIElmIHRoZSBwYXJlbnQgZG9lc24ndCBoYXZlIHNtb290aENoaWxkVGltaW5nLCB3ZSByZW5kZXIgYXQgdGhlIHJhd1RpbWUoKSBiZWNhdXNlIHRoZSBzdGFydFRpbWUgd29uJ3QgZ2V0IHVwZGF0ZWQuXG5cbiAgICAgICAgdGhpcy50b3RhbFRpbWUodGhpcy5wYXJlbnQgJiYgIXRoaXMucGFyZW50LnNtb290aENoaWxkVGltaW5nID8gdGhpcy5yYXdUaW1lKCkgOiB0aGlzLl90VGltZSB8fCB0aGlzLl9wVGltZSwgdGhpcy5wcm9ncmVzcygpID09PSAxICYmIE1hdGguYWJzKHRoaXMuX3pUaW1lKSAhPT0gX3RpbnlOdW0gJiYgKHRoaXMuX3RUaW1lIC09IF90aW55TnVtKSk7IC8vIGVkZ2UgY2FzZTogYW5pbWF0aW9uLnByb2dyZXNzKDEpLnBhdXNlKCkucGxheSgpIHdvdWxkbid0IHJlbmRlciBhZ2FpbiBiZWNhdXNlIHRoZSBwbGF5aGVhZCBpcyBhbHJlYWR5IGF0IHRoZSBlbmQsIGJ1dCB0aGUgY2FsbCB0byB0b3RhbFRpbWUoKSBiZWxvdyB3aWxsIGFkZCBpdCBiYWNrIHRvIGl0cyBwYXJlbnQuLi5hbmQgbm90IHJlbW92ZSBpdCBhZ2FpbiAoc2luY2UgcmVtb3Zpbmcgb25seSBoYXBwZW5zIHVwb24gcmVuZGVyaW5nIGF0IGEgbmV3IHRpbWUpLiBPZmZzZXR0aW5nIHRoZSBfdFRpbWUgc2xpZ2h0bHkgaXMgZG9uZSBzaW1wbHkgdG8gY2F1c2UgdGhlIGZpbmFsIHJlbmRlciBpbiB0b3RhbFRpbWUoKSB0aGF0J2xsIHBvcCBpdCBvZmYgaXRzIHRpbWVsaW5lIChpZiBhdXRvUmVtb3ZlQ2hpbGRyZW4gaXMgdHJ1ZSwgb2YgY291cnNlKS4gQ2hlY2sgdG8gbWFrZSBzdXJlIF96VGltZSBpc24ndCAtX3RpbnlOdW0gdG8gYXZvaWQgYW4gZWRnZSBjYXNlIHdoZXJlIHRoZSBwbGF5aGVhZCBpcyBwdXNoZWQgdG8gdGhlIGVuZCBidXQgSU5TSURFIGEgdHdlZW4vY2FsbGJhY2ssIHRoZSB0aW1lbGluZSBpdHNlbGYgaXMgcGF1c2VkIHRodXMgaGFsdGluZyByZW5kZXJpbmcgYW5kIGxlYXZpbmcgYSBmZXcgdW5yZW5kZXJlZC4gV2hlbiByZXN1bWluZywgaXQgd291bGRuJ3QgcmVuZGVyIHRob3NlIG90aGVyd2lzZS5cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBfcHJvdG8uc3RhcnRUaW1lID0gZnVuY3Rpb24gc3RhcnRUaW1lKHZhbHVlKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgIHRoaXMuX3N0YXJ0ID0gdmFsdWU7XG4gICAgICB2YXIgcGFyZW50ID0gdGhpcy5wYXJlbnQgfHwgdGhpcy5fZHA7XG4gICAgICBwYXJlbnQgJiYgKHBhcmVudC5fc29ydCB8fCAhdGhpcy5wYXJlbnQpICYmIF9hZGRUb1RpbWVsaW5lKHBhcmVudCwgdGhpcywgdmFsdWUgLSB0aGlzLl9kZWxheSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5fc3RhcnQ7XG4gIH07XG5cbiAgX3Byb3RvLmVuZFRpbWUgPSBmdW5jdGlvbiBlbmRUaW1lKGluY2x1ZGVSZXBlYXRzKSB7XG4gICAgcmV0dXJuIHRoaXMuX3N0YXJ0ICsgKF9pc05vdEZhbHNlKGluY2x1ZGVSZXBlYXRzKSA/IHRoaXMudG90YWxEdXJhdGlvbigpIDogdGhpcy5kdXJhdGlvbigpKSAvIE1hdGguYWJzKHRoaXMuX3RzIHx8IDEpO1xuICB9O1xuXG4gIF9wcm90by5yYXdUaW1lID0gZnVuY3Rpb24gcmF3VGltZSh3cmFwUmVwZWF0cykge1xuICAgIHZhciBwYXJlbnQgPSB0aGlzLnBhcmVudCB8fCB0aGlzLl9kcDsgLy8gX2RwID0gZGV0YWNoZWQgcGFyZW50XG5cbiAgICByZXR1cm4gIXBhcmVudCA/IHRoaXMuX3RUaW1lIDogd3JhcFJlcGVhdHMgJiYgKCF0aGlzLl90cyB8fCB0aGlzLl9yZXBlYXQgJiYgdGhpcy5fdGltZSAmJiB0aGlzLnRvdGFsUHJvZ3Jlc3MoKSA8IDEpID8gdGhpcy5fdFRpbWUgJSAodGhpcy5fZHVyICsgdGhpcy5fckRlbGF5KSA6ICF0aGlzLl90cyA/IHRoaXMuX3RUaW1lIDogX3BhcmVudFRvQ2hpbGRUb3RhbFRpbWUocGFyZW50LnJhd1RpbWUod3JhcFJlcGVhdHMpLCB0aGlzKTtcbiAgfTtcblxuICBfcHJvdG8uZ2xvYmFsVGltZSA9IGZ1bmN0aW9uIGdsb2JhbFRpbWUocmF3VGltZSkge1xuICAgIHZhciBhbmltYXRpb24gPSB0aGlzLFxuICAgICAgICB0aW1lID0gYXJndW1lbnRzLmxlbmd0aCA/IHJhd1RpbWUgOiBhbmltYXRpb24ucmF3VGltZSgpO1xuXG4gICAgd2hpbGUgKGFuaW1hdGlvbikge1xuICAgICAgdGltZSA9IGFuaW1hdGlvbi5fc3RhcnQgKyB0aW1lIC8gKGFuaW1hdGlvbi5fdHMgfHwgMSk7XG4gICAgICBhbmltYXRpb24gPSBhbmltYXRpb24uX2RwO1xuICAgIH1cblxuICAgIHJldHVybiB0aW1lO1xuICB9O1xuXG4gIF9wcm90by5yZXBlYXQgPSBmdW5jdGlvbiByZXBlYXQodmFsdWUpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgdGhpcy5fcmVwZWF0ID0gdmFsdWUgPT09IEluZmluaXR5ID8gLTIgOiB2YWx1ZTtcbiAgICAgIHJldHVybiBfb25VcGRhdGVUb3RhbER1cmF0aW9uKHRoaXMpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLl9yZXBlYXQgPT09IC0yID8gSW5maW5pdHkgOiB0aGlzLl9yZXBlYXQ7XG4gIH07XG5cbiAgX3Byb3RvLnJlcGVhdERlbGF5ID0gZnVuY3Rpb24gcmVwZWF0RGVsYXkodmFsdWUpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgdmFyIHRpbWUgPSB0aGlzLl90aW1lO1xuICAgICAgdGhpcy5fckRlbGF5ID0gdmFsdWU7XG5cbiAgICAgIF9vblVwZGF0ZVRvdGFsRHVyYXRpb24odGhpcyk7XG5cbiAgICAgIHJldHVybiB0aW1lID8gdGhpcy50aW1lKHRpbWUpIDogdGhpcztcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5fckRlbGF5O1xuICB9O1xuXG4gIF9wcm90by55b3lvID0gZnVuY3Rpb24geW95byh2YWx1ZSkge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICB0aGlzLl95b3lvID0gdmFsdWU7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5feW95bztcbiAgfTtcblxuICBfcHJvdG8uc2VlayA9IGZ1bmN0aW9uIHNlZWsocG9zaXRpb24sIHN1cHByZXNzRXZlbnRzKSB7XG4gICAgcmV0dXJuIHRoaXMudG90YWxUaW1lKF9wYXJzZVBvc2l0aW9uKHRoaXMsIHBvc2l0aW9uKSwgX2lzTm90RmFsc2Uoc3VwcHJlc3NFdmVudHMpKTtcbiAgfTtcblxuICBfcHJvdG8ucmVzdGFydCA9IGZ1bmN0aW9uIHJlc3RhcnQoaW5jbHVkZURlbGF5LCBzdXBwcmVzc0V2ZW50cykge1xuICAgIHJldHVybiB0aGlzLnBsYXkoKS50b3RhbFRpbWUoaW5jbHVkZURlbGF5ID8gLXRoaXMuX2RlbGF5IDogMCwgX2lzTm90RmFsc2Uoc3VwcHJlc3NFdmVudHMpKTtcbiAgfTtcblxuICBfcHJvdG8ucGxheSA9IGZ1bmN0aW9uIHBsYXkoZnJvbSwgc3VwcHJlc3NFdmVudHMpIHtcbiAgICBmcm9tICE9IG51bGwgJiYgdGhpcy5zZWVrKGZyb20sIHN1cHByZXNzRXZlbnRzKTtcbiAgICByZXR1cm4gdGhpcy5yZXZlcnNlZChmYWxzZSkucGF1c2VkKGZhbHNlKTtcbiAgfTtcblxuICBfcHJvdG8ucmV2ZXJzZSA9IGZ1bmN0aW9uIHJldmVyc2UoZnJvbSwgc3VwcHJlc3NFdmVudHMpIHtcbiAgICBmcm9tICE9IG51bGwgJiYgdGhpcy5zZWVrKGZyb20gfHwgdGhpcy50b3RhbER1cmF0aW9uKCksIHN1cHByZXNzRXZlbnRzKTtcbiAgICByZXR1cm4gdGhpcy5yZXZlcnNlZCh0cnVlKS5wYXVzZWQoZmFsc2UpO1xuICB9O1xuXG4gIF9wcm90by5wYXVzZSA9IGZ1bmN0aW9uIHBhdXNlKGF0VGltZSwgc3VwcHJlc3NFdmVudHMpIHtcbiAgICBhdFRpbWUgIT0gbnVsbCAmJiB0aGlzLnNlZWsoYXRUaW1lLCBzdXBwcmVzc0V2ZW50cyk7XG4gICAgcmV0dXJuIHRoaXMucGF1c2VkKHRydWUpO1xuICB9O1xuXG4gIF9wcm90by5yZXN1bWUgPSBmdW5jdGlvbiByZXN1bWUoKSB7XG4gICAgcmV0dXJuIHRoaXMucGF1c2VkKGZhbHNlKTtcbiAgfTtcblxuICBfcHJvdG8ucmV2ZXJzZWQgPSBmdW5jdGlvbiByZXZlcnNlZCh2YWx1ZSkge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICAhIXZhbHVlICE9PSB0aGlzLnJldmVyc2VkKCkgJiYgdGhpcy50aW1lU2NhbGUoLXRoaXMuX3J0cyB8fCAodmFsdWUgPyAtX3RpbnlOdW0gOiAwKSk7IC8vIGluIGNhc2UgdGltZVNjYWxlIGlzIHplcm8sIHJldmVyc2luZyB3b3VsZCBoYXZlIG5vIGVmZmVjdCBzbyB3ZSB1c2UgX3RpbnlOdW0uXG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLl9ydHMgPCAwO1xuICB9O1xuXG4gIF9wcm90by5pbnZhbGlkYXRlID0gZnVuY3Rpb24gaW52YWxpZGF0ZSgpIHtcbiAgICB0aGlzLl9pbml0dGVkID0gdGhpcy5fYWN0ID0gMDtcbiAgICB0aGlzLl96VGltZSA9IC1fdGlueU51bTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBfcHJvdG8uaXNBY3RpdmUgPSBmdW5jdGlvbiBpc0FjdGl2ZSgpIHtcbiAgICB2YXIgcGFyZW50ID0gdGhpcy5wYXJlbnQgfHwgdGhpcy5fZHAsXG4gICAgICAgIHN0YXJ0ID0gdGhpcy5fc3RhcnQsXG4gICAgICAgIHJhd1RpbWU7XG4gICAgcmV0dXJuICEhKCFwYXJlbnQgfHwgdGhpcy5fdHMgJiYgdGhpcy5faW5pdHRlZCAmJiBwYXJlbnQuaXNBY3RpdmUoKSAmJiAocmF3VGltZSA9IHBhcmVudC5yYXdUaW1lKHRydWUpKSA+PSBzdGFydCAmJiByYXdUaW1lIDwgdGhpcy5lbmRUaW1lKHRydWUpIC0gX3RpbnlOdW0pO1xuICB9O1xuXG4gIF9wcm90by5ldmVudENhbGxiYWNrID0gZnVuY3Rpb24gZXZlbnRDYWxsYmFjayh0eXBlLCBjYWxsYmFjaywgcGFyYW1zKSB7XG4gICAgdmFyIHZhcnMgPSB0aGlzLnZhcnM7XG5cbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgIGlmICghY2FsbGJhY2spIHtcbiAgICAgICAgZGVsZXRlIHZhcnNbdHlwZV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXJzW3R5cGVdID0gY2FsbGJhY2s7XG4gICAgICAgIHBhcmFtcyAmJiAodmFyc1t0eXBlICsgXCJQYXJhbXNcIl0gPSBwYXJhbXMpO1xuICAgICAgICB0eXBlID09PSBcIm9uVXBkYXRlXCIgJiYgKHRoaXMuX29uVXBkYXRlID0gY2FsbGJhY2spO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICByZXR1cm4gdmFyc1t0eXBlXTtcbiAgfTtcblxuICBfcHJvdG8udGhlbiA9IGZ1bmN0aW9uIHRoZW4ob25GdWxmaWxsZWQpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7XG4gICAgICB2YXIgZiA9IF9pc0Z1bmN0aW9uKG9uRnVsZmlsbGVkKSA/IG9uRnVsZmlsbGVkIDogX3Bhc3NUaHJvdWdoLFxuICAgICAgICAgIF9yZXNvbHZlID0gZnVuY3Rpb24gX3Jlc29sdmUoKSB7XG4gICAgICAgIHZhciBfdGhlbiA9IHNlbGYudGhlbjtcbiAgICAgICAgc2VsZi50aGVuID0gbnVsbDsgLy8gdGVtcG9yYXJpbHkgbnVsbCB0aGUgdGhlbigpIG1ldGhvZCB0byBhdm9pZCBhbiBpbmZpbml0ZSBsb29wIChzZWUgaHR0cHM6Ly9naXRodWIuY29tL2dyZWVuc29jay9HU0FQL2lzc3Vlcy8zMjIpXG5cbiAgICAgICAgX2lzRnVuY3Rpb24oZikgJiYgKGYgPSBmKHNlbGYpKSAmJiAoZi50aGVuIHx8IGYgPT09IHNlbGYpICYmIChzZWxmLnRoZW4gPSBfdGhlbik7XG4gICAgICAgIHJlc29sdmUoZik7XG4gICAgICAgIHNlbGYudGhlbiA9IF90aGVuO1xuICAgICAgfTtcblxuICAgICAgaWYgKHNlbGYuX2luaXR0ZWQgJiYgc2VsZi50b3RhbFByb2dyZXNzKCkgPT09IDEgJiYgc2VsZi5fdHMgPj0gMCB8fCAhc2VsZi5fdFRpbWUgJiYgc2VsZi5fdHMgPCAwKSB7XG4gICAgICAgIF9yZXNvbHZlKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZWxmLl9wcm9tID0gX3Jlc29sdmU7XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG5cbiAgX3Byb3RvLmtpbGwgPSBmdW5jdGlvbiBraWxsKCkge1xuICAgIF9pbnRlcnJ1cHQodGhpcyk7XG4gIH07XG5cbiAgcmV0dXJuIEFuaW1hdGlvbjtcbn0oKTtcblxuX3NldERlZmF1bHRzKEFuaW1hdGlvbi5wcm90b3R5cGUsIHtcbiAgX3RpbWU6IDAsXG4gIF9zdGFydDogMCxcbiAgX2VuZDogMCxcbiAgX3RUaW1lOiAwLFxuICBfdER1cjogMCxcbiAgX2RpcnR5OiAwLFxuICBfcmVwZWF0OiAwLFxuICBfeW95bzogZmFsc2UsXG4gIHBhcmVudDogbnVsbCxcbiAgX2luaXR0ZWQ6IGZhbHNlLFxuICBfckRlbGF5OiAwLFxuICBfdHM6IDEsXG4gIF9kcDogMCxcbiAgcmF0aW86IDAsXG4gIF96VGltZTogLV90aW55TnVtLFxuICBfcHJvbTogMCxcbiAgX3BzOiBmYWxzZSxcbiAgX3J0czogMVxufSk7XG4vKlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogVElNRUxJTkVcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqL1xuXG5cbmV4cG9ydCB2YXIgVGltZWxpbmUgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9BbmltYXRpb24pIHtcbiAgX2luaGVyaXRzTG9vc2UoVGltZWxpbmUsIF9BbmltYXRpb24pO1xuXG4gIGZ1bmN0aW9uIFRpbWVsaW5lKHZhcnMsIHBvc2l0aW9uKSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgaWYgKHZhcnMgPT09IHZvaWQgMCkge1xuICAgICAgdmFycyA9IHt9O1xuICAgIH1cblxuICAgIF90aGlzID0gX0FuaW1hdGlvbi5jYWxsKHRoaXMsIHZhcnMpIHx8IHRoaXM7XG4gICAgX3RoaXMubGFiZWxzID0ge307XG4gICAgX3RoaXMuc21vb3RoQ2hpbGRUaW1pbmcgPSAhIXZhcnMuc21vb3RoQ2hpbGRUaW1pbmc7XG4gICAgX3RoaXMuYXV0b1JlbW92ZUNoaWxkcmVuID0gISF2YXJzLmF1dG9SZW1vdmVDaGlsZHJlbjtcbiAgICBfdGhpcy5fc29ydCA9IF9pc05vdEZhbHNlKHZhcnMuc29ydENoaWxkcmVuKTtcbiAgICBfZ2xvYmFsVGltZWxpbmUgJiYgX2FkZFRvVGltZWxpbmUodmFycy5wYXJlbnQgfHwgX2dsb2JhbFRpbWVsaW5lLCBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSwgcG9zaXRpb24pO1xuICAgIHZhcnMucmV2ZXJzZWQgJiYgX3RoaXMucmV2ZXJzZSgpO1xuICAgIHZhcnMucGF1c2VkICYmIF90aGlzLnBhdXNlZCh0cnVlKTtcbiAgICB2YXJzLnNjcm9sbFRyaWdnZXIgJiYgX3Njcm9sbFRyaWdnZXIoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcyksIHZhcnMuc2Nyb2xsVHJpZ2dlcik7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgdmFyIF9wcm90bzIgPSBUaW1lbGluZS5wcm90b3R5cGU7XG5cbiAgX3Byb3RvMi50byA9IGZ1bmN0aW9uIHRvKHRhcmdldHMsIHZhcnMsIHBvc2l0aW9uKSB7XG4gICAgX2NyZWF0ZVR3ZWVuVHlwZSgwLCBhcmd1bWVudHMsIHRoaXMpO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgX3Byb3RvMi5mcm9tID0gZnVuY3Rpb24gZnJvbSh0YXJnZXRzLCB2YXJzLCBwb3NpdGlvbikge1xuICAgIF9jcmVhdGVUd2VlblR5cGUoMSwgYXJndW1lbnRzLCB0aGlzKTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIF9wcm90bzIuZnJvbVRvID0gZnVuY3Rpb24gZnJvbVRvKHRhcmdldHMsIGZyb21WYXJzLCB0b1ZhcnMsIHBvc2l0aW9uKSB7XG4gICAgX2NyZWF0ZVR3ZWVuVHlwZSgyLCBhcmd1bWVudHMsIHRoaXMpO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgX3Byb3RvMi5zZXQgPSBmdW5jdGlvbiBzZXQodGFyZ2V0cywgdmFycywgcG9zaXRpb24pIHtcbiAgICB2YXJzLmR1cmF0aW9uID0gMDtcbiAgICB2YXJzLnBhcmVudCA9IHRoaXM7XG4gICAgX2luaGVyaXREZWZhdWx0cyh2YXJzKS5yZXBlYXREZWxheSB8fCAodmFycy5yZXBlYXQgPSAwKTtcbiAgICB2YXJzLmltbWVkaWF0ZVJlbmRlciA9ICEhdmFycy5pbW1lZGlhdGVSZW5kZXI7XG4gICAgbmV3IFR3ZWVuKHRhcmdldHMsIHZhcnMsIF9wYXJzZVBvc2l0aW9uKHRoaXMsIHBvc2l0aW9uKSwgMSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgX3Byb3RvMi5jYWxsID0gZnVuY3Rpb24gY2FsbChjYWxsYmFjaywgcGFyYW1zLCBwb3NpdGlvbikge1xuICAgIHJldHVybiBfYWRkVG9UaW1lbGluZSh0aGlzLCBUd2Vlbi5kZWxheWVkQ2FsbCgwLCBjYWxsYmFjaywgcGFyYW1zKSwgcG9zaXRpb24pO1xuICB9IC8vT05MWSBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eSEgTWF5YmUgZGVsZXRlP1xuICA7XG5cbiAgX3Byb3RvMi5zdGFnZ2VyVG8gPSBmdW5jdGlvbiBzdGFnZ2VyVG8odGFyZ2V0cywgZHVyYXRpb24sIHZhcnMsIHN0YWdnZXIsIHBvc2l0aW9uLCBvbkNvbXBsZXRlQWxsLCBvbkNvbXBsZXRlQWxsUGFyYW1zKSB7XG4gICAgdmFycy5kdXJhdGlvbiA9IGR1cmF0aW9uO1xuICAgIHZhcnMuc3RhZ2dlciA9IHZhcnMuc3RhZ2dlciB8fCBzdGFnZ2VyO1xuICAgIHZhcnMub25Db21wbGV0ZSA9IG9uQ29tcGxldGVBbGw7XG4gICAgdmFycy5vbkNvbXBsZXRlUGFyYW1zID0gb25Db21wbGV0ZUFsbFBhcmFtcztcbiAgICB2YXJzLnBhcmVudCA9IHRoaXM7XG4gICAgbmV3IFR3ZWVuKHRhcmdldHMsIHZhcnMsIF9wYXJzZVBvc2l0aW9uKHRoaXMsIHBvc2l0aW9uKSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgX3Byb3RvMi5zdGFnZ2VyRnJvbSA9IGZ1bmN0aW9uIHN0YWdnZXJGcm9tKHRhcmdldHMsIGR1cmF0aW9uLCB2YXJzLCBzdGFnZ2VyLCBwb3NpdGlvbiwgb25Db21wbGV0ZUFsbCwgb25Db21wbGV0ZUFsbFBhcmFtcykge1xuICAgIHZhcnMucnVuQmFja3dhcmRzID0gMTtcbiAgICBfaW5oZXJpdERlZmF1bHRzKHZhcnMpLmltbWVkaWF0ZVJlbmRlciA9IF9pc05vdEZhbHNlKHZhcnMuaW1tZWRpYXRlUmVuZGVyKTtcbiAgICByZXR1cm4gdGhpcy5zdGFnZ2VyVG8odGFyZ2V0cywgZHVyYXRpb24sIHZhcnMsIHN0YWdnZXIsIHBvc2l0aW9uLCBvbkNvbXBsZXRlQWxsLCBvbkNvbXBsZXRlQWxsUGFyYW1zKTtcbiAgfTtcblxuICBfcHJvdG8yLnN0YWdnZXJGcm9tVG8gPSBmdW5jdGlvbiBzdGFnZ2VyRnJvbVRvKHRhcmdldHMsIGR1cmF0aW9uLCBmcm9tVmFycywgdG9WYXJzLCBzdGFnZ2VyLCBwb3NpdGlvbiwgb25Db21wbGV0ZUFsbCwgb25Db21wbGV0ZUFsbFBhcmFtcykge1xuICAgIHRvVmFycy5zdGFydEF0ID0gZnJvbVZhcnM7XG4gICAgX2luaGVyaXREZWZhdWx0cyh0b1ZhcnMpLmltbWVkaWF0ZVJlbmRlciA9IF9pc05vdEZhbHNlKHRvVmFycy5pbW1lZGlhdGVSZW5kZXIpO1xuICAgIHJldHVybiB0aGlzLnN0YWdnZXJUbyh0YXJnZXRzLCBkdXJhdGlvbiwgdG9WYXJzLCBzdGFnZ2VyLCBwb3NpdGlvbiwgb25Db21wbGV0ZUFsbCwgb25Db21wbGV0ZUFsbFBhcmFtcyk7XG4gIH07XG5cbiAgX3Byb3RvMi5yZW5kZXIgPSBmdW5jdGlvbiByZW5kZXIodG90YWxUaW1lLCBzdXBwcmVzc0V2ZW50cywgZm9yY2UpIHtcbiAgICB2YXIgcHJldlRpbWUgPSB0aGlzLl90aW1lLFxuICAgICAgICB0RHVyID0gdGhpcy5fZGlydHkgPyB0aGlzLnRvdGFsRHVyYXRpb24oKSA6IHRoaXMuX3REdXIsXG4gICAgICAgIGR1ciA9IHRoaXMuX2R1cixcbiAgICAgICAgdFRpbWUgPSB0b3RhbFRpbWUgPD0gMCA/IDAgOiBfcm91bmRQcmVjaXNlKHRvdGFsVGltZSksXG4gICAgICAgIC8vIGlmIGEgcGF1c2VkIHRpbWVsaW5lIGlzIHJlc3VtZWQgKG9yIGl0cyBfc3RhcnQgaXMgdXBkYXRlZCBmb3IgYW5vdGhlciByZWFzb24uLi53aGljaCByb3VuZHMgaXQpLCB0aGF0IGNvdWxkIHJlc3VsdCBpbiB0aGUgcGxheWhlYWQgc2hpZnRpbmcgYSAqKnRpbnkqKiBhbW91bnQgYW5kIGEgemVyby1kdXJhdGlvbiBjaGlsZCBhdCB0aGF0IHNwb3QgbWF5IGdldCByZW5kZXJlZCBhdCBhIGRpZmZlcmVudCByYXRpbywgbGlrZSBpdHMgdG90YWxUaW1lIGluIHJlbmRlcigpIG1heSBiZSAxZS0xNyBpbnN0ZWFkIG9mIDAsIGZvciBleGFtcGxlLlxuICAgIGNyb3NzaW5nU3RhcnQgPSB0aGlzLl96VGltZSA8IDAgIT09IHRvdGFsVGltZSA8IDAgJiYgKHRoaXMuX2luaXR0ZWQgfHwgIWR1ciksXG4gICAgICAgIHRpbWUsXG4gICAgICAgIGNoaWxkLFxuICAgICAgICBuZXh0LFxuICAgICAgICBpdGVyYXRpb24sXG4gICAgICAgIGN5Y2xlRHVyYXRpb24sXG4gICAgICAgIHByZXZQYXVzZWQsXG4gICAgICAgIHBhdXNlVHdlZW4sXG4gICAgICAgIHRpbWVTY2FsZSxcbiAgICAgICAgcHJldlN0YXJ0LFxuICAgICAgICBwcmV2SXRlcmF0aW9uLFxuICAgICAgICB5b3lvLFxuICAgICAgICBpc1lveW87XG4gICAgdGhpcyAhPT0gX2dsb2JhbFRpbWVsaW5lICYmIHRUaW1lID4gdER1ciAmJiB0b3RhbFRpbWUgPj0gMCAmJiAodFRpbWUgPSB0RHVyKTtcblxuICAgIGlmICh0VGltZSAhPT0gdGhpcy5fdFRpbWUgfHwgZm9yY2UgfHwgY3Jvc3NpbmdTdGFydCkge1xuICAgICAgaWYgKHByZXZUaW1lICE9PSB0aGlzLl90aW1lICYmIGR1cikge1xuICAgICAgICAvL2lmIHRvdGFsRHVyYXRpb24oKSBmaW5kcyBhIGNoaWxkIHdpdGggYSBuZWdhdGl2ZSBzdGFydFRpbWUgYW5kIHNtb290aENoaWxkVGltaW5nIGlzIHRydWUsIHRoaW5ncyBnZXQgc2hpZnRlZCBhcm91bmQgaW50ZXJuYWxseSBzbyB3ZSBuZWVkIHRvIGFkanVzdCB0aGUgdGltZSBhY2NvcmRpbmdseS4gRm9yIGV4YW1wbGUsIGlmIGEgdHdlZW4gc3RhcnRzIGF0IC0zMCB3ZSBtdXN0IHNoaWZ0IEVWRVJZVEhJTkcgZm9yd2FyZCAzMCBzZWNvbmRzIGFuZCBtb3ZlIHRoaXMgdGltZWxpbmUncyBzdGFydFRpbWUgYmFja3dhcmQgYnkgMzAgc2Vjb25kcyBzbyB0aGF0IHRoaW5ncyBhbGlnbiB3aXRoIHRoZSBwbGF5aGVhZCAobm8ganVtcCkuXG4gICAgICAgIHRUaW1lICs9IHRoaXMuX3RpbWUgLSBwcmV2VGltZTtcbiAgICAgICAgdG90YWxUaW1lICs9IHRoaXMuX3RpbWUgLSBwcmV2VGltZTtcbiAgICAgIH1cblxuICAgICAgdGltZSA9IHRUaW1lO1xuICAgICAgcHJldlN0YXJ0ID0gdGhpcy5fc3RhcnQ7XG4gICAgICB0aW1lU2NhbGUgPSB0aGlzLl90cztcbiAgICAgIHByZXZQYXVzZWQgPSAhdGltZVNjYWxlO1xuXG4gICAgICBpZiAoY3Jvc3NpbmdTdGFydCkge1xuICAgICAgICBkdXIgfHwgKHByZXZUaW1lID0gdGhpcy5felRpbWUpOyAvL3doZW4gdGhlIHBsYXloZWFkIGFycml2ZXMgYXQgRVhBQ1RMWSB0aW1lIDAgKHJpZ2h0IG9uIHRvcCkgb2YgYSB6ZXJvLWR1cmF0aW9uIHRpbWVsaW5lLCB3ZSBuZWVkIHRvIGRpc2Nlcm4gaWYgZXZlbnRzIGFyZSBzdXBwcmVzc2VkIHNvIHRoYXQgd2hlbiB0aGUgcGxheWhlYWQgbW92ZXMgYWdhaW4gKG5leHQgdGltZSksIGl0J2xsIHRyaWdnZXIgdGhlIGNhbGxiYWNrLiBJZiBldmVudHMgYXJlIE5PVCBzdXBwcmVzc2VkLCBvYnZpb3VzbHkgdGhlIGNhbGxiYWNrIHdvdWxkIGJlIHRyaWdnZXJlZCBpbiB0aGlzIHJlbmRlci4gQmFzaWNhbGx5LCB0aGUgY2FsbGJhY2sgc2hvdWxkIGZpcmUgZWl0aGVyIHdoZW4gdGhlIHBsYXloZWFkIEFSUklWRVMgb3IgTEVBVkVTIHRoaXMgZXhhY3Qgc3BvdCwgbm90IGJvdGguIEltYWdpbmUgZG9pbmcgYSB0aW1lbGluZS5zZWVrKDApIGFuZCB0aGVyZSdzIGEgY2FsbGJhY2sgdGhhdCBzaXRzIGF0IDAuIFNpbmNlIGV2ZW50cyBhcmUgc3VwcHJlc3NlZCBvbiB0aGF0IHNlZWsoKSBieSBkZWZhdWx0LCBub3RoaW5nIHdpbGwgZmlyZSwgYnV0IHdoZW4gdGhlIHBsYXloZWFkIG1vdmVzIG9mZiBvZiB0aGF0IHBvc2l0aW9uLCB0aGUgY2FsbGJhY2sgc2hvdWxkIGZpcmUuIFRoaXMgYmVoYXZpb3IgaXMgd2hhdCBwZW9wbGUgaW50dWl0aXZlbHkgZXhwZWN0LlxuXG4gICAgICAgICh0b3RhbFRpbWUgfHwgIXN1cHByZXNzRXZlbnRzKSAmJiAodGhpcy5felRpbWUgPSB0b3RhbFRpbWUpO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5fcmVwZWF0KSB7XG4gICAgICAgIC8vYWRqdXN0IHRoZSB0aW1lIGZvciByZXBlYXRzIGFuZCB5b3lvc1xuICAgICAgICB5b3lvID0gdGhpcy5feW95bztcbiAgICAgICAgY3ljbGVEdXJhdGlvbiA9IGR1ciArIHRoaXMuX3JEZWxheTtcblxuICAgICAgICBpZiAodGhpcy5fcmVwZWF0IDwgLTEgJiYgdG90YWxUaW1lIDwgMCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLnRvdGFsVGltZShjeWNsZUR1cmF0aW9uICogMTAwICsgdG90YWxUaW1lLCBzdXBwcmVzc0V2ZW50cywgZm9yY2UpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGltZSA9IF9yb3VuZFByZWNpc2UodFRpbWUgJSBjeWNsZUR1cmF0aW9uKTsgLy9yb3VuZCB0byBhdm9pZCBmbG9hdGluZyBwb2ludCBlcnJvcnMuICg0ICUgMC44IHNob3VsZCBiZSAwIGJ1dCBzb21lIGJyb3dzZXJzIHJlcG9ydCBpdCBhcyAwLjc5OTk5OTk5ISlcblxuICAgICAgICBpZiAodFRpbWUgPT09IHREdXIpIHtcbiAgICAgICAgICAvLyB0aGUgdER1ciA9PT0gdFRpbWUgaXMgZm9yIGVkZ2UgY2FzZXMgd2hlcmUgdGhlcmUncyBhIGxlbmd0aHkgZGVjaW1hbCBvbiB0aGUgZHVyYXRpb24gYW5kIGl0IG1heSByZWFjaCB0aGUgdmVyeSBlbmQgYnV0IHRoZSB0aW1lIGlzIHJlbmRlcmVkIGFzIG5vdC1xdWl0ZS10aGVyZSAocmVtZW1iZXIsIHREdXIgaXMgcm91bmRlZCB0byA0IGRlY2ltYWxzIHdoZXJlYXMgZHVyIGlzbid0KVxuICAgICAgICAgIGl0ZXJhdGlvbiA9IHRoaXMuX3JlcGVhdDtcbiAgICAgICAgICB0aW1lID0gZHVyO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGl0ZXJhdGlvbiA9IH5+KHRUaW1lIC8gY3ljbGVEdXJhdGlvbik7XG5cbiAgICAgICAgICBpZiAoaXRlcmF0aW9uICYmIGl0ZXJhdGlvbiA9PT0gdFRpbWUgLyBjeWNsZUR1cmF0aW9uKSB7XG4gICAgICAgICAgICB0aW1lID0gZHVyO1xuICAgICAgICAgICAgaXRlcmF0aW9uLS07XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGltZSA+IGR1ciAmJiAodGltZSA9IGR1cik7XG4gICAgICAgIH1cblxuICAgICAgICBwcmV2SXRlcmF0aW9uID0gX2FuaW1hdGlvbkN5Y2xlKHRoaXMuX3RUaW1lLCBjeWNsZUR1cmF0aW9uKTtcbiAgICAgICAgIXByZXZUaW1lICYmIHRoaXMuX3RUaW1lICYmIHByZXZJdGVyYXRpb24gIT09IGl0ZXJhdGlvbiAmJiAocHJldkl0ZXJhdGlvbiA9IGl0ZXJhdGlvbik7IC8vIGVkZ2UgY2FzZSAtIGlmIHNvbWVvbmUgZG9lcyBhZGRQYXVzZSgpIGF0IHRoZSB2ZXJ5IGJlZ2lubmluZyBvZiBhIHJlcGVhdGluZyB0aW1lbGluZSwgdGhhdCBwYXVzZSBpcyB0ZWNobmljYWxseSBhdCB0aGUgc2FtZSBzcG90IGFzIHRoZSBlbmQgd2hpY2ggY2F1c2VzIHRoaXMuX3RpbWUgdG8gZ2V0IHNldCB0byAwIHdoZW4gdGhlIHRvdGFsVGltZSB3b3VsZCBub3JtYWxseSBwbGFjZSB0aGUgcGxheWhlYWQgYXQgdGhlIGVuZC4gU2VlIGh0dHBzOi8vZ3JlZW5zb2NrLmNvbS9mb3J1bXMvdG9waWMvMjM4MjMtY2xvc2luZy1uYXYtYW5pbWF0aW9uLW5vdC13b3JraW5nLW9uLWllLWFuZC1pcGhvbmUtNi1tYXliZS1vdGhlci1vbGRlci1icm93c2VyLz90YWI9Y29tbWVudHMjY29tbWVudC0xMTMwMDVcblxuICAgICAgICBpZiAoeW95byAmJiBpdGVyYXRpb24gJiAxKSB7XG4gICAgICAgICAgdGltZSA9IGR1ciAtIHRpbWU7XG4gICAgICAgICAgaXNZb3lvID0gMTtcbiAgICAgICAgfVxuICAgICAgICAvKlxuICAgICAgICBtYWtlIHN1cmUgY2hpbGRyZW4gYXQgdGhlIGVuZC9iZWdpbm5pbmcgb2YgdGhlIHRpbWVsaW5lIGFyZSByZW5kZXJlZCBwcm9wZXJseS4gSWYsIGZvciBleGFtcGxlLFxuICAgICAgICBhIDMtc2Vjb25kIGxvbmcgdGltZWxpbmUgcmVuZGVyZWQgYXQgMi45IHNlY29uZHMgcHJldmlvdXNseSwgYW5kIG5vdyByZW5kZXJzIGF0IDMuMiBzZWNvbmRzICh3aGljaFxuICAgICAgICB3b3VsZCBnZXQgdHJhbnNsYXRlZCB0byAyLjggc2Vjb25kcyBpZiB0aGUgdGltZWxpbmUgeW95b3Mgb3IgMC4yIHNlY29uZHMgaWYgaXQganVzdCByZXBlYXRzKSwgdGhlcmVcbiAgICAgICAgY291bGQgYmUgYSBjYWxsYmFjayBvciBhIHNob3J0IHR3ZWVuIHRoYXQncyBhdCAyLjk1IG9yIDMgc2Vjb25kcyBpbiB3aGljaCB3b3VsZG4ndCByZW5kZXIuIFNvXG4gICAgICAgIHdlIG5lZWQgdG8gcHVzaCB0aGUgdGltZWxpbmUgdG8gdGhlIGVuZCAoYW5kL29yIGJlZ2lubmluZyBkZXBlbmRpbmcgb24gaXRzIHlveW8gdmFsdWUpLiBBbHNvIHdlIG11c3RcbiAgICAgICAgZW5zdXJlIHRoYXQgemVyby1kdXJhdGlvbiB0d2VlbnMgYXQgdGhlIHZlcnkgYmVnaW5uaW5nIG9yIGVuZCBvZiB0aGUgVGltZWxpbmUgd29yay5cbiAgICAgICAgKi9cblxuXG4gICAgICAgIGlmIChpdGVyYXRpb24gIT09IHByZXZJdGVyYXRpb24gJiYgIXRoaXMuX2xvY2spIHtcbiAgICAgICAgICB2YXIgcmV3aW5kaW5nID0geW95byAmJiBwcmV2SXRlcmF0aW9uICYgMSxcbiAgICAgICAgICAgICAgZG9lc1dyYXAgPSByZXdpbmRpbmcgPT09ICh5b3lvICYmIGl0ZXJhdGlvbiAmIDEpO1xuICAgICAgICAgIGl0ZXJhdGlvbiA8IHByZXZJdGVyYXRpb24gJiYgKHJld2luZGluZyA9ICFyZXdpbmRpbmcpO1xuICAgICAgICAgIHByZXZUaW1lID0gcmV3aW5kaW5nID8gMCA6IGR1cjtcbiAgICAgICAgICB0aGlzLl9sb2NrID0gMTtcbiAgICAgICAgICB0aGlzLnJlbmRlcihwcmV2VGltZSB8fCAoaXNZb3lvID8gMCA6IF9yb3VuZFByZWNpc2UoaXRlcmF0aW9uICogY3ljbGVEdXJhdGlvbikpLCBzdXBwcmVzc0V2ZW50cywgIWR1cikuX2xvY2sgPSAwO1xuICAgICAgICAgIHRoaXMuX3RUaW1lID0gdFRpbWU7IC8vIGlmIGEgdXNlciBnZXRzIHRoZSBpdGVyYXRpb24oKSBpbnNpZGUgdGhlIG9uUmVwZWF0LCBmb3IgZXhhbXBsZSwgaXQgc2hvdWxkIGJlIGFjY3VyYXRlLlxuXG4gICAgICAgICAgIXN1cHByZXNzRXZlbnRzICYmIHRoaXMucGFyZW50ICYmIF9jYWxsYmFjayh0aGlzLCBcIm9uUmVwZWF0XCIpO1xuICAgICAgICAgIHRoaXMudmFycy5yZXBlYXRSZWZyZXNoICYmICFpc1lveW8gJiYgKHRoaXMuaW52YWxpZGF0ZSgpLl9sb2NrID0gMSk7XG5cbiAgICAgICAgICBpZiAocHJldlRpbWUgJiYgcHJldlRpbWUgIT09IHRoaXMuX3RpbWUgfHwgcHJldlBhdXNlZCAhPT0gIXRoaXMuX3RzIHx8IHRoaXMudmFycy5vblJlcGVhdCAmJiAhdGhpcy5wYXJlbnQgJiYgIXRoaXMuX2FjdCkge1xuICAgICAgICAgICAgLy8gaWYgcHJldlRpbWUgaXMgMCBhbmQgd2UgcmVuZGVyIGF0IHRoZSB2ZXJ5IGVuZCwgX3RpbWUgd2lsbCBiZSB0aGUgZW5kLCB0aHVzIHdvbid0IG1hdGNoLiBTbyBpbiB0aGlzIGVkZ2UgY2FzZSwgcHJldlRpbWUgd29uJ3QgbWF0Y2ggX3RpbWUgYnV0IHRoYXQncyBva2F5LiBJZiBpdCBnZXRzIGtpbGxlZCBpbiB0aGUgb25SZXBlYXQsIGVqZWN0IGFzIHdlbGwuXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBkdXIgPSB0aGlzLl9kdXI7IC8vIGluIGNhc2UgdGhlIGR1cmF0aW9uIGNoYW5nZWQgaW4gdGhlIG9uUmVwZWF0XG5cbiAgICAgICAgICB0RHVyID0gdGhpcy5fdER1cjtcblxuICAgICAgICAgIGlmIChkb2VzV3JhcCkge1xuICAgICAgICAgICAgdGhpcy5fbG9jayA9IDI7XG4gICAgICAgICAgICBwcmV2VGltZSA9IHJld2luZGluZyA/IGR1ciA6IC0wLjAwMDE7XG4gICAgICAgICAgICB0aGlzLnJlbmRlcihwcmV2VGltZSwgdHJ1ZSk7XG4gICAgICAgICAgICB0aGlzLnZhcnMucmVwZWF0UmVmcmVzaCAmJiAhaXNZb3lvICYmIHRoaXMuaW52YWxpZGF0ZSgpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXMuX2xvY2sgPSAwO1xuXG4gICAgICAgICAgaWYgKCF0aGlzLl90cyAmJiAhcHJldlBhdXNlZCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgfSAvL2luIG9yZGVyIGZvciB5b3lvRWFzZSB0byB3b3JrIHByb3Blcmx5IHdoZW4gdGhlcmUncyBhIHN0YWdnZXIsIHdlIG11c3Qgc3dhcCBvdXQgdGhlIGVhc2UgaW4gZWFjaCBzdWItdHdlZW4uXG5cblxuICAgICAgICAgIF9wcm9wYWdhdGVZb3lvRWFzZSh0aGlzLCBpc1lveW8pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLl9oYXNQYXVzZSAmJiAhdGhpcy5fZm9yY2luZyAmJiB0aGlzLl9sb2NrIDwgMikge1xuICAgICAgICBwYXVzZVR3ZWVuID0gX2ZpbmROZXh0UGF1c2VUd2Vlbih0aGlzLCBfcm91bmRQcmVjaXNlKHByZXZUaW1lKSwgX3JvdW5kUHJlY2lzZSh0aW1lKSk7XG5cbiAgICAgICAgaWYgKHBhdXNlVHdlZW4pIHtcbiAgICAgICAgICB0VGltZSAtPSB0aW1lIC0gKHRpbWUgPSBwYXVzZVR3ZWVuLl9zdGFydCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdGhpcy5fdFRpbWUgPSB0VGltZTtcbiAgICAgIHRoaXMuX3RpbWUgPSB0aW1lO1xuICAgICAgdGhpcy5fYWN0ID0gIXRpbWVTY2FsZTsgLy9hcyBsb25nIGFzIGl0J3Mgbm90IHBhdXNlZCwgZm9yY2UgaXQgdG8gYmUgYWN0aXZlIHNvIHRoYXQgaWYgdGhlIHVzZXIgcmVuZGVycyBpbmRlcGVuZGVudCBvZiB0aGUgcGFyZW50IHRpbWVsaW5lLCBpdCdsbCBiZSBmb3JjZWQgdG8gcmUtcmVuZGVyIG9uIHRoZSBuZXh0IHRpY2suXG5cbiAgICAgIGlmICghdGhpcy5faW5pdHRlZCkge1xuICAgICAgICB0aGlzLl9vblVwZGF0ZSA9IHRoaXMudmFycy5vblVwZGF0ZTtcbiAgICAgICAgdGhpcy5faW5pdHRlZCA9IDE7XG4gICAgICAgIHRoaXMuX3pUaW1lID0gdG90YWxUaW1lO1xuICAgICAgICBwcmV2VGltZSA9IDA7IC8vIHVwb24gaW5pdCwgdGhlIHBsYXloZWFkIHNob3VsZCBhbHdheXMgZ28gZm9yd2FyZDsgc29tZW9uZSBjb3VsZCBpbnZhbGlkYXRlKCkgYSBjb21wbGV0ZWQgdGltZWxpbmUgYW5kIHRoZW4gaWYgdGhleSByZXN0YXJ0KCksIHRoYXQgd291bGQgbWFrZSBjaGlsZCB0d2VlbnMgcmVuZGVyIGluIHJldmVyc2Ugb3JkZXIgd2hpY2ggY291bGQgbG9jayBpbiB0aGUgd3Jvbmcgc3RhcnRpbmcgdmFsdWVzIGlmIHRoZXkgYnVpbGQgb24gZWFjaCBvdGhlciwgbGlrZSB0bC50byhvYmosIHt4OiAxMDB9KS50byhvYmosIHt4OiAwfSkuXG4gICAgICB9XG5cbiAgICAgIGlmICghcHJldlRpbWUgJiYgdGltZSAmJiAhc3VwcHJlc3NFdmVudHMpIHtcbiAgICAgICAgX2NhbGxiYWNrKHRoaXMsIFwib25TdGFydFwiKTtcblxuICAgICAgICBpZiAodGhpcy5fdFRpbWUgIT09IHRUaW1lKSB7XG4gICAgICAgICAgLy8gaW4gY2FzZSB0aGUgb25TdGFydCB0cmlnZ2VyZWQgYSByZW5kZXIgYXQgYSBkaWZmZXJlbnQgc3BvdCwgZWplY3QuIExpa2UgaWYgc29tZW9uZSBkaWQgYW5pbWF0aW9uLnBhdXNlKDAuNSkgb3Igc29tZXRoaW5nIGluc2lkZSB0aGUgb25TdGFydC5cbiAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAodGltZSA+PSBwcmV2VGltZSAmJiB0b3RhbFRpbWUgPj0gMCkge1xuICAgICAgICBjaGlsZCA9IHRoaXMuX2ZpcnN0O1xuXG4gICAgICAgIHdoaWxlIChjaGlsZCkge1xuICAgICAgICAgIG5leHQgPSBjaGlsZC5fbmV4dDtcblxuICAgICAgICAgIGlmICgoY2hpbGQuX2FjdCB8fCB0aW1lID49IGNoaWxkLl9zdGFydCkgJiYgY2hpbGQuX3RzICYmIHBhdXNlVHdlZW4gIT09IGNoaWxkKSB7XG4gICAgICAgICAgICBpZiAoY2hpbGQucGFyZW50ICE9PSB0aGlzKSB7XG4gICAgICAgICAgICAgIC8vIGFuIGV4dHJlbWUgZWRnZSBjYXNlIC0gdGhlIGNoaWxkJ3MgcmVuZGVyIGNvdWxkIGRvIHNvbWV0aGluZyBsaWtlIGtpbGwoKSB0aGUgXCJuZXh0XCIgb25lIGluIHRoZSBsaW5rZWQgbGlzdCwgb3IgcmVwYXJlbnQgaXQuIEluIHRoYXQgY2FzZSB3ZSBtdXN0IHJlLWluaXRpYXRlIHRoZSB3aG9sZSByZW5kZXIgdG8gYmUgc2FmZS5cbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVuZGVyKHRvdGFsVGltZSwgc3VwcHJlc3NFdmVudHMsIGZvcmNlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY2hpbGQucmVuZGVyKGNoaWxkLl90cyA+IDAgPyAodGltZSAtIGNoaWxkLl9zdGFydCkgKiBjaGlsZC5fdHMgOiAoY2hpbGQuX2RpcnR5ID8gY2hpbGQudG90YWxEdXJhdGlvbigpIDogY2hpbGQuX3REdXIpICsgKHRpbWUgLSBjaGlsZC5fc3RhcnQpICogY2hpbGQuX3RzLCBzdXBwcmVzc0V2ZW50cywgZm9yY2UpO1xuXG4gICAgICAgICAgICBpZiAodGltZSAhPT0gdGhpcy5fdGltZSB8fCAhdGhpcy5fdHMgJiYgIXByZXZQYXVzZWQpIHtcbiAgICAgICAgICAgICAgLy9pbiBjYXNlIGEgdHdlZW4gcGF1c2VzIG9yIHNlZWtzIHRoZSB0aW1lbGluZSB3aGVuIHJlbmRlcmluZywgbGlrZSBpbnNpZGUgb2YgYW4gb25VcGRhdGUvb25Db21wbGV0ZVxuICAgICAgICAgICAgICBwYXVzZVR3ZWVuID0gMDtcbiAgICAgICAgICAgICAgbmV4dCAmJiAodFRpbWUgKz0gdGhpcy5felRpbWUgPSAtX3RpbnlOdW0pOyAvLyBpdCBkaWRuJ3QgZmluaXNoIHJlbmRlcmluZywgc28gZmxhZyB6VGltZSBhcyBuZWdhdGl2ZSBzbyB0aGF0IHNvIHRoYXQgdGhlIG5leHQgdGltZSByZW5kZXIoKSBpcyBjYWxsZWQgaXQnbGwgYmUgZm9yY2VkICh0byByZW5kZXIgYW55IHJlbWFpbmluZyBjaGlsZHJlbilcblxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjaGlsZCA9IG5leHQ7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNoaWxkID0gdGhpcy5fbGFzdDtcbiAgICAgICAgdmFyIGFkanVzdGVkVGltZSA9IHRvdGFsVGltZSA8IDAgPyB0b3RhbFRpbWUgOiB0aW1lOyAvL3doZW4gdGhlIHBsYXloZWFkIGdvZXMgYmFja3dhcmQgYmV5b25kIHRoZSBzdGFydCBvZiB0aGlzIHRpbWVsaW5lLCB3ZSBtdXN0IHBhc3MgdGhhdCBpbmZvcm1hdGlvbiBkb3duIHRvIHRoZSBjaGlsZCBhbmltYXRpb25zIHNvIHRoYXQgemVyby1kdXJhdGlvbiB0d2VlbnMga25vdyB3aGV0aGVyIHRvIHJlbmRlciB0aGVpciBzdGFydGluZyBvciBlbmRpbmcgdmFsdWVzLlxuXG4gICAgICAgIHdoaWxlIChjaGlsZCkge1xuICAgICAgICAgIG5leHQgPSBjaGlsZC5fcHJldjtcblxuICAgICAgICAgIGlmICgoY2hpbGQuX2FjdCB8fCBhZGp1c3RlZFRpbWUgPD0gY2hpbGQuX2VuZCkgJiYgY2hpbGQuX3RzICYmIHBhdXNlVHdlZW4gIT09IGNoaWxkKSB7XG4gICAgICAgICAgICBpZiAoY2hpbGQucGFyZW50ICE9PSB0aGlzKSB7XG4gICAgICAgICAgICAgIC8vIGFuIGV4dHJlbWUgZWRnZSBjYXNlIC0gdGhlIGNoaWxkJ3MgcmVuZGVyIGNvdWxkIGRvIHNvbWV0aGluZyBsaWtlIGtpbGwoKSB0aGUgXCJuZXh0XCIgb25lIGluIHRoZSBsaW5rZWQgbGlzdCwgb3IgcmVwYXJlbnQgaXQuIEluIHRoYXQgY2FzZSB3ZSBtdXN0IHJlLWluaXRpYXRlIHRoZSB3aG9sZSByZW5kZXIgdG8gYmUgc2FmZS5cbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVuZGVyKHRvdGFsVGltZSwgc3VwcHJlc3NFdmVudHMsIGZvcmNlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY2hpbGQucmVuZGVyKGNoaWxkLl90cyA+IDAgPyAoYWRqdXN0ZWRUaW1lIC0gY2hpbGQuX3N0YXJ0KSAqIGNoaWxkLl90cyA6IChjaGlsZC5fZGlydHkgPyBjaGlsZC50b3RhbER1cmF0aW9uKCkgOiBjaGlsZC5fdER1cikgKyAoYWRqdXN0ZWRUaW1lIC0gY2hpbGQuX3N0YXJ0KSAqIGNoaWxkLl90cywgc3VwcHJlc3NFdmVudHMsIGZvcmNlKTtcblxuICAgICAgICAgICAgaWYgKHRpbWUgIT09IHRoaXMuX3RpbWUgfHwgIXRoaXMuX3RzICYmICFwcmV2UGF1c2VkKSB7XG4gICAgICAgICAgICAgIC8vaW4gY2FzZSBhIHR3ZWVuIHBhdXNlcyBvciBzZWVrcyB0aGUgdGltZWxpbmUgd2hlbiByZW5kZXJpbmcsIGxpa2UgaW5zaWRlIG9mIGFuIG9uVXBkYXRlL29uQ29tcGxldGVcbiAgICAgICAgICAgICAgcGF1c2VUd2VlbiA9IDA7XG4gICAgICAgICAgICAgIG5leHQgJiYgKHRUaW1lICs9IHRoaXMuX3pUaW1lID0gYWRqdXN0ZWRUaW1lID8gLV90aW55TnVtIDogX3RpbnlOdW0pOyAvLyBpdCBkaWRuJ3QgZmluaXNoIHJlbmRlcmluZywgc28gYWRqdXN0IHpUaW1lIHNvIHRoYXQgc28gdGhhdCB0aGUgbmV4dCB0aW1lIHJlbmRlcigpIGlzIGNhbGxlZCBpdCdsbCBiZSBmb3JjZWQgKHRvIHJlbmRlciBhbnkgcmVtYWluaW5nIGNoaWxkcmVuKVxuXG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGNoaWxkID0gbmV4dDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAocGF1c2VUd2VlbiAmJiAhc3VwcHJlc3NFdmVudHMpIHtcbiAgICAgICAgdGhpcy5wYXVzZSgpO1xuICAgICAgICBwYXVzZVR3ZWVuLnJlbmRlcih0aW1lID49IHByZXZUaW1lID8gMCA6IC1fdGlueU51bSkuX3pUaW1lID0gdGltZSA+PSBwcmV2VGltZSA/IDEgOiAtMTtcblxuICAgICAgICBpZiAodGhpcy5fdHMpIHtcbiAgICAgICAgICAvL3RoZSBjYWxsYmFjayByZXN1bWVkIHBsYXliYWNrISBTbyBzaW5jZSB3ZSBtYXkgaGF2ZSBoZWxkIGJhY2sgdGhlIHBsYXloZWFkIGR1ZSB0byB3aGVyZSB0aGUgcGF1c2UgaXMgcG9zaXRpb25lZCwgZ28gYWhlYWQgYW5kIGp1bXAgdG8gd2hlcmUgaXQncyBTVVBQT1NFRCB0byBiZSAoaWYgbm8gcGF1c2UgaGFwcGVuZWQpLlxuICAgICAgICAgIHRoaXMuX3N0YXJ0ID0gcHJldlN0YXJ0OyAvL2lmIHRoZSBwYXVzZSB3YXMgYXQgYW4gZWFybGllciB0aW1lIGFuZCB0aGUgdXNlciByZXN1bWVkIGluIHRoZSBjYWxsYmFjaywgaXQgY291bGQgcmVwb3NpdGlvbiB0aGUgdGltZWxpbmUgKGNoYW5naW5nIGl0cyBzdGFydFRpbWUpLCB0aHJvd2luZyB0aGluZ3Mgb2ZmIHNsaWdodGx5LCBzbyB3ZSBtYWtlIHN1cmUgdGhlIF9zdGFydCBkb2Vzbid0IHNoaWZ0LlxuXG4gICAgICAgICAgX3NldEVuZCh0aGlzKTtcblxuICAgICAgICAgIHJldHVybiB0aGlzLnJlbmRlcih0b3RhbFRpbWUsIHN1cHByZXNzRXZlbnRzLCBmb3JjZSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdGhpcy5fb25VcGRhdGUgJiYgIXN1cHByZXNzRXZlbnRzICYmIF9jYWxsYmFjayh0aGlzLCBcIm9uVXBkYXRlXCIsIHRydWUpO1xuICAgICAgaWYgKHRUaW1lID09PSB0RHVyICYmIHRoaXMuX3RUaW1lID49IHRoaXMudG90YWxEdXJhdGlvbigpIHx8ICF0VGltZSAmJiBwcmV2VGltZSkgaWYgKHByZXZTdGFydCA9PT0gdGhpcy5fc3RhcnQgfHwgTWF0aC5hYnModGltZVNjYWxlKSAhPT0gTWF0aC5hYnModGhpcy5fdHMpKSBpZiAoIXRoaXMuX2xvY2spIHtcbiAgICAgICAgLy8gcmVtZW1iZXIsIGEgY2hpbGQncyBjYWxsYmFjayBtYXkgYWx0ZXIgdGhpcyB0aW1lbGluZSdzIHBsYXloZWFkIG9yIHRpbWVTY2FsZSB3aGljaCBpcyB3aHkgd2UgbmVlZCB0byBhZGQgc29tZSBvZiB0aGVzZSBjaGVja3MuXG4gICAgICAgICh0b3RhbFRpbWUgfHwgIWR1cikgJiYgKHRUaW1lID09PSB0RHVyICYmIHRoaXMuX3RzID4gMCB8fCAhdFRpbWUgJiYgdGhpcy5fdHMgPCAwKSAmJiBfcmVtb3ZlRnJvbVBhcmVudCh0aGlzLCAxKTsgLy8gZG9uJ3QgcmVtb3ZlIGlmIHRoZSB0aW1lbGluZSBpcyByZXZlcnNlZCBhbmQgdGhlIHBsYXloZWFkIGlzbid0IGF0IDAsIG90aGVyd2lzZSB0bC5wcm9ncmVzcygxKS5yZXZlcnNlKCkgd29uJ3Qgd29yay4gT25seSByZW1vdmUgaWYgdGhlIHBsYXloZWFkIGlzIGF0IHRoZSBlbmQgYW5kIHRpbWVTY2FsZSBpcyBwb3NpdGl2ZSwgb3IgaWYgdGhlIHBsYXloZWFkIGlzIGF0IDAgYW5kIHRoZSB0aW1lU2NhbGUgaXMgbmVnYXRpdmUuXG5cbiAgICAgICAgaWYgKCFzdXBwcmVzc0V2ZW50cyAmJiAhKHRvdGFsVGltZSA8IDAgJiYgIXByZXZUaW1lKSAmJiAodFRpbWUgfHwgcHJldlRpbWUgfHwgIXREdXIpKSB7XG4gICAgICAgICAgX2NhbGxiYWNrKHRoaXMsIHRUaW1lID09PSB0RHVyICYmIHRvdGFsVGltZSA+PSAwID8gXCJvbkNvbXBsZXRlXCIgOiBcIm9uUmV2ZXJzZUNvbXBsZXRlXCIsIHRydWUpO1xuXG4gICAgICAgICAgdGhpcy5fcHJvbSAmJiAhKHRUaW1lIDwgdER1ciAmJiB0aGlzLnRpbWVTY2FsZSgpID4gMCkgJiYgdGhpcy5fcHJvbSgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgX3Byb3RvMi5hZGQgPSBmdW5jdGlvbiBhZGQoY2hpbGQsIHBvc2l0aW9uKSB7XG4gICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICBfaXNOdW1iZXIocG9zaXRpb24pIHx8IChwb3NpdGlvbiA9IF9wYXJzZVBvc2l0aW9uKHRoaXMsIHBvc2l0aW9uLCBjaGlsZCkpO1xuXG4gICAgaWYgKCEoY2hpbGQgaW5zdGFuY2VvZiBBbmltYXRpb24pKSB7XG4gICAgICBpZiAoX2lzQXJyYXkoY2hpbGQpKSB7XG4gICAgICAgIGNoaWxkLmZvckVhY2goZnVuY3Rpb24gKG9iaikge1xuICAgICAgICAgIHJldHVybiBfdGhpczIuYWRkKG9iaiwgcG9zaXRpb24pO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG5cbiAgICAgIGlmIChfaXNTdHJpbmcoY2hpbGQpKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFkZExhYmVsKGNoaWxkLCBwb3NpdGlvbik7XG4gICAgICB9XG5cbiAgICAgIGlmIChfaXNGdW5jdGlvbihjaGlsZCkpIHtcbiAgICAgICAgY2hpbGQgPSBUd2Vlbi5kZWxheWVkQ2FsbCgwLCBjaGlsZCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcyAhPT0gY2hpbGQgPyBfYWRkVG9UaW1lbGluZSh0aGlzLCBjaGlsZCwgcG9zaXRpb24pIDogdGhpczsgLy9kb24ndCBhbGxvdyBhIHRpbWVsaW5lIHRvIGJlIGFkZGVkIHRvIGl0c2VsZiBhcyBhIGNoaWxkIVxuICB9O1xuXG4gIF9wcm90bzIuZ2V0Q2hpbGRyZW4gPSBmdW5jdGlvbiBnZXRDaGlsZHJlbihuZXN0ZWQsIHR3ZWVucywgdGltZWxpbmVzLCBpZ25vcmVCZWZvcmVUaW1lKSB7XG4gICAgaWYgKG5lc3RlZCA9PT0gdm9pZCAwKSB7XG4gICAgICBuZXN0ZWQgPSB0cnVlO1xuICAgIH1cblxuICAgIGlmICh0d2VlbnMgPT09IHZvaWQgMCkge1xuICAgICAgdHdlZW5zID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAodGltZWxpbmVzID09PSB2b2lkIDApIHtcbiAgICAgIHRpbWVsaW5lcyA9IHRydWU7XG4gICAgfVxuXG4gICAgaWYgKGlnbm9yZUJlZm9yZVRpbWUgPT09IHZvaWQgMCkge1xuICAgICAgaWdub3JlQmVmb3JlVGltZSA9IC1fYmlnTnVtO1xuICAgIH1cblxuICAgIHZhciBhID0gW10sXG4gICAgICAgIGNoaWxkID0gdGhpcy5fZmlyc3Q7XG5cbiAgICB3aGlsZSAoY2hpbGQpIHtcbiAgICAgIGlmIChjaGlsZC5fc3RhcnQgPj0gaWdub3JlQmVmb3JlVGltZSkge1xuICAgICAgICBpZiAoY2hpbGQgaW5zdGFuY2VvZiBUd2Vlbikge1xuICAgICAgICAgIHR3ZWVucyAmJiBhLnB1c2goY2hpbGQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRpbWVsaW5lcyAmJiBhLnB1c2goY2hpbGQpO1xuICAgICAgICAgIG5lc3RlZCAmJiBhLnB1c2guYXBwbHkoYSwgY2hpbGQuZ2V0Q2hpbGRyZW4odHJ1ZSwgdHdlZW5zLCB0aW1lbGluZXMpKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBjaGlsZCA9IGNoaWxkLl9uZXh0O1xuICAgIH1cblxuICAgIHJldHVybiBhO1xuICB9O1xuXG4gIF9wcm90bzIuZ2V0QnlJZCA9IGZ1bmN0aW9uIGdldEJ5SWQoaWQpIHtcbiAgICB2YXIgYW5pbWF0aW9ucyA9IHRoaXMuZ2V0Q2hpbGRyZW4oMSwgMSwgMSksXG4gICAgICAgIGkgPSBhbmltYXRpb25zLmxlbmd0aDtcblxuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIGlmIChhbmltYXRpb25zW2ldLnZhcnMuaWQgPT09IGlkKSB7XG4gICAgICAgIHJldHVybiBhbmltYXRpb25zW2ldO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBfcHJvdG8yLnJlbW92ZSA9IGZ1bmN0aW9uIHJlbW92ZShjaGlsZCkge1xuICAgIGlmIChfaXNTdHJpbmcoY2hpbGQpKSB7XG4gICAgICByZXR1cm4gdGhpcy5yZW1vdmVMYWJlbChjaGlsZCk7XG4gICAgfVxuXG4gICAgaWYgKF9pc0Z1bmN0aW9uKGNoaWxkKSkge1xuICAgICAgcmV0dXJuIHRoaXMua2lsbFR3ZWVuc09mKGNoaWxkKTtcbiAgICB9XG5cbiAgICBfcmVtb3ZlTGlua2VkTGlzdEl0ZW0odGhpcywgY2hpbGQpO1xuXG4gICAgaWYgKGNoaWxkID09PSB0aGlzLl9yZWNlbnQpIHtcbiAgICAgIHRoaXMuX3JlY2VudCA9IHRoaXMuX2xhc3Q7XG4gICAgfVxuXG4gICAgcmV0dXJuIF91bmNhY2hlKHRoaXMpO1xuICB9O1xuXG4gIF9wcm90bzIudG90YWxUaW1lID0gZnVuY3Rpb24gdG90YWxUaW1lKF90b3RhbFRpbWUyLCBzdXBwcmVzc0V2ZW50cykge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3RUaW1lO1xuICAgIH1cblxuICAgIHRoaXMuX2ZvcmNpbmcgPSAxO1xuXG4gICAgaWYgKCF0aGlzLl9kcCAmJiB0aGlzLl90cykge1xuICAgICAgLy9zcGVjaWFsIGNhc2UgZm9yIHRoZSBnbG9iYWwgdGltZWxpbmUgKG9yIGFueSBvdGhlciB0aGF0IGhhcyBubyBwYXJlbnQgb3IgZGV0YWNoZWQgcGFyZW50KS5cbiAgICAgIHRoaXMuX3N0YXJ0ID0gX3JvdW5kUHJlY2lzZShfdGlja2VyLnRpbWUgLSAodGhpcy5fdHMgPiAwID8gX3RvdGFsVGltZTIgLyB0aGlzLl90cyA6ICh0aGlzLnRvdGFsRHVyYXRpb24oKSAtIF90b3RhbFRpbWUyKSAvIC10aGlzLl90cykpO1xuICAgIH1cblxuICAgIF9BbmltYXRpb24ucHJvdG90eXBlLnRvdGFsVGltZS5jYWxsKHRoaXMsIF90b3RhbFRpbWUyLCBzdXBwcmVzc0V2ZW50cyk7XG5cbiAgICB0aGlzLl9mb3JjaW5nID0gMDtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBfcHJvdG8yLmFkZExhYmVsID0gZnVuY3Rpb24gYWRkTGFiZWwobGFiZWwsIHBvc2l0aW9uKSB7XG4gICAgdGhpcy5sYWJlbHNbbGFiZWxdID0gX3BhcnNlUG9zaXRpb24odGhpcywgcG9zaXRpb24pO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIF9wcm90bzIucmVtb3ZlTGFiZWwgPSBmdW5jdGlvbiByZW1vdmVMYWJlbChsYWJlbCkge1xuICAgIGRlbGV0ZSB0aGlzLmxhYmVsc1tsYWJlbF07XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgX3Byb3RvMi5hZGRQYXVzZSA9IGZ1bmN0aW9uIGFkZFBhdXNlKHBvc2l0aW9uLCBjYWxsYmFjaywgcGFyYW1zKSB7XG4gICAgdmFyIHQgPSBUd2Vlbi5kZWxheWVkQ2FsbCgwLCBjYWxsYmFjayB8fCBfZW1wdHlGdW5jLCBwYXJhbXMpO1xuICAgIHQuZGF0YSA9IFwiaXNQYXVzZVwiO1xuICAgIHRoaXMuX2hhc1BhdXNlID0gMTtcbiAgICByZXR1cm4gX2FkZFRvVGltZWxpbmUodGhpcywgdCwgX3BhcnNlUG9zaXRpb24odGhpcywgcG9zaXRpb24pKTtcbiAgfTtcblxuICBfcHJvdG8yLnJlbW92ZVBhdXNlID0gZnVuY3Rpb24gcmVtb3ZlUGF1c2UocG9zaXRpb24pIHtcbiAgICB2YXIgY2hpbGQgPSB0aGlzLl9maXJzdDtcbiAgICBwb3NpdGlvbiA9IF9wYXJzZVBvc2l0aW9uKHRoaXMsIHBvc2l0aW9uKTtcblxuICAgIHdoaWxlIChjaGlsZCkge1xuICAgICAgaWYgKGNoaWxkLl9zdGFydCA9PT0gcG9zaXRpb24gJiYgY2hpbGQuZGF0YSA9PT0gXCJpc1BhdXNlXCIpIHtcbiAgICAgICAgX3JlbW92ZUZyb21QYXJlbnQoY2hpbGQpO1xuICAgICAgfVxuXG4gICAgICBjaGlsZCA9IGNoaWxkLl9uZXh0O1xuICAgIH1cbiAgfTtcblxuICBfcHJvdG8yLmtpbGxUd2VlbnNPZiA9IGZ1bmN0aW9uIGtpbGxUd2VlbnNPZih0YXJnZXRzLCBwcm9wcywgb25seUFjdGl2ZSkge1xuICAgIHZhciB0d2VlbnMgPSB0aGlzLmdldFR3ZWVuc09mKHRhcmdldHMsIG9ubHlBY3RpdmUpLFxuICAgICAgICBpID0gdHdlZW5zLmxlbmd0aDtcblxuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIF9vdmVyd3JpdGluZ1R3ZWVuICE9PSB0d2VlbnNbaV0gJiYgdHdlZW5zW2ldLmtpbGwodGFyZ2V0cywgcHJvcHMpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIF9wcm90bzIuZ2V0VHdlZW5zT2YgPSBmdW5jdGlvbiBnZXRUd2VlbnNPZih0YXJnZXRzLCBvbmx5QWN0aXZlKSB7XG4gICAgdmFyIGEgPSBbXSxcbiAgICAgICAgcGFyc2VkVGFyZ2V0cyA9IHRvQXJyYXkodGFyZ2V0cyksXG4gICAgICAgIGNoaWxkID0gdGhpcy5fZmlyc3QsXG4gICAgICAgIGlzR2xvYmFsVGltZSA9IF9pc051bWJlcihvbmx5QWN0aXZlKSxcbiAgICAgICAgLy8gYSBudW1iZXIgaXMgaW50ZXJwcmV0ZWQgYXMgYSBnbG9iYWwgdGltZS4gSWYgdGhlIGFuaW1hdGlvbiBzcGFuc1xuICAgIGNoaWxkcmVuO1xuXG4gICAgd2hpbGUgKGNoaWxkKSB7XG4gICAgICBpZiAoY2hpbGQgaW5zdGFuY2VvZiBUd2Vlbikge1xuICAgICAgICBpZiAoX2FycmF5Q29udGFpbnNBbnkoY2hpbGQuX3RhcmdldHMsIHBhcnNlZFRhcmdldHMpICYmIChpc0dsb2JhbFRpbWUgPyAoIV9vdmVyd3JpdGluZ1R3ZWVuIHx8IGNoaWxkLl9pbml0dGVkICYmIGNoaWxkLl90cykgJiYgY2hpbGQuZ2xvYmFsVGltZSgwKSA8PSBvbmx5QWN0aXZlICYmIGNoaWxkLmdsb2JhbFRpbWUoY2hpbGQudG90YWxEdXJhdGlvbigpKSA+IG9ubHlBY3RpdmUgOiAhb25seUFjdGl2ZSB8fCBjaGlsZC5pc0FjdGl2ZSgpKSkge1xuICAgICAgICAgIC8vIG5vdGU6IGlmIHRoaXMgaXMgZm9yIG92ZXJ3cml0aW5nLCBpdCBzaG91bGQgb25seSBiZSBmb3IgdHdlZW5zIHRoYXQgYXJlbid0IHBhdXNlZCBhbmQgYXJlIGluaXR0ZWQuXG4gICAgICAgICAgYS5wdXNoKGNoaWxkKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICgoY2hpbGRyZW4gPSBjaGlsZC5nZXRUd2VlbnNPZihwYXJzZWRUYXJnZXRzLCBvbmx5QWN0aXZlKSkubGVuZ3RoKSB7XG4gICAgICAgIGEucHVzaC5hcHBseShhLCBjaGlsZHJlbik7XG4gICAgICB9XG5cbiAgICAgIGNoaWxkID0gY2hpbGQuX25leHQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIGE7XG4gIH0gLy8gcG90ZW50aWFsIGZ1dHVyZSBmZWF0dXJlIC0gdGFyZ2V0cygpIG9uIHRpbWVsaW5lc1xuICAvLyB0YXJnZXRzKCkge1xuICAvLyBcdGxldCByZXN1bHQgPSBbXTtcbiAgLy8gXHR0aGlzLmdldENoaWxkcmVuKHRydWUsIHRydWUsIGZhbHNlKS5mb3JFYWNoKHQgPT4gcmVzdWx0LnB1c2goLi4udC50YXJnZXRzKCkpKTtcbiAgLy8gXHRyZXR1cm4gcmVzdWx0LmZpbHRlcigodiwgaSkgPT4gcmVzdWx0LmluZGV4T2YodikgPT09IGkpO1xuICAvLyB9XG4gIDtcblxuICBfcHJvdG8yLnR3ZWVuVG8gPSBmdW5jdGlvbiB0d2VlblRvKHBvc2l0aW9uLCB2YXJzKSB7XG4gICAgdmFycyA9IHZhcnMgfHwge307XG5cbiAgICB2YXIgdGwgPSB0aGlzLFxuICAgICAgICBlbmRUaW1lID0gX3BhcnNlUG9zaXRpb24odGwsIHBvc2l0aW9uKSxcbiAgICAgICAgX3ZhcnMgPSB2YXJzLFxuICAgICAgICBzdGFydEF0ID0gX3ZhcnMuc3RhcnRBdCxcbiAgICAgICAgX29uU3RhcnQgPSBfdmFycy5vblN0YXJ0LFxuICAgICAgICBvblN0YXJ0UGFyYW1zID0gX3ZhcnMub25TdGFydFBhcmFtcyxcbiAgICAgICAgaW1tZWRpYXRlUmVuZGVyID0gX3ZhcnMuaW1tZWRpYXRlUmVuZGVyLFxuICAgICAgICBpbml0dGVkLFxuICAgICAgICB0d2VlbiA9IFR3ZWVuLnRvKHRsLCBfc2V0RGVmYXVsdHMoe1xuICAgICAgZWFzZTogdmFycy5lYXNlIHx8IFwibm9uZVwiLFxuICAgICAgbGF6eTogZmFsc2UsXG4gICAgICBpbW1lZGlhdGVSZW5kZXI6IGZhbHNlLFxuICAgICAgdGltZTogZW5kVGltZSxcbiAgICAgIG92ZXJ3cml0ZTogXCJhdXRvXCIsXG4gICAgICBkdXJhdGlvbjogdmFycy5kdXJhdGlvbiB8fCBNYXRoLmFicygoZW5kVGltZSAtIChzdGFydEF0ICYmIFwidGltZVwiIGluIHN0YXJ0QXQgPyBzdGFydEF0LnRpbWUgOiB0bC5fdGltZSkpIC8gdGwudGltZVNjYWxlKCkpIHx8IF90aW55TnVtLFxuICAgICAgb25TdGFydDogZnVuY3Rpb24gb25TdGFydCgpIHtcbiAgICAgICAgdGwucGF1c2UoKTtcblxuICAgICAgICBpZiAoIWluaXR0ZWQpIHtcbiAgICAgICAgICB2YXIgZHVyYXRpb24gPSB2YXJzLmR1cmF0aW9uIHx8IE1hdGguYWJzKChlbmRUaW1lIC0gKHN0YXJ0QXQgJiYgXCJ0aW1lXCIgaW4gc3RhcnRBdCA/IHN0YXJ0QXQudGltZSA6IHRsLl90aW1lKSkgLyB0bC50aW1lU2NhbGUoKSk7XG4gICAgICAgICAgdHdlZW4uX2R1ciAhPT0gZHVyYXRpb24gJiYgX3NldER1cmF0aW9uKHR3ZWVuLCBkdXJhdGlvbiwgMCwgMSkucmVuZGVyKHR3ZWVuLl90aW1lLCB0cnVlLCB0cnVlKTtcbiAgICAgICAgICBpbml0dGVkID0gMTtcbiAgICAgICAgfVxuXG4gICAgICAgIF9vblN0YXJ0ICYmIF9vblN0YXJ0LmFwcGx5KHR3ZWVuLCBvblN0YXJ0UGFyYW1zIHx8IFtdKTsgLy9pbiBjYXNlIHRoZSB1c2VyIGhhZCBhbiBvblN0YXJ0IGluIHRoZSB2YXJzIC0gd2UgZG9uJ3Qgd2FudCB0byBvdmVyd3JpdGUgaXQuXG4gICAgICB9XG4gICAgfSwgdmFycykpO1xuXG4gICAgcmV0dXJuIGltbWVkaWF0ZVJlbmRlciA/IHR3ZWVuLnJlbmRlcigwKSA6IHR3ZWVuO1xuICB9O1xuXG4gIF9wcm90bzIudHdlZW5Gcm9tVG8gPSBmdW5jdGlvbiB0d2VlbkZyb21Ubyhmcm9tUG9zaXRpb24sIHRvUG9zaXRpb24sIHZhcnMpIHtcbiAgICByZXR1cm4gdGhpcy50d2VlblRvKHRvUG9zaXRpb24sIF9zZXREZWZhdWx0cyh7XG4gICAgICBzdGFydEF0OiB7XG4gICAgICAgIHRpbWU6IF9wYXJzZVBvc2l0aW9uKHRoaXMsIGZyb21Qb3NpdGlvbilcbiAgICAgIH1cbiAgICB9LCB2YXJzKSk7XG4gIH07XG5cbiAgX3Byb3RvMi5yZWNlbnQgPSBmdW5jdGlvbiByZWNlbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3JlY2VudDtcbiAgfTtcblxuICBfcHJvdG8yLm5leHRMYWJlbCA9IGZ1bmN0aW9uIG5leHRMYWJlbChhZnRlclRpbWUpIHtcbiAgICBpZiAoYWZ0ZXJUaW1lID09PSB2b2lkIDApIHtcbiAgICAgIGFmdGVyVGltZSA9IHRoaXMuX3RpbWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIF9nZXRMYWJlbEluRGlyZWN0aW9uKHRoaXMsIF9wYXJzZVBvc2l0aW9uKHRoaXMsIGFmdGVyVGltZSkpO1xuICB9O1xuXG4gIF9wcm90bzIucHJldmlvdXNMYWJlbCA9IGZ1bmN0aW9uIHByZXZpb3VzTGFiZWwoYmVmb3JlVGltZSkge1xuICAgIGlmIChiZWZvcmVUaW1lID09PSB2b2lkIDApIHtcbiAgICAgIGJlZm9yZVRpbWUgPSB0aGlzLl90aW1lO1xuICAgIH1cblxuICAgIHJldHVybiBfZ2V0TGFiZWxJbkRpcmVjdGlvbih0aGlzLCBfcGFyc2VQb3NpdGlvbih0aGlzLCBiZWZvcmVUaW1lKSwgMSk7XG4gIH07XG5cbiAgX3Byb3RvMi5jdXJyZW50TGFiZWwgPSBmdW5jdGlvbiBjdXJyZW50TGFiZWwodmFsdWUpIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IHRoaXMuc2Vlayh2YWx1ZSwgdHJ1ZSkgOiB0aGlzLnByZXZpb3VzTGFiZWwodGhpcy5fdGltZSArIF90aW55TnVtKTtcbiAgfTtcblxuICBfcHJvdG8yLnNoaWZ0Q2hpbGRyZW4gPSBmdW5jdGlvbiBzaGlmdENoaWxkcmVuKGFtb3VudCwgYWRqdXN0TGFiZWxzLCBpZ25vcmVCZWZvcmVUaW1lKSB7XG4gICAgaWYgKGlnbm9yZUJlZm9yZVRpbWUgPT09IHZvaWQgMCkge1xuICAgICAgaWdub3JlQmVmb3JlVGltZSA9IDA7XG4gICAgfVxuXG4gICAgdmFyIGNoaWxkID0gdGhpcy5fZmlyc3QsXG4gICAgICAgIGxhYmVscyA9IHRoaXMubGFiZWxzLFxuICAgICAgICBwO1xuXG4gICAgd2hpbGUgKGNoaWxkKSB7XG4gICAgICBpZiAoY2hpbGQuX3N0YXJ0ID49IGlnbm9yZUJlZm9yZVRpbWUpIHtcbiAgICAgICAgY2hpbGQuX3N0YXJ0ICs9IGFtb3VudDtcbiAgICAgICAgY2hpbGQuX2VuZCArPSBhbW91bnQ7XG4gICAgICB9XG5cbiAgICAgIGNoaWxkID0gY2hpbGQuX25leHQ7XG4gICAgfVxuXG4gICAgaWYgKGFkanVzdExhYmVscykge1xuICAgICAgZm9yIChwIGluIGxhYmVscykge1xuICAgICAgICBpZiAobGFiZWxzW3BdID49IGlnbm9yZUJlZm9yZVRpbWUpIHtcbiAgICAgICAgICBsYWJlbHNbcF0gKz0gYW1vdW50O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIF91bmNhY2hlKHRoaXMpO1xuICB9O1xuXG4gIF9wcm90bzIuaW52YWxpZGF0ZSA9IGZ1bmN0aW9uIGludmFsaWRhdGUoKSB7XG4gICAgdmFyIGNoaWxkID0gdGhpcy5fZmlyc3Q7XG4gICAgdGhpcy5fbG9jayA9IDA7XG5cbiAgICB3aGlsZSAoY2hpbGQpIHtcbiAgICAgIGNoaWxkLmludmFsaWRhdGUoKTtcbiAgICAgIGNoaWxkID0gY2hpbGQuX25leHQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIF9BbmltYXRpb24ucHJvdG90eXBlLmludmFsaWRhdGUuY2FsbCh0aGlzKTtcbiAgfTtcblxuICBfcHJvdG8yLmNsZWFyID0gZnVuY3Rpb24gY2xlYXIoaW5jbHVkZUxhYmVscykge1xuICAgIGlmIChpbmNsdWRlTGFiZWxzID09PSB2b2lkIDApIHtcbiAgICAgIGluY2x1ZGVMYWJlbHMgPSB0cnVlO1xuICAgIH1cblxuICAgIHZhciBjaGlsZCA9IHRoaXMuX2ZpcnN0LFxuICAgICAgICBuZXh0O1xuXG4gICAgd2hpbGUgKGNoaWxkKSB7XG4gICAgICBuZXh0ID0gY2hpbGQuX25leHQ7XG4gICAgICB0aGlzLnJlbW92ZShjaGlsZCk7XG4gICAgICBjaGlsZCA9IG5leHQ7XG4gICAgfVxuXG4gICAgdGhpcy5fZHAgJiYgKHRoaXMuX3RpbWUgPSB0aGlzLl90VGltZSA9IHRoaXMuX3BUaW1lID0gMCk7XG4gICAgaW5jbHVkZUxhYmVscyAmJiAodGhpcy5sYWJlbHMgPSB7fSk7XG4gICAgcmV0dXJuIF91bmNhY2hlKHRoaXMpO1xuICB9O1xuXG4gIF9wcm90bzIudG90YWxEdXJhdGlvbiA9IGZ1bmN0aW9uIHRvdGFsRHVyYXRpb24odmFsdWUpIHtcbiAgICB2YXIgbWF4ID0gMCxcbiAgICAgICAgc2VsZiA9IHRoaXMsXG4gICAgICAgIGNoaWxkID0gc2VsZi5fbGFzdCxcbiAgICAgICAgcHJldlN0YXJ0ID0gX2JpZ051bSxcbiAgICAgICAgcHJldixcbiAgICAgICAgc3RhcnQsXG4gICAgICAgIHBhcmVudDtcblxuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gc2VsZi50aW1lU2NhbGUoKHNlbGYuX3JlcGVhdCA8IDAgPyBzZWxmLmR1cmF0aW9uKCkgOiBzZWxmLnRvdGFsRHVyYXRpb24oKSkgLyAoc2VsZi5yZXZlcnNlZCgpID8gLXZhbHVlIDogdmFsdWUpKTtcbiAgICB9XG5cbiAgICBpZiAoc2VsZi5fZGlydHkpIHtcbiAgICAgIHBhcmVudCA9IHNlbGYucGFyZW50O1xuXG4gICAgICB3aGlsZSAoY2hpbGQpIHtcbiAgICAgICAgcHJldiA9IGNoaWxkLl9wcmV2OyAvL3JlY29yZCBpdCBoZXJlIGluIGNhc2UgdGhlIHR3ZWVuIGNoYW5nZXMgcG9zaXRpb24gaW4gdGhlIHNlcXVlbmNlLi4uXG5cbiAgICAgICAgY2hpbGQuX2RpcnR5ICYmIGNoaWxkLnRvdGFsRHVyYXRpb24oKTsgLy9jb3VsZCBjaGFuZ2UgdGhlIHR3ZWVuLl9zdGFydFRpbWUsIHNvIG1ha2Ugc3VyZSB0aGUgYW5pbWF0aW9uJ3MgY2FjaGUgaXMgY2xlYW4gYmVmb3JlIGFuYWx5emluZyBpdC5cblxuICAgICAgICBzdGFydCA9IGNoaWxkLl9zdGFydDtcblxuICAgICAgICBpZiAoc3RhcnQgPiBwcmV2U3RhcnQgJiYgc2VsZi5fc29ydCAmJiBjaGlsZC5fdHMgJiYgIXNlbGYuX2xvY2spIHtcbiAgICAgICAgICAvL2luIGNhc2Ugb25lIG9mIHRoZSB0d2VlbnMgc2hpZnRlZCBvdXQgb2Ygb3JkZXIsIGl0IG5lZWRzIHRvIGJlIHJlLWluc2VydGVkIGludG8gdGhlIGNvcnJlY3QgcG9zaXRpb24gaW4gdGhlIHNlcXVlbmNlXG4gICAgICAgICAgc2VsZi5fbG9jayA9IDE7IC8vcHJldmVudCBlbmRsZXNzIHJlY3Vyc2l2ZSBjYWxscyAtIHRoZXJlIGFyZSBtZXRob2RzIHRoYXQgZ2V0IHRyaWdnZXJlZCB0aGF0IGNoZWNrIGR1cmF0aW9uL3RvdGFsRHVyYXRpb24gd2hlbiB3ZSBhZGQoKS5cblxuICAgICAgICAgIF9hZGRUb1RpbWVsaW5lKHNlbGYsIGNoaWxkLCBzdGFydCAtIGNoaWxkLl9kZWxheSwgMSkuX2xvY2sgPSAwO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHByZXZTdGFydCA9IHN0YXJ0O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHN0YXJ0IDwgMCAmJiBjaGlsZC5fdHMpIHtcbiAgICAgICAgICAvL2NoaWxkcmVuIGFyZW4ndCBhbGxvd2VkIHRvIGhhdmUgbmVnYXRpdmUgc3RhcnRUaW1lcyB1bmxlc3Mgc21vb3RoQ2hpbGRUaW1pbmcgaXMgdHJ1ZSwgc28gYWRqdXN0IGhlcmUgaWYgb25lIGlzIGZvdW5kLlxuICAgICAgICAgIG1heCAtPSBzdGFydDtcblxuICAgICAgICAgIGlmICghcGFyZW50ICYmICFzZWxmLl9kcCB8fCBwYXJlbnQgJiYgcGFyZW50LnNtb290aENoaWxkVGltaW5nKSB7XG4gICAgICAgICAgICBzZWxmLl9zdGFydCArPSBzdGFydCAvIHNlbGYuX3RzO1xuICAgICAgICAgICAgc2VsZi5fdGltZSAtPSBzdGFydDtcbiAgICAgICAgICAgIHNlbGYuX3RUaW1lIC09IHN0YXJ0O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHNlbGYuc2hpZnRDaGlsZHJlbigtc3RhcnQsIGZhbHNlLCAtMWU5OTkpO1xuICAgICAgICAgIHByZXZTdGFydCA9IDA7XG4gICAgICAgIH1cblxuICAgICAgICBjaGlsZC5fZW5kID4gbWF4ICYmIGNoaWxkLl90cyAmJiAobWF4ID0gY2hpbGQuX2VuZCk7XG4gICAgICAgIGNoaWxkID0gcHJldjtcbiAgICAgIH1cblxuICAgICAgX3NldER1cmF0aW9uKHNlbGYsIHNlbGYgPT09IF9nbG9iYWxUaW1lbGluZSAmJiBzZWxmLl90aW1lID4gbWF4ID8gc2VsZi5fdGltZSA6IG1heCwgMSwgMSk7XG5cbiAgICAgIHNlbGYuX2RpcnR5ID0gMDtcbiAgICB9XG5cbiAgICByZXR1cm4gc2VsZi5fdER1cjtcbiAgfTtcblxuICBUaW1lbGluZS51cGRhdGVSb290ID0gZnVuY3Rpb24gdXBkYXRlUm9vdCh0aW1lKSB7XG4gICAgaWYgKF9nbG9iYWxUaW1lbGluZS5fdHMpIHtcbiAgICAgIF9sYXp5U2FmZVJlbmRlcihfZ2xvYmFsVGltZWxpbmUsIF9wYXJlbnRUb0NoaWxkVG90YWxUaW1lKHRpbWUsIF9nbG9iYWxUaW1lbGluZSkpO1xuXG4gICAgICBfbGFzdFJlbmRlcmVkRnJhbWUgPSBfdGlja2VyLmZyYW1lO1xuICAgIH1cblxuICAgIGlmIChfdGlja2VyLmZyYW1lID49IF9uZXh0R0NGcmFtZSkge1xuICAgICAgX25leHRHQ0ZyYW1lICs9IF9jb25maWcuYXV0b1NsZWVwIHx8IDEyMDtcbiAgICAgIHZhciBjaGlsZCA9IF9nbG9iYWxUaW1lbGluZS5fZmlyc3Q7XG4gICAgICBpZiAoIWNoaWxkIHx8ICFjaGlsZC5fdHMpIGlmIChfY29uZmlnLmF1dG9TbGVlcCAmJiBfdGlja2VyLl9saXN0ZW5lcnMubGVuZ3RoIDwgMikge1xuICAgICAgICB3aGlsZSAoY2hpbGQgJiYgIWNoaWxkLl90cykge1xuICAgICAgICAgIGNoaWxkID0gY2hpbGQuX25leHQ7XG4gICAgICAgIH1cblxuICAgICAgICBjaGlsZCB8fCBfdGlja2VyLnNsZWVwKCk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiBUaW1lbGluZTtcbn0oQW5pbWF0aW9uKTtcblxuX3NldERlZmF1bHRzKFRpbWVsaW5lLnByb3RvdHlwZSwge1xuICBfbG9jazogMCxcbiAgX2hhc1BhdXNlOiAwLFxuICBfZm9yY2luZzogMFxufSk7XG5cbnZhciBfYWRkQ29tcGxleFN0cmluZ1Byb3BUd2VlbiA9IGZ1bmN0aW9uIF9hZGRDb21wbGV4U3RyaW5nUHJvcFR3ZWVuKHRhcmdldCwgcHJvcCwgc3RhcnQsIGVuZCwgc2V0dGVyLCBzdHJpbmdGaWx0ZXIsIGZ1bmNQYXJhbSkge1xuICAvL25vdGU6IHdlIGNhbGwgX2FkZENvbXBsZXhTdHJpbmdQcm9wVHdlZW4uY2FsbCh0d2Vlbkluc3RhbmNlLi4uKSB0byBlbnN1cmUgdGhhdCBpdCdzIHNjb3BlZCBwcm9wZXJseS4gV2UgbWF5IGNhbGwgaXQgZnJvbSB3aXRoaW4gYSBwbHVnaW4gdG9vLCB0aHVzIFwidGhpc1wiIHdvdWxkIHJlZmVyIHRvIHRoZSBwbHVnaW4uXG4gIHZhciBwdCA9IG5ldyBQcm9wVHdlZW4odGhpcy5fcHQsIHRhcmdldCwgcHJvcCwgMCwgMSwgX3JlbmRlckNvbXBsZXhTdHJpbmcsIG51bGwsIHNldHRlciksXG4gICAgICBpbmRleCA9IDAsXG4gICAgICBtYXRjaEluZGV4ID0gMCxcbiAgICAgIHJlc3VsdCxcbiAgICAgIHN0YXJ0TnVtcyxcbiAgICAgIGNvbG9yLFxuICAgICAgZW5kTnVtLFxuICAgICAgY2h1bmssXG4gICAgICBzdGFydE51bSxcbiAgICAgIGhhc1JhbmRvbSxcbiAgICAgIGE7XG4gIHB0LmIgPSBzdGFydDtcbiAgcHQuZSA9IGVuZDtcbiAgc3RhcnQgKz0gXCJcIjsgLy9lbnN1cmUgdmFsdWVzIGFyZSBzdHJpbmdzXG5cbiAgZW5kICs9IFwiXCI7XG5cbiAgaWYgKGhhc1JhbmRvbSA9IH5lbmQuaW5kZXhPZihcInJhbmRvbShcIikpIHtcbiAgICBlbmQgPSBfcmVwbGFjZVJhbmRvbShlbmQpO1xuICB9XG5cbiAgaWYgKHN0cmluZ0ZpbHRlcikge1xuICAgIGEgPSBbc3RhcnQsIGVuZF07XG4gICAgc3RyaW5nRmlsdGVyKGEsIHRhcmdldCwgcHJvcCk7IC8vcGFzcyBhbiBhcnJheSB3aXRoIHRoZSBzdGFydGluZyBhbmQgZW5kaW5nIHZhbHVlcyBhbmQgbGV0IHRoZSBmaWx0ZXIgZG8gd2hhdGV2ZXIgaXQgbmVlZHMgdG8gdGhlIHZhbHVlcy5cblxuICAgIHN0YXJ0ID0gYVswXTtcbiAgICBlbmQgPSBhWzFdO1xuICB9XG5cbiAgc3RhcnROdW1zID0gc3RhcnQubWF0Y2goX2NvbXBsZXhTdHJpbmdOdW1FeHApIHx8IFtdO1xuXG4gIHdoaWxlIChyZXN1bHQgPSBfY29tcGxleFN0cmluZ051bUV4cC5leGVjKGVuZCkpIHtcbiAgICBlbmROdW0gPSByZXN1bHRbMF07XG4gICAgY2h1bmsgPSBlbmQuc3Vic3RyaW5nKGluZGV4LCByZXN1bHQuaW5kZXgpO1xuXG4gICAgaWYgKGNvbG9yKSB7XG4gICAgICBjb2xvciA9IChjb2xvciArIDEpICUgNTtcbiAgICB9IGVsc2UgaWYgKGNodW5rLnN1YnN0cigtNSkgPT09IFwicmdiYShcIikge1xuICAgICAgY29sb3IgPSAxO1xuICAgIH1cblxuICAgIGlmIChlbmROdW0gIT09IHN0YXJ0TnVtc1ttYXRjaEluZGV4KytdKSB7XG4gICAgICBzdGFydE51bSA9IHBhcnNlRmxvYXQoc3RhcnROdW1zW21hdGNoSW5kZXggLSAxXSkgfHwgMDsgLy90aGVzZSBuZXN0ZWQgUHJvcFR3ZWVucyBhcmUgaGFuZGxlZCBpbiBhIHNwZWNpYWwgd2F5IC0gd2UnbGwgbmV2ZXIgYWN0dWFsbHkgY2FsbCBhIHJlbmRlciBvciBzZXR0ZXIgbWV0aG9kIG9uIHRoZW0uIFdlJ2xsIGp1c3QgbG9vcCB0aHJvdWdoIHRoZW0gaW4gdGhlIHBhcmVudCBjb21wbGV4IHN0cmluZyBQcm9wVHdlZW4ncyByZW5kZXIgbWV0aG9kLlxuXG4gICAgICBwdC5fcHQgPSB7XG4gICAgICAgIF9uZXh0OiBwdC5fcHQsXG4gICAgICAgIHA6IGNodW5rIHx8IG1hdGNoSW5kZXggPT09IDEgPyBjaHVuayA6IFwiLFwiLFxuICAgICAgICAvL25vdGU6IFNWRyBzcGVjIGFsbG93cyBvbWlzc2lvbiBvZiBjb21tYS9zcGFjZSB3aGVuIGEgbmVnYXRpdmUgc2lnbiBpcyB3ZWRnZWQgYmV0d2VlbiB0d28gbnVtYmVycywgbGlrZSAyLjUtNS4zIGluc3RlYWQgb2YgMi41LC01LjMgYnV0IHdoZW4gdHdlZW5pbmcsIHRoZSBuZWdhdGl2ZSB2YWx1ZSBtYXkgc3dpdGNoIHRvIHBvc2l0aXZlLCBzbyB3ZSBpbnNlcnQgdGhlIGNvbW1hIGp1c3QgaW4gY2FzZS5cbiAgICAgICAgczogc3RhcnROdW0sXG4gICAgICAgIGM6IGVuZE51bS5jaGFyQXQoMSkgPT09IFwiPVwiID8gX3BhcnNlUmVsYXRpdmUoc3RhcnROdW0sIGVuZE51bSkgLSBzdGFydE51bSA6IHBhcnNlRmxvYXQoZW5kTnVtKSAtIHN0YXJ0TnVtLFxuICAgICAgICBtOiBjb2xvciAmJiBjb2xvciA8IDQgPyBNYXRoLnJvdW5kIDogMFxuICAgICAgfTtcbiAgICAgIGluZGV4ID0gX2NvbXBsZXhTdHJpbmdOdW1FeHAubGFzdEluZGV4O1xuICAgIH1cbiAgfVxuXG4gIHB0LmMgPSBpbmRleCA8IGVuZC5sZW5ndGggPyBlbmQuc3Vic3RyaW5nKGluZGV4LCBlbmQubGVuZ3RoKSA6IFwiXCI7IC8vd2UgdXNlIHRoZSBcImNcIiBvZiB0aGUgUHJvcFR3ZWVuIHRvIHN0b3JlIHRoZSBmaW5hbCBwYXJ0IG9mIHRoZSBzdHJpbmcgKGFmdGVyIHRoZSBsYXN0IG51bWJlcilcblxuICBwdC5mcCA9IGZ1bmNQYXJhbTtcblxuICBpZiAoX3JlbEV4cC50ZXN0KGVuZCkgfHwgaGFzUmFuZG9tKSB7XG4gICAgcHQuZSA9IDA7IC8vaWYgdGhlIGVuZCBzdHJpbmcgY29udGFpbnMgcmVsYXRpdmUgdmFsdWVzIG9yIGR5bmFtaWMgcmFuZG9tKC4uLikgdmFsdWVzLCBkZWxldGUgdGhlIGVuZCBpdCBzbyB0aGF0IG9uIHRoZSBmaW5hbCByZW5kZXIgd2UgZG9uJ3QgYWN0dWFsbHkgc2V0IGl0IHRvIHRoZSBzdHJpbmcgd2l0aCArPSBvciAtPSBjaGFyYWN0ZXJzIChmb3JjZXMgaXQgdG8gdXNlIHRoZSBjYWxjdWxhdGVkIHZhbHVlKS5cbiAgfVxuXG4gIHRoaXMuX3B0ID0gcHQ7IC8vc3RhcnQgdGhlIGxpbmtlZCBsaXN0IHdpdGggdGhpcyBuZXcgUHJvcFR3ZWVuLiBSZW1lbWJlciwgd2UgY2FsbCBfYWRkQ29tcGxleFN0cmluZ1Byb3BUd2Vlbi5jYWxsKHR3ZWVuSW5zdGFuY2UuLi4pIHRvIGVuc3VyZSB0aGF0IGl0J3Mgc2NvcGVkIHByb3Blcmx5LiBXZSBtYXkgY2FsbCBpdCBmcm9tIHdpdGhpbiBhIHBsdWdpbiB0b28sIHRodXMgXCJ0aGlzXCIgd291bGQgcmVmZXIgdG8gdGhlIHBsdWdpbi5cblxuICByZXR1cm4gcHQ7XG59LFxuICAgIF9hZGRQcm9wVHdlZW4gPSBmdW5jdGlvbiBfYWRkUHJvcFR3ZWVuKHRhcmdldCwgcHJvcCwgc3RhcnQsIGVuZCwgaW5kZXgsIHRhcmdldHMsIG1vZGlmaWVyLCBzdHJpbmdGaWx0ZXIsIGZ1bmNQYXJhbSkge1xuICBfaXNGdW5jdGlvbihlbmQpICYmIChlbmQgPSBlbmQoaW5kZXggfHwgMCwgdGFyZ2V0LCB0YXJnZXRzKSk7XG4gIHZhciBjdXJyZW50VmFsdWUgPSB0YXJnZXRbcHJvcF0sXG4gICAgICBwYXJzZWRTdGFydCA9IHN0YXJ0ICE9PSBcImdldFwiID8gc3RhcnQgOiAhX2lzRnVuY3Rpb24oY3VycmVudFZhbHVlKSA/IGN1cnJlbnRWYWx1ZSA6IGZ1bmNQYXJhbSA/IHRhcmdldFtwcm9wLmluZGV4T2YoXCJzZXRcIikgfHwgIV9pc0Z1bmN0aW9uKHRhcmdldFtcImdldFwiICsgcHJvcC5zdWJzdHIoMyldKSA/IHByb3AgOiBcImdldFwiICsgcHJvcC5zdWJzdHIoMyldKGZ1bmNQYXJhbSkgOiB0YXJnZXRbcHJvcF0oKSxcbiAgICAgIHNldHRlciA9ICFfaXNGdW5jdGlvbihjdXJyZW50VmFsdWUpID8gX3NldHRlclBsYWluIDogZnVuY1BhcmFtID8gX3NldHRlckZ1bmNXaXRoUGFyYW0gOiBfc2V0dGVyRnVuYyxcbiAgICAgIHB0O1xuXG4gIGlmIChfaXNTdHJpbmcoZW5kKSkge1xuICAgIGlmICh+ZW5kLmluZGV4T2YoXCJyYW5kb20oXCIpKSB7XG4gICAgICBlbmQgPSBfcmVwbGFjZVJhbmRvbShlbmQpO1xuICAgIH1cblxuICAgIGlmIChlbmQuY2hhckF0KDEpID09PSBcIj1cIikge1xuICAgICAgcHQgPSBfcGFyc2VSZWxhdGl2ZShwYXJzZWRTdGFydCwgZW5kKSArIChnZXRVbml0KHBhcnNlZFN0YXJ0KSB8fCAwKTtcblxuICAgICAgaWYgKHB0IHx8IHB0ID09PSAwKSB7XG4gICAgICAgIC8vIHRvIGF2b2lkIGlzTmFOLCBsaWtlIGlmIHNvbWVvbmUgcGFzc2VzIGluIGEgdmFsdWUgbGlrZSBcIiE9IHdoYXRldmVyXCJcbiAgICAgICAgZW5kID0gcHQ7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKHBhcnNlZFN0YXJ0ICE9PSBlbmQgfHwgX2ZvcmNlQWxsUHJvcFR3ZWVucykge1xuICAgIGlmICghaXNOYU4ocGFyc2VkU3RhcnQgKiBlbmQpICYmIGVuZCAhPT0gXCJcIikge1xuICAgICAgLy8gZnVuIGZhY3Q6IGFueSBudW1iZXIgbXVsdGlwbGllZCBieSBcIlwiIGlzIGV2YWx1YXRlZCBhcyB0aGUgbnVtYmVyIDAhXG4gICAgICBwdCA9IG5ldyBQcm9wVHdlZW4odGhpcy5fcHQsIHRhcmdldCwgcHJvcCwgK3BhcnNlZFN0YXJ0IHx8IDAsIGVuZCAtIChwYXJzZWRTdGFydCB8fCAwKSwgdHlwZW9mIGN1cnJlbnRWYWx1ZSA9PT0gXCJib29sZWFuXCIgPyBfcmVuZGVyQm9vbGVhbiA6IF9yZW5kZXJQbGFpbiwgMCwgc2V0dGVyKTtcbiAgICAgIGZ1bmNQYXJhbSAmJiAocHQuZnAgPSBmdW5jUGFyYW0pO1xuICAgICAgbW9kaWZpZXIgJiYgcHQubW9kaWZpZXIobW9kaWZpZXIsIHRoaXMsIHRhcmdldCk7XG4gICAgICByZXR1cm4gdGhpcy5fcHQgPSBwdDtcbiAgICB9XG5cbiAgICAhY3VycmVudFZhbHVlICYmICEocHJvcCBpbiB0YXJnZXQpICYmIF9taXNzaW5nUGx1Z2luKHByb3AsIGVuZCk7XG4gICAgcmV0dXJuIF9hZGRDb21wbGV4U3RyaW5nUHJvcFR3ZWVuLmNhbGwodGhpcywgdGFyZ2V0LCBwcm9wLCBwYXJzZWRTdGFydCwgZW5kLCBzZXR0ZXIsIHN0cmluZ0ZpbHRlciB8fCBfY29uZmlnLnN0cmluZ0ZpbHRlciwgZnVuY1BhcmFtKTtcbiAgfVxufSxcbiAgICAvL2NyZWF0ZXMgYSBjb3B5IG9mIHRoZSB2YXJzIG9iamVjdCBhbmQgcHJvY2Vzc2VzIGFueSBmdW5jdGlvbi1iYXNlZCB2YWx1ZXMgKHB1dHRpbmcgdGhlIHJlc3VsdGluZyB2YWx1ZXMgZGlyZWN0bHkgaW50byB0aGUgY29weSkgYXMgd2VsbCBhcyBzdHJpbmdzIHdpdGggXCJyYW5kb20oKVwiIGluIHRoZW0uIEl0IGRvZXMgTk9UIHByb2Nlc3MgcmVsYXRpdmUgdmFsdWVzLlxuX3Byb2Nlc3NWYXJzID0gZnVuY3Rpb24gX3Byb2Nlc3NWYXJzKHZhcnMsIGluZGV4LCB0YXJnZXQsIHRhcmdldHMsIHR3ZWVuKSB7XG4gIF9pc0Z1bmN0aW9uKHZhcnMpICYmICh2YXJzID0gX3BhcnNlRnVuY09yU3RyaW5nKHZhcnMsIHR3ZWVuLCBpbmRleCwgdGFyZ2V0LCB0YXJnZXRzKSk7XG5cbiAgaWYgKCFfaXNPYmplY3QodmFycykgfHwgdmFycy5zdHlsZSAmJiB2YXJzLm5vZGVUeXBlIHx8IF9pc0FycmF5KHZhcnMpIHx8IF9pc1R5cGVkQXJyYXkodmFycykpIHtcbiAgICByZXR1cm4gX2lzU3RyaW5nKHZhcnMpID8gX3BhcnNlRnVuY09yU3RyaW5nKHZhcnMsIHR3ZWVuLCBpbmRleCwgdGFyZ2V0LCB0YXJnZXRzKSA6IHZhcnM7XG4gIH1cblxuICB2YXIgY29weSA9IHt9LFxuICAgICAgcDtcblxuICBmb3IgKHAgaW4gdmFycykge1xuICAgIGNvcHlbcF0gPSBfcGFyc2VGdW5jT3JTdHJpbmcodmFyc1twXSwgdHdlZW4sIGluZGV4LCB0YXJnZXQsIHRhcmdldHMpO1xuICB9XG5cbiAgcmV0dXJuIGNvcHk7XG59LFxuICAgIF9jaGVja1BsdWdpbiA9IGZ1bmN0aW9uIF9jaGVja1BsdWdpbihwcm9wZXJ0eSwgdmFycywgdHdlZW4sIGluZGV4LCB0YXJnZXQsIHRhcmdldHMpIHtcbiAgdmFyIHBsdWdpbiwgcHQsIHB0TG9va3VwLCBpO1xuXG4gIGlmIChfcGx1Z2luc1twcm9wZXJ0eV0gJiYgKHBsdWdpbiA9IG5ldyBfcGx1Z2luc1twcm9wZXJ0eV0oKSkuaW5pdCh0YXJnZXQsIHBsdWdpbi5yYXdWYXJzID8gdmFyc1twcm9wZXJ0eV0gOiBfcHJvY2Vzc1ZhcnModmFyc1twcm9wZXJ0eV0sIGluZGV4LCB0YXJnZXQsIHRhcmdldHMsIHR3ZWVuKSwgdHdlZW4sIGluZGV4LCB0YXJnZXRzKSAhPT0gZmFsc2UpIHtcbiAgICB0d2Vlbi5fcHQgPSBwdCA9IG5ldyBQcm9wVHdlZW4odHdlZW4uX3B0LCB0YXJnZXQsIHByb3BlcnR5LCAwLCAxLCBwbHVnaW4ucmVuZGVyLCBwbHVnaW4sIDAsIHBsdWdpbi5wcmlvcml0eSk7XG5cbiAgICBpZiAodHdlZW4gIT09IF9xdWlja1R3ZWVuKSB7XG4gICAgICBwdExvb2t1cCA9IHR3ZWVuLl9wdExvb2t1cFt0d2Vlbi5fdGFyZ2V0cy5pbmRleE9mKHRhcmdldCldOyAvL25vdGU6IHdlIGNhbid0IHVzZSB0d2Vlbi5fcHRMb29rdXBbaW5kZXhdIGJlY2F1c2UgZm9yIHN0YWdnZXJlZCB0d2VlbnMsIHRoZSBpbmRleCBmcm9tIHRoZSBmdWxsVGFyZ2V0cyBhcnJheSB3b24ndCBtYXRjaCB3aGF0IGl0IGlzIGluIGVhY2ggaW5kaXZpZHVhbCB0d2VlbiB0aGF0IHNwYXducyBmcm9tIHRoZSBzdGFnZ2VyLlxuXG4gICAgICBpID0gcGx1Z2luLl9wcm9wcy5sZW5ndGg7XG5cbiAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgcHRMb29rdXBbcGx1Z2luLl9wcm9wc1tpXV0gPSBwdDtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gcGx1Z2luO1xufSxcbiAgICBfb3ZlcndyaXRpbmdUd2VlbixcbiAgICAvL3N0b3JlIGEgcmVmZXJlbmNlIHRlbXBvcmFyaWx5IHNvIHdlIGNhbiBhdm9pZCBvdmVyd3JpdGluZyBpdHNlbGYuXG5fZm9yY2VBbGxQcm9wVHdlZW5zLFxuICAgIF9pbml0VHdlZW4gPSBmdW5jdGlvbiBfaW5pdFR3ZWVuKHR3ZWVuLCB0aW1lKSB7XG4gIHZhciB2YXJzID0gdHdlZW4udmFycyxcbiAgICAgIGVhc2UgPSB2YXJzLmVhc2UsXG4gICAgICBzdGFydEF0ID0gdmFycy5zdGFydEF0LFxuICAgICAgaW1tZWRpYXRlUmVuZGVyID0gdmFycy5pbW1lZGlhdGVSZW5kZXIsXG4gICAgICBsYXp5ID0gdmFycy5sYXp5LFxuICAgICAgb25VcGRhdGUgPSB2YXJzLm9uVXBkYXRlLFxuICAgICAgb25VcGRhdGVQYXJhbXMgPSB2YXJzLm9uVXBkYXRlUGFyYW1zLFxuICAgICAgY2FsbGJhY2tTY29wZSA9IHZhcnMuY2FsbGJhY2tTY29wZSxcbiAgICAgIHJ1bkJhY2t3YXJkcyA9IHZhcnMucnVuQmFja3dhcmRzLFxuICAgICAgeW95b0Vhc2UgPSB2YXJzLnlveW9FYXNlLFxuICAgICAga2V5ZnJhbWVzID0gdmFycy5rZXlmcmFtZXMsXG4gICAgICBhdXRvUmV2ZXJ0ID0gdmFycy5hdXRvUmV2ZXJ0LFxuICAgICAgZHVyID0gdHdlZW4uX2R1cixcbiAgICAgIHByZXZTdGFydEF0ID0gdHdlZW4uX3N0YXJ0QXQsXG4gICAgICB0YXJnZXRzID0gdHdlZW4uX3RhcmdldHMsXG4gICAgICBwYXJlbnQgPSB0d2Vlbi5wYXJlbnQsXG4gICAgICBmdWxsVGFyZ2V0cyA9IHBhcmVudCAmJiBwYXJlbnQuZGF0YSA9PT0gXCJuZXN0ZWRcIiA/IHBhcmVudC5wYXJlbnQuX3RhcmdldHMgOiB0YXJnZXRzLFxuICAgICAgYXV0b092ZXJ3cml0ZSA9IHR3ZWVuLl9vdmVyd3JpdGUgPT09IFwiYXV0b1wiICYmICFfc3VwcHJlc3NPdmVyd3JpdGVzLFxuICAgICAgdGwgPSB0d2Vlbi50aW1lbGluZSxcbiAgICAgIGNsZWFuVmFycyxcbiAgICAgIGksXG4gICAgICBwLFxuICAgICAgcHQsXG4gICAgICB0YXJnZXQsXG4gICAgICBoYXNQcmlvcml0eSxcbiAgICAgIGdzRGF0YSxcbiAgICAgIGhhcm5lc3MsXG4gICAgICBwbHVnaW4sXG4gICAgICBwdExvb2t1cCxcbiAgICAgIGluZGV4LFxuICAgICAgaGFybmVzc1ZhcnMsXG4gICAgICBvdmVyd3JpdHRlbjtcbiAgdGwgJiYgKCFrZXlmcmFtZXMgfHwgIWVhc2UpICYmIChlYXNlID0gXCJub25lXCIpO1xuICB0d2Vlbi5fZWFzZSA9IF9wYXJzZUVhc2UoZWFzZSwgX2RlZmF1bHRzLmVhc2UpO1xuICB0d2Vlbi5feUVhc2UgPSB5b3lvRWFzZSA/IF9pbnZlcnRFYXNlKF9wYXJzZUVhc2UoeW95b0Vhc2UgPT09IHRydWUgPyBlYXNlIDogeW95b0Vhc2UsIF9kZWZhdWx0cy5lYXNlKSkgOiAwO1xuXG4gIGlmICh5b3lvRWFzZSAmJiB0d2Vlbi5feW95byAmJiAhdHdlZW4uX3JlcGVhdCkge1xuICAgIC8vdGhlcmUgbXVzdCBoYXZlIGJlZW4gYSBwYXJlbnQgdGltZWxpbmUgd2l0aCB5b3lvOnRydWUgdGhhdCBpcyBjdXJyZW50bHkgaW4gaXRzIHlveW8gcGhhc2UsIHNvIGZsaXAgdGhlIGVhc2VzLlxuICAgIHlveW9FYXNlID0gdHdlZW4uX3lFYXNlO1xuICAgIHR3ZWVuLl95RWFzZSA9IHR3ZWVuLl9lYXNlO1xuICAgIHR3ZWVuLl9lYXNlID0geW95b0Vhc2U7XG4gIH1cblxuICB0d2Vlbi5fZnJvbSA9ICF0bCAmJiAhIXZhcnMucnVuQmFja3dhcmRzOyAvL25lc3RlZCB0aW1lbGluZXMgc2hvdWxkIG5ldmVyIHJ1biBiYWNrd2FyZHMgLSB0aGUgYmFja3dhcmRzLW5lc3MgaXMgaW4gdGhlIGNoaWxkIHR3ZWVucy5cblxuICBpZiAoIXRsIHx8IGtleWZyYW1lcyAmJiAhdmFycy5zdGFnZ2VyKSB7XG4gICAgLy9pZiB0aGVyZSdzIGFuIGludGVybmFsIHRpbWVsaW5lLCBza2lwIGFsbCB0aGUgcGFyc2luZyBiZWNhdXNlIHdlIHBhc3NlZCB0aGF0IHRhc2sgZG93biB0aGUgY2hhaW4uXG4gICAgaGFybmVzcyA9IHRhcmdldHNbMF0gPyBfZ2V0Q2FjaGUodGFyZ2V0c1swXSkuaGFybmVzcyA6IDA7XG4gICAgaGFybmVzc1ZhcnMgPSBoYXJuZXNzICYmIHZhcnNbaGFybmVzcy5wcm9wXTsgLy9zb21lb25lIG1heSBuZWVkIHRvIHNwZWNpZnkgQ1NTLXNwZWNpZmljIHZhbHVlcyBBTkQgbm9uLUNTUyB2YWx1ZXMsIGxpa2UgaWYgdGhlIGVsZW1lbnQgaGFzIGFuIFwieFwiIHByb3BlcnR5IHBsdXMgaXQncyBhIHN0YW5kYXJkIERPTSBlbGVtZW50LiBXZSBhbGxvdyBwZW9wbGUgdG8gZGlzdGluZ3Vpc2ggYnkgd3JhcHBpbmcgcGx1Z2luLXNwZWNpZmljIHN0dWZmIGluIGEgY3NzOnt9IG9iamVjdCBmb3IgZXhhbXBsZS5cblxuICAgIGNsZWFuVmFycyA9IF9jb3B5RXhjbHVkaW5nKHZhcnMsIF9yZXNlcnZlZFByb3BzKTtcblxuICAgIGlmIChwcmV2U3RhcnRBdCkge1xuICAgICAgX3JlbW92ZUZyb21QYXJlbnQocHJldlN0YXJ0QXQucmVuZGVyKC0xLCB0cnVlKSk7XG5cbiAgICAgIHByZXZTdGFydEF0Ll9sYXp5ID0gMDtcbiAgICB9XG5cbiAgICBpZiAoc3RhcnRBdCkge1xuICAgICAgX3JlbW92ZUZyb21QYXJlbnQodHdlZW4uX3N0YXJ0QXQgPSBUd2Vlbi5zZXQodGFyZ2V0cywgX3NldERlZmF1bHRzKHtcbiAgICAgICAgZGF0YTogXCJpc1N0YXJ0XCIsXG4gICAgICAgIG92ZXJ3cml0ZTogZmFsc2UsXG4gICAgICAgIHBhcmVudDogcGFyZW50LFxuICAgICAgICBpbW1lZGlhdGVSZW5kZXI6IHRydWUsXG4gICAgICAgIGxhenk6IF9pc05vdEZhbHNlKGxhenkpLFxuICAgICAgICBzdGFydEF0OiBudWxsLFxuICAgICAgICBkZWxheTogMCxcbiAgICAgICAgb25VcGRhdGU6IG9uVXBkYXRlLFxuICAgICAgICBvblVwZGF0ZVBhcmFtczogb25VcGRhdGVQYXJhbXMsXG4gICAgICAgIGNhbGxiYWNrU2NvcGU6IGNhbGxiYWNrU2NvcGUsXG4gICAgICAgIHN0YWdnZXI6IDBcbiAgICAgIH0sIHN0YXJ0QXQpKSk7IC8vY29weSB0aGUgcHJvcGVydGllcy92YWx1ZXMgaW50byBhIG5ldyBvYmplY3QgdG8gYXZvaWQgY29sbGlzaW9ucywgbGlrZSB2YXIgdG8gPSB7eDowfSwgZnJvbSA9IHt4OjUwMH07IHRpbWVsaW5lLmZyb21UbyhlLCBmcm9tLCB0bykuZnJvbVRvKGUsIHRvLCBmcm9tKTtcblxuXG4gICAgICB0aW1lIDwgMCAmJiAhaW1tZWRpYXRlUmVuZGVyICYmICFhdXRvUmV2ZXJ0ICYmIHR3ZWVuLl9zdGFydEF0LnJlbmRlcigtMSwgdHJ1ZSk7IC8vIHJhcmUgZWRnZSBjYXNlLCBsaWtlIGlmIGEgcmVuZGVyIGlzIGZvcmNlZCBpbiB0aGUgbmVnYXRpdmUgZGlyZWN0aW9uIG9mIGEgbm9uLWluaXR0ZWQgdHdlZW4uXG5cbiAgICAgIGlmIChpbW1lZGlhdGVSZW5kZXIpIHtcbiAgICAgICAgdGltZSA+IDAgJiYgIWF1dG9SZXZlcnQgJiYgKHR3ZWVuLl9zdGFydEF0ID0gMCk7IC8vdHdlZW5zIHRoYXQgcmVuZGVyIGltbWVkaWF0ZWx5IChsaWtlIG1vc3QgZnJvbSgpIGFuZCBmcm9tVG8oKSB0d2VlbnMpIHNob3VsZG4ndCByZXZlcnQgd2hlbiB0aGVpciBwYXJlbnQgdGltZWxpbmUncyBwbGF5aGVhZCBnb2VzIGJhY2t3YXJkIHBhc3QgdGhlIHN0YXJ0VGltZSBiZWNhdXNlIHRoZSBpbml0aWFsIHJlbmRlciBjb3VsZCBoYXZlIGhhcHBlbmVkIGFueXRpbWUgYW5kIGl0IHNob3VsZG4ndCBiZSBkaXJlY3RseSBjb3JyZWxhdGVkIHRvIHRoaXMgdHdlZW4ncyBzdGFydFRpbWUuIEltYWdpbmUgc2V0dGluZyB1cCBhIGNvbXBsZXggYW5pbWF0aW9uIHdoZXJlIHRoZSBiZWdpbm5pbmcgc3RhdGVzIG9mIHZhcmlvdXMgb2JqZWN0cyBhcmUgcmVuZGVyZWQgaW1tZWRpYXRlbHkgYnV0IHRoZSB0d2VlbiBkb2Vzbid0IGhhcHBlbiBmb3IgcXVpdGUgc29tZSB0aW1lIC0gaWYgd2UgcmV2ZXJ0IHRvIHRoZSBzdGFydGluZyB2YWx1ZXMgYXMgc29vbiBhcyB0aGUgcGxheWhlYWQgZ29lcyBiYWNrd2FyZCBwYXN0IHRoZSB0d2VlbidzIHN0YXJ0VGltZSwgaXQgd2lsbCB0aHJvdyB0aGluZ3Mgb2ZmIHZpc3VhbGx5LiBSZXZlcnNpb24gc2hvdWxkIG9ubHkgaGFwcGVuIGluIFRpbWVsaW5lIGluc3RhbmNlcyB3aGVyZSBpbW1lZGlhdGVSZW5kZXIgd2FzIGZhbHNlIG9yIHdoZW4gYXV0b1JldmVydCBpcyBleHBsaWNpdGx5IHNldCB0byB0cnVlLlxuXG4gICAgICAgIGlmIChkdXIgJiYgdGltZSA8PSAwKSB7XG4gICAgICAgICAgdGltZSAmJiAodHdlZW4uX3pUaW1lID0gdGltZSk7XG4gICAgICAgICAgcmV0dXJuOyAvL3dlIHNraXAgaW5pdGlhbGl6YXRpb24gaGVyZSBzbyB0aGF0IG92ZXJ3cml0aW5nIGRvZXNuJ3Qgb2NjdXIgdW50aWwgdGhlIHR3ZWVuIGFjdHVhbGx5IGJlZ2lucy4gT3RoZXJ3aXNlLCBpZiB5b3UgY3JlYXRlIHNldmVyYWwgaW1tZWRpYXRlUmVuZGVyOnRydWUgdHdlZW5zIG9mIHRoZSBzYW1lIHRhcmdldC9wcm9wZXJ0aWVzIHRvIGRyb3AgaW50byBhIFRpbWVsaW5lLCB0aGUgbGFzdCBvbmUgY3JlYXRlZCB3b3VsZCBvdmVyd3JpdGUgdGhlIGZpcnN0IG9uZXMgYmVjYXVzZSB0aGV5IGRpZG4ndCBnZXQgcGxhY2VkIGludG8gdGhlIHRpbWVsaW5lIHlldCBiZWZvcmUgdGhlIGZpcnN0IHJlbmRlciBvY2N1cnMgYW5kIGtpY2tzIGluIG92ZXJ3cml0aW5nLlxuICAgICAgICB9IC8vIGlmICh0aW1lID4gMCkge1xuICAgICAgICAvLyBcdGF1dG9SZXZlcnQgfHwgKHR3ZWVuLl9zdGFydEF0ID0gMCk7IC8vdHdlZW5zIHRoYXQgcmVuZGVyIGltbWVkaWF0ZWx5IChsaWtlIG1vc3QgZnJvbSgpIGFuZCBmcm9tVG8oKSB0d2VlbnMpIHNob3VsZG4ndCByZXZlcnQgd2hlbiB0aGVpciBwYXJlbnQgdGltZWxpbmUncyBwbGF5aGVhZCBnb2VzIGJhY2t3YXJkIHBhc3QgdGhlIHN0YXJ0VGltZSBiZWNhdXNlIHRoZSBpbml0aWFsIHJlbmRlciBjb3VsZCBoYXZlIGhhcHBlbmVkIGFueXRpbWUgYW5kIGl0IHNob3VsZG4ndCBiZSBkaXJlY3RseSBjb3JyZWxhdGVkIHRvIHRoaXMgdHdlZW4ncyBzdGFydFRpbWUuIEltYWdpbmUgc2V0dGluZyB1cCBhIGNvbXBsZXggYW5pbWF0aW9uIHdoZXJlIHRoZSBiZWdpbm5pbmcgc3RhdGVzIG9mIHZhcmlvdXMgb2JqZWN0cyBhcmUgcmVuZGVyZWQgaW1tZWRpYXRlbHkgYnV0IHRoZSB0d2VlbiBkb2Vzbid0IGhhcHBlbiBmb3IgcXVpdGUgc29tZSB0aW1lIC0gaWYgd2UgcmV2ZXJ0IHRvIHRoZSBzdGFydGluZyB2YWx1ZXMgYXMgc29vbiBhcyB0aGUgcGxheWhlYWQgZ29lcyBiYWNrd2FyZCBwYXN0IHRoZSB0d2VlbidzIHN0YXJ0VGltZSwgaXQgd2lsbCB0aHJvdyB0aGluZ3Mgb2ZmIHZpc3VhbGx5LiBSZXZlcnNpb24gc2hvdWxkIG9ubHkgaGFwcGVuIGluIFRpbWVsaW5lIGluc3RhbmNlcyB3aGVyZSBpbW1lZGlhdGVSZW5kZXIgd2FzIGZhbHNlIG9yIHdoZW4gYXV0b1JldmVydCBpcyBleHBsaWNpdGx5IHNldCB0byB0cnVlLlxuICAgICAgICAvLyB9IGVsc2UgaWYgKGR1ciAmJiAhKHRpbWUgPCAwICYmIHByZXZTdGFydEF0KSkge1xuICAgICAgICAvLyBcdHRpbWUgJiYgKHR3ZWVuLl96VGltZSA9IHRpbWUpO1xuICAgICAgICAvLyBcdHJldHVybjsgLy93ZSBza2lwIGluaXRpYWxpemF0aW9uIGhlcmUgc28gdGhhdCBvdmVyd3JpdGluZyBkb2Vzbid0IG9jY3VyIHVudGlsIHRoZSB0d2VlbiBhY3R1YWxseSBiZWdpbnMuIE90aGVyd2lzZSwgaWYgeW91IGNyZWF0ZSBzZXZlcmFsIGltbWVkaWF0ZVJlbmRlcjp0cnVlIHR3ZWVucyBvZiB0aGUgc2FtZSB0YXJnZXQvcHJvcGVydGllcyB0byBkcm9wIGludG8gYSBUaW1lbGluZSwgdGhlIGxhc3Qgb25lIGNyZWF0ZWQgd291bGQgb3ZlcndyaXRlIHRoZSBmaXJzdCBvbmVzIGJlY2F1c2UgdGhleSBkaWRuJ3QgZ2V0IHBsYWNlZCBpbnRvIHRoZSB0aW1lbGluZSB5ZXQgYmVmb3JlIHRoZSBmaXJzdCByZW5kZXIgb2NjdXJzIGFuZCBraWNrcyBpbiBvdmVyd3JpdGluZy5cbiAgICAgICAgLy8gfVxuXG4gICAgICB9IGVsc2UgaWYgKGF1dG9SZXZlcnQgPT09IGZhbHNlKSB7XG4gICAgICAgIHR3ZWVuLl9zdGFydEF0ID0gMDtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHJ1bkJhY2t3YXJkcyAmJiBkdXIpIHtcbiAgICAgIC8vZnJvbSgpIHR3ZWVucyBtdXN0IGJlIGhhbmRsZWQgdW5pcXVlbHk6IHRoZWlyIGJlZ2lubmluZyB2YWx1ZXMgbXVzdCBiZSByZW5kZXJlZCBidXQgd2UgZG9uJ3Qgd2FudCBvdmVyd3JpdGluZyB0byBvY2N1ciB5ZXQgKHdoZW4gdGltZSBpcyBzdGlsbCAwKS4gV2FpdCB1bnRpbCB0aGUgdHdlZW4gYWN0dWFsbHkgYmVnaW5zIGJlZm9yZSBkb2luZyBhbGwgdGhlIHJvdXRpbmVzIGxpa2Ugb3ZlcndyaXRpbmcuIEF0IHRoYXQgdGltZSwgd2Ugc2hvdWxkIHJlbmRlciBhdCB0aGUgRU5EIG9mIHRoZSB0d2VlbiB0byBlbnN1cmUgdGhhdCB0aGluZ3MgaW5pdGlhbGl6ZSBjb3JyZWN0bHkgKHJlbWVtYmVyLCBmcm9tKCkgdHdlZW5zIGdvIGJhY2t3YXJkcylcbiAgICAgIGlmIChwcmV2U3RhcnRBdCkge1xuICAgICAgICAhYXV0b1JldmVydCAmJiAodHdlZW4uX3N0YXJ0QXQgPSAwKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRpbWUgJiYgKGltbWVkaWF0ZVJlbmRlciA9IGZhbHNlKTsgLy9pbiByYXJlIGNhc2VzIChsaWtlIGlmIGEgZnJvbSgpIHR3ZWVuIHJ1bnMgYW5kIHRoZW4gaXMgaW52YWxpZGF0ZSgpLWVkKSwgaW1tZWRpYXRlUmVuZGVyIGNvdWxkIGJlIHRydWUgYnV0IHRoZSBpbml0aWFsIGZvcmNlZC1yZW5kZXIgZ2V0cyBza2lwcGVkLCBzbyB0aGVyZSdzIG5vIG5lZWQgdG8gZm9yY2UgdGhlIHJlbmRlciBpbiB0aGlzIGNvbnRleHQgd2hlbiB0aGUgX3RpbWUgaXMgZ3JlYXRlciB0aGFuIDBcblxuICAgICAgICBwID0gX3NldERlZmF1bHRzKHtcbiAgICAgICAgICBvdmVyd3JpdGU6IGZhbHNlLFxuICAgICAgICAgIGRhdGE6IFwiaXNGcm9tU3RhcnRcIixcbiAgICAgICAgICAvL3dlIHRhZyB0aGUgdHdlZW4gd2l0aCBhcyBcImlzRnJvbVN0YXJ0XCIgc28gdGhhdCBpZiBbaW5zaWRlIGEgcGx1Z2luXSB3ZSBuZWVkIHRvIG9ubHkgZG8gc29tZXRoaW5nIGF0IHRoZSB2ZXJ5IEVORCBvZiBhIHR3ZWVuLCB3ZSBoYXZlIGEgd2F5IG9mIGlkZW50aWZ5aW5nIHRoaXMgdHdlZW4gYXMgbWVyZWx5IHRoZSBvbmUgdGhhdCdzIHNldHRpbmcgdGhlIGJlZ2lubmluZyB2YWx1ZXMgZm9yIGEgXCJmcm9tKClcIiB0d2Vlbi4gRm9yIGV4YW1wbGUsIGNsZWFyUHJvcHMgaW4gQ1NTUGx1Z2luIHNob3VsZCBvbmx5IGdldCBhcHBsaWVkIGF0IHRoZSB2ZXJ5IEVORCBvZiBhIHR3ZWVuIGFuZCB3aXRob3V0IHRoaXMgdGFnLCBmcm9tKC4uLntoZWlnaHQ6MTAwLCBjbGVhclByb3BzOlwiaGVpZ2h0XCIsIGRlbGF5OjF9KSB3b3VsZCB3aXBlIHRoZSBoZWlnaHQgYXQgdGhlIGJlZ2lubmluZyBvZiB0aGUgdHdlZW4gYW5kIGFmdGVyIDEgc2Vjb25kLCBpdCdkIGtpY2sgYmFjayBpbi5cbiAgICAgICAgICBsYXp5OiBpbW1lZGlhdGVSZW5kZXIgJiYgX2lzTm90RmFsc2UobGF6eSksXG4gICAgICAgICAgaW1tZWRpYXRlUmVuZGVyOiBpbW1lZGlhdGVSZW5kZXIsXG4gICAgICAgICAgLy96ZXJvLWR1cmF0aW9uIHR3ZWVucyByZW5kZXIgaW1tZWRpYXRlbHkgYnkgZGVmYXVsdCwgYnV0IGlmIHdlJ3JlIG5vdCBzcGVjaWZpY2FsbHkgaW5zdHJ1Y3RlZCB0byByZW5kZXIgdGhpcyB0d2VlbiBpbW1lZGlhdGVseSwgd2Ugc2hvdWxkIHNraXAgdGhpcyBhbmQgbWVyZWx5IF9pbml0KCkgdG8gcmVjb3JkIHRoZSBzdGFydGluZyB2YWx1ZXMgKHJlbmRlcmluZyB0aGVtIGltbWVkaWF0ZWx5IHdvdWxkIHB1c2ggdGhlbSB0byBjb21wbGV0aW9uIHdoaWNoIGlzIHdhc3RlZnVsIGluIHRoYXQgY2FzZSAtIHdlJ2QgaGF2ZSB0byByZW5kZXIoLTEpIGltbWVkaWF0ZWx5IGFmdGVyKVxuICAgICAgICAgIHN0YWdnZXI6IDAsXG4gICAgICAgICAgcGFyZW50OiBwYXJlbnQgLy9lbnN1cmVzIHRoYXQgbmVzdGVkIHR3ZWVucyB0aGF0IGhhZCBhIHN0YWdnZXIgYXJlIGhhbmRsZWQgcHJvcGVybHksIGxpa2UgZ3NhcC5mcm9tKFwiLmNsYXNzXCIsIHt5OmdzYXAudXRpbHMud3JhcChbLTEwMCwxMDBdKX0pXG5cbiAgICAgICAgfSwgY2xlYW5WYXJzKTtcbiAgICAgICAgaGFybmVzc1ZhcnMgJiYgKHBbaGFybmVzcy5wcm9wXSA9IGhhcm5lc3NWYXJzKTsgLy8gaW4gY2FzZSBzb21lb25lIGRvZXMgc29tZXRoaW5nIGxpa2UgLmZyb20oLi4uLCB7Y3NzOnt9fSlcblxuICAgICAgICBfcmVtb3ZlRnJvbVBhcmVudCh0d2Vlbi5fc3RhcnRBdCA9IFR3ZWVuLnNldCh0YXJnZXRzLCBwKSk7XG5cbiAgICAgICAgdGltZSA8IDAgJiYgdHdlZW4uX3N0YXJ0QXQucmVuZGVyKC0xLCB0cnVlKTsgLy8gcmFyZSBlZGdlIGNhc2UsIGxpa2UgaWYgYSByZW5kZXIgaXMgZm9yY2VkIGluIHRoZSBuZWdhdGl2ZSBkaXJlY3Rpb24gb2YgYSBub24taW5pdHRlZCBmcm9tKCkgdHdlZW4uXG5cbiAgICAgICAgdHdlZW4uX3pUaW1lID0gdGltZTtcblxuICAgICAgICBpZiAoIWltbWVkaWF0ZVJlbmRlcikge1xuICAgICAgICAgIF9pbml0VHdlZW4odHdlZW4uX3N0YXJ0QXQsIF90aW55TnVtKTsgLy9lbnN1cmVzIHRoYXQgdGhlIGluaXRpYWwgdmFsdWVzIGFyZSByZWNvcmRlZFxuXG4gICAgICAgIH0gZWxzZSBpZiAoIXRpbWUpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICB0d2Vlbi5fcHQgPSB0d2Vlbi5fcHRDYWNoZSA9IDA7XG4gICAgbGF6eSA9IGR1ciAmJiBfaXNOb3RGYWxzZShsYXp5KSB8fCBsYXp5ICYmICFkdXI7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgdGFyZ2V0cy5sZW5ndGg7IGkrKykge1xuICAgICAgdGFyZ2V0ID0gdGFyZ2V0c1tpXTtcbiAgICAgIGdzRGF0YSA9IHRhcmdldC5fZ3NhcCB8fCBfaGFybmVzcyh0YXJnZXRzKVtpXS5fZ3NhcDtcbiAgICAgIHR3ZWVuLl9wdExvb2t1cFtpXSA9IHB0TG9va3VwID0ge307XG4gICAgICBfbGF6eUxvb2t1cFtnc0RhdGEuaWRdICYmIF9sYXp5VHdlZW5zLmxlbmd0aCAmJiBfbGF6eVJlbmRlcigpOyAvL2lmIG90aGVyIHR3ZWVucyBvZiB0aGUgc2FtZSB0YXJnZXQgaGF2ZSByZWNlbnRseSBpbml0dGVkIGJ1dCBoYXZlbid0IHJlbmRlcmVkIHlldCwgd2UndmUgZ290IHRvIGZvcmNlIHRoZSByZW5kZXIgc28gdGhhdCB0aGUgc3RhcnRpbmcgdmFsdWVzIGFyZSBjb3JyZWN0IChpbWFnaW5lIHBvcHVsYXRpbmcgYSB0aW1lbGluZSB3aXRoIGEgYnVuY2ggb2Ygc2VxdWVudGlhbCB0d2VlbnMgYW5kIHRoZW4ganVtcGluZyB0byB0aGUgZW5kKVxuXG4gICAgICBpbmRleCA9IGZ1bGxUYXJnZXRzID09PSB0YXJnZXRzID8gaSA6IGZ1bGxUYXJnZXRzLmluZGV4T2YodGFyZ2V0KTtcblxuICAgICAgaWYgKGhhcm5lc3MgJiYgKHBsdWdpbiA9IG5ldyBoYXJuZXNzKCkpLmluaXQodGFyZ2V0LCBoYXJuZXNzVmFycyB8fCBjbGVhblZhcnMsIHR3ZWVuLCBpbmRleCwgZnVsbFRhcmdldHMpICE9PSBmYWxzZSkge1xuICAgICAgICB0d2Vlbi5fcHQgPSBwdCA9IG5ldyBQcm9wVHdlZW4odHdlZW4uX3B0LCB0YXJnZXQsIHBsdWdpbi5uYW1lLCAwLCAxLCBwbHVnaW4ucmVuZGVyLCBwbHVnaW4sIDAsIHBsdWdpbi5wcmlvcml0eSk7XG5cbiAgICAgICAgcGx1Z2luLl9wcm9wcy5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgICAgcHRMb29rdXBbbmFtZV0gPSBwdDtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcGx1Z2luLnByaW9yaXR5ICYmIChoYXNQcmlvcml0eSA9IDEpO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWhhcm5lc3MgfHwgaGFybmVzc1ZhcnMpIHtcbiAgICAgICAgZm9yIChwIGluIGNsZWFuVmFycykge1xuICAgICAgICAgIGlmIChfcGx1Z2luc1twXSAmJiAocGx1Z2luID0gX2NoZWNrUGx1Z2luKHAsIGNsZWFuVmFycywgdHdlZW4sIGluZGV4LCB0YXJnZXQsIGZ1bGxUYXJnZXRzKSkpIHtcbiAgICAgICAgICAgIHBsdWdpbi5wcmlvcml0eSAmJiAoaGFzUHJpb3JpdHkgPSAxKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcHRMb29rdXBbcF0gPSBwdCA9IF9hZGRQcm9wVHdlZW4uY2FsbCh0d2VlbiwgdGFyZ2V0LCBwLCBcImdldFwiLCBjbGVhblZhcnNbcF0sIGluZGV4LCBmdWxsVGFyZ2V0cywgMCwgdmFycy5zdHJpbmdGaWx0ZXIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB0d2Vlbi5fb3AgJiYgdHdlZW4uX29wW2ldICYmIHR3ZWVuLmtpbGwodGFyZ2V0LCB0d2Vlbi5fb3BbaV0pO1xuXG4gICAgICBpZiAoYXV0b092ZXJ3cml0ZSAmJiB0d2Vlbi5fcHQpIHtcbiAgICAgICAgX292ZXJ3cml0aW5nVHdlZW4gPSB0d2VlbjtcblxuICAgICAgICBfZ2xvYmFsVGltZWxpbmUua2lsbFR3ZWVuc09mKHRhcmdldCwgcHRMb29rdXAsIHR3ZWVuLmdsb2JhbFRpbWUodGltZSkpOyAvLyBtYWtlIHN1cmUgdGhlIG92ZXJ3cml0aW5nIGRvZXNuJ3Qgb3ZlcndyaXRlIFRISVMgdHdlZW4hISFcblxuXG4gICAgICAgIG92ZXJ3cml0dGVuID0gIXR3ZWVuLnBhcmVudDtcbiAgICAgICAgX292ZXJ3cml0aW5nVHdlZW4gPSAwO1xuICAgICAgfVxuXG4gICAgICB0d2Vlbi5fcHQgJiYgbGF6eSAmJiAoX2xhenlMb29rdXBbZ3NEYXRhLmlkXSA9IDEpO1xuICAgIH1cblxuICAgIGhhc1ByaW9yaXR5ICYmIF9zb3J0UHJvcFR3ZWVuc0J5UHJpb3JpdHkodHdlZW4pO1xuICAgIHR3ZWVuLl9vbkluaXQgJiYgdHdlZW4uX29uSW5pdCh0d2Vlbik7IC8vcGx1Z2lucyBsaWtlIFJvdW5kUHJvcHMgbXVzdCB3YWl0IHVudGlsIEFMTCBvZiB0aGUgUHJvcFR3ZWVucyBhcmUgaW5zdGFudGlhdGVkLiBJbiB0aGUgcGx1Z2luJ3MgaW5pdCgpIGZ1bmN0aW9uLCBpdCBzZXRzIHRoZSBfb25Jbml0IG9uIHRoZSB0d2VlbiBpbnN0YW5jZS4gTWF5IG5vdCBiZSBwcmV0dHkvaW50dWl0aXZlLCBidXQgaXQncyBmYXN0IGFuZCBrZWVwcyBmaWxlIHNpemUgZG93bi5cbiAgfVxuXG4gIHR3ZWVuLl9vblVwZGF0ZSA9IG9uVXBkYXRlO1xuICB0d2Vlbi5faW5pdHRlZCA9ICghdHdlZW4uX29wIHx8IHR3ZWVuLl9wdCkgJiYgIW92ZXJ3cml0dGVuOyAvLyBpZiBvdmVyd3JpdHRlblByb3BzIHJlc3VsdGVkIGluIHRoZSBlbnRpcmUgdHdlZW4gYmVpbmcga2lsbGVkLCBkbyBOT1QgZmxhZyBpdCBhcyBpbml0dGVkIG9yIGVsc2UgaXQgbWF5IHJlbmRlciBmb3Igb25lIHRpY2suXG5cbiAga2V5ZnJhbWVzICYmIHRpbWUgPD0gMCAmJiB0bC5yZW5kZXIoX2JpZ051bSwgdHJ1ZSwgdHJ1ZSk7IC8vIGlmIHRoZXJlJ3MgYSAwJSBrZXlmcmFtZSwgaXQnbGwgcmVuZGVyIGluIHRoZSBcImJlZm9yZVwiIHN0YXRlIGZvciBhbnkgc3RhZ2dlcmVkL2RlbGF5ZWQgYW5pbWF0aW9ucyB0aHVzIHdoZW4gdGhlIGZvbGxvd2luZyB0d2VlbiBpbml0aWFsaXplcywgaXQnbGwgdXNlIHRoZSBcImJlZm9yZVwiIHN0YXRlIGluc3RlYWQgb2YgdGhlIFwiYWZ0ZXJcIiBzdGF0ZSBhcyB0aGUgaW5pdGlhbCB2YWx1ZXMuXG59LFxuICAgIF91cGRhdGVQcm9wVHdlZW5zID0gZnVuY3Rpb24gX3VwZGF0ZVByb3BUd2VlbnModHdlZW4sIHByb3BlcnR5LCB2YWx1ZSwgc3RhcnQsIHN0YXJ0SXNSZWxhdGl2ZSwgcmF0aW8sIHRpbWUpIHtcbiAgdmFyIHB0Q2FjaGUgPSAodHdlZW4uX3B0ICYmIHR3ZWVuLl9wdENhY2hlIHx8ICh0d2Vlbi5fcHRDYWNoZSA9IHt9KSlbcHJvcGVydHldLFxuICAgICAgcHQsXG4gICAgICBsb29rdXAsXG4gICAgICBpO1xuXG4gIGlmICghcHRDYWNoZSkge1xuICAgIHB0Q2FjaGUgPSB0d2Vlbi5fcHRDYWNoZVtwcm9wZXJ0eV0gPSBbXTtcbiAgICBsb29rdXAgPSB0d2Vlbi5fcHRMb29rdXA7XG4gICAgaSA9IHR3ZWVuLl90YXJnZXRzLmxlbmd0aDtcblxuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIHB0ID0gbG9va3VwW2ldW3Byb3BlcnR5XTtcblxuICAgICAgaWYgKHB0ICYmIHB0LmQgJiYgcHQuZC5fcHQpIHtcbiAgICAgICAgLy8gaXQncyBhIHBsdWdpbiwgc28gZmluZCB0aGUgbmVzdGVkIFByb3BUd2VlblxuICAgICAgICBwdCA9IHB0LmQuX3B0O1xuXG4gICAgICAgIHdoaWxlIChwdCAmJiBwdC5wICE9PSBwcm9wZXJ0eSkge1xuICAgICAgICAgIHB0ID0gcHQuX25leHQ7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKCFwdCkge1xuICAgICAgICAvLyB0aGVyZSBpcyBubyBQcm9wVHdlZW4gYXNzb2NpYXRlZCB3aXRoIHRoYXQgcHJvcGVydHksIHNvIHdlIG11c3QgRk9SQ0Ugb25lIHRvIGJlIGNyZWF0ZWQgYW5kIGRpdGNoIG91dCBvZiB0aGlzXG4gICAgICAgIC8vIGlmIHRoZSB0d2VlbiBoYXMgb3RoZXIgcHJvcGVydGllcyB0aGF0IGFscmVhZHkgcmVuZGVyZWQgYXQgbmV3IHBvc2l0aW9ucywgd2UnZCBub3JtYWxseSBoYXZlIHRvIHJld2luZCB0byBwdXQgdGhlbSBiYWNrIGxpa2UgdHdlZW4ucmVuZGVyKDAsIHRydWUpIGJlZm9yZSBmb3JjaW5nIGFuIF9pbml0VHdlZW4oKSwgYnV0IHRoYXQgY2FuIGNyZWF0ZSBhbm90aGVyIGVkZ2UgY2FzZSBsaWtlIHR3ZWVuaW5nIGEgdGltZWxpbmUncyBwcm9ncmVzcyB3b3VsZCB0cmlnZ2VyIG9uVXBkYXRlcyB0byBmaXJlIHdoaWNoIGNvdWxkIG1vdmUgb3RoZXIgdGhpbmdzIGFyb3VuZC4gSXQncyBiZXR0ZXIgdG8ganVzdCBpbmZvcm0gdXNlcnMgdGhhdCAucmVzZXRUbygpIHNob3VsZCBPTkxZIGJlIHVzZWQgZm9yIHR3ZWVucyB0aGF0IGFscmVhZHkgaGF2ZSB0aGF0IHByb3BlcnR5LiBGb3IgZXhhbXBsZSwgeW91IGNhbid0IGdzYXAudG8oLi4ueyB5OiAwIH0pIGFuZCB0aGVuIHR3ZWVuLnJlc3RUbyhcInhcIiwgMjAwKSBmb3IgZXhhbXBsZS5cbiAgICAgICAgX2ZvcmNlQWxsUHJvcFR3ZWVucyA9IDE7IC8vIG90aGVyd2lzZSwgd2hlbiB3ZSBfYWRkUHJvcFR3ZWVuKCkgYW5kIGl0IGZpbmRzIG5vIGNoYW5nZSBiZXR3ZWVuIHRoZSBzdGFydCBhbmQgZW5kIHZhbHVlcywgaXQgc2tpcHMgY3JlYXRpbmcgYSBQcm9wVHdlZW4gKGZvciBlZmZpY2llbmN5Li4ud2h5IHR3ZWVuIHdoZW4gdGhlcmUncyBubyBkaWZmZXJlbmNlPykgYnV0IGluIHRoaXMgY2FzZSB3ZSBORUVEIHRoYXQgUHJvcFR3ZWVuIGNyZWF0ZWQgc28gd2UgY2FuIGVkaXQgaXQuXG5cbiAgICAgICAgdHdlZW4udmFyc1twcm9wZXJ0eV0gPSBcIis9MFwiO1xuXG4gICAgICAgIF9pbml0VHdlZW4odHdlZW4sIHRpbWUpO1xuXG4gICAgICAgIF9mb3JjZUFsbFByb3BUd2VlbnMgPSAwO1xuICAgICAgICByZXR1cm4gMTtcbiAgICAgIH1cblxuICAgICAgcHRDYWNoZS5wdXNoKHB0KTtcbiAgICB9XG4gIH1cblxuICBpID0gcHRDYWNoZS5sZW5ndGg7XG5cbiAgd2hpbGUgKGktLSkge1xuICAgIHB0ID0gcHRDYWNoZVtpXTtcbiAgICBwdC5zID0gKHN0YXJ0IHx8IHN0YXJ0ID09PSAwKSAmJiAhc3RhcnRJc1JlbGF0aXZlID8gc3RhcnQgOiBwdC5zICsgKHN0YXJ0IHx8IDApICsgcmF0aW8gKiBwdC5jO1xuICAgIHB0LmMgPSB2YWx1ZSAtIHB0LnM7XG4gICAgcHQuZSAmJiAocHQuZSA9IF9yb3VuZCh2YWx1ZSkgKyBnZXRVbml0KHB0LmUpKTsgLy8gbWFpbmx5IGZvciBDU1NQbHVnaW4gKGVuZCB2YWx1ZSlcblxuICAgIHB0LmIgJiYgKHB0LmIgPSBwdC5zICsgZ2V0VW5pdChwdC5iKSk7IC8vIChiZWdpbm5pbmcgdmFsdWUpXG4gIH1cbn0sXG4gICAgX2FkZEFsaWFzZXNUb1ZhcnMgPSBmdW5jdGlvbiBfYWRkQWxpYXNlc1RvVmFycyh0YXJnZXRzLCB2YXJzKSB7XG4gIHZhciBoYXJuZXNzID0gdGFyZ2V0c1swXSA/IF9nZXRDYWNoZSh0YXJnZXRzWzBdKS5oYXJuZXNzIDogMCxcbiAgICAgIHByb3BlcnR5QWxpYXNlcyA9IGhhcm5lc3MgJiYgaGFybmVzcy5hbGlhc2VzLFxuICAgICAgY29weSxcbiAgICAgIHAsXG4gICAgICBpLFxuICAgICAgYWxpYXNlcztcblxuICBpZiAoIXByb3BlcnR5QWxpYXNlcykge1xuICAgIHJldHVybiB2YXJzO1xuICB9XG5cbiAgY29weSA9IF9tZXJnZSh7fSwgdmFycyk7XG5cbiAgZm9yIChwIGluIHByb3BlcnR5QWxpYXNlcykge1xuICAgIGlmIChwIGluIGNvcHkpIHtcbiAgICAgIGFsaWFzZXMgPSBwcm9wZXJ0eUFsaWFzZXNbcF0uc3BsaXQoXCIsXCIpO1xuICAgICAgaSA9IGFsaWFzZXMubGVuZ3RoO1xuXG4gICAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgIGNvcHlbYWxpYXNlc1tpXV0gPSBjb3B5W3BdO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBjb3B5O1xufSxcbiAgICAvLyBwYXJzZXMgbXVsdGlwbGUgZm9ybWF0cywgbGlrZSB7XCIwJVwiOiB7eDogMTAwfSwge1wiNTAlXCI6IHt4OiAtMjB9fSBhbmQgeyB4OiB7XCIwJVwiOiAxMDAsIFwiNTAlXCI6IC0yMH0gfSwgYW5kIGFuIFwiZWFzZVwiIGNhbiBiZSBzZXQgb24gYW55IG9iamVjdC4gV2UgcG9wdWxhdGUgYW4gXCJhbGxQcm9wc1wiIG9iamVjdCB3aXRoIGFuIEFycmF5IGZvciBlYWNoIHByb3BlcnR5LCBsaWtlIHt4OiBbe30sIHt9XSwgeTpbe30sIHt9XX0gd2l0aCBkYXRhIGZvciBlYWNoIHByb3BlcnR5IHR3ZWVuLiBUaGUgb2JqZWN0cyBoYXZlIGEgXCJ0XCIgKHRpbWUpLCBcInZcIiwgKHZhbHVlKSwgYW5kIFwiZVwiIChlYXNlKSBwcm9wZXJ0eS4gVGhpcyBhbGxvd3MgdXMgdG8gcGllY2UgdG9nZXRoZXIgYSB0aW1lbGluZSBsYXRlci5cbl9wYXJzZUtleWZyYW1lID0gZnVuY3Rpb24gX3BhcnNlS2V5ZnJhbWUocHJvcCwgb2JqLCBhbGxQcm9wcywgZWFzZUVhY2gpIHtcbiAgdmFyIGVhc2UgPSBvYmouZWFzZSB8fCBlYXNlRWFjaCB8fCBcInBvd2VyMS5pbk91dFwiLFxuICAgICAgcCxcbiAgICAgIGE7XG5cbiAgaWYgKF9pc0FycmF5KG9iaikpIHtcbiAgICBhID0gYWxsUHJvcHNbcHJvcF0gfHwgKGFsbFByb3BzW3Byb3BdID0gW10pOyAvLyB0ID0gdGltZSAob3V0IG9mIDEwMCksIHYgPSB2YWx1ZSwgZSA9IGVhc2VcblxuICAgIG9iai5mb3JFYWNoKGZ1bmN0aW9uICh2YWx1ZSwgaSkge1xuICAgICAgcmV0dXJuIGEucHVzaCh7XG4gICAgICAgIHQ6IGkgLyAob2JqLmxlbmd0aCAtIDEpICogMTAwLFxuICAgICAgICB2OiB2YWx1ZSxcbiAgICAgICAgZTogZWFzZVxuICAgICAgfSk7XG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgZm9yIChwIGluIG9iaikge1xuICAgICAgYSA9IGFsbFByb3BzW3BdIHx8IChhbGxQcm9wc1twXSA9IFtdKTtcbiAgICAgIHAgPT09IFwiZWFzZVwiIHx8IGEucHVzaCh7XG4gICAgICAgIHQ6IHBhcnNlRmxvYXQocHJvcCksXG4gICAgICAgIHY6IG9ialtwXSxcbiAgICAgICAgZTogZWFzZVxuICAgICAgfSk7XG4gICAgfVxuICB9XG59LFxuICAgIF9wYXJzZUZ1bmNPclN0cmluZyA9IGZ1bmN0aW9uIF9wYXJzZUZ1bmNPclN0cmluZyh2YWx1ZSwgdHdlZW4sIGksIHRhcmdldCwgdGFyZ2V0cykge1xuICByZXR1cm4gX2lzRnVuY3Rpb24odmFsdWUpID8gdmFsdWUuY2FsbCh0d2VlbiwgaSwgdGFyZ2V0LCB0YXJnZXRzKSA6IF9pc1N0cmluZyh2YWx1ZSkgJiYgfnZhbHVlLmluZGV4T2YoXCJyYW5kb20oXCIpID8gX3JlcGxhY2VSYW5kb20odmFsdWUpIDogdmFsdWU7XG59LFxuICAgIF9zdGFnZ2VyVHdlZW5Qcm9wcyA9IF9jYWxsYmFja05hbWVzICsgXCJyZXBlYXQscmVwZWF0RGVsYXkseW95byxyZXBlYXRSZWZyZXNoLHlveW9FYXNlLGF1dG9SZXZlcnRcIixcbiAgICBfc3RhZ2dlclByb3BzVG9Ta2lwID0ge307XG5cbl9mb3JFYWNoTmFtZShfc3RhZ2dlclR3ZWVuUHJvcHMgKyBcIixpZCxzdGFnZ2VyLGRlbGF5LGR1cmF0aW9uLHBhdXNlZCxzY3JvbGxUcmlnZ2VyXCIsIGZ1bmN0aW9uIChuYW1lKSB7XG4gIHJldHVybiBfc3RhZ2dlclByb3BzVG9Ta2lwW25hbWVdID0gMTtcbn0pO1xuLypcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBUV0VFTlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqL1xuXG5cbmV4cG9ydCB2YXIgVHdlZW4gPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9BbmltYXRpb24yKSB7XG4gIF9pbmhlcml0c0xvb3NlKFR3ZWVuLCBfQW5pbWF0aW9uMik7XG5cbiAgZnVuY3Rpb24gVHdlZW4odGFyZ2V0cywgdmFycywgcG9zaXRpb24sIHNraXBJbmhlcml0KSB7XG4gICAgdmFyIF90aGlzMztcblxuICAgIGlmICh0eXBlb2YgdmFycyA9PT0gXCJudW1iZXJcIikge1xuICAgICAgcG9zaXRpb24uZHVyYXRpb24gPSB2YXJzO1xuICAgICAgdmFycyA9IHBvc2l0aW9uO1xuICAgICAgcG9zaXRpb24gPSBudWxsO1xuICAgIH1cblxuICAgIF90aGlzMyA9IF9BbmltYXRpb24yLmNhbGwodGhpcywgc2tpcEluaGVyaXQgPyB2YXJzIDogX2luaGVyaXREZWZhdWx0cyh2YXJzKSkgfHwgdGhpcztcbiAgICB2YXIgX3RoaXMzJHZhcnMgPSBfdGhpczMudmFycyxcbiAgICAgICAgZHVyYXRpb24gPSBfdGhpczMkdmFycy5kdXJhdGlvbixcbiAgICAgICAgZGVsYXkgPSBfdGhpczMkdmFycy5kZWxheSxcbiAgICAgICAgaW1tZWRpYXRlUmVuZGVyID0gX3RoaXMzJHZhcnMuaW1tZWRpYXRlUmVuZGVyLFxuICAgICAgICBzdGFnZ2VyID0gX3RoaXMzJHZhcnMuc3RhZ2dlcixcbiAgICAgICAgb3ZlcndyaXRlID0gX3RoaXMzJHZhcnMub3ZlcndyaXRlLFxuICAgICAgICBrZXlmcmFtZXMgPSBfdGhpczMkdmFycy5rZXlmcmFtZXMsXG4gICAgICAgIGRlZmF1bHRzID0gX3RoaXMzJHZhcnMuZGVmYXVsdHMsXG4gICAgICAgIHNjcm9sbFRyaWdnZXIgPSBfdGhpczMkdmFycy5zY3JvbGxUcmlnZ2VyLFxuICAgICAgICB5b3lvRWFzZSA9IF90aGlzMyR2YXJzLnlveW9FYXNlLFxuICAgICAgICBwYXJlbnQgPSB2YXJzLnBhcmVudCB8fCBfZ2xvYmFsVGltZWxpbmUsXG4gICAgICAgIHBhcnNlZFRhcmdldHMgPSAoX2lzQXJyYXkodGFyZ2V0cykgfHwgX2lzVHlwZWRBcnJheSh0YXJnZXRzKSA/IF9pc051bWJlcih0YXJnZXRzWzBdKSA6IFwibGVuZ3RoXCIgaW4gdmFycykgPyBbdGFyZ2V0c10gOiB0b0FycmF5KHRhcmdldHMpLFxuICAgICAgICB0bCxcbiAgICAgICAgaSxcbiAgICAgICAgY29weSxcbiAgICAgICAgbCxcbiAgICAgICAgcCxcbiAgICAgICAgY3VyVGFyZ2V0LFxuICAgICAgICBzdGFnZ2VyRnVuYyxcbiAgICAgICAgc3RhZ2dlclZhcnNUb01lcmdlO1xuICAgIF90aGlzMy5fdGFyZ2V0cyA9IHBhcnNlZFRhcmdldHMubGVuZ3RoID8gX2hhcm5lc3MocGFyc2VkVGFyZ2V0cykgOiBfd2FybihcIkdTQVAgdGFyZ2V0IFwiICsgdGFyZ2V0cyArIFwiIG5vdCBmb3VuZC4gaHR0cHM6Ly9ncmVlbnNvY2suY29tXCIsICFfY29uZmlnLm51bGxUYXJnZXRXYXJuKSB8fCBbXTtcbiAgICBfdGhpczMuX3B0TG9va3VwID0gW107IC8vUHJvcFR3ZWVuIGxvb2t1cC4gQW4gYXJyYXkgY29udGFpbmluZyBhbiBvYmplY3QgZm9yIGVhY2ggdGFyZ2V0LCBoYXZpbmcga2V5cyBmb3IgZWFjaCB0d2VlbmluZyBwcm9wZXJ0eVxuXG4gICAgX3RoaXMzLl9vdmVyd3JpdGUgPSBvdmVyd3JpdGU7XG5cbiAgICBpZiAoa2V5ZnJhbWVzIHx8IHN0YWdnZXIgfHwgX2lzRnVuY09yU3RyaW5nKGR1cmF0aW9uKSB8fCBfaXNGdW5jT3JTdHJpbmcoZGVsYXkpKSB7XG4gICAgICB2YXJzID0gX3RoaXMzLnZhcnM7XG4gICAgICB0bCA9IF90aGlzMy50aW1lbGluZSA9IG5ldyBUaW1lbGluZSh7XG4gICAgICAgIGRhdGE6IFwibmVzdGVkXCIsXG4gICAgICAgIGRlZmF1bHRzOiBkZWZhdWx0cyB8fCB7fVxuICAgICAgfSk7XG4gICAgICB0bC5raWxsKCk7XG4gICAgICB0bC5wYXJlbnQgPSB0bC5fZHAgPSBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzMyk7XG4gICAgICB0bC5fc3RhcnQgPSAwO1xuXG4gICAgICBpZiAoc3RhZ2dlciB8fCBfaXNGdW5jT3JTdHJpbmcoZHVyYXRpb24pIHx8IF9pc0Z1bmNPclN0cmluZyhkZWxheSkpIHtcbiAgICAgICAgbCA9IHBhcnNlZFRhcmdldHMubGVuZ3RoO1xuICAgICAgICBzdGFnZ2VyRnVuYyA9IHN0YWdnZXIgJiYgZGlzdHJpYnV0ZShzdGFnZ2VyKTtcblxuICAgICAgICBpZiAoX2lzT2JqZWN0KHN0YWdnZXIpKSB7XG4gICAgICAgICAgLy91c2VycyBjYW4gcGFzcyBpbiBjYWxsYmFja3MgbGlrZSBvblN0YXJ0L29uQ29tcGxldGUgaW4gdGhlIHN0YWdnZXIgb2JqZWN0LiBUaGVzZSBzaG91bGQgZmlyZSB3aXRoIGVhY2ggaW5kaXZpZHVhbCB0d2Vlbi5cbiAgICAgICAgICBmb3IgKHAgaW4gc3RhZ2dlcikge1xuICAgICAgICAgICAgaWYgKH5fc3RhZ2dlclR3ZWVuUHJvcHMuaW5kZXhPZihwKSkge1xuICAgICAgICAgICAgICBzdGFnZ2VyVmFyc1RvTWVyZ2UgfHwgKHN0YWdnZXJWYXJzVG9NZXJnZSA9IHt9KTtcbiAgICAgICAgICAgICAgc3RhZ2dlclZhcnNUb01lcmdlW3BdID0gc3RhZ2dlcltwXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgY29weSA9IF9jb3B5RXhjbHVkaW5nKHZhcnMsIF9zdGFnZ2VyUHJvcHNUb1NraXApO1xuICAgICAgICAgIGNvcHkuc3RhZ2dlciA9IDA7XG4gICAgICAgICAgeW95b0Vhc2UgJiYgKGNvcHkueW95b0Vhc2UgPSB5b3lvRWFzZSk7XG4gICAgICAgICAgc3RhZ2dlclZhcnNUb01lcmdlICYmIF9tZXJnZShjb3B5LCBzdGFnZ2VyVmFyc1RvTWVyZ2UpO1xuICAgICAgICAgIGN1clRhcmdldCA9IHBhcnNlZFRhcmdldHNbaV07IC8vZG9uJ3QganVzdCBjb3B5IGR1cmF0aW9uIG9yIGRlbGF5IGJlY2F1c2UgaWYgdGhleSdyZSBhIHN0cmluZyBvciBmdW5jdGlvbiwgd2UnZCBlbmQgdXAgaW4gYW4gaW5maW5pdGUgbG9vcCBiZWNhdXNlIF9pc0Z1bmNPclN0cmluZygpIHdvdWxkIGV2YWx1YXRlIGFzIHRydWUgaW4gdGhlIGNoaWxkIHR3ZWVucywgZW50ZXJpbmcgdGhpcyBsb29wLCBldGMuIFNvIHdlIHBhcnNlIHRoZSB2YWx1ZSBzdHJhaWdodCBmcm9tIHZhcnMgYW5kIGRlZmF1bHQgdG8gMC5cblxuICAgICAgICAgIGNvcHkuZHVyYXRpb24gPSArX3BhcnNlRnVuY09yU3RyaW5nKGR1cmF0aW9uLCBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzMyksIGksIGN1clRhcmdldCwgcGFyc2VkVGFyZ2V0cyk7XG4gICAgICAgICAgY29weS5kZWxheSA9ICgrX3BhcnNlRnVuY09yU3RyaW5nKGRlbGF5LCBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzMyksIGksIGN1clRhcmdldCwgcGFyc2VkVGFyZ2V0cykgfHwgMCkgLSBfdGhpczMuX2RlbGF5O1xuXG4gICAgICAgICAgaWYgKCFzdGFnZ2VyICYmIGwgPT09IDEgJiYgY29weS5kZWxheSkge1xuICAgICAgICAgICAgLy8gaWYgc29tZW9uZSBkb2VzIGRlbGF5OlwicmFuZG9tKDEsIDUpXCIsIHJlcGVhdDotMSwgZm9yIGV4YW1wbGUsIHRoZSBkZWxheSBzaG91bGRuJ3QgYmUgaW5zaWRlIHRoZSByZXBlYXQuXG4gICAgICAgICAgICBfdGhpczMuX2RlbGF5ID0gZGVsYXkgPSBjb3B5LmRlbGF5O1xuICAgICAgICAgICAgX3RoaXMzLl9zdGFydCArPSBkZWxheTtcbiAgICAgICAgICAgIGNvcHkuZGVsYXkgPSAwO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRsLnRvKGN1clRhcmdldCwgY29weSwgc3RhZ2dlckZ1bmMgPyBzdGFnZ2VyRnVuYyhpLCBjdXJUYXJnZXQsIHBhcnNlZFRhcmdldHMpIDogMCk7XG4gICAgICAgICAgdGwuX2Vhc2UgPSBfZWFzZU1hcC5ub25lO1xuICAgICAgICB9XG5cbiAgICAgICAgdGwuZHVyYXRpb24oKSA/IGR1cmF0aW9uID0gZGVsYXkgPSAwIDogX3RoaXMzLnRpbWVsaW5lID0gMDsgLy8gaWYgdGhlIHRpbWVsaW5lJ3MgZHVyYXRpb24gaXMgMCwgd2UgZG9uJ3QgbmVlZCBhIHRpbWVsaW5lIGludGVybmFsbHkhXG4gICAgICB9IGVsc2UgaWYgKGtleWZyYW1lcykge1xuICAgICAgICBfaW5oZXJpdERlZmF1bHRzKF9zZXREZWZhdWx0cyh0bC52YXJzLmRlZmF1bHRzLCB7XG4gICAgICAgICAgZWFzZTogXCJub25lXCJcbiAgICAgICAgfSkpO1xuXG4gICAgICAgIHRsLl9lYXNlID0gX3BhcnNlRWFzZShrZXlmcmFtZXMuZWFzZSB8fCB2YXJzLmVhc2UgfHwgXCJub25lXCIpO1xuICAgICAgICB2YXIgdGltZSA9IDAsXG4gICAgICAgICAgICBhLFxuICAgICAgICAgICAga2YsXG4gICAgICAgICAgICB2O1xuXG4gICAgICAgIGlmIChfaXNBcnJheShrZXlmcmFtZXMpKSB7XG4gICAgICAgICAga2V5ZnJhbWVzLmZvckVhY2goZnVuY3Rpb24gKGZyYW1lKSB7XG4gICAgICAgICAgICByZXR1cm4gdGwudG8ocGFyc2VkVGFyZ2V0cywgZnJhbWUsIFwiPlwiKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb3B5ID0ge307XG5cbiAgICAgICAgICBmb3IgKHAgaW4ga2V5ZnJhbWVzKSB7XG4gICAgICAgICAgICBwID09PSBcImVhc2VcIiB8fCBwID09PSBcImVhc2VFYWNoXCIgfHwgX3BhcnNlS2V5ZnJhbWUocCwga2V5ZnJhbWVzW3BdLCBjb3B5LCBrZXlmcmFtZXMuZWFzZUVhY2gpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGZvciAocCBpbiBjb3B5KSB7XG4gICAgICAgICAgICBhID0gY29weVtwXS5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgICAgICAgIHJldHVybiBhLnQgLSBiLnQ7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRpbWUgPSAwO1xuXG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgYS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICBrZiA9IGFbaV07XG4gICAgICAgICAgICAgIHYgPSB7XG4gICAgICAgICAgICAgICAgZWFzZToga2YuZSxcbiAgICAgICAgICAgICAgICBkdXJhdGlvbjogKGtmLnQgLSAoaSA/IGFbaSAtIDFdLnQgOiAwKSkgLyAxMDAgKiBkdXJhdGlvblxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICB2W3BdID0ga2YudjtcbiAgICAgICAgICAgICAgdGwudG8ocGFyc2VkVGFyZ2V0cywgdiwgdGltZSk7XG4gICAgICAgICAgICAgIHRpbWUgKz0gdi5kdXJhdGlvbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0bC5kdXJhdGlvbigpIDwgZHVyYXRpb24gJiYgdGwudG8oe30sIHtcbiAgICAgICAgICAgIGR1cmF0aW9uOiBkdXJhdGlvbiAtIHRsLmR1cmF0aW9uKClcbiAgICAgICAgICB9KTsgLy8gaW4gY2FzZSBrZXlmcmFtZXMgZGlkbid0IGdvIHRvIDEwMCVcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBkdXJhdGlvbiB8fCBfdGhpczMuZHVyYXRpb24oZHVyYXRpb24gPSB0bC5kdXJhdGlvbigpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgX3RoaXMzLnRpbWVsaW5lID0gMDsgLy9zcGVlZCBvcHRpbWl6YXRpb24sIGZhc3RlciBsb29rdXBzIChubyBnb2luZyB1cCB0aGUgcHJvdG90eXBlIGNoYWluKVxuICAgIH1cblxuICAgIGlmIChvdmVyd3JpdGUgPT09IHRydWUgJiYgIV9zdXBwcmVzc092ZXJ3cml0ZXMpIHtcbiAgICAgIF9vdmVyd3JpdGluZ1R3ZWVuID0gX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpczMpO1xuXG4gICAgICBfZ2xvYmFsVGltZWxpbmUua2lsbFR3ZWVuc09mKHBhcnNlZFRhcmdldHMpO1xuXG4gICAgICBfb3ZlcndyaXRpbmdUd2VlbiA9IDA7XG4gICAgfVxuXG4gICAgX2FkZFRvVGltZWxpbmUocGFyZW50LCBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzMyksIHBvc2l0aW9uKTtcblxuICAgIHZhcnMucmV2ZXJzZWQgJiYgX3RoaXMzLnJldmVyc2UoKTtcbiAgICB2YXJzLnBhdXNlZCAmJiBfdGhpczMucGF1c2VkKHRydWUpO1xuXG4gICAgaWYgKGltbWVkaWF0ZVJlbmRlciB8fCAhZHVyYXRpb24gJiYgIWtleWZyYW1lcyAmJiBfdGhpczMuX3N0YXJ0ID09PSBfcm91bmRQcmVjaXNlKHBhcmVudC5fdGltZSkgJiYgX2lzTm90RmFsc2UoaW1tZWRpYXRlUmVuZGVyKSAmJiBfaGFzTm9QYXVzZWRBbmNlc3RvcnMoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpczMpKSAmJiBwYXJlbnQuZGF0YSAhPT0gXCJuZXN0ZWRcIikge1xuICAgICAgX3RoaXMzLl90VGltZSA9IC1fdGlueU51bTsgLy9mb3JjZXMgYSByZW5kZXIgd2l0aG91dCBoYXZpbmcgdG8gc2V0IHRoZSByZW5kZXIoKSBcImZvcmNlXCIgcGFyYW1ldGVyIHRvIHRydWUgYmVjYXVzZSB3ZSB3YW50IHRvIGFsbG93IGxhenlpbmcgYnkgZGVmYXVsdCAodXNpbmcgdGhlIFwiZm9yY2VcIiBwYXJhbWV0ZXIgYWx3YXlzIGZvcmNlcyBhbiBpbW1lZGlhdGUgZnVsbCByZW5kZXIpXG5cbiAgICAgIF90aGlzMy5yZW5kZXIoTWF0aC5tYXgoMCwgLWRlbGF5KSk7IC8vaW4gY2FzZSBkZWxheSBpcyBuZWdhdGl2ZVxuXG4gICAgfVxuXG4gICAgc2Nyb2xsVHJpZ2dlciAmJiBfc2Nyb2xsVHJpZ2dlcihfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzMyksIHNjcm9sbFRyaWdnZXIpO1xuICAgIHJldHVybiBfdGhpczM7XG4gIH1cblxuICB2YXIgX3Byb3RvMyA9IFR3ZWVuLnByb3RvdHlwZTtcblxuICBfcHJvdG8zLnJlbmRlciA9IGZ1bmN0aW9uIHJlbmRlcih0b3RhbFRpbWUsIHN1cHByZXNzRXZlbnRzLCBmb3JjZSkge1xuICAgIHZhciBwcmV2VGltZSA9IHRoaXMuX3RpbWUsXG4gICAgICAgIHREdXIgPSB0aGlzLl90RHVyLFxuICAgICAgICBkdXIgPSB0aGlzLl9kdXIsXG4gICAgICAgIHRUaW1lID0gdG90YWxUaW1lID4gdER1ciAtIF90aW55TnVtICYmIHRvdGFsVGltZSA+PSAwID8gdER1ciA6IHRvdGFsVGltZSA8IF90aW55TnVtID8gMCA6IHRvdGFsVGltZSxcbiAgICAgICAgdGltZSxcbiAgICAgICAgcHQsXG4gICAgICAgIGl0ZXJhdGlvbixcbiAgICAgICAgY3ljbGVEdXJhdGlvbixcbiAgICAgICAgcHJldkl0ZXJhdGlvbixcbiAgICAgICAgaXNZb3lvLFxuICAgICAgICByYXRpbyxcbiAgICAgICAgdGltZWxpbmUsXG4gICAgICAgIHlveW9FYXNlO1xuXG4gICAgaWYgKCFkdXIpIHtcbiAgICAgIF9yZW5kZXJaZXJvRHVyYXRpb25Ud2Vlbih0aGlzLCB0b3RhbFRpbWUsIHN1cHByZXNzRXZlbnRzLCBmb3JjZSk7XG4gICAgfSBlbHNlIGlmICh0VGltZSAhPT0gdGhpcy5fdFRpbWUgfHwgIXRvdGFsVGltZSB8fCBmb3JjZSB8fCAhdGhpcy5faW5pdHRlZCAmJiB0aGlzLl90VGltZSB8fCB0aGlzLl9zdGFydEF0ICYmIHRoaXMuX3pUaW1lIDwgMCAhPT0gdG90YWxUaW1lIDwgMCkge1xuICAgICAgLy90aGlzIHNlbnNlcyBpZiB3ZSdyZSBjcm9zc2luZyBvdmVyIHRoZSBzdGFydCB0aW1lLCBpbiB3aGljaCBjYXNlIHdlIG11c3QgcmVjb3JkIF96VGltZSBhbmQgZm9yY2UgdGhlIHJlbmRlciwgYnV0IHdlIGRvIGl0IGluIHRoaXMgbGVuZ3RoeSBjb25kaXRpb25hbCB3YXkgZm9yIHBlcmZvcm1hbmNlIHJlYXNvbnMgKHVzdWFsbHkgd2UgY2FuIHNraXAgdGhlIGNhbGN1bGF0aW9ucyk6IHRoaXMuX2luaXR0ZWQgJiYgKHRoaXMuX3pUaW1lIDwgMCkgIT09ICh0b3RhbFRpbWUgPCAwKVxuICAgICAgdGltZSA9IHRUaW1lO1xuICAgICAgdGltZWxpbmUgPSB0aGlzLnRpbWVsaW5lO1xuXG4gICAgICBpZiAodGhpcy5fcmVwZWF0KSB7XG4gICAgICAgIC8vYWRqdXN0IHRoZSB0aW1lIGZvciByZXBlYXRzIGFuZCB5b3lvc1xuICAgICAgICBjeWNsZUR1cmF0aW9uID0gZHVyICsgdGhpcy5fckRlbGF5O1xuXG4gICAgICAgIGlmICh0aGlzLl9yZXBlYXQgPCAtMSAmJiB0b3RhbFRpbWUgPCAwKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMudG90YWxUaW1lKGN5Y2xlRHVyYXRpb24gKiAxMDAgKyB0b3RhbFRpbWUsIHN1cHByZXNzRXZlbnRzLCBmb3JjZSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aW1lID0gX3JvdW5kUHJlY2lzZSh0VGltZSAlIGN5Y2xlRHVyYXRpb24pOyAvL3JvdW5kIHRvIGF2b2lkIGZsb2F0aW5nIHBvaW50IGVycm9ycy4gKDQgJSAwLjggc2hvdWxkIGJlIDAgYnV0IHNvbWUgYnJvd3NlcnMgcmVwb3J0IGl0IGFzIDAuNzk5OTk5OTkhKVxuXG4gICAgICAgIGlmICh0VGltZSA9PT0gdER1cikge1xuICAgICAgICAgIC8vIHRoZSB0RHVyID09PSB0VGltZSBpcyBmb3IgZWRnZSBjYXNlcyB3aGVyZSB0aGVyZSdzIGEgbGVuZ3RoeSBkZWNpbWFsIG9uIHRoZSBkdXJhdGlvbiBhbmQgaXQgbWF5IHJlYWNoIHRoZSB2ZXJ5IGVuZCBidXQgdGhlIHRpbWUgaXMgcmVuZGVyZWQgYXMgbm90LXF1aXRlLXRoZXJlIChyZW1lbWJlciwgdER1ciBpcyByb3VuZGVkIHRvIDQgZGVjaW1hbHMgd2hlcmVhcyBkdXIgaXNuJ3QpXG4gICAgICAgICAgaXRlcmF0aW9uID0gdGhpcy5fcmVwZWF0O1xuICAgICAgICAgIHRpbWUgPSBkdXI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaXRlcmF0aW9uID0gfn4odFRpbWUgLyBjeWNsZUR1cmF0aW9uKTtcblxuICAgICAgICAgIGlmIChpdGVyYXRpb24gJiYgaXRlcmF0aW9uID09PSB0VGltZSAvIGN5Y2xlRHVyYXRpb24pIHtcbiAgICAgICAgICAgIHRpbWUgPSBkdXI7XG4gICAgICAgICAgICBpdGVyYXRpb24tLTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aW1lID4gZHVyICYmICh0aW1lID0gZHVyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlzWW95byA9IHRoaXMuX3lveW8gJiYgaXRlcmF0aW9uICYgMTtcblxuICAgICAgICBpZiAoaXNZb3lvKSB7XG4gICAgICAgICAgeW95b0Vhc2UgPSB0aGlzLl95RWFzZTtcbiAgICAgICAgICB0aW1lID0gZHVyIC0gdGltZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHByZXZJdGVyYXRpb24gPSBfYW5pbWF0aW9uQ3ljbGUodGhpcy5fdFRpbWUsIGN5Y2xlRHVyYXRpb24pO1xuXG4gICAgICAgIGlmICh0aW1lID09PSBwcmV2VGltZSAmJiAhZm9yY2UgJiYgdGhpcy5faW5pdHRlZCkge1xuICAgICAgICAgIC8vY291bGQgYmUgZHVyaW5nIHRoZSByZXBlYXREZWxheSBwYXJ0LiBObyBuZWVkIHRvIHJlbmRlciBhbmQgZmlyZSBjYWxsYmFja3MuXG4gICAgICAgICAgdGhpcy5fdFRpbWUgPSB0VGltZTtcbiAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpdGVyYXRpb24gIT09IHByZXZJdGVyYXRpb24pIHtcbiAgICAgICAgICB0aW1lbGluZSAmJiB0aGlzLl95RWFzZSAmJiBfcHJvcGFnYXRlWW95b0Vhc2UodGltZWxpbmUsIGlzWW95byk7IC8vcmVwZWF0UmVmcmVzaCBmdW5jdGlvbmFsaXR5XG5cbiAgICAgICAgICBpZiAodGhpcy52YXJzLnJlcGVhdFJlZnJlc2ggJiYgIWlzWW95byAmJiAhdGhpcy5fbG9jaykge1xuICAgICAgICAgICAgdGhpcy5fbG9jayA9IGZvcmNlID0gMTsgLy9mb3JjZSwgb3RoZXJ3aXNlIGlmIGxhenkgaXMgdHJ1ZSwgdGhlIF9hdHRlbXB0SW5pdFR3ZWVuKCkgd2lsbCByZXR1cm4gYW5kIHdlJ2xsIGp1bXAgb3V0IGFuZCBnZXQgY2F1Z2h0IGJvdW5jaW5nIG9uIGVhY2ggdGljay5cblxuICAgICAgICAgICAgdGhpcy5yZW5kZXIoX3JvdW5kUHJlY2lzZShjeWNsZUR1cmF0aW9uICogaXRlcmF0aW9uKSwgdHJ1ZSkuaW52YWxpZGF0ZSgpLl9sb2NrID0gMDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKCF0aGlzLl9pbml0dGVkKSB7XG4gICAgICAgIGlmIChfYXR0ZW1wdEluaXRUd2Vlbih0aGlzLCB0b3RhbFRpbWUgPCAwID8gdG90YWxUaW1lIDogdGltZSwgZm9yY2UsIHN1cHByZXNzRXZlbnRzKSkge1xuICAgICAgICAgIHRoaXMuX3RUaW1lID0gMDsgLy8gaW4gY29uc3RydWN0b3IgaWYgaW1tZWRpYXRlUmVuZGVyIGlzIHRydWUsIHdlIHNldCBfdFRpbWUgdG8gLV90aW55TnVtIHRvIGhhdmUgdGhlIHBsYXloZWFkIGNyb3NzIHRoZSBzdGFydGluZyBwb2ludCBidXQgd2UgY2FuJ3QgbGVhdmUgX3RUaW1lIGFzIGEgbmVnYXRpdmUgbnVtYmVyLlxuXG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocHJldlRpbWUgIT09IHRoaXMuX3RpbWUpIHtcbiAgICAgICAgICAvLyByYXJlIGVkZ2UgY2FzZSAtIGR1cmluZyBpbml0aWFsaXphdGlvbiwgYW4gb25VcGRhdGUgaW4gdGhlIF9zdGFydEF0ICguZnJvbVRvKCkpIG1pZ2h0IGZvcmNlIHRoaXMgdHdlZW4gdG8gcmVuZGVyIGF0IGEgZGlmZmVyZW50IHNwb3QgaW4gd2hpY2ggY2FzZSB3ZSBzaG91bGQgZGl0Y2ggdGhpcyByZW5kZXIoKSBjYWxsIHNvIHRoYXQgaXQgZG9lc24ndCByZXZlcnQgdGhlIHZhbHVlcy5cbiAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChkdXIgIT09IHRoaXMuX2R1cikge1xuICAgICAgICAgIC8vIHdoaWxlIGluaXR0aW5nLCBhIHBsdWdpbiBsaWtlIEluZXJ0aWFQbHVnaW4gbWlnaHQgYWx0ZXIgdGhlIGR1cmF0aW9uLCBzbyByZXJ1biBmcm9tIHRoZSBzdGFydCB0byBlbnN1cmUgZXZlcnl0aGluZyByZW5kZXJzIGFzIGl0IHNob3VsZC5cbiAgICAgICAgICByZXR1cm4gdGhpcy5yZW5kZXIodG90YWxUaW1lLCBzdXBwcmVzc0V2ZW50cywgZm9yY2UpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX3RUaW1lID0gdFRpbWU7XG4gICAgICB0aGlzLl90aW1lID0gdGltZTtcblxuICAgICAgaWYgKCF0aGlzLl9hY3QgJiYgdGhpcy5fdHMpIHtcbiAgICAgICAgdGhpcy5fYWN0ID0gMTsgLy9hcyBsb25nIGFzIGl0J3Mgbm90IHBhdXNlZCwgZm9yY2UgaXQgdG8gYmUgYWN0aXZlIHNvIHRoYXQgaWYgdGhlIHVzZXIgcmVuZGVycyBpbmRlcGVuZGVudCBvZiB0aGUgcGFyZW50IHRpbWVsaW5lLCBpdCdsbCBiZSBmb3JjZWQgdG8gcmUtcmVuZGVyIG9uIHRoZSBuZXh0IHRpY2suXG5cbiAgICAgICAgdGhpcy5fbGF6eSA9IDA7XG4gICAgICB9XG5cbiAgICAgIHRoaXMucmF0aW8gPSByYXRpbyA9ICh5b3lvRWFzZSB8fCB0aGlzLl9lYXNlKSh0aW1lIC8gZHVyKTtcblxuICAgICAgaWYgKHRoaXMuX2Zyb20pIHtcbiAgICAgICAgdGhpcy5yYXRpbyA9IHJhdGlvID0gMSAtIHJhdGlvO1xuICAgICAgfVxuXG4gICAgICBpZiAodGltZSAmJiAhcHJldlRpbWUgJiYgIXN1cHByZXNzRXZlbnRzKSB7XG4gICAgICAgIF9jYWxsYmFjayh0aGlzLCBcIm9uU3RhcnRcIik7XG5cbiAgICAgICAgaWYgKHRoaXMuX3RUaW1lICE9PSB0VGltZSkge1xuICAgICAgICAgIC8vIGluIGNhc2UgdGhlIG9uU3RhcnQgdHJpZ2dlcmVkIGEgcmVuZGVyIGF0IGEgZGlmZmVyZW50IHNwb3QsIGVqZWN0LiBMaWtlIGlmIHNvbWVvbmUgZGlkIGFuaW1hdGlvbi5wYXVzZSgwLjUpIG9yIHNvbWV0aGluZyBpbnNpZGUgdGhlIG9uU3RhcnQuXG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcHQgPSB0aGlzLl9wdDtcblxuICAgICAgd2hpbGUgKHB0KSB7XG4gICAgICAgIHB0LnIocmF0aW8sIHB0LmQpO1xuICAgICAgICBwdCA9IHB0Ll9uZXh0O1xuICAgICAgfVxuXG4gICAgICB0aW1lbGluZSAmJiB0aW1lbGluZS5yZW5kZXIodG90YWxUaW1lIDwgMCA/IHRvdGFsVGltZSA6ICF0aW1lICYmIGlzWW95byA/IC1fdGlueU51bSA6IHRpbWVsaW5lLl9kdXIgKiB0aW1lbGluZS5fZWFzZSh0aW1lIC8gdGhpcy5fZHVyKSwgc3VwcHJlc3NFdmVudHMsIGZvcmNlKSB8fCB0aGlzLl9zdGFydEF0ICYmICh0aGlzLl96VGltZSA9IHRvdGFsVGltZSk7XG5cbiAgICAgIGlmICh0aGlzLl9vblVwZGF0ZSAmJiAhc3VwcHJlc3NFdmVudHMpIHtcbiAgICAgICAgdG90YWxUaW1lIDwgMCAmJiB0aGlzLl9zdGFydEF0ICYmIHRoaXMuX3N0YXJ0QXQucmVuZGVyKHRvdGFsVGltZSwgdHJ1ZSwgZm9yY2UpOyAvL25vdGU6IGZvciBwZXJmb3JtYW5jZSByZWFzb25zLCB3ZSB0dWNrIHRoaXMgY29uZGl0aW9uYWwgbG9naWMgaW5zaWRlIGxlc3MgdHJhdmVsZWQgYXJlYXMgKG1vc3QgdHdlZW5zIGRvbid0IGhhdmUgYW4gb25VcGRhdGUpLiBXZSdkIGp1c3QgaGF2ZSBpdCBhdCB0aGUgZW5kIGJlZm9yZSB0aGUgb25Db21wbGV0ZSwgYnV0IHRoZSB2YWx1ZXMgc2hvdWxkIGJlIHVwZGF0ZWQgYmVmb3JlIGFueSBvblVwZGF0ZSBpcyBjYWxsZWQsIHNvIHdlIEFMU08gcHV0IGl0IGhlcmUgYW5kIHRoZW4gaWYgaXQncyBub3QgY2FsbGVkLCB3ZSBkbyBzbyBsYXRlciBuZWFyIHRoZSBvbkNvbXBsZXRlLlxuXG4gICAgICAgIF9jYWxsYmFjayh0aGlzLCBcIm9uVXBkYXRlXCIpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9yZXBlYXQgJiYgaXRlcmF0aW9uICE9PSBwcmV2SXRlcmF0aW9uICYmIHRoaXMudmFycy5vblJlcGVhdCAmJiAhc3VwcHJlc3NFdmVudHMgJiYgdGhpcy5wYXJlbnQgJiYgX2NhbGxiYWNrKHRoaXMsIFwib25SZXBlYXRcIik7XG5cbiAgICAgIGlmICgodFRpbWUgPT09IHRoaXMuX3REdXIgfHwgIXRUaW1lKSAmJiB0aGlzLl90VGltZSA9PT0gdFRpbWUpIHtcbiAgICAgICAgdG90YWxUaW1lIDwgMCAmJiB0aGlzLl9zdGFydEF0ICYmICF0aGlzLl9vblVwZGF0ZSAmJiB0aGlzLl9zdGFydEF0LnJlbmRlcih0b3RhbFRpbWUsIHRydWUsIHRydWUpO1xuICAgICAgICAodG90YWxUaW1lIHx8ICFkdXIpICYmICh0VGltZSA9PT0gdGhpcy5fdER1ciAmJiB0aGlzLl90cyA+IDAgfHwgIXRUaW1lICYmIHRoaXMuX3RzIDwgMCkgJiYgX3JlbW92ZUZyb21QYXJlbnQodGhpcywgMSk7IC8vIGRvbid0IHJlbW92ZSBpZiB3ZSdyZSByZW5kZXJpbmcgYXQgZXhhY3RseSBhIHRpbWUgb2YgMCwgYXMgdGhlcmUgY291bGQgYmUgYXV0b1JldmVydCB2YWx1ZXMgdGhhdCBzaG91bGQgZ2V0IHNldCBvbiB0aGUgbmV4dCB0aWNrIChpZiB0aGUgcGxheWhlYWQgZ29lcyBiYWNrd2FyZCBiZXlvbmQgdGhlIHN0YXJ0VGltZSwgbmVnYXRpdmUgdG90YWxUaW1lKS4gRG9uJ3QgcmVtb3ZlIGlmIHRoZSB0aW1lbGluZSBpcyByZXZlcnNlZCBhbmQgdGhlIHBsYXloZWFkIGlzbid0IGF0IDAsIG90aGVyd2lzZSB0bC5wcm9ncmVzcygxKS5yZXZlcnNlKCkgd29uJ3Qgd29yay4gT25seSByZW1vdmUgaWYgdGhlIHBsYXloZWFkIGlzIGF0IHRoZSBlbmQgYW5kIHRpbWVTY2FsZSBpcyBwb3NpdGl2ZSwgb3IgaWYgdGhlIHBsYXloZWFkIGlzIGF0IDAgYW5kIHRoZSB0aW1lU2NhbGUgaXMgbmVnYXRpdmUuXG5cbiAgICAgICAgaWYgKCFzdXBwcmVzc0V2ZW50cyAmJiAhKHRvdGFsVGltZSA8IDAgJiYgIXByZXZUaW1lKSAmJiAodFRpbWUgfHwgcHJldlRpbWUpKSB7XG4gICAgICAgICAgLy8gaWYgcHJldlRpbWUgYW5kIHRUaW1lIGFyZSB6ZXJvLCB3ZSBzaG91bGRuJ3QgZmlyZSB0aGUgb25SZXZlcnNlQ29tcGxldGUuIFRoaXMgY291bGQgaGFwcGVuIGlmIHlvdSBnc2FwLnRvKC4uLiB7cGF1c2VkOnRydWV9KS5wbGF5KCk7XG4gICAgICAgICAgX2NhbGxiYWNrKHRoaXMsIHRUaW1lID09PSB0RHVyID8gXCJvbkNvbXBsZXRlXCIgOiBcIm9uUmV2ZXJzZUNvbXBsZXRlXCIsIHRydWUpO1xuXG4gICAgICAgICAgdGhpcy5fcHJvbSAmJiAhKHRUaW1lIDwgdER1ciAmJiB0aGlzLnRpbWVTY2FsZSgpID4gMCkgJiYgdGhpcy5fcHJvbSgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgX3Byb3RvMy50YXJnZXRzID0gZnVuY3Rpb24gdGFyZ2V0cygpIHtcbiAgICByZXR1cm4gdGhpcy5fdGFyZ2V0cztcbiAgfTtcblxuICBfcHJvdG8zLmludmFsaWRhdGUgPSBmdW5jdGlvbiBpbnZhbGlkYXRlKCkge1xuICAgIHRoaXMuX3B0ID0gdGhpcy5fb3AgPSB0aGlzLl9zdGFydEF0ID0gdGhpcy5fb25VcGRhdGUgPSB0aGlzLl9sYXp5ID0gdGhpcy5yYXRpbyA9IDA7XG4gICAgdGhpcy5fcHRMb29rdXAgPSBbXTtcbiAgICB0aGlzLnRpbWVsaW5lICYmIHRoaXMudGltZWxpbmUuaW52YWxpZGF0ZSgpO1xuICAgIHJldHVybiBfQW5pbWF0aW9uMi5wcm90b3R5cGUuaW52YWxpZGF0ZS5jYWxsKHRoaXMpO1xuICB9O1xuXG4gIF9wcm90bzMucmVzZXRUbyA9IGZ1bmN0aW9uIHJlc2V0VG8ocHJvcGVydHksIHZhbHVlLCBzdGFydCwgc3RhcnRJc1JlbGF0aXZlKSB7XG4gICAgX3RpY2tlckFjdGl2ZSB8fCBfdGlja2VyLndha2UoKTtcbiAgICB0aGlzLl90cyB8fCB0aGlzLnBsYXkoKTtcbiAgICB2YXIgdGltZSA9IE1hdGgubWluKHRoaXMuX2R1ciwgKHRoaXMuX2RwLl90aW1lIC0gdGhpcy5fc3RhcnQpICogdGhpcy5fdHMpLFxuICAgICAgICByYXRpbztcbiAgICB0aGlzLl9pbml0dGVkIHx8IF9pbml0VHdlZW4odGhpcywgdGltZSk7XG4gICAgcmF0aW8gPSB0aGlzLl9lYXNlKHRpbWUgLyB0aGlzLl9kdXIpOyAvLyBkb24ndCBqdXN0IGdldCB0d2Vlbi5yYXRpbyBiZWNhdXNlIGl0IG1heSBub3QgaGF2ZSByZW5kZXJlZCB5ZXQuXG4gICAgLy8gcG9zc2libGUgZnV0dXJlIGFkZGl0aW9uIHRvIGFsbG93IGFuIG9iamVjdCB3aXRoIG11bHRpcGxlIHZhbHVlcyB0byB1cGRhdGUsIGxpa2UgdHdlZW4ucmVzZXRUbyh7eDogMTAwLCB5OiAyMDB9KTsgQXQgdGhpcyBwb2ludCwgaXQgZG9lc24ndCBzZWVtIHdvcnRoIHRoZSBhZGRlZCBrYiBnaXZlbiB0aGUgZmFjdCB0aGF0IG1vc3QgdXNlcnMgd2lsbCBsaWtlbHkgb3B0IGZvciB0aGUgY29udmVuaWVudCBnc2FwLnF1aWNrVG8oKSB3YXkgb2YgaW50ZXJhY3Rpbmcgd2l0aCB0aGlzIG1ldGhvZC5cbiAgICAvLyBpZiAoX2lzT2JqZWN0KHByb3BlcnR5KSkgeyAvLyBwZXJmb3JtYW5jZSBvcHRpbWl6YXRpb25cbiAgICAvLyBcdGZvciAocCBpbiBwcm9wZXJ0eSkge1xuICAgIC8vIFx0XHRpZiAoX3VwZGF0ZVByb3BUd2VlbnModGhpcywgcCwgcHJvcGVydHlbcF0sIHZhbHVlID8gdmFsdWVbcF0gOiBudWxsLCBzdGFydCwgcmF0aW8sIHRpbWUpKSB7XG4gICAgLy8gXHRcdFx0cmV0dXJuIHRoaXMucmVzZXRUbyhwcm9wZXJ0eSwgdmFsdWUsIHN0YXJ0LCBzdGFydElzUmVsYXRpdmUpOyAvLyBpZiBhIFByb3BUd2VlbiB3YXNuJ3QgZm91bmQgZm9yIHRoZSBwcm9wZXJ0eSwgaXQnbGwgZ2V0IGZvcmNlZCB3aXRoIGEgcmUtaW5pdGlhbGl6YXRpb24gc28gd2UgbmVlZCB0byBqdW1wIG91dCBhbmQgc3RhcnQgb3ZlciBhZ2Fpbi5cbiAgICAvLyBcdFx0fVxuICAgIC8vIFx0fVxuICAgIC8vIH0gZWxzZSB7XG5cbiAgICBpZiAoX3VwZGF0ZVByb3BUd2VlbnModGhpcywgcHJvcGVydHksIHZhbHVlLCBzdGFydCwgc3RhcnRJc1JlbGF0aXZlLCByYXRpbywgdGltZSkpIHtcbiAgICAgIHJldHVybiB0aGlzLnJlc2V0VG8ocHJvcGVydHksIHZhbHVlLCBzdGFydCwgc3RhcnRJc1JlbGF0aXZlKTsgLy8gaWYgYSBQcm9wVHdlZW4gd2Fzbid0IGZvdW5kIGZvciB0aGUgcHJvcGVydHksIGl0J2xsIGdldCBmb3JjZWQgd2l0aCBhIHJlLWluaXRpYWxpemF0aW9uIHNvIHdlIG5lZWQgdG8ganVtcCBvdXQgYW5kIHN0YXJ0IG92ZXIgYWdhaW4uXG4gICAgfSAvL31cblxuXG4gICAgX2FsaWduUGxheWhlYWQodGhpcywgMCk7XG5cbiAgICB0aGlzLnBhcmVudCB8fCBfYWRkTGlua2VkTGlzdEl0ZW0odGhpcy5fZHAsIHRoaXMsIFwiX2ZpcnN0XCIsIFwiX2xhc3RcIiwgdGhpcy5fZHAuX3NvcnQgPyBcIl9zdGFydFwiIDogMCk7XG4gICAgcmV0dXJuIHRoaXMucmVuZGVyKDApO1xuICB9O1xuXG4gIF9wcm90bzMua2lsbCA9IGZ1bmN0aW9uIGtpbGwodGFyZ2V0cywgdmFycykge1xuICAgIGlmICh2YXJzID09PSB2b2lkIDApIHtcbiAgICAgIHZhcnMgPSBcImFsbFwiO1xuICAgIH1cblxuICAgIGlmICghdGFyZ2V0cyAmJiAoIXZhcnMgfHwgdmFycyA9PT0gXCJhbGxcIikpIHtcbiAgICAgIHRoaXMuX2xhenkgPSB0aGlzLl9wdCA9IDA7XG4gICAgICByZXR1cm4gdGhpcy5wYXJlbnQgPyBfaW50ZXJydXB0KHRoaXMpIDogdGhpcztcbiAgICB9XG5cbiAgICBpZiAodGhpcy50aW1lbGluZSkge1xuICAgICAgdmFyIHREdXIgPSB0aGlzLnRpbWVsaW5lLnRvdGFsRHVyYXRpb24oKTtcbiAgICAgIHRoaXMudGltZWxpbmUua2lsbFR3ZWVuc09mKHRhcmdldHMsIHZhcnMsIF9vdmVyd3JpdGluZ1R3ZWVuICYmIF9vdmVyd3JpdGluZ1R3ZWVuLnZhcnMub3ZlcndyaXRlICE9PSB0cnVlKS5fZmlyc3QgfHwgX2ludGVycnVwdCh0aGlzKTsgLy8gaWYgbm90aGluZyBpcyBsZWZ0IHR3ZWVuaW5nLCBpbnRlcnJ1cHQuXG5cbiAgICAgIHRoaXMucGFyZW50ICYmIHREdXIgIT09IHRoaXMudGltZWxpbmUudG90YWxEdXJhdGlvbigpICYmIF9zZXREdXJhdGlvbih0aGlzLCB0aGlzLl9kdXIgKiB0aGlzLnRpbWVsaW5lLl90RHVyIC8gdER1ciwgMCwgMSk7IC8vIGlmIGEgbmVzdGVkIHR3ZWVuIGlzIGtpbGxlZCB0aGF0IGNoYW5nZXMgdGhlIGR1cmF0aW9uLCBpdCBzaG91bGQgYWZmZWN0IHRoaXMgdHdlZW4ncyBkdXJhdGlvbi4gV2UgbXVzdCB1c2UgdGhlIHJhdGlvLCB0aG91Z2gsIGJlY2F1c2Ugc29tZXRpbWVzIHRoZSBpbnRlcm5hbCB0aW1lbGluZSBpcyBzdHJldGNoZWQgbGlrZSBmb3Iga2V5ZnJhbWVzIHdoZXJlIHRoZXkgZG9uJ3QgYWxsIGFkZCB1cCB0byB3aGF0ZXZlciB0aGUgcGFyZW50IHR3ZWVuJ3MgZHVyYXRpb24gd2FzIHNldCB0by5cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgdmFyIHBhcnNlZFRhcmdldHMgPSB0aGlzLl90YXJnZXRzLFxuICAgICAgICBraWxsaW5nVGFyZ2V0cyA9IHRhcmdldHMgPyB0b0FycmF5KHRhcmdldHMpIDogcGFyc2VkVGFyZ2V0cyxcbiAgICAgICAgcHJvcFR3ZWVuTG9va3VwID0gdGhpcy5fcHRMb29rdXAsXG4gICAgICAgIGZpcnN0UFQgPSB0aGlzLl9wdCxcbiAgICAgICAgb3ZlcndyaXR0ZW5Qcm9wcyxcbiAgICAgICAgY3VyTG9va3VwLFxuICAgICAgICBjdXJPdmVyd3JpdGVQcm9wcyxcbiAgICAgICAgcHJvcHMsXG4gICAgICAgIHAsXG4gICAgICAgIHB0LFxuICAgICAgICBpO1xuXG4gICAgaWYgKCghdmFycyB8fCB2YXJzID09PSBcImFsbFwiKSAmJiBfYXJyYXlzTWF0Y2gocGFyc2VkVGFyZ2V0cywga2lsbGluZ1RhcmdldHMpKSB7XG4gICAgICB2YXJzID09PSBcImFsbFwiICYmICh0aGlzLl9wdCA9IDApO1xuICAgICAgcmV0dXJuIF9pbnRlcnJ1cHQodGhpcyk7XG4gICAgfVxuXG4gICAgb3ZlcndyaXR0ZW5Qcm9wcyA9IHRoaXMuX29wID0gdGhpcy5fb3AgfHwgW107XG5cbiAgICBpZiAodmFycyAhPT0gXCJhbGxcIikge1xuICAgICAgLy9zbyBwZW9wbGUgY2FuIHBhc3MgaW4gYSBjb21tYS1kZWxpbWl0ZWQgbGlzdCBvZiBwcm9wZXJ0eSBuYW1lc1xuICAgICAgaWYgKF9pc1N0cmluZyh2YXJzKSkge1xuICAgICAgICBwID0ge307XG5cbiAgICAgICAgX2ZvckVhY2hOYW1lKHZhcnMsIGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgICAgcmV0dXJuIHBbbmFtZV0gPSAxO1xuICAgICAgICB9KTtcblxuICAgICAgICB2YXJzID0gcDtcbiAgICAgIH1cblxuICAgICAgdmFycyA9IF9hZGRBbGlhc2VzVG9WYXJzKHBhcnNlZFRhcmdldHMsIHZhcnMpO1xuICAgIH1cblxuICAgIGkgPSBwYXJzZWRUYXJnZXRzLmxlbmd0aDtcblxuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIGlmICh+a2lsbGluZ1RhcmdldHMuaW5kZXhPZihwYXJzZWRUYXJnZXRzW2ldKSkge1xuICAgICAgICBjdXJMb29rdXAgPSBwcm9wVHdlZW5Mb29rdXBbaV07XG5cbiAgICAgICAgaWYgKHZhcnMgPT09IFwiYWxsXCIpIHtcbiAgICAgICAgICBvdmVyd3JpdHRlblByb3BzW2ldID0gdmFycztcbiAgICAgICAgICBwcm9wcyA9IGN1ckxvb2t1cDtcbiAgICAgICAgICBjdXJPdmVyd3JpdGVQcm9wcyA9IHt9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGN1ck92ZXJ3cml0ZVByb3BzID0gb3ZlcndyaXR0ZW5Qcm9wc1tpXSA9IG92ZXJ3cml0dGVuUHJvcHNbaV0gfHwge307XG4gICAgICAgICAgcHJvcHMgPSB2YXJzO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChwIGluIHByb3BzKSB7XG4gICAgICAgICAgcHQgPSBjdXJMb29rdXAgJiYgY3VyTG9va3VwW3BdO1xuXG4gICAgICAgICAgaWYgKHB0KSB7XG4gICAgICAgICAgICBpZiAoIShcImtpbGxcIiBpbiBwdC5kKSB8fCBwdC5kLmtpbGwocCkgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgX3JlbW92ZUxpbmtlZExpc3RJdGVtKHRoaXMsIHB0LCBcIl9wdFwiKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZGVsZXRlIGN1ckxvb2t1cFtwXTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoY3VyT3ZlcndyaXRlUHJvcHMgIT09IFwiYWxsXCIpIHtcbiAgICAgICAgICAgIGN1ck92ZXJ3cml0ZVByb3BzW3BdID0gMTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLl9pbml0dGVkICYmICF0aGlzLl9wdCAmJiBmaXJzdFBUICYmIF9pbnRlcnJ1cHQodGhpcyk7IC8vaWYgYWxsIHR3ZWVuaW5nIHByb3BlcnRpZXMgYXJlIGtpbGxlZCwga2lsbCB0aGUgdHdlZW4uIFdpdGhvdXQgdGhpcyBsaW5lLCBpZiB0aGVyZSdzIGEgdHdlZW4gd2l0aCBtdWx0aXBsZSB0YXJnZXRzIGFuZCB0aGVuIHlvdSBraWxsVHdlZW5zT2YoKSBlYWNoIHRhcmdldCBpbmRpdmlkdWFsbHksIHRoZSB0d2VlbiB3b3VsZCB0ZWNobmljYWxseSBzdGlsbCByZW1haW4gYWN0aXZlIGFuZCBmaXJlIGl0cyBvbkNvbXBsZXRlIGV2ZW4gdGhvdWdoIHRoZXJlIGFyZW4ndCBhbnkgbW9yZSBwcm9wZXJ0aWVzIHR3ZWVuaW5nLlxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgVHdlZW4udG8gPSBmdW5jdGlvbiB0byh0YXJnZXRzLCB2YXJzKSB7XG4gICAgcmV0dXJuIG5ldyBUd2Vlbih0YXJnZXRzLCB2YXJzLCBhcmd1bWVudHNbMl0pO1xuICB9O1xuXG4gIFR3ZWVuLmZyb20gPSBmdW5jdGlvbiBmcm9tKHRhcmdldHMsIHZhcnMpIHtcbiAgICByZXR1cm4gX2NyZWF0ZVR3ZWVuVHlwZSgxLCBhcmd1bWVudHMpO1xuICB9O1xuXG4gIFR3ZWVuLmRlbGF5ZWRDYWxsID0gZnVuY3Rpb24gZGVsYXllZENhbGwoZGVsYXksIGNhbGxiYWNrLCBwYXJhbXMsIHNjb3BlKSB7XG4gICAgcmV0dXJuIG5ldyBUd2VlbihjYWxsYmFjaywgMCwge1xuICAgICAgaW1tZWRpYXRlUmVuZGVyOiBmYWxzZSxcbiAgICAgIGxhenk6IGZhbHNlLFxuICAgICAgb3ZlcndyaXRlOiBmYWxzZSxcbiAgICAgIGRlbGF5OiBkZWxheSxcbiAgICAgIG9uQ29tcGxldGU6IGNhbGxiYWNrLFxuICAgICAgb25SZXZlcnNlQ29tcGxldGU6IGNhbGxiYWNrLFxuICAgICAgb25Db21wbGV0ZVBhcmFtczogcGFyYW1zLFxuICAgICAgb25SZXZlcnNlQ29tcGxldGVQYXJhbXM6IHBhcmFtcyxcbiAgICAgIGNhbGxiYWNrU2NvcGU6IHNjb3BlXG4gICAgfSk7XG4gIH07XG5cbiAgVHdlZW4uZnJvbVRvID0gZnVuY3Rpb24gZnJvbVRvKHRhcmdldHMsIGZyb21WYXJzLCB0b1ZhcnMpIHtcbiAgICByZXR1cm4gX2NyZWF0ZVR3ZWVuVHlwZSgyLCBhcmd1bWVudHMpO1xuICB9O1xuXG4gIFR3ZWVuLnNldCA9IGZ1bmN0aW9uIHNldCh0YXJnZXRzLCB2YXJzKSB7XG4gICAgdmFycy5kdXJhdGlvbiA9IDA7XG4gICAgdmFycy5yZXBlYXREZWxheSB8fCAodmFycy5yZXBlYXQgPSAwKTtcbiAgICByZXR1cm4gbmV3IFR3ZWVuKHRhcmdldHMsIHZhcnMpO1xuICB9O1xuXG4gIFR3ZWVuLmtpbGxUd2VlbnNPZiA9IGZ1bmN0aW9uIGtpbGxUd2VlbnNPZih0YXJnZXRzLCBwcm9wcywgb25seUFjdGl2ZSkge1xuICAgIHJldHVybiBfZ2xvYmFsVGltZWxpbmUua2lsbFR3ZWVuc09mKHRhcmdldHMsIHByb3BzLCBvbmx5QWN0aXZlKTtcbiAgfTtcblxuICByZXR1cm4gVHdlZW47XG59KEFuaW1hdGlvbik7XG5cbl9zZXREZWZhdWx0cyhUd2Vlbi5wcm90b3R5cGUsIHtcbiAgX3RhcmdldHM6IFtdLFxuICBfbGF6eTogMCxcbiAgX3N0YXJ0QXQ6IDAsXG4gIF9vcDogMCxcbiAgX29uSW5pdDogMFxufSk7IC8vYWRkIHRoZSBwZXJ0aW5lbnQgdGltZWxpbmUgbWV0aG9kcyB0byBUd2VlbiBpbnN0YW5jZXMgc28gdGhhdCB1c2VycyBjYW4gY2hhaW4gY29udmVuaWVudGx5IGFuZCBjcmVhdGUgYSB0aW1lbGluZSBhdXRvbWF0aWNhbGx5LiAocmVtb3ZlZCBkdWUgdG8gY29uY2VybnMgdGhhdCBpdCdkIHVsdGltYXRlbHkgYWRkIHRvIG1vcmUgY29uZnVzaW9uIGVzcGVjaWFsbHkgZm9yIGJlZ2lubmVycylcbi8vIF9mb3JFYWNoTmFtZShcInRvLGZyb20sZnJvbVRvLHNldCxjYWxsLGFkZCxhZGRMYWJlbCxhZGRQYXVzZVwiLCBuYW1lID0+IHtcbi8vIFx0VHdlZW4ucHJvdG90eXBlW25hbWVdID0gZnVuY3Rpb24oKSB7XG4vLyBcdFx0bGV0IHRsID0gbmV3IFRpbWVsaW5lKCk7XG4vLyBcdFx0cmV0dXJuIF9hZGRUb1RpbWVsaW5lKHRsLCB0aGlzKVtuYW1lXS5hcHBseSh0bCwgdG9BcnJheShhcmd1bWVudHMpKTtcbi8vIFx0fVxuLy8gfSk7XG4vL2ZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5LiBMZXZlcmFnZSB0aGUgdGltZWxpbmUgY2FsbHMuXG5cblxuX2ZvckVhY2hOYW1lKFwic3RhZ2dlclRvLHN0YWdnZXJGcm9tLHN0YWdnZXJGcm9tVG9cIiwgZnVuY3Rpb24gKG5hbWUpIHtcbiAgVHdlZW5bbmFtZV0gPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHRsID0gbmV3IFRpbWVsaW5lKCksXG4gICAgICAgIHBhcmFtcyA9IF9zbGljZS5jYWxsKGFyZ3VtZW50cywgMCk7XG5cbiAgICBwYXJhbXMuc3BsaWNlKG5hbWUgPT09IFwic3RhZ2dlckZyb21Ub1wiID8gNSA6IDQsIDAsIDApO1xuICAgIHJldHVybiB0bFtuYW1lXS5hcHBseSh0bCwgcGFyYW1zKTtcbiAgfTtcbn0pO1xuLypcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBQUk9QVFdFRU5cbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKi9cblxuXG52YXIgX3NldHRlclBsYWluID0gZnVuY3Rpb24gX3NldHRlclBsYWluKHRhcmdldCwgcHJvcGVydHksIHZhbHVlKSB7XG4gIHJldHVybiB0YXJnZXRbcHJvcGVydHldID0gdmFsdWU7XG59LFxuICAgIF9zZXR0ZXJGdW5jID0gZnVuY3Rpb24gX3NldHRlckZ1bmModGFyZ2V0LCBwcm9wZXJ0eSwgdmFsdWUpIHtcbiAgcmV0dXJuIHRhcmdldFtwcm9wZXJ0eV0odmFsdWUpO1xufSxcbiAgICBfc2V0dGVyRnVuY1dpdGhQYXJhbSA9IGZ1bmN0aW9uIF9zZXR0ZXJGdW5jV2l0aFBhcmFtKHRhcmdldCwgcHJvcGVydHksIHZhbHVlLCBkYXRhKSB7XG4gIHJldHVybiB0YXJnZXRbcHJvcGVydHldKGRhdGEuZnAsIHZhbHVlKTtcbn0sXG4gICAgX3NldHRlckF0dHJpYnV0ZSA9IGZ1bmN0aW9uIF9zZXR0ZXJBdHRyaWJ1dGUodGFyZ2V0LCBwcm9wZXJ0eSwgdmFsdWUpIHtcbiAgcmV0dXJuIHRhcmdldC5zZXRBdHRyaWJ1dGUocHJvcGVydHksIHZhbHVlKTtcbn0sXG4gICAgX2dldFNldHRlciA9IGZ1bmN0aW9uIF9nZXRTZXR0ZXIodGFyZ2V0LCBwcm9wZXJ0eSkge1xuICByZXR1cm4gX2lzRnVuY3Rpb24odGFyZ2V0W3Byb3BlcnR5XSkgPyBfc2V0dGVyRnVuYyA6IF9pc1VuZGVmaW5lZCh0YXJnZXRbcHJvcGVydHldKSAmJiB0YXJnZXQuc2V0QXR0cmlidXRlID8gX3NldHRlckF0dHJpYnV0ZSA6IF9zZXR0ZXJQbGFpbjtcbn0sXG4gICAgX3JlbmRlclBsYWluID0gZnVuY3Rpb24gX3JlbmRlclBsYWluKHJhdGlvLCBkYXRhKSB7XG4gIHJldHVybiBkYXRhLnNldChkYXRhLnQsIGRhdGEucCwgTWF0aC5yb3VuZCgoZGF0YS5zICsgZGF0YS5jICogcmF0aW8pICogMTAwMDAwMCkgLyAxMDAwMDAwLCBkYXRhKTtcbn0sXG4gICAgX3JlbmRlckJvb2xlYW4gPSBmdW5jdGlvbiBfcmVuZGVyQm9vbGVhbihyYXRpbywgZGF0YSkge1xuICByZXR1cm4gZGF0YS5zZXQoZGF0YS50LCBkYXRhLnAsICEhKGRhdGEucyArIGRhdGEuYyAqIHJhdGlvKSwgZGF0YSk7XG59LFxuICAgIF9yZW5kZXJDb21wbGV4U3RyaW5nID0gZnVuY3Rpb24gX3JlbmRlckNvbXBsZXhTdHJpbmcocmF0aW8sIGRhdGEpIHtcbiAgdmFyIHB0ID0gZGF0YS5fcHQsXG4gICAgICBzID0gXCJcIjtcblxuICBpZiAoIXJhdGlvICYmIGRhdGEuYikge1xuICAgIC8vYiA9IGJlZ2lubmluZyBzdHJpbmdcbiAgICBzID0gZGF0YS5iO1xuICB9IGVsc2UgaWYgKHJhdGlvID09PSAxICYmIGRhdGEuZSkge1xuICAgIC8vZSA9IGVuZGluZyBzdHJpbmdcbiAgICBzID0gZGF0YS5lO1xuICB9IGVsc2Uge1xuICAgIHdoaWxlIChwdCkge1xuICAgICAgcyA9IHB0LnAgKyAocHQubSA/IHB0Lm0ocHQucyArIHB0LmMgKiByYXRpbykgOiBNYXRoLnJvdW5kKChwdC5zICsgcHQuYyAqIHJhdGlvKSAqIDEwMDAwKSAvIDEwMDAwKSArIHM7IC8vd2UgdXNlIHRoZSBcInBcIiBwcm9wZXJ0eSBmb3IgdGhlIHRleHQgaW5iZXR3ZWVuIChsaWtlIGEgc3VmZml4KS4gQW5kIGluIHRoZSBjb250ZXh0IG9mIGEgY29tcGxleCBzdHJpbmcsIHRoZSBtb2RpZmllciAobSkgaXMgdHlwaWNhbGx5IGp1c3QgTWF0aC5yb3VuZCgpLCBsaWtlIGZvciBSR0IgY29sb3JzLlxuXG4gICAgICBwdCA9IHB0Ll9uZXh0O1xuICAgIH1cblxuICAgIHMgKz0gZGF0YS5jOyAvL3dlIHVzZSB0aGUgXCJjXCIgb2YgdGhlIFByb3BUd2VlbiB0byBzdG9yZSB0aGUgZmluYWwgY2h1bmsgb2Ygbm9uLW51bWVyaWMgdGV4dC5cbiAgfVxuXG4gIGRhdGEuc2V0KGRhdGEudCwgZGF0YS5wLCBzLCBkYXRhKTtcbn0sXG4gICAgX3JlbmRlclByb3BUd2VlbnMgPSBmdW5jdGlvbiBfcmVuZGVyUHJvcFR3ZWVucyhyYXRpbywgZGF0YSkge1xuICB2YXIgcHQgPSBkYXRhLl9wdDtcblxuICB3aGlsZSAocHQpIHtcbiAgICBwdC5yKHJhdGlvLCBwdC5kKTtcbiAgICBwdCA9IHB0Ll9uZXh0O1xuICB9XG59LFxuICAgIF9hZGRQbHVnaW5Nb2RpZmllciA9IGZ1bmN0aW9uIF9hZGRQbHVnaW5Nb2RpZmllcihtb2RpZmllciwgdHdlZW4sIHRhcmdldCwgcHJvcGVydHkpIHtcbiAgdmFyIHB0ID0gdGhpcy5fcHQsXG4gICAgICBuZXh0O1xuXG4gIHdoaWxlIChwdCkge1xuICAgIG5leHQgPSBwdC5fbmV4dDtcbiAgICBwdC5wID09PSBwcm9wZXJ0eSAmJiBwdC5tb2RpZmllcihtb2RpZmllciwgdHdlZW4sIHRhcmdldCk7XG4gICAgcHQgPSBuZXh0O1xuICB9XG59LFxuICAgIF9raWxsUHJvcFR3ZWVuc09mID0gZnVuY3Rpb24gX2tpbGxQcm9wVHdlZW5zT2YocHJvcGVydHkpIHtcbiAgdmFyIHB0ID0gdGhpcy5fcHQsXG4gICAgICBoYXNOb25EZXBlbmRlbnRSZW1haW5pbmcsXG4gICAgICBuZXh0O1xuXG4gIHdoaWxlIChwdCkge1xuICAgIG5leHQgPSBwdC5fbmV4dDtcblxuICAgIGlmIChwdC5wID09PSBwcm9wZXJ0eSAmJiAhcHQub3AgfHwgcHQub3AgPT09IHByb3BlcnR5KSB7XG4gICAgICBfcmVtb3ZlTGlua2VkTGlzdEl0ZW0odGhpcywgcHQsIFwiX3B0XCIpO1xuICAgIH0gZWxzZSBpZiAoIXB0LmRlcCkge1xuICAgICAgaGFzTm9uRGVwZW5kZW50UmVtYWluaW5nID0gMTtcbiAgICB9XG5cbiAgICBwdCA9IG5leHQ7XG4gIH1cblxuICByZXR1cm4gIWhhc05vbkRlcGVuZGVudFJlbWFpbmluZztcbn0sXG4gICAgX3NldHRlcldpdGhNb2RpZmllciA9IGZ1bmN0aW9uIF9zZXR0ZXJXaXRoTW9kaWZpZXIodGFyZ2V0LCBwcm9wZXJ0eSwgdmFsdWUsIGRhdGEpIHtcbiAgZGF0YS5tU2V0KHRhcmdldCwgcHJvcGVydHksIGRhdGEubS5jYWxsKGRhdGEudHdlZW4sIHZhbHVlLCBkYXRhLm10KSwgZGF0YSk7XG59LFxuICAgIF9zb3J0UHJvcFR3ZWVuc0J5UHJpb3JpdHkgPSBmdW5jdGlvbiBfc29ydFByb3BUd2VlbnNCeVByaW9yaXR5KHBhcmVudCkge1xuICB2YXIgcHQgPSBwYXJlbnQuX3B0LFxuICAgICAgbmV4dCxcbiAgICAgIHB0MixcbiAgICAgIGZpcnN0LFxuICAgICAgbGFzdDsgLy9zb3J0cyB0aGUgUHJvcFR3ZWVuIGxpbmtlZCBsaXN0IGluIG9yZGVyIG9mIHByaW9yaXR5IGJlY2F1c2Ugc29tZSBwbHVnaW5zIG5lZWQgdG8gZG8gdGhlaXIgd29yayBhZnRlciBBTEwgb2YgdGhlIFByb3BUd2VlbnMgd2VyZSBjcmVhdGVkIChsaWtlIFJvdW5kUHJvcHNQbHVnaW4gYW5kIE1vZGlmaWVyc1BsdWdpbilcblxuICB3aGlsZSAocHQpIHtcbiAgICBuZXh0ID0gcHQuX25leHQ7XG4gICAgcHQyID0gZmlyc3Q7XG5cbiAgICB3aGlsZSAocHQyICYmIHB0Mi5wciA+IHB0LnByKSB7XG4gICAgICBwdDIgPSBwdDIuX25leHQ7XG4gICAgfVxuXG4gICAgaWYgKHB0Ll9wcmV2ID0gcHQyID8gcHQyLl9wcmV2IDogbGFzdCkge1xuICAgICAgcHQuX3ByZXYuX25leHQgPSBwdDtcbiAgICB9IGVsc2Uge1xuICAgICAgZmlyc3QgPSBwdDtcbiAgICB9XG5cbiAgICBpZiAocHQuX25leHQgPSBwdDIpIHtcbiAgICAgIHB0Mi5fcHJldiA9IHB0O1xuICAgIH0gZWxzZSB7XG4gICAgICBsYXN0ID0gcHQ7XG4gICAgfVxuXG4gICAgcHQgPSBuZXh0O1xuICB9XG5cbiAgcGFyZW50Ll9wdCA9IGZpcnN0O1xufTsgLy9Qcm9wVHdlZW4ga2V5OiB0ID0gdGFyZ2V0LCBwID0gcHJvcCwgciA9IHJlbmRlcmVyLCBkID0gZGF0YSwgcyA9IHN0YXJ0LCBjID0gY2hhbmdlLCBvcCA9IG92ZXJ3cml0ZVByb3BlcnR5IChPTkxZIHBvcHVsYXRlZCB3aGVuIGl0J3MgZGlmZmVyZW50IHRoYW4gcCksIHByID0gcHJpb3JpdHksIF9uZXh0L19wcmV2IGZvciB0aGUgbGlua2VkIGxpc3Qgc2libGluZ3MsIHNldCA9IHNldHRlciwgbSA9IG1vZGlmaWVyLCBtU2V0ID0gbW9kaWZpZXJTZXR0ZXIgKHRoZSBvcmlnaW5hbCBzZXR0ZXIsIGJlZm9yZSBhIG1vZGlmaWVyIHdhcyBhZGRlZClcblxuXG5leHBvcnQgdmFyIFByb3BUd2VlbiA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFByb3BUd2VlbihuZXh0LCB0YXJnZXQsIHByb3AsIHN0YXJ0LCBjaGFuZ2UsIHJlbmRlcmVyLCBkYXRhLCBzZXR0ZXIsIHByaW9yaXR5KSB7XG4gICAgdGhpcy50ID0gdGFyZ2V0O1xuICAgIHRoaXMucyA9IHN0YXJ0O1xuICAgIHRoaXMuYyA9IGNoYW5nZTtcbiAgICB0aGlzLnAgPSBwcm9wO1xuICAgIHRoaXMuciA9IHJlbmRlcmVyIHx8IF9yZW5kZXJQbGFpbjtcbiAgICB0aGlzLmQgPSBkYXRhIHx8IHRoaXM7XG4gICAgdGhpcy5zZXQgPSBzZXR0ZXIgfHwgX3NldHRlclBsYWluO1xuICAgIHRoaXMucHIgPSBwcmlvcml0eSB8fCAwO1xuICAgIHRoaXMuX25leHQgPSBuZXh0O1xuXG4gICAgaWYgKG5leHQpIHtcbiAgICAgIG5leHQuX3ByZXYgPSB0aGlzO1xuICAgIH1cbiAgfVxuXG4gIHZhciBfcHJvdG80ID0gUHJvcFR3ZWVuLnByb3RvdHlwZTtcblxuICBfcHJvdG80Lm1vZGlmaWVyID0gZnVuY3Rpb24gbW9kaWZpZXIoZnVuYywgdHdlZW4sIHRhcmdldCkge1xuICAgIHRoaXMubVNldCA9IHRoaXMubVNldCB8fCB0aGlzLnNldDsgLy9pbiBjYXNlIGl0IHdhcyBhbHJlYWR5IHNldCAoYSBQcm9wVHdlZW4gY2FuIG9ubHkgaGF2ZSBvbmUgbW9kaWZpZXIpXG5cbiAgICB0aGlzLnNldCA9IF9zZXR0ZXJXaXRoTW9kaWZpZXI7XG4gICAgdGhpcy5tID0gZnVuYztcbiAgICB0aGlzLm10ID0gdGFyZ2V0OyAvL21vZGlmaWVyIHRhcmdldFxuXG4gICAgdGhpcy50d2VlbiA9IHR3ZWVuO1xuICB9O1xuXG4gIHJldHVybiBQcm9wVHdlZW47XG59KCk7IC8vSW5pdGlhbGl6YXRpb24gdGFza3NcblxuX2ZvckVhY2hOYW1lKF9jYWxsYmFja05hbWVzICsgXCJwYXJlbnQsZHVyYXRpb24sZWFzZSxkZWxheSxvdmVyd3JpdGUscnVuQmFja3dhcmRzLHN0YXJ0QXQseW95byxpbW1lZGlhdGVSZW5kZXIscmVwZWF0LHJlcGVhdERlbGF5LGRhdGEscGF1c2VkLHJldmVyc2VkLGxhenksY2FsbGJhY2tTY29wZSxzdHJpbmdGaWx0ZXIsaWQseW95b0Vhc2Usc3RhZ2dlcixpbmhlcml0LHJlcGVhdFJlZnJlc2gsa2V5ZnJhbWVzLGF1dG9SZXZlcnQsc2Nyb2xsVHJpZ2dlclwiLCBmdW5jdGlvbiAobmFtZSkge1xuICByZXR1cm4gX3Jlc2VydmVkUHJvcHNbbmFtZV0gPSAxO1xufSk7XG5cbl9nbG9iYWxzLlR3ZWVuTWF4ID0gX2dsb2JhbHMuVHdlZW5MaXRlID0gVHdlZW47XG5fZ2xvYmFscy5UaW1lbGluZUxpdGUgPSBfZ2xvYmFscy5UaW1lbGluZU1heCA9IFRpbWVsaW5lO1xuX2dsb2JhbFRpbWVsaW5lID0gbmV3IFRpbWVsaW5lKHtcbiAgc29ydENoaWxkcmVuOiBmYWxzZSxcbiAgZGVmYXVsdHM6IF9kZWZhdWx0cyxcbiAgYXV0b1JlbW92ZUNoaWxkcmVuOiB0cnVlLFxuICBpZDogXCJyb290XCIsXG4gIHNtb290aENoaWxkVGltaW5nOiB0cnVlXG59KTtcbl9jb25maWcuc3RyaW5nRmlsdGVyID0gX2NvbG9yU3RyaW5nRmlsdGVyO1xuLypcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBHU0FQXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICovXG5cbnZhciBfZ3NhcCA9IHtcbiAgcmVnaXN0ZXJQbHVnaW46IGZ1bmN0aW9uIHJlZ2lzdGVyUGx1Z2luKCkge1xuICAgIGZvciAodmFyIF9sZW4yID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuMiksIF9rZXkyID0gMDsgX2tleTIgPCBfbGVuMjsgX2tleTIrKykge1xuICAgICAgYXJnc1tfa2V5Ml0gPSBhcmd1bWVudHNbX2tleTJdO1xuICAgIH1cblxuICAgIGFyZ3MuZm9yRWFjaChmdW5jdGlvbiAoY29uZmlnKSB7XG4gICAgICByZXR1cm4gX2NyZWF0ZVBsdWdpbihjb25maWcpO1xuICAgIH0pO1xuICB9LFxuICB0aW1lbGluZTogZnVuY3Rpb24gdGltZWxpbmUodmFycykge1xuICAgIHJldHVybiBuZXcgVGltZWxpbmUodmFycyk7XG4gIH0sXG4gIGdldFR3ZWVuc09mOiBmdW5jdGlvbiBnZXRUd2VlbnNPZih0YXJnZXRzLCBvbmx5QWN0aXZlKSB7XG4gICAgcmV0dXJuIF9nbG9iYWxUaW1lbGluZS5nZXRUd2VlbnNPZih0YXJnZXRzLCBvbmx5QWN0aXZlKTtcbiAgfSxcbiAgZ2V0UHJvcGVydHk6IGZ1bmN0aW9uIGdldFByb3BlcnR5KHRhcmdldCwgcHJvcGVydHksIHVuaXQsIHVuY2FjaGUpIHtcbiAgICBfaXNTdHJpbmcodGFyZ2V0KSAmJiAodGFyZ2V0ID0gdG9BcnJheSh0YXJnZXQpWzBdKTsgLy9pbiBjYXNlIHNlbGVjdG9yIHRleHQgb3IgYW4gYXJyYXkgaXMgcGFzc2VkIGluXG5cbiAgICB2YXIgZ2V0dGVyID0gX2dldENhY2hlKHRhcmdldCB8fCB7fSkuZ2V0LFxuICAgICAgICBmb3JtYXQgPSB1bml0ID8gX3Bhc3NUaHJvdWdoIDogX251bWVyaWNJZlBvc3NpYmxlO1xuXG4gICAgdW5pdCA9PT0gXCJuYXRpdmVcIiAmJiAodW5pdCA9IFwiXCIpO1xuICAgIHJldHVybiAhdGFyZ2V0ID8gdGFyZ2V0IDogIXByb3BlcnR5ID8gZnVuY3Rpb24gKHByb3BlcnR5LCB1bml0LCB1bmNhY2hlKSB7XG4gICAgICByZXR1cm4gZm9ybWF0KChfcGx1Z2luc1twcm9wZXJ0eV0gJiYgX3BsdWdpbnNbcHJvcGVydHldLmdldCB8fCBnZXR0ZXIpKHRhcmdldCwgcHJvcGVydHksIHVuaXQsIHVuY2FjaGUpKTtcbiAgICB9IDogZm9ybWF0KChfcGx1Z2luc1twcm9wZXJ0eV0gJiYgX3BsdWdpbnNbcHJvcGVydHldLmdldCB8fCBnZXR0ZXIpKHRhcmdldCwgcHJvcGVydHksIHVuaXQsIHVuY2FjaGUpKTtcbiAgfSxcbiAgcXVpY2tTZXR0ZXI6IGZ1bmN0aW9uIHF1aWNrU2V0dGVyKHRhcmdldCwgcHJvcGVydHksIHVuaXQpIHtcbiAgICB0YXJnZXQgPSB0b0FycmF5KHRhcmdldCk7XG5cbiAgICBpZiAodGFyZ2V0Lmxlbmd0aCA+IDEpIHtcbiAgICAgIHZhciBzZXR0ZXJzID0gdGFyZ2V0Lm1hcChmdW5jdGlvbiAodCkge1xuICAgICAgICByZXR1cm4gZ3NhcC5xdWlja1NldHRlcih0LCBwcm9wZXJ0eSwgdW5pdCk7XG4gICAgICB9KSxcbiAgICAgICAgICBsID0gc2V0dGVycy5sZW5ndGg7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHZhciBpID0gbDtcblxuICAgICAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgICAgc2V0dGVyc1tpXSh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuXG4gICAgdGFyZ2V0ID0gdGFyZ2V0WzBdIHx8IHt9O1xuXG4gICAgdmFyIFBsdWdpbiA9IF9wbHVnaW5zW3Byb3BlcnR5XSxcbiAgICAgICAgY2FjaGUgPSBfZ2V0Q2FjaGUodGFyZ2V0KSxcbiAgICAgICAgcCA9IGNhY2hlLmhhcm5lc3MgJiYgKGNhY2hlLmhhcm5lc3MuYWxpYXNlcyB8fCB7fSlbcHJvcGVydHldIHx8IHByb3BlcnR5LFxuICAgICAgICAvLyBpbiBjYXNlIGl0J3MgYW4gYWxpYXMsIGxpa2UgXCJyb3RhdGVcIiBmb3IgXCJyb3RhdGlvblwiLlxuICAgIHNldHRlciA9IFBsdWdpbiA/IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgdmFyIHAgPSBuZXcgUGx1Z2luKCk7XG4gICAgICBfcXVpY2tUd2Vlbi5fcHQgPSAwO1xuICAgICAgcC5pbml0KHRhcmdldCwgdW5pdCA/IHZhbHVlICsgdW5pdCA6IHZhbHVlLCBfcXVpY2tUd2VlbiwgMCwgW3RhcmdldF0pO1xuICAgICAgcC5yZW5kZXIoMSwgcCk7XG4gICAgICBfcXVpY2tUd2Vlbi5fcHQgJiYgX3JlbmRlclByb3BUd2VlbnMoMSwgX3F1aWNrVHdlZW4pO1xuICAgIH0gOiBjYWNoZS5zZXQodGFyZ2V0LCBwKTtcblxuICAgIHJldHVybiBQbHVnaW4gPyBzZXR0ZXIgOiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgIHJldHVybiBzZXR0ZXIodGFyZ2V0LCBwLCB1bml0ID8gdmFsdWUgKyB1bml0IDogdmFsdWUsIGNhY2hlLCAxKTtcbiAgICB9O1xuICB9LFxuICBxdWlja1RvOiBmdW5jdGlvbiBxdWlja1RvKHRhcmdldCwgcHJvcGVydHksIHZhcnMpIHtcbiAgICB2YXIgX21lcmdlMjtcblxuICAgIHZhciB0d2VlbiA9IGdzYXAudG8odGFyZ2V0LCBfbWVyZ2UoKF9tZXJnZTIgPSB7fSwgX21lcmdlMltwcm9wZXJ0eV0gPSBcIis9MC4xXCIsIF9tZXJnZTIucGF1c2VkID0gdHJ1ZSwgX21lcmdlMiksIHZhcnMgfHwge30pKSxcbiAgICAgICAgZnVuYyA9IGZ1bmN0aW9uIGZ1bmModmFsdWUsIHN0YXJ0LCBzdGFydElzUmVsYXRpdmUpIHtcbiAgICAgIHJldHVybiB0d2Vlbi5yZXNldFRvKHByb3BlcnR5LCB2YWx1ZSwgc3RhcnQsIHN0YXJ0SXNSZWxhdGl2ZSk7XG4gICAgfTtcblxuICAgIGZ1bmMudHdlZW4gPSB0d2VlbjtcbiAgICByZXR1cm4gZnVuYztcbiAgfSxcbiAgaXNUd2VlbmluZzogZnVuY3Rpb24gaXNUd2VlbmluZyh0YXJnZXRzKSB7XG4gICAgcmV0dXJuIF9nbG9iYWxUaW1lbGluZS5nZXRUd2VlbnNPZih0YXJnZXRzLCB0cnVlKS5sZW5ndGggPiAwO1xuICB9LFxuICBkZWZhdWx0czogZnVuY3Rpb24gZGVmYXVsdHModmFsdWUpIHtcbiAgICB2YWx1ZSAmJiB2YWx1ZS5lYXNlICYmICh2YWx1ZS5lYXNlID0gX3BhcnNlRWFzZSh2YWx1ZS5lYXNlLCBfZGVmYXVsdHMuZWFzZSkpO1xuICAgIHJldHVybiBfbWVyZ2VEZWVwKF9kZWZhdWx0cywgdmFsdWUgfHwge30pO1xuICB9LFxuICBjb25maWc6IGZ1bmN0aW9uIGNvbmZpZyh2YWx1ZSkge1xuICAgIHJldHVybiBfbWVyZ2VEZWVwKF9jb25maWcsIHZhbHVlIHx8IHt9KTtcbiAgfSxcbiAgcmVnaXN0ZXJFZmZlY3Q6IGZ1bmN0aW9uIHJlZ2lzdGVyRWZmZWN0KF9yZWYzKSB7XG4gICAgdmFyIG5hbWUgPSBfcmVmMy5uYW1lLFxuICAgICAgICBlZmZlY3QgPSBfcmVmMy5lZmZlY3QsXG4gICAgICAgIHBsdWdpbnMgPSBfcmVmMy5wbHVnaW5zLFxuICAgICAgICBkZWZhdWx0cyA9IF9yZWYzLmRlZmF1bHRzLFxuICAgICAgICBleHRlbmRUaW1lbGluZSA9IF9yZWYzLmV4dGVuZFRpbWVsaW5lO1xuICAgIChwbHVnaW5zIHx8IFwiXCIpLnNwbGl0KFwiLFwiKS5mb3JFYWNoKGZ1bmN0aW9uIChwbHVnaW5OYW1lKSB7XG4gICAgICByZXR1cm4gcGx1Z2luTmFtZSAmJiAhX3BsdWdpbnNbcGx1Z2luTmFtZV0gJiYgIV9nbG9iYWxzW3BsdWdpbk5hbWVdICYmIF93YXJuKG5hbWUgKyBcIiBlZmZlY3QgcmVxdWlyZXMgXCIgKyBwbHVnaW5OYW1lICsgXCIgcGx1Z2luLlwiKTtcbiAgICB9KTtcblxuICAgIF9lZmZlY3RzW25hbWVdID0gZnVuY3Rpb24gKHRhcmdldHMsIHZhcnMsIHRsKSB7XG4gICAgICByZXR1cm4gZWZmZWN0KHRvQXJyYXkodGFyZ2V0cyksIF9zZXREZWZhdWx0cyh2YXJzIHx8IHt9LCBkZWZhdWx0cyksIHRsKTtcbiAgICB9O1xuXG4gICAgaWYgKGV4dGVuZFRpbWVsaW5lKSB7XG4gICAgICBUaW1lbGluZS5wcm90b3R5cGVbbmFtZV0gPSBmdW5jdGlvbiAodGFyZ2V0cywgdmFycywgcG9zaXRpb24pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYWRkKF9lZmZlY3RzW25hbWVdKHRhcmdldHMsIF9pc09iamVjdCh2YXJzKSA/IHZhcnMgOiAocG9zaXRpb24gPSB2YXJzKSAmJiB7fSwgdGhpcyksIHBvc2l0aW9uKTtcbiAgICAgIH07XG4gICAgfVxuICB9LFxuICByZWdpc3RlckVhc2U6IGZ1bmN0aW9uIHJlZ2lzdGVyRWFzZShuYW1lLCBlYXNlKSB7XG4gICAgX2Vhc2VNYXBbbmFtZV0gPSBfcGFyc2VFYXNlKGVhc2UpO1xuICB9LFxuICBwYXJzZUVhc2U6IGZ1bmN0aW9uIHBhcnNlRWFzZShlYXNlLCBkZWZhdWx0RWFzZSkge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gX3BhcnNlRWFzZShlYXNlLCBkZWZhdWx0RWFzZSkgOiBfZWFzZU1hcDtcbiAgfSxcbiAgZ2V0QnlJZDogZnVuY3Rpb24gZ2V0QnlJZChpZCkge1xuICAgIHJldHVybiBfZ2xvYmFsVGltZWxpbmUuZ2V0QnlJZChpZCk7XG4gIH0sXG4gIGV4cG9ydFJvb3Q6IGZ1bmN0aW9uIGV4cG9ydFJvb3QodmFycywgaW5jbHVkZURlbGF5ZWRDYWxscykge1xuICAgIGlmICh2YXJzID09PSB2b2lkIDApIHtcbiAgICAgIHZhcnMgPSB7fTtcbiAgICB9XG5cbiAgICB2YXIgdGwgPSBuZXcgVGltZWxpbmUodmFycyksXG4gICAgICAgIGNoaWxkLFxuICAgICAgICBuZXh0O1xuICAgIHRsLnNtb290aENoaWxkVGltaW5nID0gX2lzTm90RmFsc2UodmFycy5zbW9vdGhDaGlsZFRpbWluZyk7XG5cbiAgICBfZ2xvYmFsVGltZWxpbmUucmVtb3ZlKHRsKTtcblxuICAgIHRsLl9kcCA9IDA7IC8vb3RoZXJ3aXNlIGl0J2xsIGdldCByZS1hY3RpdmF0ZWQgd2hlbiBhZGRpbmcgY2hpbGRyZW4gYW5kIGJlIHJlLWludHJvZHVjZWQgaW50byBfZ2xvYmFsVGltZWxpbmUncyBsaW5rZWQgbGlzdCAodGhlbiBhZGRlZCB0byBpdHNlbGYpLlxuXG4gICAgdGwuX3RpbWUgPSB0bC5fdFRpbWUgPSBfZ2xvYmFsVGltZWxpbmUuX3RpbWU7XG4gICAgY2hpbGQgPSBfZ2xvYmFsVGltZWxpbmUuX2ZpcnN0O1xuXG4gICAgd2hpbGUgKGNoaWxkKSB7XG4gICAgICBuZXh0ID0gY2hpbGQuX25leHQ7XG5cbiAgICAgIGlmIChpbmNsdWRlRGVsYXllZENhbGxzIHx8ICEoIWNoaWxkLl9kdXIgJiYgY2hpbGQgaW5zdGFuY2VvZiBUd2VlbiAmJiBjaGlsZC52YXJzLm9uQ29tcGxldGUgPT09IGNoaWxkLl90YXJnZXRzWzBdKSkge1xuICAgICAgICBfYWRkVG9UaW1lbGluZSh0bCwgY2hpbGQsIGNoaWxkLl9zdGFydCAtIGNoaWxkLl9kZWxheSk7XG4gICAgICB9XG5cbiAgICAgIGNoaWxkID0gbmV4dDtcbiAgICB9XG5cbiAgICBfYWRkVG9UaW1lbGluZShfZ2xvYmFsVGltZWxpbmUsIHRsLCAwKTtcblxuICAgIHJldHVybiB0bDtcbiAgfSxcbiAgdXRpbHM6IHtcbiAgICB3cmFwOiB3cmFwLFxuICAgIHdyYXBZb3lvOiB3cmFwWW95byxcbiAgICBkaXN0cmlidXRlOiBkaXN0cmlidXRlLFxuICAgIHJhbmRvbTogcmFuZG9tLFxuICAgIHNuYXA6IHNuYXAsXG4gICAgbm9ybWFsaXplOiBub3JtYWxpemUsXG4gICAgZ2V0VW5pdDogZ2V0VW5pdCxcbiAgICBjbGFtcDogY2xhbXAsXG4gICAgc3BsaXRDb2xvcjogc3BsaXRDb2xvcixcbiAgICB0b0FycmF5OiB0b0FycmF5LFxuICAgIHNlbGVjdG9yOiBzZWxlY3RvcixcbiAgICBtYXBSYW5nZTogbWFwUmFuZ2UsXG4gICAgcGlwZTogcGlwZSxcbiAgICB1bml0aXplOiB1bml0aXplLFxuICAgIGludGVycG9sYXRlOiBpbnRlcnBvbGF0ZSxcbiAgICBzaHVmZmxlOiBzaHVmZmxlXG4gIH0sXG4gIGluc3RhbGw6IF9pbnN0YWxsLFxuICBlZmZlY3RzOiBfZWZmZWN0cyxcbiAgdGlja2VyOiBfdGlja2VyLFxuICB1cGRhdGVSb290OiBUaW1lbGluZS51cGRhdGVSb290LFxuICBwbHVnaW5zOiBfcGx1Z2lucyxcbiAgZ2xvYmFsVGltZWxpbmU6IF9nbG9iYWxUaW1lbGluZSxcbiAgY29yZToge1xuICAgIFByb3BUd2VlbjogUHJvcFR3ZWVuLFxuICAgIGdsb2JhbHM6IF9hZGRHbG9iYWwsXG4gICAgVHdlZW46IFR3ZWVuLFxuICAgIFRpbWVsaW5lOiBUaW1lbGluZSxcbiAgICBBbmltYXRpb246IEFuaW1hdGlvbixcbiAgICBnZXRDYWNoZTogX2dldENhY2hlLFxuICAgIF9yZW1vdmVMaW5rZWRMaXN0SXRlbTogX3JlbW92ZUxpbmtlZExpc3RJdGVtLFxuICAgIHN1cHByZXNzT3ZlcndyaXRlczogZnVuY3Rpb24gc3VwcHJlc3NPdmVyd3JpdGVzKHZhbHVlKSB7XG4gICAgICByZXR1cm4gX3N1cHByZXNzT3ZlcndyaXRlcyA9IHZhbHVlO1xuICAgIH1cbiAgfVxufTtcblxuX2ZvckVhY2hOYW1lKFwidG8sZnJvbSxmcm9tVG8sZGVsYXllZENhbGwsc2V0LGtpbGxUd2VlbnNPZlwiLCBmdW5jdGlvbiAobmFtZSkge1xuICByZXR1cm4gX2dzYXBbbmFtZV0gPSBUd2VlbltuYW1lXTtcbn0pO1xuXG5fdGlja2VyLmFkZChUaW1lbGluZS51cGRhdGVSb290KTtcblxuX3F1aWNrVHdlZW4gPSBfZ3NhcC50byh7fSwge1xuICBkdXJhdGlvbjogMFxufSk7IC8vIC0tLS0gRVhUUkEgUExVR0lOUyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG52YXIgX2dldFBsdWdpblByb3BUd2VlbiA9IGZ1bmN0aW9uIF9nZXRQbHVnaW5Qcm9wVHdlZW4ocGx1Z2luLCBwcm9wKSB7XG4gIHZhciBwdCA9IHBsdWdpbi5fcHQ7XG5cbiAgd2hpbGUgKHB0ICYmIHB0LnAgIT09IHByb3AgJiYgcHQub3AgIT09IHByb3AgJiYgcHQuZnAgIT09IHByb3ApIHtcbiAgICBwdCA9IHB0Ll9uZXh0O1xuICB9XG5cbiAgcmV0dXJuIHB0O1xufSxcbiAgICBfYWRkTW9kaWZpZXJzID0gZnVuY3Rpb24gX2FkZE1vZGlmaWVycyh0d2VlbiwgbW9kaWZpZXJzKSB7XG4gIHZhciB0YXJnZXRzID0gdHdlZW4uX3RhcmdldHMsXG4gICAgICBwLFxuICAgICAgaSxcbiAgICAgIHB0O1xuXG4gIGZvciAocCBpbiBtb2RpZmllcnMpIHtcbiAgICBpID0gdGFyZ2V0cy5sZW5ndGg7XG5cbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICBwdCA9IHR3ZWVuLl9wdExvb2t1cFtpXVtwXTtcblxuICAgICAgaWYgKHB0ICYmIChwdCA9IHB0LmQpKSB7XG4gICAgICAgIGlmIChwdC5fcHQpIHtcbiAgICAgICAgICAvLyBpcyBhIHBsdWdpblxuICAgICAgICAgIHB0ID0gX2dldFBsdWdpblByb3BUd2VlbihwdCwgcCk7XG4gICAgICAgIH1cblxuICAgICAgICBwdCAmJiBwdC5tb2RpZmllciAmJiBwdC5tb2RpZmllcihtb2RpZmllcnNbcF0sIHR3ZWVuLCB0YXJnZXRzW2ldLCBwKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn0sXG4gICAgX2J1aWxkTW9kaWZpZXJQbHVnaW4gPSBmdW5jdGlvbiBfYnVpbGRNb2RpZmllclBsdWdpbihuYW1lLCBtb2RpZmllcikge1xuICByZXR1cm4ge1xuICAgIG5hbWU6IG5hbWUsXG4gICAgcmF3VmFyczogMSxcbiAgICAvL2Rvbid0IHByZS1wcm9jZXNzIGZ1bmN0aW9uLWJhc2VkIHZhbHVlcyBvciBcInJhbmRvbSgpXCIgc3RyaW5ncy5cbiAgICBpbml0OiBmdW5jdGlvbiBpbml0KHRhcmdldCwgdmFycywgdHdlZW4pIHtcbiAgICAgIHR3ZWVuLl9vbkluaXQgPSBmdW5jdGlvbiAodHdlZW4pIHtcbiAgICAgICAgdmFyIHRlbXAsIHA7XG5cbiAgICAgICAgaWYgKF9pc1N0cmluZyh2YXJzKSkge1xuICAgICAgICAgIHRlbXAgPSB7fTtcblxuICAgICAgICAgIF9mb3JFYWNoTmFtZSh2YXJzLCBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRlbXBbbmFtZV0gPSAxO1xuICAgICAgICAgIH0pOyAvL2lmIHRoZSB1c2VyIHBhc3NlcyBpbiBhIGNvbW1hLWRlbGltaXRlZCBsaXN0IG9mIHByb3BlcnR5IG5hbWVzIHRvIHJvdW5kUHJvcHMsIGxpa2UgXCJ4LHlcIiwgd2Ugcm91bmQgdG8gd2hvbGUgbnVtYmVycy5cblxuXG4gICAgICAgICAgdmFycyA9IHRlbXA7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobW9kaWZpZXIpIHtcbiAgICAgICAgICB0ZW1wID0ge307XG5cbiAgICAgICAgICBmb3IgKHAgaW4gdmFycykge1xuICAgICAgICAgICAgdGVtcFtwXSA9IG1vZGlmaWVyKHZhcnNbcF0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhcnMgPSB0ZW1wO1xuICAgICAgICB9XG5cbiAgICAgICAgX2FkZE1vZGlmaWVycyh0d2VlbiwgdmFycyk7XG4gICAgICB9O1xuICAgIH1cbiAgfTtcbn07IC8vcmVnaXN0ZXIgY29yZSBwbHVnaW5zXG5cblxuZXhwb3J0IHZhciBnc2FwID0gX2dzYXAucmVnaXN0ZXJQbHVnaW4oe1xuICBuYW1lOiBcImF0dHJcIixcbiAgaW5pdDogZnVuY3Rpb24gaW5pdCh0YXJnZXQsIHZhcnMsIHR3ZWVuLCBpbmRleCwgdGFyZ2V0cykge1xuICAgIHZhciBwLCBwdDtcblxuICAgIGZvciAocCBpbiB2YXJzKSB7XG4gICAgICBwdCA9IHRoaXMuYWRkKHRhcmdldCwgXCJzZXRBdHRyaWJ1dGVcIiwgKHRhcmdldC5nZXRBdHRyaWJ1dGUocCkgfHwgMCkgKyBcIlwiLCB2YXJzW3BdLCBpbmRleCwgdGFyZ2V0cywgMCwgMCwgcCk7XG4gICAgICBwdCAmJiAocHQub3AgPSBwKTtcblxuICAgICAgdGhpcy5fcHJvcHMucHVzaChwKTtcbiAgICB9XG4gIH1cbn0sIHtcbiAgbmFtZTogXCJlbmRBcnJheVwiLFxuICBpbml0OiBmdW5jdGlvbiBpbml0KHRhcmdldCwgdmFsdWUpIHtcbiAgICB2YXIgaSA9IHZhbHVlLmxlbmd0aDtcblxuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIHRoaXMuYWRkKHRhcmdldCwgaSwgdGFyZ2V0W2ldIHx8IDAsIHZhbHVlW2ldKTtcbiAgICB9XG4gIH1cbn0sIF9idWlsZE1vZGlmaWVyUGx1Z2luKFwicm91bmRQcm9wc1wiLCBfcm91bmRNb2RpZmllciksIF9idWlsZE1vZGlmaWVyUGx1Z2luKFwibW9kaWZpZXJzXCIpLCBfYnVpbGRNb2RpZmllclBsdWdpbihcInNuYXBcIiwgc25hcCkpIHx8IF9nc2FwOyAvL3RvIHByZXZlbnQgdGhlIGNvcmUgcGx1Z2lucyBmcm9tIGJlaW5nIGRyb3BwZWQgdmlhIGFnZ3Jlc3NpdmUgdHJlZSBzaGFraW5nLCB3ZSBtdXN0IGluY2x1ZGUgdGhlbSBpbiB0aGUgdmFyaWFibGUgZGVjbGFyYXRpb24gaW4gdGhpcyB3YXkuXG5cblR3ZWVuLnZlcnNpb24gPSBUaW1lbGluZS52ZXJzaW9uID0gZ3NhcC52ZXJzaW9uID0gXCIzLjEwLjRcIjtcbl9jb3JlUmVhZHkgPSAxO1xuX3dpbmRvd0V4aXN0cygpICYmIF93YWtlKCk7XG52YXIgUG93ZXIwID0gX2Vhc2VNYXAuUG93ZXIwLFxuICAgIFBvd2VyMSA9IF9lYXNlTWFwLlBvd2VyMSxcbiAgICBQb3dlcjIgPSBfZWFzZU1hcC5Qb3dlcjIsXG4gICAgUG93ZXIzID0gX2Vhc2VNYXAuUG93ZXIzLFxuICAgIFBvd2VyNCA9IF9lYXNlTWFwLlBvd2VyNCxcbiAgICBMaW5lYXIgPSBfZWFzZU1hcC5MaW5lYXIsXG4gICAgUXVhZCA9IF9lYXNlTWFwLlF1YWQsXG4gICAgQ3ViaWMgPSBfZWFzZU1hcC5DdWJpYyxcbiAgICBRdWFydCA9IF9lYXNlTWFwLlF1YXJ0LFxuICAgIFF1aW50ID0gX2Vhc2VNYXAuUXVpbnQsXG4gICAgU3Ryb25nID0gX2Vhc2VNYXAuU3Ryb25nLFxuICAgIEVsYXN0aWMgPSBfZWFzZU1hcC5FbGFzdGljLFxuICAgIEJhY2sgPSBfZWFzZU1hcC5CYWNrLFxuICAgIFN0ZXBwZWRFYXNlID0gX2Vhc2VNYXAuU3RlcHBlZEVhc2UsXG4gICAgQm91bmNlID0gX2Vhc2VNYXAuQm91bmNlLFxuICAgIFNpbmUgPSBfZWFzZU1hcC5TaW5lLFxuICAgIEV4cG8gPSBfZWFzZU1hcC5FeHBvLFxuICAgIENpcmMgPSBfZWFzZU1hcC5DaXJjO1xuZXhwb3J0IHsgUG93ZXIwLCBQb3dlcjEsIFBvd2VyMiwgUG93ZXIzLCBQb3dlcjQsIExpbmVhciwgUXVhZCwgQ3ViaWMsIFF1YXJ0LCBRdWludCwgU3Ryb25nLCBFbGFzdGljLCBCYWNrLCBTdGVwcGVkRWFzZSwgQm91bmNlLCBTaW5lLCBFeHBvLCBDaXJjIH07XG5leHBvcnQgeyBUd2VlbiBhcyBUd2Vlbk1heCwgVHdlZW4gYXMgVHdlZW5MaXRlLCBUaW1lbGluZSBhcyBUaW1lbGluZU1heCwgVGltZWxpbmUgYXMgVGltZWxpbmVMaXRlLCBnc2FwIGFzIGRlZmF1bHQsIHdyYXAsIHdyYXBZb3lvLCBkaXN0cmlidXRlLCByYW5kb20sIHNuYXAsIG5vcm1hbGl6ZSwgZ2V0VW5pdCwgY2xhbXAsIHNwbGl0Q29sb3IsIHRvQXJyYXksIHNlbGVjdG9yLCBtYXBSYW5nZSwgcGlwZSwgdW5pdGl6ZSwgaW50ZXJwb2xhdGUsIHNodWZmbGUgfTsgLy9leHBvcnQgc29tZSBpbnRlcm5hbCBtZXRob2RzL29yb2plY3RzIGZvciB1c2UgaW4gQ1NTUGx1Z2luIHNvIHRoYXQgd2UgY2FuIGV4dGVybmFsaXplIHRoYXQgZmlsZSBhbmQgYWxsb3cgY3VzdG9tIGJ1aWxkcyB0aGF0IGV4Y2x1ZGUgaXQuXG5cbmV4cG9ydCB7IF9nZXRQcm9wZXJ0eSwgX251bUV4cCwgX251bVdpdGhVbml0RXhwLCBfaXNTdHJpbmcsIF9pc1VuZGVmaW5lZCwgX3JlbmRlckNvbXBsZXhTdHJpbmcsIF9yZWxFeHAsIF9zZXREZWZhdWx0cywgX3JlbW92ZUxpbmtlZExpc3RJdGVtLCBfZm9yRWFjaE5hbWUsIF9zb3J0UHJvcFR3ZWVuc0J5UHJpb3JpdHksIF9jb2xvclN0cmluZ0ZpbHRlciwgX3JlcGxhY2VSYW5kb20sIF9jaGVja1BsdWdpbiwgX3BsdWdpbnMsIF90aWNrZXIsIF9jb25maWcsIF9yb3VuZE1vZGlmaWVyLCBfcm91bmQsIF9taXNzaW5nUGx1Z2luLCBfZ2V0U2V0dGVyLCBfZ2V0Q2FjaGUsIF9jb2xvckV4cCwgX3BhcnNlUmVsYXRpdmUgfTsiLCIvKiFcbiAqIENTU1BsdWdpbiAzLjEwLjRcbiAqIGh0dHBzOi8vZ3JlZW5zb2NrLmNvbVxuICpcbiAqIENvcHlyaWdodCAyMDA4LTIwMjIsIEdyZWVuU29jay4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFN1YmplY3QgdG8gdGhlIHRlcm1zIGF0IGh0dHBzOi8vZ3JlZW5zb2NrLmNvbS9zdGFuZGFyZC1saWNlbnNlIG9yIGZvclxuICogQ2x1YiBHcmVlblNvY2sgbWVtYmVycywgdGhlIGFncmVlbWVudCBpc3N1ZWQgd2l0aCB0aGF0IG1lbWJlcnNoaXAuXG4gKiBAYXV0aG9yOiBKYWNrIERveWxlLCBqYWNrQGdyZWVuc29jay5jb21cbiovXG5cbi8qIGVzbGludC1kaXNhYmxlICovXG5pbXBvcnQgeyBnc2FwLCBfZ2V0UHJvcGVydHksIF9udW1FeHAsIF9udW1XaXRoVW5pdEV4cCwgZ2V0VW5pdCwgX2lzU3RyaW5nLCBfaXNVbmRlZmluZWQsIF9yZW5kZXJDb21wbGV4U3RyaW5nLCBfcmVsRXhwLCBfZm9yRWFjaE5hbWUsIF9zb3J0UHJvcFR3ZWVuc0J5UHJpb3JpdHksIF9jb2xvclN0cmluZ0ZpbHRlciwgX2NoZWNrUGx1Z2luLCBfcmVwbGFjZVJhbmRvbSwgX3BsdWdpbnMsIEdTQ2FjaGUsIFByb3BUd2VlbiwgX2NvbmZpZywgX3RpY2tlciwgX3JvdW5kLCBfbWlzc2luZ1BsdWdpbiwgX2dldFNldHRlciwgX2dldENhY2hlLCBfY29sb3JFeHAsIF9wYXJzZVJlbGF0aXZlLCBfc2V0RGVmYXVsdHMsIF9yZW1vdmVMaW5rZWRMaXN0SXRlbSAvL2ZvciB0aGUgY29tbWVudGVkLW91dCBjbGFzc05hbWUgZmVhdHVyZS5cbn0gZnJvbSBcIi4vZ3NhcC1jb3JlLmpzXCI7XG5cbnZhciBfd2luLFxuICAgIF9kb2MsXG4gICAgX2RvY0VsZW1lbnQsXG4gICAgX3BsdWdpbkluaXR0ZWQsXG4gICAgX3RlbXBEaXYsXG4gICAgX3RlbXBEaXZTdHlsZXIsXG4gICAgX3JlY2VudFNldHRlclBsdWdpbixcbiAgICBfd2luZG93RXhpc3RzID0gZnVuY3Rpb24gX3dpbmRvd0V4aXN0cygpIHtcbiAgcmV0dXJuIHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCI7XG59LFxuICAgIF90cmFuc2Zvcm1Qcm9wcyA9IHt9LFxuICAgIF9SQUQyREVHID0gMTgwIC8gTWF0aC5QSSxcbiAgICBfREVHMlJBRCA9IE1hdGguUEkgLyAxODAsXG4gICAgX2F0YW4yID0gTWF0aC5hdGFuMixcbiAgICBfYmlnTnVtID0gMWU4LFxuICAgIF9jYXBzRXhwID0gLyhbQS1aXSkvZyxcbiAgICBfaG9yaXpvbnRhbEV4cCA9IC8obGVmdHxyaWdodHx3aWR0aHxtYXJnaW58cGFkZGluZ3x4KS9pLFxuICAgIF9jb21wbGV4RXhwID0gL1tcXHMsXFwoXVxcUy8sXG4gICAgX3Byb3BlcnR5QWxpYXNlcyA9IHtcbiAgYXV0b0FscGhhOiBcIm9wYWNpdHksdmlzaWJpbGl0eVwiLFxuICBzY2FsZTogXCJzY2FsZVgsc2NhbGVZXCIsXG4gIGFscGhhOiBcIm9wYWNpdHlcIlxufSxcbiAgICBfcmVuZGVyQ1NTUHJvcCA9IGZ1bmN0aW9uIF9yZW5kZXJDU1NQcm9wKHJhdGlvLCBkYXRhKSB7XG4gIHJldHVybiBkYXRhLnNldChkYXRhLnQsIGRhdGEucCwgTWF0aC5yb3VuZCgoZGF0YS5zICsgZGF0YS5jICogcmF0aW8pICogMTAwMDApIC8gMTAwMDAgKyBkYXRhLnUsIGRhdGEpO1xufSxcbiAgICBfcmVuZGVyUHJvcFdpdGhFbmQgPSBmdW5jdGlvbiBfcmVuZGVyUHJvcFdpdGhFbmQocmF0aW8sIGRhdGEpIHtcbiAgcmV0dXJuIGRhdGEuc2V0KGRhdGEudCwgZGF0YS5wLCByYXRpbyA9PT0gMSA/IGRhdGEuZSA6IE1hdGgucm91bmQoKGRhdGEucyArIGRhdGEuYyAqIHJhdGlvKSAqIDEwMDAwKSAvIDEwMDAwICsgZGF0YS51LCBkYXRhKTtcbn0sXG4gICAgX3JlbmRlckNTU1Byb3BXaXRoQmVnaW5uaW5nID0gZnVuY3Rpb24gX3JlbmRlckNTU1Byb3BXaXRoQmVnaW5uaW5nKHJhdGlvLCBkYXRhKSB7XG4gIHJldHVybiBkYXRhLnNldChkYXRhLnQsIGRhdGEucCwgcmF0aW8gPyBNYXRoLnJvdW5kKChkYXRhLnMgKyBkYXRhLmMgKiByYXRpbykgKiAxMDAwMCkgLyAxMDAwMCArIGRhdGEudSA6IGRhdGEuYiwgZGF0YSk7XG59LFxuICAgIC8vaWYgdW5pdHMgY2hhbmdlLCB3ZSBuZWVkIGEgd2F5IHRvIHJlbmRlciB0aGUgb3JpZ2luYWwgdW5pdC92YWx1ZSB3aGVuIHRoZSB0d2VlbiBnb2VzIGFsbCB0aGUgd2F5IGJhY2sgdG8gdGhlIGJlZ2lubmluZyAocmF0aW86MClcbl9yZW5kZXJSb3VuZGVkQ1NTUHJvcCA9IGZ1bmN0aW9uIF9yZW5kZXJSb3VuZGVkQ1NTUHJvcChyYXRpbywgZGF0YSkge1xuICB2YXIgdmFsdWUgPSBkYXRhLnMgKyBkYXRhLmMgKiByYXRpbztcbiAgZGF0YS5zZXQoZGF0YS50LCBkYXRhLnAsIH5+KHZhbHVlICsgKHZhbHVlIDwgMCA/IC0uNSA6IC41KSkgKyBkYXRhLnUsIGRhdGEpO1xufSxcbiAgICBfcmVuZGVyTm9uVHdlZW5pbmdWYWx1ZSA9IGZ1bmN0aW9uIF9yZW5kZXJOb25Ud2VlbmluZ1ZhbHVlKHJhdGlvLCBkYXRhKSB7XG4gIHJldHVybiBkYXRhLnNldChkYXRhLnQsIGRhdGEucCwgcmF0aW8gPyBkYXRhLmUgOiBkYXRhLmIsIGRhdGEpO1xufSxcbiAgICBfcmVuZGVyTm9uVHdlZW5pbmdWYWx1ZU9ubHlBdEVuZCA9IGZ1bmN0aW9uIF9yZW5kZXJOb25Ud2VlbmluZ1ZhbHVlT25seUF0RW5kKHJhdGlvLCBkYXRhKSB7XG4gIHJldHVybiBkYXRhLnNldChkYXRhLnQsIGRhdGEucCwgcmF0aW8gIT09IDEgPyBkYXRhLmIgOiBkYXRhLmUsIGRhdGEpO1xufSxcbiAgICBfc2V0dGVyQ1NTU3R5bGUgPSBmdW5jdGlvbiBfc2V0dGVyQ1NTU3R5bGUodGFyZ2V0LCBwcm9wZXJ0eSwgdmFsdWUpIHtcbiAgcmV0dXJuIHRhcmdldC5zdHlsZVtwcm9wZXJ0eV0gPSB2YWx1ZTtcbn0sXG4gICAgX3NldHRlckNTU1Byb3AgPSBmdW5jdGlvbiBfc2V0dGVyQ1NTUHJvcCh0YXJnZXQsIHByb3BlcnR5LCB2YWx1ZSkge1xuICByZXR1cm4gdGFyZ2V0LnN0eWxlLnNldFByb3BlcnR5KHByb3BlcnR5LCB2YWx1ZSk7XG59LFxuICAgIF9zZXR0ZXJUcmFuc2Zvcm0gPSBmdW5jdGlvbiBfc2V0dGVyVHJhbnNmb3JtKHRhcmdldCwgcHJvcGVydHksIHZhbHVlKSB7XG4gIHJldHVybiB0YXJnZXQuX2dzYXBbcHJvcGVydHldID0gdmFsdWU7XG59LFxuICAgIF9zZXR0ZXJTY2FsZSA9IGZ1bmN0aW9uIF9zZXR0ZXJTY2FsZSh0YXJnZXQsIHByb3BlcnR5LCB2YWx1ZSkge1xuICByZXR1cm4gdGFyZ2V0Ll9nc2FwLnNjYWxlWCA9IHRhcmdldC5fZ3NhcC5zY2FsZVkgPSB2YWx1ZTtcbn0sXG4gICAgX3NldHRlclNjYWxlV2l0aFJlbmRlciA9IGZ1bmN0aW9uIF9zZXR0ZXJTY2FsZVdpdGhSZW5kZXIodGFyZ2V0LCBwcm9wZXJ0eSwgdmFsdWUsIGRhdGEsIHJhdGlvKSB7XG4gIHZhciBjYWNoZSA9IHRhcmdldC5fZ3NhcDtcbiAgY2FjaGUuc2NhbGVYID0gY2FjaGUuc2NhbGVZID0gdmFsdWU7XG4gIGNhY2hlLnJlbmRlclRyYW5zZm9ybShyYXRpbywgY2FjaGUpO1xufSxcbiAgICBfc2V0dGVyVHJhbnNmb3JtV2l0aFJlbmRlciA9IGZ1bmN0aW9uIF9zZXR0ZXJUcmFuc2Zvcm1XaXRoUmVuZGVyKHRhcmdldCwgcHJvcGVydHksIHZhbHVlLCBkYXRhLCByYXRpbykge1xuICB2YXIgY2FjaGUgPSB0YXJnZXQuX2dzYXA7XG4gIGNhY2hlW3Byb3BlcnR5XSA9IHZhbHVlO1xuICBjYWNoZS5yZW5kZXJUcmFuc2Zvcm0ocmF0aW8sIGNhY2hlKTtcbn0sXG4gICAgX3RyYW5zZm9ybVByb3AgPSBcInRyYW5zZm9ybVwiLFxuICAgIF90cmFuc2Zvcm1PcmlnaW5Qcm9wID0gX3RyYW5zZm9ybVByb3AgKyBcIk9yaWdpblwiLFxuICAgIF9zdXBwb3J0czNELFxuICAgIF9jcmVhdGVFbGVtZW50ID0gZnVuY3Rpb24gX2NyZWF0ZUVsZW1lbnQodHlwZSwgbnMpIHtcbiAgdmFyIGUgPSBfZG9jLmNyZWF0ZUVsZW1lbnROUyA/IF9kb2MuY3JlYXRlRWxlbWVudE5TKChucyB8fCBcImh0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWxcIikucmVwbGFjZSgvXmh0dHBzLywgXCJodHRwXCIpLCB0eXBlKSA6IF9kb2MuY3JlYXRlRWxlbWVudCh0eXBlKTsgLy9zb21lIHNlcnZlcnMgc3dhcCBpbiBodHRwcyBmb3IgaHR0cCBpbiB0aGUgbmFtZXNwYWNlIHdoaWNoIGNhbiBicmVhayB0aGluZ3MsIG1ha2luZyBcInN0eWxlXCIgaW5hY2Nlc3NpYmxlLlxuXG4gIHJldHVybiBlLnN0eWxlID8gZSA6IF9kb2MuY3JlYXRlRWxlbWVudCh0eXBlKTsgLy9zb21lIGVudmlyb25tZW50cyB3b24ndCBhbGxvdyBhY2Nlc3MgdG8gdGhlIGVsZW1lbnQncyBzdHlsZSB3aGVuIGNyZWF0ZWQgd2l0aCBhIG5hbWVzcGFjZSBpbiB3aGljaCBjYXNlIHdlIGRlZmF1bHQgdG8gdGhlIHN0YW5kYXJkIGNyZWF0ZUVsZW1lbnQoKSB0byB3b3JrIGFyb3VuZCB0aGUgaXNzdWUuIEFsc28gbm90ZSB0aGF0IHdoZW4gR1NBUCBpcyBlbWJlZGRlZCBkaXJlY3RseSBpbnNpZGUgYW4gU1ZHIGZpbGUsIGNyZWF0ZUVsZW1lbnQoKSB3b24ndCBhbGxvdyBhY2Nlc3MgdG8gdGhlIHN0eWxlIG9iamVjdCBpbiBGaXJlZm94IChzZWUgaHR0cHM6Ly9ncmVlbnNvY2suY29tL2ZvcnVtcy90b3BpYy8yMDIxNS1wcm9ibGVtLXVzaW5nLXR3ZWVubWF4LWluLXN0YW5kYWxvbmUtc2VsZi1jb250YWluaW5nLXN2Zy1maWxlLWVyci1jYW5ub3Qtc2V0LXByb3BlcnR5LWNzc3RleHQtb2YtdW5kZWZpbmVkLykuXG59LFxuICAgIF9nZXRDb21wdXRlZFByb3BlcnR5ID0gZnVuY3Rpb24gX2dldENvbXB1dGVkUHJvcGVydHkodGFyZ2V0LCBwcm9wZXJ0eSwgc2tpcFByZWZpeEZhbGxiYWNrKSB7XG4gIHZhciBjcyA9IGdldENvbXB1dGVkU3R5bGUodGFyZ2V0KTtcbiAgcmV0dXJuIGNzW3Byb3BlcnR5XSB8fCBjcy5nZXRQcm9wZXJ0eVZhbHVlKHByb3BlcnR5LnJlcGxhY2UoX2NhcHNFeHAsIFwiLSQxXCIpLnRvTG93ZXJDYXNlKCkpIHx8IGNzLmdldFByb3BlcnR5VmFsdWUocHJvcGVydHkpIHx8ICFza2lwUHJlZml4RmFsbGJhY2sgJiYgX2dldENvbXB1dGVkUHJvcGVydHkodGFyZ2V0LCBfY2hlY2tQcm9wUHJlZml4KHByb3BlcnR5KSB8fCBwcm9wZXJ0eSwgMSkgfHwgXCJcIjsgLy9jc3MgdmFyaWFibGVzIG1heSBub3QgbmVlZCBjYXBzIHN3YXBwZWQgb3V0IGZvciBkYXNoZXMgYW5kIGxvd2VyY2FzZS5cbn0sXG4gICAgX3ByZWZpeGVzID0gXCJPLE1veixtcyxNcyxXZWJraXRcIi5zcGxpdChcIixcIiksXG4gICAgX2NoZWNrUHJvcFByZWZpeCA9IGZ1bmN0aW9uIF9jaGVja1Byb3BQcmVmaXgocHJvcGVydHksIGVsZW1lbnQsIHByZWZlclByZWZpeCkge1xuICB2YXIgZSA9IGVsZW1lbnQgfHwgX3RlbXBEaXYsXG4gICAgICBzID0gZS5zdHlsZSxcbiAgICAgIGkgPSA1O1xuXG4gIGlmIChwcm9wZXJ0eSBpbiBzICYmICFwcmVmZXJQcmVmaXgpIHtcbiAgICByZXR1cm4gcHJvcGVydHk7XG4gIH1cblxuICBwcm9wZXJ0eSA9IHByb3BlcnR5LmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgcHJvcGVydHkuc3Vic3RyKDEpO1xuXG4gIHdoaWxlIChpLS0gJiYgIShfcHJlZml4ZXNbaV0gKyBwcm9wZXJ0eSBpbiBzKSkge31cblxuICByZXR1cm4gaSA8IDAgPyBudWxsIDogKGkgPT09IDMgPyBcIm1zXCIgOiBpID49IDAgPyBfcHJlZml4ZXNbaV0gOiBcIlwiKSArIHByb3BlcnR5O1xufSxcbiAgICBfaW5pdENvcmUgPSBmdW5jdGlvbiBfaW5pdENvcmUoKSB7XG4gIGlmIChfd2luZG93RXhpc3RzKCkgJiYgd2luZG93LmRvY3VtZW50KSB7XG4gICAgX3dpbiA9IHdpbmRvdztcbiAgICBfZG9jID0gX3dpbi5kb2N1bWVudDtcbiAgICBfZG9jRWxlbWVudCA9IF9kb2MuZG9jdW1lbnRFbGVtZW50O1xuICAgIF90ZW1wRGl2ID0gX2NyZWF0ZUVsZW1lbnQoXCJkaXZcIikgfHwge1xuICAgICAgc3R5bGU6IHt9XG4gICAgfTtcbiAgICBfdGVtcERpdlN0eWxlciA9IF9jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgIF90cmFuc2Zvcm1Qcm9wID0gX2NoZWNrUHJvcFByZWZpeChfdHJhbnNmb3JtUHJvcCk7XG4gICAgX3RyYW5zZm9ybU9yaWdpblByb3AgPSBfdHJhbnNmb3JtUHJvcCArIFwiT3JpZ2luXCI7XG4gICAgX3RlbXBEaXYuc3R5bGUuY3NzVGV4dCA9IFwiYm9yZGVyLXdpZHRoOjA7bGluZS1oZWlnaHQ6MDtwb3NpdGlvbjphYnNvbHV0ZTtwYWRkaW5nOjBcIjsgLy9tYWtlIHN1cmUgdG8gb3ZlcnJpZGUgY2VydGFpbiBwcm9wZXJ0aWVzIHRoYXQgbWF5IGNvbnRhbWluYXRlIG1lYXN1cmVtZW50cywgaW4gY2FzZSB0aGUgdXNlciBoYXMgb3ZlcnJlYWNoaW5nIHN0eWxlIHNoZWV0cy5cblxuICAgIF9zdXBwb3J0czNEID0gISFfY2hlY2tQcm9wUHJlZml4KFwicGVyc3BlY3RpdmVcIik7XG4gICAgX3BsdWdpbkluaXR0ZWQgPSAxO1xuICB9XG59LFxuICAgIF9nZXRCQm94SGFjayA9IGZ1bmN0aW9uIF9nZXRCQm94SGFjayhzd2FwSWZQb3NzaWJsZSkge1xuICAvL3dvcmtzIGFyb3VuZCBpc3N1ZXMgaW4gc29tZSBicm93c2VycyAobGlrZSBGaXJlZm94KSB0aGF0IGRvbid0IGNvcnJlY3RseSByZXBvcnQgZ2V0QkJveCgpIG9uIFNWRyBlbGVtZW50cyBpbnNpZGUgYSA8ZGVmcz4gZWxlbWVudCBhbmQvb3IgPG1hc2s+LiBXZSB0cnkgY3JlYXRpbmcgYW4gU1ZHLCBhZGRpbmcgaXQgdG8gdGhlIGRvY3VtZW50RWxlbWVudCBhbmQgdG9zcyB0aGUgZWxlbWVudCBpbiB0aGVyZSBzbyB0aGF0IGl0J3MgZGVmaW5pdGVseSBwYXJ0IG9mIHRoZSByZW5kZXJpbmcgdHJlZSwgdGhlbiBncmFiIHRoZSBiYm94IGFuZCBpZiBpdCB3b3Jrcywgd2UgYWN0dWFsbHkgc3dhcCBvdXQgdGhlIG9yaWdpbmFsIGdldEJCb3goKSBtZXRob2QgZm9yIG91ciBvd24gdGhhdCBkb2VzIHRoZXNlIGV4dHJhIHN0ZXBzIHdoZW5ldmVyIGdldEJCb3ggaXMgbmVlZGVkLiBUaGlzIGhlbHBzIGVuc3VyZSB0aGF0IHBlcmZvcm1hbmNlIGlzIG9wdGltYWwgKG9ubHkgZG8gYWxsIHRoZXNlIGV4dHJhIHN0ZXBzIHdoZW4gYWJzb2x1dGVseSBuZWNlc3NhcnkuLi5tb3N0IGVsZW1lbnRzIGRvbid0IG5lZWQgaXQpLlxuICB2YXIgc3ZnID0gX2NyZWF0ZUVsZW1lbnQoXCJzdmdcIiwgdGhpcy5vd25lclNWR0VsZW1lbnQgJiYgdGhpcy5vd25lclNWR0VsZW1lbnQuZ2V0QXR0cmlidXRlKFwieG1sbnNcIikgfHwgXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiKSxcbiAgICAgIG9sZFBhcmVudCA9IHRoaXMucGFyZW50Tm9kZSxcbiAgICAgIG9sZFNpYmxpbmcgPSB0aGlzLm5leHRTaWJsaW5nLFxuICAgICAgb2xkQ1NTID0gdGhpcy5zdHlsZS5jc3NUZXh0LFxuICAgICAgYmJveDtcblxuICBfZG9jRWxlbWVudC5hcHBlbmRDaGlsZChzdmcpO1xuXG4gIHN2Zy5hcHBlbmRDaGlsZCh0aGlzKTtcbiAgdGhpcy5zdHlsZS5kaXNwbGF5ID0gXCJibG9ja1wiO1xuXG4gIGlmIChzd2FwSWZQb3NzaWJsZSkge1xuICAgIHRyeSB7XG4gICAgICBiYm94ID0gdGhpcy5nZXRCQm94KCk7XG4gICAgICB0aGlzLl9nc2FwQkJveCA9IHRoaXMuZ2V0QkJveDsgLy9zdG9yZSB0aGUgb3JpZ2luYWxcblxuICAgICAgdGhpcy5nZXRCQm94ID0gX2dldEJCb3hIYWNrO1xuICAgIH0gY2F0Y2ggKGUpIHt9XG4gIH0gZWxzZSBpZiAodGhpcy5fZ3NhcEJCb3gpIHtcbiAgICBiYm94ID0gdGhpcy5fZ3NhcEJCb3goKTtcbiAgfVxuXG4gIGlmIChvbGRQYXJlbnQpIHtcbiAgICBpZiAob2xkU2libGluZykge1xuICAgICAgb2xkUGFyZW50Lmluc2VydEJlZm9yZSh0aGlzLCBvbGRTaWJsaW5nKTtcbiAgICB9IGVsc2Uge1xuICAgICAgb2xkUGFyZW50LmFwcGVuZENoaWxkKHRoaXMpO1xuICAgIH1cbiAgfVxuXG4gIF9kb2NFbGVtZW50LnJlbW92ZUNoaWxkKHN2Zyk7XG5cbiAgdGhpcy5zdHlsZS5jc3NUZXh0ID0gb2xkQ1NTO1xuICByZXR1cm4gYmJveDtcbn0sXG4gICAgX2dldEF0dHJpYnV0ZUZhbGxiYWNrcyA9IGZ1bmN0aW9uIF9nZXRBdHRyaWJ1dGVGYWxsYmFja3ModGFyZ2V0LCBhdHRyaWJ1dGVzQXJyYXkpIHtcbiAgdmFyIGkgPSBhdHRyaWJ1dGVzQXJyYXkubGVuZ3RoO1xuXG4gIHdoaWxlIChpLS0pIHtcbiAgICBpZiAodGFyZ2V0Lmhhc0F0dHJpYnV0ZShhdHRyaWJ1dGVzQXJyYXlbaV0pKSB7XG4gICAgICByZXR1cm4gdGFyZ2V0LmdldEF0dHJpYnV0ZShhdHRyaWJ1dGVzQXJyYXlbaV0pO1xuICAgIH1cbiAgfVxufSxcbiAgICBfZ2V0QkJveCA9IGZ1bmN0aW9uIF9nZXRCQm94KHRhcmdldCkge1xuICB2YXIgYm91bmRzO1xuXG4gIHRyeSB7XG4gICAgYm91bmRzID0gdGFyZ2V0LmdldEJCb3goKTsgLy9GaXJlZm94IHRocm93cyBlcnJvcnMgaWYgeW91IHRyeSBjYWxsaW5nIGdldEJCb3goKSBvbiBhbiBTVkcgZWxlbWVudCB0aGF0J3Mgbm90IHJlbmRlcmVkIChsaWtlIGluIGEgPHN5bWJvbD4gb3IgPGRlZnM+KS4gaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9NjEyMTE4XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgYm91bmRzID0gX2dldEJCb3hIYWNrLmNhbGwodGFyZ2V0LCB0cnVlKTtcbiAgfVxuXG4gIGJvdW5kcyAmJiAoYm91bmRzLndpZHRoIHx8IGJvdW5kcy5oZWlnaHQpIHx8IHRhcmdldC5nZXRCQm94ID09PSBfZ2V0QkJveEhhY2sgfHwgKGJvdW5kcyA9IF9nZXRCQm94SGFjay5jYWxsKHRhcmdldCwgdHJ1ZSkpOyAvL3NvbWUgYnJvd3NlcnMgKGxpa2UgRmlyZWZveCkgbWlzcmVwb3J0IHRoZSBib3VuZHMgaWYgdGhlIGVsZW1lbnQgaGFzIHplcm8gd2lkdGggYW5kIGhlaWdodCAoaXQganVzdCBhc3N1bWVzIGl0J3MgYXQgeDowLCB5OjApLCB0aHVzIHdlIG5lZWQgdG8gbWFudWFsbHkgZ3JhYiB0aGUgcG9zaXRpb24gaW4gdGhhdCBjYXNlLlxuXG4gIHJldHVybiBib3VuZHMgJiYgIWJvdW5kcy53aWR0aCAmJiAhYm91bmRzLnggJiYgIWJvdW5kcy55ID8ge1xuICAgIHg6ICtfZ2V0QXR0cmlidXRlRmFsbGJhY2tzKHRhcmdldCwgW1wieFwiLCBcImN4XCIsIFwieDFcIl0pIHx8IDAsXG4gICAgeTogK19nZXRBdHRyaWJ1dGVGYWxsYmFja3ModGFyZ2V0LCBbXCJ5XCIsIFwiY3lcIiwgXCJ5MVwiXSkgfHwgMCxcbiAgICB3aWR0aDogMCxcbiAgICBoZWlnaHQ6IDBcbiAgfSA6IGJvdW5kcztcbn0sXG4gICAgX2lzU1ZHID0gZnVuY3Rpb24gX2lzU1ZHKGUpIHtcbiAgcmV0dXJuICEhKGUuZ2V0Q1RNICYmICghZS5wYXJlbnROb2RlIHx8IGUub3duZXJTVkdFbGVtZW50KSAmJiBfZ2V0QkJveChlKSk7XG59LFxuICAgIC8vcmVwb3J0cyBpZiB0aGUgZWxlbWVudCBpcyBhbiBTVkcgb24gd2hpY2ggZ2V0QkJveCgpIGFjdHVhbGx5IHdvcmtzXG5fcmVtb3ZlUHJvcGVydHkgPSBmdW5jdGlvbiBfcmVtb3ZlUHJvcGVydHkodGFyZ2V0LCBwcm9wZXJ0eSkge1xuICBpZiAocHJvcGVydHkpIHtcbiAgICB2YXIgc3R5bGUgPSB0YXJnZXQuc3R5bGU7XG5cbiAgICBpZiAocHJvcGVydHkgaW4gX3RyYW5zZm9ybVByb3BzICYmIHByb3BlcnR5ICE9PSBfdHJhbnNmb3JtT3JpZ2luUHJvcCkge1xuICAgICAgcHJvcGVydHkgPSBfdHJhbnNmb3JtUHJvcDtcbiAgICB9XG5cbiAgICBpZiAoc3R5bGUucmVtb3ZlUHJvcGVydHkpIHtcbiAgICAgIGlmIChwcm9wZXJ0eS5zdWJzdHIoMCwgMikgPT09IFwibXNcIiB8fCBwcm9wZXJ0eS5zdWJzdHIoMCwgNikgPT09IFwid2Via2l0XCIpIHtcbiAgICAgICAgLy9NaWNyb3NvZnQgYW5kIHNvbWUgV2Via2l0IGJyb3dzZXJzIGRvbid0IGNvbmZvcm0gdG8gdGhlIHN0YW5kYXJkIG9mIGNhcGl0YWxpemluZyB0aGUgZmlyc3QgcHJlZml4IGNoYXJhY3Rlciwgc28gd2UgYWRqdXN0IHNvIHRoYXQgd2hlbiB3ZSBwcmVmaXggdGhlIGNhcHMgd2l0aCBhIGRhc2gsIGl0J3MgY29ycmVjdCAob3RoZXJ3aXNlIGl0J2QgYmUgXCJtcy10cmFuc2Zvcm1cIiBpbnN0ZWFkIG9mIFwiLW1zLXRyYW5zZm9ybVwiIGZvciBJRTksIGZvciBleGFtcGxlKVxuICAgICAgICBwcm9wZXJ0eSA9IFwiLVwiICsgcHJvcGVydHk7XG4gICAgICB9XG5cbiAgICAgIHN0eWxlLnJlbW92ZVByb3BlcnR5KHByb3BlcnR5LnJlcGxhY2UoX2NhcHNFeHAsIFwiLSQxXCIpLnRvTG93ZXJDYXNlKCkpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvL25vdGU6IG9sZCB2ZXJzaW9ucyBvZiBJRSB1c2UgXCJyZW1vdmVBdHRyaWJ1dGUoKVwiIGluc3RlYWQgb2YgXCJyZW1vdmVQcm9wZXJ0eSgpXCJcbiAgICAgIHN0eWxlLnJlbW92ZUF0dHJpYnV0ZShwcm9wZXJ0eSk7XG4gICAgfVxuICB9XG59LFxuICAgIF9hZGROb25Ud2VlbmluZ1BUID0gZnVuY3Rpb24gX2FkZE5vblR3ZWVuaW5nUFQocGx1Z2luLCB0YXJnZXQsIHByb3BlcnR5LCBiZWdpbm5pbmcsIGVuZCwgb25seVNldEF0RW5kKSB7XG4gIHZhciBwdCA9IG5ldyBQcm9wVHdlZW4ocGx1Z2luLl9wdCwgdGFyZ2V0LCBwcm9wZXJ0eSwgMCwgMSwgb25seVNldEF0RW5kID8gX3JlbmRlck5vblR3ZWVuaW5nVmFsdWVPbmx5QXRFbmQgOiBfcmVuZGVyTm9uVHdlZW5pbmdWYWx1ZSk7XG4gIHBsdWdpbi5fcHQgPSBwdDtcbiAgcHQuYiA9IGJlZ2lubmluZztcbiAgcHQuZSA9IGVuZDtcblxuICBwbHVnaW4uX3Byb3BzLnB1c2gocHJvcGVydHkpO1xuXG4gIHJldHVybiBwdDtcbn0sXG4gICAgX25vbkNvbnZlcnRpYmxlVW5pdHMgPSB7XG4gIGRlZzogMSxcbiAgcmFkOiAxLFxuICB0dXJuOiAxXG59LFxuICAgIC8vdGFrZXMgYSBzaW5nbGUgdmFsdWUgbGlrZSAyMHB4IGFuZCBjb252ZXJ0cyBpdCB0byB0aGUgdW5pdCBzcGVjaWZpZWQsIGxpa2UgXCIlXCIsIHJldHVybmluZyBvbmx5IHRoZSBudW1lcmljIGFtb3VudC5cbl9jb252ZXJ0VG9Vbml0ID0gZnVuY3Rpb24gX2NvbnZlcnRUb1VuaXQodGFyZ2V0LCBwcm9wZXJ0eSwgdmFsdWUsIHVuaXQpIHtcbiAgdmFyIGN1clZhbHVlID0gcGFyc2VGbG9hdCh2YWx1ZSkgfHwgMCxcbiAgICAgIGN1clVuaXQgPSAodmFsdWUgKyBcIlwiKS50cmltKCkuc3Vic3RyKChjdXJWYWx1ZSArIFwiXCIpLmxlbmd0aCkgfHwgXCJweFwiLFxuICAgICAgLy8gc29tZSBicm93c2VycyBsZWF2ZSBleHRyYSB3aGl0ZXNwYWNlIGF0IHRoZSBiZWdpbm5pbmcgb2YgQ1NTIHZhcmlhYmxlcywgaGVuY2UgdGhlIG5lZWQgdG8gdHJpbSgpXG4gIHN0eWxlID0gX3RlbXBEaXYuc3R5bGUsXG4gICAgICBob3Jpem9udGFsID0gX2hvcml6b250YWxFeHAudGVzdChwcm9wZXJ0eSksXG4gICAgICBpc1Jvb3RTVkcgPSB0YXJnZXQudGFnTmFtZS50b0xvd2VyQ2FzZSgpID09PSBcInN2Z1wiLFxuICAgICAgbWVhc3VyZVByb3BlcnR5ID0gKGlzUm9vdFNWRyA/IFwiY2xpZW50XCIgOiBcIm9mZnNldFwiKSArIChob3Jpem9udGFsID8gXCJXaWR0aFwiIDogXCJIZWlnaHRcIiksXG4gICAgICBhbW91bnQgPSAxMDAsXG4gICAgICB0b1BpeGVscyA9IHVuaXQgPT09IFwicHhcIixcbiAgICAgIHRvUGVyY2VudCA9IHVuaXQgPT09IFwiJVwiLFxuICAgICAgcHgsXG4gICAgICBwYXJlbnQsXG4gICAgICBjYWNoZSxcbiAgICAgIGlzU1ZHO1xuXG4gIGlmICh1bml0ID09PSBjdXJVbml0IHx8ICFjdXJWYWx1ZSB8fCBfbm9uQ29udmVydGlibGVVbml0c1t1bml0XSB8fCBfbm9uQ29udmVydGlibGVVbml0c1tjdXJVbml0XSkge1xuICAgIHJldHVybiBjdXJWYWx1ZTtcbiAgfVxuXG4gIGN1clVuaXQgIT09IFwicHhcIiAmJiAhdG9QaXhlbHMgJiYgKGN1clZhbHVlID0gX2NvbnZlcnRUb1VuaXQodGFyZ2V0LCBwcm9wZXJ0eSwgdmFsdWUsIFwicHhcIikpO1xuICBpc1NWRyA9IHRhcmdldC5nZXRDVE0gJiYgX2lzU1ZHKHRhcmdldCk7XG5cbiAgaWYgKCh0b1BlcmNlbnQgfHwgY3VyVW5pdCA9PT0gXCIlXCIpICYmIChfdHJhbnNmb3JtUHJvcHNbcHJvcGVydHldIHx8IH5wcm9wZXJ0eS5pbmRleE9mKFwiYWRpdXNcIikpKSB7XG4gICAgcHggPSBpc1NWRyA/IHRhcmdldC5nZXRCQm94KClbaG9yaXpvbnRhbCA/IFwid2lkdGhcIiA6IFwiaGVpZ2h0XCJdIDogdGFyZ2V0W21lYXN1cmVQcm9wZXJ0eV07XG4gICAgcmV0dXJuIF9yb3VuZCh0b1BlcmNlbnQgPyBjdXJWYWx1ZSAvIHB4ICogYW1vdW50IDogY3VyVmFsdWUgLyAxMDAgKiBweCk7XG4gIH1cblxuICBzdHlsZVtob3Jpem9udGFsID8gXCJ3aWR0aFwiIDogXCJoZWlnaHRcIl0gPSBhbW91bnQgKyAodG9QaXhlbHMgPyBjdXJVbml0IDogdW5pdCk7XG4gIHBhcmVudCA9IH5wcm9wZXJ0eS5pbmRleE9mKFwiYWRpdXNcIikgfHwgdW5pdCA9PT0gXCJlbVwiICYmIHRhcmdldC5hcHBlbmRDaGlsZCAmJiAhaXNSb290U1ZHID8gdGFyZ2V0IDogdGFyZ2V0LnBhcmVudE5vZGU7XG5cbiAgaWYgKGlzU1ZHKSB7XG4gICAgcGFyZW50ID0gKHRhcmdldC5vd25lclNWR0VsZW1lbnQgfHwge30pLnBhcmVudE5vZGU7XG4gIH1cblxuICBpZiAoIXBhcmVudCB8fCBwYXJlbnQgPT09IF9kb2MgfHwgIXBhcmVudC5hcHBlbmRDaGlsZCkge1xuICAgIHBhcmVudCA9IF9kb2MuYm9keTtcbiAgfVxuXG4gIGNhY2hlID0gcGFyZW50Ll9nc2FwO1xuXG4gIGlmIChjYWNoZSAmJiB0b1BlcmNlbnQgJiYgY2FjaGUud2lkdGggJiYgaG9yaXpvbnRhbCAmJiBjYWNoZS50aW1lID09PSBfdGlja2VyLnRpbWUpIHtcbiAgICByZXR1cm4gX3JvdW5kKGN1clZhbHVlIC8gY2FjaGUud2lkdGggKiBhbW91bnQpO1xuICB9IGVsc2Uge1xuICAgICh0b1BlcmNlbnQgfHwgY3VyVW5pdCA9PT0gXCIlXCIpICYmIChzdHlsZS5wb3NpdGlvbiA9IF9nZXRDb21wdXRlZFByb3BlcnR5KHRhcmdldCwgXCJwb3NpdGlvblwiKSk7XG4gICAgcGFyZW50ID09PSB0YXJnZXQgJiYgKHN0eWxlLnBvc2l0aW9uID0gXCJzdGF0aWNcIik7IC8vIGxpa2UgZm9yIGJvcmRlclJhZGl1cywgaWYgaXQncyBhICUgd2UgbXVzdCBoYXZlIGl0IHJlbGF0aXZlIHRvIHRoZSB0YXJnZXQgaXRzZWxmIGJ1dCB0aGF0IG1heSBub3QgaGF2ZSBwb3NpdGlvbjogcmVsYXRpdmUgb3IgcG9zaXRpb246IGFic29sdXRlIGluIHdoaWNoIGNhc2UgaXQnZCBnbyB1cCB0aGUgY2hhaW4gdW50aWwgaXQgZmluZHMgaXRzIG9mZnNldFBhcmVudCAoYmFkKS4gcG9zaXRpb246IHN0YXRpYyBwcm90ZWN0cyBhZ2FpbnN0IHRoYXQuXG5cbiAgICBwYXJlbnQuYXBwZW5kQ2hpbGQoX3RlbXBEaXYpO1xuICAgIHB4ID0gX3RlbXBEaXZbbWVhc3VyZVByb3BlcnR5XTtcbiAgICBwYXJlbnQucmVtb3ZlQ2hpbGQoX3RlbXBEaXYpO1xuICAgIHN0eWxlLnBvc2l0aW9uID0gXCJhYnNvbHV0ZVwiO1xuXG4gICAgaWYgKGhvcml6b250YWwgJiYgdG9QZXJjZW50KSB7XG4gICAgICBjYWNoZSA9IF9nZXRDYWNoZShwYXJlbnQpO1xuICAgICAgY2FjaGUudGltZSA9IF90aWNrZXIudGltZTtcbiAgICAgIGNhY2hlLndpZHRoID0gcGFyZW50W21lYXN1cmVQcm9wZXJ0eV07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIF9yb3VuZCh0b1BpeGVscyA/IHB4ICogY3VyVmFsdWUgLyBhbW91bnQgOiBweCAmJiBjdXJWYWx1ZSA/IGFtb3VudCAvIHB4ICogY3VyVmFsdWUgOiAwKTtcbn0sXG4gICAgX2dldCA9IGZ1bmN0aW9uIF9nZXQodGFyZ2V0LCBwcm9wZXJ0eSwgdW5pdCwgdW5jYWNoZSkge1xuICB2YXIgdmFsdWU7XG4gIF9wbHVnaW5Jbml0dGVkIHx8IF9pbml0Q29yZSgpO1xuXG4gIGlmIChwcm9wZXJ0eSBpbiBfcHJvcGVydHlBbGlhc2VzICYmIHByb3BlcnR5ICE9PSBcInRyYW5zZm9ybVwiKSB7XG4gICAgcHJvcGVydHkgPSBfcHJvcGVydHlBbGlhc2VzW3Byb3BlcnR5XTtcblxuICAgIGlmICh+cHJvcGVydHkuaW5kZXhPZihcIixcIikpIHtcbiAgICAgIHByb3BlcnR5ID0gcHJvcGVydHkuc3BsaXQoXCIsXCIpWzBdO1xuICAgIH1cbiAgfVxuXG4gIGlmIChfdHJhbnNmb3JtUHJvcHNbcHJvcGVydHldICYmIHByb3BlcnR5ICE9PSBcInRyYW5zZm9ybVwiKSB7XG4gICAgdmFsdWUgPSBfcGFyc2VUcmFuc2Zvcm0odGFyZ2V0LCB1bmNhY2hlKTtcbiAgICB2YWx1ZSA9IHByb3BlcnR5ICE9PSBcInRyYW5zZm9ybU9yaWdpblwiID8gdmFsdWVbcHJvcGVydHldIDogdmFsdWUuc3ZnID8gdmFsdWUub3JpZ2luIDogX2ZpcnN0VHdvT25seShfZ2V0Q29tcHV0ZWRQcm9wZXJ0eSh0YXJnZXQsIF90cmFuc2Zvcm1PcmlnaW5Qcm9wKSkgKyBcIiBcIiArIHZhbHVlLnpPcmlnaW4gKyBcInB4XCI7XG4gIH0gZWxzZSB7XG4gICAgdmFsdWUgPSB0YXJnZXQuc3R5bGVbcHJvcGVydHldO1xuXG4gICAgaWYgKCF2YWx1ZSB8fCB2YWx1ZSA9PT0gXCJhdXRvXCIgfHwgdW5jYWNoZSB8fCB+KHZhbHVlICsgXCJcIikuaW5kZXhPZihcImNhbGMoXCIpKSB7XG4gICAgICB2YWx1ZSA9IF9zcGVjaWFsUHJvcHNbcHJvcGVydHldICYmIF9zcGVjaWFsUHJvcHNbcHJvcGVydHldKHRhcmdldCwgcHJvcGVydHksIHVuaXQpIHx8IF9nZXRDb21wdXRlZFByb3BlcnR5KHRhcmdldCwgcHJvcGVydHkpIHx8IF9nZXRQcm9wZXJ0eSh0YXJnZXQsIHByb3BlcnR5KSB8fCAocHJvcGVydHkgPT09IFwib3BhY2l0eVwiID8gMSA6IDApOyAvLyBub3RlOiBzb21lIGJyb3dzZXJzLCBsaWtlIEZpcmVmb3gsIGRvbid0IHJlcG9ydCBib3JkZXJSYWRpdXMgY29ycmVjdGx5ISBJbnN0ZWFkLCBpdCBvbmx5IHJlcG9ydHMgZXZlcnkgY29ybmVyIGxpa2UgIGJvcmRlclRvcExlZnRSYWRpdXNcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdW5pdCAmJiAhfih2YWx1ZSArIFwiXCIpLnRyaW0oKS5pbmRleE9mKFwiIFwiKSA/IF9jb252ZXJ0VG9Vbml0KHRhcmdldCwgcHJvcGVydHksIHZhbHVlLCB1bml0KSArIHVuaXQgOiB2YWx1ZTtcbn0sXG4gICAgX3R3ZWVuQ29tcGxleENTU1N0cmluZyA9IGZ1bmN0aW9uIF90d2VlbkNvbXBsZXhDU1NTdHJpbmcodGFyZ2V0LCBwcm9wLCBzdGFydCwgZW5kKSB7XG4gIC8vIG5vdGU6IHdlIGNhbGwgX3R3ZWVuQ29tcGxleENTU1N0cmluZy5jYWxsKHBsdWdpbkluc3RhbmNlLi4uKSB0byBlbnN1cmUgdGhhdCBpdCdzIHNjb3BlZCBwcm9wZXJseS4gV2UgbWF5IGNhbGwgaXQgZnJvbSB3aXRoaW4gYSBwbHVnaW4gdG9vLCB0aHVzIFwidGhpc1wiIHdvdWxkIHJlZmVyIHRvIHRoZSBwbHVnaW4uXG4gIGlmICghc3RhcnQgfHwgc3RhcnQgPT09IFwibm9uZVwiKSB7XG4gICAgLy8gc29tZSBicm93c2VycyBsaWtlIFNhZmFyaSBhY3R1YWxseSBQUkVGRVIgdGhlIHByZWZpeGVkIHByb3BlcnR5IGFuZCBtaXMtcmVwb3J0IHRoZSB1bnByZWZpeGVkIHZhbHVlIGxpa2UgY2xpcFBhdGggKEJVRykuIEluIG90aGVyIHdvcmRzLCBldmVuIHRob3VnaCBjbGlwUGF0aCBleGlzdHMgaW4gdGhlIHN0eWxlIChcImNsaXBQYXRoXCIgaW4gdGFyZ2V0LnN0eWxlKSBhbmQgaXQncyBzZXQgaW4gdGhlIENTUyBwcm9wZXJseSAoYWxvbmcgd2l0aCAtd2Via2l0LWNsaXAtcGF0aCksIFNhZmFyaSByZXBvcnRzIGNsaXBQYXRoIGFzIFwibm9uZVwiIHdoZXJlYXMgV2Via2l0Q2xpcFBhdGggcmVwb3J0cyBhY2N1cmF0ZWx5IGxpa2UgXCJlbGxpcHNlKDEwMCUgMCUgYXQgNTAlIDAlKVwiLCBzbyBpbiB0aGlzIGNhc2Ugd2UgbXVzdCBTV0lUQ0ggdG8gdXNpbmcgdGhlIHByZWZpeGVkIHByb3BlcnR5IGluc3RlYWQuIFNlZSBodHRwczovL2dyZWVuc29jay5jb20vZm9ydW1zL3RvcGljLzE4MzEwLWNsaXBwYXRoLWRvZXNudC13b3JrLW9uLWlvcy9cbiAgICB2YXIgcCA9IF9jaGVja1Byb3BQcmVmaXgocHJvcCwgdGFyZ2V0LCAxKSxcbiAgICAgICAgcyA9IHAgJiYgX2dldENvbXB1dGVkUHJvcGVydHkodGFyZ2V0LCBwLCAxKTtcblxuICAgIGlmIChzICYmIHMgIT09IHN0YXJ0KSB7XG4gICAgICBwcm9wID0gcDtcbiAgICAgIHN0YXJ0ID0gcztcbiAgICB9IGVsc2UgaWYgKHByb3AgPT09IFwiYm9yZGVyQ29sb3JcIikge1xuICAgICAgc3RhcnQgPSBfZ2V0Q29tcHV0ZWRQcm9wZXJ0eSh0YXJnZXQsIFwiYm9yZGVyVG9wQ29sb3JcIik7IC8vIEZpcmVmb3ggYnVnOiBhbHdheXMgcmVwb3J0cyBcImJvcmRlckNvbG9yXCIgYXMgXCJcIiwgc28gd2UgbXVzdCBmYWxsIGJhY2sgdG8gYm9yZGVyVG9wQ29sb3IuIFNlZSBodHRwczovL2dyZWVuc29jay5jb20vZm9ydW1zL3RvcGljLzI0NTgzLWhvdy10by1yZXR1cm4tY29sb3JzLXRoYXQtaS1oYWQtYWZ0ZXItcmV2ZXJzZS9cbiAgICB9XG4gIH1cblxuICB2YXIgcHQgPSBuZXcgUHJvcFR3ZWVuKHRoaXMuX3B0LCB0YXJnZXQuc3R5bGUsIHByb3AsIDAsIDEsIF9yZW5kZXJDb21wbGV4U3RyaW5nKSxcbiAgICAgIGluZGV4ID0gMCxcbiAgICAgIG1hdGNoSW5kZXggPSAwLFxuICAgICAgYSxcbiAgICAgIHJlc3VsdCxcbiAgICAgIHN0YXJ0VmFsdWVzLFxuICAgICAgc3RhcnROdW0sXG4gICAgICBjb2xvcixcbiAgICAgIHN0YXJ0VmFsdWUsXG4gICAgICBlbmRWYWx1ZSxcbiAgICAgIGVuZE51bSxcbiAgICAgIGNodW5rLFxuICAgICAgZW5kVW5pdCxcbiAgICAgIHN0YXJ0VW5pdCxcbiAgICAgIGVuZFZhbHVlcztcbiAgcHQuYiA9IHN0YXJ0O1xuICBwdC5lID0gZW5kO1xuICBzdGFydCArPSBcIlwiOyAvLyBlbnN1cmUgdmFsdWVzIGFyZSBzdHJpbmdzXG5cbiAgZW5kICs9IFwiXCI7XG5cbiAgaWYgKGVuZCA9PT0gXCJhdXRvXCIpIHtcbiAgICB0YXJnZXQuc3R5bGVbcHJvcF0gPSBlbmQ7XG4gICAgZW5kID0gX2dldENvbXB1dGVkUHJvcGVydHkodGFyZ2V0LCBwcm9wKSB8fCBlbmQ7XG4gICAgdGFyZ2V0LnN0eWxlW3Byb3BdID0gc3RhcnQ7XG4gIH1cblxuICBhID0gW3N0YXJ0LCBlbmRdO1xuXG4gIF9jb2xvclN0cmluZ0ZpbHRlcihhKTsgLy8gcGFzcyBhbiBhcnJheSB3aXRoIHRoZSBzdGFydGluZyBhbmQgZW5kaW5nIHZhbHVlcyBhbmQgbGV0IHRoZSBmaWx0ZXIgZG8gd2hhdGV2ZXIgaXQgbmVlZHMgdG8gdGhlIHZhbHVlcy4gSWYgY29sb3JzIGFyZSBmb3VuZCwgaXQgcmV0dXJucyB0cnVlIGFuZCB0aGVuIHdlIG11c3QgbWF0Y2ggd2hlcmUgdGhlIGNvbG9yIHNob3dzIHVwIG9yZGVyLXdpc2UgYmVjYXVzZSBmb3IgdGhpbmdzIGxpa2UgYm94U2hhZG93LCBzb21ldGltZXMgdGhlIGJyb3dzZXIgcHJvdmlkZXMgdGhlIGNvbXB1dGVkIHZhbHVlcyB3aXRoIHRoZSBjb2xvciBGSVJTVCwgYnV0IHRoZSB1c2VyIHByb3ZpZGVzIGl0IHdpdGggdGhlIGNvbG9yIExBU1QsIHNvIGZsaXAgdGhlbSBpZiBuZWNlc3NhcnkuIFNhbWUgZm9yIGRyb3Atc2hhZG93KCkuXG5cblxuICBzdGFydCA9IGFbMF07XG4gIGVuZCA9IGFbMV07XG4gIHN0YXJ0VmFsdWVzID0gc3RhcnQubWF0Y2goX251bVdpdGhVbml0RXhwKSB8fCBbXTtcbiAgZW5kVmFsdWVzID0gZW5kLm1hdGNoKF9udW1XaXRoVW5pdEV4cCkgfHwgW107XG5cbiAgaWYgKGVuZFZhbHVlcy5sZW5ndGgpIHtcbiAgICB3aGlsZSAocmVzdWx0ID0gX251bVdpdGhVbml0RXhwLmV4ZWMoZW5kKSkge1xuICAgICAgZW5kVmFsdWUgPSByZXN1bHRbMF07XG4gICAgICBjaHVuayA9IGVuZC5zdWJzdHJpbmcoaW5kZXgsIHJlc3VsdC5pbmRleCk7XG5cbiAgICAgIGlmIChjb2xvcikge1xuICAgICAgICBjb2xvciA9IChjb2xvciArIDEpICUgNTtcbiAgICAgIH0gZWxzZSBpZiAoY2h1bmsuc3Vic3RyKC01KSA9PT0gXCJyZ2JhKFwiIHx8IGNodW5rLnN1YnN0cigtNSkgPT09IFwiaHNsYShcIikge1xuICAgICAgICBjb2xvciA9IDE7XG4gICAgICB9XG5cbiAgICAgIGlmIChlbmRWYWx1ZSAhPT0gKHN0YXJ0VmFsdWUgPSBzdGFydFZhbHVlc1ttYXRjaEluZGV4KytdIHx8IFwiXCIpKSB7XG4gICAgICAgIHN0YXJ0TnVtID0gcGFyc2VGbG9hdChzdGFydFZhbHVlKSB8fCAwO1xuICAgICAgICBzdGFydFVuaXQgPSBzdGFydFZhbHVlLnN1YnN0cigoc3RhcnROdW0gKyBcIlwiKS5sZW5ndGgpO1xuICAgICAgICBlbmRWYWx1ZS5jaGFyQXQoMSkgPT09IFwiPVwiICYmIChlbmRWYWx1ZSA9IF9wYXJzZVJlbGF0aXZlKHN0YXJ0TnVtLCBlbmRWYWx1ZSkgKyBzdGFydFVuaXQpO1xuICAgICAgICBlbmROdW0gPSBwYXJzZUZsb2F0KGVuZFZhbHVlKTtcbiAgICAgICAgZW5kVW5pdCA9IGVuZFZhbHVlLnN1YnN0cigoZW5kTnVtICsgXCJcIikubGVuZ3RoKTtcbiAgICAgICAgaW5kZXggPSBfbnVtV2l0aFVuaXRFeHAubGFzdEluZGV4IC0gZW5kVW5pdC5sZW5ndGg7XG5cbiAgICAgICAgaWYgKCFlbmRVbml0KSB7XG4gICAgICAgICAgLy9pZiBzb21ldGhpbmcgbGlrZSBcInBlcnNwZWN0aXZlOjMwMFwiIGlzIHBhc3NlZCBpbiBhbmQgd2UgbXVzdCBhZGQgYSB1bml0IHRvIHRoZSBlbmRcbiAgICAgICAgICBlbmRVbml0ID0gZW5kVW5pdCB8fCBfY29uZmlnLnVuaXRzW3Byb3BdIHx8IHN0YXJ0VW5pdDtcblxuICAgICAgICAgIGlmIChpbmRleCA9PT0gZW5kLmxlbmd0aCkge1xuICAgICAgICAgICAgZW5kICs9IGVuZFVuaXQ7XG4gICAgICAgICAgICBwdC5lICs9IGVuZFVuaXQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHN0YXJ0VW5pdCAhPT0gZW5kVW5pdCkge1xuICAgICAgICAgIHN0YXJ0TnVtID0gX2NvbnZlcnRUb1VuaXQodGFyZ2V0LCBwcm9wLCBzdGFydFZhbHVlLCBlbmRVbml0KSB8fCAwO1xuICAgICAgICB9IC8vIHRoZXNlIG5lc3RlZCBQcm9wVHdlZW5zIGFyZSBoYW5kbGVkIGluIGEgc3BlY2lhbCB3YXkgLSB3ZSdsbCBuZXZlciBhY3R1YWxseSBjYWxsIGEgcmVuZGVyIG9yIHNldHRlciBtZXRob2Qgb24gdGhlbS4gV2UnbGwganVzdCBsb29wIHRocm91Z2ggdGhlbSBpbiB0aGUgcGFyZW50IGNvbXBsZXggc3RyaW5nIFByb3BUd2VlbidzIHJlbmRlciBtZXRob2QuXG5cblxuICAgICAgICBwdC5fcHQgPSB7XG4gICAgICAgICAgX25leHQ6IHB0Ll9wdCxcbiAgICAgICAgICBwOiBjaHVuayB8fCBtYXRjaEluZGV4ID09PSAxID8gY2h1bmsgOiBcIixcIixcbiAgICAgICAgICAvL25vdGU6IFNWRyBzcGVjIGFsbG93cyBvbWlzc2lvbiBvZiBjb21tYS9zcGFjZSB3aGVuIGEgbmVnYXRpdmUgc2lnbiBpcyB3ZWRnZWQgYmV0d2VlbiB0d28gbnVtYmVycywgbGlrZSAyLjUtNS4zIGluc3RlYWQgb2YgMi41LC01LjMgYnV0IHdoZW4gdHdlZW5pbmcsIHRoZSBuZWdhdGl2ZSB2YWx1ZSBtYXkgc3dpdGNoIHRvIHBvc2l0aXZlLCBzbyB3ZSBpbnNlcnQgdGhlIGNvbW1hIGp1c3QgaW4gY2FzZS5cbiAgICAgICAgICBzOiBzdGFydE51bSxcbiAgICAgICAgICBjOiBlbmROdW0gLSBzdGFydE51bSxcbiAgICAgICAgICBtOiBjb2xvciAmJiBjb2xvciA8IDQgfHwgcHJvcCA9PT0gXCJ6SW5kZXhcIiA/IE1hdGgucm91bmQgOiAwXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuXG4gICAgcHQuYyA9IGluZGV4IDwgZW5kLmxlbmd0aCA/IGVuZC5zdWJzdHJpbmcoaW5kZXgsIGVuZC5sZW5ndGgpIDogXCJcIjsgLy93ZSB1c2UgdGhlIFwiY1wiIG9mIHRoZSBQcm9wVHdlZW4gdG8gc3RvcmUgdGhlIGZpbmFsIHBhcnQgb2YgdGhlIHN0cmluZyAoYWZ0ZXIgdGhlIGxhc3QgbnVtYmVyKVxuICB9IGVsc2Uge1xuICAgIHB0LnIgPSBwcm9wID09PSBcImRpc3BsYXlcIiAmJiBlbmQgPT09IFwibm9uZVwiID8gX3JlbmRlck5vblR3ZWVuaW5nVmFsdWVPbmx5QXRFbmQgOiBfcmVuZGVyTm9uVHdlZW5pbmdWYWx1ZTtcbiAgfVxuXG4gIF9yZWxFeHAudGVzdChlbmQpICYmIChwdC5lID0gMCk7IC8vaWYgdGhlIGVuZCBzdHJpbmcgY29udGFpbnMgcmVsYXRpdmUgdmFsdWVzIG9yIGR5bmFtaWMgcmFuZG9tKC4uLikgdmFsdWVzLCBkZWxldGUgdGhlIGVuZCBpdCBzbyB0aGF0IG9uIHRoZSBmaW5hbCByZW5kZXIgd2UgZG9uJ3QgYWN0dWFsbHkgc2V0IGl0IHRvIHRoZSBzdHJpbmcgd2l0aCArPSBvciAtPSBjaGFyYWN0ZXJzIChmb3JjZXMgaXQgdG8gdXNlIHRoZSBjYWxjdWxhdGVkIHZhbHVlKS5cblxuICB0aGlzLl9wdCA9IHB0OyAvL3N0YXJ0IHRoZSBsaW5rZWQgbGlzdCB3aXRoIHRoaXMgbmV3IFByb3BUd2Vlbi4gUmVtZW1iZXIsIHdlIGNhbGwgX3R3ZWVuQ29tcGxleENTU1N0cmluZy5jYWxsKHBsdWdpbkluc3RhbmNlLi4uKSB0byBlbnN1cmUgdGhhdCBpdCdzIHNjb3BlZCBwcm9wZXJseS4gV2UgbWF5IGNhbGwgaXQgZnJvbSB3aXRoaW4gYW5vdGhlciBwbHVnaW4gdG9vLCB0aHVzIFwidGhpc1wiIHdvdWxkIHJlZmVyIHRvIHRoZSBwbHVnaW4uXG5cbiAgcmV0dXJuIHB0O1xufSxcbiAgICBfa2V5d29yZFRvUGVyY2VudCA9IHtcbiAgdG9wOiBcIjAlXCIsXG4gIGJvdHRvbTogXCIxMDAlXCIsXG4gIGxlZnQ6IFwiMCVcIixcbiAgcmlnaHQ6IFwiMTAwJVwiLFxuICBjZW50ZXI6IFwiNTAlXCJcbn0sXG4gICAgX2NvbnZlcnRLZXl3b3Jkc1RvUGVyY2VudGFnZXMgPSBmdW5jdGlvbiBfY29udmVydEtleXdvcmRzVG9QZXJjZW50YWdlcyh2YWx1ZSkge1xuICB2YXIgc3BsaXQgPSB2YWx1ZS5zcGxpdChcIiBcIiksXG4gICAgICB4ID0gc3BsaXRbMF0sXG4gICAgICB5ID0gc3BsaXRbMV0gfHwgXCI1MCVcIjtcblxuICBpZiAoeCA9PT0gXCJ0b3BcIiB8fCB4ID09PSBcImJvdHRvbVwiIHx8IHkgPT09IFwibGVmdFwiIHx8IHkgPT09IFwicmlnaHRcIikge1xuICAgIC8vdGhlIHVzZXIgcHJvdmlkZWQgdGhlbSBpbiB0aGUgd3Jvbmcgb3JkZXIsIHNvIGZsaXAgdGhlbVxuICAgIHZhbHVlID0geDtcbiAgICB4ID0geTtcbiAgICB5ID0gdmFsdWU7XG4gIH1cblxuICBzcGxpdFswXSA9IF9rZXl3b3JkVG9QZXJjZW50W3hdIHx8IHg7XG4gIHNwbGl0WzFdID0gX2tleXdvcmRUb1BlcmNlbnRbeV0gfHwgeTtcbiAgcmV0dXJuIHNwbGl0LmpvaW4oXCIgXCIpO1xufSxcbiAgICBfcmVuZGVyQ2xlYXJQcm9wcyA9IGZ1bmN0aW9uIF9yZW5kZXJDbGVhclByb3BzKHJhdGlvLCBkYXRhKSB7XG4gIGlmIChkYXRhLnR3ZWVuICYmIGRhdGEudHdlZW4uX3RpbWUgPT09IGRhdGEudHdlZW4uX2R1cikge1xuICAgIHZhciB0YXJnZXQgPSBkYXRhLnQsXG4gICAgICAgIHN0eWxlID0gdGFyZ2V0LnN0eWxlLFxuICAgICAgICBwcm9wcyA9IGRhdGEudSxcbiAgICAgICAgY2FjaGUgPSB0YXJnZXQuX2dzYXAsXG4gICAgICAgIHByb3AsXG4gICAgICAgIGNsZWFyVHJhbnNmb3JtcyxcbiAgICAgICAgaTtcblxuICAgIGlmIChwcm9wcyA9PT0gXCJhbGxcIiB8fCBwcm9wcyA9PT0gdHJ1ZSkge1xuICAgICAgc3R5bGUuY3NzVGV4dCA9IFwiXCI7XG4gICAgICBjbGVhclRyYW5zZm9ybXMgPSAxO1xuICAgIH0gZWxzZSB7XG4gICAgICBwcm9wcyA9IHByb3BzLnNwbGl0KFwiLFwiKTtcbiAgICAgIGkgPSBwcm9wcy5sZW5ndGg7XG5cbiAgICAgIHdoaWxlICgtLWkgPiAtMSkge1xuICAgICAgICBwcm9wID0gcHJvcHNbaV07XG5cbiAgICAgICAgaWYgKF90cmFuc2Zvcm1Qcm9wc1twcm9wXSkge1xuICAgICAgICAgIGNsZWFyVHJhbnNmb3JtcyA9IDE7XG4gICAgICAgICAgcHJvcCA9IHByb3AgPT09IFwidHJhbnNmb3JtT3JpZ2luXCIgPyBfdHJhbnNmb3JtT3JpZ2luUHJvcCA6IF90cmFuc2Zvcm1Qcm9wO1xuICAgICAgICB9XG5cbiAgICAgICAgX3JlbW92ZVByb3BlcnR5KHRhcmdldCwgcHJvcCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGNsZWFyVHJhbnNmb3Jtcykge1xuICAgICAgX3JlbW92ZVByb3BlcnR5KHRhcmdldCwgX3RyYW5zZm9ybVByb3ApO1xuXG4gICAgICBpZiAoY2FjaGUpIHtcbiAgICAgICAgY2FjaGUuc3ZnICYmIHRhcmdldC5yZW1vdmVBdHRyaWJ1dGUoXCJ0cmFuc2Zvcm1cIik7XG5cbiAgICAgICAgX3BhcnNlVHJhbnNmb3JtKHRhcmdldCwgMSk7IC8vIGZvcmNlIGFsbCB0aGUgY2FjaGVkIHZhbHVlcyBiYWNrIHRvIFwibm9ybWFsXCIvaWRlbnRpdHksIG90aGVyd2lzZSBpZiB0aGVyZSdzIGFub3RoZXIgdHdlZW4gdGhhdCdzIGFscmVhZHkgc2V0IHRvIHJlbmRlciB0cmFuc2Zvcm1zIG9uIHRoaXMgZWxlbWVudCwgaXQgY291bGQgZGlzcGxheSB0aGUgd3JvbmcgdmFsdWVzLlxuXG5cbiAgICAgICAgY2FjaGUudW5jYWNoZSA9IDE7XG4gICAgICB9XG4gICAgfVxuICB9XG59LFxuICAgIC8vIG5vdGU6IHNwZWNpYWxQcm9wcyBzaG91bGQgcmV0dXJuIDEgaWYgKGFuZCBvbmx5IGlmKSB0aGV5IGhhdmUgYSBub24temVybyBwcmlvcml0eS4gSXQgaW5kaWNhdGVzIHdlIG5lZWQgdG8gc29ydCB0aGUgbGlua2VkIGxpc3QuXG5fc3BlY2lhbFByb3BzID0ge1xuICBjbGVhclByb3BzOiBmdW5jdGlvbiBjbGVhclByb3BzKHBsdWdpbiwgdGFyZ2V0LCBwcm9wZXJ0eSwgZW5kVmFsdWUsIHR3ZWVuKSB7XG4gICAgaWYgKHR3ZWVuLmRhdGEgIT09IFwiaXNGcm9tU3RhcnRcIikge1xuICAgICAgdmFyIHB0ID0gcGx1Z2luLl9wdCA9IG5ldyBQcm9wVHdlZW4ocGx1Z2luLl9wdCwgdGFyZ2V0LCBwcm9wZXJ0eSwgMCwgMCwgX3JlbmRlckNsZWFyUHJvcHMpO1xuICAgICAgcHQudSA9IGVuZFZhbHVlO1xuICAgICAgcHQucHIgPSAtMTA7XG4gICAgICBwdC50d2VlbiA9IHR3ZWVuO1xuXG4gICAgICBwbHVnaW4uX3Byb3BzLnB1c2gocHJvcGVydHkpO1xuXG4gICAgICByZXR1cm4gMTtcbiAgICB9XG4gIH1cbiAgLyogY2xhc3NOYW1lIGZlYXR1cmUgKGFib3V0IDAuNGtiIGd6aXBwZWQpLlxuICAsIGNsYXNzTmFtZShwbHVnaW4sIHRhcmdldCwgcHJvcGVydHksIGVuZFZhbHVlLCB0d2Vlbikge1xuICBcdGxldCBfcmVuZGVyQ2xhc3NOYW1lID0gKHJhdGlvLCBkYXRhKSA9PiB7XG4gIFx0XHRcdGRhdGEuY3NzLnJlbmRlcihyYXRpbywgZGF0YS5jc3MpO1xuICBcdFx0XHRpZiAoIXJhdGlvIHx8IHJhdGlvID09PSAxKSB7XG4gIFx0XHRcdFx0bGV0IGlubGluZSA9IGRhdGEucm12LFxuICBcdFx0XHRcdFx0dGFyZ2V0ID0gZGF0YS50LFxuICBcdFx0XHRcdFx0cDtcbiAgXHRcdFx0XHR0YXJnZXQuc2V0QXR0cmlidXRlKFwiY2xhc3NcIiwgcmF0aW8gPyBkYXRhLmUgOiBkYXRhLmIpO1xuICBcdFx0XHRcdGZvciAocCBpbiBpbmxpbmUpIHtcbiAgXHRcdFx0XHRcdF9yZW1vdmVQcm9wZXJ0eSh0YXJnZXQsIHApO1xuICBcdFx0XHRcdH1cbiAgXHRcdFx0fVxuICBcdFx0fSxcbiAgXHRcdF9nZXRBbGxTdHlsZXMgPSAodGFyZ2V0KSA9PiB7XG4gIFx0XHRcdGxldCBzdHlsZXMgPSB7fSxcbiAgXHRcdFx0XHRjb21wdXRlZCA9IGdldENvbXB1dGVkU3R5bGUodGFyZ2V0KSxcbiAgXHRcdFx0XHRwO1xuICBcdFx0XHRmb3IgKHAgaW4gY29tcHV0ZWQpIHtcbiAgXHRcdFx0XHRpZiAoaXNOYU4ocCkgJiYgcCAhPT0gXCJjc3NUZXh0XCIgJiYgcCAhPT0gXCJsZW5ndGhcIikge1xuICBcdFx0XHRcdFx0c3R5bGVzW3BdID0gY29tcHV0ZWRbcF07XG4gIFx0XHRcdFx0fVxuICBcdFx0XHR9XG4gIFx0XHRcdF9zZXREZWZhdWx0cyhzdHlsZXMsIF9wYXJzZVRyYW5zZm9ybSh0YXJnZXQsIDEpKTtcbiAgXHRcdFx0cmV0dXJuIHN0eWxlcztcbiAgXHRcdH0sXG4gIFx0XHRzdGFydENsYXNzTGlzdCA9IHRhcmdldC5nZXRBdHRyaWJ1dGUoXCJjbGFzc1wiKSxcbiAgXHRcdHN0eWxlID0gdGFyZ2V0LnN0eWxlLFxuICBcdFx0Y3NzVGV4dCA9IHN0eWxlLmNzc1RleHQsXG4gIFx0XHRjYWNoZSA9IHRhcmdldC5fZ3NhcCxcbiAgXHRcdGNsYXNzUFQgPSBjYWNoZS5jbGFzc1BULFxuICBcdFx0aW5saW5lVG9SZW1vdmVBdEVuZCA9IHt9LFxuICBcdFx0ZGF0YSA9IHt0OnRhcmdldCwgcGx1Z2luOnBsdWdpbiwgcm12OmlubGluZVRvUmVtb3ZlQXRFbmQsIGI6c3RhcnRDbGFzc0xpc3QsIGU6KGVuZFZhbHVlLmNoYXJBdCgxKSAhPT0gXCI9XCIpID8gZW5kVmFsdWUgOiBzdGFydENsYXNzTGlzdC5yZXBsYWNlKG5ldyBSZWdFeHAoXCIoPzpcXFxcc3xeKVwiICsgZW5kVmFsdWUuc3Vic3RyKDIpICsgXCIoPyFbXFxcXHctXSlcIiksIFwiXCIpICsgKChlbmRWYWx1ZS5jaGFyQXQoMCkgPT09IFwiK1wiKSA/IFwiIFwiICsgZW5kVmFsdWUuc3Vic3RyKDIpIDogXCJcIil9LFxuICBcdFx0Y2hhbmdpbmdWYXJzID0ge30sXG4gIFx0XHRzdGFydFZhcnMgPSBfZ2V0QWxsU3R5bGVzKHRhcmdldCksXG4gIFx0XHR0cmFuc2Zvcm1SZWxhdGVkID0gLyh0cmFuc2Zvcm18cGVyc3BlY3RpdmUpL2ksXG4gIFx0XHRlbmRWYXJzLCBwO1xuICBcdGlmIChjbGFzc1BUKSB7XG4gIFx0XHRjbGFzc1BULnIoMSwgY2xhc3NQVC5kKTtcbiAgXHRcdF9yZW1vdmVMaW5rZWRMaXN0SXRlbShjbGFzc1BULmQucGx1Z2luLCBjbGFzc1BULCBcIl9wdFwiKTtcbiAgXHR9XG4gIFx0dGFyZ2V0LnNldEF0dHJpYnV0ZShcImNsYXNzXCIsIGRhdGEuZSk7XG4gIFx0ZW5kVmFycyA9IF9nZXRBbGxTdHlsZXModGFyZ2V0LCB0cnVlKTtcbiAgXHR0YXJnZXQuc2V0QXR0cmlidXRlKFwiY2xhc3NcIiwgc3RhcnRDbGFzc0xpc3QpO1xuICBcdGZvciAocCBpbiBlbmRWYXJzKSB7XG4gIFx0XHRpZiAoZW5kVmFyc1twXSAhPT0gc3RhcnRWYXJzW3BdICYmICF0cmFuc2Zvcm1SZWxhdGVkLnRlc3QocCkpIHtcbiAgXHRcdFx0Y2hhbmdpbmdWYXJzW3BdID0gZW5kVmFyc1twXTtcbiAgXHRcdFx0aWYgKCFzdHlsZVtwXSAmJiBzdHlsZVtwXSAhPT0gXCIwXCIpIHtcbiAgXHRcdFx0XHRpbmxpbmVUb1JlbW92ZUF0RW5kW3BdID0gMTtcbiAgXHRcdFx0fVxuICBcdFx0fVxuICBcdH1cbiAgXHRjYWNoZS5jbGFzc1BUID0gcGx1Z2luLl9wdCA9IG5ldyBQcm9wVHdlZW4ocGx1Z2luLl9wdCwgdGFyZ2V0LCBcImNsYXNzTmFtZVwiLCAwLCAwLCBfcmVuZGVyQ2xhc3NOYW1lLCBkYXRhLCAwLCAtMTEpO1xuICBcdGlmIChzdHlsZS5jc3NUZXh0ICE9PSBjc3NUZXh0KSB7IC8vb25seSBhcHBseSBpZiB0aGluZ3MgY2hhbmdlLiBPdGhlcndpc2UsIGluIGNhc2VzIGxpa2UgYSBiYWNrZ3JvdW5kLWltYWdlIHRoYXQncyBwdWxsZWQgZHluYW1pY2FsbHksIGl0IGNvdWxkIGNhdXNlIGEgcmVmcmVzaC4gU2VlIGh0dHBzOi8vZ3JlZW5zb2NrLmNvbS9mb3J1bXMvdG9waWMvMjAzNjgtcG9zc2libGUtZ3NhcC1idWctc3dpdGNoaW5nLWNsYXNzbmFtZXMtaW4tY2hyb21lLy5cbiAgXHRcdHN0eWxlLmNzc1RleHQgPSBjc3NUZXh0OyAvL3dlIHJlY29yZGVkIGNzc1RleHQgYmVmb3JlIHdlIHN3YXBwZWQgY2xhc3NlcyBhbmQgcmFuIF9nZXRBbGxTdHlsZXMoKSBiZWNhdXNlIGluIGNhc2VzIHdoZW4gYSBjbGFzc05hbWUgdHdlZW4gaXMgb3ZlcndyaXR0ZW4sIHdlIHJlbW92ZSBhbGwgdGhlIHJlbGF0ZWQgdHdlZW5pbmcgcHJvcGVydGllcyBmcm9tIHRoYXQgY2xhc3MgY2hhbmdlIChvdGhlcndpc2UgY2xhc3Mtc3BlY2lmaWMgc3R1ZmYgY2FuJ3Qgb3ZlcnJpZGUgcHJvcGVydGllcyB3ZSd2ZSBkaXJlY3RseSBzZXQgb24gdGhlIHRhcmdldCdzIHN0eWxlIG9iamVjdCBkdWUgdG8gc3BlY2lmaWNpdHkpLlxuICBcdH1cbiAgXHRfcGFyc2VUcmFuc2Zvcm0odGFyZ2V0LCB0cnVlKTsgLy90byBjbGVhciB0aGUgY2FjaGluZyBvZiB0cmFuc2Zvcm1zXG4gIFx0ZGF0YS5jc3MgPSBuZXcgZ3NhcC5wbHVnaW5zLmNzcygpO1xuICBcdGRhdGEuY3NzLmluaXQodGFyZ2V0LCBjaGFuZ2luZ1ZhcnMsIHR3ZWVuKTtcbiAgXHRwbHVnaW4uX3Byb3BzLnB1c2goLi4uZGF0YS5jc3MuX3Byb3BzKTtcbiAgXHRyZXR1cm4gMTtcbiAgfVxuICAqL1xuXG59LFxuXG4vKlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIFRSQU5TRk9STVNcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKi9cbl9pZGVudGl0eTJETWF0cml4ID0gWzEsIDAsIDAsIDEsIDAsIDBdLFxuICAgIF9yb3RhdGlvbmFsUHJvcGVydGllcyA9IHt9LFxuICAgIF9pc051bGxUcmFuc2Zvcm0gPSBmdW5jdGlvbiBfaXNOdWxsVHJhbnNmb3JtKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSA9PT0gXCJtYXRyaXgoMSwgMCwgMCwgMSwgMCwgMClcIiB8fCB2YWx1ZSA9PT0gXCJub25lXCIgfHwgIXZhbHVlO1xufSxcbiAgICBfZ2V0Q29tcHV0ZWRUcmFuc2Zvcm1NYXRyaXhBc0FycmF5ID0gZnVuY3Rpb24gX2dldENvbXB1dGVkVHJhbnNmb3JtTWF0cml4QXNBcnJheSh0YXJnZXQpIHtcbiAgdmFyIG1hdHJpeFN0cmluZyA9IF9nZXRDb21wdXRlZFByb3BlcnR5KHRhcmdldCwgX3RyYW5zZm9ybVByb3ApO1xuXG4gIHJldHVybiBfaXNOdWxsVHJhbnNmb3JtKG1hdHJpeFN0cmluZykgPyBfaWRlbnRpdHkyRE1hdHJpeCA6IG1hdHJpeFN0cmluZy5zdWJzdHIoNykubWF0Y2goX251bUV4cCkubWFwKF9yb3VuZCk7XG59LFxuICAgIF9nZXRNYXRyaXggPSBmdW5jdGlvbiBfZ2V0TWF0cml4KHRhcmdldCwgZm9yY2UyRCkge1xuICB2YXIgY2FjaGUgPSB0YXJnZXQuX2dzYXAgfHwgX2dldENhY2hlKHRhcmdldCksXG4gICAgICBzdHlsZSA9IHRhcmdldC5zdHlsZSxcbiAgICAgIG1hdHJpeCA9IF9nZXRDb21wdXRlZFRyYW5zZm9ybU1hdHJpeEFzQXJyYXkodGFyZ2V0KSxcbiAgICAgIHBhcmVudCxcbiAgICAgIG5leHRTaWJsaW5nLFxuICAgICAgdGVtcCxcbiAgICAgIGFkZGVkVG9ET007XG5cbiAgaWYgKGNhY2hlLnN2ZyAmJiB0YXJnZXQuZ2V0QXR0cmlidXRlKFwidHJhbnNmb3JtXCIpKSB7XG4gICAgdGVtcCA9IHRhcmdldC50cmFuc2Zvcm0uYmFzZVZhbC5jb25zb2xpZGF0ZSgpLm1hdHJpeDsgLy9lbnN1cmVzIHRoYXQgZXZlbiBjb21wbGV4IHZhbHVlcyBsaWtlIFwidHJhbnNsYXRlKDUwLDYwKSByb3RhdGUoMTM1LDAsMClcIiBhcmUgcGFyc2VkIGJlY2F1c2UgaXQgbWFzaGVzIGl0IGludG8gYSBtYXRyaXguXG5cbiAgICBtYXRyaXggPSBbdGVtcC5hLCB0ZW1wLmIsIHRlbXAuYywgdGVtcC5kLCB0ZW1wLmUsIHRlbXAuZl07XG4gICAgcmV0dXJuIG1hdHJpeC5qb2luKFwiLFwiKSA9PT0gXCIxLDAsMCwxLDAsMFwiID8gX2lkZW50aXR5MkRNYXRyaXggOiBtYXRyaXg7XG4gIH0gZWxzZSBpZiAobWF0cml4ID09PSBfaWRlbnRpdHkyRE1hdHJpeCAmJiAhdGFyZ2V0Lm9mZnNldFBhcmVudCAmJiB0YXJnZXQgIT09IF9kb2NFbGVtZW50ICYmICFjYWNoZS5zdmcpIHtcbiAgICAvL25vdGU6IGlmIG9mZnNldFBhcmVudCBpcyBudWxsLCB0aGF0IG1lYW5zIHRoZSBlbGVtZW50IGlzbid0IGluIHRoZSBub3JtYWwgZG9jdW1lbnQgZmxvdywgbGlrZSBpZiBpdCBoYXMgZGlzcGxheTpub25lIG9yIG9uZSBvZiBpdHMgYW5jZXN0b3JzIGhhcyBkaXNwbGF5Om5vbmUpLiBGaXJlZm94IHJldHVybnMgbnVsbCBmb3IgZ2V0Q29tcHV0ZWRTdHlsZSgpIGlmIHRoZSBlbGVtZW50IGlzIGluIGFuIGlmcmFtZSB0aGF0IGhhcyBkaXNwbGF5Om5vbmUuIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTU0ODM5N1xuICAgIC8vYnJvd3NlcnMgZG9uJ3QgcmVwb3J0IHRyYW5zZm9ybXMgYWNjdXJhdGVseSB1bmxlc3MgdGhlIGVsZW1lbnQgaXMgaW4gdGhlIERPTSBhbmQgaGFzIGEgZGlzcGxheSB2YWx1ZSB0aGF0J3Mgbm90IFwibm9uZVwiLiBGaXJlZm94IGFuZCBNaWNyb3NvZnQgYnJvd3NlcnMgaGF2ZSBhIHBhcnRpYWwgYnVnIHdoZXJlIHRoZXknbGwgcmVwb3J0IHRyYW5zZm9ybXMgZXZlbiBpZiBkaXNwbGF5Om5vbmUgQlVUIG5vdCBhbnkgcGVyY2VudGFnZS1iYXNlZCB2YWx1ZXMgbGlrZSB0cmFuc2xhdGUoLTUwJSwgOHB4KSB3aWxsIGJlIHJlcG9ydGVkIGFzIGlmIGl0J3MgdHJhbnNsYXRlKDAsIDhweCkuXG4gICAgdGVtcCA9IHN0eWxlLmRpc3BsYXk7XG4gICAgc3R5bGUuZGlzcGxheSA9IFwiYmxvY2tcIjtcbiAgICBwYXJlbnQgPSB0YXJnZXQucGFyZW50Tm9kZTtcblxuICAgIGlmICghcGFyZW50IHx8ICF0YXJnZXQub2Zmc2V0UGFyZW50KSB7XG4gICAgICAvLyBub3RlOiBpbiAzLjMuMCB3ZSBzd2l0Y2hlZCB0YXJnZXQub2Zmc2V0UGFyZW50IHRvIF9kb2MuYm9keS5jb250YWlucyh0YXJnZXQpIHRvIGF2b2lkIFtzb21ldGltZXMgdW5uZWNlc3NhcnldIE11dGF0aW9uT2JzZXJ2ZXIgY2FsbHMgYnV0IHRoYXQgd2Fzbid0IGFkZXF1YXRlIGJlY2F1c2UgdGhlcmUgYXJlIGVkZ2UgY2FzZXMgd2hlcmUgbmVzdGVkIHBvc2l0aW9uOiBmaXhlZCBlbGVtZW50cyBuZWVkIHRvIGdldCByZXBhcmVudGVkIHRvIGFjY3VyYXRlbHkgc2Vuc2UgdHJhbnNmb3Jtcy4gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9ncmVlbnNvY2svR1NBUC9pc3N1ZXMvMzg4IGFuZCBodHRwczovL2dpdGh1Yi5jb20vZ3JlZW5zb2NrL0dTQVAvaXNzdWVzLzM3NVxuICAgICAgYWRkZWRUb0RPTSA9IDE7IC8vZmxhZ1xuXG4gICAgICBuZXh0U2libGluZyA9IHRhcmdldC5uZXh0U2libGluZztcblxuICAgICAgX2RvY0VsZW1lbnQuYXBwZW5kQ2hpbGQodGFyZ2V0KTsgLy93ZSBtdXN0IGFkZCBpdCB0byB0aGUgRE9NIGluIG9yZGVyIHRvIGdldCB2YWx1ZXMgcHJvcGVybHlcblxuICAgIH1cblxuICAgIG1hdHJpeCA9IF9nZXRDb21wdXRlZFRyYW5zZm9ybU1hdHJpeEFzQXJyYXkodGFyZ2V0KTtcbiAgICB0ZW1wID8gc3R5bGUuZGlzcGxheSA9IHRlbXAgOiBfcmVtb3ZlUHJvcGVydHkodGFyZ2V0LCBcImRpc3BsYXlcIik7XG5cbiAgICBpZiAoYWRkZWRUb0RPTSkge1xuICAgICAgbmV4dFNpYmxpbmcgPyBwYXJlbnQuaW5zZXJ0QmVmb3JlKHRhcmdldCwgbmV4dFNpYmxpbmcpIDogcGFyZW50ID8gcGFyZW50LmFwcGVuZENoaWxkKHRhcmdldCkgOiBfZG9jRWxlbWVudC5yZW1vdmVDaGlsZCh0YXJnZXQpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmb3JjZTJEICYmIG1hdHJpeC5sZW5ndGggPiA2ID8gW21hdHJpeFswXSwgbWF0cml4WzFdLCBtYXRyaXhbNF0sIG1hdHJpeFs1XSwgbWF0cml4WzEyXSwgbWF0cml4WzEzXV0gOiBtYXRyaXg7XG59LFxuICAgIF9hcHBseVNWR09yaWdpbiA9IGZ1bmN0aW9uIF9hcHBseVNWR09yaWdpbih0YXJnZXQsIG9yaWdpbiwgb3JpZ2luSXNBYnNvbHV0ZSwgc21vb3RoLCBtYXRyaXhBcnJheSwgcGx1Z2luVG9BZGRQcm9wVHdlZW5zVG8pIHtcbiAgdmFyIGNhY2hlID0gdGFyZ2V0Ll9nc2FwLFxuICAgICAgbWF0cml4ID0gbWF0cml4QXJyYXkgfHwgX2dldE1hdHJpeCh0YXJnZXQsIHRydWUpLFxuICAgICAgeE9yaWdpbk9sZCA9IGNhY2hlLnhPcmlnaW4gfHwgMCxcbiAgICAgIHlPcmlnaW5PbGQgPSBjYWNoZS55T3JpZ2luIHx8IDAsXG4gICAgICB4T2Zmc2V0T2xkID0gY2FjaGUueE9mZnNldCB8fCAwLFxuICAgICAgeU9mZnNldE9sZCA9IGNhY2hlLnlPZmZzZXQgfHwgMCxcbiAgICAgIGEgPSBtYXRyaXhbMF0sXG4gICAgICBiID0gbWF0cml4WzFdLFxuICAgICAgYyA9IG1hdHJpeFsyXSxcbiAgICAgIGQgPSBtYXRyaXhbM10sXG4gICAgICB0eCA9IG1hdHJpeFs0XSxcbiAgICAgIHR5ID0gbWF0cml4WzVdLFxuICAgICAgb3JpZ2luU3BsaXQgPSBvcmlnaW4uc3BsaXQoXCIgXCIpLFxuICAgICAgeE9yaWdpbiA9IHBhcnNlRmxvYXQob3JpZ2luU3BsaXRbMF0pIHx8IDAsXG4gICAgICB5T3JpZ2luID0gcGFyc2VGbG9hdChvcmlnaW5TcGxpdFsxXSkgfHwgMCxcbiAgICAgIGJvdW5kcyxcbiAgICAgIGRldGVybWluYW50LFxuICAgICAgeCxcbiAgICAgIHk7XG5cbiAgaWYgKCFvcmlnaW5Jc0Fic29sdXRlKSB7XG4gICAgYm91bmRzID0gX2dldEJCb3godGFyZ2V0KTtcbiAgICB4T3JpZ2luID0gYm91bmRzLnggKyAofm9yaWdpblNwbGl0WzBdLmluZGV4T2YoXCIlXCIpID8geE9yaWdpbiAvIDEwMCAqIGJvdW5kcy53aWR0aCA6IHhPcmlnaW4pO1xuICAgIHlPcmlnaW4gPSBib3VuZHMueSArICh+KG9yaWdpblNwbGl0WzFdIHx8IG9yaWdpblNwbGl0WzBdKS5pbmRleE9mKFwiJVwiKSA/IHlPcmlnaW4gLyAxMDAgKiBib3VuZHMuaGVpZ2h0IDogeU9yaWdpbik7XG4gIH0gZWxzZSBpZiAobWF0cml4ICE9PSBfaWRlbnRpdHkyRE1hdHJpeCAmJiAoZGV0ZXJtaW5hbnQgPSBhICogZCAtIGIgKiBjKSkge1xuICAgIC8vaWYgaXQncyB6ZXJvIChsaWtlIGlmIHNjYWxlWCBhbmQgc2NhbGVZIGFyZSB6ZXJvKSwgc2tpcCBpdCB0byBhdm9pZCBlcnJvcnMgd2l0aCBkaXZpZGluZyBieSB6ZXJvLlxuICAgIHggPSB4T3JpZ2luICogKGQgLyBkZXRlcm1pbmFudCkgKyB5T3JpZ2luICogKC1jIC8gZGV0ZXJtaW5hbnQpICsgKGMgKiB0eSAtIGQgKiB0eCkgLyBkZXRlcm1pbmFudDtcbiAgICB5ID0geE9yaWdpbiAqICgtYiAvIGRldGVybWluYW50KSArIHlPcmlnaW4gKiAoYSAvIGRldGVybWluYW50KSAtIChhICogdHkgLSBiICogdHgpIC8gZGV0ZXJtaW5hbnQ7XG4gICAgeE9yaWdpbiA9IHg7XG4gICAgeU9yaWdpbiA9IHk7XG4gIH1cblxuICBpZiAoc21vb3RoIHx8IHNtb290aCAhPT0gZmFsc2UgJiYgY2FjaGUuc21vb3RoKSB7XG4gICAgdHggPSB4T3JpZ2luIC0geE9yaWdpbk9sZDtcbiAgICB0eSA9IHlPcmlnaW4gLSB5T3JpZ2luT2xkO1xuICAgIGNhY2hlLnhPZmZzZXQgPSB4T2Zmc2V0T2xkICsgKHR4ICogYSArIHR5ICogYykgLSB0eDtcbiAgICBjYWNoZS55T2Zmc2V0ID0geU9mZnNldE9sZCArICh0eCAqIGIgKyB0eSAqIGQpIC0gdHk7XG4gIH0gZWxzZSB7XG4gICAgY2FjaGUueE9mZnNldCA9IGNhY2hlLnlPZmZzZXQgPSAwO1xuICB9XG5cbiAgY2FjaGUueE9yaWdpbiA9IHhPcmlnaW47XG4gIGNhY2hlLnlPcmlnaW4gPSB5T3JpZ2luO1xuICBjYWNoZS5zbW9vdGggPSAhIXNtb290aDtcbiAgY2FjaGUub3JpZ2luID0gb3JpZ2luO1xuICBjYWNoZS5vcmlnaW5Jc0Fic29sdXRlID0gISFvcmlnaW5Jc0Fic29sdXRlO1xuICB0YXJnZXQuc3R5bGVbX3RyYW5zZm9ybU9yaWdpblByb3BdID0gXCIwcHggMHB4XCI7IC8vb3RoZXJ3aXNlLCBpZiBzb21lb25lIHNldHMgIGFuIG9yaWdpbiB2aWEgQ1NTLCBpdCB3aWxsIGxpa2VseSBpbnRlcmZlcmUgd2l0aCB0aGUgU1ZHIHRyYW5zZm9ybSBhdHRyaWJ1dGUgb25lcyAoYmVjYXVzZSByZW1lbWJlciwgd2UncmUgYmFraW5nIHRoZSBvcmlnaW4gaW50byB0aGUgbWF0cml4KCkgdmFsdWUpLlxuXG4gIGlmIChwbHVnaW5Ub0FkZFByb3BUd2VlbnNUbykge1xuICAgIF9hZGROb25Ud2VlbmluZ1BUKHBsdWdpblRvQWRkUHJvcFR3ZWVuc1RvLCBjYWNoZSwgXCJ4T3JpZ2luXCIsIHhPcmlnaW5PbGQsIHhPcmlnaW4pO1xuXG4gICAgX2FkZE5vblR3ZWVuaW5nUFQocGx1Z2luVG9BZGRQcm9wVHdlZW5zVG8sIGNhY2hlLCBcInlPcmlnaW5cIiwgeU9yaWdpbk9sZCwgeU9yaWdpbik7XG5cbiAgICBfYWRkTm9uVHdlZW5pbmdQVChwbHVnaW5Ub0FkZFByb3BUd2VlbnNUbywgY2FjaGUsIFwieE9mZnNldFwiLCB4T2Zmc2V0T2xkLCBjYWNoZS54T2Zmc2V0KTtcblxuICAgIF9hZGROb25Ud2VlbmluZ1BUKHBsdWdpblRvQWRkUHJvcFR3ZWVuc1RvLCBjYWNoZSwgXCJ5T2Zmc2V0XCIsIHlPZmZzZXRPbGQsIGNhY2hlLnlPZmZzZXQpO1xuICB9XG5cbiAgdGFyZ2V0LnNldEF0dHJpYnV0ZShcImRhdGEtc3ZnLW9yaWdpblwiLCB4T3JpZ2luICsgXCIgXCIgKyB5T3JpZ2luKTtcbn0sXG4gICAgX3BhcnNlVHJhbnNmb3JtID0gZnVuY3Rpb24gX3BhcnNlVHJhbnNmb3JtKHRhcmdldCwgdW5jYWNoZSkge1xuICB2YXIgY2FjaGUgPSB0YXJnZXQuX2dzYXAgfHwgbmV3IEdTQ2FjaGUodGFyZ2V0KTtcblxuICBpZiAoXCJ4XCIgaW4gY2FjaGUgJiYgIXVuY2FjaGUgJiYgIWNhY2hlLnVuY2FjaGUpIHtcbiAgICByZXR1cm4gY2FjaGU7XG4gIH1cblxuICB2YXIgc3R5bGUgPSB0YXJnZXQuc3R5bGUsXG4gICAgICBpbnZlcnRlZFNjYWxlWCA9IGNhY2hlLnNjYWxlWCA8IDAsXG4gICAgICBweCA9IFwicHhcIixcbiAgICAgIGRlZyA9IFwiZGVnXCIsXG4gICAgICBvcmlnaW4gPSBfZ2V0Q29tcHV0ZWRQcm9wZXJ0eSh0YXJnZXQsIF90cmFuc2Zvcm1PcmlnaW5Qcm9wKSB8fCBcIjBcIixcbiAgICAgIHgsXG4gICAgICB5LFxuICAgICAgeixcbiAgICAgIHNjYWxlWCxcbiAgICAgIHNjYWxlWSxcbiAgICAgIHJvdGF0aW9uLFxuICAgICAgcm90YXRpb25YLFxuICAgICAgcm90YXRpb25ZLFxuICAgICAgc2tld1gsXG4gICAgICBza2V3WSxcbiAgICAgIHBlcnNwZWN0aXZlLFxuICAgICAgeE9yaWdpbixcbiAgICAgIHlPcmlnaW4sXG4gICAgICBtYXRyaXgsXG4gICAgICBhbmdsZSxcbiAgICAgIGNvcyxcbiAgICAgIHNpbixcbiAgICAgIGEsXG4gICAgICBiLFxuICAgICAgYyxcbiAgICAgIGQsXG4gICAgICBhMTIsXG4gICAgICBhMjIsXG4gICAgICB0MSxcbiAgICAgIHQyLFxuICAgICAgdDMsXG4gICAgICBhMTMsXG4gICAgICBhMjMsXG4gICAgICBhMzMsXG4gICAgICBhNDIsXG4gICAgICBhNDMsXG4gICAgICBhMzI7XG4gIHggPSB5ID0geiA9IHJvdGF0aW9uID0gcm90YXRpb25YID0gcm90YXRpb25ZID0gc2tld1ggPSBza2V3WSA9IHBlcnNwZWN0aXZlID0gMDtcbiAgc2NhbGVYID0gc2NhbGVZID0gMTtcbiAgY2FjaGUuc3ZnID0gISEodGFyZ2V0LmdldENUTSAmJiBfaXNTVkcodGFyZ2V0KSk7XG4gIG1hdHJpeCA9IF9nZXRNYXRyaXgodGFyZ2V0LCBjYWNoZS5zdmcpO1xuXG4gIGlmIChjYWNoZS5zdmcpIHtcbiAgICB0MSA9ICghY2FjaGUudW5jYWNoZSB8fCBvcmlnaW4gPT09IFwiMHB4IDBweFwiKSAmJiAhdW5jYWNoZSAmJiB0YXJnZXQuZ2V0QXR0cmlidXRlKFwiZGF0YS1zdmctb3JpZ2luXCIpOyAvLyBpZiBvcmlnaW4gaXMgMCwwIGFuZCBjYWNoZS51bmNhY2hlIGlzIHRydWUsIGxldCB0aGUgcmVjb3JkZWQgZGF0YS1zdmctb3JpZ2luIHN0YXkuIE90aGVyd2lzZSwgd2hlbmV2ZXIgd2Ugc2V0IGNhY2hlLnVuY2FjaGUgdG8gdHJ1ZSwgd2UnZCBuZWVkIHRvIHNldCBlbGVtZW50LnN0eWxlLnRyYW5zZm9ybU9yaWdpbiA9IChjYWNoZS54T3JpZ2luIC0gYmJveC54KSArIFwicHggXCIgKyAoY2FjaGUueU9yaWdpbiAtIGJib3gueSkgKyBcInB4XCIuIFJlbWVtYmVyLCB0byB3b3JrIGFyb3VuZCBicm93c2VyIGluY29uc2lzdGVuY2llcyB3ZSBhbHdheXMgZm9yY2UgU1ZHIGVsZW1lbnRzJyB0cmFuc2Zvcm1PcmlnaW4gdG8gMCwwIGFuZCBvZmZzZXQgdGhlIHRyYW5zbGF0aW9uIGFjY29yZGluZ2x5LlxuXG4gICAgX2FwcGx5U1ZHT3JpZ2luKHRhcmdldCwgdDEgfHwgb3JpZ2luLCAhIXQxIHx8IGNhY2hlLm9yaWdpbklzQWJzb2x1dGUsIGNhY2hlLnNtb290aCAhPT0gZmFsc2UsIG1hdHJpeCk7XG4gIH1cblxuICB4T3JpZ2luID0gY2FjaGUueE9yaWdpbiB8fCAwO1xuICB5T3JpZ2luID0gY2FjaGUueU9yaWdpbiB8fCAwO1xuXG4gIGlmIChtYXRyaXggIT09IF9pZGVudGl0eTJETWF0cml4KSB7XG4gICAgYSA9IG1hdHJpeFswXTsgLy9hMTFcblxuICAgIGIgPSBtYXRyaXhbMV07IC8vYTIxXG5cbiAgICBjID0gbWF0cml4WzJdOyAvL2EzMVxuXG4gICAgZCA9IG1hdHJpeFszXTsgLy9hNDFcblxuICAgIHggPSBhMTIgPSBtYXRyaXhbNF07XG4gICAgeSA9IGEyMiA9IG1hdHJpeFs1XTsgLy8yRCBtYXRyaXhcblxuICAgIGlmIChtYXRyaXgubGVuZ3RoID09PSA2KSB7XG4gICAgICBzY2FsZVggPSBNYXRoLnNxcnQoYSAqIGEgKyBiICogYik7XG4gICAgICBzY2FsZVkgPSBNYXRoLnNxcnQoZCAqIGQgKyBjICogYyk7XG4gICAgICByb3RhdGlvbiA9IGEgfHwgYiA/IF9hdGFuMihiLCBhKSAqIF9SQUQyREVHIDogMDsgLy9ub3RlOiBpZiBzY2FsZVggaXMgMCwgd2UgY2Fubm90IGFjY3VyYXRlbHkgbWVhc3VyZSByb3RhdGlvbi4gU2FtZSBmb3Igc2tld1ggd2l0aCBhIHNjYWxlWSBvZiAwLiBUaGVyZWZvcmUsIHdlIGRlZmF1bHQgdG8gdGhlIHByZXZpb3VzbHkgcmVjb3JkZWQgdmFsdWUgKG9yIHplcm8gaWYgdGhhdCBkb2Vzbid0IGV4aXN0KS5cblxuICAgICAgc2tld1ggPSBjIHx8IGQgPyBfYXRhbjIoYywgZCkgKiBfUkFEMkRFRyArIHJvdGF0aW9uIDogMDtcbiAgICAgIHNrZXdYICYmIChzY2FsZVkgKj0gTWF0aC5hYnMoTWF0aC5jb3Moc2tld1ggKiBfREVHMlJBRCkpKTtcblxuICAgICAgaWYgKGNhY2hlLnN2Zykge1xuICAgICAgICB4IC09IHhPcmlnaW4gLSAoeE9yaWdpbiAqIGEgKyB5T3JpZ2luICogYyk7XG4gICAgICAgIHkgLT0geU9yaWdpbiAtICh4T3JpZ2luICogYiArIHlPcmlnaW4gKiBkKTtcbiAgICAgIH0gLy8zRCBtYXRyaXhcblxuICAgIH0gZWxzZSB7XG4gICAgICBhMzIgPSBtYXRyaXhbNl07XG4gICAgICBhNDIgPSBtYXRyaXhbN107XG4gICAgICBhMTMgPSBtYXRyaXhbOF07XG4gICAgICBhMjMgPSBtYXRyaXhbOV07XG4gICAgICBhMzMgPSBtYXRyaXhbMTBdO1xuICAgICAgYTQzID0gbWF0cml4WzExXTtcbiAgICAgIHggPSBtYXRyaXhbMTJdO1xuICAgICAgeSA9IG1hdHJpeFsxM107XG4gICAgICB6ID0gbWF0cml4WzE0XTtcbiAgICAgIGFuZ2xlID0gX2F0YW4yKGEzMiwgYTMzKTtcbiAgICAgIHJvdGF0aW9uWCA9IGFuZ2xlICogX1JBRDJERUc7IC8vcm90YXRpb25YXG5cbiAgICAgIGlmIChhbmdsZSkge1xuICAgICAgICBjb3MgPSBNYXRoLmNvcygtYW5nbGUpO1xuICAgICAgICBzaW4gPSBNYXRoLnNpbigtYW5nbGUpO1xuICAgICAgICB0MSA9IGExMiAqIGNvcyArIGExMyAqIHNpbjtcbiAgICAgICAgdDIgPSBhMjIgKiBjb3MgKyBhMjMgKiBzaW47XG4gICAgICAgIHQzID0gYTMyICogY29zICsgYTMzICogc2luO1xuICAgICAgICBhMTMgPSBhMTIgKiAtc2luICsgYTEzICogY29zO1xuICAgICAgICBhMjMgPSBhMjIgKiAtc2luICsgYTIzICogY29zO1xuICAgICAgICBhMzMgPSBhMzIgKiAtc2luICsgYTMzICogY29zO1xuICAgICAgICBhNDMgPSBhNDIgKiAtc2luICsgYTQzICogY29zO1xuICAgICAgICBhMTIgPSB0MTtcbiAgICAgICAgYTIyID0gdDI7XG4gICAgICAgIGEzMiA9IHQzO1xuICAgICAgfSAvL3JvdGF0aW9uWVxuXG5cbiAgICAgIGFuZ2xlID0gX2F0YW4yKC1jLCBhMzMpO1xuICAgICAgcm90YXRpb25ZID0gYW5nbGUgKiBfUkFEMkRFRztcblxuICAgICAgaWYgKGFuZ2xlKSB7XG4gICAgICAgIGNvcyA9IE1hdGguY29zKC1hbmdsZSk7XG4gICAgICAgIHNpbiA9IE1hdGguc2luKC1hbmdsZSk7XG4gICAgICAgIHQxID0gYSAqIGNvcyAtIGExMyAqIHNpbjtcbiAgICAgICAgdDIgPSBiICogY29zIC0gYTIzICogc2luO1xuICAgICAgICB0MyA9IGMgKiBjb3MgLSBhMzMgKiBzaW47XG4gICAgICAgIGE0MyA9IGQgKiBzaW4gKyBhNDMgKiBjb3M7XG4gICAgICAgIGEgPSB0MTtcbiAgICAgICAgYiA9IHQyO1xuICAgICAgICBjID0gdDM7XG4gICAgICB9IC8vcm90YXRpb25aXG5cblxuICAgICAgYW5nbGUgPSBfYXRhbjIoYiwgYSk7XG4gICAgICByb3RhdGlvbiA9IGFuZ2xlICogX1JBRDJERUc7XG5cbiAgICAgIGlmIChhbmdsZSkge1xuICAgICAgICBjb3MgPSBNYXRoLmNvcyhhbmdsZSk7XG4gICAgICAgIHNpbiA9IE1hdGguc2luKGFuZ2xlKTtcbiAgICAgICAgdDEgPSBhICogY29zICsgYiAqIHNpbjtcbiAgICAgICAgdDIgPSBhMTIgKiBjb3MgKyBhMjIgKiBzaW47XG4gICAgICAgIGIgPSBiICogY29zIC0gYSAqIHNpbjtcbiAgICAgICAgYTIyID0gYTIyICogY29zIC0gYTEyICogc2luO1xuICAgICAgICBhID0gdDE7XG4gICAgICAgIGExMiA9IHQyO1xuICAgICAgfVxuXG4gICAgICBpZiAocm90YXRpb25YICYmIE1hdGguYWJzKHJvdGF0aW9uWCkgKyBNYXRoLmFicyhyb3RhdGlvbikgPiAzNTkuOSkge1xuICAgICAgICAvL3doZW4gcm90YXRpb25ZIGlzIHNldCwgaXQgd2lsbCBvZnRlbiBiZSBwYXJzZWQgYXMgMTgwIGRlZ3JlZXMgZGlmZmVyZW50IHRoYW4gaXQgc2hvdWxkIGJlLCBhbmQgcm90YXRpb25YIGFuZCByb3RhdGlvbiBib3RoIGJlaW5nIDE4MCAoaXQgbG9va3MgdGhlIHNhbWUpLCBzbyB3ZSBhZGp1c3QgZm9yIHRoYXQgaGVyZS5cbiAgICAgICAgcm90YXRpb25YID0gcm90YXRpb24gPSAwO1xuICAgICAgICByb3RhdGlvblkgPSAxODAgLSByb3RhdGlvblk7XG4gICAgICB9XG5cbiAgICAgIHNjYWxlWCA9IF9yb3VuZChNYXRoLnNxcnQoYSAqIGEgKyBiICogYiArIGMgKiBjKSk7XG4gICAgICBzY2FsZVkgPSBfcm91bmQoTWF0aC5zcXJ0KGEyMiAqIGEyMiArIGEzMiAqIGEzMikpO1xuICAgICAgYW5nbGUgPSBfYXRhbjIoYTEyLCBhMjIpO1xuICAgICAgc2tld1ggPSBNYXRoLmFicyhhbmdsZSkgPiAwLjAwMDIgPyBhbmdsZSAqIF9SQUQyREVHIDogMDtcbiAgICAgIHBlcnNwZWN0aXZlID0gYTQzID8gMSAvIChhNDMgPCAwID8gLWE0MyA6IGE0MykgOiAwO1xuICAgIH1cblxuICAgIGlmIChjYWNoZS5zdmcpIHtcbiAgICAgIC8vc2Vuc2UgaWYgdGhlcmUgYXJlIENTUyB0cmFuc2Zvcm1zIGFwcGxpZWQgb24gYW4gU1ZHIGVsZW1lbnQgaW4gd2hpY2ggY2FzZSB3ZSBtdXN0IG92ZXJ3cml0ZSB0aGVtIHdoZW4gcmVuZGVyaW5nLiBUaGUgdHJhbnNmb3JtIGF0dHJpYnV0ZSBpcyBtb3JlIHJlbGlhYmxlIGNyb3NzLWJyb3dzZXIsIGJ1dCB3ZSBjYW4ndCBqdXN0IHJlbW92ZSB0aGUgQ1NTIG9uZXMgYmVjYXVzZSB0aGV5IG1heSBiZSBhcHBsaWVkIGluIGEgQ1NTIHJ1bGUgc29tZXdoZXJlIChub3QganVzdCBpbmxpbmUpLlxuICAgICAgdDEgPSB0YXJnZXQuZ2V0QXR0cmlidXRlKFwidHJhbnNmb3JtXCIpO1xuICAgICAgY2FjaGUuZm9yY2VDU1MgPSB0YXJnZXQuc2V0QXR0cmlidXRlKFwidHJhbnNmb3JtXCIsIFwiXCIpIHx8ICFfaXNOdWxsVHJhbnNmb3JtKF9nZXRDb21wdXRlZFByb3BlcnR5KHRhcmdldCwgX3RyYW5zZm9ybVByb3ApKTtcbiAgICAgIHQxICYmIHRhcmdldC5zZXRBdHRyaWJ1dGUoXCJ0cmFuc2Zvcm1cIiwgdDEpO1xuICAgIH1cbiAgfVxuXG4gIGlmIChNYXRoLmFicyhza2V3WCkgPiA5MCAmJiBNYXRoLmFicyhza2V3WCkgPCAyNzApIHtcbiAgICBpZiAoaW52ZXJ0ZWRTY2FsZVgpIHtcbiAgICAgIHNjYWxlWCAqPSAtMTtcbiAgICAgIHNrZXdYICs9IHJvdGF0aW9uIDw9IDAgPyAxODAgOiAtMTgwO1xuICAgICAgcm90YXRpb24gKz0gcm90YXRpb24gPD0gMCA/IDE4MCA6IC0xODA7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNjYWxlWSAqPSAtMTtcbiAgICAgIHNrZXdYICs9IHNrZXdYIDw9IDAgPyAxODAgOiAtMTgwO1xuICAgIH1cbiAgfVxuXG4gIHVuY2FjaGUgPSB1bmNhY2hlIHx8IGNhY2hlLnVuY2FjaGU7XG4gIGNhY2hlLnggPSB4IC0gKChjYWNoZS54UGVyY2VudCA9IHggJiYgKCF1bmNhY2hlICYmIGNhY2hlLnhQZXJjZW50IHx8IChNYXRoLnJvdW5kKHRhcmdldC5vZmZzZXRXaWR0aCAvIDIpID09PSBNYXRoLnJvdW5kKC14KSA/IC01MCA6IDApKSkgPyB0YXJnZXQub2Zmc2V0V2lkdGggKiBjYWNoZS54UGVyY2VudCAvIDEwMCA6IDApICsgcHg7XG4gIGNhY2hlLnkgPSB5IC0gKChjYWNoZS55UGVyY2VudCA9IHkgJiYgKCF1bmNhY2hlICYmIGNhY2hlLnlQZXJjZW50IHx8IChNYXRoLnJvdW5kKHRhcmdldC5vZmZzZXRIZWlnaHQgLyAyKSA9PT0gTWF0aC5yb3VuZCgteSkgPyAtNTAgOiAwKSkpID8gdGFyZ2V0Lm9mZnNldEhlaWdodCAqIGNhY2hlLnlQZXJjZW50IC8gMTAwIDogMCkgKyBweDtcbiAgY2FjaGUueiA9IHogKyBweDtcbiAgY2FjaGUuc2NhbGVYID0gX3JvdW5kKHNjYWxlWCk7XG4gIGNhY2hlLnNjYWxlWSA9IF9yb3VuZChzY2FsZVkpO1xuICBjYWNoZS5yb3RhdGlvbiA9IF9yb3VuZChyb3RhdGlvbikgKyBkZWc7XG4gIGNhY2hlLnJvdGF0aW9uWCA9IF9yb3VuZChyb3RhdGlvblgpICsgZGVnO1xuICBjYWNoZS5yb3RhdGlvblkgPSBfcm91bmQocm90YXRpb25ZKSArIGRlZztcbiAgY2FjaGUuc2tld1ggPSBza2V3WCArIGRlZztcbiAgY2FjaGUuc2tld1kgPSBza2V3WSArIGRlZztcbiAgY2FjaGUudHJhbnNmb3JtUGVyc3BlY3RpdmUgPSBwZXJzcGVjdGl2ZSArIHB4O1xuXG4gIGlmIChjYWNoZS56T3JpZ2luID0gcGFyc2VGbG9hdChvcmlnaW4uc3BsaXQoXCIgXCIpWzJdKSB8fCAwKSB7XG4gICAgc3R5bGVbX3RyYW5zZm9ybU9yaWdpblByb3BdID0gX2ZpcnN0VHdvT25seShvcmlnaW4pO1xuICB9XG5cbiAgY2FjaGUueE9mZnNldCA9IGNhY2hlLnlPZmZzZXQgPSAwO1xuICBjYWNoZS5mb3JjZTNEID0gX2NvbmZpZy5mb3JjZTNEO1xuICBjYWNoZS5yZW5kZXJUcmFuc2Zvcm0gPSBjYWNoZS5zdmcgPyBfcmVuZGVyU1ZHVHJhbnNmb3JtcyA6IF9zdXBwb3J0czNEID8gX3JlbmRlckNTU1RyYW5zZm9ybXMgOiBfcmVuZGVyTm9uM0RUcmFuc2Zvcm1zO1xuICBjYWNoZS51bmNhY2hlID0gMDtcbiAgcmV0dXJuIGNhY2hlO1xufSxcbiAgICBfZmlyc3RUd29Pbmx5ID0gZnVuY3Rpb24gX2ZpcnN0VHdvT25seSh2YWx1ZSkge1xuICByZXR1cm4gKHZhbHVlID0gdmFsdWUuc3BsaXQoXCIgXCIpKVswXSArIFwiIFwiICsgdmFsdWVbMV07XG59LFxuICAgIC8vZm9yIGhhbmRsaW5nIHRyYW5zZm9ybU9yaWdpbiB2YWx1ZXMsIHN0cmlwcGluZyBvdXQgdGhlIDNyZCBkaW1lbnNpb25cbl9hZGRQeFRyYW5zbGF0ZSA9IGZ1bmN0aW9uIF9hZGRQeFRyYW5zbGF0ZSh0YXJnZXQsIHN0YXJ0LCB2YWx1ZSkge1xuICB2YXIgdW5pdCA9IGdldFVuaXQoc3RhcnQpO1xuICByZXR1cm4gX3JvdW5kKHBhcnNlRmxvYXQoc3RhcnQpICsgcGFyc2VGbG9hdChfY29udmVydFRvVW5pdCh0YXJnZXQsIFwieFwiLCB2YWx1ZSArIFwicHhcIiwgdW5pdCkpKSArIHVuaXQ7XG59LFxuICAgIF9yZW5kZXJOb24zRFRyYW5zZm9ybXMgPSBmdW5jdGlvbiBfcmVuZGVyTm9uM0RUcmFuc2Zvcm1zKHJhdGlvLCBjYWNoZSkge1xuICBjYWNoZS56ID0gXCIwcHhcIjtcbiAgY2FjaGUucm90YXRpb25ZID0gY2FjaGUucm90YXRpb25YID0gXCIwZGVnXCI7XG4gIGNhY2hlLmZvcmNlM0QgPSAwO1xuXG4gIF9yZW5kZXJDU1NUcmFuc2Zvcm1zKHJhdGlvLCBjYWNoZSk7XG59LFxuICAgIF96ZXJvRGVnID0gXCIwZGVnXCIsXG4gICAgX3plcm9QeCA9IFwiMHB4XCIsXG4gICAgX2VuZFBhcmVudGhlc2lzID0gXCIpIFwiLFxuICAgIF9yZW5kZXJDU1NUcmFuc2Zvcm1zID0gZnVuY3Rpb24gX3JlbmRlckNTU1RyYW5zZm9ybXMocmF0aW8sIGNhY2hlKSB7XG4gIHZhciBfcmVmID0gY2FjaGUgfHwgdGhpcyxcbiAgICAgIHhQZXJjZW50ID0gX3JlZi54UGVyY2VudCxcbiAgICAgIHlQZXJjZW50ID0gX3JlZi55UGVyY2VudCxcbiAgICAgIHggPSBfcmVmLngsXG4gICAgICB5ID0gX3JlZi55LFxuICAgICAgeiA9IF9yZWYueixcbiAgICAgIHJvdGF0aW9uID0gX3JlZi5yb3RhdGlvbixcbiAgICAgIHJvdGF0aW9uWSA9IF9yZWYucm90YXRpb25ZLFxuICAgICAgcm90YXRpb25YID0gX3JlZi5yb3RhdGlvblgsXG4gICAgICBza2V3WCA9IF9yZWYuc2tld1gsXG4gICAgICBza2V3WSA9IF9yZWYuc2tld1ksXG4gICAgICBzY2FsZVggPSBfcmVmLnNjYWxlWCxcbiAgICAgIHNjYWxlWSA9IF9yZWYuc2NhbGVZLFxuICAgICAgdHJhbnNmb3JtUGVyc3BlY3RpdmUgPSBfcmVmLnRyYW5zZm9ybVBlcnNwZWN0aXZlLFxuICAgICAgZm9yY2UzRCA9IF9yZWYuZm9yY2UzRCxcbiAgICAgIHRhcmdldCA9IF9yZWYudGFyZ2V0LFxuICAgICAgek9yaWdpbiA9IF9yZWYuek9yaWdpbixcbiAgICAgIHRyYW5zZm9ybXMgPSBcIlwiLFxuICAgICAgdXNlM0QgPSBmb3JjZTNEID09PSBcImF1dG9cIiAmJiByYXRpbyAmJiByYXRpbyAhPT0gMSB8fCBmb3JjZTNEID09PSB0cnVlOyAvLyBTYWZhcmkgaGFzIGEgYnVnIHRoYXQgY2F1c2VzIGl0IG5vdCB0byByZW5kZXIgM0QgdHJhbnNmb3JtLW9yaWdpbiB2YWx1ZXMgcHJvcGVybHksIHNvIHdlIGZvcmNlIHRoZSB6IG9yaWdpbiB0byAwLCByZWNvcmQgaXQgaW4gdGhlIGNhY2hlLCBhbmQgdGhlbiBkbyB0aGUgbWF0aCBoZXJlIHRvIG9mZnNldCB0aGUgdHJhbnNsYXRlIHZhbHVlcyBhY2NvcmRpbmdseSAoYmFzaWNhbGx5IGRvIHRoZSAzRCB0cmFuc2Zvcm0tb3JpZ2luIHBhcnQgbWFudWFsbHkpXG5cblxuICBpZiAoek9yaWdpbiAmJiAocm90YXRpb25YICE9PSBfemVyb0RlZyB8fCByb3RhdGlvblkgIT09IF96ZXJvRGVnKSkge1xuICAgIHZhciBhbmdsZSA9IHBhcnNlRmxvYXQocm90YXRpb25ZKSAqIF9ERUcyUkFELFxuICAgICAgICBhMTMgPSBNYXRoLnNpbihhbmdsZSksXG4gICAgICAgIGEzMyA9IE1hdGguY29zKGFuZ2xlKSxcbiAgICAgICAgY29zO1xuXG4gICAgYW5nbGUgPSBwYXJzZUZsb2F0KHJvdGF0aW9uWCkgKiBfREVHMlJBRDtcbiAgICBjb3MgPSBNYXRoLmNvcyhhbmdsZSk7XG4gICAgeCA9IF9hZGRQeFRyYW5zbGF0ZSh0YXJnZXQsIHgsIGExMyAqIGNvcyAqIC16T3JpZ2luKTtcbiAgICB5ID0gX2FkZFB4VHJhbnNsYXRlKHRhcmdldCwgeSwgLU1hdGguc2luKGFuZ2xlKSAqIC16T3JpZ2luKTtcbiAgICB6ID0gX2FkZFB4VHJhbnNsYXRlKHRhcmdldCwgeiwgYTMzICogY29zICogLXpPcmlnaW4gKyB6T3JpZ2luKTtcbiAgfVxuXG4gIGlmICh0cmFuc2Zvcm1QZXJzcGVjdGl2ZSAhPT0gX3plcm9QeCkge1xuICAgIHRyYW5zZm9ybXMgKz0gXCJwZXJzcGVjdGl2ZShcIiArIHRyYW5zZm9ybVBlcnNwZWN0aXZlICsgX2VuZFBhcmVudGhlc2lzO1xuICB9XG5cbiAgaWYgKHhQZXJjZW50IHx8IHlQZXJjZW50KSB7XG4gICAgdHJhbnNmb3JtcyArPSBcInRyYW5zbGF0ZShcIiArIHhQZXJjZW50ICsgXCIlLCBcIiArIHlQZXJjZW50ICsgXCIlKSBcIjtcbiAgfVxuXG4gIGlmICh1c2UzRCB8fCB4ICE9PSBfemVyb1B4IHx8IHkgIT09IF96ZXJvUHggfHwgeiAhPT0gX3plcm9QeCkge1xuICAgIHRyYW5zZm9ybXMgKz0geiAhPT0gX3plcm9QeCB8fCB1c2UzRCA/IFwidHJhbnNsYXRlM2QoXCIgKyB4ICsgXCIsIFwiICsgeSArIFwiLCBcIiArIHogKyBcIikgXCIgOiBcInRyYW5zbGF0ZShcIiArIHggKyBcIiwgXCIgKyB5ICsgX2VuZFBhcmVudGhlc2lzO1xuICB9XG5cbiAgaWYgKHJvdGF0aW9uICE9PSBfemVyb0RlZykge1xuICAgIHRyYW5zZm9ybXMgKz0gXCJyb3RhdGUoXCIgKyByb3RhdGlvbiArIF9lbmRQYXJlbnRoZXNpcztcbiAgfVxuXG4gIGlmIChyb3RhdGlvblkgIT09IF96ZXJvRGVnKSB7XG4gICAgdHJhbnNmb3JtcyArPSBcInJvdGF0ZVkoXCIgKyByb3RhdGlvblkgKyBfZW5kUGFyZW50aGVzaXM7XG4gIH1cblxuICBpZiAocm90YXRpb25YICE9PSBfemVyb0RlZykge1xuICAgIHRyYW5zZm9ybXMgKz0gXCJyb3RhdGVYKFwiICsgcm90YXRpb25YICsgX2VuZFBhcmVudGhlc2lzO1xuICB9XG5cbiAgaWYgKHNrZXdYICE9PSBfemVyb0RlZyB8fCBza2V3WSAhPT0gX3plcm9EZWcpIHtcbiAgICB0cmFuc2Zvcm1zICs9IFwic2tldyhcIiArIHNrZXdYICsgXCIsIFwiICsgc2tld1kgKyBfZW5kUGFyZW50aGVzaXM7XG4gIH1cblxuICBpZiAoc2NhbGVYICE9PSAxIHx8IHNjYWxlWSAhPT0gMSkge1xuICAgIHRyYW5zZm9ybXMgKz0gXCJzY2FsZShcIiArIHNjYWxlWCArIFwiLCBcIiArIHNjYWxlWSArIF9lbmRQYXJlbnRoZXNpcztcbiAgfVxuXG4gIHRhcmdldC5zdHlsZVtfdHJhbnNmb3JtUHJvcF0gPSB0cmFuc2Zvcm1zIHx8IFwidHJhbnNsYXRlKDAsIDApXCI7XG59LFxuICAgIF9yZW5kZXJTVkdUcmFuc2Zvcm1zID0gZnVuY3Rpb24gX3JlbmRlclNWR1RyYW5zZm9ybXMocmF0aW8sIGNhY2hlKSB7XG4gIHZhciBfcmVmMiA9IGNhY2hlIHx8IHRoaXMsXG4gICAgICB4UGVyY2VudCA9IF9yZWYyLnhQZXJjZW50LFxuICAgICAgeVBlcmNlbnQgPSBfcmVmMi55UGVyY2VudCxcbiAgICAgIHggPSBfcmVmMi54LFxuICAgICAgeSA9IF9yZWYyLnksXG4gICAgICByb3RhdGlvbiA9IF9yZWYyLnJvdGF0aW9uLFxuICAgICAgc2tld1ggPSBfcmVmMi5za2V3WCxcbiAgICAgIHNrZXdZID0gX3JlZjIuc2tld1ksXG4gICAgICBzY2FsZVggPSBfcmVmMi5zY2FsZVgsXG4gICAgICBzY2FsZVkgPSBfcmVmMi5zY2FsZVksXG4gICAgICB0YXJnZXQgPSBfcmVmMi50YXJnZXQsXG4gICAgICB4T3JpZ2luID0gX3JlZjIueE9yaWdpbixcbiAgICAgIHlPcmlnaW4gPSBfcmVmMi55T3JpZ2luLFxuICAgICAgeE9mZnNldCA9IF9yZWYyLnhPZmZzZXQsXG4gICAgICB5T2Zmc2V0ID0gX3JlZjIueU9mZnNldCxcbiAgICAgIGZvcmNlQ1NTID0gX3JlZjIuZm9yY2VDU1MsXG4gICAgICB0eCA9IHBhcnNlRmxvYXQoeCksXG4gICAgICB0eSA9IHBhcnNlRmxvYXQoeSksXG4gICAgICBhMTEsXG4gICAgICBhMjEsXG4gICAgICBhMTIsXG4gICAgICBhMjIsXG4gICAgICB0ZW1wO1xuXG4gIHJvdGF0aW9uID0gcGFyc2VGbG9hdChyb3RhdGlvbik7XG4gIHNrZXdYID0gcGFyc2VGbG9hdChza2V3WCk7XG4gIHNrZXdZID0gcGFyc2VGbG9hdChza2V3WSk7XG5cbiAgaWYgKHNrZXdZKSB7XG4gICAgLy9mb3IgcGVyZm9ybWFuY2UgcmVhc29ucywgd2UgY29tYmluZSBhbGwgc2tld2luZyBpbnRvIHRoZSBza2V3WCBhbmQgcm90YXRpb24gdmFsdWVzLiBSZW1lbWJlciwgYSBza2V3WSBvZiAxMCBkZWdyZWVzIGxvb2tzIHRoZSBzYW1lIGFzIGEgcm90YXRpb24gb2YgMTAgZGVncmVlcyBwbHVzIGEgc2tld1ggb2YgMTAgZGVncmVlcy5cbiAgICBza2V3WSA9IHBhcnNlRmxvYXQoc2tld1kpO1xuICAgIHNrZXdYICs9IHNrZXdZO1xuICAgIHJvdGF0aW9uICs9IHNrZXdZO1xuICB9XG5cbiAgaWYgKHJvdGF0aW9uIHx8IHNrZXdYKSB7XG4gICAgcm90YXRpb24gKj0gX0RFRzJSQUQ7XG4gICAgc2tld1ggKj0gX0RFRzJSQUQ7XG4gICAgYTExID0gTWF0aC5jb3Mocm90YXRpb24pICogc2NhbGVYO1xuICAgIGEyMSA9IE1hdGguc2luKHJvdGF0aW9uKSAqIHNjYWxlWDtcbiAgICBhMTIgPSBNYXRoLnNpbihyb3RhdGlvbiAtIHNrZXdYKSAqIC1zY2FsZVk7XG4gICAgYTIyID0gTWF0aC5jb3Mocm90YXRpb24gLSBza2V3WCkgKiBzY2FsZVk7XG5cbiAgICBpZiAoc2tld1gpIHtcbiAgICAgIHNrZXdZICo9IF9ERUcyUkFEO1xuICAgICAgdGVtcCA9IE1hdGgudGFuKHNrZXdYIC0gc2tld1kpO1xuICAgICAgdGVtcCA9IE1hdGguc3FydCgxICsgdGVtcCAqIHRlbXApO1xuICAgICAgYTEyICo9IHRlbXA7XG4gICAgICBhMjIgKj0gdGVtcDtcblxuICAgICAgaWYgKHNrZXdZKSB7XG4gICAgICAgIHRlbXAgPSBNYXRoLnRhbihza2V3WSk7XG4gICAgICAgIHRlbXAgPSBNYXRoLnNxcnQoMSArIHRlbXAgKiB0ZW1wKTtcbiAgICAgICAgYTExICo9IHRlbXA7XG4gICAgICAgIGEyMSAqPSB0ZW1wO1xuICAgICAgfVxuICAgIH1cblxuICAgIGExMSA9IF9yb3VuZChhMTEpO1xuICAgIGEyMSA9IF9yb3VuZChhMjEpO1xuICAgIGExMiA9IF9yb3VuZChhMTIpO1xuICAgIGEyMiA9IF9yb3VuZChhMjIpO1xuICB9IGVsc2Uge1xuICAgIGExMSA9IHNjYWxlWDtcbiAgICBhMjIgPSBzY2FsZVk7XG4gICAgYTIxID0gYTEyID0gMDtcbiAgfVxuXG4gIGlmICh0eCAmJiAhfih4ICsgXCJcIikuaW5kZXhPZihcInB4XCIpIHx8IHR5ICYmICF+KHkgKyBcIlwiKS5pbmRleE9mKFwicHhcIikpIHtcbiAgICB0eCA9IF9jb252ZXJ0VG9Vbml0KHRhcmdldCwgXCJ4XCIsIHgsIFwicHhcIik7XG4gICAgdHkgPSBfY29udmVydFRvVW5pdCh0YXJnZXQsIFwieVwiLCB5LCBcInB4XCIpO1xuICB9XG5cbiAgaWYgKHhPcmlnaW4gfHwgeU9yaWdpbiB8fCB4T2Zmc2V0IHx8IHlPZmZzZXQpIHtcbiAgICB0eCA9IF9yb3VuZCh0eCArIHhPcmlnaW4gLSAoeE9yaWdpbiAqIGExMSArIHlPcmlnaW4gKiBhMTIpICsgeE9mZnNldCk7XG4gICAgdHkgPSBfcm91bmQodHkgKyB5T3JpZ2luIC0gKHhPcmlnaW4gKiBhMjEgKyB5T3JpZ2luICogYTIyKSArIHlPZmZzZXQpO1xuICB9XG5cbiAgaWYgKHhQZXJjZW50IHx8IHlQZXJjZW50KSB7XG4gICAgLy9UaGUgU1ZHIHNwZWMgZG9lc24ndCBzdXBwb3J0IHBlcmNlbnRhZ2UtYmFzZWQgdHJhbnNsYXRpb24gaW4gdGhlIFwidHJhbnNmb3JtXCIgYXR0cmlidXRlLCBzbyB3ZSBtZXJnZSBpdCBpbnRvIHRoZSB0cmFuc2xhdGlvbiB0byBzaW11bGF0ZSBpdC5cbiAgICB0ZW1wID0gdGFyZ2V0LmdldEJCb3goKTtcbiAgICB0eCA9IF9yb3VuZCh0eCArIHhQZXJjZW50IC8gMTAwICogdGVtcC53aWR0aCk7XG4gICAgdHkgPSBfcm91bmQodHkgKyB5UGVyY2VudCAvIDEwMCAqIHRlbXAuaGVpZ2h0KTtcbiAgfVxuXG4gIHRlbXAgPSBcIm1hdHJpeChcIiArIGExMSArIFwiLFwiICsgYTIxICsgXCIsXCIgKyBhMTIgKyBcIixcIiArIGEyMiArIFwiLFwiICsgdHggKyBcIixcIiArIHR5ICsgXCIpXCI7XG4gIHRhcmdldC5zZXRBdHRyaWJ1dGUoXCJ0cmFuc2Zvcm1cIiwgdGVtcCk7XG4gIGZvcmNlQ1NTICYmICh0YXJnZXQuc3R5bGVbX3RyYW5zZm9ybVByb3BdID0gdGVtcCk7IC8vc29tZSBicm93c2VycyBwcmlvcml0aXplIENTUyB0cmFuc2Zvcm1zIG92ZXIgdGhlIHRyYW5zZm9ybSBhdHRyaWJ1dGUuIFdoZW4gd2Ugc2Vuc2UgdGhhdCB0aGUgdXNlciBoYXMgQ1NTIHRyYW5zZm9ybXMgYXBwbGllZCwgd2UgbXVzdCBvdmVyd3JpdGUgdGhlbSB0aGlzIHdheSAob3RoZXJ3aXNlIHNvbWUgYnJvd3NlciBzaW1wbHkgd29uJ3QgcmVuZGVyIHRoZSAgdHJhbnNmb3JtIGF0dHJpYnV0ZSBjaGFuZ2VzISlcbn0sXG4gICAgX2FkZFJvdGF0aW9uYWxQcm9wVHdlZW4gPSBmdW5jdGlvbiBfYWRkUm90YXRpb25hbFByb3BUd2VlbihwbHVnaW4sIHRhcmdldCwgcHJvcGVydHksIHN0YXJ0TnVtLCBlbmRWYWx1ZSkge1xuICB2YXIgY2FwID0gMzYwLFxuICAgICAgaXNTdHJpbmcgPSBfaXNTdHJpbmcoZW5kVmFsdWUpLFxuICAgICAgZW5kTnVtID0gcGFyc2VGbG9hdChlbmRWYWx1ZSkgKiAoaXNTdHJpbmcgJiYgfmVuZFZhbHVlLmluZGV4T2YoXCJyYWRcIikgPyBfUkFEMkRFRyA6IDEpLFxuICAgICAgY2hhbmdlID0gZW5kTnVtIC0gc3RhcnROdW0sXG4gICAgICBmaW5hbFZhbHVlID0gc3RhcnROdW0gKyBjaGFuZ2UgKyBcImRlZ1wiLFxuICAgICAgZGlyZWN0aW9uLFxuICAgICAgcHQ7XG5cbiAgaWYgKGlzU3RyaW5nKSB7XG4gICAgZGlyZWN0aW9uID0gZW5kVmFsdWUuc3BsaXQoXCJfXCIpWzFdO1xuXG4gICAgaWYgKGRpcmVjdGlvbiA9PT0gXCJzaG9ydFwiKSB7XG4gICAgICBjaGFuZ2UgJT0gY2FwO1xuXG4gICAgICBpZiAoY2hhbmdlICE9PSBjaGFuZ2UgJSAoY2FwIC8gMikpIHtcbiAgICAgICAgY2hhbmdlICs9IGNoYW5nZSA8IDAgPyBjYXAgOiAtY2FwO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChkaXJlY3Rpb24gPT09IFwiY3dcIiAmJiBjaGFuZ2UgPCAwKSB7XG4gICAgICBjaGFuZ2UgPSAoY2hhbmdlICsgY2FwICogX2JpZ051bSkgJSBjYXAgLSB+fihjaGFuZ2UgLyBjYXApICogY2FwO1xuICAgIH0gZWxzZSBpZiAoZGlyZWN0aW9uID09PSBcImNjd1wiICYmIGNoYW5nZSA+IDApIHtcbiAgICAgIGNoYW5nZSA9IChjaGFuZ2UgLSBjYXAgKiBfYmlnTnVtKSAlIGNhcCAtIH5+KGNoYW5nZSAvIGNhcCkgKiBjYXA7XG4gICAgfVxuICB9XG5cbiAgcGx1Z2luLl9wdCA9IHB0ID0gbmV3IFByb3BUd2VlbihwbHVnaW4uX3B0LCB0YXJnZXQsIHByb3BlcnR5LCBzdGFydE51bSwgY2hhbmdlLCBfcmVuZGVyUHJvcFdpdGhFbmQpO1xuICBwdC5lID0gZmluYWxWYWx1ZTtcbiAgcHQudSA9IFwiZGVnXCI7XG5cbiAgcGx1Z2luLl9wcm9wcy5wdXNoKHByb3BlcnR5KTtcblxuICByZXR1cm4gcHQ7XG59LFxuICAgIF9hc3NpZ24gPSBmdW5jdGlvbiBfYXNzaWduKHRhcmdldCwgc291cmNlKSB7XG4gIC8vIEludGVybmV0IEV4cGxvcmVyIGRvZXNuJ3QgaGF2ZSBPYmplY3QuYXNzaWduKCksIHNvIHdlIHJlY3JlYXRlIGl0IGhlcmUuXG4gIGZvciAodmFyIHAgaW4gc291cmNlKSB7XG4gICAgdGFyZ2V0W3BdID0gc291cmNlW3BdO1xuICB9XG5cbiAgcmV0dXJuIHRhcmdldDtcbn0sXG4gICAgX2FkZFJhd1RyYW5zZm9ybVBUcyA9IGZ1bmN0aW9uIF9hZGRSYXdUcmFuc2Zvcm1QVHMocGx1Z2luLCB0cmFuc2Zvcm1zLCB0YXJnZXQpIHtcbiAgLy9mb3IgaGFuZGxpbmcgY2FzZXMgd2hlcmUgc29tZW9uZSBwYXNzZXMgaW4gYSB3aG9sZSB0cmFuc2Zvcm0gc3RyaW5nLCBsaWtlIHRyYW5zZm9ybTogXCJzY2FsZSgyLCAzKSByb3RhdGUoMjBkZWcpIHRyYW5zbGF0ZVkoMzBlbSlcIlxuICB2YXIgc3RhcnRDYWNoZSA9IF9hc3NpZ24oe30sIHRhcmdldC5fZ3NhcCksXG4gICAgICBleGNsdWRlID0gXCJwZXJzcGVjdGl2ZSxmb3JjZTNELHRyYW5zZm9ybU9yaWdpbixzdmdPcmlnaW5cIixcbiAgICAgIHN0eWxlID0gdGFyZ2V0LnN0eWxlLFxuICAgICAgZW5kQ2FjaGUsXG4gICAgICBwLFxuICAgICAgc3RhcnRWYWx1ZSxcbiAgICAgIGVuZFZhbHVlLFxuICAgICAgc3RhcnROdW0sXG4gICAgICBlbmROdW0sXG4gICAgICBzdGFydFVuaXQsXG4gICAgICBlbmRVbml0O1xuXG4gIGlmIChzdGFydENhY2hlLnN2Zykge1xuICAgIHN0YXJ0VmFsdWUgPSB0YXJnZXQuZ2V0QXR0cmlidXRlKFwidHJhbnNmb3JtXCIpO1xuICAgIHRhcmdldC5zZXRBdHRyaWJ1dGUoXCJ0cmFuc2Zvcm1cIiwgXCJcIik7XG4gICAgc3R5bGVbX3RyYW5zZm9ybVByb3BdID0gdHJhbnNmb3JtcztcbiAgICBlbmRDYWNoZSA9IF9wYXJzZVRyYW5zZm9ybSh0YXJnZXQsIDEpO1xuXG4gICAgX3JlbW92ZVByb3BlcnR5KHRhcmdldCwgX3RyYW5zZm9ybVByb3ApO1xuXG4gICAgdGFyZ2V0LnNldEF0dHJpYnV0ZShcInRyYW5zZm9ybVwiLCBzdGFydFZhbHVlKTtcbiAgfSBlbHNlIHtcbiAgICBzdGFydFZhbHVlID0gZ2V0Q29tcHV0ZWRTdHlsZSh0YXJnZXQpW190cmFuc2Zvcm1Qcm9wXTtcbiAgICBzdHlsZVtfdHJhbnNmb3JtUHJvcF0gPSB0cmFuc2Zvcm1zO1xuICAgIGVuZENhY2hlID0gX3BhcnNlVHJhbnNmb3JtKHRhcmdldCwgMSk7XG4gICAgc3R5bGVbX3RyYW5zZm9ybVByb3BdID0gc3RhcnRWYWx1ZTtcbiAgfVxuXG4gIGZvciAocCBpbiBfdHJhbnNmb3JtUHJvcHMpIHtcbiAgICBzdGFydFZhbHVlID0gc3RhcnRDYWNoZVtwXTtcbiAgICBlbmRWYWx1ZSA9IGVuZENhY2hlW3BdO1xuXG4gICAgaWYgKHN0YXJ0VmFsdWUgIT09IGVuZFZhbHVlICYmIGV4Y2x1ZGUuaW5kZXhPZihwKSA8IDApIHtcbiAgICAgIC8vdHdlZW5pbmcgdG8gbm8gcGVyc3BlY3RpdmUgZ2l2ZXMgdmVyeSB1bmludHVpdGl2ZSByZXN1bHRzIC0ganVzdCBrZWVwIHRoZSBzYW1lIHBlcnNwZWN0aXZlIGluIHRoYXQgY2FzZS5cbiAgICAgIHN0YXJ0VW5pdCA9IGdldFVuaXQoc3RhcnRWYWx1ZSk7XG4gICAgICBlbmRVbml0ID0gZ2V0VW5pdChlbmRWYWx1ZSk7XG4gICAgICBzdGFydE51bSA9IHN0YXJ0VW5pdCAhPT0gZW5kVW5pdCA/IF9jb252ZXJ0VG9Vbml0KHRhcmdldCwgcCwgc3RhcnRWYWx1ZSwgZW5kVW5pdCkgOiBwYXJzZUZsb2F0KHN0YXJ0VmFsdWUpO1xuICAgICAgZW5kTnVtID0gcGFyc2VGbG9hdChlbmRWYWx1ZSk7XG4gICAgICBwbHVnaW4uX3B0ID0gbmV3IFByb3BUd2VlbihwbHVnaW4uX3B0LCBlbmRDYWNoZSwgcCwgc3RhcnROdW0sIGVuZE51bSAtIHN0YXJ0TnVtLCBfcmVuZGVyQ1NTUHJvcCk7XG4gICAgICBwbHVnaW4uX3B0LnUgPSBlbmRVbml0IHx8IDA7XG5cbiAgICAgIHBsdWdpbi5fcHJvcHMucHVzaChwKTtcbiAgICB9XG4gIH1cblxuICBfYXNzaWduKGVuZENhY2hlLCBzdGFydENhY2hlKTtcbn07IC8vIGhhbmRsZSBzcGxpdHRpbmcgYXBhcnQgcGFkZGluZywgbWFyZ2luLCBib3JkZXJXaWR0aCwgYW5kIGJvcmRlclJhZGl1cyBpbnRvIHRoZWlyIDQgY29tcG9uZW50cy4gRmlyZWZveCwgZm9yIGV4YW1wbGUsIHdvbid0IHJlcG9ydCBib3JkZXJSYWRpdXMgY29ycmVjdGx5IC0gaXQgd2lsbCBvbmx5IGRvIGJvcmRlclRvcExlZnRSYWRpdXMgYW5kIHRoZSBvdGhlciBjb3JuZXJzLiBXZSBhbHNvIHdhbnQgdG8gaGFuZGxlIHBhZGRpbmdUb3AsIG1hcmdpbkxlZnQsIGJvcmRlclJpZ2h0V2lkdGgsIGV0Yy5cblxuXG5fZm9yRWFjaE5hbWUoXCJwYWRkaW5nLG1hcmdpbixXaWR0aCxSYWRpdXNcIiwgZnVuY3Rpb24gKG5hbWUsIGluZGV4KSB7XG4gIHZhciB0ID0gXCJUb3BcIixcbiAgICAgIHIgPSBcIlJpZ2h0XCIsXG4gICAgICBiID0gXCJCb3R0b21cIixcbiAgICAgIGwgPSBcIkxlZnRcIixcbiAgICAgIHByb3BzID0gKGluZGV4IDwgMyA/IFt0LCByLCBiLCBsXSA6IFt0ICsgbCwgdCArIHIsIGIgKyByLCBiICsgbF0pLm1hcChmdW5jdGlvbiAoc2lkZSkge1xuICAgIHJldHVybiBpbmRleCA8IDIgPyBuYW1lICsgc2lkZSA6IFwiYm9yZGVyXCIgKyBzaWRlICsgbmFtZTtcbiAgfSk7XG5cbiAgX3NwZWNpYWxQcm9wc1tpbmRleCA+IDEgPyBcImJvcmRlclwiICsgbmFtZSA6IG5hbWVdID0gZnVuY3Rpb24gKHBsdWdpbiwgdGFyZ2V0LCBwcm9wZXJ0eSwgZW5kVmFsdWUsIHR3ZWVuKSB7XG4gICAgdmFyIGEsIHZhcnM7XG5cbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDQpIHtcbiAgICAgIC8vIGdldHRlciwgcGFzc2VkIHRhcmdldCwgcHJvcGVydHksIGFuZCB1bml0IChmcm9tIF9nZXQoKSlcbiAgICAgIGEgPSBwcm9wcy5tYXAoZnVuY3Rpb24gKHByb3ApIHtcbiAgICAgICAgcmV0dXJuIF9nZXQocGx1Z2luLCBwcm9wLCBwcm9wZXJ0eSk7XG4gICAgICB9KTtcbiAgICAgIHZhcnMgPSBhLmpvaW4oXCIgXCIpO1xuICAgICAgcmV0dXJuIHZhcnMuc3BsaXQoYVswXSkubGVuZ3RoID09PSA1ID8gYVswXSA6IHZhcnM7XG4gICAgfVxuXG4gICAgYSA9IChlbmRWYWx1ZSArIFwiXCIpLnNwbGl0KFwiIFwiKTtcbiAgICB2YXJzID0ge307XG4gICAgcHJvcHMuZm9yRWFjaChmdW5jdGlvbiAocHJvcCwgaSkge1xuICAgICAgcmV0dXJuIHZhcnNbcHJvcF0gPSBhW2ldID0gYVtpXSB8fCBhWyhpIC0gMSkgLyAyIHwgMF07XG4gICAgfSk7XG4gICAgcGx1Z2luLmluaXQodGFyZ2V0LCB2YXJzLCB0d2Vlbik7XG4gIH07XG59KTtcblxuZXhwb3J0IHZhciBDU1NQbHVnaW4gPSB7XG4gIG5hbWU6IFwiY3NzXCIsXG4gIHJlZ2lzdGVyOiBfaW5pdENvcmUsXG4gIHRhcmdldFRlc3Q6IGZ1bmN0aW9uIHRhcmdldFRlc3QodGFyZ2V0KSB7XG4gICAgcmV0dXJuIHRhcmdldC5zdHlsZSAmJiB0YXJnZXQubm9kZVR5cGU7XG4gIH0sXG4gIGluaXQ6IGZ1bmN0aW9uIGluaXQodGFyZ2V0LCB2YXJzLCB0d2VlbiwgaW5kZXgsIHRhcmdldHMpIHtcbiAgICB2YXIgcHJvcHMgPSB0aGlzLl9wcm9wcyxcbiAgICAgICAgc3R5bGUgPSB0YXJnZXQuc3R5bGUsXG4gICAgICAgIHN0YXJ0QXQgPSB0d2Vlbi52YXJzLnN0YXJ0QXQsXG4gICAgICAgIHN0YXJ0VmFsdWUsXG4gICAgICAgIGVuZFZhbHVlLFxuICAgICAgICBlbmROdW0sXG4gICAgICAgIHN0YXJ0TnVtLFxuICAgICAgICB0eXBlLFxuICAgICAgICBzcGVjaWFsUHJvcCxcbiAgICAgICAgcCxcbiAgICAgICAgc3RhcnRVbml0LFxuICAgICAgICBlbmRVbml0LFxuICAgICAgICByZWxhdGl2ZSxcbiAgICAgICAgaXNUcmFuc2Zvcm1SZWxhdGVkLFxuICAgICAgICB0cmFuc2Zvcm1Qcm9wVHdlZW4sXG4gICAgICAgIGNhY2hlLFxuICAgICAgICBzbW9vdGgsXG4gICAgICAgIGhhc1ByaW9yaXR5O1xuICAgIF9wbHVnaW5Jbml0dGVkIHx8IF9pbml0Q29yZSgpO1xuXG4gICAgZm9yIChwIGluIHZhcnMpIHtcbiAgICAgIGlmIChwID09PSBcImF1dG9Sb3VuZFwiKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBlbmRWYWx1ZSA9IHZhcnNbcF07XG5cbiAgICAgIGlmIChfcGx1Z2luc1twXSAmJiBfY2hlY2tQbHVnaW4ocCwgdmFycywgdHdlZW4sIGluZGV4LCB0YXJnZXQsIHRhcmdldHMpKSB7XG4gICAgICAgIC8vIHBsdWdpbnNcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIHR5cGUgPSB0eXBlb2YgZW5kVmFsdWU7XG4gICAgICBzcGVjaWFsUHJvcCA9IF9zcGVjaWFsUHJvcHNbcF07XG5cbiAgICAgIGlmICh0eXBlID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgZW5kVmFsdWUgPSBlbmRWYWx1ZS5jYWxsKHR3ZWVuLCBpbmRleCwgdGFyZ2V0LCB0YXJnZXRzKTtcbiAgICAgICAgdHlwZSA9IHR5cGVvZiBlbmRWYWx1ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGUgPT09IFwic3RyaW5nXCIgJiYgfmVuZFZhbHVlLmluZGV4T2YoXCJyYW5kb20oXCIpKSB7XG4gICAgICAgIGVuZFZhbHVlID0gX3JlcGxhY2VSYW5kb20oZW5kVmFsdWUpO1xuICAgICAgfVxuXG4gICAgICBpZiAoc3BlY2lhbFByb3ApIHtcbiAgICAgICAgc3BlY2lhbFByb3AodGhpcywgdGFyZ2V0LCBwLCBlbmRWYWx1ZSwgdHdlZW4pICYmIChoYXNQcmlvcml0eSA9IDEpO1xuICAgICAgfSBlbHNlIGlmIChwLnN1YnN0cigwLCAyKSA9PT0gXCItLVwiKSB7XG4gICAgICAgIC8vQ1NTIHZhcmlhYmxlXG4gICAgICAgIHN0YXJ0VmFsdWUgPSAoZ2V0Q29tcHV0ZWRTdHlsZSh0YXJnZXQpLmdldFByb3BlcnR5VmFsdWUocCkgKyBcIlwiKS50cmltKCk7XG4gICAgICAgIGVuZFZhbHVlICs9IFwiXCI7XG4gICAgICAgIF9jb2xvckV4cC5sYXN0SW5kZXggPSAwO1xuXG4gICAgICAgIGlmICghX2NvbG9yRXhwLnRlc3Qoc3RhcnRWYWx1ZSkpIHtcbiAgICAgICAgICAvLyBjb2xvcnMgZG9uJ3QgaGF2ZSB1bml0c1xuICAgICAgICAgIHN0YXJ0VW5pdCA9IGdldFVuaXQoc3RhcnRWYWx1ZSk7XG4gICAgICAgICAgZW5kVW5pdCA9IGdldFVuaXQoZW5kVmFsdWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgZW5kVW5pdCA/IHN0YXJ0VW5pdCAhPT0gZW5kVW5pdCAmJiAoc3RhcnRWYWx1ZSA9IF9jb252ZXJ0VG9Vbml0KHRhcmdldCwgcCwgc3RhcnRWYWx1ZSwgZW5kVW5pdCkgKyBlbmRVbml0KSA6IHN0YXJ0VW5pdCAmJiAoZW5kVmFsdWUgKz0gc3RhcnRVbml0KTtcbiAgICAgICAgdGhpcy5hZGQoc3R5bGUsIFwic2V0UHJvcGVydHlcIiwgc3RhcnRWYWx1ZSwgZW5kVmFsdWUsIGluZGV4LCB0YXJnZXRzLCAwLCAwLCBwKTtcbiAgICAgICAgcHJvcHMucHVzaChwKTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZSAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICBpZiAoc3RhcnRBdCAmJiBwIGluIHN0YXJ0QXQpIHtcbiAgICAgICAgICAvLyBpbiBjYXNlIHNvbWVvbmUgaGFyZC1jb2RlcyBhIGNvbXBsZXggdmFsdWUgYXMgdGhlIHN0YXJ0LCBsaWtlIHRvcDogXCJjYWxjKDJ2aCAvIDIpXCIuIFdpdGhvdXQgdGhpcywgaXQnZCB1c2UgdGhlIGNvbXB1dGVkIHZhbHVlIChhbHdheXMgaW4gcHgpXG4gICAgICAgICAgc3RhcnRWYWx1ZSA9IHR5cGVvZiBzdGFydEF0W3BdID09PSBcImZ1bmN0aW9uXCIgPyBzdGFydEF0W3BdLmNhbGwodHdlZW4sIGluZGV4LCB0YXJnZXQsIHRhcmdldHMpIDogc3RhcnRBdFtwXTtcbiAgICAgICAgICBfaXNTdHJpbmcoc3RhcnRWYWx1ZSkgJiYgfnN0YXJ0VmFsdWUuaW5kZXhPZihcInJhbmRvbShcIikgJiYgKHN0YXJ0VmFsdWUgPSBfcmVwbGFjZVJhbmRvbShzdGFydFZhbHVlKSk7XG4gICAgICAgICAgZ2V0VW5pdChzdGFydFZhbHVlICsgXCJcIikgfHwgKHN0YXJ0VmFsdWUgKz0gX2NvbmZpZy51bml0c1twXSB8fCBnZXRVbml0KF9nZXQodGFyZ2V0LCBwKSkgfHwgXCJcIik7IC8vIGZvciBjYXNlcyB3aGVuIHNvbWVvbmUgcGFzc2VzIGluIGEgdW5pdGxlc3MgdmFsdWUgbGlrZSB7eDogMTAwfTsgaWYgd2UgdHJ5IHNldHRpbmcgdHJhbnNsYXRlKDEwMCwgMHB4KSBpdCB3b24ndCB3b3JrLlxuXG4gICAgICAgICAgKHN0YXJ0VmFsdWUgKyBcIlwiKS5jaGFyQXQoMSkgPT09IFwiPVwiICYmIChzdGFydFZhbHVlID0gX2dldCh0YXJnZXQsIHApKTsgLy8gY2FuJ3Qgd29yayB3aXRoIHJlbGF0aXZlIHZhbHVlc1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHN0YXJ0VmFsdWUgPSBfZ2V0KHRhcmdldCwgcCk7XG4gICAgICAgIH1cblxuICAgICAgICBzdGFydE51bSA9IHBhcnNlRmxvYXQoc3RhcnRWYWx1ZSk7XG4gICAgICAgIHJlbGF0aXZlID0gdHlwZSA9PT0gXCJzdHJpbmdcIiAmJiBlbmRWYWx1ZS5jaGFyQXQoMSkgPT09IFwiPVwiICYmIGVuZFZhbHVlLnN1YnN0cigwLCAyKTtcbiAgICAgICAgcmVsYXRpdmUgJiYgKGVuZFZhbHVlID0gZW5kVmFsdWUuc3Vic3RyKDIpKTtcbiAgICAgICAgZW5kTnVtID0gcGFyc2VGbG9hdChlbmRWYWx1ZSk7XG5cbiAgICAgICAgaWYgKHAgaW4gX3Byb3BlcnR5QWxpYXNlcykge1xuICAgICAgICAgIGlmIChwID09PSBcImF1dG9BbHBoYVwiKSB7XG4gICAgICAgICAgICAvL3NwZWNpYWwgY2FzZSB3aGVyZSB3ZSBjb250cm9sIHRoZSB2aXNpYmlsaXR5IGFsb25nIHdpdGggb3BhY2l0eS4gV2Ugc3RpbGwgYWxsb3cgdGhlIG9wYWNpdHkgdmFsdWUgdG8gcGFzcyB0aHJvdWdoIGFuZCBnZXQgdHdlZW5lZC5cbiAgICAgICAgICAgIGlmIChzdGFydE51bSA9PT0gMSAmJiBfZ2V0KHRhcmdldCwgXCJ2aXNpYmlsaXR5XCIpID09PSBcImhpZGRlblwiICYmIGVuZE51bSkge1xuICAgICAgICAgICAgICAvL2lmIHZpc2liaWxpdHkgaXMgaW5pdGlhbGx5IHNldCB0byBcImhpZGRlblwiLCB3ZSBzaG91bGQgaW50ZXJwcmV0IHRoYXQgYXMgaW50ZW50IHRvIG1ha2Ugb3BhY2l0eSAwIChhIGNvbnZlbmllbmNlKVxuICAgICAgICAgICAgICBzdGFydE51bSA9IDA7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIF9hZGROb25Ud2VlbmluZ1BUKHRoaXMsIHN0eWxlLCBcInZpc2liaWxpdHlcIiwgc3RhcnROdW0gPyBcImluaGVyaXRcIiA6IFwiaGlkZGVuXCIsIGVuZE51bSA/IFwiaW5oZXJpdFwiIDogXCJoaWRkZW5cIiwgIWVuZE51bSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHAgIT09IFwic2NhbGVcIiAmJiBwICE9PSBcInRyYW5zZm9ybVwiKSB7XG4gICAgICAgICAgICBwID0gX3Byb3BlcnR5QWxpYXNlc1twXTtcbiAgICAgICAgICAgIH5wLmluZGV4T2YoXCIsXCIpICYmIChwID0gcC5zcGxpdChcIixcIilbMF0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlzVHJhbnNmb3JtUmVsYXRlZCA9IHAgaW4gX3RyYW5zZm9ybVByb3BzOyAvLy0tLSBUUkFOU0ZPUk0tUkVMQVRFRCAtLS1cblxuICAgICAgICBpZiAoaXNUcmFuc2Zvcm1SZWxhdGVkKSB7XG4gICAgICAgICAgaWYgKCF0cmFuc2Zvcm1Qcm9wVHdlZW4pIHtcbiAgICAgICAgICAgIGNhY2hlID0gdGFyZ2V0Ll9nc2FwO1xuICAgICAgICAgICAgY2FjaGUucmVuZGVyVHJhbnNmb3JtICYmICF2YXJzLnBhcnNlVHJhbnNmb3JtIHx8IF9wYXJzZVRyYW5zZm9ybSh0YXJnZXQsIHZhcnMucGFyc2VUcmFuc2Zvcm0pOyAvLyBpZiwgZm9yIGV4YW1wbGUsIGdzYXAuc2V0KC4uLiB7dHJhbnNmb3JtOlwidHJhbnNsYXRlWCg1MHZ3KVwifSksIHRoZSBfZ2V0KCkgY2FsbCBkb2Vzbid0IHBhcnNlIHRoZSB0cmFuc2Zvcm0sIHRodXMgY2FjaGUucmVuZGVyVHJhbnNmb3JtIHdvbid0IGJlIHNldCB5ZXQgc28gZm9yY2UgdGhlIHBhcnNpbmcgb2YgdGhlIHRyYW5zZm9ybSBoZXJlLlxuXG4gICAgICAgICAgICBzbW9vdGggPSB2YXJzLnNtb290aE9yaWdpbiAhPT0gZmFsc2UgJiYgY2FjaGUuc21vb3RoO1xuICAgICAgICAgICAgdHJhbnNmb3JtUHJvcFR3ZWVuID0gdGhpcy5fcHQgPSBuZXcgUHJvcFR3ZWVuKHRoaXMuX3B0LCBzdHlsZSwgX3RyYW5zZm9ybVByb3AsIDAsIDEsIGNhY2hlLnJlbmRlclRyYW5zZm9ybSwgY2FjaGUsIDAsIC0xKTsgLy90aGUgZmlyc3QgdGltZSB0aHJvdWdoLCBjcmVhdGUgdGhlIHJlbmRlcmluZyBQcm9wVHdlZW4gc28gdGhhdCBpdCBydW5zIExBU1QgKGluIHRoZSBsaW5rZWQgbGlzdCwgd2Uga2VlcCBhZGRpbmcgdG8gdGhlIGJlZ2lubmluZylcblxuICAgICAgICAgICAgdHJhbnNmb3JtUHJvcFR3ZWVuLmRlcCA9IDE7IC8vZmxhZyBpdCBhcyBkZXBlbmRlbnQgc28gdGhhdCBpZiB0aGluZ3MgZ2V0IGtpbGxlZC9vdmVyd3JpdHRlbiBhbmQgdGhpcyBpcyB0aGUgb25seSBQcm9wVHdlZW4gbGVmdCwgd2UgY2FuIHNhZmVseSBraWxsIHRoZSB3aG9sZSB0d2Vlbi5cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAocCA9PT0gXCJzY2FsZVwiKSB7XG4gICAgICAgICAgICB0aGlzLl9wdCA9IG5ldyBQcm9wVHdlZW4odGhpcy5fcHQsIGNhY2hlLCBcInNjYWxlWVwiLCBjYWNoZS5zY2FsZVksIChyZWxhdGl2ZSA/IF9wYXJzZVJlbGF0aXZlKGNhY2hlLnNjYWxlWSwgcmVsYXRpdmUgKyBlbmROdW0pIDogZW5kTnVtKSAtIGNhY2hlLnNjYWxlWSB8fCAwKTtcbiAgICAgICAgICAgIHByb3BzLnB1c2goXCJzY2FsZVlcIiwgcCk7XG4gICAgICAgICAgICBwICs9IFwiWFwiO1xuICAgICAgICAgIH0gZWxzZSBpZiAocCA9PT0gXCJ0cmFuc2Zvcm1PcmlnaW5cIikge1xuICAgICAgICAgICAgZW5kVmFsdWUgPSBfY29udmVydEtleXdvcmRzVG9QZXJjZW50YWdlcyhlbmRWYWx1ZSk7IC8vaW4gY2FzZSBzb21ldGhpbmcgbGlrZSBcImxlZnQgdG9wXCIgb3IgXCJib3R0b20gcmlnaHRcIiBpcyBwYXNzZWQgaW4uIENvbnZlcnQgdG8gcGVyY2VudGFnZXMuXG5cbiAgICAgICAgICAgIGlmIChjYWNoZS5zdmcpIHtcbiAgICAgICAgICAgICAgX2FwcGx5U1ZHT3JpZ2luKHRhcmdldCwgZW5kVmFsdWUsIDAsIHNtb290aCwgMCwgdGhpcyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBlbmRVbml0ID0gcGFyc2VGbG9hdChlbmRWYWx1ZS5zcGxpdChcIiBcIilbMl0pIHx8IDA7IC8vaGFuZGxlIHRoZSB6T3JpZ2luIHNlcGFyYXRlbHkhXG5cbiAgICAgICAgICAgICAgZW5kVW5pdCAhPT0gY2FjaGUuek9yaWdpbiAmJiBfYWRkTm9uVHdlZW5pbmdQVCh0aGlzLCBjYWNoZSwgXCJ6T3JpZ2luXCIsIGNhY2hlLnpPcmlnaW4sIGVuZFVuaXQpO1xuXG4gICAgICAgICAgICAgIF9hZGROb25Ud2VlbmluZ1BUKHRoaXMsIHN0eWxlLCBwLCBfZmlyc3RUd29Pbmx5KHN0YXJ0VmFsdWUpLCBfZmlyc3RUd29Pbmx5KGVuZFZhbHVlKSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH0gZWxzZSBpZiAocCA9PT0gXCJzdmdPcmlnaW5cIikge1xuICAgICAgICAgICAgX2FwcGx5U1ZHT3JpZ2luKHRhcmdldCwgZW5kVmFsdWUsIDEsIHNtb290aCwgMCwgdGhpcyk7XG5cbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH0gZWxzZSBpZiAocCBpbiBfcm90YXRpb25hbFByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgIF9hZGRSb3RhdGlvbmFsUHJvcFR3ZWVuKHRoaXMsIGNhY2hlLCBwLCBzdGFydE51bSwgcmVsYXRpdmUgPyBfcGFyc2VSZWxhdGl2ZShzdGFydE51bSwgcmVsYXRpdmUgKyBlbmRWYWx1ZSkgOiBlbmRWYWx1ZSk7XG5cbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH0gZWxzZSBpZiAocCA9PT0gXCJzbW9vdGhPcmlnaW5cIikge1xuICAgICAgICAgICAgX2FkZE5vblR3ZWVuaW5nUFQodGhpcywgY2FjaGUsIFwic21vb3RoXCIsIGNhY2hlLnNtb290aCwgZW5kVmFsdWUpO1xuXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHAgPT09IFwiZm9yY2UzRFwiKSB7XG4gICAgICAgICAgICBjYWNoZVtwXSA9IGVuZFZhbHVlO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfSBlbHNlIGlmIChwID09PSBcInRyYW5zZm9ybVwiKSB7XG4gICAgICAgICAgICBfYWRkUmF3VHJhbnNmb3JtUFRzKHRoaXMsIGVuZFZhbHVlLCB0YXJnZXQpO1xuXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoIShwIGluIHN0eWxlKSkge1xuICAgICAgICAgIHAgPSBfY2hlY2tQcm9wUHJlZml4KHApIHx8IHA7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNUcmFuc2Zvcm1SZWxhdGVkIHx8IChlbmROdW0gfHwgZW5kTnVtID09PSAwKSAmJiAoc3RhcnROdW0gfHwgc3RhcnROdW0gPT09IDApICYmICFfY29tcGxleEV4cC50ZXN0KGVuZFZhbHVlKSAmJiBwIGluIHN0eWxlKSB7XG4gICAgICAgICAgc3RhcnRVbml0ID0gKHN0YXJ0VmFsdWUgKyBcIlwiKS5zdWJzdHIoKHN0YXJ0TnVtICsgXCJcIikubGVuZ3RoKTtcbiAgICAgICAgICBlbmROdW0gfHwgKGVuZE51bSA9IDApOyAvLyBwcm90ZWN0IGFnYWluc3QgTmFOXG5cbiAgICAgICAgICBlbmRVbml0ID0gZ2V0VW5pdChlbmRWYWx1ZSkgfHwgKHAgaW4gX2NvbmZpZy51bml0cyA/IF9jb25maWcudW5pdHNbcF0gOiBzdGFydFVuaXQpO1xuICAgICAgICAgIHN0YXJ0VW5pdCAhPT0gZW5kVW5pdCAmJiAoc3RhcnROdW0gPSBfY29udmVydFRvVW5pdCh0YXJnZXQsIHAsIHN0YXJ0VmFsdWUsIGVuZFVuaXQpKTtcbiAgICAgICAgICB0aGlzLl9wdCA9IG5ldyBQcm9wVHdlZW4odGhpcy5fcHQsIGlzVHJhbnNmb3JtUmVsYXRlZCA/IGNhY2hlIDogc3R5bGUsIHAsIHN0YXJ0TnVtLCAocmVsYXRpdmUgPyBfcGFyc2VSZWxhdGl2ZShzdGFydE51bSwgcmVsYXRpdmUgKyBlbmROdW0pIDogZW5kTnVtKSAtIHN0YXJ0TnVtLCAhaXNUcmFuc2Zvcm1SZWxhdGVkICYmIChlbmRVbml0ID09PSBcInB4XCIgfHwgcCA9PT0gXCJ6SW5kZXhcIikgJiYgdmFycy5hdXRvUm91bmQgIT09IGZhbHNlID8gX3JlbmRlclJvdW5kZWRDU1NQcm9wIDogX3JlbmRlckNTU1Byb3ApO1xuICAgICAgICAgIHRoaXMuX3B0LnUgPSBlbmRVbml0IHx8IDA7XG5cbiAgICAgICAgICBpZiAoc3RhcnRVbml0ICE9PSBlbmRVbml0ICYmIGVuZFVuaXQgIT09IFwiJVwiKSB7XG4gICAgICAgICAgICAvL3doZW4gdGhlIHR3ZWVuIGdvZXMgYWxsIHRoZSB3YXkgYmFjayB0byB0aGUgYmVnaW5uaW5nLCB3ZSBuZWVkIHRvIHJldmVydCBpdCB0byB0aGUgT0xEL09SSUdJTkFMIHZhbHVlICh3aXRoIHRob3NlIHVuaXRzKS4gV2UgcmVjb3JkIHRoYXQgYXMgYSBcImJcIiAoYmVnaW5uaW5nKSBwcm9wZXJ0eSBhbmQgcG9pbnQgdG8gYSByZW5kZXIgbWV0aG9kIHRoYXQgaGFuZGxlcyB0aGF0LiAocGVyZm9ybWFuY2Ugb3B0aW1pemF0aW9uKVxuICAgICAgICAgICAgdGhpcy5fcHQuYiA9IHN0YXJ0VmFsdWU7XG4gICAgICAgICAgICB0aGlzLl9wdC5yID0gX3JlbmRlckNTU1Byb3BXaXRoQmVnaW5uaW5nO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICghKHAgaW4gc3R5bGUpKSB7XG4gICAgICAgICAgaWYgKHAgaW4gdGFyZ2V0KSB7XG4gICAgICAgICAgICAvL21heWJlIGl0J3Mgbm90IGEgc3R5bGUgLSBpdCBjb3VsZCBiZSBhIHByb3BlcnR5IGFkZGVkIGRpcmVjdGx5IHRvIGFuIGVsZW1lbnQgaW4gd2hpY2ggY2FzZSB3ZSdsbCB0cnkgdG8gYW5pbWF0ZSB0aGF0LlxuICAgICAgICAgICAgdGhpcy5hZGQodGFyZ2V0LCBwLCBzdGFydFZhbHVlIHx8IHRhcmdldFtwXSwgcmVsYXRpdmUgPyByZWxhdGl2ZSArIGVuZFZhbHVlIDogZW5kVmFsdWUsIGluZGV4LCB0YXJnZXRzKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgX21pc3NpbmdQbHVnaW4ocCwgZW5kVmFsdWUpO1xuXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgX3R3ZWVuQ29tcGxleENTU1N0cmluZy5jYWxsKHRoaXMsIHRhcmdldCwgcCwgc3RhcnRWYWx1ZSwgcmVsYXRpdmUgPyByZWxhdGl2ZSArIGVuZFZhbHVlIDogZW5kVmFsdWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgcHJvcHMucHVzaChwKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBoYXNQcmlvcml0eSAmJiBfc29ydFByb3BUd2VlbnNCeVByaW9yaXR5KHRoaXMpO1xuICB9LFxuICBnZXQ6IF9nZXQsXG4gIGFsaWFzZXM6IF9wcm9wZXJ0eUFsaWFzZXMsXG4gIGdldFNldHRlcjogZnVuY3Rpb24gZ2V0U2V0dGVyKHRhcmdldCwgcHJvcGVydHksIHBsdWdpbikge1xuICAgIC8vcmV0dXJucyBhIHNldHRlciBmdW5jdGlvbiB0aGF0IGFjY2VwdHMgdGFyZ2V0LCBwcm9wZXJ0eSwgdmFsdWUgYW5kIGFwcGxpZXMgaXQgYWNjb3JkaW5nbHkuIFJlbWVtYmVyLCBwcm9wZXJ0aWVzIGxpa2UgXCJ4XCIgYXJlbid0IGFzIHNpbXBsZSBhcyB0YXJnZXQuc3R5bGUucHJvcGVydHkgPSB2YWx1ZSBiZWNhdXNlIHRoZXkndmUgZ290IHRvIGJlIGFwcGxpZWQgdG8gYSBwcm94eSBvYmplY3QgYW5kIHRoZW4gbWVyZ2VkIGludG8gYSB0cmFuc2Zvcm0gc3RyaW5nIGluIGEgcmVuZGVyZXIuXG4gICAgdmFyIHAgPSBfcHJvcGVydHlBbGlhc2VzW3Byb3BlcnR5XTtcbiAgICBwICYmIHAuaW5kZXhPZihcIixcIikgPCAwICYmIChwcm9wZXJ0eSA9IHApO1xuICAgIHJldHVybiBwcm9wZXJ0eSBpbiBfdHJhbnNmb3JtUHJvcHMgJiYgcHJvcGVydHkgIT09IF90cmFuc2Zvcm1PcmlnaW5Qcm9wICYmICh0YXJnZXQuX2dzYXAueCB8fCBfZ2V0KHRhcmdldCwgXCJ4XCIpKSA/IHBsdWdpbiAmJiBfcmVjZW50U2V0dGVyUGx1Z2luID09PSBwbHVnaW4gPyBwcm9wZXJ0eSA9PT0gXCJzY2FsZVwiID8gX3NldHRlclNjYWxlIDogX3NldHRlclRyYW5zZm9ybSA6IChfcmVjZW50U2V0dGVyUGx1Z2luID0gcGx1Z2luIHx8IHt9KSAmJiAocHJvcGVydHkgPT09IFwic2NhbGVcIiA/IF9zZXR0ZXJTY2FsZVdpdGhSZW5kZXIgOiBfc2V0dGVyVHJhbnNmb3JtV2l0aFJlbmRlcikgOiB0YXJnZXQuc3R5bGUgJiYgIV9pc1VuZGVmaW5lZCh0YXJnZXQuc3R5bGVbcHJvcGVydHldKSA/IF9zZXR0ZXJDU1NTdHlsZSA6IH5wcm9wZXJ0eS5pbmRleE9mKFwiLVwiKSA/IF9zZXR0ZXJDU1NQcm9wIDogX2dldFNldHRlcih0YXJnZXQsIHByb3BlcnR5KTtcbiAgfSxcbiAgY29yZToge1xuICAgIF9yZW1vdmVQcm9wZXJ0eTogX3JlbW92ZVByb3BlcnR5LFxuICAgIF9nZXRNYXRyaXg6IF9nZXRNYXRyaXhcbiAgfVxufTtcbmdzYXAudXRpbHMuY2hlY2tQcmVmaXggPSBfY2hlY2tQcm9wUHJlZml4O1xuXG4oZnVuY3Rpb24gKHBvc2l0aW9uQW5kU2NhbGUsIHJvdGF0aW9uLCBvdGhlcnMsIGFsaWFzZXMpIHtcbiAgdmFyIGFsbCA9IF9mb3JFYWNoTmFtZShwb3NpdGlvbkFuZFNjYWxlICsgXCIsXCIgKyByb3RhdGlvbiArIFwiLFwiICsgb3RoZXJzLCBmdW5jdGlvbiAobmFtZSkge1xuICAgIF90cmFuc2Zvcm1Qcm9wc1tuYW1lXSA9IDE7XG4gIH0pO1xuXG4gIF9mb3JFYWNoTmFtZShyb3RhdGlvbiwgZnVuY3Rpb24gKG5hbWUpIHtcbiAgICBfY29uZmlnLnVuaXRzW25hbWVdID0gXCJkZWdcIjtcbiAgICBfcm90YXRpb25hbFByb3BlcnRpZXNbbmFtZV0gPSAxO1xuICB9KTtcblxuICBfcHJvcGVydHlBbGlhc2VzW2FsbFsxM11dID0gcG9zaXRpb25BbmRTY2FsZSArIFwiLFwiICsgcm90YXRpb247XG5cbiAgX2ZvckVhY2hOYW1lKGFsaWFzZXMsIGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdmFyIHNwbGl0ID0gbmFtZS5zcGxpdChcIjpcIik7XG4gICAgX3Byb3BlcnR5QWxpYXNlc1tzcGxpdFsxXV0gPSBhbGxbc3BsaXRbMF1dO1xuICB9KTtcbn0pKFwieCx5LHosc2NhbGUsc2NhbGVYLHNjYWxlWSx4UGVyY2VudCx5UGVyY2VudFwiLCBcInJvdGF0aW9uLHJvdGF0aW9uWCxyb3RhdGlvblksc2tld1gsc2tld1lcIiwgXCJ0cmFuc2Zvcm0sdHJhbnNmb3JtT3JpZ2luLHN2Z09yaWdpbixmb3JjZTNELHNtb290aE9yaWdpbix0cmFuc2Zvcm1QZXJzcGVjdGl2ZVwiLCBcIjA6dHJhbnNsYXRlWCwxOnRyYW5zbGF0ZVksMjp0cmFuc2xhdGVaLDg6cm90YXRlLDg6cm90YXRpb25aLDg6cm90YXRlWiw5OnJvdGF0ZVgsMTA6cm90YXRlWVwiKTtcblxuX2ZvckVhY2hOYW1lKFwieCx5LHosdG9wLHJpZ2h0LGJvdHRvbSxsZWZ0LHdpZHRoLGhlaWdodCxmb250U2l6ZSxwYWRkaW5nLG1hcmdpbixwZXJzcGVjdGl2ZVwiLCBmdW5jdGlvbiAobmFtZSkge1xuICBfY29uZmlnLnVuaXRzW25hbWVdID0gXCJweFwiO1xufSk7XG5cbmdzYXAucmVnaXN0ZXJQbHVnaW4oQ1NTUGx1Z2luKTtcbmV4cG9ydCB7IENTU1BsdWdpbiBhcyBkZWZhdWx0LCBfZ2V0QkJveCwgX2NyZWF0ZUVsZW1lbnQsIF9jaGVja1Byb3BQcmVmaXggYXMgY2hlY2tQcmVmaXggfTsiLCJpbXBvcnQgeyBnc2FwLCBQb3dlcjAsIFBvd2VyMSwgUG93ZXIyLCBQb3dlcjMsIFBvd2VyNCwgTGluZWFyLCBRdWFkLCBDdWJpYywgUXVhcnQsIFF1aW50LCBTdHJvbmcsIEVsYXN0aWMsIEJhY2ssIFN0ZXBwZWRFYXNlLCBCb3VuY2UsIFNpbmUsIEV4cG8sIENpcmMsIFR3ZWVuTGl0ZSwgVGltZWxpbmVMaXRlLCBUaW1lbGluZU1heCB9IGZyb20gXCIuL2dzYXAtY29yZS5qc1wiO1xuaW1wb3J0IHsgQ1NTUGx1Z2luIH0gZnJvbSBcIi4vQ1NTUGx1Z2luLmpzXCI7XG52YXIgZ3NhcFdpdGhDU1MgPSBnc2FwLnJlZ2lzdGVyUGx1Z2luKENTU1BsdWdpbikgfHwgZ3NhcCxcbiAgICAvLyB0byBwcm90ZWN0IGZyb20gdHJlZSBzaGFraW5nXG5Ud2Vlbk1heFdpdGhDU1MgPSBnc2FwV2l0aENTUy5jb3JlLlR3ZWVuO1xuZXhwb3J0IHsgZ3NhcFdpdGhDU1MgYXMgZ3NhcCwgZ3NhcFdpdGhDU1MgYXMgZGVmYXVsdCwgQ1NTUGx1Z2luLCBUd2Vlbk1heFdpdGhDU1MgYXMgVHdlZW5NYXgsIFR3ZWVuTGl0ZSwgVGltZWxpbmVNYXgsIFRpbWVsaW5lTGl0ZSwgUG93ZXIwLCBQb3dlcjEsIFBvd2VyMiwgUG93ZXIzLCBQb3dlcjQsIExpbmVhciwgUXVhZCwgQ3ViaWMsIFF1YXJ0LCBRdWludCwgU3Ryb25nLCBFbGFzdGljLCBCYWNrLCBTdGVwcGVkRWFzZSwgQm91bmNlLCBTaW5lLCBFeHBvLCBDaXJjIH07IiwiLyohXG4gKiBtYXRyaXggMy4xMC40XG4gKiBodHRwczovL2dyZWVuc29jay5jb21cbiAqXG4gKiBDb3B5cmlnaHQgMjAwOC0yMDIyLCBHcmVlblNvY2suIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBTdWJqZWN0IHRvIHRoZSB0ZXJtcyBhdCBodHRwczovL2dyZWVuc29jay5jb20vc3RhbmRhcmQtbGljZW5zZSBvciBmb3JcbiAqIENsdWIgR3JlZW5Tb2NrIG1lbWJlcnMsIHRoZSBhZ3JlZW1lbnQgaXNzdWVkIHdpdGggdGhhdCBtZW1iZXJzaGlwLlxuICogQGF1dGhvcjogSmFjayBEb3lsZSwgamFja0BncmVlbnNvY2suY29tXG4qL1xuXG4vKiBlc2xpbnQtZGlzYWJsZSAqL1xudmFyIF9kb2MsXG4gICAgX3dpbixcbiAgICBfZG9jRWxlbWVudCxcbiAgICBfYm9keSxcbiAgICBfZGl2Q29udGFpbmVyLFxuICAgIF9zdmdDb250YWluZXIsXG4gICAgX2lkZW50aXR5TWF0cml4LFxuICAgIF9nRWwsXG4gICAgX3RyYW5zZm9ybVByb3AgPSBcInRyYW5zZm9ybVwiLFxuICAgIF90cmFuc2Zvcm1PcmlnaW5Qcm9wID0gX3RyYW5zZm9ybVByb3AgKyBcIk9yaWdpblwiLFxuICAgIF9oYXNPZmZzZXRCdWcsXG4gICAgX3NldERvYyA9IGZ1bmN0aW9uIF9zZXREb2MoZWxlbWVudCkge1xuICB2YXIgZG9jID0gZWxlbWVudC5vd25lckRvY3VtZW50IHx8IGVsZW1lbnQ7XG5cbiAgaWYgKCEoX3RyYW5zZm9ybVByb3AgaW4gZWxlbWVudC5zdHlsZSkgJiYgXCJtc1RyYW5zZm9ybVwiIGluIGVsZW1lbnQuc3R5bGUpIHtcbiAgICAvL3RvIGltcHJvdmUgY29tcGF0aWJpbGl0eSB3aXRoIG9sZCBNaWNyb3NvZnQgYnJvd3NlcnNcbiAgICBfdHJhbnNmb3JtUHJvcCA9IFwibXNUcmFuc2Zvcm1cIjtcbiAgICBfdHJhbnNmb3JtT3JpZ2luUHJvcCA9IF90cmFuc2Zvcm1Qcm9wICsgXCJPcmlnaW5cIjtcbiAgfVxuXG4gIHdoaWxlIChkb2MucGFyZW50Tm9kZSAmJiAoZG9jID0gZG9jLnBhcmVudE5vZGUpKSB7fVxuXG4gIF93aW4gPSB3aW5kb3c7XG4gIF9pZGVudGl0eU1hdHJpeCA9IG5ldyBNYXRyaXgyRCgpO1xuXG4gIGlmIChkb2MpIHtcbiAgICBfZG9jID0gZG9jO1xuICAgIF9kb2NFbGVtZW50ID0gZG9jLmRvY3VtZW50RWxlbWVudDtcbiAgICBfYm9keSA9IGRvYy5ib2R5O1xuICAgIF9nRWwgPSBfZG9jLmNyZWF0ZUVsZW1lbnROUyhcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIsIFwiZ1wiKTsgLy8gcHJldmVudCBhbnkgZXhpc3RpbmcgQ1NTIGZyb20gdHJhbnNmb3JtaW5nIGl0XG5cbiAgICBfZ0VsLnN0eWxlLnRyYW5zZm9ybSA9IFwibm9uZVwiOyAvLyBub3cgdGVzdCBmb3IgdGhlIG9mZnNldCByZXBvcnRpbmcgYnVnLiBVc2UgZmVhdHVyZSBkZXRlY3Rpb24gaW5zdGVhZCBvZiBicm93c2VyIHNuaWZmaW5nIHRvIG1ha2UgdGhpbmdzIG1vcmUgYnVsbGV0cHJvb2YgYW5kIGZ1dHVyZS1wcm9vZi4gSG9wZWZ1bGx5IFNhZmFyaSB3aWxsIGZpeCB0aGVpciBidWcgc29vbiBidXQgaXQncyAyMDIwIGFuZCBpdCdzIHN0aWxsIG5vdCBmaXhlZC5cblxuICAgIHZhciBkMSA9IGRvYy5jcmVhdGVFbGVtZW50KFwiZGl2XCIpLFxuICAgICAgICBkMiA9IGRvYy5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuXG4gICAgX2JvZHkuYXBwZW5kQ2hpbGQoZDEpO1xuXG4gICAgZDEuYXBwZW5kQ2hpbGQoZDIpO1xuICAgIGQxLnN0eWxlLnBvc2l0aW9uID0gXCJzdGF0aWNcIjtcbiAgICBkMS5zdHlsZVtfdHJhbnNmb3JtUHJvcF0gPSBcInRyYW5zbGF0ZTNkKDAsMCwxcHgpXCI7XG4gICAgX2hhc09mZnNldEJ1ZyA9IGQyLm9mZnNldFBhcmVudCAhPT0gZDE7XG5cbiAgICBfYm9keS5yZW1vdmVDaGlsZChkMSk7XG4gIH1cblxuICByZXR1cm4gZG9jO1xufSxcbiAgICBfZm9yY2VOb25aZXJvU2NhbGUgPSBmdW5jdGlvbiBfZm9yY2VOb25aZXJvU2NhbGUoZSkge1xuICAvLyB3YWxrcyB1cCB0aGUgZWxlbWVudCdzIGFuY2VzdG9ycyBhbmQgZmluZHMgYW55IHRoYXQgaGFkIHRoZWlyIHNjYWxlIHNldCB0byAwIHZpYSBHU0FQLCBhbmQgY2hhbmdlcyB0aGVtIHRvIDAuMDAwMSB0byBlbnN1cmUgdGhhdCBtZWFzdXJlbWVudHMgd29yay4gRmlyZWZveCBoYXMgYSBidWcgdGhhdCBjYXVzZXMgaXQgdG8gaW5jb3JyZWN0bHkgcmVwb3J0IGdldEJvdW5kaW5nQ2xpZW50UmVjdCgpIHdoZW4gc2NhbGUgaXMgMC5cbiAgdmFyIGEsIGNhY2hlO1xuXG4gIHdoaWxlIChlICYmIGUgIT09IF9ib2R5KSB7XG4gICAgY2FjaGUgPSBlLl9nc2FwO1xuICAgIGNhY2hlICYmIGNhY2hlLnVuY2FjaGUgJiYgY2FjaGUuZ2V0KGUsIFwieFwiKTsgLy8gZm9yY2UgcmUtcGFyc2luZyBvZiB0cmFuc2Zvcm1zIGlmIG5lY2Vzc2FyeVxuXG4gICAgaWYgKGNhY2hlICYmICFjYWNoZS5zY2FsZVggJiYgIWNhY2hlLnNjYWxlWSAmJiBjYWNoZS5yZW5kZXJUcmFuc2Zvcm0pIHtcbiAgICAgIGNhY2hlLnNjYWxlWCA9IGNhY2hlLnNjYWxlWSA9IDFlLTQ7XG4gICAgICBjYWNoZS5yZW5kZXJUcmFuc2Zvcm0oMSwgY2FjaGUpO1xuICAgICAgYSA/IGEucHVzaChjYWNoZSkgOiBhID0gW2NhY2hlXTtcbiAgICB9XG5cbiAgICBlID0gZS5wYXJlbnROb2RlO1xuICB9XG5cbiAgcmV0dXJuIGE7XG59LFxuICAgIC8vIHBvc3NpYmxlIGZ1dHVyZSBhZGRpdGlvbjogcGFzcyBhbiBlbGVtZW50IHRvIF9mb3JjZURpc3BsYXkoKSBhbmQgaXQnbGwgd2FsayB1cCBhbGwgaXRzIGFuY2VzdG9ycyBhbmQgbWFrZSBzdXJlIGFueXRoaW5nIHdpdGggZGlzcGxheTogbm9uZSBpcyBzZXQgdG8gZGlzcGxheTogYmxvY2ssIGFuZCBpZiB0aGVyZSdzIG5vIHBhcmVudE5vZGUsIGl0J2xsIGFkZCBpdCB0byB0aGUgYm9keS4gSXQgcmV0dXJucyBhbiBBcnJheSB0aGF0IHlvdSBjYW4gdGhlbiBmZWVkIHRvIF9yZXZlcnREaXNwbGF5KCkgdG8gaGF2ZSBpdCByZXZlcnQgYWxsIHRoZSBjaGFuZ2VzIGl0IG1hZGUuXG4vLyBfZm9yY2VEaXNwbGF5ID0gZSA9PiB7XG4vLyBcdGxldCBhID0gW10sXG4vLyBcdFx0cGFyZW50O1xuLy8gXHR3aGlsZSAoZSAmJiBlICE9PSBfYm9keSkge1xuLy8gXHRcdHBhcmVudCA9IGUucGFyZW50Tm9kZTtcbi8vIFx0XHQoX3dpbi5nZXRDb21wdXRlZFN0eWxlKGUpLmRpc3BsYXkgPT09IFwibm9uZVwiIHx8ICFwYXJlbnQpICYmIGEucHVzaChlLCBlLnN0eWxlLmRpc3BsYXksIHBhcmVudCkgJiYgKGUuc3R5bGUuZGlzcGxheSA9IFwiYmxvY2tcIik7XG4vLyBcdFx0cGFyZW50IHx8IF9ib2R5LmFwcGVuZENoaWxkKGUpO1xuLy8gXHRcdGUgPSBwYXJlbnQ7XG4vLyBcdH1cbi8vIFx0cmV0dXJuIGE7XG4vLyB9LFxuLy8gX3JldmVydERpc3BsYXkgPSBhID0+IHtcbi8vIFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBhLmxlbmd0aDsgaSs9Mykge1xuLy8gXHRcdGFbaSsxXSA/IChhW2ldLnN0eWxlLmRpc3BsYXkgPSBhW2krMV0pIDogYVtpXS5zdHlsZS5yZW1vdmVQcm9wZXJ0eShcImRpc3BsYXlcIik7XG4vLyBcdFx0YVtpKzJdIHx8IGFbaV0ucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChhW2ldKTtcbi8vIFx0fVxuLy8gfSxcbl9zdmdUZW1wcyA9IFtdLFxuICAgIC8vd2UgY3JlYXRlIDMgZWxlbWVudHMgZm9yIFNWRywgYW5kIDMgZm9yIG90aGVyIERPTSBlbGVtZW50cyBhbmQgY2FjaGUgdGhlbSBmb3IgcGVyZm9ybWFuY2UgcmVhc29ucy4gVGhleSBnZXQgbmVzdGVkIGluIF9kaXZDb250YWluZXIgYW5kIF9zdmdDb250YWluZXIgc28gdGhhdCBqdXN0IG9uZSBlbGVtZW50IGlzIGFkZGVkIHRvIHRoZSBET00gb24gZWFjaCBzdWNjZXNzaXZlIGF0dGVtcHQuIEFnYWluLCBwZXJmb3JtYW5jZSBpcyBrZXkuXG5fZGl2VGVtcHMgPSBbXSxcbiAgICBfZ2V0RG9jU2Nyb2xsVG9wID0gZnVuY3Rpb24gX2dldERvY1Njcm9sbFRvcCgpIHtcbiAgcmV0dXJuIF93aW4ucGFnZVlPZmZzZXQgfHwgX2RvYy5zY3JvbGxUb3AgfHwgX2RvY0VsZW1lbnQuc2Nyb2xsVG9wIHx8IF9ib2R5LnNjcm9sbFRvcCB8fCAwO1xufSxcbiAgICBfZ2V0RG9jU2Nyb2xsTGVmdCA9IGZ1bmN0aW9uIF9nZXREb2NTY3JvbGxMZWZ0KCkge1xuICByZXR1cm4gX3dpbi5wYWdlWE9mZnNldCB8fCBfZG9jLnNjcm9sbExlZnQgfHwgX2RvY0VsZW1lbnQuc2Nyb2xsTGVmdCB8fCBfYm9keS5zY3JvbGxMZWZ0IHx8IDA7XG59LFxuICAgIF9zdmdPd25lciA9IGZ1bmN0aW9uIF9zdmdPd25lcihlbGVtZW50KSB7XG4gIHJldHVybiBlbGVtZW50Lm93bmVyU1ZHRWxlbWVudCB8fCAoKGVsZW1lbnQudGFnTmFtZSArIFwiXCIpLnRvTG93ZXJDYXNlKCkgPT09IFwic3ZnXCIgPyBlbGVtZW50IDogbnVsbCk7XG59LFxuICAgIF9pc0ZpeGVkID0gZnVuY3Rpb24gX2lzRml4ZWQoZWxlbWVudCkge1xuICBpZiAoX3dpbi5nZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpLnBvc2l0aW9uID09PSBcImZpeGVkXCIpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGVsZW1lbnQgPSBlbGVtZW50LnBhcmVudE5vZGU7XG5cbiAgaWYgKGVsZW1lbnQgJiYgZWxlbWVudC5ub2RlVHlwZSA9PT0gMSkge1xuICAgIC8vIGF2b2lkIGRvY3VtZW50IGZyYWdtZW50cyB3aGljaCB3aWxsIHRocm93IGFuIGVycm9yLlxuICAgIHJldHVybiBfaXNGaXhlZChlbGVtZW50KTtcbiAgfVxufSxcbiAgICBfY3JlYXRlU2libGluZyA9IGZ1bmN0aW9uIF9jcmVhdGVTaWJsaW5nKGVsZW1lbnQsIGkpIHtcbiAgaWYgKGVsZW1lbnQucGFyZW50Tm9kZSAmJiAoX2RvYyB8fCBfc2V0RG9jKGVsZW1lbnQpKSkge1xuICAgIHZhciBzdmcgPSBfc3ZnT3duZXIoZWxlbWVudCksXG4gICAgICAgIG5zID0gc3ZnID8gc3ZnLmdldEF0dHJpYnV0ZShcInhtbG5zXCIpIHx8IFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiA6IFwiaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbFwiLFxuICAgICAgICB0eXBlID0gc3ZnID8gaSA/IFwicmVjdFwiIDogXCJnXCIgOiBcImRpdlwiLFxuICAgICAgICB4ID0gaSAhPT0gMiA/IDAgOiAxMDAsXG4gICAgICAgIHkgPSBpID09PSAzID8gMTAwIDogMCxcbiAgICAgICAgY3NzID0gXCJwb3NpdGlvbjphYnNvbHV0ZTtkaXNwbGF5OmJsb2NrO3BvaW50ZXItZXZlbnRzOm5vbmU7bWFyZ2luOjA7cGFkZGluZzowO1wiLFxuICAgICAgICBlID0gX2RvYy5jcmVhdGVFbGVtZW50TlMgPyBfZG9jLmNyZWF0ZUVsZW1lbnROUyhucy5yZXBsYWNlKC9eaHR0cHMvLCBcImh0dHBcIiksIHR5cGUpIDogX2RvYy5jcmVhdGVFbGVtZW50KHR5cGUpO1xuXG4gICAgaWYgKGkpIHtcbiAgICAgIGlmICghc3ZnKSB7XG4gICAgICAgIGlmICghX2RpdkNvbnRhaW5lcikge1xuICAgICAgICAgIF9kaXZDb250YWluZXIgPSBfY3JlYXRlU2libGluZyhlbGVtZW50KTtcbiAgICAgICAgICBfZGl2Q29udGFpbmVyLnN0eWxlLmNzc1RleHQgPSBjc3M7XG4gICAgICAgIH1cblxuICAgICAgICBlLnN0eWxlLmNzc1RleHQgPSBjc3MgKyBcIndpZHRoOjAuMXB4O2hlaWdodDowLjFweDt0b3A6XCIgKyB5ICsgXCJweDtsZWZ0OlwiICsgeCArIFwicHhcIjtcblxuICAgICAgICBfZGl2Q29udGFpbmVyLmFwcGVuZENoaWxkKGUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgX3N2Z0NvbnRhaW5lciB8fCAoX3N2Z0NvbnRhaW5lciA9IF9jcmVhdGVTaWJsaW5nKGVsZW1lbnQpKTtcbiAgICAgICAgZS5zZXRBdHRyaWJ1dGUoXCJ3aWR0aFwiLCAwLjAxKTtcbiAgICAgICAgZS5zZXRBdHRyaWJ1dGUoXCJoZWlnaHRcIiwgMC4wMSk7XG4gICAgICAgIGUuc2V0QXR0cmlidXRlKFwidHJhbnNmb3JtXCIsIFwidHJhbnNsYXRlKFwiICsgeCArIFwiLFwiICsgeSArIFwiKVwiKTtcblxuICAgICAgICBfc3ZnQ29udGFpbmVyLmFwcGVuZENoaWxkKGUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBlO1xuICB9XG5cbiAgdGhyb3cgXCJOZWVkIGRvY3VtZW50IGFuZCBwYXJlbnQuXCI7XG59LFxuICAgIF9jb25zb2xpZGF0ZSA9IGZ1bmN0aW9uIF9jb25zb2xpZGF0ZShtKSB7XG4gIC8vIHJlcGxhY2VzIFNWR1RyYW5zZm9ybUxpc3QuY29uc29saWRhdGUoKSBiZWNhdXNlIGEgYnVnIGluIEZpcmVmb3ggY2F1c2VzIGl0IHRvIGJyZWFrIHBvaW50ZXIgZXZlbnRzLiBTZWUgaHR0cHM6Ly9ncmVlbnNvY2suY29tL2ZvcnVtcy90b3BpYy8yMzI0OC10b3VjaC1pcy1ub3Qtd29ya2luZy1vbi1kcmFnZ2FibGUtaW4tZmlyZWZveC13aW5kb3dzLXYzMjQvP3RhYj1jb21tZW50cyNjb21tZW50LTEwOTgwMFxuICB2YXIgYyA9IG5ldyBNYXRyaXgyRCgpLFxuICAgICAgaSA9IDA7XG5cbiAgZm9yICg7IGkgPCBtLm51bWJlck9mSXRlbXM7IGkrKykge1xuICAgIGMubXVsdGlwbHkobS5nZXRJdGVtKGkpLm1hdHJpeCk7XG4gIH1cblxuICByZXR1cm4gYztcbn0sXG4gICAgX2dldENUTSA9IGZ1bmN0aW9uIF9nZXRDVE0oc3ZnKSB7XG4gIHZhciBtID0gc3ZnLmdldENUTSgpLFxuICAgICAgdHJhbnNmb3JtO1xuXG4gIGlmICghbSkge1xuICAgIC8vIEZpcmVmb3ggcmV0dXJucyBudWxsIGZvciBnZXRDVE0oKSBvbiByb290IDxzdmc+IGVsZW1lbnRzLCBzbyB0aGlzIGlzIGEgd29ya2Fyb3VuZCB1c2luZyBhIDxnPiB0aGF0IHdlIHRlbXBvcmFyaWx5IGFwcGVuZC5cbiAgICB0cmFuc2Zvcm0gPSBzdmcuc3R5bGVbX3RyYW5zZm9ybVByb3BdO1xuICAgIHN2Zy5zdHlsZVtfdHJhbnNmb3JtUHJvcF0gPSBcIm5vbmVcIjsgLy8gYSBidWcgaW4gRmlyZWZveCBjYXVzZXMgY3NzIHRyYW5zZm9ybXMgdG8gY29udGFtaW5hdGUgdGhlIGdldENUTSgpXG5cbiAgICBzdmcuYXBwZW5kQ2hpbGQoX2dFbCk7XG4gICAgbSA9IF9nRWwuZ2V0Q1RNKCk7XG4gICAgc3ZnLnJlbW92ZUNoaWxkKF9nRWwpO1xuICAgIHRyYW5zZm9ybSA/IHN2Zy5zdHlsZVtfdHJhbnNmb3JtUHJvcF0gPSB0cmFuc2Zvcm0gOiBzdmcuc3R5bGUucmVtb3ZlUHJvcGVydHkoX3RyYW5zZm9ybVByb3AucmVwbGFjZSgvKFtBLVpdKS9nLCBcIi0kMVwiKS50b0xvd2VyQ2FzZSgpKTtcbiAgfVxuXG4gIHJldHVybiBtIHx8IF9pZGVudGl0eU1hdHJpeC5jbG9uZSgpOyAvLyBGaXJlZm94IHdpbGwgc3RpbGwgcmV0dXJuIG51bGwgaWYgdGhlIDxzdmc+IGhhcyBhIHdpZHRoL2hlaWdodCBvZiAwIGluIHRoZSBicm93c2VyLlxufSxcbiAgICBfcGxhY2VTaWJsaW5ncyA9IGZ1bmN0aW9uIF9wbGFjZVNpYmxpbmdzKGVsZW1lbnQsIGFkanVzdEdPZmZzZXQpIHtcbiAgdmFyIHN2ZyA9IF9zdmdPd25lcihlbGVtZW50KSxcbiAgICAgIGlzUm9vdFNWRyA9IGVsZW1lbnQgPT09IHN2ZyxcbiAgICAgIHNpYmxpbmdzID0gc3ZnID8gX3N2Z1RlbXBzIDogX2RpdlRlbXBzLFxuICAgICAgcGFyZW50ID0gZWxlbWVudC5wYXJlbnROb2RlLFxuICAgICAgY29udGFpbmVyLFxuICAgICAgbSxcbiAgICAgIGIsXG4gICAgICB4LFxuICAgICAgeSxcbiAgICAgIGNzO1xuXG4gIGlmIChlbGVtZW50ID09PSBfd2luKSB7XG4gICAgcmV0dXJuIGVsZW1lbnQ7XG4gIH1cblxuICBzaWJsaW5ncy5sZW5ndGggfHwgc2libGluZ3MucHVzaChfY3JlYXRlU2libGluZyhlbGVtZW50LCAxKSwgX2NyZWF0ZVNpYmxpbmcoZWxlbWVudCwgMiksIF9jcmVhdGVTaWJsaW5nKGVsZW1lbnQsIDMpKTtcbiAgY29udGFpbmVyID0gc3ZnID8gX3N2Z0NvbnRhaW5lciA6IF9kaXZDb250YWluZXI7XG5cbiAgaWYgKHN2Zykge1xuICAgIGlmIChpc1Jvb3RTVkcpIHtcbiAgICAgIGIgPSBfZ2V0Q1RNKGVsZW1lbnQpO1xuICAgICAgeCA9IC1iLmUgLyBiLmE7XG4gICAgICB5ID0gLWIuZiAvIGIuZDtcbiAgICAgIG0gPSBfaWRlbnRpdHlNYXRyaXg7XG4gICAgfSBlbHNlIGlmIChlbGVtZW50LmdldEJCb3gpIHtcbiAgICAgIGIgPSBlbGVtZW50LmdldEJCb3goKTtcbiAgICAgIG0gPSBlbGVtZW50LnRyYW5zZm9ybSA/IGVsZW1lbnQudHJhbnNmb3JtLmJhc2VWYWwgOiB7fTsgLy8gSUUxMSBkb2Vzbid0IGZvbGxvdyB0aGUgc3BlYy5cblxuICAgICAgbSA9ICFtLm51bWJlck9mSXRlbXMgPyBfaWRlbnRpdHlNYXRyaXggOiBtLm51bWJlck9mSXRlbXMgPiAxID8gX2NvbnNvbGlkYXRlKG0pIDogbS5nZXRJdGVtKDApLm1hdHJpeDsgLy8gZG9uJ3QgY2FsbCBtLmNvbnNvbGlkYXRlKCkubWF0cml4IGJlY2F1c2UgYSBidWcgaW4gRmlyZWZveCBtYWtlcyBwb2ludGVyIGV2ZW50cyBub3Qgd29yayB3aGVuIGNvbnNvbGlkYXRlKCkgaXMgY2FsbGVkIG9uIHRoZSBzYW1lIHRpY2sgYXMgZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkhIFNlZSBodHRwczovL2dyZWVuc29jay5jb20vZm9ydW1zL3RvcGljLzIzMjQ4LXRvdWNoLWlzLW5vdC13b3JraW5nLW9uLWRyYWdnYWJsZS1pbi1maXJlZm94LXdpbmRvd3MtdjMyNC8/dGFiPWNvbW1lbnRzI2NvbW1lbnQtMTA5ODAwXG5cbiAgICAgIHggPSBtLmEgKiBiLnggKyBtLmMgKiBiLnk7XG4gICAgICB5ID0gbS5iICogYi54ICsgbS5kICogYi55O1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBtYXkgYmUgYSA8bWFzaz4gd2hpY2ggaGFzIG5vIGdldEJCb3goKSBzbyBqdXN0IHVzZSBkZWZhdWx0cyBpbnN0ZWFkIG9mIHRocm93aW5nIGVycm9ycy5cbiAgICAgIG0gPSBuZXcgTWF0cml4MkQoKTtcbiAgICAgIHggPSB5ID0gMDtcbiAgICB9XG5cbiAgICBpZiAoYWRqdXN0R09mZnNldCAmJiBlbGVtZW50LnRhZ05hbWUudG9Mb3dlckNhc2UoKSA9PT0gXCJnXCIpIHtcbiAgICAgIHggPSB5ID0gMDtcbiAgICB9XG5cbiAgICAoaXNSb290U1ZHID8gc3ZnIDogcGFyZW50KS5hcHBlbmRDaGlsZChjb250YWluZXIpO1xuICAgIGNvbnRhaW5lci5zZXRBdHRyaWJ1dGUoXCJ0cmFuc2Zvcm1cIiwgXCJtYXRyaXgoXCIgKyBtLmEgKyBcIixcIiArIG0uYiArIFwiLFwiICsgbS5jICsgXCIsXCIgKyBtLmQgKyBcIixcIiArIChtLmUgKyB4KSArIFwiLFwiICsgKG0uZiArIHkpICsgXCIpXCIpO1xuICB9IGVsc2Uge1xuICAgIHggPSB5ID0gMDtcblxuICAgIGlmIChfaGFzT2Zmc2V0QnVnKSB7XG4gICAgICAvLyBzb21lIGJyb3dzZXJzIChsaWtlIFNhZmFyaSkgaGF2ZSBhIGJ1ZyB0aGF0IGNhdXNlcyB0aGVtIHRvIG1pc3JlcG9ydCBvZmZzZXQgdmFsdWVzLiBXaGVuIGFuIGFuY2VzdG9yIGVsZW1lbnQgaGFzIGEgdHJhbnNmb3JtIGFwcGxpZWQsIGl0J3Mgc3VwcG9zZWQgdG8gdHJlYXQgaXQgYXMgaWYgaXQncyBwb3NpdGlvbjogcmVsYXRpdmUgKG5ldyBjb250ZXh0KS4gU2FmYXJpIGJvdGNoZXMgdGhpcywgc28gd2UgbmVlZCB0byBmaW5kIHRoZSBjbG9zZXN0IGFuY2VzdG9yIChiZXR3ZWVuIHRoZSBlbGVtZW50IGFuZCBpdHMgb2Zmc2V0UGFyZW50KSB0aGF0IGhhcyBhIHRyYW5zZm9ybSBhcHBsaWVkIGFuZCBpZiBvbmUgaXMgZm91bmQsIGdyYWIgaXRzIG9mZnNldFRvcC9MZWZ0IGFuZCBzdWJ0cmFjdCB0aGVtIHRvIGNvbXBlbnNhdGUuXG4gICAgICBtID0gZWxlbWVudC5vZmZzZXRQYXJlbnQ7XG4gICAgICBiID0gZWxlbWVudDtcblxuICAgICAgd2hpbGUgKGIgJiYgKGIgPSBiLnBhcmVudE5vZGUpICYmIGIgIT09IG0gJiYgYi5wYXJlbnROb2RlKSB7XG4gICAgICAgIGlmICgoX3dpbi5nZXRDb21wdXRlZFN0eWxlKGIpW190cmFuc2Zvcm1Qcm9wXSArIFwiXCIpLmxlbmd0aCA+IDQpIHtcbiAgICAgICAgICB4ID0gYi5vZmZzZXRMZWZ0O1xuICAgICAgICAgIHkgPSBiLm9mZnNldFRvcDtcbiAgICAgICAgICBiID0gMDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGNzID0gX3dpbi5nZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpO1xuXG4gICAgaWYgKGNzLnBvc2l0aW9uICE9PSBcImFic29sdXRlXCIgJiYgY3MucG9zaXRpb24gIT09IFwiZml4ZWRcIikge1xuICAgICAgbSA9IGVsZW1lbnQub2Zmc2V0UGFyZW50O1xuXG4gICAgICB3aGlsZSAocGFyZW50ICYmIHBhcmVudCAhPT0gbSkge1xuICAgICAgICAvLyBpZiB0aGVyZSdzIGFuIGFuY2VzdG9yIGVsZW1lbnQgYmV0d2VlbiB0aGUgZWxlbWVudCBhbmQgaXRzIG9mZnNldFBhcmVudCB0aGF0J3Mgc2Nyb2xsZWQsIHdlIG11c3QgZmFjdG9yIHRoYXQgaW4uXG4gICAgICAgIHggKz0gcGFyZW50LnNjcm9sbExlZnQgfHwgMDtcbiAgICAgICAgeSArPSBwYXJlbnQuc2Nyb2xsVG9wIHx8IDA7XG4gICAgICAgIHBhcmVudCA9IHBhcmVudC5wYXJlbnROb2RlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGIgPSBjb250YWluZXIuc3R5bGU7XG4gICAgYi50b3AgPSBlbGVtZW50Lm9mZnNldFRvcCAtIHkgKyBcInB4XCI7XG4gICAgYi5sZWZ0ID0gZWxlbWVudC5vZmZzZXRMZWZ0IC0geCArIFwicHhcIjtcbiAgICBiW190cmFuc2Zvcm1Qcm9wXSA9IGNzW190cmFuc2Zvcm1Qcm9wXTtcbiAgICBiW190cmFuc2Zvcm1PcmlnaW5Qcm9wXSA9IGNzW190cmFuc2Zvcm1PcmlnaW5Qcm9wXTsgLy8gYi5ib3JkZXIgPSBtLmJvcmRlcjtcbiAgICAvLyBiLmJvcmRlckxlZnRTdHlsZSA9IG0uYm9yZGVyTGVmdFN0eWxlO1xuICAgIC8vIGIuYm9yZGVyVG9wU3R5bGUgPSBtLmJvcmRlclRvcFN0eWxlO1xuICAgIC8vIGIuYm9yZGVyTGVmdFdpZHRoID0gbS5ib3JkZXJMZWZ0V2lkdGg7XG4gICAgLy8gYi5ib3JkZXJUb3BXaWR0aCA9IG0uYm9yZGVyVG9wV2lkdGg7XG5cbiAgICBiLnBvc2l0aW9uID0gY3MucG9zaXRpb24gPT09IFwiZml4ZWRcIiA/IFwiZml4ZWRcIiA6IFwiYWJzb2x1dGVcIjtcbiAgICBlbGVtZW50LnBhcmVudE5vZGUuYXBwZW5kQ2hpbGQoY29udGFpbmVyKTtcbiAgfVxuXG4gIHJldHVybiBjb250YWluZXI7XG59LFxuICAgIF9zZXRNYXRyaXggPSBmdW5jdGlvbiBfc2V0TWF0cml4KG0sIGEsIGIsIGMsIGQsIGUsIGYpIHtcbiAgbS5hID0gYTtcbiAgbS5iID0gYjtcbiAgbS5jID0gYztcbiAgbS5kID0gZDtcbiAgbS5lID0gZTtcbiAgbS5mID0gZjtcbiAgcmV0dXJuIG07XG59O1xuXG5leHBvcnQgdmFyIE1hdHJpeDJEID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gTWF0cml4MkQoYSwgYiwgYywgZCwgZSwgZikge1xuICAgIGlmIChhID09PSB2b2lkIDApIHtcbiAgICAgIGEgPSAxO1xuICAgIH1cblxuICAgIGlmIChiID09PSB2b2lkIDApIHtcbiAgICAgIGIgPSAwO1xuICAgIH1cblxuICAgIGlmIChjID09PSB2b2lkIDApIHtcbiAgICAgIGMgPSAwO1xuICAgIH1cblxuICAgIGlmIChkID09PSB2b2lkIDApIHtcbiAgICAgIGQgPSAxO1xuICAgIH1cblxuICAgIGlmIChlID09PSB2b2lkIDApIHtcbiAgICAgIGUgPSAwO1xuICAgIH1cblxuICAgIGlmIChmID09PSB2b2lkIDApIHtcbiAgICAgIGYgPSAwO1xuICAgIH1cblxuICAgIF9zZXRNYXRyaXgodGhpcywgYSwgYiwgYywgZCwgZSwgZik7XG4gIH1cblxuICB2YXIgX3Byb3RvID0gTWF0cml4MkQucHJvdG90eXBlO1xuXG4gIF9wcm90by5pbnZlcnNlID0gZnVuY3Rpb24gaW52ZXJzZSgpIHtcbiAgICB2YXIgYSA9IHRoaXMuYSxcbiAgICAgICAgYiA9IHRoaXMuYixcbiAgICAgICAgYyA9IHRoaXMuYyxcbiAgICAgICAgZCA9IHRoaXMuZCxcbiAgICAgICAgZSA9IHRoaXMuZSxcbiAgICAgICAgZiA9IHRoaXMuZixcbiAgICAgICAgZGV0ZXJtaW5hbnQgPSBhICogZCAtIGIgKiBjIHx8IDFlLTEwO1xuICAgIHJldHVybiBfc2V0TWF0cml4KHRoaXMsIGQgLyBkZXRlcm1pbmFudCwgLWIgLyBkZXRlcm1pbmFudCwgLWMgLyBkZXRlcm1pbmFudCwgYSAvIGRldGVybWluYW50LCAoYyAqIGYgLSBkICogZSkgLyBkZXRlcm1pbmFudCwgLShhICogZiAtIGIgKiBlKSAvIGRldGVybWluYW50KTtcbiAgfTtcblxuICBfcHJvdG8ubXVsdGlwbHkgPSBmdW5jdGlvbiBtdWx0aXBseShtYXRyaXgpIHtcbiAgICB2YXIgYSA9IHRoaXMuYSxcbiAgICAgICAgYiA9IHRoaXMuYixcbiAgICAgICAgYyA9IHRoaXMuYyxcbiAgICAgICAgZCA9IHRoaXMuZCxcbiAgICAgICAgZSA9IHRoaXMuZSxcbiAgICAgICAgZiA9IHRoaXMuZixcbiAgICAgICAgYTIgPSBtYXRyaXguYSxcbiAgICAgICAgYjIgPSBtYXRyaXguYyxcbiAgICAgICAgYzIgPSBtYXRyaXguYixcbiAgICAgICAgZDIgPSBtYXRyaXguZCxcbiAgICAgICAgZTIgPSBtYXRyaXguZSxcbiAgICAgICAgZjIgPSBtYXRyaXguZjtcbiAgICByZXR1cm4gX3NldE1hdHJpeCh0aGlzLCBhMiAqIGEgKyBjMiAqIGMsIGEyICogYiArIGMyICogZCwgYjIgKiBhICsgZDIgKiBjLCBiMiAqIGIgKyBkMiAqIGQsIGUgKyBlMiAqIGEgKyBmMiAqIGMsIGYgKyBlMiAqIGIgKyBmMiAqIGQpO1xuICB9O1xuXG4gIF9wcm90by5jbG9uZSA9IGZ1bmN0aW9uIGNsb25lKCkge1xuICAgIHJldHVybiBuZXcgTWF0cml4MkQodGhpcy5hLCB0aGlzLmIsIHRoaXMuYywgdGhpcy5kLCB0aGlzLmUsIHRoaXMuZik7XG4gIH07XG5cbiAgX3Byb3RvLmVxdWFscyA9IGZ1bmN0aW9uIGVxdWFscyhtYXRyaXgpIHtcbiAgICB2YXIgYSA9IHRoaXMuYSxcbiAgICAgICAgYiA9IHRoaXMuYixcbiAgICAgICAgYyA9IHRoaXMuYyxcbiAgICAgICAgZCA9IHRoaXMuZCxcbiAgICAgICAgZSA9IHRoaXMuZSxcbiAgICAgICAgZiA9IHRoaXMuZjtcbiAgICByZXR1cm4gYSA9PT0gbWF0cml4LmEgJiYgYiA9PT0gbWF0cml4LmIgJiYgYyA9PT0gbWF0cml4LmMgJiYgZCA9PT0gbWF0cml4LmQgJiYgZSA9PT0gbWF0cml4LmUgJiYgZiA9PT0gbWF0cml4LmY7XG4gIH07XG5cbiAgX3Byb3RvLmFwcGx5ID0gZnVuY3Rpb24gYXBwbHkocG9pbnQsIGRlY29yYXRlZSkge1xuICAgIGlmIChkZWNvcmF0ZWUgPT09IHZvaWQgMCkge1xuICAgICAgZGVjb3JhdGVlID0ge307XG4gICAgfVxuXG4gICAgdmFyIHggPSBwb2ludC54LFxuICAgICAgICB5ID0gcG9pbnQueSxcbiAgICAgICAgYSA9IHRoaXMuYSxcbiAgICAgICAgYiA9IHRoaXMuYixcbiAgICAgICAgYyA9IHRoaXMuYyxcbiAgICAgICAgZCA9IHRoaXMuZCxcbiAgICAgICAgZSA9IHRoaXMuZSxcbiAgICAgICAgZiA9IHRoaXMuZjtcbiAgICBkZWNvcmF0ZWUueCA9IHggKiBhICsgeSAqIGMgKyBlIHx8IDA7XG4gICAgZGVjb3JhdGVlLnkgPSB4ICogYiArIHkgKiBkICsgZiB8fCAwO1xuICAgIHJldHVybiBkZWNvcmF0ZWU7XG4gIH07XG5cbiAgcmV0dXJuIE1hdHJpeDJEO1xufSgpOyAvLyBGZWVkIGluIGFuIGVsZW1lbnQgYW5kIGl0J2xsIHJldHVybiBhIDJEIG1hdHJpeCAob3B0aW9uYWxseSBpbnZlcnRlZCkgc28gdGhhdCB5b3UgY2FuIHRyYW5zbGF0ZSBiZXR3ZWVuIGNvb3JkaW5hdGUgc3BhY2VzLlxuLy8gSW52ZXJ0aW5nIGxldHMgeW91IHRyYW5zbGF0ZSBhIGdsb2JhbCBwb2ludCBpbnRvIGEgbG9jYWwgY29vcmRpbmF0ZSBzcGFjZS4gTm8gaW52ZXJ0aW5nIGxldHMgeW91IGdvIHRoZSBvdGhlciB3YXkuXG4vLyBXZSBuZWVkZWQgdGhpcyB0byB3b3JrIGFyb3VuZCB2YXJpb3VzIGJyb3dzZXIgYnVncywgbGlrZSBGaXJlZm94IGRvZXNuJ3QgYWNjdXJhdGVseSByZXBvcnQgZ2V0U2NyZWVuQ1RNKCkgd2hlbiB0aGVyZVxuLy8gYXJlIHRyYW5zZm9ybXMgYXBwbGllZCB0byBhbmNlc3RvciBlbGVtZW50cy5cbi8vIFRoZSBtYXRyaXggbWF0aCB0byBjb252ZXJ0IGFueSB4L3kgY29vcmRpbmF0ZSBpcyBhcyBmb2xsb3dzLCB3aGljaCBpcyB3cmFwcGVkIGluIGEgY29udmVuaWVudCBhcHBseSgpIG1ldGhvZCBvZiBNYXRyaXgyRCBhYm92ZTpcbi8vICAgICB0eCA9IG0uYSAqIHggKyBtLmMgKiB5ICsgbS5lXG4vLyAgICAgdHkgPSBtLmIgKiB4ICsgbS5kICogeSArIG0uZlxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0R2xvYmFsTWF0cml4KGVsZW1lbnQsIGludmVyc2UsIGFkanVzdEdPZmZzZXQsIGluY2x1ZGVTY3JvbGxJbkZpeGVkKSB7XG4gIC8vIGFkanVzdEdPZmZzZXQgaXMgdHlwaWNhbGx5IHVzZWQgb25seSB3aGVuIGdyYWJiaW5nIGFuIGVsZW1lbnQncyBQQVJFTlQncyBnbG9iYWwgbWF0cml4LCBhbmQgaXQgaWdub3JlcyB0aGUgeC95IG9mZnNldCBvZiBhbnkgU1ZHIDxnPiBlbGVtZW50cyBiZWNhdXNlIHRoZXkgYmVoYXZlIGluIGEgc3BlY2lhbCB3YXkuXG4gIGlmICghZWxlbWVudCB8fCAhZWxlbWVudC5wYXJlbnROb2RlIHx8IChfZG9jIHx8IF9zZXREb2MoZWxlbWVudCkpLmRvY3VtZW50RWxlbWVudCA9PT0gZWxlbWVudCkge1xuICAgIHJldHVybiBuZXcgTWF0cml4MkQoKTtcbiAgfVxuXG4gIHZhciB6ZXJvU2NhbGVzID0gX2ZvcmNlTm9uWmVyb1NjYWxlKGVsZW1lbnQpLFxuICAgICAgc3ZnID0gX3N2Z093bmVyKGVsZW1lbnQpLFxuICAgICAgdGVtcHMgPSBzdmcgPyBfc3ZnVGVtcHMgOiBfZGl2VGVtcHMsXG4gICAgICBjb250YWluZXIgPSBfcGxhY2VTaWJsaW5ncyhlbGVtZW50LCBhZGp1c3RHT2Zmc2V0KSxcbiAgICAgIGIxID0gdGVtcHNbMF0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksXG4gICAgICBiMiA9IHRlbXBzWzFdLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLFxuICAgICAgYjMgPSB0ZW1wc1syXS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSxcbiAgICAgIHBhcmVudCA9IGNvbnRhaW5lci5wYXJlbnROb2RlLFxuICAgICAgaXNGaXhlZCA9ICFpbmNsdWRlU2Nyb2xsSW5GaXhlZCAmJiBfaXNGaXhlZChlbGVtZW50KSxcbiAgICAgIG0gPSBuZXcgTWF0cml4MkQoKGIyLmxlZnQgLSBiMS5sZWZ0KSAvIDEwMCwgKGIyLnRvcCAtIGIxLnRvcCkgLyAxMDAsIChiMy5sZWZ0IC0gYjEubGVmdCkgLyAxMDAsIChiMy50b3AgLSBiMS50b3ApIC8gMTAwLCBiMS5sZWZ0ICsgKGlzRml4ZWQgPyAwIDogX2dldERvY1Njcm9sbExlZnQoKSksIGIxLnRvcCArIChpc0ZpeGVkID8gMCA6IF9nZXREb2NTY3JvbGxUb3AoKSkpO1xuXG4gIHBhcmVudC5yZW1vdmVDaGlsZChjb250YWluZXIpO1xuXG4gIGlmICh6ZXJvU2NhbGVzKSB7XG4gICAgYjEgPSB6ZXJvU2NhbGVzLmxlbmd0aDtcblxuICAgIHdoaWxlIChiMS0tKSB7XG4gICAgICBiMiA9IHplcm9TY2FsZXNbYjFdO1xuICAgICAgYjIuc2NhbGVYID0gYjIuc2NhbGVZID0gMDtcbiAgICAgIGIyLnJlbmRlclRyYW5zZm9ybSgxLCBiMik7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGludmVyc2UgPyBtLmludmVyc2UoKSA6IG07XG59XG5leHBvcnQgeyBfZ2V0RG9jU2Nyb2xsVG9wLCBfZ2V0RG9jU2Nyb2xsTGVmdCwgX3NldERvYywgX2lzRml4ZWQsIF9nZXRDVE0gfTsgLy8gZXhwb3J0IGZ1bmN0aW9uIGdldE1hdHJpeChlbGVtZW50KSB7XG4vLyBcdF9kb2MgfHwgX3NldERvYyhlbGVtZW50KTtcbi8vIFx0bGV0IG0gPSAoX3dpbi5nZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpW190cmFuc2Zvcm1Qcm9wXSArIFwiXCIpLnN1YnN0cig3KS5tYXRjaCgvWy0uXSpcXGQrWy5lXFwtK10qXFxkKltlXFwtXFwrXSpcXGQqL2cpLFxuLy8gXHRcdGlzMkQgPSBtICYmIG0ubGVuZ3RoID09PSA2O1xuLy8gXHRyZXR1cm4gIW0gfHwgbS5sZW5ndGggPCA2ID8gbmV3IE1hdHJpeDJEKCkgOiBuZXcgTWF0cml4MkQoK21bMF0sICttWzFdLCArbVtpczJEID8gMiA6IDRdLCArbVtpczJEID8gMyA6IDVdLCArbVtpczJEID8gNCA6IDEyXSwgK21baXMyRCA/IDUgOiAxM10pO1xuLy8gfSIsIi8qIVxuICogalF1ZXJ5IEphdmFTY3JpcHQgTGlicmFyeSB2My42LjBcbiAqIGh0dHBzOi8vanF1ZXJ5LmNvbS9cbiAqXG4gKiBJbmNsdWRlcyBTaXp6bGUuanNcbiAqIGh0dHBzOi8vc2l6emxlanMuY29tL1xuICpcbiAqIENvcHlyaWdodCBPcGVuSlMgRm91bmRhdGlvbiBhbmQgb3RoZXIgY29udHJpYnV0b3JzXG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcbiAqIGh0dHBzOi8vanF1ZXJ5Lm9yZy9saWNlbnNlXG4gKlxuICogRGF0ZTogMjAyMS0wMy0wMlQxNzowOFpcbiAqL1xuKCBmdW5jdGlvbiggZ2xvYmFsLCBmYWN0b3J5ICkge1xuXG5cdFwidXNlIHN0cmljdFwiO1xuXG5cdGlmICggdHlwZW9mIG1vZHVsZSA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgbW9kdWxlLmV4cG9ydHMgPT09IFwib2JqZWN0XCIgKSB7XG5cblx0XHQvLyBGb3IgQ29tbW9uSlMgYW5kIENvbW1vbkpTLWxpa2UgZW52aXJvbm1lbnRzIHdoZXJlIGEgcHJvcGVyIGB3aW5kb3dgXG5cdFx0Ly8gaXMgcHJlc2VudCwgZXhlY3V0ZSB0aGUgZmFjdG9yeSBhbmQgZ2V0IGpRdWVyeS5cblx0XHQvLyBGb3IgZW52aXJvbm1lbnRzIHRoYXQgZG8gbm90IGhhdmUgYSBgd2luZG93YCB3aXRoIGEgYGRvY3VtZW50YFxuXHRcdC8vIChzdWNoIGFzIE5vZGUuanMpLCBleHBvc2UgYSBmYWN0b3J5IGFzIG1vZHVsZS5leHBvcnRzLlxuXHRcdC8vIFRoaXMgYWNjZW50dWF0ZXMgdGhlIG5lZWQgZm9yIHRoZSBjcmVhdGlvbiBvZiBhIHJlYWwgYHdpbmRvd2AuXG5cdFx0Ly8gZS5nLiB2YXIgalF1ZXJ5ID0gcmVxdWlyZShcImpxdWVyeVwiKSh3aW5kb3cpO1xuXHRcdC8vIFNlZSB0aWNrZXQgIzE0NTQ5IGZvciBtb3JlIGluZm8uXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBnbG9iYWwuZG9jdW1lbnQgP1xuXHRcdFx0ZmFjdG9yeSggZ2xvYmFsLCB0cnVlICkgOlxuXHRcdFx0ZnVuY3Rpb24oIHcgKSB7XG5cdFx0XHRcdGlmICggIXcuZG9jdW1lbnQgKSB7XG5cdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCBcImpRdWVyeSByZXF1aXJlcyBhIHdpbmRvdyB3aXRoIGEgZG9jdW1lbnRcIiApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBmYWN0b3J5KCB3ICk7XG5cdFx0XHR9O1xuXHR9IGVsc2Uge1xuXHRcdGZhY3RvcnkoIGdsb2JhbCApO1xuXHR9XG5cbi8vIFBhc3MgdGhpcyBpZiB3aW5kb3cgaXMgbm90IGRlZmluZWQgeWV0XG59ICkoIHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB0aGlzLCBmdW5jdGlvbiggd2luZG93LCBub0dsb2JhbCApIHtcblxuLy8gRWRnZSA8PSAxMiAtIDEzKywgRmlyZWZveCA8PTE4IC0gNDUrLCBJRSAxMCAtIDExLCBTYWZhcmkgNS4xIC0gOSssIGlPUyA2IC0gOS4xXG4vLyB0aHJvdyBleGNlcHRpb25zIHdoZW4gbm9uLXN0cmljdCBjb2RlIChlLmcuLCBBU1AuTkVUIDQuNSkgYWNjZXNzZXMgc3RyaWN0IG1vZGVcbi8vIGFyZ3VtZW50cy5jYWxsZWUuY2FsbGVyICh0cmFjLTEzMzM1KS4gQnV0IGFzIG9mIGpRdWVyeSAzLjAgKDIwMTYpLCBzdHJpY3QgbW9kZSBzaG91bGQgYmUgY29tbW9uXG4vLyBlbm91Z2ggdGhhdCBhbGwgc3VjaCBhdHRlbXB0cyBhcmUgZ3VhcmRlZCBpbiBhIHRyeSBibG9jay5cblwidXNlIHN0cmljdFwiO1xuXG52YXIgYXJyID0gW107XG5cbnZhciBnZXRQcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZjtcblxudmFyIHNsaWNlID0gYXJyLnNsaWNlO1xuXG52YXIgZmxhdCA9IGFyci5mbGF0ID8gZnVuY3Rpb24oIGFycmF5ICkge1xuXHRyZXR1cm4gYXJyLmZsYXQuY2FsbCggYXJyYXkgKTtcbn0gOiBmdW5jdGlvbiggYXJyYXkgKSB7XG5cdHJldHVybiBhcnIuY29uY2F0LmFwcGx5KCBbXSwgYXJyYXkgKTtcbn07XG5cblxudmFyIHB1c2ggPSBhcnIucHVzaDtcblxudmFyIGluZGV4T2YgPSBhcnIuaW5kZXhPZjtcblxudmFyIGNsYXNzMnR5cGUgPSB7fTtcblxudmFyIHRvU3RyaW5nID0gY2xhc3MydHlwZS50b1N0cmluZztcblxudmFyIGhhc093biA9IGNsYXNzMnR5cGUuaGFzT3duUHJvcGVydHk7XG5cbnZhciBmblRvU3RyaW5nID0gaGFzT3duLnRvU3RyaW5nO1xuXG52YXIgT2JqZWN0RnVuY3Rpb25TdHJpbmcgPSBmblRvU3RyaW5nLmNhbGwoIE9iamVjdCApO1xuXG52YXIgc3VwcG9ydCA9IHt9O1xuXG52YXIgaXNGdW5jdGlvbiA9IGZ1bmN0aW9uIGlzRnVuY3Rpb24oIG9iaiApIHtcblxuXHRcdC8vIFN1cHBvcnQ6IENocm9tZSA8PTU3LCBGaXJlZm94IDw9NTJcblx0XHQvLyBJbiBzb21lIGJyb3dzZXJzLCB0eXBlb2YgcmV0dXJucyBcImZ1bmN0aW9uXCIgZm9yIEhUTUwgPG9iamVjdD4gZWxlbWVudHNcblx0XHQvLyAoaS5lLiwgYHR5cGVvZiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcIm9iamVjdFwiICkgPT09IFwiZnVuY3Rpb25cImApLlxuXHRcdC8vIFdlIGRvbid0IHdhbnQgdG8gY2xhc3NpZnkgKmFueSogRE9NIG5vZGUgYXMgYSBmdW5jdGlvbi5cblx0XHQvLyBTdXBwb3J0OiBRdFdlYiA8PTMuOC41LCBXZWJLaXQgPD01MzQuMzQsIHdraHRtbHRvcGRmIHRvb2wgPD0wLjEyLjVcblx0XHQvLyBQbHVzIGZvciBvbGQgV2ViS2l0LCB0eXBlb2YgcmV0dXJucyBcImZ1bmN0aW9uXCIgZm9yIEhUTUwgY29sbGVjdGlvbnNcblx0XHQvLyAoZS5nLiwgYHR5cGVvZiBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZShcImRpdlwiKSA9PT0gXCJmdW5jdGlvblwiYCkuIChnaC00NzU2KVxuXHRcdHJldHVybiB0eXBlb2Ygb2JqID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIG9iai5ub2RlVHlwZSAhPT0gXCJudW1iZXJcIiAmJlxuXHRcdFx0dHlwZW9mIG9iai5pdGVtICE9PSBcImZ1bmN0aW9uXCI7XG5cdH07XG5cblxudmFyIGlzV2luZG93ID0gZnVuY3Rpb24gaXNXaW5kb3coIG9iaiApIHtcblx0XHRyZXR1cm4gb2JqICE9IG51bGwgJiYgb2JqID09PSBvYmoud2luZG93O1xuXHR9O1xuXG5cbnZhciBkb2N1bWVudCA9IHdpbmRvdy5kb2N1bWVudDtcblxuXG5cblx0dmFyIHByZXNlcnZlZFNjcmlwdEF0dHJpYnV0ZXMgPSB7XG5cdFx0dHlwZTogdHJ1ZSxcblx0XHRzcmM6IHRydWUsXG5cdFx0bm9uY2U6IHRydWUsXG5cdFx0bm9Nb2R1bGU6IHRydWVcblx0fTtcblxuXHRmdW5jdGlvbiBET01FdmFsKCBjb2RlLCBub2RlLCBkb2MgKSB7XG5cdFx0ZG9jID0gZG9jIHx8IGRvY3VtZW50O1xuXG5cdFx0dmFyIGksIHZhbCxcblx0XHRcdHNjcmlwdCA9IGRvYy5jcmVhdGVFbGVtZW50KCBcInNjcmlwdFwiICk7XG5cblx0XHRzY3JpcHQudGV4dCA9IGNvZGU7XG5cdFx0aWYgKCBub2RlICkge1xuXHRcdFx0Zm9yICggaSBpbiBwcmVzZXJ2ZWRTY3JpcHRBdHRyaWJ1dGVzICkge1xuXG5cdFx0XHRcdC8vIFN1cHBvcnQ6IEZpcmVmb3ggNjQrLCBFZGdlIDE4K1xuXHRcdFx0XHQvLyBTb21lIGJyb3dzZXJzIGRvbid0IHN1cHBvcnQgdGhlIFwibm9uY2VcIiBwcm9wZXJ0eSBvbiBzY3JpcHRzLlxuXHRcdFx0XHQvLyBPbiB0aGUgb3RoZXIgaGFuZCwganVzdCB1c2luZyBgZ2V0QXR0cmlidXRlYCBpcyBub3QgZW5vdWdoIGFzXG5cdFx0XHRcdC8vIHRoZSBgbm9uY2VgIGF0dHJpYnV0ZSBpcyByZXNldCB0byBhbiBlbXB0eSBzdHJpbmcgd2hlbmV2ZXIgaXRcblx0XHRcdFx0Ly8gYmVjb21lcyBicm93c2luZy1jb250ZXh0IGNvbm5lY3RlZC5cblx0XHRcdFx0Ly8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS93aGF0d2cvaHRtbC9pc3N1ZXMvMjM2OVxuXHRcdFx0XHQvLyBTZWUgaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy8jbm9uY2UtYXR0cmlidXRlc1xuXHRcdFx0XHQvLyBUaGUgYG5vZGUuZ2V0QXR0cmlidXRlYCBjaGVjayB3YXMgYWRkZWQgZm9yIHRoZSBzYWtlIG9mXG5cdFx0XHRcdC8vIGBqUXVlcnkuZ2xvYmFsRXZhbGAgc28gdGhhdCBpdCBjYW4gZmFrZSBhIG5vbmNlLWNvbnRhaW5pbmcgbm9kZVxuXHRcdFx0XHQvLyB2aWEgYW4gb2JqZWN0LlxuXHRcdFx0XHR2YWwgPSBub2RlWyBpIF0gfHwgbm9kZS5nZXRBdHRyaWJ1dGUgJiYgbm9kZS5nZXRBdHRyaWJ1dGUoIGkgKTtcblx0XHRcdFx0aWYgKCB2YWwgKSB7XG5cdFx0XHRcdFx0c2NyaXB0LnNldEF0dHJpYnV0ZSggaSwgdmFsICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdFx0ZG9jLmhlYWQuYXBwZW5kQ2hpbGQoIHNjcmlwdCApLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoIHNjcmlwdCApO1xuXHR9XG5cblxuZnVuY3Rpb24gdG9UeXBlKCBvYmogKSB7XG5cdGlmICggb2JqID09IG51bGwgKSB7XG5cdFx0cmV0dXJuIG9iaiArIFwiXCI7XG5cdH1cblxuXHQvLyBTdXBwb3J0OiBBbmRyb2lkIDw9Mi4zIG9ubHkgKGZ1bmN0aW9uaXNoIFJlZ0V4cClcblx0cmV0dXJuIHR5cGVvZiBvYmogPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIG9iaiA9PT0gXCJmdW5jdGlvblwiID9cblx0XHRjbGFzczJ0eXBlWyB0b1N0cmluZy5jYWxsKCBvYmogKSBdIHx8IFwib2JqZWN0XCIgOlxuXHRcdHR5cGVvZiBvYmo7XG59XG4vKiBnbG9iYWwgU3ltYm9sICovXG4vLyBEZWZpbmluZyB0aGlzIGdsb2JhbCBpbiAuZXNsaW50cmMuanNvbiB3b3VsZCBjcmVhdGUgYSBkYW5nZXIgb2YgdXNpbmcgdGhlIGdsb2JhbFxuLy8gdW5ndWFyZGVkIGluIGFub3RoZXIgcGxhY2UsIGl0IHNlZW1zIHNhZmVyIHRvIGRlZmluZSBnbG9iYWwgb25seSBmb3IgdGhpcyBtb2R1bGVcblxuXG5cbnZhclxuXHR2ZXJzaW9uID0gXCIzLjYuMFwiLFxuXG5cdC8vIERlZmluZSBhIGxvY2FsIGNvcHkgb2YgalF1ZXJ5XG5cdGpRdWVyeSA9IGZ1bmN0aW9uKCBzZWxlY3RvciwgY29udGV4dCApIHtcblxuXHRcdC8vIFRoZSBqUXVlcnkgb2JqZWN0IGlzIGFjdHVhbGx5IGp1c3QgdGhlIGluaXQgY29uc3RydWN0b3IgJ2VuaGFuY2VkJ1xuXHRcdC8vIE5lZWQgaW5pdCBpZiBqUXVlcnkgaXMgY2FsbGVkIChqdXN0IGFsbG93IGVycm9yIHRvIGJlIHRocm93biBpZiBub3QgaW5jbHVkZWQpXG5cdFx0cmV0dXJuIG5ldyBqUXVlcnkuZm4uaW5pdCggc2VsZWN0b3IsIGNvbnRleHQgKTtcblx0fTtcblxualF1ZXJ5LmZuID0galF1ZXJ5LnByb3RvdHlwZSA9IHtcblxuXHQvLyBUaGUgY3VycmVudCB2ZXJzaW9uIG9mIGpRdWVyeSBiZWluZyB1c2VkXG5cdGpxdWVyeTogdmVyc2lvbixcblxuXHRjb25zdHJ1Y3RvcjogalF1ZXJ5LFxuXG5cdC8vIFRoZSBkZWZhdWx0IGxlbmd0aCBvZiBhIGpRdWVyeSBvYmplY3QgaXMgMFxuXHRsZW5ndGg6IDAsXG5cblx0dG9BcnJheTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHNsaWNlLmNhbGwoIHRoaXMgKTtcblx0fSxcblxuXHQvLyBHZXQgdGhlIE50aCBlbGVtZW50IGluIHRoZSBtYXRjaGVkIGVsZW1lbnQgc2V0IE9SXG5cdC8vIEdldCB0aGUgd2hvbGUgbWF0Y2hlZCBlbGVtZW50IHNldCBhcyBhIGNsZWFuIGFycmF5XG5cdGdldDogZnVuY3Rpb24oIG51bSApIHtcblxuXHRcdC8vIFJldHVybiBhbGwgdGhlIGVsZW1lbnRzIGluIGEgY2xlYW4gYXJyYXlcblx0XHRpZiAoIG51bSA9PSBudWxsICkge1xuXHRcdFx0cmV0dXJuIHNsaWNlLmNhbGwoIHRoaXMgKTtcblx0XHR9XG5cblx0XHQvLyBSZXR1cm4ganVzdCB0aGUgb25lIGVsZW1lbnQgZnJvbSB0aGUgc2V0XG5cdFx0cmV0dXJuIG51bSA8IDAgPyB0aGlzWyBudW0gKyB0aGlzLmxlbmd0aCBdIDogdGhpc1sgbnVtIF07XG5cdH0sXG5cblx0Ly8gVGFrZSBhbiBhcnJheSBvZiBlbGVtZW50cyBhbmQgcHVzaCBpdCBvbnRvIHRoZSBzdGFja1xuXHQvLyAocmV0dXJuaW5nIHRoZSBuZXcgbWF0Y2hlZCBlbGVtZW50IHNldClcblx0cHVzaFN0YWNrOiBmdW5jdGlvbiggZWxlbXMgKSB7XG5cblx0XHQvLyBCdWlsZCBhIG5ldyBqUXVlcnkgbWF0Y2hlZCBlbGVtZW50IHNldFxuXHRcdHZhciByZXQgPSBqUXVlcnkubWVyZ2UoIHRoaXMuY29uc3RydWN0b3IoKSwgZWxlbXMgKTtcblxuXHRcdC8vIEFkZCB0aGUgb2xkIG9iamVjdCBvbnRvIHRoZSBzdGFjayAoYXMgYSByZWZlcmVuY2UpXG5cdFx0cmV0LnByZXZPYmplY3QgPSB0aGlzO1xuXG5cdFx0Ly8gUmV0dXJuIHRoZSBuZXdseS1mb3JtZWQgZWxlbWVudCBzZXRcblx0XHRyZXR1cm4gcmV0O1xuXHR9LFxuXG5cdC8vIEV4ZWN1dGUgYSBjYWxsYmFjayBmb3IgZXZlcnkgZWxlbWVudCBpbiB0aGUgbWF0Y2hlZCBzZXQuXG5cdGVhY2g6IGZ1bmN0aW9uKCBjYWxsYmFjayApIHtcblx0XHRyZXR1cm4galF1ZXJ5LmVhY2goIHRoaXMsIGNhbGxiYWNrICk7XG5cdH0sXG5cblx0bWFwOiBmdW5jdGlvbiggY2FsbGJhY2sgKSB7XG5cdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKCBqUXVlcnkubWFwKCB0aGlzLCBmdW5jdGlvbiggZWxlbSwgaSApIHtcblx0XHRcdHJldHVybiBjYWxsYmFjay5jYWxsKCBlbGVtLCBpLCBlbGVtICk7XG5cdFx0fSApICk7XG5cdH0sXG5cblx0c2xpY2U6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLnB1c2hTdGFjayggc2xpY2UuYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApICk7XG5cdH0sXG5cblx0Zmlyc3Q6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLmVxKCAwICk7XG5cdH0sXG5cblx0bGFzdDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuZXEoIC0xICk7XG5cdH0sXG5cblx0ZXZlbjogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKCBqUXVlcnkuZ3JlcCggdGhpcywgZnVuY3Rpb24oIF9lbGVtLCBpICkge1xuXHRcdFx0cmV0dXJuICggaSArIDEgKSAlIDI7XG5cdFx0fSApICk7XG5cdH0sXG5cblx0b2RkOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5wdXNoU3RhY2soIGpRdWVyeS5ncmVwKCB0aGlzLCBmdW5jdGlvbiggX2VsZW0sIGkgKSB7XG5cdFx0XHRyZXR1cm4gaSAlIDI7XG5cdFx0fSApICk7XG5cdH0sXG5cblx0ZXE6IGZ1bmN0aW9uKCBpICkge1xuXHRcdHZhciBsZW4gPSB0aGlzLmxlbmd0aCxcblx0XHRcdGogPSAraSArICggaSA8IDAgPyBsZW4gOiAwICk7XG5cdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKCBqID49IDAgJiYgaiA8IGxlbiA/IFsgdGhpc1sgaiBdIF0gOiBbXSApO1xuXHR9LFxuXG5cdGVuZDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMucHJldk9iamVjdCB8fCB0aGlzLmNvbnN0cnVjdG9yKCk7XG5cdH0sXG5cblx0Ly8gRm9yIGludGVybmFsIHVzZSBvbmx5LlxuXHQvLyBCZWhhdmVzIGxpa2UgYW4gQXJyYXkncyBtZXRob2QsIG5vdCBsaWtlIGEgalF1ZXJ5IG1ldGhvZC5cblx0cHVzaDogcHVzaCxcblx0c29ydDogYXJyLnNvcnQsXG5cdHNwbGljZTogYXJyLnNwbGljZVxufTtcblxualF1ZXJ5LmV4dGVuZCA9IGpRdWVyeS5mbi5leHRlbmQgPSBmdW5jdGlvbigpIHtcblx0dmFyIG9wdGlvbnMsIG5hbWUsIHNyYywgY29weSwgY29weUlzQXJyYXksIGNsb25lLFxuXHRcdHRhcmdldCA9IGFyZ3VtZW50c1sgMCBdIHx8IHt9LFxuXHRcdGkgPSAxLFxuXHRcdGxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGgsXG5cdFx0ZGVlcCA9IGZhbHNlO1xuXG5cdC8vIEhhbmRsZSBhIGRlZXAgY29weSBzaXR1YXRpb25cblx0aWYgKCB0eXBlb2YgdGFyZ2V0ID09PSBcImJvb2xlYW5cIiApIHtcblx0XHRkZWVwID0gdGFyZ2V0O1xuXG5cdFx0Ly8gU2tpcCB0aGUgYm9vbGVhbiBhbmQgdGhlIHRhcmdldFxuXHRcdHRhcmdldCA9IGFyZ3VtZW50c1sgaSBdIHx8IHt9O1xuXHRcdGkrKztcblx0fVxuXG5cdC8vIEhhbmRsZSBjYXNlIHdoZW4gdGFyZ2V0IGlzIGEgc3RyaW5nIG9yIHNvbWV0aGluZyAocG9zc2libGUgaW4gZGVlcCBjb3B5KVxuXHRpZiAoIHR5cGVvZiB0YXJnZXQgIT09IFwib2JqZWN0XCIgJiYgIWlzRnVuY3Rpb24oIHRhcmdldCApICkge1xuXHRcdHRhcmdldCA9IHt9O1xuXHR9XG5cblx0Ly8gRXh0ZW5kIGpRdWVyeSBpdHNlbGYgaWYgb25seSBvbmUgYXJndW1lbnQgaXMgcGFzc2VkXG5cdGlmICggaSA9PT0gbGVuZ3RoICkge1xuXHRcdHRhcmdldCA9IHRoaXM7XG5cdFx0aS0tO1xuXHR9XG5cblx0Zm9yICggOyBpIDwgbGVuZ3RoOyBpKysgKSB7XG5cblx0XHQvLyBPbmx5IGRlYWwgd2l0aCBub24tbnVsbC91bmRlZmluZWQgdmFsdWVzXG5cdFx0aWYgKCAoIG9wdGlvbnMgPSBhcmd1bWVudHNbIGkgXSApICE9IG51bGwgKSB7XG5cblx0XHRcdC8vIEV4dGVuZCB0aGUgYmFzZSBvYmplY3Rcblx0XHRcdGZvciAoIG5hbWUgaW4gb3B0aW9ucyApIHtcblx0XHRcdFx0Y29weSA9IG9wdGlvbnNbIG5hbWUgXTtcblxuXHRcdFx0XHQvLyBQcmV2ZW50IE9iamVjdC5wcm90b3R5cGUgcG9sbHV0aW9uXG5cdFx0XHRcdC8vIFByZXZlbnQgbmV2ZXItZW5kaW5nIGxvb3Bcblx0XHRcdFx0aWYgKCBuYW1lID09PSBcIl9fcHJvdG9fX1wiIHx8IHRhcmdldCA9PT0gY29weSApIHtcblx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFJlY3Vyc2UgaWYgd2UncmUgbWVyZ2luZyBwbGFpbiBvYmplY3RzIG9yIGFycmF5c1xuXHRcdFx0XHRpZiAoIGRlZXAgJiYgY29weSAmJiAoIGpRdWVyeS5pc1BsYWluT2JqZWN0KCBjb3B5ICkgfHxcblx0XHRcdFx0XHQoIGNvcHlJc0FycmF5ID0gQXJyYXkuaXNBcnJheSggY29weSApICkgKSApIHtcblx0XHRcdFx0XHRzcmMgPSB0YXJnZXRbIG5hbWUgXTtcblxuXHRcdFx0XHRcdC8vIEVuc3VyZSBwcm9wZXIgdHlwZSBmb3IgdGhlIHNvdXJjZSB2YWx1ZVxuXHRcdFx0XHRcdGlmICggY29weUlzQXJyYXkgJiYgIUFycmF5LmlzQXJyYXkoIHNyYyApICkge1xuXHRcdFx0XHRcdFx0Y2xvbmUgPSBbXTtcblx0XHRcdFx0XHR9IGVsc2UgaWYgKCAhY29weUlzQXJyYXkgJiYgIWpRdWVyeS5pc1BsYWluT2JqZWN0KCBzcmMgKSApIHtcblx0XHRcdFx0XHRcdGNsb25lID0ge307XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdGNsb25lID0gc3JjO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRjb3B5SXNBcnJheSA9IGZhbHNlO1xuXG5cdFx0XHRcdFx0Ly8gTmV2ZXIgbW92ZSBvcmlnaW5hbCBvYmplY3RzLCBjbG9uZSB0aGVtXG5cdFx0XHRcdFx0dGFyZ2V0WyBuYW1lIF0gPSBqUXVlcnkuZXh0ZW5kKCBkZWVwLCBjbG9uZSwgY29weSApO1xuXG5cdFx0XHRcdC8vIERvbid0IGJyaW5nIGluIHVuZGVmaW5lZCB2YWx1ZXNcblx0XHRcdFx0fSBlbHNlIGlmICggY29weSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdHRhcmdldFsgbmFtZSBdID0gY29weTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8vIFJldHVybiB0aGUgbW9kaWZpZWQgb2JqZWN0XG5cdHJldHVybiB0YXJnZXQ7XG59O1xuXG5qUXVlcnkuZXh0ZW5kKCB7XG5cblx0Ly8gVW5pcXVlIGZvciBlYWNoIGNvcHkgb2YgalF1ZXJ5IG9uIHRoZSBwYWdlXG5cdGV4cGFuZG86IFwialF1ZXJ5XCIgKyAoIHZlcnNpb24gKyBNYXRoLnJhbmRvbSgpICkucmVwbGFjZSggL1xcRC9nLCBcIlwiICksXG5cblx0Ly8gQXNzdW1lIGpRdWVyeSBpcyByZWFkeSB3aXRob3V0IHRoZSByZWFkeSBtb2R1bGVcblx0aXNSZWFkeTogdHJ1ZSxcblxuXHRlcnJvcjogZnVuY3Rpb24oIG1zZyApIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoIG1zZyApO1xuXHR9LFxuXG5cdG5vb3A6IGZ1bmN0aW9uKCkge30sXG5cblx0aXNQbGFpbk9iamVjdDogZnVuY3Rpb24oIG9iaiApIHtcblx0XHR2YXIgcHJvdG8sIEN0b3I7XG5cblx0XHQvLyBEZXRlY3Qgb2J2aW91cyBuZWdhdGl2ZXNcblx0XHQvLyBVc2UgdG9TdHJpbmcgaW5zdGVhZCBvZiBqUXVlcnkudHlwZSB0byBjYXRjaCBob3N0IG9iamVjdHNcblx0XHRpZiAoICFvYmogfHwgdG9TdHJpbmcuY2FsbCggb2JqICkgIT09IFwiW29iamVjdCBPYmplY3RdXCIgKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0cHJvdG8gPSBnZXRQcm90byggb2JqICk7XG5cblx0XHQvLyBPYmplY3RzIHdpdGggbm8gcHJvdG90eXBlIChlLmcuLCBgT2JqZWN0LmNyZWF0ZSggbnVsbCApYCkgYXJlIHBsYWluXG5cdFx0aWYgKCAhcHJvdG8gKSB7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cblx0XHQvLyBPYmplY3RzIHdpdGggcHJvdG90eXBlIGFyZSBwbGFpbiBpZmYgdGhleSB3ZXJlIGNvbnN0cnVjdGVkIGJ5IGEgZ2xvYmFsIE9iamVjdCBmdW5jdGlvblxuXHRcdEN0b3IgPSBoYXNPd24uY2FsbCggcHJvdG8sIFwiY29uc3RydWN0b3JcIiApICYmIHByb3RvLmNvbnN0cnVjdG9yO1xuXHRcdHJldHVybiB0eXBlb2YgQ3RvciA9PT0gXCJmdW5jdGlvblwiICYmIGZuVG9TdHJpbmcuY2FsbCggQ3RvciApID09PSBPYmplY3RGdW5jdGlvblN0cmluZztcblx0fSxcblxuXHRpc0VtcHR5T2JqZWN0OiBmdW5jdGlvbiggb2JqICkge1xuXHRcdHZhciBuYW1lO1xuXG5cdFx0Zm9yICggbmFtZSBpbiBvYmogKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXHRcdHJldHVybiB0cnVlO1xuXHR9LFxuXG5cdC8vIEV2YWx1YXRlcyBhIHNjcmlwdCBpbiBhIHByb3ZpZGVkIGNvbnRleHQ7IGZhbGxzIGJhY2sgdG8gdGhlIGdsb2JhbCBvbmVcblx0Ly8gaWYgbm90IHNwZWNpZmllZC5cblx0Z2xvYmFsRXZhbDogZnVuY3Rpb24oIGNvZGUsIG9wdGlvbnMsIGRvYyApIHtcblx0XHRET01FdmFsKCBjb2RlLCB7IG5vbmNlOiBvcHRpb25zICYmIG9wdGlvbnMubm9uY2UgfSwgZG9jICk7XG5cdH0sXG5cblx0ZWFjaDogZnVuY3Rpb24oIG9iaiwgY2FsbGJhY2sgKSB7XG5cdFx0dmFyIGxlbmd0aCwgaSA9IDA7XG5cblx0XHRpZiAoIGlzQXJyYXlMaWtlKCBvYmogKSApIHtcblx0XHRcdGxlbmd0aCA9IG9iai5sZW5ndGg7XG5cdFx0XHRmb3IgKCA7IGkgPCBsZW5ndGg7IGkrKyApIHtcblx0XHRcdFx0aWYgKCBjYWxsYmFjay5jYWxsKCBvYmpbIGkgXSwgaSwgb2JqWyBpIF0gKSA9PT0gZmFsc2UgKSB7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0Zm9yICggaSBpbiBvYmogKSB7XG5cdFx0XHRcdGlmICggY2FsbGJhY2suY2FsbCggb2JqWyBpIF0sIGksIG9ialsgaSBdICkgPT09IGZhbHNlICkge1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIG9iajtcblx0fSxcblxuXHQvLyByZXN1bHRzIGlzIGZvciBpbnRlcm5hbCB1c2FnZSBvbmx5XG5cdG1ha2VBcnJheTogZnVuY3Rpb24oIGFyciwgcmVzdWx0cyApIHtcblx0XHR2YXIgcmV0ID0gcmVzdWx0cyB8fCBbXTtcblxuXHRcdGlmICggYXJyICE9IG51bGwgKSB7XG5cdFx0XHRpZiAoIGlzQXJyYXlMaWtlKCBPYmplY3QoIGFyciApICkgKSB7XG5cdFx0XHRcdGpRdWVyeS5tZXJnZSggcmV0LFxuXHRcdFx0XHRcdHR5cGVvZiBhcnIgPT09IFwic3RyaW5nXCIgP1xuXHRcdFx0XHRcdFx0WyBhcnIgXSA6IGFyclxuXHRcdFx0XHQpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cHVzaC5jYWxsKCByZXQsIGFyciApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiByZXQ7XG5cdH0sXG5cblx0aW5BcnJheTogZnVuY3Rpb24oIGVsZW0sIGFyciwgaSApIHtcblx0XHRyZXR1cm4gYXJyID09IG51bGwgPyAtMSA6IGluZGV4T2YuY2FsbCggYXJyLCBlbGVtLCBpICk7XG5cdH0sXG5cblx0Ly8gU3VwcG9ydDogQW5kcm9pZCA8PTQuMCBvbmx5LCBQaGFudG9tSlMgMSBvbmx5XG5cdC8vIHB1c2guYXBwbHkoXywgYXJyYXlsaWtlKSB0aHJvd3Mgb24gYW5jaWVudCBXZWJLaXRcblx0bWVyZ2U6IGZ1bmN0aW9uKCBmaXJzdCwgc2Vjb25kICkge1xuXHRcdHZhciBsZW4gPSArc2Vjb25kLmxlbmd0aCxcblx0XHRcdGogPSAwLFxuXHRcdFx0aSA9IGZpcnN0Lmxlbmd0aDtcblxuXHRcdGZvciAoIDsgaiA8IGxlbjsgaisrICkge1xuXHRcdFx0Zmlyc3RbIGkrKyBdID0gc2Vjb25kWyBqIF07XG5cdFx0fVxuXG5cdFx0Zmlyc3QubGVuZ3RoID0gaTtcblxuXHRcdHJldHVybiBmaXJzdDtcblx0fSxcblxuXHRncmVwOiBmdW5jdGlvbiggZWxlbXMsIGNhbGxiYWNrLCBpbnZlcnQgKSB7XG5cdFx0dmFyIGNhbGxiYWNrSW52ZXJzZSxcblx0XHRcdG1hdGNoZXMgPSBbXSxcblx0XHRcdGkgPSAwLFxuXHRcdFx0bGVuZ3RoID0gZWxlbXMubGVuZ3RoLFxuXHRcdFx0Y2FsbGJhY2tFeHBlY3QgPSAhaW52ZXJ0O1xuXG5cdFx0Ly8gR28gdGhyb3VnaCB0aGUgYXJyYXksIG9ubHkgc2F2aW5nIHRoZSBpdGVtc1xuXHRcdC8vIHRoYXQgcGFzcyB0aGUgdmFsaWRhdG9yIGZ1bmN0aW9uXG5cdFx0Zm9yICggOyBpIDwgbGVuZ3RoOyBpKysgKSB7XG5cdFx0XHRjYWxsYmFja0ludmVyc2UgPSAhY2FsbGJhY2soIGVsZW1zWyBpIF0sIGkgKTtcblx0XHRcdGlmICggY2FsbGJhY2tJbnZlcnNlICE9PSBjYWxsYmFja0V4cGVjdCApIHtcblx0XHRcdFx0bWF0Y2hlcy5wdXNoKCBlbGVtc1sgaSBdICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIG1hdGNoZXM7XG5cdH0sXG5cblx0Ly8gYXJnIGlzIGZvciBpbnRlcm5hbCB1c2FnZSBvbmx5XG5cdG1hcDogZnVuY3Rpb24oIGVsZW1zLCBjYWxsYmFjaywgYXJnICkge1xuXHRcdHZhciBsZW5ndGgsIHZhbHVlLFxuXHRcdFx0aSA9IDAsXG5cdFx0XHRyZXQgPSBbXTtcblxuXHRcdC8vIEdvIHRocm91Z2ggdGhlIGFycmF5LCB0cmFuc2xhdGluZyBlYWNoIG9mIHRoZSBpdGVtcyB0byB0aGVpciBuZXcgdmFsdWVzXG5cdFx0aWYgKCBpc0FycmF5TGlrZSggZWxlbXMgKSApIHtcblx0XHRcdGxlbmd0aCA9IGVsZW1zLmxlbmd0aDtcblx0XHRcdGZvciAoIDsgaSA8IGxlbmd0aDsgaSsrICkge1xuXHRcdFx0XHR2YWx1ZSA9IGNhbGxiYWNrKCBlbGVtc1sgaSBdLCBpLCBhcmcgKTtcblxuXHRcdFx0XHRpZiAoIHZhbHVlICE9IG51bGwgKSB7XG5cdFx0XHRcdFx0cmV0LnB1c2goIHZhbHVlICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdC8vIEdvIHRocm91Z2ggZXZlcnkga2V5IG9uIHRoZSBvYmplY3QsXG5cdFx0fSBlbHNlIHtcblx0XHRcdGZvciAoIGkgaW4gZWxlbXMgKSB7XG5cdFx0XHRcdHZhbHVlID0gY2FsbGJhY2soIGVsZW1zWyBpIF0sIGksIGFyZyApO1xuXG5cdFx0XHRcdGlmICggdmFsdWUgIT0gbnVsbCApIHtcblx0XHRcdFx0XHRyZXQucHVzaCggdmFsdWUgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIEZsYXR0ZW4gYW55IG5lc3RlZCBhcnJheXNcblx0XHRyZXR1cm4gZmxhdCggcmV0ICk7XG5cdH0sXG5cblx0Ly8gQSBnbG9iYWwgR1VJRCBjb3VudGVyIGZvciBvYmplY3RzXG5cdGd1aWQ6IDEsXG5cblx0Ly8galF1ZXJ5LnN1cHBvcnQgaXMgbm90IHVzZWQgaW4gQ29yZSBidXQgb3RoZXIgcHJvamVjdHMgYXR0YWNoIHRoZWlyXG5cdC8vIHByb3BlcnRpZXMgdG8gaXQgc28gaXQgbmVlZHMgdG8gZXhpc3QuXG5cdHN1cHBvcnQ6IHN1cHBvcnRcbn0gKTtcblxuaWYgKCB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgKSB7XG5cdGpRdWVyeS5mblsgU3ltYm9sLml0ZXJhdG9yIF0gPSBhcnJbIFN5bWJvbC5pdGVyYXRvciBdO1xufVxuXG4vLyBQb3B1bGF0ZSB0aGUgY2xhc3MydHlwZSBtYXBcbmpRdWVyeS5lYWNoKCBcIkJvb2xlYW4gTnVtYmVyIFN0cmluZyBGdW5jdGlvbiBBcnJheSBEYXRlIFJlZ0V4cCBPYmplY3QgRXJyb3IgU3ltYm9sXCIuc3BsaXQoIFwiIFwiICksXG5cdGZ1bmN0aW9uKCBfaSwgbmFtZSApIHtcblx0XHRjbGFzczJ0eXBlWyBcIltvYmplY3QgXCIgKyBuYW1lICsgXCJdXCIgXSA9IG5hbWUudG9Mb3dlckNhc2UoKTtcblx0fSApO1xuXG5mdW5jdGlvbiBpc0FycmF5TGlrZSggb2JqICkge1xuXG5cdC8vIFN1cHBvcnQ6IHJlYWwgaU9TIDguMiBvbmx5IChub3QgcmVwcm9kdWNpYmxlIGluIHNpbXVsYXRvcilcblx0Ly8gYGluYCBjaGVjayB1c2VkIHRvIHByZXZlbnQgSklUIGVycm9yIChnaC0yMTQ1KVxuXHQvLyBoYXNPd24gaXNuJ3QgdXNlZCBoZXJlIGR1ZSB0byBmYWxzZSBuZWdhdGl2ZXNcblx0Ly8gcmVnYXJkaW5nIE5vZGVsaXN0IGxlbmd0aCBpbiBJRVxuXHR2YXIgbGVuZ3RoID0gISFvYmogJiYgXCJsZW5ndGhcIiBpbiBvYmogJiYgb2JqLmxlbmd0aCxcblx0XHR0eXBlID0gdG9UeXBlKCBvYmogKTtcblxuXHRpZiAoIGlzRnVuY3Rpb24oIG9iaiApIHx8IGlzV2luZG93KCBvYmogKSApIHtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cblxuXHRyZXR1cm4gdHlwZSA9PT0gXCJhcnJheVwiIHx8IGxlbmd0aCA9PT0gMCB8fFxuXHRcdHR5cGVvZiBsZW5ndGggPT09IFwibnVtYmVyXCIgJiYgbGVuZ3RoID4gMCAmJiAoIGxlbmd0aCAtIDEgKSBpbiBvYmo7XG59XG52YXIgU2l6emxlID1cbi8qIVxuICogU2l6emxlIENTUyBTZWxlY3RvciBFbmdpbmUgdjIuMy42XG4gKiBodHRwczovL3NpenpsZWpzLmNvbS9cbiAqXG4gKiBDb3B5cmlnaHQgSlMgRm91bmRhdGlvbiBhbmQgb3RoZXIgY29udHJpYnV0b3JzXG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcbiAqIGh0dHBzOi8vanMuZm91bmRhdGlvbi9cbiAqXG4gKiBEYXRlOiAyMDIxLTAyLTE2XG4gKi9cbiggZnVuY3Rpb24oIHdpbmRvdyApIHtcbnZhciBpLFxuXHRzdXBwb3J0LFxuXHRFeHByLFxuXHRnZXRUZXh0LFxuXHRpc1hNTCxcblx0dG9rZW5pemUsXG5cdGNvbXBpbGUsXG5cdHNlbGVjdCxcblx0b3V0ZXJtb3N0Q29udGV4dCxcblx0c29ydElucHV0LFxuXHRoYXNEdXBsaWNhdGUsXG5cblx0Ly8gTG9jYWwgZG9jdW1lbnQgdmFyc1xuXHRzZXREb2N1bWVudCxcblx0ZG9jdW1lbnQsXG5cdGRvY0VsZW0sXG5cdGRvY3VtZW50SXNIVE1MLFxuXHRyYnVnZ3lRU0EsXG5cdHJidWdneU1hdGNoZXMsXG5cdG1hdGNoZXMsXG5cdGNvbnRhaW5zLFxuXG5cdC8vIEluc3RhbmNlLXNwZWNpZmljIGRhdGFcblx0ZXhwYW5kbyA9IFwic2l6emxlXCIgKyAxICogbmV3IERhdGUoKSxcblx0cHJlZmVycmVkRG9jID0gd2luZG93LmRvY3VtZW50LFxuXHRkaXJydW5zID0gMCxcblx0ZG9uZSA9IDAsXG5cdGNsYXNzQ2FjaGUgPSBjcmVhdGVDYWNoZSgpLFxuXHR0b2tlbkNhY2hlID0gY3JlYXRlQ2FjaGUoKSxcblx0Y29tcGlsZXJDYWNoZSA9IGNyZWF0ZUNhY2hlKCksXG5cdG5vbm5hdGl2ZVNlbGVjdG9yQ2FjaGUgPSBjcmVhdGVDYWNoZSgpLFxuXHRzb3J0T3JkZXIgPSBmdW5jdGlvbiggYSwgYiApIHtcblx0XHRpZiAoIGEgPT09IGIgKSB7XG5cdFx0XHRoYXNEdXBsaWNhdGUgPSB0cnVlO1xuXHRcdH1cblx0XHRyZXR1cm4gMDtcblx0fSxcblxuXHQvLyBJbnN0YW5jZSBtZXRob2RzXG5cdGhhc093biA9ICgge30gKS5oYXNPd25Qcm9wZXJ0eSxcblx0YXJyID0gW10sXG5cdHBvcCA9IGFyci5wb3AsXG5cdHB1c2hOYXRpdmUgPSBhcnIucHVzaCxcblx0cHVzaCA9IGFyci5wdXNoLFxuXHRzbGljZSA9IGFyci5zbGljZSxcblxuXHQvLyBVc2UgYSBzdHJpcHBlZC1kb3duIGluZGV4T2YgYXMgaXQncyBmYXN0ZXIgdGhhbiBuYXRpdmVcblx0Ly8gaHR0cHM6Ly9qc3BlcmYuY29tL3Rob3ItaW5kZXhvZi12cy1mb3IvNVxuXHRpbmRleE9mID0gZnVuY3Rpb24oIGxpc3QsIGVsZW0gKSB7XG5cdFx0dmFyIGkgPSAwLFxuXHRcdFx0bGVuID0gbGlzdC5sZW5ndGg7XG5cdFx0Zm9yICggOyBpIDwgbGVuOyBpKysgKSB7XG5cdFx0XHRpZiAoIGxpc3RbIGkgXSA9PT0gZWxlbSApIHtcblx0XHRcdFx0cmV0dXJuIGk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiAtMTtcblx0fSxcblxuXHRib29sZWFucyA9IFwiY2hlY2tlZHxzZWxlY3RlZHxhc3luY3xhdXRvZm9jdXN8YXV0b3BsYXl8Y29udHJvbHN8ZGVmZXJ8ZGlzYWJsZWR8aGlkZGVufFwiICtcblx0XHRcImlzbWFwfGxvb3B8bXVsdGlwbGV8b3BlbnxyZWFkb25seXxyZXF1aXJlZHxzY29wZWRcIixcblxuXHQvLyBSZWd1bGFyIGV4cHJlc3Npb25zXG5cblx0Ly8gaHR0cDovL3d3dy53My5vcmcvVFIvY3NzMy1zZWxlY3RvcnMvI3doaXRlc3BhY2Vcblx0d2hpdGVzcGFjZSA9IFwiW1xcXFx4MjBcXFxcdFxcXFxyXFxcXG5cXFxcZl1cIixcblxuXHQvLyBodHRwczovL3d3dy53My5vcmcvVFIvY3NzLXN5bnRheC0zLyNpZGVudC10b2tlbi1kaWFncmFtXG5cdGlkZW50aWZpZXIgPSBcIig/OlxcXFxcXFxcW1xcXFxkYS1mQS1GXXsxLDZ9XCIgKyB3aGl0ZXNwYWNlICtcblx0XHRcIj98XFxcXFxcXFxbXlxcXFxyXFxcXG5cXFxcZl18W1xcXFx3LV18W15cXDAtXFxcXHg3Zl0pK1wiLFxuXG5cdC8vIEF0dHJpYnV0ZSBzZWxlY3RvcnM6IGh0dHA6Ly93d3cudzMub3JnL1RSL3NlbGVjdG9ycy8jYXR0cmlidXRlLXNlbGVjdG9yc1xuXHRhdHRyaWJ1dGVzID0gXCJcXFxcW1wiICsgd2hpdGVzcGFjZSArIFwiKihcIiArIGlkZW50aWZpZXIgKyBcIikoPzpcIiArIHdoaXRlc3BhY2UgK1xuXG5cdFx0Ly8gT3BlcmF0b3IgKGNhcHR1cmUgMilcblx0XHRcIiooWypeJHwhfl0/PSlcIiArIHdoaXRlc3BhY2UgK1xuXG5cdFx0Ly8gXCJBdHRyaWJ1dGUgdmFsdWVzIG11c3QgYmUgQ1NTIGlkZW50aWZpZXJzIFtjYXB0dXJlIDVdXG5cdFx0Ly8gb3Igc3RyaW5ncyBbY2FwdHVyZSAzIG9yIGNhcHR1cmUgNF1cIlxuXHRcdFwiKig/OicoKD86XFxcXFxcXFwufFteXFxcXFxcXFwnXSkqKSd8XFxcIigoPzpcXFxcXFxcXC58W15cXFxcXFxcXFxcXCJdKSopXFxcInwoXCIgKyBpZGVudGlmaWVyICsgXCIpKXwpXCIgK1xuXHRcdHdoaXRlc3BhY2UgKyBcIipcXFxcXVwiLFxuXG5cdHBzZXVkb3MgPSBcIjooXCIgKyBpZGVudGlmaWVyICsgXCIpKD86XFxcXCgoXCIgK1xuXG5cdFx0Ly8gVG8gcmVkdWNlIHRoZSBudW1iZXIgb2Ygc2VsZWN0b3JzIG5lZWRpbmcgdG9rZW5pemUgaW4gdGhlIHByZUZpbHRlciwgcHJlZmVyIGFyZ3VtZW50czpcblx0XHQvLyAxLiBxdW90ZWQgKGNhcHR1cmUgMzsgY2FwdHVyZSA0IG9yIGNhcHR1cmUgNSlcblx0XHRcIignKCg/OlxcXFxcXFxcLnxbXlxcXFxcXFxcJ10pKiknfFxcXCIoKD86XFxcXFxcXFwufFteXFxcXFxcXFxcXFwiXSkqKVxcXCIpfFwiICtcblxuXHRcdC8vIDIuIHNpbXBsZSAoY2FwdHVyZSA2KVxuXHRcdFwiKCg/OlxcXFxcXFxcLnxbXlxcXFxcXFxcKClbXFxcXF1dfFwiICsgYXR0cmlidXRlcyArIFwiKSopfFwiICtcblxuXHRcdC8vIDMuIGFueXRoaW5nIGVsc2UgKGNhcHR1cmUgMilcblx0XHRcIi4qXCIgK1xuXHRcdFwiKVxcXFwpfClcIixcblxuXHQvLyBMZWFkaW5nIGFuZCBub24tZXNjYXBlZCB0cmFpbGluZyB3aGl0ZXNwYWNlLCBjYXB0dXJpbmcgc29tZSBub24td2hpdGVzcGFjZSBjaGFyYWN0ZXJzIHByZWNlZGluZyB0aGUgbGF0dGVyXG5cdHJ3aGl0ZXNwYWNlID0gbmV3IFJlZ0V4cCggd2hpdGVzcGFjZSArIFwiK1wiLCBcImdcIiApLFxuXHRydHJpbSA9IG5ldyBSZWdFeHAoIFwiXlwiICsgd2hpdGVzcGFjZSArIFwiK3woKD86XnxbXlxcXFxcXFxcXSkoPzpcXFxcXFxcXC4pKilcIiArXG5cdFx0d2hpdGVzcGFjZSArIFwiKyRcIiwgXCJnXCIgKSxcblxuXHRyY29tbWEgPSBuZXcgUmVnRXhwKCBcIl5cIiArIHdoaXRlc3BhY2UgKyBcIiosXCIgKyB3aGl0ZXNwYWNlICsgXCIqXCIgKSxcblx0cmNvbWJpbmF0b3JzID0gbmV3IFJlZ0V4cCggXCJeXCIgKyB3aGl0ZXNwYWNlICsgXCIqKFs+K35dfFwiICsgd2hpdGVzcGFjZSArIFwiKVwiICsgd2hpdGVzcGFjZSArXG5cdFx0XCIqXCIgKSxcblx0cmRlc2NlbmQgPSBuZXcgUmVnRXhwKCB3aGl0ZXNwYWNlICsgXCJ8PlwiICksXG5cblx0cnBzZXVkbyA9IG5ldyBSZWdFeHAoIHBzZXVkb3MgKSxcblx0cmlkZW50aWZpZXIgPSBuZXcgUmVnRXhwKCBcIl5cIiArIGlkZW50aWZpZXIgKyBcIiRcIiApLFxuXG5cdG1hdGNoRXhwciA9IHtcblx0XHRcIklEXCI6IG5ldyBSZWdFeHAoIFwiXiMoXCIgKyBpZGVudGlmaWVyICsgXCIpXCIgKSxcblx0XHRcIkNMQVNTXCI6IG5ldyBSZWdFeHAoIFwiXlxcXFwuKFwiICsgaWRlbnRpZmllciArIFwiKVwiICksXG5cdFx0XCJUQUdcIjogbmV3IFJlZ0V4cCggXCJeKFwiICsgaWRlbnRpZmllciArIFwifFsqXSlcIiApLFxuXHRcdFwiQVRUUlwiOiBuZXcgUmVnRXhwKCBcIl5cIiArIGF0dHJpYnV0ZXMgKSxcblx0XHRcIlBTRVVET1wiOiBuZXcgUmVnRXhwKCBcIl5cIiArIHBzZXVkb3MgKSxcblx0XHRcIkNISUxEXCI6IG5ldyBSZWdFeHAoIFwiXjoob25seXxmaXJzdHxsYXN0fG50aHxudGgtbGFzdCktKGNoaWxkfG9mLXR5cGUpKD86XFxcXChcIiArXG5cdFx0XHR3aGl0ZXNwYWNlICsgXCIqKGV2ZW58b2RkfCgoWystXXwpKFxcXFxkKilufClcIiArIHdoaXRlc3BhY2UgKyBcIiooPzooWystXXwpXCIgK1xuXHRcdFx0d2hpdGVzcGFjZSArIFwiKihcXFxcZCspfCkpXCIgKyB3aGl0ZXNwYWNlICsgXCIqXFxcXCl8KVwiLCBcImlcIiApLFxuXHRcdFwiYm9vbFwiOiBuZXcgUmVnRXhwKCBcIl4oPzpcIiArIGJvb2xlYW5zICsgXCIpJFwiLCBcImlcIiApLFxuXG5cdFx0Ly8gRm9yIHVzZSBpbiBsaWJyYXJpZXMgaW1wbGVtZW50aW5nIC5pcygpXG5cdFx0Ly8gV2UgdXNlIHRoaXMgZm9yIFBPUyBtYXRjaGluZyBpbiBgc2VsZWN0YFxuXHRcdFwibmVlZHNDb250ZXh0XCI6IG5ldyBSZWdFeHAoIFwiXlwiICsgd2hpdGVzcGFjZSArXG5cdFx0XHRcIipbPit+XXw6KGV2ZW58b2RkfGVxfGd0fGx0fG50aHxmaXJzdHxsYXN0KSg/OlxcXFwoXCIgKyB3aGl0ZXNwYWNlICtcblx0XHRcdFwiKigoPzotXFxcXGQpP1xcXFxkKilcIiArIHdoaXRlc3BhY2UgKyBcIipcXFxcKXwpKD89W14tXXwkKVwiLCBcImlcIiApXG5cdH0sXG5cblx0cmh0bWwgPSAvSFRNTCQvaSxcblx0cmlucHV0cyA9IC9eKD86aW5wdXR8c2VsZWN0fHRleHRhcmVhfGJ1dHRvbikkL2ksXG5cdHJoZWFkZXIgPSAvXmhcXGQkL2ksXG5cblx0cm5hdGl2ZSA9IC9eW157XStcXHtcXHMqXFxbbmF0aXZlIFxcdy8sXG5cblx0Ly8gRWFzaWx5LXBhcnNlYWJsZS9yZXRyaWV2YWJsZSBJRCBvciBUQUcgb3IgQ0xBU1Mgc2VsZWN0b3JzXG5cdHJxdWlja0V4cHIgPSAvXig/OiMoW1xcdy1dKyl8KFxcdyspfFxcLihbXFx3LV0rKSkkLyxcblxuXHRyc2libGluZyA9IC9bK35dLyxcblxuXHQvLyBDU1MgZXNjYXBlc1xuXHQvLyBodHRwOi8vd3d3LnczLm9yZy9UUi9DU1MyMS9zeW5kYXRhLmh0bWwjZXNjYXBlZC1jaGFyYWN0ZXJzXG5cdHJ1bmVzY2FwZSA9IG5ldyBSZWdFeHAoIFwiXFxcXFxcXFxbXFxcXGRhLWZBLUZdezEsNn1cIiArIHdoaXRlc3BhY2UgKyBcIj98XFxcXFxcXFwoW15cXFxcclxcXFxuXFxcXGZdKVwiLCBcImdcIiApLFxuXHRmdW5lc2NhcGUgPSBmdW5jdGlvbiggZXNjYXBlLCBub25IZXggKSB7XG5cdFx0dmFyIGhpZ2ggPSBcIjB4XCIgKyBlc2NhcGUuc2xpY2UoIDEgKSAtIDB4MTAwMDA7XG5cblx0XHRyZXR1cm4gbm9uSGV4ID9cblxuXHRcdFx0Ly8gU3RyaXAgdGhlIGJhY2tzbGFzaCBwcmVmaXggZnJvbSBhIG5vbi1oZXggZXNjYXBlIHNlcXVlbmNlXG5cdFx0XHRub25IZXggOlxuXG5cdFx0XHQvLyBSZXBsYWNlIGEgaGV4YWRlY2ltYWwgZXNjYXBlIHNlcXVlbmNlIHdpdGggdGhlIGVuY29kZWQgVW5pY29kZSBjb2RlIHBvaW50XG5cdFx0XHQvLyBTdXBwb3J0OiBJRSA8PTExK1xuXHRcdFx0Ly8gRm9yIHZhbHVlcyBvdXRzaWRlIHRoZSBCYXNpYyBNdWx0aWxpbmd1YWwgUGxhbmUgKEJNUCksIG1hbnVhbGx5IGNvbnN0cnVjdCBhXG5cdFx0XHQvLyBzdXJyb2dhdGUgcGFpclxuXHRcdFx0aGlnaCA8IDAgP1xuXHRcdFx0XHRTdHJpbmcuZnJvbUNoYXJDb2RlKCBoaWdoICsgMHgxMDAwMCApIDpcblx0XHRcdFx0U3RyaW5nLmZyb21DaGFyQ29kZSggaGlnaCA+PiAxMCB8IDB4RDgwMCwgaGlnaCAmIDB4M0ZGIHwgMHhEQzAwICk7XG5cdH0sXG5cblx0Ly8gQ1NTIHN0cmluZy9pZGVudGlmaWVyIHNlcmlhbGl6YXRpb25cblx0Ly8gaHR0cHM6Ly9kcmFmdHMuY3Nzd2cub3JnL2Nzc29tLyNjb21tb24tc2VyaWFsaXppbmctaWRpb21zXG5cdHJjc3Nlc2NhcGUgPSAvKFtcXDAtXFx4MWZcXHg3Zl18Xi0/XFxkKXxeLSR8W15cXDAtXFx4MWZcXHg3Zi1cXHVGRkZGXFx3LV0vZyxcblx0ZmNzc2VzY2FwZSA9IGZ1bmN0aW9uKCBjaCwgYXNDb2RlUG9pbnQgKSB7XG5cdFx0aWYgKCBhc0NvZGVQb2ludCApIHtcblxuXHRcdFx0Ly8gVSswMDAwIE5VTEwgYmVjb21lcyBVK0ZGRkQgUkVQTEFDRU1FTlQgQ0hBUkFDVEVSXG5cdFx0XHRpZiAoIGNoID09PSBcIlxcMFwiICkge1xuXHRcdFx0XHRyZXR1cm4gXCJcXHVGRkZEXCI7XG5cdFx0XHR9XG5cblx0XHRcdC8vIENvbnRyb2wgY2hhcmFjdGVycyBhbmQgKGRlcGVuZGVudCB1cG9uIHBvc2l0aW9uKSBudW1iZXJzIGdldCBlc2NhcGVkIGFzIGNvZGUgcG9pbnRzXG5cdFx0XHRyZXR1cm4gY2guc2xpY2UoIDAsIC0xICkgKyBcIlxcXFxcIiArXG5cdFx0XHRcdGNoLmNoYXJDb2RlQXQoIGNoLmxlbmd0aCAtIDEgKS50b1N0cmluZyggMTYgKSArIFwiIFwiO1xuXHRcdH1cblxuXHRcdC8vIE90aGVyIHBvdGVudGlhbGx5LXNwZWNpYWwgQVNDSUkgY2hhcmFjdGVycyBnZXQgYmFja3NsYXNoLWVzY2FwZWRcblx0XHRyZXR1cm4gXCJcXFxcXCIgKyBjaDtcblx0fSxcblxuXHQvLyBVc2VkIGZvciBpZnJhbWVzXG5cdC8vIFNlZSBzZXREb2N1bWVudCgpXG5cdC8vIFJlbW92aW5nIHRoZSBmdW5jdGlvbiB3cmFwcGVyIGNhdXNlcyBhIFwiUGVybWlzc2lvbiBEZW5pZWRcIlxuXHQvLyBlcnJvciBpbiBJRVxuXHR1bmxvYWRIYW5kbGVyID0gZnVuY3Rpb24oKSB7XG5cdFx0c2V0RG9jdW1lbnQoKTtcblx0fSxcblxuXHRpbkRpc2FibGVkRmllbGRzZXQgPSBhZGRDb21iaW5hdG9yKFxuXHRcdGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuIGVsZW0uZGlzYWJsZWQgPT09IHRydWUgJiYgZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSBcImZpZWxkc2V0XCI7XG5cdFx0fSxcblx0XHR7IGRpcjogXCJwYXJlbnROb2RlXCIsIG5leHQ6IFwibGVnZW5kXCIgfVxuXHQpO1xuXG4vLyBPcHRpbWl6ZSBmb3IgcHVzaC5hcHBseSggXywgTm9kZUxpc3QgKVxudHJ5IHtcblx0cHVzaC5hcHBseShcblx0XHQoIGFyciA9IHNsaWNlLmNhbGwoIHByZWZlcnJlZERvYy5jaGlsZE5vZGVzICkgKSxcblx0XHRwcmVmZXJyZWREb2MuY2hpbGROb2Rlc1xuXHQpO1xuXG5cdC8vIFN1cHBvcnQ6IEFuZHJvaWQ8NC4wXG5cdC8vIERldGVjdCBzaWxlbnRseSBmYWlsaW5nIHB1c2guYXBwbHlcblx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVudXNlZC1leHByZXNzaW9uc1xuXHRhcnJbIHByZWZlcnJlZERvYy5jaGlsZE5vZGVzLmxlbmd0aCBdLm5vZGVUeXBlO1xufSBjYXRjaCAoIGUgKSB7XG5cdHB1c2ggPSB7IGFwcGx5OiBhcnIubGVuZ3RoID9cblxuXHRcdC8vIExldmVyYWdlIHNsaWNlIGlmIHBvc3NpYmxlXG5cdFx0ZnVuY3Rpb24oIHRhcmdldCwgZWxzICkge1xuXHRcdFx0cHVzaE5hdGl2ZS5hcHBseSggdGFyZ2V0LCBzbGljZS5jYWxsKCBlbHMgKSApO1xuXHRcdH0gOlxuXG5cdFx0Ly8gU3VwcG9ydDogSUU8OVxuXHRcdC8vIE90aGVyd2lzZSBhcHBlbmQgZGlyZWN0bHlcblx0XHRmdW5jdGlvbiggdGFyZ2V0LCBlbHMgKSB7XG5cdFx0XHR2YXIgaiA9IHRhcmdldC5sZW5ndGgsXG5cdFx0XHRcdGkgPSAwO1xuXG5cdFx0XHQvLyBDYW4ndCB0cnVzdCBOb2RlTGlzdC5sZW5ndGhcblx0XHRcdHdoaWxlICggKCB0YXJnZXRbIGorKyBdID0gZWxzWyBpKysgXSApICkge31cblx0XHRcdHRhcmdldC5sZW5ndGggPSBqIC0gMTtcblx0XHR9XG5cdH07XG59XG5cbmZ1bmN0aW9uIFNpenpsZSggc2VsZWN0b3IsIGNvbnRleHQsIHJlc3VsdHMsIHNlZWQgKSB7XG5cdHZhciBtLCBpLCBlbGVtLCBuaWQsIG1hdGNoLCBncm91cHMsIG5ld1NlbGVjdG9yLFxuXHRcdG5ld0NvbnRleHQgPSBjb250ZXh0ICYmIGNvbnRleHQub3duZXJEb2N1bWVudCxcblxuXHRcdC8vIG5vZGVUeXBlIGRlZmF1bHRzIHRvIDksIHNpbmNlIGNvbnRleHQgZGVmYXVsdHMgdG8gZG9jdW1lbnRcblx0XHRub2RlVHlwZSA9IGNvbnRleHQgPyBjb250ZXh0Lm5vZGVUeXBlIDogOTtcblxuXHRyZXN1bHRzID0gcmVzdWx0cyB8fCBbXTtcblxuXHQvLyBSZXR1cm4gZWFybHkgZnJvbSBjYWxscyB3aXRoIGludmFsaWQgc2VsZWN0b3Igb3IgY29udGV4dFxuXHRpZiAoIHR5cGVvZiBzZWxlY3RvciAhPT0gXCJzdHJpbmdcIiB8fCAhc2VsZWN0b3IgfHxcblx0XHRub2RlVHlwZSAhPT0gMSAmJiBub2RlVHlwZSAhPT0gOSAmJiBub2RlVHlwZSAhPT0gMTEgKSB7XG5cblx0XHRyZXR1cm4gcmVzdWx0cztcblx0fVxuXG5cdC8vIFRyeSB0byBzaG9ydGN1dCBmaW5kIG9wZXJhdGlvbnMgKGFzIG9wcG9zZWQgdG8gZmlsdGVycykgaW4gSFRNTCBkb2N1bWVudHNcblx0aWYgKCAhc2VlZCApIHtcblx0XHRzZXREb2N1bWVudCggY29udGV4dCApO1xuXHRcdGNvbnRleHQgPSBjb250ZXh0IHx8IGRvY3VtZW50O1xuXG5cdFx0aWYgKCBkb2N1bWVudElzSFRNTCApIHtcblxuXHRcdFx0Ly8gSWYgdGhlIHNlbGVjdG9yIGlzIHN1ZmZpY2llbnRseSBzaW1wbGUsIHRyeSB1c2luZyBhIFwiZ2V0KkJ5KlwiIERPTSBtZXRob2Rcblx0XHRcdC8vIChleGNlcHRpbmcgRG9jdW1lbnRGcmFnbWVudCBjb250ZXh0LCB3aGVyZSB0aGUgbWV0aG9kcyBkb24ndCBleGlzdClcblx0XHRcdGlmICggbm9kZVR5cGUgIT09IDExICYmICggbWF0Y2ggPSBycXVpY2tFeHByLmV4ZWMoIHNlbGVjdG9yICkgKSApIHtcblxuXHRcdFx0XHQvLyBJRCBzZWxlY3RvclxuXHRcdFx0XHRpZiAoICggbSA9IG1hdGNoWyAxIF0gKSApIHtcblxuXHRcdFx0XHRcdC8vIERvY3VtZW50IGNvbnRleHRcblx0XHRcdFx0XHRpZiAoIG5vZGVUeXBlID09PSA5ICkge1xuXHRcdFx0XHRcdFx0aWYgKCAoIGVsZW0gPSBjb250ZXh0LmdldEVsZW1lbnRCeUlkKCBtICkgKSApIHtcblxuXHRcdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRSwgT3BlcmEsIFdlYmtpdFxuXHRcdFx0XHRcdFx0XHQvLyBUT0RPOiBpZGVudGlmeSB2ZXJzaW9uc1xuXHRcdFx0XHRcdFx0XHQvLyBnZXRFbGVtZW50QnlJZCBjYW4gbWF0Y2ggZWxlbWVudHMgYnkgbmFtZSBpbnN0ZWFkIG9mIElEXG5cdFx0XHRcdFx0XHRcdGlmICggZWxlbS5pZCA9PT0gbSApIHtcblx0XHRcdFx0XHRcdFx0XHRyZXN1bHRzLnB1c2goIGVsZW0gKTtcblx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gcmVzdWx0cztcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIHJlc3VsdHM7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBFbGVtZW50IGNvbnRleHRcblx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRSwgT3BlcmEsIFdlYmtpdFxuXHRcdFx0XHRcdFx0Ly8gVE9ETzogaWRlbnRpZnkgdmVyc2lvbnNcblx0XHRcdFx0XHRcdC8vIGdldEVsZW1lbnRCeUlkIGNhbiBtYXRjaCBlbGVtZW50cyBieSBuYW1lIGluc3RlYWQgb2YgSURcblx0XHRcdFx0XHRcdGlmICggbmV3Q29udGV4dCAmJiAoIGVsZW0gPSBuZXdDb250ZXh0LmdldEVsZW1lbnRCeUlkKCBtICkgKSAmJlxuXHRcdFx0XHRcdFx0XHRjb250YWlucyggY29udGV4dCwgZWxlbSApICYmXG5cdFx0XHRcdFx0XHRcdGVsZW0uaWQgPT09IG0gKSB7XG5cblx0XHRcdFx0XHRcdFx0cmVzdWx0cy5wdXNoKCBlbGVtICk7XG5cdFx0XHRcdFx0XHRcdHJldHVybiByZXN1bHRzO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBUeXBlIHNlbGVjdG9yXG5cdFx0XHRcdH0gZWxzZSBpZiAoIG1hdGNoWyAyIF0gKSB7XG5cdFx0XHRcdFx0cHVzaC5hcHBseSggcmVzdWx0cywgY29udGV4dC5nZXRFbGVtZW50c0J5VGFnTmFtZSggc2VsZWN0b3IgKSApO1xuXHRcdFx0XHRcdHJldHVybiByZXN1bHRzO1xuXG5cdFx0XHRcdC8vIENsYXNzIHNlbGVjdG9yXG5cdFx0XHRcdH0gZWxzZSBpZiAoICggbSA9IG1hdGNoWyAzIF0gKSAmJiBzdXBwb3J0LmdldEVsZW1lbnRzQnlDbGFzc05hbWUgJiZcblx0XHRcdFx0XHRjb250ZXh0LmdldEVsZW1lbnRzQnlDbGFzc05hbWUgKSB7XG5cblx0XHRcdFx0XHRwdXNoLmFwcGx5KCByZXN1bHRzLCBjb250ZXh0LmdldEVsZW1lbnRzQnlDbGFzc05hbWUoIG0gKSApO1xuXHRcdFx0XHRcdHJldHVybiByZXN1bHRzO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIFRha2UgYWR2YW50YWdlIG9mIHF1ZXJ5U2VsZWN0b3JBbGxcblx0XHRcdGlmICggc3VwcG9ydC5xc2EgJiZcblx0XHRcdFx0IW5vbm5hdGl2ZVNlbGVjdG9yQ2FjaGVbIHNlbGVjdG9yICsgXCIgXCIgXSAmJlxuXHRcdFx0XHQoICFyYnVnZ3lRU0EgfHwgIXJidWdneVFTQS50ZXN0KCBzZWxlY3RvciApICkgJiZcblxuXHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA4IG9ubHlcblx0XHRcdFx0Ly8gRXhjbHVkZSBvYmplY3QgZWxlbWVudHNcblx0XHRcdFx0KCBub2RlVHlwZSAhPT0gMSB8fCBjb250ZXh0Lm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgIT09IFwib2JqZWN0XCIgKSApIHtcblxuXHRcdFx0XHRuZXdTZWxlY3RvciA9IHNlbGVjdG9yO1xuXHRcdFx0XHRuZXdDb250ZXh0ID0gY29udGV4dDtcblxuXHRcdFx0XHQvLyBxU0EgY29uc2lkZXJzIGVsZW1lbnRzIG91dHNpZGUgYSBzY29waW5nIHJvb3Qgd2hlbiBldmFsdWF0aW5nIGNoaWxkIG9yXG5cdFx0XHRcdC8vIGRlc2NlbmRhbnQgY29tYmluYXRvcnMsIHdoaWNoIGlzIG5vdCB3aGF0IHdlIHdhbnQuXG5cdFx0XHRcdC8vIEluIHN1Y2ggY2FzZXMsIHdlIHdvcmsgYXJvdW5kIHRoZSBiZWhhdmlvciBieSBwcmVmaXhpbmcgZXZlcnkgc2VsZWN0b3IgaW4gdGhlXG5cdFx0XHRcdC8vIGxpc3Qgd2l0aCBhbiBJRCBzZWxlY3RvciByZWZlcmVuY2luZyB0aGUgc2NvcGUgY29udGV4dC5cblx0XHRcdFx0Ly8gVGhlIHRlY2huaXF1ZSBoYXMgdG8gYmUgdXNlZCBhcyB3ZWxsIHdoZW4gYSBsZWFkaW5nIGNvbWJpbmF0b3IgaXMgdXNlZFxuXHRcdFx0XHQvLyBhcyBzdWNoIHNlbGVjdG9ycyBhcmUgbm90IHJlY29nbml6ZWQgYnkgcXVlcnlTZWxlY3RvckFsbC5cblx0XHRcdFx0Ly8gVGhhbmtzIHRvIEFuZHJldyBEdXBvbnQgZm9yIHRoaXMgdGVjaG5pcXVlLlxuXHRcdFx0XHRpZiAoIG5vZGVUeXBlID09PSAxICYmXG5cdFx0XHRcdFx0KCByZGVzY2VuZC50ZXN0KCBzZWxlY3RvciApIHx8IHJjb21iaW5hdG9ycy50ZXN0KCBzZWxlY3RvciApICkgKSB7XG5cblx0XHRcdFx0XHQvLyBFeHBhbmQgY29udGV4dCBmb3Igc2libGluZyBzZWxlY3RvcnNcblx0XHRcdFx0XHRuZXdDb250ZXh0ID0gcnNpYmxpbmcudGVzdCggc2VsZWN0b3IgKSAmJiB0ZXN0Q29udGV4dCggY29udGV4dC5wYXJlbnROb2RlICkgfHxcblx0XHRcdFx0XHRcdGNvbnRleHQ7XG5cblx0XHRcdFx0XHQvLyBXZSBjYW4gdXNlIDpzY29wZSBpbnN0ZWFkIG9mIHRoZSBJRCBoYWNrIGlmIHRoZSBicm93c2VyXG5cdFx0XHRcdFx0Ly8gc3VwcG9ydHMgaXQgJiBpZiB3ZSdyZSBub3QgY2hhbmdpbmcgdGhlIGNvbnRleHQuXG5cdFx0XHRcdFx0aWYgKCBuZXdDb250ZXh0ICE9PSBjb250ZXh0IHx8ICFzdXBwb3J0LnNjb3BlICkge1xuXG5cdFx0XHRcdFx0XHQvLyBDYXB0dXJlIHRoZSBjb250ZXh0IElELCBzZXR0aW5nIGl0IGZpcnN0IGlmIG5lY2Vzc2FyeVxuXHRcdFx0XHRcdFx0aWYgKCAoIG5pZCA9IGNvbnRleHQuZ2V0QXR0cmlidXRlKCBcImlkXCIgKSApICkge1xuXHRcdFx0XHRcdFx0XHRuaWQgPSBuaWQucmVwbGFjZSggcmNzc2VzY2FwZSwgZmNzc2VzY2FwZSApO1xuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0Y29udGV4dC5zZXRBdHRyaWJ1dGUoIFwiaWRcIiwgKCBuaWQgPSBleHBhbmRvICkgKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBQcmVmaXggZXZlcnkgc2VsZWN0b3IgaW4gdGhlIGxpc3Rcblx0XHRcdFx0XHRncm91cHMgPSB0b2tlbml6ZSggc2VsZWN0b3IgKTtcblx0XHRcdFx0XHRpID0gZ3JvdXBzLmxlbmd0aDtcblx0XHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0XHRcdGdyb3Vwc1sgaSBdID0gKCBuaWQgPyBcIiNcIiArIG5pZCA6IFwiOnNjb3BlXCIgKSArIFwiIFwiICtcblx0XHRcdFx0XHRcdFx0dG9TZWxlY3RvciggZ3JvdXBzWyBpIF0gKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0bmV3U2VsZWN0b3IgPSBncm91cHMuam9pbiggXCIsXCIgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0cHVzaC5hcHBseSggcmVzdWx0cyxcblx0XHRcdFx0XHRcdG5ld0NvbnRleHQucXVlcnlTZWxlY3RvckFsbCggbmV3U2VsZWN0b3IgKVxuXHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0cmV0dXJuIHJlc3VsdHM7XG5cdFx0XHRcdH0gY2F0Y2ggKCBxc2FFcnJvciApIHtcblx0XHRcdFx0XHRub25uYXRpdmVTZWxlY3RvckNhY2hlKCBzZWxlY3RvciwgdHJ1ZSApO1xuXHRcdFx0XHR9IGZpbmFsbHkge1xuXHRcdFx0XHRcdGlmICggbmlkID09PSBleHBhbmRvICkge1xuXHRcdFx0XHRcdFx0Y29udGV4dC5yZW1vdmVBdHRyaWJ1dGUoIFwiaWRcIiApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8vIEFsbCBvdGhlcnNcblx0cmV0dXJuIHNlbGVjdCggc2VsZWN0b3IucmVwbGFjZSggcnRyaW0sIFwiJDFcIiApLCBjb250ZXh0LCByZXN1bHRzLCBzZWVkICk7XG59XG5cbi8qKlxuICogQ3JlYXRlIGtleS12YWx1ZSBjYWNoZXMgb2YgbGltaXRlZCBzaXplXG4gKiBAcmV0dXJucyB7ZnVuY3Rpb24oc3RyaW5nLCBvYmplY3QpfSBSZXR1cm5zIHRoZSBPYmplY3QgZGF0YSBhZnRlciBzdG9yaW5nIGl0IG9uIGl0c2VsZiB3aXRoXG4gKlx0cHJvcGVydHkgbmFtZSB0aGUgKHNwYWNlLXN1ZmZpeGVkKSBzdHJpbmcgYW5kIChpZiB0aGUgY2FjaGUgaXMgbGFyZ2VyIHRoYW4gRXhwci5jYWNoZUxlbmd0aClcbiAqXHRkZWxldGluZyB0aGUgb2xkZXN0IGVudHJ5XG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUNhY2hlKCkge1xuXHR2YXIga2V5cyA9IFtdO1xuXG5cdGZ1bmN0aW9uIGNhY2hlKCBrZXksIHZhbHVlICkge1xuXG5cdFx0Ly8gVXNlIChrZXkgKyBcIiBcIikgdG8gYXZvaWQgY29sbGlzaW9uIHdpdGggbmF0aXZlIHByb3RvdHlwZSBwcm9wZXJ0aWVzIChzZWUgSXNzdWUgIzE1Nylcblx0XHRpZiAoIGtleXMucHVzaCgga2V5ICsgXCIgXCIgKSA+IEV4cHIuY2FjaGVMZW5ndGggKSB7XG5cblx0XHRcdC8vIE9ubHkga2VlcCB0aGUgbW9zdCByZWNlbnQgZW50cmllc1xuXHRcdFx0ZGVsZXRlIGNhY2hlWyBrZXlzLnNoaWZ0KCkgXTtcblx0XHR9XG5cdFx0cmV0dXJuICggY2FjaGVbIGtleSArIFwiIFwiIF0gPSB2YWx1ZSApO1xuXHR9XG5cdHJldHVybiBjYWNoZTtcbn1cblxuLyoqXG4gKiBNYXJrIGEgZnVuY3Rpb24gZm9yIHNwZWNpYWwgdXNlIGJ5IFNpenpsZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGZ1bmN0aW9uIHRvIG1hcmtcbiAqL1xuZnVuY3Rpb24gbWFya0Z1bmN0aW9uKCBmbiApIHtcblx0Zm5bIGV4cGFuZG8gXSA9IHRydWU7XG5cdHJldHVybiBmbjtcbn1cblxuLyoqXG4gKiBTdXBwb3J0IHRlc3RpbmcgdXNpbmcgYW4gZWxlbWVudFxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gUGFzc2VkIHRoZSBjcmVhdGVkIGVsZW1lbnQgYW5kIHJldHVybnMgYSBib29sZWFuIHJlc3VsdFxuICovXG5mdW5jdGlvbiBhc3NlcnQoIGZuICkge1xuXHR2YXIgZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImZpZWxkc2V0XCIgKTtcblxuXHR0cnkge1xuXHRcdHJldHVybiAhIWZuKCBlbCApO1xuXHR9IGNhdGNoICggZSApIHtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH0gZmluYWxseSB7XG5cblx0XHQvLyBSZW1vdmUgZnJvbSBpdHMgcGFyZW50IGJ5IGRlZmF1bHRcblx0XHRpZiAoIGVsLnBhcmVudE5vZGUgKSB7XG5cdFx0XHRlbC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKCBlbCApO1xuXHRcdH1cblxuXHRcdC8vIHJlbGVhc2UgbWVtb3J5IGluIElFXG5cdFx0ZWwgPSBudWxsO1xuXHR9XG59XG5cbi8qKlxuICogQWRkcyB0aGUgc2FtZSBoYW5kbGVyIGZvciBhbGwgb2YgdGhlIHNwZWNpZmllZCBhdHRyc1xuICogQHBhcmFtIHtTdHJpbmd9IGF0dHJzIFBpcGUtc2VwYXJhdGVkIGxpc3Qgb2YgYXR0cmlidXRlc1xuICogQHBhcmFtIHtGdW5jdGlvbn0gaGFuZGxlciBUaGUgbWV0aG9kIHRoYXQgd2lsbCBiZSBhcHBsaWVkXG4gKi9cbmZ1bmN0aW9uIGFkZEhhbmRsZSggYXR0cnMsIGhhbmRsZXIgKSB7XG5cdHZhciBhcnIgPSBhdHRycy5zcGxpdCggXCJ8XCIgKSxcblx0XHRpID0gYXJyLmxlbmd0aDtcblxuXHR3aGlsZSAoIGktLSApIHtcblx0XHRFeHByLmF0dHJIYW5kbGVbIGFyclsgaSBdIF0gPSBoYW5kbGVyO1xuXHR9XG59XG5cbi8qKlxuICogQ2hlY2tzIGRvY3VtZW50IG9yZGVyIG9mIHR3byBzaWJsaW5nc1xuICogQHBhcmFtIHtFbGVtZW50fSBhXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGJcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IFJldHVybnMgbGVzcyB0aGFuIDAgaWYgYSBwcmVjZWRlcyBiLCBncmVhdGVyIHRoYW4gMCBpZiBhIGZvbGxvd3MgYlxuICovXG5mdW5jdGlvbiBzaWJsaW5nQ2hlY2soIGEsIGIgKSB7XG5cdHZhciBjdXIgPSBiICYmIGEsXG5cdFx0ZGlmZiA9IGN1ciAmJiBhLm5vZGVUeXBlID09PSAxICYmIGIubm9kZVR5cGUgPT09IDEgJiZcblx0XHRcdGEuc291cmNlSW5kZXggLSBiLnNvdXJjZUluZGV4O1xuXG5cdC8vIFVzZSBJRSBzb3VyY2VJbmRleCBpZiBhdmFpbGFibGUgb24gYm90aCBub2Rlc1xuXHRpZiAoIGRpZmYgKSB7XG5cdFx0cmV0dXJuIGRpZmY7XG5cdH1cblxuXHQvLyBDaGVjayBpZiBiIGZvbGxvd3MgYVxuXHRpZiAoIGN1ciApIHtcblx0XHR3aGlsZSAoICggY3VyID0gY3VyLm5leHRTaWJsaW5nICkgKSB7XG5cdFx0XHRpZiAoIGN1ciA9PT0gYiApIHtcblx0XHRcdFx0cmV0dXJuIC0xO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHJldHVybiBhID8gMSA6IC0xO1xufVxuXG4vKipcbiAqIFJldHVybnMgYSBmdW5jdGlvbiB0byB1c2UgaW4gcHNldWRvcyBmb3IgaW5wdXQgdHlwZXNcbiAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUlucHV0UHNldWRvKCB0eXBlICkge1xuXHRyZXR1cm4gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0dmFyIG5hbWUgPSBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG5cdFx0cmV0dXJuIG5hbWUgPT09IFwiaW5wdXRcIiAmJiBlbGVtLnR5cGUgPT09IHR5cGU7XG5cdH07XG59XG5cbi8qKlxuICogUmV0dXJucyBhIGZ1bmN0aW9uIHRvIHVzZSBpbiBwc2V1ZG9zIGZvciBidXR0b25zXG4gKiBAcGFyYW0ge1N0cmluZ30gdHlwZVxuICovXG5mdW5jdGlvbiBjcmVhdGVCdXR0b25Qc2V1ZG8oIHR5cGUgKSB7XG5cdHJldHVybiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHR2YXIgbmFtZSA9IGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcblx0XHRyZXR1cm4gKCBuYW1lID09PSBcImlucHV0XCIgfHwgbmFtZSA9PT0gXCJidXR0b25cIiApICYmIGVsZW0udHlwZSA9PT0gdHlwZTtcblx0fTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgZnVuY3Rpb24gdG8gdXNlIGluIHBzZXVkb3MgZm9yIDplbmFibGVkLzpkaXNhYmxlZFxuICogQHBhcmFtIHtCb29sZWFufSBkaXNhYmxlZCB0cnVlIGZvciA6ZGlzYWJsZWQ7IGZhbHNlIGZvciA6ZW5hYmxlZFxuICovXG5mdW5jdGlvbiBjcmVhdGVEaXNhYmxlZFBzZXVkbyggZGlzYWJsZWQgKSB7XG5cblx0Ly8gS25vd24gOmRpc2FibGVkIGZhbHNlIHBvc2l0aXZlczogZmllbGRzZXRbZGlzYWJsZWRdID4gbGVnZW5kOm50aC1vZi10eXBlKG4rMikgOmNhbi1kaXNhYmxlXG5cdHJldHVybiBmdW5jdGlvbiggZWxlbSApIHtcblxuXHRcdC8vIE9ubHkgY2VydGFpbiBlbGVtZW50cyBjYW4gbWF0Y2ggOmVuYWJsZWQgb3IgOmRpc2FibGVkXG5cdFx0Ly8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc2NyaXB0aW5nLmh0bWwjc2VsZWN0b3ItZW5hYmxlZFxuXHRcdC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3NjcmlwdGluZy5odG1sI3NlbGVjdG9yLWRpc2FibGVkXG5cdFx0aWYgKCBcImZvcm1cIiBpbiBlbGVtICkge1xuXG5cdFx0XHQvLyBDaGVjayBmb3IgaW5oZXJpdGVkIGRpc2FibGVkbmVzcyBvbiByZWxldmFudCBub24tZGlzYWJsZWQgZWxlbWVudHM6XG5cdFx0XHQvLyAqIGxpc3RlZCBmb3JtLWFzc29jaWF0ZWQgZWxlbWVudHMgaW4gYSBkaXNhYmxlZCBmaWVsZHNldFxuXHRcdFx0Ly8gICBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9mb3Jtcy5odG1sI2NhdGVnb3J5LWxpc3RlZFxuXHRcdFx0Ly8gICBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9mb3Jtcy5odG1sI2NvbmNlcHQtZmUtZGlzYWJsZWRcblx0XHRcdC8vICogb3B0aW9uIGVsZW1lbnRzIGluIGEgZGlzYWJsZWQgb3B0Z3JvdXBcblx0XHRcdC8vICAgaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvZm9ybXMuaHRtbCNjb25jZXB0LW9wdGlvbi1kaXNhYmxlZFxuXHRcdFx0Ly8gQWxsIHN1Y2ggZWxlbWVudHMgaGF2ZSBhIFwiZm9ybVwiIHByb3BlcnR5LlxuXHRcdFx0aWYgKCBlbGVtLnBhcmVudE5vZGUgJiYgZWxlbS5kaXNhYmxlZCA9PT0gZmFsc2UgKSB7XG5cblx0XHRcdFx0Ly8gT3B0aW9uIGVsZW1lbnRzIGRlZmVyIHRvIGEgcGFyZW50IG9wdGdyb3VwIGlmIHByZXNlbnRcblx0XHRcdFx0aWYgKCBcImxhYmVsXCIgaW4gZWxlbSApIHtcblx0XHRcdFx0XHRpZiAoIFwibGFiZWxcIiBpbiBlbGVtLnBhcmVudE5vZGUgKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZWxlbS5wYXJlbnROb2RlLmRpc2FibGVkID09PSBkaXNhYmxlZDtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0cmV0dXJuIGVsZW0uZGlzYWJsZWQgPT09IGRpc2FibGVkO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDYgLSAxMVxuXHRcdFx0XHQvLyBVc2UgdGhlIGlzRGlzYWJsZWQgc2hvcnRjdXQgcHJvcGVydHkgdG8gY2hlY2sgZm9yIGRpc2FibGVkIGZpZWxkc2V0IGFuY2VzdG9yc1xuXHRcdFx0XHRyZXR1cm4gZWxlbS5pc0Rpc2FibGVkID09PSBkaXNhYmxlZCB8fFxuXG5cdFx0XHRcdFx0Ly8gV2hlcmUgdGhlcmUgaXMgbm8gaXNEaXNhYmxlZCwgY2hlY2sgbWFudWFsbHlcblx0XHRcdFx0XHQvKiBqc2hpbnQgLVcwMTggKi9cblx0XHRcdFx0XHRlbGVtLmlzRGlzYWJsZWQgIT09ICFkaXNhYmxlZCAmJlxuXHRcdFx0XHRcdGluRGlzYWJsZWRGaWVsZHNldCggZWxlbSApID09PSBkaXNhYmxlZDtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGVsZW0uZGlzYWJsZWQgPT09IGRpc2FibGVkO1xuXG5cdFx0Ly8gVHJ5IHRvIHdpbm5vdyBvdXQgZWxlbWVudHMgdGhhdCBjYW4ndCBiZSBkaXNhYmxlZCBiZWZvcmUgdHJ1c3RpbmcgdGhlIGRpc2FibGVkIHByb3BlcnR5LlxuXHRcdC8vIFNvbWUgdmljdGltcyBnZXQgY2F1Z2h0IGluIG91ciBuZXQgKGxhYmVsLCBsZWdlbmQsIG1lbnUsIHRyYWNrKSwgYnV0IGl0IHNob3VsZG4ndFxuXHRcdC8vIGV2ZW4gZXhpc3Qgb24gdGhlbSwgbGV0IGFsb25lIGhhdmUgYSBib29sZWFuIHZhbHVlLlxuXHRcdH0gZWxzZSBpZiAoIFwibGFiZWxcIiBpbiBlbGVtICkge1xuXHRcdFx0cmV0dXJuIGVsZW0uZGlzYWJsZWQgPT09IGRpc2FibGVkO1xuXHRcdH1cblxuXHRcdC8vIFJlbWFpbmluZyBlbGVtZW50cyBhcmUgbmVpdGhlciA6ZW5hYmxlZCBub3IgOmRpc2FibGVkXG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9O1xufVxuXG4vKipcbiAqIFJldHVybnMgYSBmdW5jdGlvbiB0byB1c2UgaW4gcHNldWRvcyBmb3IgcG9zaXRpb25hbHNcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVBvc2l0aW9uYWxQc2V1ZG8oIGZuICkge1xuXHRyZXR1cm4gbWFya0Z1bmN0aW9uKCBmdW5jdGlvbiggYXJndW1lbnQgKSB7XG5cdFx0YXJndW1lbnQgPSArYXJndW1lbnQ7XG5cdFx0cmV0dXJuIG1hcmtGdW5jdGlvbiggZnVuY3Rpb24oIHNlZWQsIG1hdGNoZXMgKSB7XG5cdFx0XHR2YXIgaixcblx0XHRcdFx0bWF0Y2hJbmRleGVzID0gZm4oIFtdLCBzZWVkLmxlbmd0aCwgYXJndW1lbnQgKSxcblx0XHRcdFx0aSA9IG1hdGNoSW5kZXhlcy5sZW5ndGg7XG5cblx0XHRcdC8vIE1hdGNoIGVsZW1lbnRzIGZvdW5kIGF0IHRoZSBzcGVjaWZpZWQgaW5kZXhlc1xuXHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdGlmICggc2VlZFsgKCBqID0gbWF0Y2hJbmRleGVzWyBpIF0gKSBdICkge1xuXHRcdFx0XHRcdHNlZWRbIGogXSA9ICEoIG1hdGNoZXNbIGogXSA9IHNlZWRbIGogXSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSApO1xuXHR9ICk7XG59XG5cbi8qKlxuICogQ2hlY2tzIGEgbm9kZSBmb3IgdmFsaWRpdHkgYXMgYSBTaXp6bGUgY29udGV4dFxuICogQHBhcmFtIHtFbGVtZW50fE9iamVjdD19IGNvbnRleHRcbiAqIEByZXR1cm5zIHtFbGVtZW50fE9iamVjdHxCb29sZWFufSBUaGUgaW5wdXQgbm9kZSBpZiBhY2NlcHRhYmxlLCBvdGhlcndpc2UgYSBmYWxzeSB2YWx1ZVxuICovXG5mdW5jdGlvbiB0ZXN0Q29udGV4dCggY29udGV4dCApIHtcblx0cmV0dXJuIGNvbnRleHQgJiYgdHlwZW9mIGNvbnRleHQuZ2V0RWxlbWVudHNCeVRhZ05hbWUgIT09IFwidW5kZWZpbmVkXCIgJiYgY29udGV4dDtcbn1cblxuLy8gRXhwb3NlIHN1cHBvcnQgdmFycyBmb3IgY29udmVuaWVuY2VcbnN1cHBvcnQgPSBTaXp6bGUuc3VwcG9ydCA9IHt9O1xuXG4vKipcbiAqIERldGVjdHMgWE1MIG5vZGVzXG4gKiBAcGFyYW0ge0VsZW1lbnR8T2JqZWN0fSBlbGVtIEFuIGVsZW1lbnQgb3IgYSBkb2N1bWVudFxuICogQHJldHVybnMge0Jvb2xlYW59IFRydWUgaWZmIGVsZW0gaXMgYSBub24tSFRNTCBYTUwgbm9kZVxuICovXG5pc1hNTCA9IFNpenpsZS5pc1hNTCA9IGZ1bmN0aW9uKCBlbGVtICkge1xuXHR2YXIgbmFtZXNwYWNlID0gZWxlbSAmJiBlbGVtLm5hbWVzcGFjZVVSSSxcblx0XHRkb2NFbGVtID0gZWxlbSAmJiAoIGVsZW0ub3duZXJEb2N1bWVudCB8fCBlbGVtICkuZG9jdW1lbnRFbGVtZW50O1xuXG5cdC8vIFN1cHBvcnQ6IElFIDw9OFxuXHQvLyBBc3N1bWUgSFRNTCB3aGVuIGRvY3VtZW50RWxlbWVudCBkb2Vzbid0IHlldCBleGlzdCwgc3VjaCBhcyBpbnNpZGUgbG9hZGluZyBpZnJhbWVzXG5cdC8vIGh0dHBzOi8vYnVncy5qcXVlcnkuY29tL3RpY2tldC80ODMzXG5cdHJldHVybiAhcmh0bWwudGVzdCggbmFtZXNwYWNlIHx8IGRvY0VsZW0gJiYgZG9jRWxlbS5ub2RlTmFtZSB8fCBcIkhUTUxcIiApO1xufTtcblxuLyoqXG4gKiBTZXRzIGRvY3VtZW50LXJlbGF0ZWQgdmFyaWFibGVzIG9uY2UgYmFzZWQgb24gdGhlIGN1cnJlbnQgZG9jdW1lbnRcbiAqIEBwYXJhbSB7RWxlbWVudHxPYmplY3R9IFtkb2NdIEFuIGVsZW1lbnQgb3IgZG9jdW1lbnQgb2JqZWN0IHRvIHVzZSB0byBzZXQgdGhlIGRvY3VtZW50XG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjdXJyZW50IGRvY3VtZW50XG4gKi9cbnNldERvY3VtZW50ID0gU2l6emxlLnNldERvY3VtZW50ID0gZnVuY3Rpb24oIG5vZGUgKSB7XG5cdHZhciBoYXNDb21wYXJlLCBzdWJXaW5kb3csXG5cdFx0ZG9jID0gbm9kZSA/IG5vZGUub3duZXJEb2N1bWVudCB8fCBub2RlIDogcHJlZmVycmVkRG9jO1xuXG5cdC8vIFJldHVybiBlYXJseSBpZiBkb2MgaXMgaW52YWxpZCBvciBhbHJlYWR5IHNlbGVjdGVkXG5cdC8vIFN1cHBvcnQ6IElFIDExKywgRWRnZSAxNyAtIDE4K1xuXHQvLyBJRS9FZGdlIHNvbWV0aW1lcyB0aHJvdyBhIFwiUGVybWlzc2lvbiBkZW5pZWRcIiBlcnJvciB3aGVuIHN0cmljdC1jb21wYXJpbmdcblx0Ly8gdHdvIGRvY3VtZW50czsgc2hhbGxvdyBjb21wYXJpc29ucyB3b3JrLlxuXHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXFlcWVxXG5cdGlmICggZG9jID09IGRvY3VtZW50IHx8IGRvYy5ub2RlVHlwZSAhPT0gOSB8fCAhZG9jLmRvY3VtZW50RWxlbWVudCApIHtcblx0XHRyZXR1cm4gZG9jdW1lbnQ7XG5cdH1cblxuXHQvLyBVcGRhdGUgZ2xvYmFsIHZhcmlhYmxlc1xuXHRkb2N1bWVudCA9IGRvYztcblx0ZG9jRWxlbSA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcblx0ZG9jdW1lbnRJc0hUTUwgPSAhaXNYTUwoIGRvY3VtZW50ICk7XG5cblx0Ly8gU3VwcG9ydDogSUUgOSAtIDExKywgRWRnZSAxMiAtIDE4K1xuXHQvLyBBY2Nlc3NpbmcgaWZyYW1lIGRvY3VtZW50cyBhZnRlciB1bmxvYWQgdGhyb3dzIFwicGVybWlzc2lvbiBkZW5pZWRcIiBlcnJvcnMgKGpRdWVyeSAjMTM5MzYpXG5cdC8vIFN1cHBvcnQ6IElFIDExKywgRWRnZSAxNyAtIDE4K1xuXHQvLyBJRS9FZGdlIHNvbWV0aW1lcyB0aHJvdyBhIFwiUGVybWlzc2lvbiBkZW5pZWRcIiBlcnJvciB3aGVuIHN0cmljdC1jb21wYXJpbmdcblx0Ly8gdHdvIGRvY3VtZW50czsgc2hhbGxvdyBjb21wYXJpc29ucyB3b3JrLlxuXHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXFlcWVxXG5cdGlmICggcHJlZmVycmVkRG9jICE9IGRvY3VtZW50ICYmXG5cdFx0KCBzdWJXaW5kb3cgPSBkb2N1bWVudC5kZWZhdWx0VmlldyApICYmIHN1YldpbmRvdy50b3AgIT09IHN1YldpbmRvdyApIHtcblxuXHRcdC8vIFN1cHBvcnQ6IElFIDExLCBFZGdlXG5cdFx0aWYgKCBzdWJXaW5kb3cuYWRkRXZlbnRMaXN0ZW5lciApIHtcblx0XHRcdHN1YldpbmRvdy5hZGRFdmVudExpc3RlbmVyKCBcInVubG9hZFwiLCB1bmxvYWRIYW5kbGVyLCBmYWxzZSApO1xuXG5cdFx0Ly8gU3VwcG9ydDogSUUgOSAtIDEwIG9ubHlcblx0XHR9IGVsc2UgaWYgKCBzdWJXaW5kb3cuYXR0YWNoRXZlbnQgKSB7XG5cdFx0XHRzdWJXaW5kb3cuYXR0YWNoRXZlbnQoIFwib251bmxvYWRcIiwgdW5sb2FkSGFuZGxlciApO1xuXHRcdH1cblx0fVxuXG5cdC8vIFN1cHBvcnQ6IElFIDggLSAxMSssIEVkZ2UgMTIgLSAxOCssIENocm9tZSA8PTE2IC0gMjUgb25seSwgRmlyZWZveCA8PTMuNiAtIDMxIG9ubHksXG5cdC8vIFNhZmFyaSA0IC0gNSBvbmx5LCBPcGVyYSA8PTExLjYgLSAxMi54IG9ubHlcblx0Ly8gSUUvRWRnZSAmIG9sZGVyIGJyb3dzZXJzIGRvbid0IHN1cHBvcnQgdGhlIDpzY29wZSBwc2V1ZG8tY2xhc3MuXG5cdC8vIFN1cHBvcnQ6IFNhZmFyaSA2LjAgb25seVxuXHQvLyBTYWZhcmkgNi4wIHN1cHBvcnRzIDpzY29wZSBidXQgaXQncyBhbiBhbGlhcyBvZiA6cm9vdCB0aGVyZS5cblx0c3VwcG9ydC5zY29wZSA9IGFzc2VydCggZnVuY3Rpb24oIGVsICkge1xuXHRcdGRvY0VsZW0uYXBwZW5kQ2hpbGQoIGVsICkuYXBwZW5kQ2hpbGQoIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiZGl2XCIgKSApO1xuXHRcdHJldHVybiB0eXBlb2YgZWwucXVlcnlTZWxlY3RvckFsbCAhPT0gXCJ1bmRlZmluZWRcIiAmJlxuXHRcdFx0IWVsLnF1ZXJ5U2VsZWN0b3JBbGwoIFwiOnNjb3BlIGZpZWxkc2V0IGRpdlwiICkubGVuZ3RoO1xuXHR9ICk7XG5cblx0LyogQXR0cmlidXRlc1xuXHQtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5cblx0Ly8gU3VwcG9ydDogSUU8OFxuXHQvLyBWZXJpZnkgdGhhdCBnZXRBdHRyaWJ1dGUgcmVhbGx5IHJldHVybnMgYXR0cmlidXRlcyBhbmQgbm90IHByb3BlcnRpZXNcblx0Ly8gKGV4Y2VwdGluZyBJRTggYm9vbGVhbnMpXG5cdHN1cHBvcnQuYXR0cmlidXRlcyA9IGFzc2VydCggZnVuY3Rpb24oIGVsICkge1xuXHRcdGVsLmNsYXNzTmFtZSA9IFwiaVwiO1xuXHRcdHJldHVybiAhZWwuZ2V0QXR0cmlidXRlKCBcImNsYXNzTmFtZVwiICk7XG5cdH0gKTtcblxuXHQvKiBnZXRFbGVtZW50KHMpQnkqXG5cdC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cblxuXHQvLyBDaGVjayBpZiBnZXRFbGVtZW50c0J5VGFnTmFtZShcIipcIikgcmV0dXJucyBvbmx5IGVsZW1lbnRzXG5cdHN1cHBvcnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUgPSBhc3NlcnQoIGZ1bmN0aW9uKCBlbCApIHtcblx0XHRlbC5hcHBlbmRDaGlsZCggZG9jdW1lbnQuY3JlYXRlQ29tbWVudCggXCJcIiApICk7XG5cdFx0cmV0dXJuICFlbC5nZXRFbGVtZW50c0J5VGFnTmFtZSggXCIqXCIgKS5sZW5ndGg7XG5cdH0gKTtcblxuXHQvLyBTdXBwb3J0OiBJRTw5XG5cdHN1cHBvcnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSA9IHJuYXRpdmUudGVzdCggZG9jdW1lbnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSApO1xuXG5cdC8vIFN1cHBvcnQ6IElFPDEwXG5cdC8vIENoZWNrIGlmIGdldEVsZW1lbnRCeUlkIHJldHVybnMgZWxlbWVudHMgYnkgbmFtZVxuXHQvLyBUaGUgYnJva2VuIGdldEVsZW1lbnRCeUlkIG1ldGhvZHMgZG9uJ3QgcGljayB1cCBwcm9ncmFtbWF0aWNhbGx5LXNldCBuYW1lcyxcblx0Ly8gc28gdXNlIGEgcm91bmRhYm91dCBnZXRFbGVtZW50c0J5TmFtZSB0ZXN0XG5cdHN1cHBvcnQuZ2V0QnlJZCA9IGFzc2VydCggZnVuY3Rpb24oIGVsICkge1xuXHRcdGRvY0VsZW0uYXBwZW5kQ2hpbGQoIGVsICkuaWQgPSBleHBhbmRvO1xuXHRcdHJldHVybiAhZG9jdW1lbnQuZ2V0RWxlbWVudHNCeU5hbWUgfHwgIWRvY3VtZW50LmdldEVsZW1lbnRzQnlOYW1lKCBleHBhbmRvICkubGVuZ3RoO1xuXHR9ICk7XG5cblx0Ly8gSUQgZmlsdGVyIGFuZCBmaW5kXG5cdGlmICggc3VwcG9ydC5nZXRCeUlkICkge1xuXHRcdEV4cHIuZmlsdGVyWyBcIklEXCIgXSA9IGZ1bmN0aW9uKCBpZCApIHtcblx0XHRcdHZhciBhdHRySWQgPSBpZC5yZXBsYWNlKCBydW5lc2NhcGUsIGZ1bmVzY2FwZSApO1xuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHRyZXR1cm4gZWxlbS5nZXRBdHRyaWJ1dGUoIFwiaWRcIiApID09PSBhdHRySWQ7XG5cdFx0XHR9O1xuXHRcdH07XG5cdFx0RXhwci5maW5kWyBcIklEXCIgXSA9IGZ1bmN0aW9uKCBpZCwgY29udGV4dCApIHtcblx0XHRcdGlmICggdHlwZW9mIGNvbnRleHQuZ2V0RWxlbWVudEJ5SWQgIT09IFwidW5kZWZpbmVkXCIgJiYgZG9jdW1lbnRJc0hUTUwgKSB7XG5cdFx0XHRcdHZhciBlbGVtID0gY29udGV4dC5nZXRFbGVtZW50QnlJZCggaWQgKTtcblx0XHRcdFx0cmV0dXJuIGVsZW0gPyBbIGVsZW0gXSA6IFtdO1xuXHRcdFx0fVxuXHRcdH07XG5cdH0gZWxzZSB7XG5cdFx0RXhwci5maWx0ZXJbIFwiSURcIiBdID0gIGZ1bmN0aW9uKCBpZCApIHtcblx0XHRcdHZhciBhdHRySWQgPSBpZC5yZXBsYWNlKCBydW5lc2NhcGUsIGZ1bmVzY2FwZSApO1xuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHR2YXIgbm9kZSA9IHR5cGVvZiBlbGVtLmdldEF0dHJpYnV0ZU5vZGUgIT09IFwidW5kZWZpbmVkXCIgJiZcblx0XHRcdFx0XHRlbGVtLmdldEF0dHJpYnV0ZU5vZGUoIFwiaWRcIiApO1xuXHRcdFx0XHRyZXR1cm4gbm9kZSAmJiBub2RlLnZhbHVlID09PSBhdHRySWQ7XG5cdFx0XHR9O1xuXHRcdH07XG5cblx0XHQvLyBTdXBwb3J0OiBJRSA2IC0gNyBvbmx5XG5cdFx0Ly8gZ2V0RWxlbWVudEJ5SWQgaXMgbm90IHJlbGlhYmxlIGFzIGEgZmluZCBzaG9ydGN1dFxuXHRcdEV4cHIuZmluZFsgXCJJRFwiIF0gPSBmdW5jdGlvbiggaWQsIGNvbnRleHQgKSB7XG5cdFx0XHRpZiAoIHR5cGVvZiBjb250ZXh0LmdldEVsZW1lbnRCeUlkICE9PSBcInVuZGVmaW5lZFwiICYmIGRvY3VtZW50SXNIVE1MICkge1xuXHRcdFx0XHR2YXIgbm9kZSwgaSwgZWxlbXMsXG5cdFx0XHRcdFx0ZWxlbSA9IGNvbnRleHQuZ2V0RWxlbWVudEJ5SWQoIGlkICk7XG5cblx0XHRcdFx0aWYgKCBlbGVtICkge1xuXG5cdFx0XHRcdFx0Ly8gVmVyaWZ5IHRoZSBpZCBhdHRyaWJ1dGVcblx0XHRcdFx0XHRub2RlID0gZWxlbS5nZXRBdHRyaWJ1dGVOb2RlKCBcImlkXCIgKTtcblx0XHRcdFx0XHRpZiAoIG5vZGUgJiYgbm9kZS52YWx1ZSA9PT0gaWQgKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gWyBlbGVtIF07XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gRmFsbCBiYWNrIG9uIGdldEVsZW1lbnRzQnlOYW1lXG5cdFx0XHRcdFx0ZWxlbXMgPSBjb250ZXh0LmdldEVsZW1lbnRzQnlOYW1lKCBpZCApO1xuXHRcdFx0XHRcdGkgPSAwO1xuXHRcdFx0XHRcdHdoaWxlICggKCBlbGVtID0gZWxlbXNbIGkrKyBdICkgKSB7XG5cdFx0XHRcdFx0XHRub2RlID0gZWxlbS5nZXRBdHRyaWJ1dGVOb2RlKCBcImlkXCIgKTtcblx0XHRcdFx0XHRcdGlmICggbm9kZSAmJiBub2RlLnZhbHVlID09PSBpZCApIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIFsgZWxlbSBdO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiBbXTtcblx0XHRcdH1cblx0XHR9O1xuXHR9XG5cblx0Ly8gVGFnXG5cdEV4cHIuZmluZFsgXCJUQUdcIiBdID0gc3VwcG9ydC5nZXRFbGVtZW50c0J5VGFnTmFtZSA/XG5cdFx0ZnVuY3Rpb24oIHRhZywgY29udGV4dCApIHtcblx0XHRcdGlmICggdHlwZW9mIGNvbnRleHQuZ2V0RWxlbWVudHNCeVRhZ05hbWUgIT09IFwidW5kZWZpbmVkXCIgKSB7XG5cdFx0XHRcdHJldHVybiBjb250ZXh0LmdldEVsZW1lbnRzQnlUYWdOYW1lKCB0YWcgKTtcblxuXHRcdFx0Ly8gRG9jdW1lbnRGcmFnbWVudCBub2RlcyBkb24ndCBoYXZlIGdFQlROXG5cdFx0XHR9IGVsc2UgaWYgKCBzdXBwb3J0LnFzYSApIHtcblx0XHRcdFx0cmV0dXJuIGNvbnRleHQucXVlcnlTZWxlY3RvckFsbCggdGFnICk7XG5cdFx0XHR9XG5cdFx0fSA6XG5cblx0XHRmdW5jdGlvbiggdGFnLCBjb250ZXh0ICkge1xuXHRcdFx0dmFyIGVsZW0sXG5cdFx0XHRcdHRtcCA9IFtdLFxuXHRcdFx0XHRpID0gMCxcblxuXHRcdFx0XHQvLyBCeSBoYXBweSBjb2luY2lkZW5jZSwgYSAoYnJva2VuKSBnRUJUTiBhcHBlYXJzIG9uIERvY3VtZW50RnJhZ21lbnQgbm9kZXMgdG9vXG5cdFx0XHRcdHJlc3VsdHMgPSBjb250ZXh0LmdldEVsZW1lbnRzQnlUYWdOYW1lKCB0YWcgKTtcblxuXHRcdFx0Ly8gRmlsdGVyIG91dCBwb3NzaWJsZSBjb21tZW50c1xuXHRcdFx0aWYgKCB0YWcgPT09IFwiKlwiICkge1xuXHRcdFx0XHR3aGlsZSAoICggZWxlbSA9IHJlc3VsdHNbIGkrKyBdICkgKSB7XG5cdFx0XHRcdFx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSAxICkge1xuXHRcdFx0XHRcdFx0dG1wLnB1c2goIGVsZW0gKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gdG1wO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHJlc3VsdHM7XG5cdFx0fTtcblxuXHQvLyBDbGFzc1xuXHRFeHByLmZpbmRbIFwiQ0xBU1NcIiBdID0gc3VwcG9ydC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lICYmIGZ1bmN0aW9uKCBjbGFzc05hbWUsIGNvbnRleHQgKSB7XG5cdFx0aWYgKCB0eXBlb2YgY29udGV4dC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lICE9PSBcInVuZGVmaW5lZFwiICYmIGRvY3VtZW50SXNIVE1MICkge1xuXHRcdFx0cmV0dXJuIGNvbnRleHQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSggY2xhc3NOYW1lICk7XG5cdFx0fVxuXHR9O1xuXG5cdC8qIFFTQS9tYXRjaGVzU2VsZWN0b3Jcblx0LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuXG5cdC8vIFFTQSBhbmQgbWF0Y2hlc1NlbGVjdG9yIHN1cHBvcnRcblxuXHQvLyBtYXRjaGVzU2VsZWN0b3IoOmFjdGl2ZSkgcmVwb3J0cyBmYWxzZSB3aGVuIHRydWUgKElFOS9PcGVyYSAxMS41KVxuXHRyYnVnZ3lNYXRjaGVzID0gW107XG5cblx0Ly8gcVNhKDpmb2N1cykgcmVwb3J0cyBmYWxzZSB3aGVuIHRydWUgKENocm9tZSAyMSlcblx0Ly8gV2UgYWxsb3cgdGhpcyBiZWNhdXNlIG9mIGEgYnVnIGluIElFOC85IHRoYXQgdGhyb3dzIGFuIGVycm9yXG5cdC8vIHdoZW5ldmVyIGBkb2N1bWVudC5hY3RpdmVFbGVtZW50YCBpcyBhY2Nlc3NlZCBvbiBhbiBpZnJhbWVcblx0Ly8gU28sIHdlIGFsbG93IDpmb2N1cyB0byBwYXNzIHRocm91Z2ggUVNBIGFsbCB0aGUgdGltZSB0byBhdm9pZCB0aGUgSUUgZXJyb3Jcblx0Ly8gU2VlIGh0dHBzOi8vYnVncy5qcXVlcnkuY29tL3RpY2tldC8xMzM3OFxuXHRyYnVnZ3lRU0EgPSBbXTtcblxuXHRpZiAoICggc3VwcG9ydC5xc2EgPSBybmF0aXZlLnRlc3QoIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwgKSApICkge1xuXG5cdFx0Ly8gQnVpbGQgUVNBIHJlZ2V4XG5cdFx0Ly8gUmVnZXggc3RyYXRlZ3kgYWRvcHRlZCBmcm9tIERpZWdvIFBlcmluaVxuXHRcdGFzc2VydCggZnVuY3Rpb24oIGVsICkge1xuXG5cdFx0XHR2YXIgaW5wdXQ7XG5cblx0XHRcdC8vIFNlbGVjdCBpcyBzZXQgdG8gZW1wdHkgc3RyaW5nIG9uIHB1cnBvc2Vcblx0XHRcdC8vIFRoaXMgaXMgdG8gdGVzdCBJRSdzIHRyZWF0bWVudCBvZiBub3QgZXhwbGljaXRseVxuXHRcdFx0Ly8gc2V0dGluZyBhIGJvb2xlYW4gY29udGVudCBhdHRyaWJ1dGUsXG5cdFx0XHQvLyBzaW5jZSBpdHMgcHJlc2VuY2Ugc2hvdWxkIGJlIGVub3VnaFxuXHRcdFx0Ly8gaHR0cHM6Ly9idWdzLmpxdWVyeS5jb20vdGlja2V0LzEyMzU5XG5cdFx0XHRkb2NFbGVtLmFwcGVuZENoaWxkKCBlbCApLmlubmVySFRNTCA9IFwiPGEgaWQ9J1wiICsgZXhwYW5kbyArIFwiJz48L2E+XCIgK1xuXHRcdFx0XHRcIjxzZWxlY3QgaWQ9J1wiICsgZXhwYW5kbyArIFwiLVxcclxcXFwnIG1zYWxsb3djYXB0dXJlPScnPlwiICtcblx0XHRcdFx0XCI8b3B0aW9uIHNlbGVjdGVkPScnPjwvb3B0aW9uPjwvc2VsZWN0PlwiO1xuXG5cdFx0XHQvLyBTdXBwb3J0OiBJRTgsIE9wZXJhIDExLTEyLjE2XG5cdFx0XHQvLyBOb3RoaW5nIHNob3VsZCBiZSBzZWxlY3RlZCB3aGVuIGVtcHR5IHN0cmluZ3MgZm9sbG93IF49IG9yICQ9IG9yICo9XG5cdFx0XHQvLyBUaGUgdGVzdCBhdHRyaWJ1dGUgbXVzdCBiZSB1bmtub3duIGluIE9wZXJhIGJ1dCBcInNhZmVcIiBmb3IgV2luUlRcblx0XHRcdC8vIGh0dHBzOi8vbXNkbi5taWNyb3NvZnQuY29tL2VuLXVzL2xpYnJhcnkvaWUvaGg0NjUzODguYXNweCNhdHRyaWJ1dGVfc2VjdGlvblxuXHRcdFx0aWYgKCBlbC5xdWVyeVNlbGVjdG9yQWxsKCBcIlttc2FsbG93Y2FwdHVyZV49JyddXCIgKS5sZW5ndGggKSB7XG5cdFx0XHRcdHJidWdneVFTQS5wdXNoKCBcIlsqXiRdPVwiICsgd2hpdGVzcGFjZSArIFwiKig/OicnfFxcXCJcXFwiKVwiICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFN1cHBvcnQ6IElFOFxuXHRcdFx0Ly8gQm9vbGVhbiBhdHRyaWJ1dGVzIGFuZCBcInZhbHVlXCIgYXJlIG5vdCB0cmVhdGVkIGNvcnJlY3RseVxuXHRcdFx0aWYgKCAhZWwucXVlcnlTZWxlY3RvckFsbCggXCJbc2VsZWN0ZWRdXCIgKS5sZW5ndGggKSB7XG5cdFx0XHRcdHJidWdneVFTQS5wdXNoKCBcIlxcXFxbXCIgKyB3aGl0ZXNwYWNlICsgXCIqKD86dmFsdWV8XCIgKyBib29sZWFucyArIFwiKVwiICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFN1cHBvcnQ6IENocm9tZTwyOSwgQW5kcm9pZDw0LjQsIFNhZmFyaTw3LjArLCBpT1M8Ny4wKywgUGhhbnRvbUpTPDEuOS44K1xuXHRcdFx0aWYgKCAhZWwucXVlcnlTZWxlY3RvckFsbCggXCJbaWR+PVwiICsgZXhwYW5kbyArIFwiLV1cIiApLmxlbmd0aCApIHtcblx0XHRcdFx0cmJ1Z2d5UVNBLnB1c2goIFwifj1cIiApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTdXBwb3J0OiBJRSAxMSssIEVkZ2UgMTUgLSAxOCtcblx0XHRcdC8vIElFIDExL0VkZ2UgZG9uJ3QgZmluZCBlbGVtZW50cyBvbiBhIGBbbmFtZT0nJ11gIHF1ZXJ5IGluIHNvbWUgY2FzZXMuXG5cdFx0XHQvLyBBZGRpbmcgYSB0ZW1wb3JhcnkgYXR0cmlidXRlIHRvIHRoZSBkb2N1bWVudCBiZWZvcmUgdGhlIHNlbGVjdGlvbiB3b3Jrc1xuXHRcdFx0Ly8gYXJvdW5kIHRoZSBpc3N1ZS5cblx0XHRcdC8vIEludGVyZXN0aW5nbHksIElFIDEwICYgb2xkZXIgZG9uJ3Qgc2VlbSB0byBoYXZlIHRoZSBpc3N1ZS5cblx0XHRcdGlucHV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJpbnB1dFwiICk7XG5cdFx0XHRpbnB1dC5zZXRBdHRyaWJ1dGUoIFwibmFtZVwiLCBcIlwiICk7XG5cdFx0XHRlbC5hcHBlbmRDaGlsZCggaW5wdXQgKTtcblx0XHRcdGlmICggIWVsLnF1ZXJ5U2VsZWN0b3JBbGwoIFwiW25hbWU9JyddXCIgKS5sZW5ndGggKSB7XG5cdFx0XHRcdHJidWdneVFTQS5wdXNoKCBcIlxcXFxbXCIgKyB3aGl0ZXNwYWNlICsgXCIqbmFtZVwiICsgd2hpdGVzcGFjZSArIFwiKj1cIiArXG5cdFx0XHRcdFx0d2hpdGVzcGFjZSArIFwiKig/OicnfFxcXCJcXFwiKVwiICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFdlYmtpdC9PcGVyYSAtIDpjaGVja2VkIHNob3VsZCByZXR1cm4gc2VsZWN0ZWQgb3B0aW9uIGVsZW1lbnRzXG5cdFx0XHQvLyBodHRwOi8vd3d3LnczLm9yZy9UUi8yMDExL1JFQy1jc3MzLXNlbGVjdG9ycy0yMDExMDkyOS8jY2hlY2tlZFxuXHRcdFx0Ly8gSUU4IHRocm93cyBlcnJvciBoZXJlIGFuZCB3aWxsIG5vdCBzZWUgbGF0ZXIgdGVzdHNcblx0XHRcdGlmICggIWVsLnF1ZXJ5U2VsZWN0b3JBbGwoIFwiOmNoZWNrZWRcIiApLmxlbmd0aCApIHtcblx0XHRcdFx0cmJ1Z2d5UVNBLnB1c2goIFwiOmNoZWNrZWRcIiApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTdXBwb3J0OiBTYWZhcmkgOCssIGlPUyA4K1xuXHRcdFx0Ly8gaHR0cHM6Ly9idWdzLndlYmtpdC5vcmcvc2hvd19idWcuY2dpP2lkPTEzNjg1MVxuXHRcdFx0Ly8gSW4tcGFnZSBgc2VsZWN0b3IjaWQgc2libGluZy1jb21iaW5hdG9yIHNlbGVjdG9yYCBmYWlsc1xuXHRcdFx0aWYgKCAhZWwucXVlcnlTZWxlY3RvckFsbCggXCJhI1wiICsgZXhwYW5kbyArIFwiKypcIiApLmxlbmd0aCApIHtcblx0XHRcdFx0cmJ1Z2d5UVNBLnB1c2goIFwiLiMuK1srfl1cIiApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTdXBwb3J0OiBGaXJlZm94IDw9My42IC0gNSBvbmx5XG5cdFx0XHQvLyBPbGQgRmlyZWZveCBkb2Vzbid0IHRocm93IG9uIGEgYmFkbHktZXNjYXBlZCBpZGVudGlmaWVyLlxuXHRcdFx0ZWwucXVlcnlTZWxlY3RvckFsbCggXCJcXFxcXFxmXCIgKTtcblx0XHRcdHJidWdneVFTQS5wdXNoKCBcIltcXFxcclxcXFxuXFxcXGZdXCIgKTtcblx0XHR9ICk7XG5cblx0XHRhc3NlcnQoIGZ1bmN0aW9uKCBlbCApIHtcblx0XHRcdGVsLmlubmVySFRNTCA9IFwiPGEgaHJlZj0nJyBkaXNhYmxlZD0nZGlzYWJsZWQnPjwvYT5cIiArXG5cdFx0XHRcdFwiPHNlbGVjdCBkaXNhYmxlZD0nZGlzYWJsZWQnPjxvcHRpb24vPjwvc2VsZWN0PlwiO1xuXG5cdFx0XHQvLyBTdXBwb3J0OiBXaW5kb3dzIDggTmF0aXZlIEFwcHNcblx0XHRcdC8vIFRoZSB0eXBlIGFuZCBuYW1lIGF0dHJpYnV0ZXMgYXJlIHJlc3RyaWN0ZWQgZHVyaW5nIC5pbm5lckhUTUwgYXNzaWdubWVudFxuXHRcdFx0dmFyIGlucHV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJpbnB1dFwiICk7XG5cdFx0XHRpbnB1dC5zZXRBdHRyaWJ1dGUoIFwidHlwZVwiLCBcImhpZGRlblwiICk7XG5cdFx0XHRlbC5hcHBlbmRDaGlsZCggaW5wdXQgKS5zZXRBdHRyaWJ1dGUoIFwibmFtZVwiLCBcIkRcIiApO1xuXG5cdFx0XHQvLyBTdXBwb3J0OiBJRThcblx0XHRcdC8vIEVuZm9yY2UgY2FzZS1zZW5zaXRpdml0eSBvZiBuYW1lIGF0dHJpYnV0ZVxuXHRcdFx0aWYgKCBlbC5xdWVyeVNlbGVjdG9yQWxsKCBcIltuYW1lPWRdXCIgKS5sZW5ndGggKSB7XG5cdFx0XHRcdHJidWdneVFTQS5wdXNoKCBcIm5hbWVcIiArIHdoaXRlc3BhY2UgKyBcIipbKl4kfCF+XT89XCIgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gRkYgMy41IC0gOmVuYWJsZWQvOmRpc2FibGVkIGFuZCBoaWRkZW4gZWxlbWVudHMgKGhpZGRlbiBlbGVtZW50cyBhcmUgc3RpbGwgZW5hYmxlZClcblx0XHRcdC8vIElFOCB0aHJvd3MgZXJyb3IgaGVyZSBhbmQgd2lsbCBub3Qgc2VlIGxhdGVyIHRlc3RzXG5cdFx0XHRpZiAoIGVsLnF1ZXJ5U2VsZWN0b3JBbGwoIFwiOmVuYWJsZWRcIiApLmxlbmd0aCAhPT0gMiApIHtcblx0XHRcdFx0cmJ1Z2d5UVNBLnB1c2goIFwiOmVuYWJsZWRcIiwgXCI6ZGlzYWJsZWRcIiApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTdXBwb3J0OiBJRTktMTErXG5cdFx0XHQvLyBJRSdzIDpkaXNhYmxlZCBzZWxlY3RvciBkb2VzIG5vdCBwaWNrIHVwIHRoZSBjaGlsZHJlbiBvZiBkaXNhYmxlZCBmaWVsZHNldHNcblx0XHRcdGRvY0VsZW0uYXBwZW5kQ2hpbGQoIGVsICkuZGlzYWJsZWQgPSB0cnVlO1xuXHRcdFx0aWYgKCBlbC5xdWVyeVNlbGVjdG9yQWxsKCBcIjpkaXNhYmxlZFwiICkubGVuZ3RoICE9PSAyICkge1xuXHRcdFx0XHRyYnVnZ3lRU0EucHVzaCggXCI6ZW5hYmxlZFwiLCBcIjpkaXNhYmxlZFwiICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFN1cHBvcnQ6IE9wZXJhIDEwIC0gMTEgb25seVxuXHRcdFx0Ly8gT3BlcmEgMTAtMTEgZG9lcyBub3QgdGhyb3cgb24gcG9zdC1jb21tYSBpbnZhbGlkIHBzZXVkb3Ncblx0XHRcdGVsLnF1ZXJ5U2VsZWN0b3JBbGwoIFwiKiw6eFwiICk7XG5cdFx0XHRyYnVnZ3lRU0EucHVzaCggXCIsLio6XCIgKTtcblx0XHR9ICk7XG5cdH1cblxuXHRpZiAoICggc3VwcG9ydC5tYXRjaGVzU2VsZWN0b3IgPSBybmF0aXZlLnRlc3QoICggbWF0Y2hlcyA9IGRvY0VsZW0ubWF0Y2hlcyB8fFxuXHRcdGRvY0VsZW0ud2Via2l0TWF0Y2hlc1NlbGVjdG9yIHx8XG5cdFx0ZG9jRWxlbS5tb3pNYXRjaGVzU2VsZWN0b3IgfHxcblx0XHRkb2NFbGVtLm9NYXRjaGVzU2VsZWN0b3IgfHxcblx0XHRkb2NFbGVtLm1zTWF0Y2hlc1NlbGVjdG9yICkgKSApICkge1xuXG5cdFx0YXNzZXJ0KCBmdW5jdGlvbiggZWwgKSB7XG5cblx0XHRcdC8vIENoZWNrIHRvIHNlZSBpZiBpdCdzIHBvc3NpYmxlIHRvIGRvIG1hdGNoZXNTZWxlY3RvclxuXHRcdFx0Ly8gb24gYSBkaXNjb25uZWN0ZWQgbm9kZSAoSUUgOSlcblx0XHRcdHN1cHBvcnQuZGlzY29ubmVjdGVkTWF0Y2ggPSBtYXRjaGVzLmNhbGwoIGVsLCBcIipcIiApO1xuXG5cdFx0XHQvLyBUaGlzIHNob3VsZCBmYWlsIHdpdGggYW4gZXhjZXB0aW9uXG5cdFx0XHQvLyBHZWNrbyBkb2VzIG5vdCBlcnJvciwgcmV0dXJucyBmYWxzZSBpbnN0ZWFkXG5cdFx0XHRtYXRjaGVzLmNhbGwoIGVsLCBcIltzIT0nJ106eFwiICk7XG5cdFx0XHRyYnVnZ3lNYXRjaGVzLnB1c2goIFwiIT1cIiwgcHNldWRvcyApO1xuXHRcdH0gKTtcblx0fVxuXG5cdHJidWdneVFTQSA9IHJidWdneVFTQS5sZW5ndGggJiYgbmV3IFJlZ0V4cCggcmJ1Z2d5UVNBLmpvaW4oIFwifFwiICkgKTtcblx0cmJ1Z2d5TWF0Y2hlcyA9IHJidWdneU1hdGNoZXMubGVuZ3RoICYmIG5ldyBSZWdFeHAoIHJidWdneU1hdGNoZXMuam9pbiggXCJ8XCIgKSApO1xuXG5cdC8qIENvbnRhaW5zXG5cdC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cblx0aGFzQ29tcGFyZSA9IHJuYXRpdmUudGVzdCggZG9jRWxlbS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbiApO1xuXG5cdC8vIEVsZW1lbnQgY29udGFpbnMgYW5vdGhlclxuXHQvLyBQdXJwb3NlZnVsbHkgc2VsZi1leGNsdXNpdmVcblx0Ly8gQXMgaW4sIGFuIGVsZW1lbnQgZG9lcyBub3QgY29udGFpbiBpdHNlbGZcblx0Y29udGFpbnMgPSBoYXNDb21wYXJlIHx8IHJuYXRpdmUudGVzdCggZG9jRWxlbS5jb250YWlucyApID9cblx0XHRmdW5jdGlvbiggYSwgYiApIHtcblx0XHRcdHZhciBhZG93biA9IGEubm9kZVR5cGUgPT09IDkgPyBhLmRvY3VtZW50RWxlbWVudCA6IGEsXG5cdFx0XHRcdGJ1cCA9IGIgJiYgYi5wYXJlbnROb2RlO1xuXHRcdFx0cmV0dXJuIGEgPT09IGJ1cCB8fCAhISggYnVwICYmIGJ1cC5ub2RlVHlwZSA9PT0gMSAmJiAoXG5cdFx0XHRcdGFkb3duLmNvbnRhaW5zID9cblx0XHRcdFx0XHRhZG93bi5jb250YWlucyggYnVwICkgOlxuXHRcdFx0XHRcdGEuY29tcGFyZURvY3VtZW50UG9zaXRpb24gJiYgYS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbiggYnVwICkgJiAxNlxuXHRcdFx0KSApO1xuXHRcdH0gOlxuXHRcdGZ1bmN0aW9uKCBhLCBiICkge1xuXHRcdFx0aWYgKCBiICkge1xuXHRcdFx0XHR3aGlsZSAoICggYiA9IGIucGFyZW50Tm9kZSApICkge1xuXHRcdFx0XHRcdGlmICggYiA9PT0gYSApIHtcblx0XHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH07XG5cblx0LyogU29ydGluZ1xuXHQtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5cblx0Ly8gRG9jdW1lbnQgb3JkZXIgc29ydGluZ1xuXHRzb3J0T3JkZXIgPSBoYXNDb21wYXJlID9cblx0ZnVuY3Rpb24oIGEsIGIgKSB7XG5cblx0XHQvLyBGbGFnIGZvciBkdXBsaWNhdGUgcmVtb3ZhbFxuXHRcdGlmICggYSA9PT0gYiApIHtcblx0XHRcdGhhc0R1cGxpY2F0ZSA9IHRydWU7XG5cdFx0XHRyZXR1cm4gMDtcblx0XHR9XG5cblx0XHQvLyBTb3J0IG9uIG1ldGhvZCBleGlzdGVuY2UgaWYgb25seSBvbmUgaW5wdXQgaGFzIGNvbXBhcmVEb2N1bWVudFBvc2l0aW9uXG5cdFx0dmFyIGNvbXBhcmUgPSAhYS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbiAtICFiLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uO1xuXHRcdGlmICggY29tcGFyZSApIHtcblx0XHRcdHJldHVybiBjb21wYXJlO1xuXHRcdH1cblxuXHRcdC8vIENhbGN1bGF0ZSBwb3NpdGlvbiBpZiBib3RoIGlucHV0cyBiZWxvbmcgdG8gdGhlIHNhbWUgZG9jdW1lbnRcblx0XHQvLyBTdXBwb3J0OiBJRSAxMSssIEVkZ2UgMTcgLSAxOCtcblx0XHQvLyBJRS9FZGdlIHNvbWV0aW1lcyB0aHJvdyBhIFwiUGVybWlzc2lvbiBkZW5pZWRcIiBlcnJvciB3aGVuIHN0cmljdC1jb21wYXJpbmdcblx0XHQvLyB0d28gZG9jdW1lbnRzOyBzaGFsbG93IGNvbXBhcmlzb25zIHdvcmsuXG5cdFx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVxZXFlcVxuXHRcdGNvbXBhcmUgPSAoIGEub3duZXJEb2N1bWVudCB8fCBhICkgPT0gKCBiLm93bmVyRG9jdW1lbnQgfHwgYiApID9cblx0XHRcdGEuY29tcGFyZURvY3VtZW50UG9zaXRpb24oIGIgKSA6XG5cblx0XHRcdC8vIE90aGVyd2lzZSB3ZSBrbm93IHRoZXkgYXJlIGRpc2Nvbm5lY3RlZFxuXHRcdFx0MTtcblxuXHRcdC8vIERpc2Nvbm5lY3RlZCBub2Rlc1xuXHRcdGlmICggY29tcGFyZSAmIDEgfHxcblx0XHRcdCggIXN1cHBvcnQuc29ydERldGFjaGVkICYmIGIuY29tcGFyZURvY3VtZW50UG9zaXRpb24oIGEgKSA9PT0gY29tcGFyZSApICkge1xuXG5cdFx0XHQvLyBDaG9vc2UgdGhlIGZpcnN0IGVsZW1lbnQgdGhhdCBpcyByZWxhdGVkIHRvIG91ciBwcmVmZXJyZWQgZG9jdW1lbnRcblx0XHRcdC8vIFN1cHBvcnQ6IElFIDExKywgRWRnZSAxNyAtIDE4K1xuXHRcdFx0Ly8gSUUvRWRnZSBzb21ldGltZXMgdGhyb3cgYSBcIlBlcm1pc3Npb24gZGVuaWVkXCIgZXJyb3Igd2hlbiBzdHJpY3QtY29tcGFyaW5nXG5cdFx0XHQvLyB0d28gZG9jdW1lbnRzOyBzaGFsbG93IGNvbXBhcmlzb25zIHdvcmsuXG5cdFx0XHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXFlcWVxXG5cdFx0XHRpZiAoIGEgPT0gZG9jdW1lbnQgfHwgYS5vd25lckRvY3VtZW50ID09IHByZWZlcnJlZERvYyAmJlxuXHRcdFx0XHRjb250YWlucyggcHJlZmVycmVkRG9jLCBhICkgKSB7XG5cdFx0XHRcdHJldHVybiAtMTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gU3VwcG9ydDogSUUgMTErLCBFZGdlIDE3IC0gMTgrXG5cdFx0XHQvLyBJRS9FZGdlIHNvbWV0aW1lcyB0aHJvdyBhIFwiUGVybWlzc2lvbiBkZW5pZWRcIiBlcnJvciB3aGVuIHN0cmljdC1jb21wYXJpbmdcblx0XHRcdC8vIHR3byBkb2N1bWVudHM7IHNoYWxsb3cgY29tcGFyaXNvbnMgd29yay5cblx0XHRcdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcWVxZXFcblx0XHRcdGlmICggYiA9PSBkb2N1bWVudCB8fCBiLm93bmVyRG9jdW1lbnQgPT0gcHJlZmVycmVkRG9jICYmXG5cdFx0XHRcdGNvbnRhaW5zKCBwcmVmZXJyZWREb2MsIGIgKSApIHtcblx0XHRcdFx0cmV0dXJuIDE7XG5cdFx0XHR9XG5cblx0XHRcdC8vIE1haW50YWluIG9yaWdpbmFsIG9yZGVyXG5cdFx0XHRyZXR1cm4gc29ydElucHV0ID9cblx0XHRcdFx0KCBpbmRleE9mKCBzb3J0SW5wdXQsIGEgKSAtIGluZGV4T2YoIHNvcnRJbnB1dCwgYiApICkgOlxuXHRcdFx0XHQwO1xuXHRcdH1cblxuXHRcdHJldHVybiBjb21wYXJlICYgNCA/IC0xIDogMTtcblx0fSA6XG5cdGZ1bmN0aW9uKCBhLCBiICkge1xuXG5cdFx0Ly8gRXhpdCBlYXJseSBpZiB0aGUgbm9kZXMgYXJlIGlkZW50aWNhbFxuXHRcdGlmICggYSA9PT0gYiApIHtcblx0XHRcdGhhc0R1cGxpY2F0ZSA9IHRydWU7XG5cdFx0XHRyZXR1cm4gMDtcblx0XHR9XG5cblx0XHR2YXIgY3VyLFxuXHRcdFx0aSA9IDAsXG5cdFx0XHRhdXAgPSBhLnBhcmVudE5vZGUsXG5cdFx0XHRidXAgPSBiLnBhcmVudE5vZGUsXG5cdFx0XHRhcCA9IFsgYSBdLFxuXHRcdFx0YnAgPSBbIGIgXTtcblxuXHRcdC8vIFBhcmVudGxlc3Mgbm9kZXMgYXJlIGVpdGhlciBkb2N1bWVudHMgb3IgZGlzY29ubmVjdGVkXG5cdFx0aWYgKCAhYXVwIHx8ICFidXAgKSB7XG5cblx0XHRcdC8vIFN1cHBvcnQ6IElFIDExKywgRWRnZSAxNyAtIDE4K1xuXHRcdFx0Ly8gSUUvRWRnZSBzb21ldGltZXMgdGhyb3cgYSBcIlBlcm1pc3Npb24gZGVuaWVkXCIgZXJyb3Igd2hlbiBzdHJpY3QtY29tcGFyaW5nXG5cdFx0XHQvLyB0d28gZG9jdW1lbnRzOyBzaGFsbG93IGNvbXBhcmlzb25zIHdvcmsuXG5cdFx0XHQvKiBlc2xpbnQtZGlzYWJsZSBlcWVxZXEgKi9cblx0XHRcdHJldHVybiBhID09IGRvY3VtZW50ID8gLTEgOlxuXHRcdFx0XHRiID09IGRvY3VtZW50ID8gMSA6XG5cdFx0XHRcdC8qIGVzbGludC1lbmFibGUgZXFlcWVxICovXG5cdFx0XHRcdGF1cCA/IC0xIDpcblx0XHRcdFx0YnVwID8gMSA6XG5cdFx0XHRcdHNvcnRJbnB1dCA/XG5cdFx0XHRcdCggaW5kZXhPZiggc29ydElucHV0LCBhICkgLSBpbmRleE9mKCBzb3J0SW5wdXQsIGIgKSApIDpcblx0XHRcdFx0MDtcblxuXHRcdC8vIElmIHRoZSBub2RlcyBhcmUgc2libGluZ3MsIHdlIGNhbiBkbyBhIHF1aWNrIGNoZWNrXG5cdFx0fSBlbHNlIGlmICggYXVwID09PSBidXAgKSB7XG5cdFx0XHRyZXR1cm4gc2libGluZ0NoZWNrKCBhLCBiICk7XG5cdFx0fVxuXG5cdFx0Ly8gT3RoZXJ3aXNlIHdlIG5lZWQgZnVsbCBsaXN0cyBvZiB0aGVpciBhbmNlc3RvcnMgZm9yIGNvbXBhcmlzb25cblx0XHRjdXIgPSBhO1xuXHRcdHdoaWxlICggKCBjdXIgPSBjdXIucGFyZW50Tm9kZSApICkge1xuXHRcdFx0YXAudW5zaGlmdCggY3VyICk7XG5cdFx0fVxuXHRcdGN1ciA9IGI7XG5cdFx0d2hpbGUgKCAoIGN1ciA9IGN1ci5wYXJlbnROb2RlICkgKSB7XG5cdFx0XHRicC51bnNoaWZ0KCBjdXIgKTtcblx0XHR9XG5cblx0XHQvLyBXYWxrIGRvd24gdGhlIHRyZWUgbG9va2luZyBmb3IgYSBkaXNjcmVwYW5jeVxuXHRcdHdoaWxlICggYXBbIGkgXSA9PT0gYnBbIGkgXSApIHtcblx0XHRcdGkrKztcblx0XHR9XG5cblx0XHRyZXR1cm4gaSA/XG5cblx0XHRcdC8vIERvIGEgc2libGluZyBjaGVjayBpZiB0aGUgbm9kZXMgaGF2ZSBhIGNvbW1vbiBhbmNlc3RvclxuXHRcdFx0c2libGluZ0NoZWNrKCBhcFsgaSBdLCBicFsgaSBdICkgOlxuXG5cdFx0XHQvLyBPdGhlcndpc2Ugbm9kZXMgaW4gb3VyIGRvY3VtZW50IHNvcnQgZmlyc3Rcblx0XHRcdC8vIFN1cHBvcnQ6IElFIDExKywgRWRnZSAxNyAtIDE4K1xuXHRcdFx0Ly8gSUUvRWRnZSBzb21ldGltZXMgdGhyb3cgYSBcIlBlcm1pc3Npb24gZGVuaWVkXCIgZXJyb3Igd2hlbiBzdHJpY3QtY29tcGFyaW5nXG5cdFx0XHQvLyB0d28gZG9jdW1lbnRzOyBzaGFsbG93IGNvbXBhcmlzb25zIHdvcmsuXG5cdFx0XHQvKiBlc2xpbnQtZGlzYWJsZSBlcWVxZXEgKi9cblx0XHRcdGFwWyBpIF0gPT0gcHJlZmVycmVkRG9jID8gLTEgOlxuXHRcdFx0YnBbIGkgXSA9PSBwcmVmZXJyZWREb2MgPyAxIDpcblx0XHRcdC8qIGVzbGludC1lbmFibGUgZXFlcWVxICovXG5cdFx0XHQwO1xuXHR9O1xuXG5cdHJldHVybiBkb2N1bWVudDtcbn07XG5cblNpenpsZS5tYXRjaGVzID0gZnVuY3Rpb24oIGV4cHIsIGVsZW1lbnRzICkge1xuXHRyZXR1cm4gU2l6emxlKCBleHByLCBudWxsLCBudWxsLCBlbGVtZW50cyApO1xufTtcblxuU2l6emxlLm1hdGNoZXNTZWxlY3RvciA9IGZ1bmN0aW9uKCBlbGVtLCBleHByICkge1xuXHRzZXREb2N1bWVudCggZWxlbSApO1xuXG5cdGlmICggc3VwcG9ydC5tYXRjaGVzU2VsZWN0b3IgJiYgZG9jdW1lbnRJc0hUTUwgJiZcblx0XHQhbm9ubmF0aXZlU2VsZWN0b3JDYWNoZVsgZXhwciArIFwiIFwiIF0gJiZcblx0XHQoICFyYnVnZ3lNYXRjaGVzIHx8ICFyYnVnZ3lNYXRjaGVzLnRlc3QoIGV4cHIgKSApICYmXG5cdFx0KCAhcmJ1Z2d5UVNBICAgICB8fCAhcmJ1Z2d5UVNBLnRlc3QoIGV4cHIgKSApICkge1xuXG5cdFx0dHJ5IHtcblx0XHRcdHZhciByZXQgPSBtYXRjaGVzLmNhbGwoIGVsZW0sIGV4cHIgKTtcblxuXHRcdFx0Ly8gSUUgOSdzIG1hdGNoZXNTZWxlY3RvciByZXR1cm5zIGZhbHNlIG9uIGRpc2Nvbm5lY3RlZCBub2Rlc1xuXHRcdFx0aWYgKCByZXQgfHwgc3VwcG9ydC5kaXNjb25uZWN0ZWRNYXRjaCB8fFxuXG5cdFx0XHRcdC8vIEFzIHdlbGwsIGRpc2Nvbm5lY3RlZCBub2RlcyBhcmUgc2FpZCB0byBiZSBpbiBhIGRvY3VtZW50XG5cdFx0XHRcdC8vIGZyYWdtZW50IGluIElFIDlcblx0XHRcdFx0ZWxlbS5kb2N1bWVudCAmJiBlbGVtLmRvY3VtZW50Lm5vZGVUeXBlICE9PSAxMSApIHtcblx0XHRcdFx0cmV0dXJuIHJldDtcblx0XHRcdH1cblx0XHR9IGNhdGNoICggZSApIHtcblx0XHRcdG5vbm5hdGl2ZVNlbGVjdG9yQ2FjaGUoIGV4cHIsIHRydWUgKTtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gU2l6emxlKCBleHByLCBkb2N1bWVudCwgbnVsbCwgWyBlbGVtIF0gKS5sZW5ndGggPiAwO1xufTtcblxuU2l6emxlLmNvbnRhaW5zID0gZnVuY3Rpb24oIGNvbnRleHQsIGVsZW0gKSB7XG5cblx0Ly8gU2V0IGRvY3VtZW50IHZhcnMgaWYgbmVlZGVkXG5cdC8vIFN1cHBvcnQ6IElFIDExKywgRWRnZSAxNyAtIDE4K1xuXHQvLyBJRS9FZGdlIHNvbWV0aW1lcyB0aHJvdyBhIFwiUGVybWlzc2lvbiBkZW5pZWRcIiBlcnJvciB3aGVuIHN0cmljdC1jb21wYXJpbmdcblx0Ly8gdHdvIGRvY3VtZW50czsgc2hhbGxvdyBjb21wYXJpc29ucyB3b3JrLlxuXHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXFlcWVxXG5cdGlmICggKCBjb250ZXh0Lm93bmVyRG9jdW1lbnQgfHwgY29udGV4dCApICE9IGRvY3VtZW50ICkge1xuXHRcdHNldERvY3VtZW50KCBjb250ZXh0ICk7XG5cdH1cblx0cmV0dXJuIGNvbnRhaW5zKCBjb250ZXh0LCBlbGVtICk7XG59O1xuXG5TaXp6bGUuYXR0ciA9IGZ1bmN0aW9uKCBlbGVtLCBuYW1lICkge1xuXG5cdC8vIFNldCBkb2N1bWVudCB2YXJzIGlmIG5lZWRlZFxuXHQvLyBTdXBwb3J0OiBJRSAxMSssIEVkZ2UgMTcgLSAxOCtcblx0Ly8gSUUvRWRnZSBzb21ldGltZXMgdGhyb3cgYSBcIlBlcm1pc3Npb24gZGVuaWVkXCIgZXJyb3Igd2hlbiBzdHJpY3QtY29tcGFyaW5nXG5cdC8vIHR3byBkb2N1bWVudHM7IHNoYWxsb3cgY29tcGFyaXNvbnMgd29yay5cblx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVxZXFlcVxuXHRpZiAoICggZWxlbS5vd25lckRvY3VtZW50IHx8IGVsZW0gKSAhPSBkb2N1bWVudCApIHtcblx0XHRzZXREb2N1bWVudCggZWxlbSApO1xuXHR9XG5cblx0dmFyIGZuID0gRXhwci5hdHRySGFuZGxlWyBuYW1lLnRvTG93ZXJDYXNlKCkgXSxcblxuXHRcdC8vIERvbid0IGdldCBmb29sZWQgYnkgT2JqZWN0LnByb3RvdHlwZSBwcm9wZXJ0aWVzIChqUXVlcnkgIzEzODA3KVxuXHRcdHZhbCA9IGZuICYmIGhhc093bi5jYWxsKCBFeHByLmF0dHJIYW5kbGUsIG5hbWUudG9Mb3dlckNhc2UoKSApID9cblx0XHRcdGZuKCBlbGVtLCBuYW1lLCAhZG9jdW1lbnRJc0hUTUwgKSA6XG5cdFx0XHR1bmRlZmluZWQ7XG5cblx0cmV0dXJuIHZhbCAhPT0gdW5kZWZpbmVkID9cblx0XHR2YWwgOlxuXHRcdHN1cHBvcnQuYXR0cmlidXRlcyB8fCAhZG9jdW1lbnRJc0hUTUwgP1xuXHRcdFx0ZWxlbS5nZXRBdHRyaWJ1dGUoIG5hbWUgKSA6XG5cdFx0XHQoIHZhbCA9IGVsZW0uZ2V0QXR0cmlidXRlTm9kZSggbmFtZSApICkgJiYgdmFsLnNwZWNpZmllZCA/XG5cdFx0XHRcdHZhbC52YWx1ZSA6XG5cdFx0XHRcdG51bGw7XG59O1xuXG5TaXp6bGUuZXNjYXBlID0gZnVuY3Rpb24oIHNlbCApIHtcblx0cmV0dXJuICggc2VsICsgXCJcIiApLnJlcGxhY2UoIHJjc3Nlc2NhcGUsIGZjc3Nlc2NhcGUgKTtcbn07XG5cblNpenpsZS5lcnJvciA9IGZ1bmN0aW9uKCBtc2cgKSB7XG5cdHRocm93IG5ldyBFcnJvciggXCJTeW50YXggZXJyb3IsIHVucmVjb2duaXplZCBleHByZXNzaW9uOiBcIiArIG1zZyApO1xufTtcblxuLyoqXG4gKiBEb2N1bWVudCBzb3J0aW5nIGFuZCByZW1vdmluZyBkdXBsaWNhdGVzXG4gKiBAcGFyYW0ge0FycmF5TGlrZX0gcmVzdWx0c1xuICovXG5TaXp6bGUudW5pcXVlU29ydCA9IGZ1bmN0aW9uKCByZXN1bHRzICkge1xuXHR2YXIgZWxlbSxcblx0XHRkdXBsaWNhdGVzID0gW10sXG5cdFx0aiA9IDAsXG5cdFx0aSA9IDA7XG5cblx0Ly8gVW5sZXNzIHdlICprbm93KiB3ZSBjYW4gZGV0ZWN0IGR1cGxpY2F0ZXMsIGFzc3VtZSB0aGVpciBwcmVzZW5jZVxuXHRoYXNEdXBsaWNhdGUgPSAhc3VwcG9ydC5kZXRlY3REdXBsaWNhdGVzO1xuXHRzb3J0SW5wdXQgPSAhc3VwcG9ydC5zb3J0U3RhYmxlICYmIHJlc3VsdHMuc2xpY2UoIDAgKTtcblx0cmVzdWx0cy5zb3J0KCBzb3J0T3JkZXIgKTtcblxuXHRpZiAoIGhhc0R1cGxpY2F0ZSApIHtcblx0XHR3aGlsZSAoICggZWxlbSA9IHJlc3VsdHNbIGkrKyBdICkgKSB7XG5cdFx0XHRpZiAoIGVsZW0gPT09IHJlc3VsdHNbIGkgXSApIHtcblx0XHRcdFx0aiA9IGR1cGxpY2F0ZXMucHVzaCggaSApO1xuXHRcdFx0fVxuXHRcdH1cblx0XHR3aGlsZSAoIGotLSApIHtcblx0XHRcdHJlc3VsdHMuc3BsaWNlKCBkdXBsaWNhdGVzWyBqIF0sIDEgKTtcblx0XHR9XG5cdH1cblxuXHQvLyBDbGVhciBpbnB1dCBhZnRlciBzb3J0aW5nIHRvIHJlbGVhc2Ugb2JqZWN0c1xuXHQvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2pxdWVyeS9zaXp6bGUvcHVsbC8yMjVcblx0c29ydElucHV0ID0gbnVsbDtcblxuXHRyZXR1cm4gcmVzdWx0cztcbn07XG5cbi8qKlxuICogVXRpbGl0eSBmdW5jdGlvbiBmb3IgcmV0cmlldmluZyB0aGUgdGV4dCB2YWx1ZSBvZiBhbiBhcnJheSBvZiBET00gbm9kZXNcbiAqIEBwYXJhbSB7QXJyYXl8RWxlbWVudH0gZWxlbVxuICovXG5nZXRUZXh0ID0gU2l6emxlLmdldFRleHQgPSBmdW5jdGlvbiggZWxlbSApIHtcblx0dmFyIG5vZGUsXG5cdFx0cmV0ID0gXCJcIixcblx0XHRpID0gMCxcblx0XHRub2RlVHlwZSA9IGVsZW0ubm9kZVR5cGU7XG5cblx0aWYgKCAhbm9kZVR5cGUgKSB7XG5cblx0XHQvLyBJZiBubyBub2RlVHlwZSwgdGhpcyBpcyBleHBlY3RlZCB0byBiZSBhbiBhcnJheVxuXHRcdHdoaWxlICggKCBub2RlID0gZWxlbVsgaSsrIF0gKSApIHtcblxuXHRcdFx0Ly8gRG8gbm90IHRyYXZlcnNlIGNvbW1lbnQgbm9kZXNcblx0XHRcdHJldCArPSBnZXRUZXh0KCBub2RlICk7XG5cdFx0fVxuXHR9IGVsc2UgaWYgKCBub2RlVHlwZSA9PT0gMSB8fCBub2RlVHlwZSA9PT0gOSB8fCBub2RlVHlwZSA9PT0gMTEgKSB7XG5cblx0XHQvLyBVc2UgdGV4dENvbnRlbnQgZm9yIGVsZW1lbnRzXG5cdFx0Ly8gaW5uZXJUZXh0IHVzYWdlIHJlbW92ZWQgZm9yIGNvbnNpc3RlbmN5IG9mIG5ldyBsaW5lcyAoalF1ZXJ5ICMxMTE1Mylcblx0XHRpZiAoIHR5cGVvZiBlbGVtLnRleHRDb250ZW50ID09PSBcInN0cmluZ1wiICkge1xuXHRcdFx0cmV0dXJuIGVsZW0udGV4dENvbnRlbnQ7XG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0Ly8gVHJhdmVyc2UgaXRzIGNoaWxkcmVuXG5cdFx0XHRmb3IgKCBlbGVtID0gZWxlbS5maXJzdENoaWxkOyBlbGVtOyBlbGVtID0gZWxlbS5uZXh0U2libGluZyApIHtcblx0XHRcdFx0cmV0ICs9IGdldFRleHQoIGVsZW0gKTtcblx0XHRcdH1cblx0XHR9XG5cdH0gZWxzZSBpZiAoIG5vZGVUeXBlID09PSAzIHx8IG5vZGVUeXBlID09PSA0ICkge1xuXHRcdHJldHVybiBlbGVtLm5vZGVWYWx1ZTtcblx0fVxuXG5cdC8vIERvIG5vdCBpbmNsdWRlIGNvbW1lbnQgb3IgcHJvY2Vzc2luZyBpbnN0cnVjdGlvbiBub2Rlc1xuXG5cdHJldHVybiByZXQ7XG59O1xuXG5FeHByID0gU2l6emxlLnNlbGVjdG9ycyA9IHtcblxuXHQvLyBDYW4gYmUgYWRqdXN0ZWQgYnkgdGhlIHVzZXJcblx0Y2FjaGVMZW5ndGg6IDUwLFxuXG5cdGNyZWF0ZVBzZXVkbzogbWFya0Z1bmN0aW9uLFxuXG5cdG1hdGNoOiBtYXRjaEV4cHIsXG5cblx0YXR0ckhhbmRsZToge30sXG5cblx0ZmluZDoge30sXG5cblx0cmVsYXRpdmU6IHtcblx0XHRcIj5cIjogeyBkaXI6IFwicGFyZW50Tm9kZVwiLCBmaXJzdDogdHJ1ZSB9LFxuXHRcdFwiIFwiOiB7IGRpcjogXCJwYXJlbnROb2RlXCIgfSxcblx0XHRcIitcIjogeyBkaXI6IFwicHJldmlvdXNTaWJsaW5nXCIsIGZpcnN0OiB0cnVlIH0sXG5cdFx0XCJ+XCI6IHsgZGlyOiBcInByZXZpb3VzU2libGluZ1wiIH1cblx0fSxcblxuXHRwcmVGaWx0ZXI6IHtcblx0XHRcIkFUVFJcIjogZnVuY3Rpb24oIG1hdGNoICkge1xuXHRcdFx0bWF0Y2hbIDEgXSA9IG1hdGNoWyAxIF0ucmVwbGFjZSggcnVuZXNjYXBlLCBmdW5lc2NhcGUgKTtcblxuXHRcdFx0Ly8gTW92ZSB0aGUgZ2l2ZW4gdmFsdWUgdG8gbWF0Y2hbM10gd2hldGhlciBxdW90ZWQgb3IgdW5xdW90ZWRcblx0XHRcdG1hdGNoWyAzIF0gPSAoIG1hdGNoWyAzIF0gfHwgbWF0Y2hbIDQgXSB8fFxuXHRcdFx0XHRtYXRjaFsgNSBdIHx8IFwiXCIgKS5yZXBsYWNlKCBydW5lc2NhcGUsIGZ1bmVzY2FwZSApO1xuXG5cdFx0XHRpZiAoIG1hdGNoWyAyIF0gPT09IFwifj1cIiApIHtcblx0XHRcdFx0bWF0Y2hbIDMgXSA9IFwiIFwiICsgbWF0Y2hbIDMgXSArIFwiIFwiO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gbWF0Y2guc2xpY2UoIDAsIDQgKTtcblx0XHR9LFxuXG5cdFx0XCJDSElMRFwiOiBmdW5jdGlvbiggbWF0Y2ggKSB7XG5cblx0XHRcdC8qIG1hdGNoZXMgZnJvbSBtYXRjaEV4cHJbXCJDSElMRFwiXVxuXHRcdFx0XHQxIHR5cGUgKG9ubHl8bnRofC4uLilcblx0XHRcdFx0MiB3aGF0IChjaGlsZHxvZi10eXBlKVxuXHRcdFx0XHQzIGFyZ3VtZW50IChldmVufG9kZHxcXGQqfFxcZCpuKFsrLV1cXGQrKT98Li4uKVxuXHRcdFx0XHQ0IHhuLWNvbXBvbmVudCBvZiB4bit5IGFyZ3VtZW50IChbKy1dP1xcZCpufClcblx0XHRcdFx0NSBzaWduIG9mIHhuLWNvbXBvbmVudFxuXHRcdFx0XHQ2IHggb2YgeG4tY29tcG9uZW50XG5cdFx0XHRcdDcgc2lnbiBvZiB5LWNvbXBvbmVudFxuXHRcdFx0XHQ4IHkgb2YgeS1jb21wb25lbnRcblx0XHRcdCovXG5cdFx0XHRtYXRjaFsgMSBdID0gbWF0Y2hbIDEgXS50b0xvd2VyQ2FzZSgpO1xuXG5cdFx0XHRpZiAoIG1hdGNoWyAxIF0uc2xpY2UoIDAsIDMgKSA9PT0gXCJudGhcIiApIHtcblxuXHRcdFx0XHQvLyBudGgtKiByZXF1aXJlcyBhcmd1bWVudFxuXHRcdFx0XHRpZiAoICFtYXRjaFsgMyBdICkge1xuXHRcdFx0XHRcdFNpenpsZS5lcnJvciggbWF0Y2hbIDAgXSApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gbnVtZXJpYyB4IGFuZCB5IHBhcmFtZXRlcnMgZm9yIEV4cHIuZmlsdGVyLkNISUxEXG5cdFx0XHRcdC8vIHJlbWVtYmVyIHRoYXQgZmFsc2UvdHJ1ZSBjYXN0IHJlc3BlY3RpdmVseSB0byAwLzFcblx0XHRcdFx0bWF0Y2hbIDQgXSA9ICsoIG1hdGNoWyA0IF0gP1xuXHRcdFx0XHRcdG1hdGNoWyA1IF0gKyAoIG1hdGNoWyA2IF0gfHwgMSApIDpcblx0XHRcdFx0XHQyICogKCBtYXRjaFsgMyBdID09PSBcImV2ZW5cIiB8fCBtYXRjaFsgMyBdID09PSBcIm9kZFwiICkgKTtcblx0XHRcdFx0bWF0Y2hbIDUgXSA9ICsoICggbWF0Y2hbIDcgXSArIG1hdGNoWyA4IF0gKSB8fCBtYXRjaFsgMyBdID09PSBcIm9kZFwiICk7XG5cblx0XHRcdFx0Ly8gb3RoZXIgdHlwZXMgcHJvaGliaXQgYXJndW1lbnRzXG5cdFx0XHR9IGVsc2UgaWYgKCBtYXRjaFsgMyBdICkge1xuXHRcdFx0XHRTaXp6bGUuZXJyb3IoIG1hdGNoWyAwIF0gKTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIG1hdGNoO1xuXHRcdH0sXG5cblx0XHRcIlBTRVVET1wiOiBmdW5jdGlvbiggbWF0Y2ggKSB7XG5cdFx0XHR2YXIgZXhjZXNzLFxuXHRcdFx0XHR1bnF1b3RlZCA9ICFtYXRjaFsgNiBdICYmIG1hdGNoWyAyIF07XG5cblx0XHRcdGlmICggbWF0Y2hFeHByWyBcIkNISUxEXCIgXS50ZXN0KCBtYXRjaFsgMCBdICkgKSB7XG5cdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBBY2NlcHQgcXVvdGVkIGFyZ3VtZW50cyBhcy1pc1xuXHRcdFx0aWYgKCBtYXRjaFsgMyBdICkge1xuXHRcdFx0XHRtYXRjaFsgMiBdID0gbWF0Y2hbIDQgXSB8fCBtYXRjaFsgNSBdIHx8IFwiXCI7XG5cblx0XHRcdC8vIFN0cmlwIGV4Y2VzcyBjaGFyYWN0ZXJzIGZyb20gdW5xdW90ZWQgYXJndW1lbnRzXG5cdFx0XHR9IGVsc2UgaWYgKCB1bnF1b3RlZCAmJiBycHNldWRvLnRlc3QoIHVucXVvdGVkICkgJiZcblxuXHRcdFx0XHQvLyBHZXQgZXhjZXNzIGZyb20gdG9rZW5pemUgKHJlY3Vyc2l2ZWx5KVxuXHRcdFx0XHQoIGV4Y2VzcyA9IHRva2VuaXplKCB1bnF1b3RlZCwgdHJ1ZSApICkgJiZcblxuXHRcdFx0XHQvLyBhZHZhbmNlIHRvIHRoZSBuZXh0IGNsb3NpbmcgcGFyZW50aGVzaXNcblx0XHRcdFx0KCBleGNlc3MgPSB1bnF1b3RlZC5pbmRleE9mKCBcIilcIiwgdW5xdW90ZWQubGVuZ3RoIC0gZXhjZXNzICkgLSB1bnF1b3RlZC5sZW5ndGggKSApIHtcblxuXHRcdFx0XHQvLyBleGNlc3MgaXMgYSBuZWdhdGl2ZSBpbmRleFxuXHRcdFx0XHRtYXRjaFsgMCBdID0gbWF0Y2hbIDAgXS5zbGljZSggMCwgZXhjZXNzICk7XG5cdFx0XHRcdG1hdGNoWyAyIF0gPSB1bnF1b3RlZC5zbGljZSggMCwgZXhjZXNzICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFJldHVybiBvbmx5IGNhcHR1cmVzIG5lZWRlZCBieSB0aGUgcHNldWRvIGZpbHRlciBtZXRob2QgKHR5cGUgYW5kIGFyZ3VtZW50KVxuXHRcdFx0cmV0dXJuIG1hdGNoLnNsaWNlKCAwLCAzICk7XG5cdFx0fVxuXHR9LFxuXG5cdGZpbHRlcjoge1xuXG5cdFx0XCJUQUdcIjogZnVuY3Rpb24oIG5vZGVOYW1lU2VsZWN0b3IgKSB7XG5cdFx0XHR2YXIgbm9kZU5hbWUgPSBub2RlTmFtZVNlbGVjdG9yLnJlcGxhY2UoIHJ1bmVzY2FwZSwgZnVuZXNjYXBlICkudG9Mb3dlckNhc2UoKTtcblx0XHRcdHJldHVybiBub2RlTmFtZVNlbGVjdG9yID09PSBcIipcIiA/XG5cdFx0XHRcdGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHR9IDpcblx0XHRcdFx0ZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGVsZW0ubm9kZU5hbWUgJiYgZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSBub2RlTmFtZTtcblx0XHRcdFx0fTtcblx0XHR9LFxuXG5cdFx0XCJDTEFTU1wiOiBmdW5jdGlvbiggY2xhc3NOYW1lICkge1xuXHRcdFx0dmFyIHBhdHRlcm4gPSBjbGFzc0NhY2hlWyBjbGFzc05hbWUgKyBcIiBcIiBdO1xuXG5cdFx0XHRyZXR1cm4gcGF0dGVybiB8fFxuXHRcdFx0XHQoIHBhdHRlcm4gPSBuZXcgUmVnRXhwKCBcIihefFwiICsgd2hpdGVzcGFjZSArXG5cdFx0XHRcdFx0XCIpXCIgKyBjbGFzc05hbWUgKyBcIihcIiArIHdoaXRlc3BhY2UgKyBcInwkKVwiICkgKSAmJiBjbGFzc0NhY2hlKFxuXHRcdFx0XHRcdFx0Y2xhc3NOYW1lLCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIHBhdHRlcm4udGVzdChcblx0XHRcdFx0XHRcdFx0XHR0eXBlb2YgZWxlbS5jbGFzc05hbWUgPT09IFwic3RyaW5nXCIgJiYgZWxlbS5jbGFzc05hbWUgfHxcblx0XHRcdFx0XHRcdFx0XHR0eXBlb2YgZWxlbS5nZXRBdHRyaWJ1dGUgIT09IFwidW5kZWZpbmVkXCIgJiZcblx0XHRcdFx0XHRcdFx0XHRcdGVsZW0uZ2V0QXR0cmlidXRlKCBcImNsYXNzXCIgKSB8fFxuXHRcdFx0XHRcdFx0XHRcdFwiXCJcblx0XHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0fSApO1xuXHRcdH0sXG5cblx0XHRcIkFUVFJcIjogZnVuY3Rpb24oIG5hbWUsIG9wZXJhdG9yLCBjaGVjayApIHtcblx0XHRcdHJldHVybiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0dmFyIHJlc3VsdCA9IFNpenpsZS5hdHRyKCBlbGVtLCBuYW1lICk7XG5cblx0XHRcdFx0aWYgKCByZXN1bHQgPT0gbnVsbCApIHtcblx0XHRcdFx0XHRyZXR1cm4gb3BlcmF0b3IgPT09IFwiIT1cIjtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoICFvcGVyYXRvciApIHtcblx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJlc3VsdCArPSBcIlwiO1xuXG5cdFx0XHRcdC8qIGVzbGludC1kaXNhYmxlIG1heC1sZW4gKi9cblxuXHRcdFx0XHRyZXR1cm4gb3BlcmF0b3IgPT09IFwiPVwiID8gcmVzdWx0ID09PSBjaGVjayA6XG5cdFx0XHRcdFx0b3BlcmF0b3IgPT09IFwiIT1cIiA/IHJlc3VsdCAhPT0gY2hlY2sgOlxuXHRcdFx0XHRcdG9wZXJhdG9yID09PSBcIl49XCIgPyBjaGVjayAmJiByZXN1bHQuaW5kZXhPZiggY2hlY2sgKSA9PT0gMCA6XG5cdFx0XHRcdFx0b3BlcmF0b3IgPT09IFwiKj1cIiA/IGNoZWNrICYmIHJlc3VsdC5pbmRleE9mKCBjaGVjayApID4gLTEgOlxuXHRcdFx0XHRcdG9wZXJhdG9yID09PSBcIiQ9XCIgPyBjaGVjayAmJiByZXN1bHQuc2xpY2UoIC1jaGVjay5sZW5ndGggKSA9PT0gY2hlY2sgOlxuXHRcdFx0XHRcdG9wZXJhdG9yID09PSBcIn49XCIgPyAoIFwiIFwiICsgcmVzdWx0LnJlcGxhY2UoIHJ3aGl0ZXNwYWNlLCBcIiBcIiApICsgXCIgXCIgKS5pbmRleE9mKCBjaGVjayApID4gLTEgOlxuXHRcdFx0XHRcdG9wZXJhdG9yID09PSBcInw9XCIgPyByZXN1bHQgPT09IGNoZWNrIHx8IHJlc3VsdC5zbGljZSggMCwgY2hlY2subGVuZ3RoICsgMSApID09PSBjaGVjayArIFwiLVwiIDpcblx0XHRcdFx0XHRmYWxzZTtcblx0XHRcdFx0LyogZXNsaW50LWVuYWJsZSBtYXgtbGVuICovXG5cblx0XHRcdH07XG5cdFx0fSxcblxuXHRcdFwiQ0hJTERcIjogZnVuY3Rpb24oIHR5cGUsIHdoYXQsIF9hcmd1bWVudCwgZmlyc3QsIGxhc3QgKSB7XG5cdFx0XHR2YXIgc2ltcGxlID0gdHlwZS5zbGljZSggMCwgMyApICE9PSBcIm50aFwiLFxuXHRcdFx0XHRmb3J3YXJkID0gdHlwZS5zbGljZSggLTQgKSAhPT0gXCJsYXN0XCIsXG5cdFx0XHRcdG9mVHlwZSA9IHdoYXQgPT09IFwib2YtdHlwZVwiO1xuXG5cdFx0XHRyZXR1cm4gZmlyc3QgPT09IDEgJiYgbGFzdCA9PT0gMCA/XG5cblx0XHRcdFx0Ly8gU2hvcnRjdXQgZm9yIDpudGgtKihuKVxuXHRcdFx0XHRmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0XHRyZXR1cm4gISFlbGVtLnBhcmVudE5vZGU7XG5cdFx0XHRcdH0gOlxuXG5cdFx0XHRcdGZ1bmN0aW9uKCBlbGVtLCBfY29udGV4dCwgeG1sICkge1xuXHRcdFx0XHRcdHZhciBjYWNoZSwgdW5pcXVlQ2FjaGUsIG91dGVyQ2FjaGUsIG5vZGUsIG5vZGVJbmRleCwgc3RhcnQsXG5cdFx0XHRcdFx0XHRkaXIgPSBzaW1wbGUgIT09IGZvcndhcmQgPyBcIm5leHRTaWJsaW5nXCIgOiBcInByZXZpb3VzU2libGluZ1wiLFxuXHRcdFx0XHRcdFx0cGFyZW50ID0gZWxlbS5wYXJlbnROb2RlLFxuXHRcdFx0XHRcdFx0bmFtZSA9IG9mVHlwZSAmJiBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCksXG5cdFx0XHRcdFx0XHR1c2VDYWNoZSA9ICF4bWwgJiYgIW9mVHlwZSxcblx0XHRcdFx0XHRcdGRpZmYgPSBmYWxzZTtcblxuXHRcdFx0XHRcdGlmICggcGFyZW50ICkge1xuXG5cdFx0XHRcdFx0XHQvLyA6KGZpcnN0fGxhc3R8b25seSktKGNoaWxkfG9mLXR5cGUpXG5cdFx0XHRcdFx0XHRpZiAoIHNpbXBsZSApIHtcblx0XHRcdFx0XHRcdFx0d2hpbGUgKCBkaXIgKSB7XG5cdFx0XHRcdFx0XHRcdFx0bm9kZSA9IGVsZW07XG5cdFx0XHRcdFx0XHRcdFx0d2hpbGUgKCAoIG5vZGUgPSBub2RlWyBkaXIgXSApICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0aWYgKCBvZlR5cGUgP1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRub2RlLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09IG5hbWUgOlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRub2RlLm5vZGVUeXBlID09PSAxICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0XHQvLyBSZXZlcnNlIGRpcmVjdGlvbiBmb3IgOm9ubHktKiAoaWYgd2UgaGF2ZW4ndCB5ZXQgZG9uZSBzbylcblx0XHRcdFx0XHRcdFx0XHRzdGFydCA9IGRpciA9IHR5cGUgPT09IFwib25seVwiICYmICFzdGFydCAmJiBcIm5leHRTaWJsaW5nXCI7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdHN0YXJ0ID0gWyBmb3J3YXJkID8gcGFyZW50LmZpcnN0Q2hpbGQgOiBwYXJlbnQubGFzdENoaWxkIF07XG5cblx0XHRcdFx0XHRcdC8vIG5vbi14bWwgOm50aC1jaGlsZCguLi4pIHN0b3JlcyBjYWNoZSBkYXRhIG9uIGBwYXJlbnRgXG5cdFx0XHRcdFx0XHRpZiAoIGZvcndhcmQgJiYgdXNlQ2FjaGUgKSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gU2VlayBgZWxlbWAgZnJvbSBhIHByZXZpb3VzbHktY2FjaGVkIGluZGV4XG5cblx0XHRcdFx0XHRcdFx0Ly8gLi4uaW4gYSBnemlwLWZyaWVuZGx5IHdheVxuXHRcdFx0XHRcdFx0XHRub2RlID0gcGFyZW50O1xuXHRcdFx0XHRcdFx0XHRvdXRlckNhY2hlID0gbm9kZVsgZXhwYW5kbyBdIHx8ICggbm9kZVsgZXhwYW5kbyBdID0ge30gKTtcblxuXHRcdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA8OSBvbmx5XG5cdFx0XHRcdFx0XHRcdC8vIERlZmVuZCBhZ2FpbnN0IGNsb25lZCBhdHRyb3BlcnRpZXMgKGpRdWVyeSBnaC0xNzA5KVxuXHRcdFx0XHRcdFx0XHR1bmlxdWVDYWNoZSA9IG91dGVyQ2FjaGVbIG5vZGUudW5pcXVlSUQgXSB8fFxuXHRcdFx0XHRcdFx0XHRcdCggb3V0ZXJDYWNoZVsgbm9kZS51bmlxdWVJRCBdID0ge30gKTtcblxuXHRcdFx0XHRcdFx0XHRjYWNoZSA9IHVuaXF1ZUNhY2hlWyB0eXBlIF0gfHwgW107XG5cdFx0XHRcdFx0XHRcdG5vZGVJbmRleCA9IGNhY2hlWyAwIF0gPT09IGRpcnJ1bnMgJiYgY2FjaGVbIDEgXTtcblx0XHRcdFx0XHRcdFx0ZGlmZiA9IG5vZGVJbmRleCAmJiBjYWNoZVsgMiBdO1xuXHRcdFx0XHRcdFx0XHRub2RlID0gbm9kZUluZGV4ICYmIHBhcmVudC5jaGlsZE5vZGVzWyBub2RlSW5kZXggXTtcblxuXHRcdFx0XHRcdFx0XHR3aGlsZSAoICggbm9kZSA9ICsrbm9kZUluZGV4ICYmIG5vZGUgJiYgbm9kZVsgZGlyIF0gfHxcblxuXHRcdFx0XHRcdFx0XHRcdC8vIEZhbGxiYWNrIHRvIHNlZWtpbmcgYGVsZW1gIGZyb20gdGhlIHN0YXJ0XG5cdFx0XHRcdFx0XHRcdFx0KCBkaWZmID0gbm9kZUluZGV4ID0gMCApIHx8IHN0YXJ0LnBvcCgpICkgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHQvLyBXaGVuIGZvdW5kLCBjYWNoZSBpbmRleGVzIG9uIGBwYXJlbnRgIGFuZCBicmVha1xuXHRcdFx0XHRcdFx0XHRcdGlmICggbm9kZS5ub2RlVHlwZSA9PT0gMSAmJiArK2RpZmYgJiYgbm9kZSA9PT0gZWxlbSApIHtcblx0XHRcdFx0XHRcdFx0XHRcdHVuaXF1ZUNhY2hlWyB0eXBlIF0gPSBbIGRpcnJ1bnMsIG5vZGVJbmRleCwgZGlmZiBdO1xuXHRcdFx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gVXNlIHByZXZpb3VzbHktY2FjaGVkIGVsZW1lbnQgaW5kZXggaWYgYXZhaWxhYmxlXG5cdFx0XHRcdFx0XHRcdGlmICggdXNlQ2FjaGUgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHQvLyAuLi5pbiBhIGd6aXAtZnJpZW5kbHkgd2F5XG5cdFx0XHRcdFx0XHRcdFx0bm9kZSA9IGVsZW07XG5cdFx0XHRcdFx0XHRcdFx0b3V0ZXJDYWNoZSA9IG5vZGVbIGV4cGFuZG8gXSB8fCAoIG5vZGVbIGV4cGFuZG8gXSA9IHt9ICk7XG5cblx0XHRcdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA8OSBvbmx5XG5cdFx0XHRcdFx0XHRcdFx0Ly8gRGVmZW5kIGFnYWluc3QgY2xvbmVkIGF0dHJvcGVydGllcyAoalF1ZXJ5IGdoLTE3MDkpXG5cdFx0XHRcdFx0XHRcdFx0dW5pcXVlQ2FjaGUgPSBvdXRlckNhY2hlWyBub2RlLnVuaXF1ZUlEIF0gfHxcblx0XHRcdFx0XHRcdFx0XHRcdCggb3V0ZXJDYWNoZVsgbm9kZS51bmlxdWVJRCBdID0ge30gKTtcblxuXHRcdFx0XHRcdFx0XHRcdGNhY2hlID0gdW5pcXVlQ2FjaGVbIHR5cGUgXSB8fCBbXTtcblx0XHRcdFx0XHRcdFx0XHRub2RlSW5kZXggPSBjYWNoZVsgMCBdID09PSBkaXJydW5zICYmIGNhY2hlWyAxIF07XG5cdFx0XHRcdFx0XHRcdFx0ZGlmZiA9IG5vZGVJbmRleDtcblx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdC8vIHhtbCA6bnRoLWNoaWxkKC4uLilcblx0XHRcdFx0XHRcdFx0Ly8gb3IgOm50aC1sYXN0LWNoaWxkKC4uLikgb3IgOm50aCgtbGFzdCk/LW9mLXR5cGUoLi4uKVxuXHRcdFx0XHRcdFx0XHRpZiAoIGRpZmYgPT09IGZhbHNlICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gVXNlIHRoZSBzYW1lIGxvb3AgYXMgYWJvdmUgdG8gc2VlayBgZWxlbWAgZnJvbSB0aGUgc3RhcnRcblx0XHRcdFx0XHRcdFx0XHR3aGlsZSAoICggbm9kZSA9ICsrbm9kZUluZGV4ICYmIG5vZGUgJiYgbm9kZVsgZGlyIF0gfHxcblx0XHRcdFx0XHRcdFx0XHRcdCggZGlmZiA9IG5vZGVJbmRleCA9IDAgKSB8fCBzdGFydC5wb3AoKSApICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRpZiAoICggb2ZUeXBlID9cblx0XHRcdFx0XHRcdFx0XHRcdFx0bm9kZS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSBuYW1lIDpcblx0XHRcdFx0XHRcdFx0XHRcdFx0bm9kZS5ub2RlVHlwZSA9PT0gMSApICYmXG5cdFx0XHRcdFx0XHRcdFx0XHRcdCsrZGlmZiApIHtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBDYWNoZSB0aGUgaW5kZXggb2YgZWFjaCBlbmNvdW50ZXJlZCBlbGVtZW50XG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlmICggdXNlQ2FjaGUgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0b3V0ZXJDYWNoZSA9IG5vZGVbIGV4cGFuZG8gXSB8fFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0KCBub2RlWyBleHBhbmRvIF0gPSB7fSApO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgPDkgb25seVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdC8vIERlZmVuZCBhZ2FpbnN0IGNsb25lZCBhdHRyb3BlcnRpZXMgKGpRdWVyeSBnaC0xNzA5KVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHVuaXF1ZUNhY2hlID0gb3V0ZXJDYWNoZVsgbm9kZS51bmlxdWVJRCBdIHx8XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHQoIG91dGVyQ2FjaGVbIG5vZGUudW5pcXVlSUQgXSA9IHt9ICk7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR1bmlxdWVDYWNoZVsgdHlwZSBdID0gWyBkaXJydW5zLCBkaWZmIF07XG5cdFx0XHRcdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZiAoIG5vZGUgPT09IGVsZW0gKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0Ly8gSW5jb3Jwb3JhdGUgdGhlIG9mZnNldCwgdGhlbiBjaGVjayBhZ2FpbnN0IGN5Y2xlIHNpemVcblx0XHRcdFx0XHRcdGRpZmYgLT0gbGFzdDtcblx0XHRcdFx0XHRcdHJldHVybiBkaWZmID09PSBmaXJzdCB8fCAoIGRpZmYgJSBmaXJzdCA9PT0gMCAmJiBkaWZmIC8gZmlyc3QgPj0gMCApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fTtcblx0XHR9LFxuXG5cdFx0XCJQU0VVRE9cIjogZnVuY3Rpb24oIHBzZXVkbywgYXJndW1lbnQgKSB7XG5cblx0XHRcdC8vIHBzZXVkby1jbGFzcyBuYW1lcyBhcmUgY2FzZS1pbnNlbnNpdGl2ZVxuXHRcdFx0Ly8gaHR0cDovL3d3dy53My5vcmcvVFIvc2VsZWN0b3JzLyNwc2V1ZG8tY2xhc3Nlc1xuXHRcdFx0Ly8gUHJpb3JpdGl6ZSBieSBjYXNlIHNlbnNpdGl2aXR5IGluIGNhc2UgY3VzdG9tIHBzZXVkb3MgYXJlIGFkZGVkIHdpdGggdXBwZXJjYXNlIGxldHRlcnNcblx0XHRcdC8vIFJlbWVtYmVyIHRoYXQgc2V0RmlsdGVycyBpbmhlcml0cyBmcm9tIHBzZXVkb3Ncblx0XHRcdHZhciBhcmdzLFxuXHRcdFx0XHRmbiA9IEV4cHIucHNldWRvc1sgcHNldWRvIF0gfHwgRXhwci5zZXRGaWx0ZXJzWyBwc2V1ZG8udG9Mb3dlckNhc2UoKSBdIHx8XG5cdFx0XHRcdFx0U2l6emxlLmVycm9yKCBcInVuc3VwcG9ydGVkIHBzZXVkbzogXCIgKyBwc2V1ZG8gKTtcblxuXHRcdFx0Ly8gVGhlIHVzZXIgbWF5IHVzZSBjcmVhdGVQc2V1ZG8gdG8gaW5kaWNhdGUgdGhhdFxuXHRcdFx0Ly8gYXJndW1lbnRzIGFyZSBuZWVkZWQgdG8gY3JlYXRlIHRoZSBmaWx0ZXIgZnVuY3Rpb25cblx0XHRcdC8vIGp1c3QgYXMgU2l6emxlIGRvZXNcblx0XHRcdGlmICggZm5bIGV4cGFuZG8gXSApIHtcblx0XHRcdFx0cmV0dXJuIGZuKCBhcmd1bWVudCApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBCdXQgbWFpbnRhaW4gc3VwcG9ydCBmb3Igb2xkIHNpZ25hdHVyZXNcblx0XHRcdGlmICggZm4ubGVuZ3RoID4gMSApIHtcblx0XHRcdFx0YXJncyA9IFsgcHNldWRvLCBwc2V1ZG8sIFwiXCIsIGFyZ3VtZW50IF07XG5cdFx0XHRcdHJldHVybiBFeHByLnNldEZpbHRlcnMuaGFzT3duUHJvcGVydHkoIHBzZXVkby50b0xvd2VyQ2FzZSgpICkgP1xuXHRcdFx0XHRcdG1hcmtGdW5jdGlvbiggZnVuY3Rpb24oIHNlZWQsIG1hdGNoZXMgKSB7XG5cdFx0XHRcdFx0XHR2YXIgaWR4LFxuXHRcdFx0XHRcdFx0XHRtYXRjaGVkID0gZm4oIHNlZWQsIGFyZ3VtZW50ICksXG5cdFx0XHRcdFx0XHRcdGkgPSBtYXRjaGVkLmxlbmd0aDtcblx0XHRcdFx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRcdFx0XHRpZHggPSBpbmRleE9mKCBzZWVkLCBtYXRjaGVkWyBpIF0gKTtcblx0XHRcdFx0XHRcdFx0c2VlZFsgaWR4IF0gPSAhKCBtYXRjaGVzWyBpZHggXSA9IG1hdGNoZWRbIGkgXSApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0gKSA6XG5cdFx0XHRcdFx0ZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZm4oIGVsZW0sIDAsIGFyZ3MgKTtcblx0XHRcdFx0XHR9O1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gZm47XG5cdFx0fVxuXHR9LFxuXG5cdHBzZXVkb3M6IHtcblxuXHRcdC8vIFBvdGVudGlhbGx5IGNvbXBsZXggcHNldWRvc1xuXHRcdFwibm90XCI6IG1hcmtGdW5jdGlvbiggZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXG5cdFx0XHQvLyBUcmltIHRoZSBzZWxlY3RvciBwYXNzZWQgdG8gY29tcGlsZVxuXHRcdFx0Ly8gdG8gYXZvaWQgdHJlYXRpbmcgbGVhZGluZyBhbmQgdHJhaWxpbmdcblx0XHRcdC8vIHNwYWNlcyBhcyBjb21iaW5hdG9yc1xuXHRcdFx0dmFyIGlucHV0ID0gW10sXG5cdFx0XHRcdHJlc3VsdHMgPSBbXSxcblx0XHRcdFx0bWF0Y2hlciA9IGNvbXBpbGUoIHNlbGVjdG9yLnJlcGxhY2UoIHJ0cmltLCBcIiQxXCIgKSApO1xuXG5cdFx0XHRyZXR1cm4gbWF0Y2hlclsgZXhwYW5kbyBdID9cblx0XHRcdFx0bWFya0Z1bmN0aW9uKCBmdW5jdGlvbiggc2VlZCwgbWF0Y2hlcywgX2NvbnRleHQsIHhtbCApIHtcblx0XHRcdFx0XHR2YXIgZWxlbSxcblx0XHRcdFx0XHRcdHVubWF0Y2hlZCA9IG1hdGNoZXIoIHNlZWQsIG51bGwsIHhtbCwgW10gKSxcblx0XHRcdFx0XHRcdGkgPSBzZWVkLmxlbmd0aDtcblxuXHRcdFx0XHRcdC8vIE1hdGNoIGVsZW1lbnRzIHVubWF0Y2hlZCBieSBgbWF0Y2hlcmBcblx0XHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0XHRcdGlmICggKCBlbGVtID0gdW5tYXRjaGVkWyBpIF0gKSApIHtcblx0XHRcdFx0XHRcdFx0c2VlZFsgaSBdID0gISggbWF0Y2hlc1sgaSBdID0gZWxlbSApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSApIDpcblx0XHRcdFx0ZnVuY3Rpb24oIGVsZW0sIF9jb250ZXh0LCB4bWwgKSB7XG5cdFx0XHRcdFx0aW5wdXRbIDAgXSA9IGVsZW07XG5cdFx0XHRcdFx0bWF0Y2hlciggaW5wdXQsIG51bGwsIHhtbCwgcmVzdWx0cyApO1xuXG5cdFx0XHRcdFx0Ly8gRG9uJ3Qga2VlcCB0aGUgZWxlbWVudCAoaXNzdWUgIzI5OSlcblx0XHRcdFx0XHRpbnB1dFsgMCBdID0gbnVsbDtcblx0XHRcdFx0XHRyZXR1cm4gIXJlc3VsdHMucG9wKCk7XG5cdFx0XHRcdH07XG5cdFx0fSApLFxuXG5cdFx0XCJoYXNcIjogbWFya0Z1bmN0aW9uKCBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdHJldHVybiBTaXp6bGUoIHNlbGVjdG9yLCBlbGVtICkubGVuZ3RoID4gMDtcblx0XHRcdH07XG5cdFx0fSApLFxuXG5cdFx0XCJjb250YWluc1wiOiBtYXJrRnVuY3Rpb24oIGZ1bmN0aW9uKCB0ZXh0ICkge1xuXHRcdFx0dGV4dCA9IHRleHQucmVwbGFjZSggcnVuZXNjYXBlLCBmdW5lc2NhcGUgKTtcblx0XHRcdHJldHVybiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0cmV0dXJuICggZWxlbS50ZXh0Q29udGVudCB8fCBnZXRUZXh0KCBlbGVtICkgKS5pbmRleE9mKCB0ZXh0ICkgPiAtMTtcblx0XHRcdH07XG5cdFx0fSApLFxuXG5cdFx0Ly8gXCJXaGV0aGVyIGFuIGVsZW1lbnQgaXMgcmVwcmVzZW50ZWQgYnkgYSA6bGFuZygpIHNlbGVjdG9yXG5cdFx0Ly8gaXMgYmFzZWQgc29sZWx5IG9uIHRoZSBlbGVtZW50J3MgbGFuZ3VhZ2UgdmFsdWVcblx0XHQvLyBiZWluZyBlcXVhbCB0byB0aGUgaWRlbnRpZmllciBDLFxuXHRcdC8vIG9yIGJlZ2lubmluZyB3aXRoIHRoZSBpZGVudGlmaWVyIEMgaW1tZWRpYXRlbHkgZm9sbG93ZWQgYnkgXCItXCIuXG5cdFx0Ly8gVGhlIG1hdGNoaW5nIG9mIEMgYWdhaW5zdCB0aGUgZWxlbWVudCdzIGxhbmd1YWdlIHZhbHVlIGlzIHBlcmZvcm1lZCBjYXNlLWluc2Vuc2l0aXZlbHkuXG5cdFx0Ly8gVGhlIGlkZW50aWZpZXIgQyBkb2VzIG5vdCBoYXZlIHRvIGJlIGEgdmFsaWQgbGFuZ3VhZ2UgbmFtZS5cIlxuXHRcdC8vIGh0dHA6Ly93d3cudzMub3JnL1RSL3NlbGVjdG9ycy8jbGFuZy1wc2V1ZG9cblx0XHRcImxhbmdcIjogbWFya0Z1bmN0aW9uKCBmdW5jdGlvbiggbGFuZyApIHtcblxuXHRcdFx0Ly8gbGFuZyB2YWx1ZSBtdXN0IGJlIGEgdmFsaWQgaWRlbnRpZmllclxuXHRcdFx0aWYgKCAhcmlkZW50aWZpZXIudGVzdCggbGFuZyB8fCBcIlwiICkgKSB7XG5cdFx0XHRcdFNpenpsZS5lcnJvciggXCJ1bnN1cHBvcnRlZCBsYW5nOiBcIiArIGxhbmcgKTtcblx0XHRcdH1cblx0XHRcdGxhbmcgPSBsYW5nLnJlcGxhY2UoIHJ1bmVzY2FwZSwgZnVuZXNjYXBlICkudG9Mb3dlckNhc2UoKTtcblx0XHRcdHJldHVybiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0dmFyIGVsZW1MYW5nO1xuXHRcdFx0XHRkbyB7XG5cdFx0XHRcdFx0aWYgKCAoIGVsZW1MYW5nID0gZG9jdW1lbnRJc0hUTUwgP1xuXHRcdFx0XHRcdFx0ZWxlbS5sYW5nIDpcblx0XHRcdFx0XHRcdGVsZW0uZ2V0QXR0cmlidXRlKCBcInhtbDpsYW5nXCIgKSB8fCBlbGVtLmdldEF0dHJpYnV0ZSggXCJsYW5nXCIgKSApICkge1xuXG5cdFx0XHRcdFx0XHRlbGVtTGFuZyA9IGVsZW1MYW5nLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZWxlbUxhbmcgPT09IGxhbmcgfHwgZWxlbUxhbmcuaW5kZXhPZiggbGFuZyArIFwiLVwiICkgPT09IDA7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IHdoaWxlICggKCBlbGVtID0gZWxlbS5wYXJlbnROb2RlICkgJiYgZWxlbS5ub2RlVHlwZSA9PT0gMSApO1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9O1xuXHRcdH0gKSxcblxuXHRcdC8vIE1pc2NlbGxhbmVvdXNcblx0XHRcInRhcmdldFwiOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHZhciBoYXNoID0gd2luZG93LmxvY2F0aW9uICYmIHdpbmRvdy5sb2NhdGlvbi5oYXNoO1xuXHRcdFx0cmV0dXJuIGhhc2ggJiYgaGFzaC5zbGljZSggMSApID09PSBlbGVtLmlkO1xuXHRcdH0sXG5cblx0XHRcInJvb3RcIjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gZWxlbSA9PT0gZG9jRWxlbTtcblx0XHR9LFxuXG5cdFx0XCJmb2N1c1wiOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiBlbGVtID09PSBkb2N1bWVudC5hY3RpdmVFbGVtZW50ICYmXG5cdFx0XHRcdCggIWRvY3VtZW50Lmhhc0ZvY3VzIHx8IGRvY3VtZW50Lmhhc0ZvY3VzKCkgKSAmJlxuXHRcdFx0XHQhISggZWxlbS50eXBlIHx8IGVsZW0uaHJlZiB8fCB+ZWxlbS50YWJJbmRleCApO1xuXHRcdH0sXG5cblx0XHQvLyBCb29sZWFuIHByb3BlcnRpZXNcblx0XHRcImVuYWJsZWRcIjogY3JlYXRlRGlzYWJsZWRQc2V1ZG8oIGZhbHNlICksXG5cdFx0XCJkaXNhYmxlZFwiOiBjcmVhdGVEaXNhYmxlZFBzZXVkbyggdHJ1ZSApLFxuXG5cdFx0XCJjaGVja2VkXCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuXG5cdFx0XHQvLyBJbiBDU1MzLCA6Y2hlY2tlZCBzaG91bGQgcmV0dXJuIGJvdGggY2hlY2tlZCBhbmQgc2VsZWN0ZWQgZWxlbWVudHNcblx0XHRcdC8vIGh0dHA6Ly93d3cudzMub3JnL1RSLzIwMTEvUkVDLWNzczMtc2VsZWN0b3JzLTIwMTEwOTI5LyNjaGVja2VkXG5cdFx0XHR2YXIgbm9kZU5hbWUgPSBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHRyZXR1cm4gKCBub2RlTmFtZSA9PT0gXCJpbnB1dFwiICYmICEhZWxlbS5jaGVja2VkICkgfHxcblx0XHRcdFx0KCBub2RlTmFtZSA9PT0gXCJvcHRpb25cIiAmJiAhIWVsZW0uc2VsZWN0ZWQgKTtcblx0XHR9LFxuXG5cdFx0XCJzZWxlY3RlZFwiOiBmdW5jdGlvbiggZWxlbSApIHtcblxuXHRcdFx0Ly8gQWNjZXNzaW5nIHRoaXMgcHJvcGVydHkgbWFrZXMgc2VsZWN0ZWQtYnktZGVmYXVsdFxuXHRcdFx0Ly8gb3B0aW9ucyBpbiBTYWZhcmkgd29yayBwcm9wZXJseVxuXHRcdFx0aWYgKCBlbGVtLnBhcmVudE5vZGUgKSB7XG5cdFx0XHRcdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnVzZWQtZXhwcmVzc2lvbnNcblx0XHRcdFx0ZWxlbS5wYXJlbnROb2RlLnNlbGVjdGVkSW5kZXg7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBlbGVtLnNlbGVjdGVkID09PSB0cnVlO1xuXHRcdH0sXG5cblx0XHQvLyBDb250ZW50c1xuXHRcdFwiZW1wdHlcIjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cblx0XHRcdC8vIGh0dHA6Ly93d3cudzMub3JnL1RSL3NlbGVjdG9ycy8jZW1wdHktcHNldWRvXG5cdFx0XHQvLyA6ZW1wdHkgaXMgbmVnYXRlZCBieSBlbGVtZW50ICgxKSBvciBjb250ZW50IG5vZGVzICh0ZXh0OiAzOyBjZGF0YTogNDsgZW50aXR5IHJlZjogNSksXG5cdFx0XHQvLyAgIGJ1dCBub3QgYnkgb3RoZXJzIChjb21tZW50OiA4OyBwcm9jZXNzaW5nIGluc3RydWN0aW9uOiA3OyBldGMuKVxuXHRcdFx0Ly8gbm9kZVR5cGUgPCA2IHdvcmtzIGJlY2F1c2UgYXR0cmlidXRlcyAoMikgZG8gbm90IGFwcGVhciBhcyBjaGlsZHJlblxuXHRcdFx0Zm9yICggZWxlbSA9IGVsZW0uZmlyc3RDaGlsZDsgZWxlbTsgZWxlbSA9IGVsZW0ubmV4dFNpYmxpbmcgKSB7XG5cdFx0XHRcdGlmICggZWxlbS5ub2RlVHlwZSA8IDYgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9LFxuXG5cdFx0XCJwYXJlbnRcIjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gIUV4cHIucHNldWRvc1sgXCJlbXB0eVwiIF0oIGVsZW0gKTtcblx0XHR9LFxuXG5cdFx0Ly8gRWxlbWVudC9pbnB1dCB0eXBlc1xuXHRcdFwiaGVhZGVyXCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuIHJoZWFkZXIudGVzdCggZWxlbS5ub2RlTmFtZSApO1xuXHRcdH0sXG5cblx0XHRcImlucHV0XCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuIHJpbnB1dHMudGVzdCggZWxlbS5ub2RlTmFtZSApO1xuXHRcdH0sXG5cblx0XHRcImJ1dHRvblwiOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHZhciBuYW1lID0gZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0cmV0dXJuIG5hbWUgPT09IFwiaW5wdXRcIiAmJiBlbGVtLnR5cGUgPT09IFwiYnV0dG9uXCIgfHwgbmFtZSA9PT0gXCJidXR0b25cIjtcblx0XHR9LFxuXG5cdFx0XCJ0ZXh0XCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0dmFyIGF0dHI7XG5cdFx0XHRyZXR1cm4gZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSBcImlucHV0XCIgJiZcblx0XHRcdFx0ZWxlbS50eXBlID09PSBcInRleHRcIiAmJlxuXG5cdFx0XHRcdC8vIFN1cHBvcnQ6IElFPDhcblx0XHRcdFx0Ly8gTmV3IEhUTUw1IGF0dHJpYnV0ZSB2YWx1ZXMgKGUuZy4sIFwic2VhcmNoXCIpIGFwcGVhciB3aXRoIGVsZW0udHlwZSA9PT0gXCJ0ZXh0XCJcblx0XHRcdFx0KCAoIGF0dHIgPSBlbGVtLmdldEF0dHJpYnV0ZSggXCJ0eXBlXCIgKSApID09IG51bGwgfHxcblx0XHRcdFx0XHRhdHRyLnRvTG93ZXJDYXNlKCkgPT09IFwidGV4dFwiICk7XG5cdFx0fSxcblxuXHRcdC8vIFBvc2l0aW9uLWluLWNvbGxlY3Rpb25cblx0XHRcImZpcnN0XCI6IGNyZWF0ZVBvc2l0aW9uYWxQc2V1ZG8oIGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIFsgMCBdO1xuXHRcdH0gKSxcblxuXHRcdFwibGFzdFwiOiBjcmVhdGVQb3NpdGlvbmFsUHNldWRvKCBmdW5jdGlvbiggX21hdGNoSW5kZXhlcywgbGVuZ3RoICkge1xuXHRcdFx0cmV0dXJuIFsgbGVuZ3RoIC0gMSBdO1xuXHRcdH0gKSxcblxuXHRcdFwiZXFcIjogY3JlYXRlUG9zaXRpb25hbFBzZXVkbyggZnVuY3Rpb24oIF9tYXRjaEluZGV4ZXMsIGxlbmd0aCwgYXJndW1lbnQgKSB7XG5cdFx0XHRyZXR1cm4gWyBhcmd1bWVudCA8IDAgPyBhcmd1bWVudCArIGxlbmd0aCA6IGFyZ3VtZW50IF07XG5cdFx0fSApLFxuXG5cdFx0XCJldmVuXCI6IGNyZWF0ZVBvc2l0aW9uYWxQc2V1ZG8oIGZ1bmN0aW9uKCBtYXRjaEluZGV4ZXMsIGxlbmd0aCApIHtcblx0XHRcdHZhciBpID0gMDtcblx0XHRcdGZvciAoIDsgaSA8IGxlbmd0aDsgaSArPSAyICkge1xuXHRcdFx0XHRtYXRjaEluZGV4ZXMucHVzaCggaSApO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIG1hdGNoSW5kZXhlcztcblx0XHR9ICksXG5cblx0XHRcIm9kZFwiOiBjcmVhdGVQb3NpdGlvbmFsUHNldWRvKCBmdW5jdGlvbiggbWF0Y2hJbmRleGVzLCBsZW5ndGggKSB7XG5cdFx0XHR2YXIgaSA9IDE7XG5cdFx0XHRmb3IgKCA7IGkgPCBsZW5ndGg7IGkgKz0gMiApIHtcblx0XHRcdFx0bWF0Y2hJbmRleGVzLnB1c2goIGkgKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBtYXRjaEluZGV4ZXM7XG5cdFx0fSApLFxuXG5cdFx0XCJsdFwiOiBjcmVhdGVQb3NpdGlvbmFsUHNldWRvKCBmdW5jdGlvbiggbWF0Y2hJbmRleGVzLCBsZW5ndGgsIGFyZ3VtZW50ICkge1xuXHRcdFx0dmFyIGkgPSBhcmd1bWVudCA8IDAgP1xuXHRcdFx0XHRhcmd1bWVudCArIGxlbmd0aCA6XG5cdFx0XHRcdGFyZ3VtZW50ID4gbGVuZ3RoID9cblx0XHRcdFx0XHRsZW5ndGggOlxuXHRcdFx0XHRcdGFyZ3VtZW50O1xuXHRcdFx0Zm9yICggOyAtLWkgPj0gMDsgKSB7XG5cdFx0XHRcdG1hdGNoSW5kZXhlcy5wdXNoKCBpICk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gbWF0Y2hJbmRleGVzO1xuXHRcdH0gKSxcblxuXHRcdFwiZ3RcIjogY3JlYXRlUG9zaXRpb25hbFBzZXVkbyggZnVuY3Rpb24oIG1hdGNoSW5kZXhlcywgbGVuZ3RoLCBhcmd1bWVudCApIHtcblx0XHRcdHZhciBpID0gYXJndW1lbnQgPCAwID8gYXJndW1lbnQgKyBsZW5ndGggOiBhcmd1bWVudDtcblx0XHRcdGZvciAoIDsgKytpIDwgbGVuZ3RoOyApIHtcblx0XHRcdFx0bWF0Y2hJbmRleGVzLnB1c2goIGkgKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBtYXRjaEluZGV4ZXM7XG5cdFx0fSApXG5cdH1cbn07XG5cbkV4cHIucHNldWRvc1sgXCJudGhcIiBdID0gRXhwci5wc2V1ZG9zWyBcImVxXCIgXTtcblxuLy8gQWRkIGJ1dHRvbi9pbnB1dCB0eXBlIHBzZXVkb3NcbmZvciAoIGkgaW4geyByYWRpbzogdHJ1ZSwgY2hlY2tib3g6IHRydWUsIGZpbGU6IHRydWUsIHBhc3N3b3JkOiB0cnVlLCBpbWFnZTogdHJ1ZSB9ICkge1xuXHRFeHByLnBzZXVkb3NbIGkgXSA9IGNyZWF0ZUlucHV0UHNldWRvKCBpICk7XG59XG5mb3IgKCBpIGluIHsgc3VibWl0OiB0cnVlLCByZXNldDogdHJ1ZSB9ICkge1xuXHRFeHByLnBzZXVkb3NbIGkgXSA9IGNyZWF0ZUJ1dHRvblBzZXVkbyggaSApO1xufVxuXG4vLyBFYXN5IEFQSSBmb3IgY3JlYXRpbmcgbmV3IHNldEZpbHRlcnNcbmZ1bmN0aW9uIHNldEZpbHRlcnMoKSB7fVxuc2V0RmlsdGVycy5wcm90b3R5cGUgPSBFeHByLmZpbHRlcnMgPSBFeHByLnBzZXVkb3M7XG5FeHByLnNldEZpbHRlcnMgPSBuZXcgc2V0RmlsdGVycygpO1xuXG50b2tlbml6ZSA9IFNpenpsZS50b2tlbml6ZSA9IGZ1bmN0aW9uKCBzZWxlY3RvciwgcGFyc2VPbmx5ICkge1xuXHR2YXIgbWF0Y2hlZCwgbWF0Y2gsIHRva2VucywgdHlwZSxcblx0XHRzb0ZhciwgZ3JvdXBzLCBwcmVGaWx0ZXJzLFxuXHRcdGNhY2hlZCA9IHRva2VuQ2FjaGVbIHNlbGVjdG9yICsgXCIgXCIgXTtcblxuXHRpZiAoIGNhY2hlZCApIHtcblx0XHRyZXR1cm4gcGFyc2VPbmx5ID8gMCA6IGNhY2hlZC5zbGljZSggMCApO1xuXHR9XG5cblx0c29GYXIgPSBzZWxlY3Rvcjtcblx0Z3JvdXBzID0gW107XG5cdHByZUZpbHRlcnMgPSBFeHByLnByZUZpbHRlcjtcblxuXHR3aGlsZSAoIHNvRmFyICkge1xuXG5cdFx0Ly8gQ29tbWEgYW5kIGZpcnN0IHJ1blxuXHRcdGlmICggIW1hdGNoZWQgfHwgKCBtYXRjaCA9IHJjb21tYS5leGVjKCBzb0ZhciApICkgKSB7XG5cdFx0XHRpZiAoIG1hdGNoICkge1xuXG5cdFx0XHRcdC8vIERvbid0IGNvbnN1bWUgdHJhaWxpbmcgY29tbWFzIGFzIHZhbGlkXG5cdFx0XHRcdHNvRmFyID0gc29GYXIuc2xpY2UoIG1hdGNoWyAwIF0ubGVuZ3RoICkgfHwgc29GYXI7XG5cdFx0XHR9XG5cdFx0XHRncm91cHMucHVzaCggKCB0b2tlbnMgPSBbXSApICk7XG5cdFx0fVxuXG5cdFx0bWF0Y2hlZCA9IGZhbHNlO1xuXG5cdFx0Ly8gQ29tYmluYXRvcnNcblx0XHRpZiAoICggbWF0Y2ggPSByY29tYmluYXRvcnMuZXhlYyggc29GYXIgKSApICkge1xuXHRcdFx0bWF0Y2hlZCA9IG1hdGNoLnNoaWZ0KCk7XG5cdFx0XHR0b2tlbnMucHVzaCgge1xuXHRcdFx0XHR2YWx1ZTogbWF0Y2hlZCxcblxuXHRcdFx0XHQvLyBDYXN0IGRlc2NlbmRhbnQgY29tYmluYXRvcnMgdG8gc3BhY2Vcblx0XHRcdFx0dHlwZTogbWF0Y2hbIDAgXS5yZXBsYWNlKCBydHJpbSwgXCIgXCIgKVxuXHRcdFx0fSApO1xuXHRcdFx0c29GYXIgPSBzb0Zhci5zbGljZSggbWF0Y2hlZC5sZW5ndGggKTtcblx0XHR9XG5cblx0XHQvLyBGaWx0ZXJzXG5cdFx0Zm9yICggdHlwZSBpbiBFeHByLmZpbHRlciApIHtcblx0XHRcdGlmICggKCBtYXRjaCA9IG1hdGNoRXhwclsgdHlwZSBdLmV4ZWMoIHNvRmFyICkgKSAmJiAoICFwcmVGaWx0ZXJzWyB0eXBlIF0gfHxcblx0XHRcdFx0KCBtYXRjaCA9IHByZUZpbHRlcnNbIHR5cGUgXSggbWF0Y2ggKSApICkgKSB7XG5cdFx0XHRcdG1hdGNoZWQgPSBtYXRjaC5zaGlmdCgpO1xuXHRcdFx0XHR0b2tlbnMucHVzaCgge1xuXHRcdFx0XHRcdHZhbHVlOiBtYXRjaGVkLFxuXHRcdFx0XHRcdHR5cGU6IHR5cGUsXG5cdFx0XHRcdFx0bWF0Y2hlczogbWF0Y2hcblx0XHRcdFx0fSApO1xuXHRcdFx0XHRzb0ZhciA9IHNvRmFyLnNsaWNlKCBtYXRjaGVkLmxlbmd0aCApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmICggIW1hdGNoZWQgKSB7XG5cdFx0XHRicmVhaztcblx0XHR9XG5cdH1cblxuXHQvLyBSZXR1cm4gdGhlIGxlbmd0aCBvZiB0aGUgaW52YWxpZCBleGNlc3Ncblx0Ly8gaWYgd2UncmUganVzdCBwYXJzaW5nXG5cdC8vIE90aGVyd2lzZSwgdGhyb3cgYW4gZXJyb3Igb3IgcmV0dXJuIHRva2Vuc1xuXHRyZXR1cm4gcGFyc2VPbmx5ID9cblx0XHRzb0Zhci5sZW5ndGggOlxuXHRcdHNvRmFyID9cblx0XHRcdFNpenpsZS5lcnJvciggc2VsZWN0b3IgKSA6XG5cblx0XHRcdC8vIENhY2hlIHRoZSB0b2tlbnNcblx0XHRcdHRva2VuQ2FjaGUoIHNlbGVjdG9yLCBncm91cHMgKS5zbGljZSggMCApO1xufTtcblxuZnVuY3Rpb24gdG9TZWxlY3RvciggdG9rZW5zICkge1xuXHR2YXIgaSA9IDAsXG5cdFx0bGVuID0gdG9rZW5zLmxlbmd0aCxcblx0XHRzZWxlY3RvciA9IFwiXCI7XG5cdGZvciAoIDsgaSA8IGxlbjsgaSsrICkge1xuXHRcdHNlbGVjdG9yICs9IHRva2Vuc1sgaSBdLnZhbHVlO1xuXHR9XG5cdHJldHVybiBzZWxlY3Rvcjtcbn1cblxuZnVuY3Rpb24gYWRkQ29tYmluYXRvciggbWF0Y2hlciwgY29tYmluYXRvciwgYmFzZSApIHtcblx0dmFyIGRpciA9IGNvbWJpbmF0b3IuZGlyLFxuXHRcdHNraXAgPSBjb21iaW5hdG9yLm5leHQsXG5cdFx0a2V5ID0gc2tpcCB8fCBkaXIsXG5cdFx0Y2hlY2tOb25FbGVtZW50cyA9IGJhc2UgJiYga2V5ID09PSBcInBhcmVudE5vZGVcIixcblx0XHRkb25lTmFtZSA9IGRvbmUrKztcblxuXHRyZXR1cm4gY29tYmluYXRvci5maXJzdCA/XG5cblx0XHQvLyBDaGVjayBhZ2FpbnN0IGNsb3Nlc3QgYW5jZXN0b3IvcHJlY2VkaW5nIGVsZW1lbnRcblx0XHRmdW5jdGlvbiggZWxlbSwgY29udGV4dCwgeG1sICkge1xuXHRcdFx0d2hpbGUgKCAoIGVsZW0gPSBlbGVtWyBkaXIgXSApICkge1xuXHRcdFx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDEgfHwgY2hlY2tOb25FbGVtZW50cyApIHtcblx0XHRcdFx0XHRyZXR1cm4gbWF0Y2hlciggZWxlbSwgY29udGV4dCwgeG1sICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9IDpcblxuXHRcdC8vIENoZWNrIGFnYWluc3QgYWxsIGFuY2VzdG9yL3ByZWNlZGluZyBlbGVtZW50c1xuXHRcdGZ1bmN0aW9uKCBlbGVtLCBjb250ZXh0LCB4bWwgKSB7XG5cdFx0XHR2YXIgb2xkQ2FjaGUsIHVuaXF1ZUNhY2hlLCBvdXRlckNhY2hlLFxuXHRcdFx0XHRuZXdDYWNoZSA9IFsgZGlycnVucywgZG9uZU5hbWUgXTtcblxuXHRcdFx0Ly8gV2UgY2FuJ3Qgc2V0IGFyYml0cmFyeSBkYXRhIG9uIFhNTCBub2Rlcywgc28gdGhleSBkb24ndCBiZW5lZml0IGZyb20gY29tYmluYXRvciBjYWNoaW5nXG5cdFx0XHRpZiAoIHhtbCApIHtcblx0XHRcdFx0d2hpbGUgKCAoIGVsZW0gPSBlbGVtWyBkaXIgXSApICkge1xuXHRcdFx0XHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSB8fCBjaGVja05vbkVsZW1lbnRzICkge1xuXHRcdFx0XHRcdFx0aWYgKCBtYXRjaGVyKCBlbGVtLCBjb250ZXh0LCB4bWwgKSApIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR3aGlsZSAoICggZWxlbSA9IGVsZW1bIGRpciBdICkgKSB7XG5cdFx0XHRcdFx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSAxIHx8IGNoZWNrTm9uRWxlbWVudHMgKSB7XG5cdFx0XHRcdFx0XHRvdXRlckNhY2hlID0gZWxlbVsgZXhwYW5kbyBdIHx8ICggZWxlbVsgZXhwYW5kbyBdID0ge30gKTtcblxuXHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgPDkgb25seVxuXHRcdFx0XHRcdFx0Ly8gRGVmZW5kIGFnYWluc3QgY2xvbmVkIGF0dHJvcGVydGllcyAoalF1ZXJ5IGdoLTE3MDkpXG5cdFx0XHRcdFx0XHR1bmlxdWVDYWNoZSA9IG91dGVyQ2FjaGVbIGVsZW0udW5pcXVlSUQgXSB8fFxuXHRcdFx0XHRcdFx0XHQoIG91dGVyQ2FjaGVbIGVsZW0udW5pcXVlSUQgXSA9IHt9ICk7XG5cblx0XHRcdFx0XHRcdGlmICggc2tpcCAmJiBza2lwID09PSBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgKSB7XG5cdFx0XHRcdFx0XHRcdGVsZW0gPSBlbGVtWyBkaXIgXSB8fCBlbGVtO1xuXHRcdFx0XHRcdFx0fSBlbHNlIGlmICggKCBvbGRDYWNoZSA9IHVuaXF1ZUNhY2hlWyBrZXkgXSApICYmXG5cdFx0XHRcdFx0XHRcdG9sZENhY2hlWyAwIF0gPT09IGRpcnJ1bnMgJiYgb2xkQ2FjaGVbIDEgXSA9PT0gZG9uZU5hbWUgKSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gQXNzaWduIHRvIG5ld0NhY2hlIHNvIHJlc3VsdHMgYmFjay1wcm9wYWdhdGUgdG8gcHJldmlvdXMgZWxlbWVudHNcblx0XHRcdFx0XHRcdFx0cmV0dXJuICggbmV3Q2FjaGVbIDIgXSA9IG9sZENhY2hlWyAyIF0gKTtcblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gUmV1c2UgbmV3Y2FjaGUgc28gcmVzdWx0cyBiYWNrLXByb3BhZ2F0ZSB0byBwcmV2aW91cyBlbGVtZW50c1xuXHRcdFx0XHRcdFx0XHR1bmlxdWVDYWNoZVsga2V5IF0gPSBuZXdDYWNoZTtcblxuXHRcdFx0XHRcdFx0XHQvLyBBIG1hdGNoIG1lYW5zIHdlJ3JlIGRvbmU7IGEgZmFpbCBtZWFucyB3ZSBoYXZlIHRvIGtlZXAgY2hlY2tpbmdcblx0XHRcdFx0XHRcdFx0aWYgKCAoIG5ld0NhY2hlWyAyIF0gPSBtYXRjaGVyKCBlbGVtLCBjb250ZXh0LCB4bWwgKSApICkge1xuXHRcdFx0XHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fTtcbn1cblxuZnVuY3Rpb24gZWxlbWVudE1hdGNoZXIoIG1hdGNoZXJzICkge1xuXHRyZXR1cm4gbWF0Y2hlcnMubGVuZ3RoID4gMSA/XG5cdFx0ZnVuY3Rpb24oIGVsZW0sIGNvbnRleHQsIHhtbCApIHtcblx0XHRcdHZhciBpID0gbWF0Y2hlcnMubGVuZ3RoO1xuXHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdGlmICggIW1hdGNoZXJzWyBpIF0oIGVsZW0sIGNvbnRleHQsIHhtbCApICkge1xuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fSA6XG5cdFx0bWF0Y2hlcnNbIDAgXTtcbn1cblxuZnVuY3Rpb24gbXVsdGlwbGVDb250ZXh0cyggc2VsZWN0b3IsIGNvbnRleHRzLCByZXN1bHRzICkge1xuXHR2YXIgaSA9IDAsXG5cdFx0bGVuID0gY29udGV4dHMubGVuZ3RoO1xuXHRmb3IgKCA7IGkgPCBsZW47IGkrKyApIHtcblx0XHRTaXp6bGUoIHNlbGVjdG9yLCBjb250ZXh0c1sgaSBdLCByZXN1bHRzICk7XG5cdH1cblx0cmV0dXJuIHJlc3VsdHM7XG59XG5cbmZ1bmN0aW9uIGNvbmRlbnNlKCB1bm1hdGNoZWQsIG1hcCwgZmlsdGVyLCBjb250ZXh0LCB4bWwgKSB7XG5cdHZhciBlbGVtLFxuXHRcdG5ld1VubWF0Y2hlZCA9IFtdLFxuXHRcdGkgPSAwLFxuXHRcdGxlbiA9IHVubWF0Y2hlZC5sZW5ndGgsXG5cdFx0bWFwcGVkID0gbWFwICE9IG51bGw7XG5cblx0Zm9yICggOyBpIDwgbGVuOyBpKysgKSB7XG5cdFx0aWYgKCAoIGVsZW0gPSB1bm1hdGNoZWRbIGkgXSApICkge1xuXHRcdFx0aWYgKCAhZmlsdGVyIHx8IGZpbHRlciggZWxlbSwgY29udGV4dCwgeG1sICkgKSB7XG5cdFx0XHRcdG5ld1VubWF0Y2hlZC5wdXNoKCBlbGVtICk7XG5cdFx0XHRcdGlmICggbWFwcGVkICkge1xuXHRcdFx0XHRcdG1hcC5wdXNoKCBpICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gbmV3VW5tYXRjaGVkO1xufVxuXG5mdW5jdGlvbiBzZXRNYXRjaGVyKCBwcmVGaWx0ZXIsIHNlbGVjdG9yLCBtYXRjaGVyLCBwb3N0RmlsdGVyLCBwb3N0RmluZGVyLCBwb3N0U2VsZWN0b3IgKSB7XG5cdGlmICggcG9zdEZpbHRlciAmJiAhcG9zdEZpbHRlclsgZXhwYW5kbyBdICkge1xuXHRcdHBvc3RGaWx0ZXIgPSBzZXRNYXRjaGVyKCBwb3N0RmlsdGVyICk7XG5cdH1cblx0aWYgKCBwb3N0RmluZGVyICYmICFwb3N0RmluZGVyWyBleHBhbmRvIF0gKSB7XG5cdFx0cG9zdEZpbmRlciA9IHNldE1hdGNoZXIoIHBvc3RGaW5kZXIsIHBvc3RTZWxlY3RvciApO1xuXHR9XG5cdHJldHVybiBtYXJrRnVuY3Rpb24oIGZ1bmN0aW9uKCBzZWVkLCByZXN1bHRzLCBjb250ZXh0LCB4bWwgKSB7XG5cdFx0dmFyIHRlbXAsIGksIGVsZW0sXG5cdFx0XHRwcmVNYXAgPSBbXSxcblx0XHRcdHBvc3RNYXAgPSBbXSxcblx0XHRcdHByZWV4aXN0aW5nID0gcmVzdWx0cy5sZW5ndGgsXG5cblx0XHRcdC8vIEdldCBpbml0aWFsIGVsZW1lbnRzIGZyb20gc2VlZCBvciBjb250ZXh0XG5cdFx0XHRlbGVtcyA9IHNlZWQgfHwgbXVsdGlwbGVDb250ZXh0cyhcblx0XHRcdFx0c2VsZWN0b3IgfHwgXCIqXCIsXG5cdFx0XHRcdGNvbnRleHQubm9kZVR5cGUgPyBbIGNvbnRleHQgXSA6IGNvbnRleHQsXG5cdFx0XHRcdFtdXG5cdFx0XHQpLFxuXG5cdFx0XHQvLyBQcmVmaWx0ZXIgdG8gZ2V0IG1hdGNoZXIgaW5wdXQsIHByZXNlcnZpbmcgYSBtYXAgZm9yIHNlZWQtcmVzdWx0cyBzeW5jaHJvbml6YXRpb25cblx0XHRcdG1hdGNoZXJJbiA9IHByZUZpbHRlciAmJiAoIHNlZWQgfHwgIXNlbGVjdG9yICkgP1xuXHRcdFx0XHRjb25kZW5zZSggZWxlbXMsIHByZU1hcCwgcHJlRmlsdGVyLCBjb250ZXh0LCB4bWwgKSA6XG5cdFx0XHRcdGVsZW1zLFxuXG5cdFx0XHRtYXRjaGVyT3V0ID0gbWF0Y2hlciA/XG5cblx0XHRcdFx0Ly8gSWYgd2UgaGF2ZSBhIHBvc3RGaW5kZXIsIG9yIGZpbHRlcmVkIHNlZWQsIG9yIG5vbi1zZWVkIHBvc3RGaWx0ZXIgb3IgcHJlZXhpc3RpbmcgcmVzdWx0cyxcblx0XHRcdFx0cG9zdEZpbmRlciB8fCAoIHNlZWQgPyBwcmVGaWx0ZXIgOiBwcmVleGlzdGluZyB8fCBwb3N0RmlsdGVyICkgP1xuXG5cdFx0XHRcdFx0Ly8gLi4uaW50ZXJtZWRpYXRlIHByb2Nlc3NpbmcgaXMgbmVjZXNzYXJ5XG5cdFx0XHRcdFx0W10gOlxuXG5cdFx0XHRcdFx0Ly8gLi4ub3RoZXJ3aXNlIHVzZSByZXN1bHRzIGRpcmVjdGx5XG5cdFx0XHRcdFx0cmVzdWx0cyA6XG5cdFx0XHRcdG1hdGNoZXJJbjtcblxuXHRcdC8vIEZpbmQgcHJpbWFyeSBtYXRjaGVzXG5cdFx0aWYgKCBtYXRjaGVyICkge1xuXHRcdFx0bWF0Y2hlciggbWF0Y2hlckluLCBtYXRjaGVyT3V0LCBjb250ZXh0LCB4bWwgKTtcblx0XHR9XG5cblx0XHQvLyBBcHBseSBwb3N0RmlsdGVyXG5cdFx0aWYgKCBwb3N0RmlsdGVyICkge1xuXHRcdFx0dGVtcCA9IGNvbmRlbnNlKCBtYXRjaGVyT3V0LCBwb3N0TWFwICk7XG5cdFx0XHRwb3N0RmlsdGVyKCB0ZW1wLCBbXSwgY29udGV4dCwgeG1sICk7XG5cblx0XHRcdC8vIFVuLW1hdGNoIGZhaWxpbmcgZWxlbWVudHMgYnkgbW92aW5nIHRoZW0gYmFjayB0byBtYXRjaGVySW5cblx0XHRcdGkgPSB0ZW1wLmxlbmd0aDtcblx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRpZiAoICggZWxlbSA9IHRlbXBbIGkgXSApICkge1xuXHRcdFx0XHRcdG1hdGNoZXJPdXRbIHBvc3RNYXBbIGkgXSBdID0gISggbWF0Y2hlckluWyBwb3N0TWFwWyBpIF0gXSA9IGVsZW0gKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmICggc2VlZCApIHtcblx0XHRcdGlmICggcG9zdEZpbmRlciB8fCBwcmVGaWx0ZXIgKSB7XG5cdFx0XHRcdGlmICggcG9zdEZpbmRlciApIHtcblxuXHRcdFx0XHRcdC8vIEdldCB0aGUgZmluYWwgbWF0Y2hlck91dCBieSBjb25kZW5zaW5nIHRoaXMgaW50ZXJtZWRpYXRlIGludG8gcG9zdEZpbmRlciBjb250ZXh0c1xuXHRcdFx0XHRcdHRlbXAgPSBbXTtcblx0XHRcdFx0XHRpID0gbWF0Y2hlck91dC5sZW5ndGg7XG5cdFx0XHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdFx0XHRpZiAoICggZWxlbSA9IG1hdGNoZXJPdXRbIGkgXSApICkge1xuXG5cdFx0XHRcdFx0XHRcdC8vIFJlc3RvcmUgbWF0Y2hlckluIHNpbmNlIGVsZW0gaXMgbm90IHlldCBhIGZpbmFsIG1hdGNoXG5cdFx0XHRcdFx0XHRcdHRlbXAucHVzaCggKCBtYXRjaGVySW5bIGkgXSA9IGVsZW0gKSApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRwb3N0RmluZGVyKCBudWxsLCAoIG1hdGNoZXJPdXQgPSBbXSApLCB0ZW1wLCB4bWwgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIE1vdmUgbWF0Y2hlZCBlbGVtZW50cyBmcm9tIHNlZWQgdG8gcmVzdWx0cyB0byBrZWVwIHRoZW0gc3luY2hyb25pemVkXG5cdFx0XHRcdGkgPSBtYXRjaGVyT3V0Lmxlbmd0aDtcblx0XHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdFx0aWYgKCAoIGVsZW0gPSBtYXRjaGVyT3V0WyBpIF0gKSAmJlxuXHRcdFx0XHRcdFx0KCB0ZW1wID0gcG9zdEZpbmRlciA/IGluZGV4T2YoIHNlZWQsIGVsZW0gKSA6IHByZU1hcFsgaSBdICkgPiAtMSApIHtcblxuXHRcdFx0XHRcdFx0c2VlZFsgdGVtcCBdID0gISggcmVzdWx0c1sgdGVtcCBdID0gZWxlbSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0Ly8gQWRkIGVsZW1lbnRzIHRvIHJlc3VsdHMsIHRocm91Z2ggcG9zdEZpbmRlciBpZiBkZWZpbmVkXG5cdFx0fSBlbHNlIHtcblx0XHRcdG1hdGNoZXJPdXQgPSBjb25kZW5zZShcblx0XHRcdFx0bWF0Y2hlck91dCA9PT0gcmVzdWx0cyA/XG5cdFx0XHRcdFx0bWF0Y2hlck91dC5zcGxpY2UoIHByZWV4aXN0aW5nLCBtYXRjaGVyT3V0Lmxlbmd0aCApIDpcblx0XHRcdFx0XHRtYXRjaGVyT3V0XG5cdFx0XHQpO1xuXHRcdFx0aWYgKCBwb3N0RmluZGVyICkge1xuXHRcdFx0XHRwb3N0RmluZGVyKCBudWxsLCByZXN1bHRzLCBtYXRjaGVyT3V0LCB4bWwgKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHB1c2guYXBwbHkoIHJlc3VsdHMsIG1hdGNoZXJPdXQgKTtcblx0XHRcdH1cblx0XHR9XG5cdH0gKTtcbn1cblxuZnVuY3Rpb24gbWF0Y2hlckZyb21Ub2tlbnMoIHRva2VucyApIHtcblx0dmFyIGNoZWNrQ29udGV4dCwgbWF0Y2hlciwgaixcblx0XHRsZW4gPSB0b2tlbnMubGVuZ3RoLFxuXHRcdGxlYWRpbmdSZWxhdGl2ZSA9IEV4cHIucmVsYXRpdmVbIHRva2Vuc1sgMCBdLnR5cGUgXSxcblx0XHRpbXBsaWNpdFJlbGF0aXZlID0gbGVhZGluZ1JlbGF0aXZlIHx8IEV4cHIucmVsYXRpdmVbIFwiIFwiIF0sXG5cdFx0aSA9IGxlYWRpbmdSZWxhdGl2ZSA/IDEgOiAwLFxuXG5cdFx0Ly8gVGhlIGZvdW5kYXRpb25hbCBtYXRjaGVyIGVuc3VyZXMgdGhhdCBlbGVtZW50cyBhcmUgcmVhY2hhYmxlIGZyb20gdG9wLWxldmVsIGNvbnRleHQocylcblx0XHRtYXRjaENvbnRleHQgPSBhZGRDb21iaW5hdG9yKCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiBlbGVtID09PSBjaGVja0NvbnRleHQ7XG5cdFx0fSwgaW1wbGljaXRSZWxhdGl2ZSwgdHJ1ZSApLFxuXHRcdG1hdGNoQW55Q29udGV4dCA9IGFkZENvbWJpbmF0b3IoIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuIGluZGV4T2YoIGNoZWNrQ29udGV4dCwgZWxlbSApID4gLTE7XG5cdFx0fSwgaW1wbGljaXRSZWxhdGl2ZSwgdHJ1ZSApLFxuXHRcdG1hdGNoZXJzID0gWyBmdW5jdGlvbiggZWxlbSwgY29udGV4dCwgeG1sICkge1xuXHRcdFx0dmFyIHJldCA9ICggIWxlYWRpbmdSZWxhdGl2ZSAmJiAoIHhtbCB8fCBjb250ZXh0ICE9PSBvdXRlcm1vc3RDb250ZXh0ICkgKSB8fCAoXG5cdFx0XHRcdCggY2hlY2tDb250ZXh0ID0gY29udGV4dCApLm5vZGVUeXBlID9cblx0XHRcdFx0XHRtYXRjaENvbnRleHQoIGVsZW0sIGNvbnRleHQsIHhtbCApIDpcblx0XHRcdFx0XHRtYXRjaEFueUNvbnRleHQoIGVsZW0sIGNvbnRleHQsIHhtbCApICk7XG5cblx0XHRcdC8vIEF2b2lkIGhhbmdpbmcgb250byBlbGVtZW50IChpc3N1ZSAjMjk5KVxuXHRcdFx0Y2hlY2tDb250ZXh0ID0gbnVsbDtcblx0XHRcdHJldHVybiByZXQ7XG5cdFx0fSBdO1xuXG5cdGZvciAoIDsgaSA8IGxlbjsgaSsrICkge1xuXHRcdGlmICggKCBtYXRjaGVyID0gRXhwci5yZWxhdGl2ZVsgdG9rZW5zWyBpIF0udHlwZSBdICkgKSB7XG5cdFx0XHRtYXRjaGVycyA9IFsgYWRkQ29tYmluYXRvciggZWxlbWVudE1hdGNoZXIoIG1hdGNoZXJzICksIG1hdGNoZXIgKSBdO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRtYXRjaGVyID0gRXhwci5maWx0ZXJbIHRva2Vuc1sgaSBdLnR5cGUgXS5hcHBseSggbnVsbCwgdG9rZW5zWyBpIF0ubWF0Y2hlcyApO1xuXG5cdFx0XHQvLyBSZXR1cm4gc3BlY2lhbCB1cG9uIHNlZWluZyBhIHBvc2l0aW9uYWwgbWF0Y2hlclxuXHRcdFx0aWYgKCBtYXRjaGVyWyBleHBhbmRvIF0gKSB7XG5cblx0XHRcdFx0Ly8gRmluZCB0aGUgbmV4dCByZWxhdGl2ZSBvcGVyYXRvciAoaWYgYW55KSBmb3IgcHJvcGVyIGhhbmRsaW5nXG5cdFx0XHRcdGogPSArK2k7XG5cdFx0XHRcdGZvciAoIDsgaiA8IGxlbjsgaisrICkge1xuXHRcdFx0XHRcdGlmICggRXhwci5yZWxhdGl2ZVsgdG9rZW5zWyBqIF0udHlwZSBdICkge1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBzZXRNYXRjaGVyKFxuXHRcdFx0XHRcdGkgPiAxICYmIGVsZW1lbnRNYXRjaGVyKCBtYXRjaGVycyApLFxuXHRcdFx0XHRcdGkgPiAxICYmIHRvU2VsZWN0b3IoXG5cblx0XHRcdFx0XHQvLyBJZiB0aGUgcHJlY2VkaW5nIHRva2VuIHdhcyBhIGRlc2NlbmRhbnQgY29tYmluYXRvciwgaW5zZXJ0IGFuIGltcGxpY2l0IGFueS1lbGVtZW50IGAqYFxuXHRcdFx0XHRcdHRva2Vuc1xuXHRcdFx0XHRcdFx0LnNsaWNlKCAwLCBpIC0gMSApXG5cdFx0XHRcdFx0XHQuY29uY2F0KCB7IHZhbHVlOiB0b2tlbnNbIGkgLSAyIF0udHlwZSA9PT0gXCIgXCIgPyBcIipcIiA6IFwiXCIgfSApXG5cdFx0XHRcdFx0KS5yZXBsYWNlKCBydHJpbSwgXCIkMVwiICksXG5cdFx0XHRcdFx0bWF0Y2hlcixcblx0XHRcdFx0XHRpIDwgaiAmJiBtYXRjaGVyRnJvbVRva2VucyggdG9rZW5zLnNsaWNlKCBpLCBqICkgKSxcblx0XHRcdFx0XHRqIDwgbGVuICYmIG1hdGNoZXJGcm9tVG9rZW5zKCAoIHRva2VucyA9IHRva2Vucy5zbGljZSggaiApICkgKSxcblx0XHRcdFx0XHRqIDwgbGVuICYmIHRvU2VsZWN0b3IoIHRva2VucyApXG5cdFx0XHRcdCk7XG5cdFx0XHR9XG5cdFx0XHRtYXRjaGVycy5wdXNoKCBtYXRjaGVyICk7XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIGVsZW1lbnRNYXRjaGVyKCBtYXRjaGVycyApO1xufVxuXG5mdW5jdGlvbiBtYXRjaGVyRnJvbUdyb3VwTWF0Y2hlcnMoIGVsZW1lbnRNYXRjaGVycywgc2V0TWF0Y2hlcnMgKSB7XG5cdHZhciBieVNldCA9IHNldE1hdGNoZXJzLmxlbmd0aCA+IDAsXG5cdFx0YnlFbGVtZW50ID0gZWxlbWVudE1hdGNoZXJzLmxlbmd0aCA+IDAsXG5cdFx0c3VwZXJNYXRjaGVyID0gZnVuY3Rpb24oIHNlZWQsIGNvbnRleHQsIHhtbCwgcmVzdWx0cywgb3V0ZXJtb3N0ICkge1xuXHRcdFx0dmFyIGVsZW0sIGosIG1hdGNoZXIsXG5cdFx0XHRcdG1hdGNoZWRDb3VudCA9IDAsXG5cdFx0XHRcdGkgPSBcIjBcIixcblx0XHRcdFx0dW5tYXRjaGVkID0gc2VlZCAmJiBbXSxcblx0XHRcdFx0c2V0TWF0Y2hlZCA9IFtdLFxuXHRcdFx0XHRjb250ZXh0QmFja3VwID0gb3V0ZXJtb3N0Q29udGV4dCxcblxuXHRcdFx0XHQvLyBXZSBtdXN0IGFsd2F5cyBoYXZlIGVpdGhlciBzZWVkIGVsZW1lbnRzIG9yIG91dGVybW9zdCBjb250ZXh0XG5cdFx0XHRcdGVsZW1zID0gc2VlZCB8fCBieUVsZW1lbnQgJiYgRXhwci5maW5kWyBcIlRBR1wiIF0oIFwiKlwiLCBvdXRlcm1vc3QgKSxcblxuXHRcdFx0XHQvLyBVc2UgaW50ZWdlciBkaXJydW5zIGlmZiB0aGlzIGlzIHRoZSBvdXRlcm1vc3QgbWF0Y2hlclxuXHRcdFx0XHRkaXJydW5zVW5pcXVlID0gKCBkaXJydW5zICs9IGNvbnRleHRCYWNrdXAgPT0gbnVsbCA/IDEgOiBNYXRoLnJhbmRvbSgpIHx8IDAuMSApLFxuXHRcdFx0XHRsZW4gPSBlbGVtcy5sZW5ndGg7XG5cblx0XHRcdGlmICggb3V0ZXJtb3N0ICkge1xuXG5cdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDExKywgRWRnZSAxNyAtIDE4K1xuXHRcdFx0XHQvLyBJRS9FZGdlIHNvbWV0aW1lcyB0aHJvdyBhIFwiUGVybWlzc2lvbiBkZW5pZWRcIiBlcnJvciB3aGVuIHN0cmljdC1jb21wYXJpbmdcblx0XHRcdFx0Ly8gdHdvIGRvY3VtZW50czsgc2hhbGxvdyBjb21wYXJpc29ucyB3b3JrLlxuXHRcdFx0XHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXFlcWVxXG5cdFx0XHRcdG91dGVybW9zdENvbnRleHQgPSBjb250ZXh0ID09IGRvY3VtZW50IHx8IGNvbnRleHQgfHwgb3V0ZXJtb3N0O1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBBZGQgZWxlbWVudHMgcGFzc2luZyBlbGVtZW50TWF0Y2hlcnMgZGlyZWN0bHkgdG8gcmVzdWx0c1xuXHRcdFx0Ly8gU3VwcG9ydDogSUU8OSwgU2FmYXJpXG5cdFx0XHQvLyBUb2xlcmF0ZSBOb2RlTGlzdCBwcm9wZXJ0aWVzIChJRTogXCJsZW5ndGhcIjsgU2FmYXJpOiA8bnVtYmVyPikgbWF0Y2hpbmcgZWxlbWVudHMgYnkgaWRcblx0XHRcdGZvciAoIDsgaSAhPT0gbGVuICYmICggZWxlbSA9IGVsZW1zWyBpIF0gKSAhPSBudWxsOyBpKysgKSB7XG5cdFx0XHRcdGlmICggYnlFbGVtZW50ICYmIGVsZW0gKSB7XG5cdFx0XHRcdFx0aiA9IDA7XG5cblx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRSAxMSssIEVkZ2UgMTcgLSAxOCtcblx0XHRcdFx0XHQvLyBJRS9FZGdlIHNvbWV0aW1lcyB0aHJvdyBhIFwiUGVybWlzc2lvbiBkZW5pZWRcIiBlcnJvciB3aGVuIHN0cmljdC1jb21wYXJpbmdcblx0XHRcdFx0XHQvLyB0d28gZG9jdW1lbnRzOyBzaGFsbG93IGNvbXBhcmlzb25zIHdvcmsuXG5cdFx0XHRcdFx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVxZXFlcVxuXHRcdFx0XHRcdGlmICggIWNvbnRleHQgJiYgZWxlbS5vd25lckRvY3VtZW50ICE9IGRvY3VtZW50ICkge1xuXHRcdFx0XHRcdFx0c2V0RG9jdW1lbnQoIGVsZW0gKTtcblx0XHRcdFx0XHRcdHhtbCA9ICFkb2N1bWVudElzSFRNTDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0d2hpbGUgKCAoIG1hdGNoZXIgPSBlbGVtZW50TWF0Y2hlcnNbIGorKyBdICkgKSB7XG5cdFx0XHRcdFx0XHRpZiAoIG1hdGNoZXIoIGVsZW0sIGNvbnRleHQgfHwgZG9jdW1lbnQsIHhtbCApICkge1xuXHRcdFx0XHRcdFx0XHRyZXN1bHRzLnB1c2goIGVsZW0gKTtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmICggb3V0ZXJtb3N0ICkge1xuXHRcdFx0XHRcdFx0ZGlycnVucyA9IGRpcnJ1bnNVbmlxdWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gVHJhY2sgdW5tYXRjaGVkIGVsZW1lbnRzIGZvciBzZXQgZmlsdGVyc1xuXHRcdFx0XHRpZiAoIGJ5U2V0ICkge1xuXG5cdFx0XHRcdFx0Ly8gVGhleSB3aWxsIGhhdmUgZ29uZSB0aHJvdWdoIGFsbCBwb3NzaWJsZSBtYXRjaGVyc1xuXHRcdFx0XHRcdGlmICggKCBlbGVtID0gIW1hdGNoZXIgJiYgZWxlbSApICkge1xuXHRcdFx0XHRcdFx0bWF0Y2hlZENvdW50LS07XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gTGVuZ3RoZW4gdGhlIGFycmF5IGZvciBldmVyeSBlbGVtZW50LCBtYXRjaGVkIG9yIG5vdFxuXHRcdFx0XHRcdGlmICggc2VlZCApIHtcblx0XHRcdFx0XHRcdHVubWF0Y2hlZC5wdXNoKCBlbGVtICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIGBpYCBpcyBub3cgdGhlIGNvdW50IG9mIGVsZW1lbnRzIHZpc2l0ZWQgYWJvdmUsIGFuZCBhZGRpbmcgaXQgdG8gYG1hdGNoZWRDb3VudGBcblx0XHRcdC8vIG1ha2VzIHRoZSBsYXR0ZXIgbm9ubmVnYXRpdmUuXG5cdFx0XHRtYXRjaGVkQ291bnQgKz0gaTtcblxuXHRcdFx0Ly8gQXBwbHkgc2V0IGZpbHRlcnMgdG8gdW5tYXRjaGVkIGVsZW1lbnRzXG5cdFx0XHQvLyBOT1RFOiBUaGlzIGNhbiBiZSBza2lwcGVkIGlmIHRoZXJlIGFyZSBubyB1bm1hdGNoZWQgZWxlbWVudHMgKGkuZS4sIGBtYXRjaGVkQ291bnRgXG5cdFx0XHQvLyBlcXVhbHMgYGlgKSwgdW5sZXNzIHdlIGRpZG4ndCB2aXNpdCBfYW55XyBlbGVtZW50cyBpbiB0aGUgYWJvdmUgbG9vcCBiZWNhdXNlIHdlIGhhdmVcblx0XHRcdC8vIG5vIGVsZW1lbnQgbWF0Y2hlcnMgYW5kIG5vIHNlZWQuXG5cdFx0XHQvLyBJbmNyZW1lbnRpbmcgYW4gaW5pdGlhbGx5LXN0cmluZyBcIjBcIiBgaWAgYWxsb3dzIGBpYCB0byByZW1haW4gYSBzdHJpbmcgb25seSBpbiB0aGF0XG5cdFx0XHQvLyBjYXNlLCB3aGljaCB3aWxsIHJlc3VsdCBpbiBhIFwiMDBcIiBgbWF0Y2hlZENvdW50YCB0aGF0IGRpZmZlcnMgZnJvbSBgaWAgYnV0IGlzIGFsc29cblx0XHRcdC8vIG51bWVyaWNhbGx5IHplcm8uXG5cdFx0XHRpZiAoIGJ5U2V0ICYmIGkgIT09IG1hdGNoZWRDb3VudCApIHtcblx0XHRcdFx0aiA9IDA7XG5cdFx0XHRcdHdoaWxlICggKCBtYXRjaGVyID0gc2V0TWF0Y2hlcnNbIGorKyBdICkgKSB7XG5cdFx0XHRcdFx0bWF0Y2hlciggdW5tYXRjaGVkLCBzZXRNYXRjaGVkLCBjb250ZXh0LCB4bWwgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmICggc2VlZCApIHtcblxuXHRcdFx0XHRcdC8vIFJlaW50ZWdyYXRlIGVsZW1lbnQgbWF0Y2hlcyB0byBlbGltaW5hdGUgdGhlIG5lZWQgZm9yIHNvcnRpbmdcblx0XHRcdFx0XHRpZiAoIG1hdGNoZWRDb3VudCA+IDAgKSB7XG5cdFx0XHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0XHRcdFx0aWYgKCAhKCB1bm1hdGNoZWRbIGkgXSB8fCBzZXRNYXRjaGVkWyBpIF0gKSApIHtcblx0XHRcdFx0XHRcdFx0XHRzZXRNYXRjaGVkWyBpIF0gPSBwb3AuY2FsbCggcmVzdWx0cyApO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gRGlzY2FyZCBpbmRleCBwbGFjZWhvbGRlciB2YWx1ZXMgdG8gZ2V0IG9ubHkgYWN0dWFsIG1hdGNoZXNcblx0XHRcdFx0XHRzZXRNYXRjaGVkID0gY29uZGVuc2UoIHNldE1hdGNoZWQgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIEFkZCBtYXRjaGVzIHRvIHJlc3VsdHNcblx0XHRcdFx0cHVzaC5hcHBseSggcmVzdWx0cywgc2V0TWF0Y2hlZCApO1xuXG5cdFx0XHRcdC8vIFNlZWRsZXNzIHNldCBtYXRjaGVzIHN1Y2NlZWRpbmcgbXVsdGlwbGUgc3VjY2Vzc2Z1bCBtYXRjaGVycyBzdGlwdWxhdGUgc29ydGluZ1xuXHRcdFx0XHRpZiAoIG91dGVybW9zdCAmJiAhc2VlZCAmJiBzZXRNYXRjaGVkLmxlbmd0aCA+IDAgJiZcblx0XHRcdFx0XHQoIG1hdGNoZWRDb3VudCArIHNldE1hdGNoZXJzLmxlbmd0aCApID4gMSApIHtcblxuXHRcdFx0XHRcdFNpenpsZS51bmlxdWVTb3J0KCByZXN1bHRzICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gT3ZlcnJpZGUgbWFuaXB1bGF0aW9uIG9mIGdsb2JhbHMgYnkgbmVzdGVkIG1hdGNoZXJzXG5cdFx0XHRpZiAoIG91dGVybW9zdCApIHtcblx0XHRcdFx0ZGlycnVucyA9IGRpcnJ1bnNVbmlxdWU7XG5cdFx0XHRcdG91dGVybW9zdENvbnRleHQgPSBjb250ZXh0QmFja3VwO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdW5tYXRjaGVkO1xuXHRcdH07XG5cblx0cmV0dXJuIGJ5U2V0ID9cblx0XHRtYXJrRnVuY3Rpb24oIHN1cGVyTWF0Y2hlciApIDpcblx0XHRzdXBlck1hdGNoZXI7XG59XG5cbmNvbXBpbGUgPSBTaXp6bGUuY29tcGlsZSA9IGZ1bmN0aW9uKCBzZWxlY3RvciwgbWF0Y2ggLyogSW50ZXJuYWwgVXNlIE9ubHkgKi8gKSB7XG5cdHZhciBpLFxuXHRcdHNldE1hdGNoZXJzID0gW10sXG5cdFx0ZWxlbWVudE1hdGNoZXJzID0gW10sXG5cdFx0Y2FjaGVkID0gY29tcGlsZXJDYWNoZVsgc2VsZWN0b3IgKyBcIiBcIiBdO1xuXG5cdGlmICggIWNhY2hlZCApIHtcblxuXHRcdC8vIEdlbmVyYXRlIGEgZnVuY3Rpb24gb2YgcmVjdXJzaXZlIGZ1bmN0aW9ucyB0aGF0IGNhbiBiZSB1c2VkIHRvIGNoZWNrIGVhY2ggZWxlbWVudFxuXHRcdGlmICggIW1hdGNoICkge1xuXHRcdFx0bWF0Y2ggPSB0b2tlbml6ZSggc2VsZWN0b3IgKTtcblx0XHR9XG5cdFx0aSA9IG1hdGNoLmxlbmd0aDtcblx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdGNhY2hlZCA9IG1hdGNoZXJGcm9tVG9rZW5zKCBtYXRjaFsgaSBdICk7XG5cdFx0XHRpZiAoIGNhY2hlZFsgZXhwYW5kbyBdICkge1xuXHRcdFx0XHRzZXRNYXRjaGVycy5wdXNoKCBjYWNoZWQgKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGVsZW1lbnRNYXRjaGVycy5wdXNoKCBjYWNoZWQgKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBDYWNoZSB0aGUgY29tcGlsZWQgZnVuY3Rpb25cblx0XHRjYWNoZWQgPSBjb21waWxlckNhY2hlKFxuXHRcdFx0c2VsZWN0b3IsXG5cdFx0XHRtYXRjaGVyRnJvbUdyb3VwTWF0Y2hlcnMoIGVsZW1lbnRNYXRjaGVycywgc2V0TWF0Y2hlcnMgKVxuXHRcdCk7XG5cblx0XHQvLyBTYXZlIHNlbGVjdG9yIGFuZCB0b2tlbml6YXRpb25cblx0XHRjYWNoZWQuc2VsZWN0b3IgPSBzZWxlY3Rvcjtcblx0fVxuXHRyZXR1cm4gY2FjaGVkO1xufTtcblxuLyoqXG4gKiBBIGxvdy1sZXZlbCBzZWxlY3Rpb24gZnVuY3Rpb24gdGhhdCB3b3JrcyB3aXRoIFNpenpsZSdzIGNvbXBpbGVkXG4gKiAgc2VsZWN0b3IgZnVuY3Rpb25zXG4gKiBAcGFyYW0ge1N0cmluZ3xGdW5jdGlvbn0gc2VsZWN0b3IgQSBzZWxlY3RvciBvciBhIHByZS1jb21waWxlZFxuICogIHNlbGVjdG9yIGZ1bmN0aW9uIGJ1aWx0IHdpdGggU2l6emxlLmNvbXBpbGVcbiAqIEBwYXJhbSB7RWxlbWVudH0gY29udGV4dFxuICogQHBhcmFtIHtBcnJheX0gW3Jlc3VsdHNdXG4gKiBAcGFyYW0ge0FycmF5fSBbc2VlZF0gQSBzZXQgb2YgZWxlbWVudHMgdG8gbWF0Y2ggYWdhaW5zdFxuICovXG5zZWxlY3QgPSBTaXp6bGUuc2VsZWN0ID0gZnVuY3Rpb24oIHNlbGVjdG9yLCBjb250ZXh0LCByZXN1bHRzLCBzZWVkICkge1xuXHR2YXIgaSwgdG9rZW5zLCB0b2tlbiwgdHlwZSwgZmluZCxcblx0XHRjb21waWxlZCA9IHR5cGVvZiBzZWxlY3RvciA9PT0gXCJmdW5jdGlvblwiICYmIHNlbGVjdG9yLFxuXHRcdG1hdGNoID0gIXNlZWQgJiYgdG9rZW5pemUoICggc2VsZWN0b3IgPSBjb21waWxlZC5zZWxlY3RvciB8fCBzZWxlY3RvciApICk7XG5cblx0cmVzdWx0cyA9IHJlc3VsdHMgfHwgW107XG5cblx0Ly8gVHJ5IHRvIG1pbmltaXplIG9wZXJhdGlvbnMgaWYgdGhlcmUgaXMgb25seSBvbmUgc2VsZWN0b3IgaW4gdGhlIGxpc3QgYW5kIG5vIHNlZWRcblx0Ly8gKHRoZSBsYXR0ZXIgb2Ygd2hpY2ggZ3VhcmFudGVlcyB1cyBjb250ZXh0KVxuXHRpZiAoIG1hdGNoLmxlbmd0aCA9PT0gMSApIHtcblxuXHRcdC8vIFJlZHVjZSBjb250ZXh0IGlmIHRoZSBsZWFkaW5nIGNvbXBvdW5kIHNlbGVjdG9yIGlzIGFuIElEXG5cdFx0dG9rZW5zID0gbWF0Y2hbIDAgXSA9IG1hdGNoWyAwIF0uc2xpY2UoIDAgKTtcblx0XHRpZiAoIHRva2Vucy5sZW5ndGggPiAyICYmICggdG9rZW4gPSB0b2tlbnNbIDAgXSApLnR5cGUgPT09IFwiSURcIiAmJlxuXHRcdFx0Y29udGV4dC5ub2RlVHlwZSA9PT0gOSAmJiBkb2N1bWVudElzSFRNTCAmJiBFeHByLnJlbGF0aXZlWyB0b2tlbnNbIDEgXS50eXBlIF0gKSB7XG5cblx0XHRcdGNvbnRleHQgPSAoIEV4cHIuZmluZFsgXCJJRFwiIF0oIHRva2VuLm1hdGNoZXNbIDAgXVxuXHRcdFx0XHQucmVwbGFjZSggcnVuZXNjYXBlLCBmdW5lc2NhcGUgKSwgY29udGV4dCApIHx8IFtdIClbIDAgXTtcblx0XHRcdGlmICggIWNvbnRleHQgKSB7XG5cdFx0XHRcdHJldHVybiByZXN1bHRzO1xuXG5cdFx0XHQvLyBQcmVjb21waWxlZCBtYXRjaGVycyB3aWxsIHN0aWxsIHZlcmlmeSBhbmNlc3RyeSwgc28gc3RlcCB1cCBhIGxldmVsXG5cdFx0XHR9IGVsc2UgaWYgKCBjb21waWxlZCApIHtcblx0XHRcdFx0Y29udGV4dCA9IGNvbnRleHQucGFyZW50Tm9kZTtcblx0XHRcdH1cblxuXHRcdFx0c2VsZWN0b3IgPSBzZWxlY3Rvci5zbGljZSggdG9rZW5zLnNoaWZ0KCkudmFsdWUubGVuZ3RoICk7XG5cdFx0fVxuXG5cdFx0Ly8gRmV0Y2ggYSBzZWVkIHNldCBmb3IgcmlnaHQtdG8tbGVmdCBtYXRjaGluZ1xuXHRcdGkgPSBtYXRjaEV4cHJbIFwibmVlZHNDb250ZXh0XCIgXS50ZXN0KCBzZWxlY3RvciApID8gMCA6IHRva2Vucy5sZW5ndGg7XG5cdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHR0b2tlbiA9IHRva2Vuc1sgaSBdO1xuXG5cdFx0XHQvLyBBYm9ydCBpZiB3ZSBoaXQgYSBjb21iaW5hdG9yXG5cdFx0XHRpZiAoIEV4cHIucmVsYXRpdmVbICggdHlwZSA9IHRva2VuLnR5cGUgKSBdICkge1xuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHRcdGlmICggKCBmaW5kID0gRXhwci5maW5kWyB0eXBlIF0gKSApIHtcblxuXHRcdFx0XHQvLyBTZWFyY2gsIGV4cGFuZGluZyBjb250ZXh0IGZvciBsZWFkaW5nIHNpYmxpbmcgY29tYmluYXRvcnNcblx0XHRcdFx0aWYgKCAoIHNlZWQgPSBmaW5kKFxuXHRcdFx0XHRcdHRva2VuLm1hdGNoZXNbIDAgXS5yZXBsYWNlKCBydW5lc2NhcGUsIGZ1bmVzY2FwZSApLFxuXHRcdFx0XHRcdHJzaWJsaW5nLnRlc3QoIHRva2Vuc1sgMCBdLnR5cGUgKSAmJiB0ZXN0Q29udGV4dCggY29udGV4dC5wYXJlbnROb2RlICkgfHxcblx0XHRcdFx0XHRcdGNvbnRleHRcblx0XHRcdFx0KSApICkge1xuXG5cdFx0XHRcdFx0Ly8gSWYgc2VlZCBpcyBlbXB0eSBvciBubyB0b2tlbnMgcmVtYWluLCB3ZSBjYW4gcmV0dXJuIGVhcmx5XG5cdFx0XHRcdFx0dG9rZW5zLnNwbGljZSggaSwgMSApO1xuXHRcdFx0XHRcdHNlbGVjdG9yID0gc2VlZC5sZW5ndGggJiYgdG9TZWxlY3RvciggdG9rZW5zICk7XG5cdFx0XHRcdFx0aWYgKCAhc2VsZWN0b3IgKSB7XG5cdFx0XHRcdFx0XHRwdXNoLmFwcGx5KCByZXN1bHRzLCBzZWVkICk7XG5cdFx0XHRcdFx0XHRyZXR1cm4gcmVzdWx0cztcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8vIENvbXBpbGUgYW5kIGV4ZWN1dGUgYSBmaWx0ZXJpbmcgZnVuY3Rpb24gaWYgb25lIGlzIG5vdCBwcm92aWRlZFxuXHQvLyBQcm92aWRlIGBtYXRjaGAgdG8gYXZvaWQgcmV0b2tlbml6YXRpb24gaWYgd2UgbW9kaWZpZWQgdGhlIHNlbGVjdG9yIGFib3ZlXG5cdCggY29tcGlsZWQgfHwgY29tcGlsZSggc2VsZWN0b3IsIG1hdGNoICkgKShcblx0XHRzZWVkLFxuXHRcdGNvbnRleHQsXG5cdFx0IWRvY3VtZW50SXNIVE1MLFxuXHRcdHJlc3VsdHMsXG5cdFx0IWNvbnRleHQgfHwgcnNpYmxpbmcudGVzdCggc2VsZWN0b3IgKSAmJiB0ZXN0Q29udGV4dCggY29udGV4dC5wYXJlbnROb2RlICkgfHwgY29udGV4dFxuXHQpO1xuXHRyZXR1cm4gcmVzdWx0cztcbn07XG5cbi8vIE9uZS10aW1lIGFzc2lnbm1lbnRzXG5cbi8vIFNvcnQgc3RhYmlsaXR5XG5zdXBwb3J0LnNvcnRTdGFibGUgPSBleHBhbmRvLnNwbGl0KCBcIlwiICkuc29ydCggc29ydE9yZGVyICkuam9pbiggXCJcIiApID09PSBleHBhbmRvO1xuXG4vLyBTdXBwb3J0OiBDaHJvbWUgMTQtMzUrXG4vLyBBbHdheXMgYXNzdW1lIGR1cGxpY2F0ZXMgaWYgdGhleSBhcmVuJ3QgcGFzc2VkIHRvIHRoZSBjb21wYXJpc29uIGZ1bmN0aW9uXG5zdXBwb3J0LmRldGVjdER1cGxpY2F0ZXMgPSAhIWhhc0R1cGxpY2F0ZTtcblxuLy8gSW5pdGlhbGl6ZSBhZ2FpbnN0IHRoZSBkZWZhdWx0IGRvY3VtZW50XG5zZXREb2N1bWVudCgpO1xuXG4vLyBTdXBwb3J0OiBXZWJraXQ8NTM3LjMyIC0gU2FmYXJpIDYuMC4zL0Nocm9tZSAyNSAoZml4ZWQgaW4gQ2hyb21lIDI3KVxuLy8gRGV0YWNoZWQgbm9kZXMgY29uZm91bmRpbmdseSBmb2xsb3cgKmVhY2ggb3RoZXIqXG5zdXBwb3J0LnNvcnREZXRhY2hlZCA9IGFzc2VydCggZnVuY3Rpb24oIGVsICkge1xuXG5cdC8vIFNob3VsZCByZXR1cm4gMSwgYnV0IHJldHVybnMgNCAoZm9sbG93aW5nKVxuXHRyZXR1cm4gZWwuY29tcGFyZURvY3VtZW50UG9zaXRpb24oIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiZmllbGRzZXRcIiApICkgJiAxO1xufSApO1xuXG4vLyBTdXBwb3J0OiBJRTw4XG4vLyBQcmV2ZW50IGF0dHJpYnV0ZS9wcm9wZXJ0eSBcImludGVycG9sYXRpb25cIlxuLy8gaHR0cHM6Ly9tc2RuLm1pY3Jvc29mdC5jb20vZW4tdXMvbGlicmFyeS9tczUzNjQyOSUyOFZTLjg1JTI5LmFzcHhcbmlmICggIWFzc2VydCggZnVuY3Rpb24oIGVsICkge1xuXHRlbC5pbm5lckhUTUwgPSBcIjxhIGhyZWY9JyMnPjwvYT5cIjtcblx0cmV0dXJuIGVsLmZpcnN0Q2hpbGQuZ2V0QXR0cmlidXRlKCBcImhyZWZcIiApID09PSBcIiNcIjtcbn0gKSApIHtcblx0YWRkSGFuZGxlKCBcInR5cGV8aHJlZnxoZWlnaHR8d2lkdGhcIiwgZnVuY3Rpb24oIGVsZW0sIG5hbWUsIGlzWE1MICkge1xuXHRcdGlmICggIWlzWE1MICkge1xuXHRcdFx0cmV0dXJuIGVsZW0uZ2V0QXR0cmlidXRlKCBuYW1lLCBuYW1lLnRvTG93ZXJDYXNlKCkgPT09IFwidHlwZVwiID8gMSA6IDIgKTtcblx0XHR9XG5cdH0gKTtcbn1cblxuLy8gU3VwcG9ydDogSUU8OVxuLy8gVXNlIGRlZmF1bHRWYWx1ZSBpbiBwbGFjZSBvZiBnZXRBdHRyaWJ1dGUoXCJ2YWx1ZVwiKVxuaWYgKCAhc3VwcG9ydC5hdHRyaWJ1dGVzIHx8ICFhc3NlcnQoIGZ1bmN0aW9uKCBlbCApIHtcblx0ZWwuaW5uZXJIVE1MID0gXCI8aW5wdXQvPlwiO1xuXHRlbC5maXJzdENoaWxkLnNldEF0dHJpYnV0ZSggXCJ2YWx1ZVwiLCBcIlwiICk7XG5cdHJldHVybiBlbC5maXJzdENoaWxkLmdldEF0dHJpYnV0ZSggXCJ2YWx1ZVwiICkgPT09IFwiXCI7XG59ICkgKSB7XG5cdGFkZEhhbmRsZSggXCJ2YWx1ZVwiLCBmdW5jdGlvbiggZWxlbSwgX25hbWUsIGlzWE1MICkge1xuXHRcdGlmICggIWlzWE1MICYmIGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gXCJpbnB1dFwiICkge1xuXHRcdFx0cmV0dXJuIGVsZW0uZGVmYXVsdFZhbHVlO1xuXHRcdH1cblx0fSApO1xufVxuXG4vLyBTdXBwb3J0OiBJRTw5XG4vLyBVc2UgZ2V0QXR0cmlidXRlTm9kZSB0byBmZXRjaCBib29sZWFucyB3aGVuIGdldEF0dHJpYnV0ZSBsaWVzXG5pZiAoICFhc3NlcnQoIGZ1bmN0aW9uKCBlbCApIHtcblx0cmV0dXJuIGVsLmdldEF0dHJpYnV0ZSggXCJkaXNhYmxlZFwiICkgPT0gbnVsbDtcbn0gKSApIHtcblx0YWRkSGFuZGxlKCBib29sZWFucywgZnVuY3Rpb24oIGVsZW0sIG5hbWUsIGlzWE1MICkge1xuXHRcdHZhciB2YWw7XG5cdFx0aWYgKCAhaXNYTUwgKSB7XG5cdFx0XHRyZXR1cm4gZWxlbVsgbmFtZSBdID09PSB0cnVlID8gbmFtZS50b0xvd2VyQ2FzZSgpIDpcblx0XHRcdFx0KCB2YWwgPSBlbGVtLmdldEF0dHJpYnV0ZU5vZGUoIG5hbWUgKSApICYmIHZhbC5zcGVjaWZpZWQgP1xuXHRcdFx0XHRcdHZhbC52YWx1ZSA6XG5cdFx0XHRcdFx0bnVsbDtcblx0XHR9XG5cdH0gKTtcbn1cblxucmV0dXJuIFNpenpsZTtcblxufSApKCB3aW5kb3cgKTtcblxuXG5cbmpRdWVyeS5maW5kID0gU2l6emxlO1xualF1ZXJ5LmV4cHIgPSBTaXp6bGUuc2VsZWN0b3JzO1xuXG4vLyBEZXByZWNhdGVkXG5qUXVlcnkuZXhwclsgXCI6XCIgXSA9IGpRdWVyeS5leHByLnBzZXVkb3M7XG5qUXVlcnkudW5pcXVlU29ydCA9IGpRdWVyeS51bmlxdWUgPSBTaXp6bGUudW5pcXVlU29ydDtcbmpRdWVyeS50ZXh0ID0gU2l6emxlLmdldFRleHQ7XG5qUXVlcnkuaXNYTUxEb2MgPSBTaXp6bGUuaXNYTUw7XG5qUXVlcnkuY29udGFpbnMgPSBTaXp6bGUuY29udGFpbnM7XG5qUXVlcnkuZXNjYXBlU2VsZWN0b3IgPSBTaXp6bGUuZXNjYXBlO1xuXG5cblxuXG52YXIgZGlyID0gZnVuY3Rpb24oIGVsZW0sIGRpciwgdW50aWwgKSB7XG5cdHZhciBtYXRjaGVkID0gW10sXG5cdFx0dHJ1bmNhdGUgPSB1bnRpbCAhPT0gdW5kZWZpbmVkO1xuXG5cdHdoaWxlICggKCBlbGVtID0gZWxlbVsgZGlyIF0gKSAmJiBlbGVtLm5vZGVUeXBlICE9PSA5ICkge1xuXHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSApIHtcblx0XHRcdGlmICggdHJ1bmNhdGUgJiYgalF1ZXJ5KCBlbGVtICkuaXMoIHVudGlsICkgKSB7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdFx0bWF0Y2hlZC5wdXNoKCBlbGVtICk7XG5cdFx0fVxuXHR9XG5cdHJldHVybiBtYXRjaGVkO1xufTtcblxuXG52YXIgc2libGluZ3MgPSBmdW5jdGlvbiggbiwgZWxlbSApIHtcblx0dmFyIG1hdGNoZWQgPSBbXTtcblxuXHRmb3IgKCA7IG47IG4gPSBuLm5leHRTaWJsaW5nICkge1xuXHRcdGlmICggbi5ub2RlVHlwZSA9PT0gMSAmJiBuICE9PSBlbGVtICkge1xuXHRcdFx0bWF0Y2hlZC5wdXNoKCBuICk7XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIG1hdGNoZWQ7XG59O1xuXG5cbnZhciBybmVlZHNDb250ZXh0ID0galF1ZXJ5LmV4cHIubWF0Y2gubmVlZHNDb250ZXh0O1xuXG5cblxuZnVuY3Rpb24gbm9kZU5hbWUoIGVsZW0sIG5hbWUgKSB7XG5cblx0cmV0dXJuIGVsZW0ubm9kZU5hbWUgJiYgZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSBuYW1lLnRvTG93ZXJDYXNlKCk7XG5cbn1cbnZhciByc2luZ2xlVGFnID0gKCAvXjwoW2Etel1bXlxcL1xcMD46XFx4MjBcXHRcXHJcXG5cXGZdKilbXFx4MjBcXHRcXHJcXG5cXGZdKlxcLz8+KD86PFxcL1xcMT58KSQvaSApO1xuXG5cblxuLy8gSW1wbGVtZW50IHRoZSBpZGVudGljYWwgZnVuY3Rpb25hbGl0eSBmb3IgZmlsdGVyIGFuZCBub3RcbmZ1bmN0aW9uIHdpbm5vdyggZWxlbWVudHMsIHF1YWxpZmllciwgbm90ICkge1xuXHRpZiAoIGlzRnVuY3Rpb24oIHF1YWxpZmllciApICkge1xuXHRcdHJldHVybiBqUXVlcnkuZ3JlcCggZWxlbWVudHMsIGZ1bmN0aW9uKCBlbGVtLCBpICkge1xuXHRcdFx0cmV0dXJuICEhcXVhbGlmaWVyLmNhbGwoIGVsZW0sIGksIGVsZW0gKSAhPT0gbm90O1xuXHRcdH0gKTtcblx0fVxuXG5cdC8vIFNpbmdsZSBlbGVtZW50XG5cdGlmICggcXVhbGlmaWVyLm5vZGVUeXBlICkge1xuXHRcdHJldHVybiBqUXVlcnkuZ3JlcCggZWxlbWVudHMsIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuICggZWxlbSA9PT0gcXVhbGlmaWVyICkgIT09IG5vdDtcblx0XHR9ICk7XG5cdH1cblxuXHQvLyBBcnJheWxpa2Ugb2YgZWxlbWVudHMgKGpRdWVyeSwgYXJndW1lbnRzLCBBcnJheSlcblx0aWYgKCB0eXBlb2YgcXVhbGlmaWVyICE9PSBcInN0cmluZ1wiICkge1xuXHRcdHJldHVybiBqUXVlcnkuZ3JlcCggZWxlbWVudHMsIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuICggaW5kZXhPZi5jYWxsKCBxdWFsaWZpZXIsIGVsZW0gKSA+IC0xICkgIT09IG5vdDtcblx0XHR9ICk7XG5cdH1cblxuXHQvLyBGaWx0ZXJlZCBkaXJlY3RseSBmb3IgYm90aCBzaW1wbGUgYW5kIGNvbXBsZXggc2VsZWN0b3JzXG5cdHJldHVybiBqUXVlcnkuZmlsdGVyKCBxdWFsaWZpZXIsIGVsZW1lbnRzLCBub3QgKTtcbn1cblxualF1ZXJ5LmZpbHRlciA9IGZ1bmN0aW9uKCBleHByLCBlbGVtcywgbm90ICkge1xuXHR2YXIgZWxlbSA9IGVsZW1zWyAwIF07XG5cblx0aWYgKCBub3QgKSB7XG5cdFx0ZXhwciA9IFwiOm5vdChcIiArIGV4cHIgKyBcIilcIjtcblx0fVxuXG5cdGlmICggZWxlbXMubGVuZ3RoID09PSAxICYmIGVsZW0ubm9kZVR5cGUgPT09IDEgKSB7XG5cdFx0cmV0dXJuIGpRdWVyeS5maW5kLm1hdGNoZXNTZWxlY3RvciggZWxlbSwgZXhwciApID8gWyBlbGVtIF0gOiBbXTtcblx0fVxuXG5cdHJldHVybiBqUXVlcnkuZmluZC5tYXRjaGVzKCBleHByLCBqUXVlcnkuZ3JlcCggZWxlbXMsIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHJldHVybiBlbGVtLm5vZGVUeXBlID09PSAxO1xuXHR9ICkgKTtcbn07XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0ZmluZDogZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdHZhciBpLCByZXQsXG5cdFx0XHRsZW4gPSB0aGlzLmxlbmd0aCxcblx0XHRcdHNlbGYgPSB0aGlzO1xuXG5cdFx0aWYgKCB0eXBlb2Ygc2VsZWN0b3IgIT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5wdXNoU3RhY2soIGpRdWVyeSggc2VsZWN0b3IgKS5maWx0ZXIoIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRmb3IgKCBpID0gMDsgaSA8IGxlbjsgaSsrICkge1xuXHRcdFx0XHRcdGlmICggalF1ZXJ5LmNvbnRhaW5zKCBzZWxmWyBpIF0sIHRoaXMgKSApIHtcblx0XHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSApICk7XG5cdFx0fVxuXG5cdFx0cmV0ID0gdGhpcy5wdXNoU3RhY2soIFtdICk7XG5cblx0XHRmb3IgKCBpID0gMDsgaSA8IGxlbjsgaSsrICkge1xuXHRcdFx0alF1ZXJ5LmZpbmQoIHNlbGVjdG9yLCBzZWxmWyBpIF0sIHJldCApO1xuXHRcdH1cblxuXHRcdHJldHVybiBsZW4gPiAxID8galF1ZXJ5LnVuaXF1ZVNvcnQoIHJldCApIDogcmV0O1xuXHR9LFxuXHRmaWx0ZXI6IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHRyZXR1cm4gdGhpcy5wdXNoU3RhY2soIHdpbm5vdyggdGhpcywgc2VsZWN0b3IgfHwgW10sIGZhbHNlICkgKTtcblx0fSxcblx0bm90OiBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKCB3aW5ub3coIHRoaXMsIHNlbGVjdG9yIHx8IFtdLCB0cnVlICkgKTtcblx0fSxcblx0aXM6IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHRyZXR1cm4gISF3aW5ub3coXG5cdFx0XHR0aGlzLFxuXG5cdFx0XHQvLyBJZiB0aGlzIGlzIGEgcG9zaXRpb25hbC9yZWxhdGl2ZSBzZWxlY3RvciwgY2hlY2sgbWVtYmVyc2hpcCBpbiB0aGUgcmV0dXJuZWQgc2V0XG5cdFx0XHQvLyBzbyAkKFwicDpmaXJzdFwiKS5pcyhcInA6bGFzdFwiKSB3b24ndCByZXR1cm4gdHJ1ZSBmb3IgYSBkb2Mgd2l0aCB0d28gXCJwXCIuXG5cdFx0XHR0eXBlb2Ygc2VsZWN0b3IgPT09IFwic3RyaW5nXCIgJiYgcm5lZWRzQ29udGV4dC50ZXN0KCBzZWxlY3RvciApID9cblx0XHRcdFx0alF1ZXJ5KCBzZWxlY3RvciApIDpcblx0XHRcdFx0c2VsZWN0b3IgfHwgW10sXG5cdFx0XHRmYWxzZVxuXHRcdCkubGVuZ3RoO1xuXHR9XG59ICk7XG5cblxuLy8gSW5pdGlhbGl6ZSBhIGpRdWVyeSBvYmplY3RcblxuXG4vLyBBIGNlbnRyYWwgcmVmZXJlbmNlIHRvIHRoZSByb290IGpRdWVyeShkb2N1bWVudClcbnZhciByb290alF1ZXJ5LFxuXG5cdC8vIEEgc2ltcGxlIHdheSB0byBjaGVjayBmb3IgSFRNTCBzdHJpbmdzXG5cdC8vIFByaW9yaXRpemUgI2lkIG92ZXIgPHRhZz4gdG8gYXZvaWQgWFNTIHZpYSBsb2NhdGlvbi5oYXNoICgjOTUyMSlcblx0Ly8gU3RyaWN0IEhUTUwgcmVjb2duaXRpb24gKCMxMTI5MDogbXVzdCBzdGFydCB3aXRoIDwpXG5cdC8vIFNob3J0Y3V0IHNpbXBsZSAjaWQgY2FzZSBmb3Igc3BlZWRcblx0cnF1aWNrRXhwciA9IC9eKD86XFxzKig8W1xcd1xcV10rPilbXj5dKnwjKFtcXHctXSspKSQvLFxuXG5cdGluaXQgPSBqUXVlcnkuZm4uaW5pdCA9IGZ1bmN0aW9uKCBzZWxlY3RvciwgY29udGV4dCwgcm9vdCApIHtcblx0XHR2YXIgbWF0Y2gsIGVsZW07XG5cblx0XHQvLyBIQU5ETEU6ICQoXCJcIiksICQobnVsbCksICQodW5kZWZpbmVkKSwgJChmYWxzZSlcblx0XHRpZiAoICFzZWxlY3RvciApIHtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdC8vIE1ldGhvZCBpbml0KCkgYWNjZXB0cyBhbiBhbHRlcm5hdGUgcm9vdGpRdWVyeVxuXHRcdC8vIHNvIG1pZ3JhdGUgY2FuIHN1cHBvcnQgalF1ZXJ5LnN1YiAoZ2gtMjEwMSlcblx0XHRyb290ID0gcm9vdCB8fCByb290alF1ZXJ5O1xuXG5cdFx0Ly8gSGFuZGxlIEhUTUwgc3RyaW5nc1xuXHRcdGlmICggdHlwZW9mIHNlbGVjdG9yID09PSBcInN0cmluZ1wiICkge1xuXHRcdFx0aWYgKCBzZWxlY3RvclsgMCBdID09PSBcIjxcIiAmJlxuXHRcdFx0XHRzZWxlY3Rvclsgc2VsZWN0b3IubGVuZ3RoIC0gMSBdID09PSBcIj5cIiAmJlxuXHRcdFx0XHRzZWxlY3Rvci5sZW5ndGggPj0gMyApIHtcblxuXHRcdFx0XHQvLyBBc3N1bWUgdGhhdCBzdHJpbmdzIHRoYXQgc3RhcnQgYW5kIGVuZCB3aXRoIDw+IGFyZSBIVE1MIGFuZCBza2lwIHRoZSByZWdleCBjaGVja1xuXHRcdFx0XHRtYXRjaCA9IFsgbnVsbCwgc2VsZWN0b3IsIG51bGwgXTtcblxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0bWF0Y2ggPSBycXVpY2tFeHByLmV4ZWMoIHNlbGVjdG9yICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIE1hdGNoIGh0bWwgb3IgbWFrZSBzdXJlIG5vIGNvbnRleHQgaXMgc3BlY2lmaWVkIGZvciAjaWRcblx0XHRcdGlmICggbWF0Y2ggJiYgKCBtYXRjaFsgMSBdIHx8ICFjb250ZXh0ICkgKSB7XG5cblx0XHRcdFx0Ly8gSEFORExFOiAkKGh0bWwpIC0+ICQoYXJyYXkpXG5cdFx0XHRcdGlmICggbWF0Y2hbIDEgXSApIHtcblx0XHRcdFx0XHRjb250ZXh0ID0gY29udGV4dCBpbnN0YW5jZW9mIGpRdWVyeSA/IGNvbnRleHRbIDAgXSA6IGNvbnRleHQ7XG5cblx0XHRcdFx0XHQvLyBPcHRpb24gdG8gcnVuIHNjcmlwdHMgaXMgdHJ1ZSBmb3IgYmFjay1jb21wYXRcblx0XHRcdFx0XHQvLyBJbnRlbnRpb25hbGx5IGxldCB0aGUgZXJyb3IgYmUgdGhyb3duIGlmIHBhcnNlSFRNTCBpcyBub3QgcHJlc2VudFxuXHRcdFx0XHRcdGpRdWVyeS5tZXJnZSggdGhpcywgalF1ZXJ5LnBhcnNlSFRNTChcblx0XHRcdFx0XHRcdG1hdGNoWyAxIF0sXG5cdFx0XHRcdFx0XHRjb250ZXh0ICYmIGNvbnRleHQubm9kZVR5cGUgPyBjb250ZXh0Lm93bmVyRG9jdW1lbnQgfHwgY29udGV4dCA6IGRvY3VtZW50LFxuXHRcdFx0XHRcdFx0dHJ1ZVxuXHRcdFx0XHRcdCkgKTtcblxuXHRcdFx0XHRcdC8vIEhBTkRMRTogJChodG1sLCBwcm9wcylcblx0XHRcdFx0XHRpZiAoIHJzaW5nbGVUYWcudGVzdCggbWF0Y2hbIDEgXSApICYmIGpRdWVyeS5pc1BsYWluT2JqZWN0KCBjb250ZXh0ICkgKSB7XG5cdFx0XHRcdFx0XHRmb3IgKCBtYXRjaCBpbiBjb250ZXh0ICkge1xuXG5cdFx0XHRcdFx0XHRcdC8vIFByb3BlcnRpZXMgb2YgY29udGV4dCBhcmUgY2FsbGVkIGFzIG1ldGhvZHMgaWYgcG9zc2libGVcblx0XHRcdFx0XHRcdFx0aWYgKCBpc0Z1bmN0aW9uKCB0aGlzWyBtYXRjaCBdICkgKSB7XG5cdFx0XHRcdFx0XHRcdFx0dGhpc1sgbWF0Y2ggXSggY29udGV4dFsgbWF0Y2ggXSApO1xuXG5cdFx0XHRcdFx0XHRcdC8vIC4uLmFuZCBvdGhlcndpc2Ugc2V0IGFzIGF0dHJpYnV0ZXNcblx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHR0aGlzLmF0dHIoIG1hdGNoLCBjb250ZXh0WyBtYXRjaCBdICk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdFx0XHQvLyBIQU5ETEU6ICQoI2lkKVxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGVsZW0gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCggbWF0Y2hbIDIgXSApO1xuXG5cdFx0XHRcdFx0aWYgKCBlbGVtICkge1xuXG5cdFx0XHRcdFx0XHQvLyBJbmplY3QgdGhlIGVsZW1lbnQgZGlyZWN0bHkgaW50byB0aGUgalF1ZXJ5IG9iamVjdFxuXHRcdFx0XHRcdFx0dGhpc1sgMCBdID0gZWxlbTtcblx0XHRcdFx0XHRcdHRoaXMubGVuZ3RoID0gMTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHRcdH1cblxuXHRcdFx0Ly8gSEFORExFOiAkKGV4cHIsICQoLi4uKSlcblx0XHRcdH0gZWxzZSBpZiAoICFjb250ZXh0IHx8IGNvbnRleHQuanF1ZXJ5ICkge1xuXHRcdFx0XHRyZXR1cm4gKCBjb250ZXh0IHx8IHJvb3QgKS5maW5kKCBzZWxlY3RvciApO1xuXG5cdFx0XHQvLyBIQU5ETEU6ICQoZXhwciwgY29udGV4dClcblx0XHRcdC8vICh3aGljaCBpcyBqdXN0IGVxdWl2YWxlbnQgdG86ICQoY29udGV4dCkuZmluZChleHByKVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuY29uc3RydWN0b3IoIGNvbnRleHQgKS5maW5kKCBzZWxlY3RvciApO1xuXHRcdFx0fVxuXG5cdFx0Ly8gSEFORExFOiAkKERPTUVsZW1lbnQpXG5cdFx0fSBlbHNlIGlmICggc2VsZWN0b3Iubm9kZVR5cGUgKSB7XG5cdFx0XHR0aGlzWyAwIF0gPSBzZWxlY3Rvcjtcblx0XHRcdHRoaXMubGVuZ3RoID0gMTtcblx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0Ly8gSEFORExFOiAkKGZ1bmN0aW9uKVxuXHRcdC8vIFNob3J0Y3V0IGZvciBkb2N1bWVudCByZWFkeVxuXHRcdH0gZWxzZSBpZiAoIGlzRnVuY3Rpb24oIHNlbGVjdG9yICkgKSB7XG5cdFx0XHRyZXR1cm4gcm9vdC5yZWFkeSAhPT0gdW5kZWZpbmVkID9cblx0XHRcdFx0cm9vdC5yZWFkeSggc2VsZWN0b3IgKSA6XG5cblx0XHRcdFx0Ly8gRXhlY3V0ZSBpbW1lZGlhdGVseSBpZiByZWFkeSBpcyBub3QgcHJlc2VudFxuXHRcdFx0XHRzZWxlY3RvciggalF1ZXJ5ICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGpRdWVyeS5tYWtlQXJyYXkoIHNlbGVjdG9yLCB0aGlzICk7XG5cdH07XG5cbi8vIEdpdmUgdGhlIGluaXQgZnVuY3Rpb24gdGhlIGpRdWVyeSBwcm90b3R5cGUgZm9yIGxhdGVyIGluc3RhbnRpYXRpb25cbmluaXQucHJvdG90eXBlID0galF1ZXJ5LmZuO1xuXG4vLyBJbml0aWFsaXplIGNlbnRyYWwgcmVmZXJlbmNlXG5yb290alF1ZXJ5ID0galF1ZXJ5KCBkb2N1bWVudCApO1xuXG5cbnZhciBycGFyZW50c3ByZXYgPSAvXig/OnBhcmVudHN8cHJldig/OlVudGlsfEFsbCkpLyxcblxuXHQvLyBNZXRob2RzIGd1YXJhbnRlZWQgdG8gcHJvZHVjZSBhIHVuaXF1ZSBzZXQgd2hlbiBzdGFydGluZyBmcm9tIGEgdW5pcXVlIHNldFxuXHRndWFyYW50ZWVkVW5pcXVlID0ge1xuXHRcdGNoaWxkcmVuOiB0cnVlLFxuXHRcdGNvbnRlbnRzOiB0cnVlLFxuXHRcdG5leHQ6IHRydWUsXG5cdFx0cHJldjogdHJ1ZVxuXHR9O1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdGhhczogZnVuY3Rpb24oIHRhcmdldCApIHtcblx0XHR2YXIgdGFyZ2V0cyA9IGpRdWVyeSggdGFyZ2V0LCB0aGlzICksXG5cdFx0XHRsID0gdGFyZ2V0cy5sZW5ndGg7XG5cblx0XHRyZXR1cm4gdGhpcy5maWx0ZXIoIGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIGkgPSAwO1xuXHRcdFx0Zm9yICggOyBpIDwgbDsgaSsrICkge1xuXHRcdFx0XHRpZiAoIGpRdWVyeS5jb250YWlucyggdGhpcywgdGFyZ2V0c1sgaSBdICkgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9ICk7XG5cdH0sXG5cblx0Y2xvc2VzdDogZnVuY3Rpb24oIHNlbGVjdG9ycywgY29udGV4dCApIHtcblx0XHR2YXIgY3VyLFxuXHRcdFx0aSA9IDAsXG5cdFx0XHRsID0gdGhpcy5sZW5ndGgsXG5cdFx0XHRtYXRjaGVkID0gW10sXG5cdFx0XHR0YXJnZXRzID0gdHlwZW9mIHNlbGVjdG9ycyAhPT0gXCJzdHJpbmdcIiAmJiBqUXVlcnkoIHNlbGVjdG9ycyApO1xuXG5cdFx0Ly8gUG9zaXRpb25hbCBzZWxlY3RvcnMgbmV2ZXIgbWF0Y2gsIHNpbmNlIHRoZXJlJ3Mgbm8gX3NlbGVjdGlvbl8gY29udGV4dFxuXHRcdGlmICggIXJuZWVkc0NvbnRleHQudGVzdCggc2VsZWN0b3JzICkgKSB7XG5cdFx0XHRmb3IgKCA7IGkgPCBsOyBpKysgKSB7XG5cdFx0XHRcdGZvciAoIGN1ciA9IHRoaXNbIGkgXTsgY3VyICYmIGN1ciAhPT0gY29udGV4dDsgY3VyID0gY3VyLnBhcmVudE5vZGUgKSB7XG5cblx0XHRcdFx0XHQvLyBBbHdheXMgc2tpcCBkb2N1bWVudCBmcmFnbWVudHNcblx0XHRcdFx0XHRpZiAoIGN1ci5ub2RlVHlwZSA8IDExICYmICggdGFyZ2V0cyA/XG5cdFx0XHRcdFx0XHR0YXJnZXRzLmluZGV4KCBjdXIgKSA+IC0xIDpcblxuXHRcdFx0XHRcdFx0Ly8gRG9uJ3QgcGFzcyBub24tZWxlbWVudHMgdG8gU2l6emxlXG5cdFx0XHRcdFx0XHRjdXIubm9kZVR5cGUgPT09IDEgJiZcblx0XHRcdFx0XHRcdFx0alF1ZXJ5LmZpbmQubWF0Y2hlc1NlbGVjdG9yKCBjdXIsIHNlbGVjdG9ycyApICkgKSB7XG5cblx0XHRcdFx0XHRcdG1hdGNoZWQucHVzaCggY3VyICk7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcy5wdXNoU3RhY2soIG1hdGNoZWQubGVuZ3RoID4gMSA/IGpRdWVyeS51bmlxdWVTb3J0KCBtYXRjaGVkICkgOiBtYXRjaGVkICk7XG5cdH0sXG5cblx0Ly8gRGV0ZXJtaW5lIHRoZSBwb3NpdGlvbiBvZiBhbiBlbGVtZW50IHdpdGhpbiB0aGUgc2V0XG5cdGluZGV4OiBmdW5jdGlvbiggZWxlbSApIHtcblxuXHRcdC8vIE5vIGFyZ3VtZW50LCByZXR1cm4gaW5kZXggaW4gcGFyZW50XG5cdFx0aWYgKCAhZWxlbSApIHtcblx0XHRcdHJldHVybiAoIHRoaXNbIDAgXSAmJiB0aGlzWyAwIF0ucGFyZW50Tm9kZSApID8gdGhpcy5maXJzdCgpLnByZXZBbGwoKS5sZW5ndGggOiAtMTtcblx0XHR9XG5cblx0XHQvLyBJbmRleCBpbiBzZWxlY3RvclxuXHRcdGlmICggdHlwZW9mIGVsZW0gPT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRyZXR1cm4gaW5kZXhPZi5jYWxsKCBqUXVlcnkoIGVsZW0gKSwgdGhpc1sgMCBdICk7XG5cdFx0fVxuXG5cdFx0Ly8gTG9jYXRlIHRoZSBwb3NpdGlvbiBvZiB0aGUgZGVzaXJlZCBlbGVtZW50XG5cdFx0cmV0dXJuIGluZGV4T2YuY2FsbCggdGhpcyxcblxuXHRcdFx0Ly8gSWYgaXQgcmVjZWl2ZXMgYSBqUXVlcnkgb2JqZWN0LCB0aGUgZmlyc3QgZWxlbWVudCBpcyB1c2VkXG5cdFx0XHRlbGVtLmpxdWVyeSA/IGVsZW1bIDAgXSA6IGVsZW1cblx0XHQpO1xuXHR9LFxuXG5cdGFkZDogZnVuY3Rpb24oIHNlbGVjdG9yLCBjb250ZXh0ICkge1xuXHRcdHJldHVybiB0aGlzLnB1c2hTdGFjayhcblx0XHRcdGpRdWVyeS51bmlxdWVTb3J0KFxuXHRcdFx0XHRqUXVlcnkubWVyZ2UoIHRoaXMuZ2V0KCksIGpRdWVyeSggc2VsZWN0b3IsIGNvbnRleHQgKSApXG5cdFx0XHQpXG5cdFx0KTtcblx0fSxcblxuXHRhZGRCYWNrOiBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0cmV0dXJuIHRoaXMuYWRkKCBzZWxlY3RvciA9PSBudWxsID9cblx0XHRcdHRoaXMucHJldk9iamVjdCA6IHRoaXMucHJldk9iamVjdC5maWx0ZXIoIHNlbGVjdG9yIClcblx0XHQpO1xuXHR9XG59ICk7XG5cbmZ1bmN0aW9uIHNpYmxpbmcoIGN1ciwgZGlyICkge1xuXHR3aGlsZSAoICggY3VyID0gY3VyWyBkaXIgXSApICYmIGN1ci5ub2RlVHlwZSAhPT0gMSApIHt9XG5cdHJldHVybiBjdXI7XG59XG5cbmpRdWVyeS5lYWNoKCB7XG5cdHBhcmVudDogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0dmFyIHBhcmVudCA9IGVsZW0ucGFyZW50Tm9kZTtcblx0XHRyZXR1cm4gcGFyZW50ICYmIHBhcmVudC5ub2RlVHlwZSAhPT0gMTEgPyBwYXJlbnQgOiBudWxsO1xuXHR9LFxuXHRwYXJlbnRzOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRyZXR1cm4gZGlyKCBlbGVtLCBcInBhcmVudE5vZGVcIiApO1xuXHR9LFxuXHRwYXJlbnRzVW50aWw6IGZ1bmN0aW9uKCBlbGVtLCBfaSwgdW50aWwgKSB7XG5cdFx0cmV0dXJuIGRpciggZWxlbSwgXCJwYXJlbnROb2RlXCIsIHVudGlsICk7XG5cdH0sXG5cdG5leHQ6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHJldHVybiBzaWJsaW5nKCBlbGVtLCBcIm5leHRTaWJsaW5nXCIgKTtcblx0fSxcblx0cHJldjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0cmV0dXJuIHNpYmxpbmcoIGVsZW0sIFwicHJldmlvdXNTaWJsaW5nXCIgKTtcblx0fSxcblx0bmV4dEFsbDogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0cmV0dXJuIGRpciggZWxlbSwgXCJuZXh0U2libGluZ1wiICk7XG5cdH0sXG5cdHByZXZBbGw6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHJldHVybiBkaXIoIGVsZW0sIFwicHJldmlvdXNTaWJsaW5nXCIgKTtcblx0fSxcblx0bmV4dFVudGlsOiBmdW5jdGlvbiggZWxlbSwgX2ksIHVudGlsICkge1xuXHRcdHJldHVybiBkaXIoIGVsZW0sIFwibmV4dFNpYmxpbmdcIiwgdW50aWwgKTtcblx0fSxcblx0cHJldlVudGlsOiBmdW5jdGlvbiggZWxlbSwgX2ksIHVudGlsICkge1xuXHRcdHJldHVybiBkaXIoIGVsZW0sIFwicHJldmlvdXNTaWJsaW5nXCIsIHVudGlsICk7XG5cdH0sXG5cdHNpYmxpbmdzOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRyZXR1cm4gc2libGluZ3MoICggZWxlbS5wYXJlbnROb2RlIHx8IHt9ICkuZmlyc3RDaGlsZCwgZWxlbSApO1xuXHR9LFxuXHRjaGlsZHJlbjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0cmV0dXJuIHNpYmxpbmdzKCBlbGVtLmZpcnN0Q2hpbGQgKTtcblx0fSxcblx0Y29udGVudHM6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdGlmICggZWxlbS5jb250ZW50RG9jdW1lbnQgIT0gbnVsbCAmJlxuXG5cdFx0XHQvLyBTdXBwb3J0OiBJRSAxMStcblx0XHRcdC8vIDxvYmplY3Q+IGVsZW1lbnRzIHdpdGggbm8gYGRhdGFgIGF0dHJpYnV0ZSBoYXMgYW4gb2JqZWN0XG5cdFx0XHQvLyBgY29udGVudERvY3VtZW50YCB3aXRoIGEgYG51bGxgIHByb3RvdHlwZS5cblx0XHRcdGdldFByb3RvKCBlbGVtLmNvbnRlbnREb2N1bWVudCApICkge1xuXG5cdFx0XHRyZXR1cm4gZWxlbS5jb250ZW50RG9jdW1lbnQ7XG5cdFx0fVxuXG5cdFx0Ly8gU3VwcG9ydDogSUUgOSAtIDExIG9ubHksIGlPUyA3IG9ubHksIEFuZHJvaWQgQnJvd3NlciA8PTQuMyBvbmx5XG5cdFx0Ly8gVHJlYXQgdGhlIHRlbXBsYXRlIGVsZW1lbnQgYXMgYSByZWd1bGFyIG9uZSBpbiBicm93c2VycyB0aGF0XG5cdFx0Ly8gZG9uJ3Qgc3VwcG9ydCBpdC5cblx0XHRpZiAoIG5vZGVOYW1lKCBlbGVtLCBcInRlbXBsYXRlXCIgKSApIHtcblx0XHRcdGVsZW0gPSBlbGVtLmNvbnRlbnQgfHwgZWxlbTtcblx0XHR9XG5cblx0XHRyZXR1cm4galF1ZXJ5Lm1lcmdlKCBbXSwgZWxlbS5jaGlsZE5vZGVzICk7XG5cdH1cbn0sIGZ1bmN0aW9uKCBuYW1lLCBmbiApIHtcblx0alF1ZXJ5LmZuWyBuYW1lIF0gPSBmdW5jdGlvbiggdW50aWwsIHNlbGVjdG9yICkge1xuXHRcdHZhciBtYXRjaGVkID0galF1ZXJ5Lm1hcCggdGhpcywgZm4sIHVudGlsICk7XG5cblx0XHRpZiAoIG5hbWUuc2xpY2UoIC01ICkgIT09IFwiVW50aWxcIiApIHtcblx0XHRcdHNlbGVjdG9yID0gdW50aWw7XG5cdFx0fVxuXG5cdFx0aWYgKCBzZWxlY3RvciAmJiB0eXBlb2Ygc2VsZWN0b3IgPT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRtYXRjaGVkID0galF1ZXJ5LmZpbHRlciggc2VsZWN0b3IsIG1hdGNoZWQgKTtcblx0XHR9XG5cblx0XHRpZiAoIHRoaXMubGVuZ3RoID4gMSApIHtcblxuXHRcdFx0Ly8gUmVtb3ZlIGR1cGxpY2F0ZXNcblx0XHRcdGlmICggIWd1YXJhbnRlZWRVbmlxdWVbIG5hbWUgXSApIHtcblx0XHRcdFx0alF1ZXJ5LnVuaXF1ZVNvcnQoIG1hdGNoZWQgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gUmV2ZXJzZSBvcmRlciBmb3IgcGFyZW50cyogYW5kIHByZXYtZGVyaXZhdGl2ZXNcblx0XHRcdGlmICggcnBhcmVudHNwcmV2LnRlc3QoIG5hbWUgKSApIHtcblx0XHRcdFx0bWF0Y2hlZC5yZXZlcnNlKCk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKCBtYXRjaGVkICk7XG5cdH07XG59ICk7XG52YXIgcm5vdGh0bWx3aGl0ZSA9ICggL1teXFx4MjBcXHRcXHJcXG5cXGZdKy9nICk7XG5cblxuXG4vLyBDb252ZXJ0IFN0cmluZy1mb3JtYXR0ZWQgb3B0aW9ucyBpbnRvIE9iamVjdC1mb3JtYXR0ZWQgb25lc1xuZnVuY3Rpb24gY3JlYXRlT3B0aW9ucyggb3B0aW9ucyApIHtcblx0dmFyIG9iamVjdCA9IHt9O1xuXHRqUXVlcnkuZWFjaCggb3B0aW9ucy5tYXRjaCggcm5vdGh0bWx3aGl0ZSApIHx8IFtdLCBmdW5jdGlvbiggXywgZmxhZyApIHtcblx0XHRvYmplY3RbIGZsYWcgXSA9IHRydWU7XG5cdH0gKTtcblx0cmV0dXJuIG9iamVjdDtcbn1cblxuLypcbiAqIENyZWF0ZSBhIGNhbGxiYWNrIGxpc3QgdXNpbmcgdGhlIGZvbGxvd2luZyBwYXJhbWV0ZXJzOlxuICpcbiAqXHRvcHRpb25zOiBhbiBvcHRpb25hbCBsaXN0IG9mIHNwYWNlLXNlcGFyYXRlZCBvcHRpb25zIHRoYXQgd2lsbCBjaGFuZ2UgaG93XG4gKlx0XHRcdHRoZSBjYWxsYmFjayBsaXN0IGJlaGF2ZXMgb3IgYSBtb3JlIHRyYWRpdGlvbmFsIG9wdGlvbiBvYmplY3RcbiAqXG4gKiBCeSBkZWZhdWx0IGEgY2FsbGJhY2sgbGlzdCB3aWxsIGFjdCBsaWtlIGFuIGV2ZW50IGNhbGxiYWNrIGxpc3QgYW5kIGNhbiBiZVxuICogXCJmaXJlZFwiIG11bHRpcGxlIHRpbWVzLlxuICpcbiAqIFBvc3NpYmxlIG9wdGlvbnM6XG4gKlxuICpcdG9uY2U6XHRcdFx0d2lsbCBlbnN1cmUgdGhlIGNhbGxiYWNrIGxpc3QgY2FuIG9ubHkgYmUgZmlyZWQgb25jZSAobGlrZSBhIERlZmVycmVkKVxuICpcbiAqXHRtZW1vcnk6XHRcdFx0d2lsbCBrZWVwIHRyYWNrIG9mIHByZXZpb3VzIHZhbHVlcyBhbmQgd2lsbCBjYWxsIGFueSBjYWxsYmFjayBhZGRlZFxuICpcdFx0XHRcdFx0YWZ0ZXIgdGhlIGxpc3QgaGFzIGJlZW4gZmlyZWQgcmlnaHQgYXdheSB3aXRoIHRoZSBsYXRlc3QgXCJtZW1vcml6ZWRcIlxuICpcdFx0XHRcdFx0dmFsdWVzIChsaWtlIGEgRGVmZXJyZWQpXG4gKlxuICpcdHVuaXF1ZTpcdFx0XHR3aWxsIGVuc3VyZSBhIGNhbGxiYWNrIGNhbiBvbmx5IGJlIGFkZGVkIG9uY2UgKG5vIGR1cGxpY2F0ZSBpbiB0aGUgbGlzdClcbiAqXG4gKlx0c3RvcE9uRmFsc2U6XHRpbnRlcnJ1cHQgY2FsbGluZ3Mgd2hlbiBhIGNhbGxiYWNrIHJldHVybnMgZmFsc2VcbiAqXG4gKi9cbmpRdWVyeS5DYWxsYmFja3MgPSBmdW5jdGlvbiggb3B0aW9ucyApIHtcblxuXHQvLyBDb252ZXJ0IG9wdGlvbnMgZnJvbSBTdHJpbmctZm9ybWF0dGVkIHRvIE9iamVjdC1mb3JtYXR0ZWQgaWYgbmVlZGVkXG5cdC8vICh3ZSBjaGVjayBpbiBjYWNoZSBmaXJzdClcblx0b3B0aW9ucyA9IHR5cGVvZiBvcHRpb25zID09PSBcInN0cmluZ1wiID9cblx0XHRjcmVhdGVPcHRpb25zKCBvcHRpb25zICkgOlxuXHRcdGpRdWVyeS5leHRlbmQoIHt9LCBvcHRpb25zICk7XG5cblx0dmFyIC8vIEZsYWcgdG8ga25vdyBpZiBsaXN0IGlzIGN1cnJlbnRseSBmaXJpbmdcblx0XHRmaXJpbmcsXG5cblx0XHQvLyBMYXN0IGZpcmUgdmFsdWUgZm9yIG5vbi1mb3JnZXR0YWJsZSBsaXN0c1xuXHRcdG1lbW9yeSxcblxuXHRcdC8vIEZsYWcgdG8ga25vdyBpZiBsaXN0IHdhcyBhbHJlYWR5IGZpcmVkXG5cdFx0ZmlyZWQsXG5cblx0XHQvLyBGbGFnIHRvIHByZXZlbnQgZmlyaW5nXG5cdFx0bG9ja2VkLFxuXG5cdFx0Ly8gQWN0dWFsIGNhbGxiYWNrIGxpc3Rcblx0XHRsaXN0ID0gW10sXG5cblx0XHQvLyBRdWV1ZSBvZiBleGVjdXRpb24gZGF0YSBmb3IgcmVwZWF0YWJsZSBsaXN0c1xuXHRcdHF1ZXVlID0gW10sXG5cblx0XHQvLyBJbmRleCBvZiBjdXJyZW50bHkgZmlyaW5nIGNhbGxiYWNrIChtb2RpZmllZCBieSBhZGQvcmVtb3ZlIGFzIG5lZWRlZClcblx0XHRmaXJpbmdJbmRleCA9IC0xLFxuXG5cdFx0Ly8gRmlyZSBjYWxsYmFja3Ncblx0XHRmaXJlID0gZnVuY3Rpb24oKSB7XG5cblx0XHRcdC8vIEVuZm9yY2Ugc2luZ2xlLWZpcmluZ1xuXHRcdFx0bG9ja2VkID0gbG9ja2VkIHx8IG9wdGlvbnMub25jZTtcblxuXHRcdFx0Ly8gRXhlY3V0ZSBjYWxsYmFja3MgZm9yIGFsbCBwZW5kaW5nIGV4ZWN1dGlvbnMsXG5cdFx0XHQvLyByZXNwZWN0aW5nIGZpcmluZ0luZGV4IG92ZXJyaWRlcyBhbmQgcnVudGltZSBjaGFuZ2VzXG5cdFx0XHRmaXJlZCA9IGZpcmluZyA9IHRydWU7XG5cdFx0XHRmb3IgKCA7IHF1ZXVlLmxlbmd0aDsgZmlyaW5nSW5kZXggPSAtMSApIHtcblx0XHRcdFx0bWVtb3J5ID0gcXVldWUuc2hpZnQoKTtcblx0XHRcdFx0d2hpbGUgKCArK2ZpcmluZ0luZGV4IDwgbGlzdC5sZW5ndGggKSB7XG5cblx0XHRcdFx0XHQvLyBSdW4gY2FsbGJhY2sgYW5kIGNoZWNrIGZvciBlYXJseSB0ZXJtaW5hdGlvblxuXHRcdFx0XHRcdGlmICggbGlzdFsgZmlyaW5nSW5kZXggXS5hcHBseSggbWVtb3J5WyAwIF0sIG1lbW9yeVsgMSBdICkgPT09IGZhbHNlICYmXG5cdFx0XHRcdFx0XHRvcHRpb25zLnN0b3BPbkZhbHNlICkge1xuXG5cdFx0XHRcdFx0XHQvLyBKdW1wIHRvIGVuZCBhbmQgZm9yZ2V0IHRoZSBkYXRhIHNvIC5hZGQgZG9lc24ndCByZS1maXJlXG5cdFx0XHRcdFx0XHRmaXJpbmdJbmRleCA9IGxpc3QubGVuZ3RoO1xuXHRcdFx0XHRcdFx0bWVtb3J5ID0gZmFsc2U7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIEZvcmdldCB0aGUgZGF0YSBpZiB3ZSdyZSBkb25lIHdpdGggaXRcblx0XHRcdGlmICggIW9wdGlvbnMubWVtb3J5ICkge1xuXHRcdFx0XHRtZW1vcnkgPSBmYWxzZTtcblx0XHRcdH1cblxuXHRcdFx0ZmlyaW5nID0gZmFsc2U7XG5cblx0XHRcdC8vIENsZWFuIHVwIGlmIHdlJ3JlIGRvbmUgZmlyaW5nIGZvciBnb29kXG5cdFx0XHRpZiAoIGxvY2tlZCApIHtcblxuXHRcdFx0XHQvLyBLZWVwIGFuIGVtcHR5IGxpc3QgaWYgd2UgaGF2ZSBkYXRhIGZvciBmdXR1cmUgYWRkIGNhbGxzXG5cdFx0XHRcdGlmICggbWVtb3J5ICkge1xuXHRcdFx0XHRcdGxpc3QgPSBbXTtcblxuXHRcdFx0XHQvLyBPdGhlcndpc2UsIHRoaXMgb2JqZWN0IGlzIHNwZW50XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0bGlzdCA9IFwiXCI7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0Ly8gQWN0dWFsIENhbGxiYWNrcyBvYmplY3Rcblx0XHRzZWxmID0ge1xuXG5cdFx0XHQvLyBBZGQgYSBjYWxsYmFjayBvciBhIGNvbGxlY3Rpb24gb2YgY2FsbGJhY2tzIHRvIHRoZSBsaXN0XG5cdFx0XHRhZGQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAoIGxpc3QgKSB7XG5cblx0XHRcdFx0XHQvLyBJZiB3ZSBoYXZlIG1lbW9yeSBmcm9tIGEgcGFzdCBydW4sIHdlIHNob3VsZCBmaXJlIGFmdGVyIGFkZGluZ1xuXHRcdFx0XHRcdGlmICggbWVtb3J5ICYmICFmaXJpbmcgKSB7XG5cdFx0XHRcdFx0XHRmaXJpbmdJbmRleCA9IGxpc3QubGVuZ3RoIC0gMTtcblx0XHRcdFx0XHRcdHF1ZXVlLnB1c2goIG1lbW9yeSApO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdCggZnVuY3Rpb24gYWRkKCBhcmdzICkge1xuXHRcdFx0XHRcdFx0alF1ZXJ5LmVhY2goIGFyZ3MsIGZ1bmN0aW9uKCBfLCBhcmcgKSB7XG5cdFx0XHRcdFx0XHRcdGlmICggaXNGdW5jdGlvbiggYXJnICkgKSB7XG5cdFx0XHRcdFx0XHRcdFx0aWYgKCAhb3B0aW9ucy51bmlxdWUgfHwgIXNlbGYuaGFzKCBhcmcgKSApIHtcblx0XHRcdFx0XHRcdFx0XHRcdGxpc3QucHVzaCggYXJnICk7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9IGVsc2UgaWYgKCBhcmcgJiYgYXJnLmxlbmd0aCAmJiB0b1R5cGUoIGFyZyApICE9PSBcInN0cmluZ1wiICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gSW5zcGVjdCByZWN1cnNpdmVseVxuXHRcdFx0XHRcdFx0XHRcdGFkZCggYXJnICk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH0gKTtcblx0XHRcdFx0XHR9ICkoIGFyZ3VtZW50cyApO1xuXG5cdFx0XHRcdFx0aWYgKCBtZW1vcnkgJiYgIWZpcmluZyApIHtcblx0XHRcdFx0XHRcdGZpcmUoKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBSZW1vdmUgYSBjYWxsYmFjayBmcm9tIHRoZSBsaXN0XG5cdFx0XHRyZW1vdmU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRqUXVlcnkuZWFjaCggYXJndW1lbnRzLCBmdW5jdGlvbiggXywgYXJnICkge1xuXHRcdFx0XHRcdHZhciBpbmRleDtcblx0XHRcdFx0XHR3aGlsZSAoICggaW5kZXggPSBqUXVlcnkuaW5BcnJheSggYXJnLCBsaXN0LCBpbmRleCApICkgPiAtMSApIHtcblx0XHRcdFx0XHRcdGxpc3Quc3BsaWNlKCBpbmRleCwgMSApO1xuXG5cdFx0XHRcdFx0XHQvLyBIYW5kbGUgZmlyaW5nIGluZGV4ZXNcblx0XHRcdFx0XHRcdGlmICggaW5kZXggPD0gZmlyaW5nSW5kZXggKSB7XG5cdFx0XHRcdFx0XHRcdGZpcmluZ0luZGV4LS07XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9ICk7XG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fSxcblxuXHRcdFx0Ly8gQ2hlY2sgaWYgYSBnaXZlbiBjYWxsYmFjayBpcyBpbiB0aGUgbGlzdC5cblx0XHRcdC8vIElmIG5vIGFyZ3VtZW50IGlzIGdpdmVuLCByZXR1cm4gd2hldGhlciBvciBub3QgbGlzdCBoYXMgY2FsbGJhY2tzIGF0dGFjaGVkLlxuXHRcdFx0aGFzOiBmdW5jdGlvbiggZm4gKSB7XG5cdFx0XHRcdHJldHVybiBmbiA/XG5cdFx0XHRcdFx0alF1ZXJ5LmluQXJyYXkoIGZuLCBsaXN0ICkgPiAtMSA6XG5cdFx0XHRcdFx0bGlzdC5sZW5ndGggPiAwO1xuXHRcdFx0fSxcblxuXHRcdFx0Ly8gUmVtb3ZlIGFsbCBjYWxsYmFja3MgZnJvbSB0aGUgbGlzdFxuXHRcdFx0ZW1wdHk6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAoIGxpc3QgKSB7XG5cdFx0XHRcdFx0bGlzdCA9IFtdO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fSxcblxuXHRcdFx0Ly8gRGlzYWJsZSAuZmlyZSBhbmQgLmFkZFxuXHRcdFx0Ly8gQWJvcnQgYW55IGN1cnJlbnQvcGVuZGluZyBleGVjdXRpb25zXG5cdFx0XHQvLyBDbGVhciBhbGwgY2FsbGJhY2tzIGFuZCB2YWx1ZXNcblx0XHRcdGRpc2FibGU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRsb2NrZWQgPSBxdWV1ZSA9IFtdO1xuXHRcdFx0XHRsaXN0ID0gbWVtb3J5ID0gXCJcIjtcblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9LFxuXHRcdFx0ZGlzYWJsZWQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gIWxpc3Q7XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBEaXNhYmxlIC5maXJlXG5cdFx0XHQvLyBBbHNvIGRpc2FibGUgLmFkZCB1bmxlc3Mgd2UgaGF2ZSBtZW1vcnkgKHNpbmNlIGl0IHdvdWxkIGhhdmUgbm8gZWZmZWN0KVxuXHRcdFx0Ly8gQWJvcnQgYW55IHBlbmRpbmcgZXhlY3V0aW9uc1xuXHRcdFx0bG9jazogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGxvY2tlZCA9IHF1ZXVlID0gW107XG5cdFx0XHRcdGlmICggIW1lbW9yeSAmJiAhZmlyaW5nICkge1xuXHRcdFx0XHRcdGxpc3QgPSBtZW1vcnkgPSBcIlwiO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fSxcblx0XHRcdGxvY2tlZDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiAhIWxvY2tlZDtcblx0XHRcdH0sXG5cblx0XHRcdC8vIENhbGwgYWxsIGNhbGxiYWNrcyB3aXRoIHRoZSBnaXZlbiBjb250ZXh0IGFuZCBhcmd1bWVudHNcblx0XHRcdGZpcmVXaXRoOiBmdW5jdGlvbiggY29udGV4dCwgYXJncyApIHtcblx0XHRcdFx0aWYgKCAhbG9ja2VkICkge1xuXHRcdFx0XHRcdGFyZ3MgPSBhcmdzIHx8IFtdO1xuXHRcdFx0XHRcdGFyZ3MgPSBbIGNvbnRleHQsIGFyZ3Muc2xpY2UgPyBhcmdzLnNsaWNlKCkgOiBhcmdzIF07XG5cdFx0XHRcdFx0cXVldWUucHVzaCggYXJncyApO1xuXHRcdFx0XHRcdGlmICggIWZpcmluZyApIHtcblx0XHRcdFx0XHRcdGZpcmUoKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBDYWxsIGFsbCB0aGUgY2FsbGJhY2tzIHdpdGggdGhlIGdpdmVuIGFyZ3VtZW50c1xuXHRcdFx0ZmlyZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHNlbGYuZmlyZVdpdGgoIHRoaXMsIGFyZ3VtZW50cyApO1xuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH0sXG5cblx0XHRcdC8vIFRvIGtub3cgaWYgdGhlIGNhbGxiYWNrcyBoYXZlIGFscmVhZHkgYmVlbiBjYWxsZWQgYXQgbGVhc3Qgb25jZVxuXHRcdFx0ZmlyZWQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gISFmaXJlZDtcblx0XHRcdH1cblx0XHR9O1xuXG5cdHJldHVybiBzZWxmO1xufTtcblxuXG5mdW5jdGlvbiBJZGVudGl0eSggdiApIHtcblx0cmV0dXJuIHY7XG59XG5mdW5jdGlvbiBUaHJvd2VyKCBleCApIHtcblx0dGhyb3cgZXg7XG59XG5cbmZ1bmN0aW9uIGFkb3B0VmFsdWUoIHZhbHVlLCByZXNvbHZlLCByZWplY3QsIG5vVmFsdWUgKSB7XG5cdHZhciBtZXRob2Q7XG5cblx0dHJ5IHtcblxuXHRcdC8vIENoZWNrIGZvciBwcm9taXNlIGFzcGVjdCBmaXJzdCB0byBwcml2aWxlZ2Ugc3luY2hyb25vdXMgYmVoYXZpb3Jcblx0XHRpZiAoIHZhbHVlICYmIGlzRnVuY3Rpb24oICggbWV0aG9kID0gdmFsdWUucHJvbWlzZSApICkgKSB7XG5cdFx0XHRtZXRob2QuY2FsbCggdmFsdWUgKS5kb25lKCByZXNvbHZlICkuZmFpbCggcmVqZWN0ICk7XG5cblx0XHQvLyBPdGhlciB0aGVuYWJsZXNcblx0XHR9IGVsc2UgaWYgKCB2YWx1ZSAmJiBpc0Z1bmN0aW9uKCAoIG1ldGhvZCA9IHZhbHVlLnRoZW4gKSApICkge1xuXHRcdFx0bWV0aG9kLmNhbGwoIHZhbHVlLCByZXNvbHZlLCByZWplY3QgKTtcblxuXHRcdC8vIE90aGVyIG5vbi10aGVuYWJsZXNcblx0XHR9IGVsc2Uge1xuXG5cdFx0XHQvLyBDb250cm9sIGByZXNvbHZlYCBhcmd1bWVudHMgYnkgbGV0dGluZyBBcnJheSNzbGljZSBjYXN0IGJvb2xlYW4gYG5vVmFsdWVgIHRvIGludGVnZXI6XG5cdFx0XHQvLyAqIGZhbHNlOiBbIHZhbHVlIF0uc2xpY2UoIDAgKSA9PiByZXNvbHZlKCB2YWx1ZSApXG5cdFx0XHQvLyAqIHRydWU6IFsgdmFsdWUgXS5zbGljZSggMSApID0+IHJlc29sdmUoKVxuXHRcdFx0cmVzb2x2ZS5hcHBseSggdW5kZWZpbmVkLCBbIHZhbHVlIF0uc2xpY2UoIG5vVmFsdWUgKSApO1xuXHRcdH1cblxuXHQvLyBGb3IgUHJvbWlzZXMvQSssIGNvbnZlcnQgZXhjZXB0aW9ucyBpbnRvIHJlamVjdGlvbnNcblx0Ly8gU2luY2UgalF1ZXJ5LndoZW4gZG9lc24ndCB1bndyYXAgdGhlbmFibGVzLCB3ZSBjYW4gc2tpcCB0aGUgZXh0cmEgY2hlY2tzIGFwcGVhcmluZyBpblxuXHQvLyBEZWZlcnJlZCN0aGVuIHRvIGNvbmRpdGlvbmFsbHkgc3VwcHJlc3MgcmVqZWN0aW9uLlxuXHR9IGNhdGNoICggdmFsdWUgKSB7XG5cblx0XHQvLyBTdXBwb3J0OiBBbmRyb2lkIDQuMCBvbmx5XG5cdFx0Ly8gU3RyaWN0IG1vZGUgZnVuY3Rpb25zIGludm9rZWQgd2l0aG91dCAuY2FsbC8uYXBwbHkgZ2V0IGdsb2JhbC1vYmplY3QgY29udGV4dFxuXHRcdHJlamVjdC5hcHBseSggdW5kZWZpbmVkLCBbIHZhbHVlIF0gKTtcblx0fVxufVxuXG5qUXVlcnkuZXh0ZW5kKCB7XG5cblx0RGVmZXJyZWQ6IGZ1bmN0aW9uKCBmdW5jICkge1xuXHRcdHZhciB0dXBsZXMgPSBbXG5cblx0XHRcdFx0Ly8gYWN0aW9uLCBhZGQgbGlzdGVuZXIsIGNhbGxiYWNrcyxcblx0XHRcdFx0Ly8gLi4uIC50aGVuIGhhbmRsZXJzLCBhcmd1bWVudCBpbmRleCwgW2ZpbmFsIHN0YXRlXVxuXHRcdFx0XHRbIFwibm90aWZ5XCIsIFwicHJvZ3Jlc3NcIiwgalF1ZXJ5LkNhbGxiYWNrcyggXCJtZW1vcnlcIiApLFxuXHRcdFx0XHRcdGpRdWVyeS5DYWxsYmFja3MoIFwibWVtb3J5XCIgKSwgMiBdLFxuXHRcdFx0XHRbIFwicmVzb2x2ZVwiLCBcImRvbmVcIiwgalF1ZXJ5LkNhbGxiYWNrcyggXCJvbmNlIG1lbW9yeVwiICksXG5cdFx0XHRcdFx0alF1ZXJ5LkNhbGxiYWNrcyggXCJvbmNlIG1lbW9yeVwiICksIDAsIFwicmVzb2x2ZWRcIiBdLFxuXHRcdFx0XHRbIFwicmVqZWN0XCIsIFwiZmFpbFwiLCBqUXVlcnkuQ2FsbGJhY2tzKCBcIm9uY2UgbWVtb3J5XCIgKSxcblx0XHRcdFx0XHRqUXVlcnkuQ2FsbGJhY2tzKCBcIm9uY2UgbWVtb3J5XCIgKSwgMSwgXCJyZWplY3RlZFwiIF1cblx0XHRcdF0sXG5cdFx0XHRzdGF0ZSA9IFwicGVuZGluZ1wiLFxuXHRcdFx0cHJvbWlzZSA9IHtcblx0XHRcdFx0c3RhdGU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdHJldHVybiBzdGF0ZTtcblx0XHRcdFx0fSxcblx0XHRcdFx0YWx3YXlzOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRkZWZlcnJlZC5kb25lKCBhcmd1bWVudHMgKS5mYWlsKCBhcmd1bWVudHMgKTtcblx0XHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdFx0fSxcblx0XHRcdFx0XCJjYXRjaFwiOiBmdW5jdGlvbiggZm4gKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHByb21pc2UudGhlbiggbnVsbCwgZm4gKTtcblx0XHRcdFx0fSxcblxuXHRcdFx0XHQvLyBLZWVwIHBpcGUgZm9yIGJhY2stY29tcGF0XG5cdFx0XHRcdHBpcGU6IGZ1bmN0aW9uKCAvKiBmbkRvbmUsIGZuRmFpbCwgZm5Qcm9ncmVzcyAqLyApIHtcblx0XHRcdFx0XHR2YXIgZm5zID0gYXJndW1lbnRzO1xuXG5cdFx0XHRcdFx0cmV0dXJuIGpRdWVyeS5EZWZlcnJlZCggZnVuY3Rpb24oIG5ld0RlZmVyICkge1xuXHRcdFx0XHRcdFx0alF1ZXJ5LmVhY2goIHR1cGxlcywgZnVuY3Rpb24oIF9pLCB0dXBsZSApIHtcblxuXHRcdFx0XHRcdFx0XHQvLyBNYXAgdHVwbGVzIChwcm9ncmVzcywgZG9uZSwgZmFpbCkgdG8gYXJndW1lbnRzIChkb25lLCBmYWlsLCBwcm9ncmVzcylcblx0XHRcdFx0XHRcdFx0dmFyIGZuID0gaXNGdW5jdGlvbiggZm5zWyB0dXBsZVsgNCBdIF0gKSAmJiBmbnNbIHR1cGxlWyA0IF0gXTtcblxuXHRcdFx0XHRcdFx0XHQvLyBkZWZlcnJlZC5wcm9ncmVzcyhmdW5jdGlvbigpIHsgYmluZCB0byBuZXdEZWZlciBvciBuZXdEZWZlci5ub3RpZnkgfSlcblx0XHRcdFx0XHRcdFx0Ly8gZGVmZXJyZWQuZG9uZShmdW5jdGlvbigpIHsgYmluZCB0byBuZXdEZWZlciBvciBuZXdEZWZlci5yZXNvbHZlIH0pXG5cdFx0XHRcdFx0XHRcdC8vIGRlZmVycmVkLmZhaWwoZnVuY3Rpb24oKSB7IGJpbmQgdG8gbmV3RGVmZXIgb3IgbmV3RGVmZXIucmVqZWN0IH0pXG5cdFx0XHRcdFx0XHRcdGRlZmVycmVkWyB0dXBsZVsgMSBdIF0oIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0XHRcdHZhciByZXR1cm5lZCA9IGZuICYmIGZuLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKTtcblx0XHRcdFx0XHRcdFx0XHRpZiAoIHJldHVybmVkICYmIGlzRnVuY3Rpb24oIHJldHVybmVkLnByb21pc2UgKSApIHtcblx0XHRcdFx0XHRcdFx0XHRcdHJldHVybmVkLnByb21pc2UoKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHQucHJvZ3Jlc3MoIG5ld0RlZmVyLm5vdGlmeSApXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC5kb25lKCBuZXdEZWZlci5yZXNvbHZlIClcblx0XHRcdFx0XHRcdFx0XHRcdFx0LmZhaWwoIG5ld0RlZmVyLnJlamVjdCApO1xuXHRcdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRuZXdEZWZlclsgdHVwbGVbIDAgXSArIFwiV2l0aFwiIF0oXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHRoaXMsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGZuID8gWyByZXR1cm5lZCBdIDogYXJndW1lbnRzXG5cdFx0XHRcdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fSApO1xuXHRcdFx0XHRcdFx0fSApO1xuXHRcdFx0XHRcdFx0Zm5zID0gbnVsbDtcblx0XHRcdFx0XHR9ICkucHJvbWlzZSgpO1xuXHRcdFx0XHR9LFxuXHRcdFx0XHR0aGVuOiBmdW5jdGlvbiggb25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQsIG9uUHJvZ3Jlc3MgKSB7XG5cdFx0XHRcdFx0dmFyIG1heERlcHRoID0gMDtcblx0XHRcdFx0XHRmdW5jdGlvbiByZXNvbHZlKCBkZXB0aCwgZGVmZXJyZWQsIGhhbmRsZXIsIHNwZWNpYWwgKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRcdHZhciB0aGF0ID0gdGhpcyxcblx0XHRcdFx0XHRcdFx0XHRhcmdzID0gYXJndW1lbnRzLFxuXHRcdFx0XHRcdFx0XHRcdG1pZ2h0VGhyb3cgPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdFx0XHRcdHZhciByZXR1cm5lZCwgdGhlbjtcblxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogUHJvbWlzZXMvQSsgc2VjdGlvbiAyLjMuMy4zLjNcblx0XHRcdFx0XHRcdFx0XHRcdC8vIGh0dHBzOi8vcHJvbWlzZXNhcGx1cy5jb20vI3BvaW50LTU5XG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBJZ25vcmUgZG91YmxlLXJlc29sdXRpb24gYXR0ZW1wdHNcblx0XHRcdFx0XHRcdFx0XHRcdGlmICggZGVwdGggPCBtYXhEZXB0aCApIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdFx0XHRyZXR1cm5lZCA9IGhhbmRsZXIuYXBwbHkoIHRoYXQsIGFyZ3MgKTtcblxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogUHJvbWlzZXMvQSsgc2VjdGlvbiAyLjMuMVxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gaHR0cHM6Ly9wcm9taXNlc2FwbHVzLmNvbS8jcG9pbnQtNDhcblx0XHRcdFx0XHRcdFx0XHRcdGlmICggcmV0dXJuZWQgPT09IGRlZmVycmVkLnByb21pc2UoKSApIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dGhyb3cgbmV3IFR5cGVFcnJvciggXCJUaGVuYWJsZSBzZWxmLXJlc29sdXRpb25cIiApO1xuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBQcm9taXNlcy9BKyBzZWN0aW9ucyAyLjMuMy4xLCAzLjVcblx0XHRcdFx0XHRcdFx0XHRcdC8vIGh0dHBzOi8vcHJvbWlzZXNhcGx1cy5jb20vI3BvaW50LTU0XG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBodHRwczovL3Byb21pc2VzYXBsdXMuY29tLyNwb2ludC03NVxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gUmV0cmlldmUgYHRoZW5gIG9ubHkgb25jZVxuXHRcdFx0XHRcdFx0XHRcdFx0dGhlbiA9IHJldHVybmVkICYmXG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogUHJvbWlzZXMvQSsgc2VjdGlvbiAyLjMuNFxuXHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBodHRwczovL3Byb21pc2VzYXBsdXMuY29tLyNwb2ludC02NFxuXHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBPbmx5IGNoZWNrIG9iamVjdHMgYW5kIGZ1bmN0aW9ucyBmb3IgdGhlbmFiaWxpdHlcblx0XHRcdFx0XHRcdFx0XHRcdFx0KCB0eXBlb2YgcmV0dXJuZWQgPT09IFwib2JqZWN0XCIgfHxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlb2YgcmV0dXJuZWQgPT09IFwiZnVuY3Rpb25cIiApICYmXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHJldHVybmVkLnRoZW47XG5cblx0XHRcdFx0XHRcdFx0XHRcdC8vIEhhbmRsZSBhIHJldHVybmVkIHRoZW5hYmxlXG5cdFx0XHRcdFx0XHRcdFx0XHRpZiAoIGlzRnVuY3Rpb24oIHRoZW4gKSApIHtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBTcGVjaWFsIHByb2Nlc3NvcnMgKG5vdGlmeSkganVzdCB3YWl0IGZvciByZXNvbHV0aW9uXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlmICggc3BlY2lhbCApIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR0aGVuLmNhbGwoXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRyZXR1cm5lZCxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHJlc29sdmUoIG1heERlcHRoLCBkZWZlcnJlZCwgSWRlbnRpdHksIHNwZWNpYWwgKSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHJlc29sdmUoIG1heERlcHRoLCBkZWZlcnJlZCwgVGhyb3dlciwgc3BlY2lhbCApXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0KTtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBOb3JtYWwgcHJvY2Vzc29ycyAocmVzb2x2ZSkgYWxzbyBob29rIGludG8gcHJvZ3Jlc3Ncblx0XHRcdFx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdC8vIC4uLmFuZCBkaXNyZWdhcmQgb2xkZXIgcmVzb2x1dGlvbiB2YWx1ZXNcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRtYXhEZXB0aCsrO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0dGhlbi5jYWxsKFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0cmV0dXJuZWQsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRyZXNvbHZlKCBtYXhEZXB0aCwgZGVmZXJyZWQsIElkZW50aXR5LCBzcGVjaWFsICksXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRyZXNvbHZlKCBtYXhEZXB0aCwgZGVmZXJyZWQsIFRocm93ZXIsIHNwZWNpYWwgKSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHJlc29sdmUoIG1heERlcHRoLCBkZWZlcnJlZCwgSWRlbnRpdHksXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGRlZmVycmVkLm5vdGlmeVdpdGggKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gSGFuZGxlIGFsbCBvdGhlciByZXR1cm5lZCB2YWx1ZXNcblx0XHRcdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gT25seSBzdWJzdGl0dXRlIGhhbmRsZXJzIHBhc3Mgb24gY29udGV4dFxuXHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBhbmQgbXVsdGlwbGUgdmFsdWVzIChub24tc3BlYyBiZWhhdmlvcilcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWYgKCBoYW5kbGVyICE9PSBJZGVudGl0eSApIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR0aGF0ID0gdW5kZWZpbmVkO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdGFyZ3MgPSBbIHJldHVybmVkIF07XG5cdFx0XHRcdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBQcm9jZXNzIHRoZSB2YWx1ZShzKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBEZWZhdWx0IHByb2Nlc3MgaXMgcmVzb2x2ZVxuXHRcdFx0XHRcdFx0XHRcdFx0XHQoIHNwZWNpYWwgfHwgZGVmZXJyZWQucmVzb2x2ZVdpdGggKSggdGhhdCwgYXJncyApO1xuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH0sXG5cblx0XHRcdFx0XHRcdFx0XHQvLyBPbmx5IG5vcm1hbCBwcm9jZXNzb3JzIChyZXNvbHZlKSBjYXRjaCBhbmQgcmVqZWN0IGV4Y2VwdGlvbnNcblx0XHRcdFx0XHRcdFx0XHRwcm9jZXNzID0gc3BlY2lhbCA/XG5cdFx0XHRcdFx0XHRcdFx0XHRtaWdodFRocm93IDpcblx0XHRcdFx0XHRcdFx0XHRcdGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdG1pZ2h0VGhyb3coKTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0fSBjYXRjaCAoIGUgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRpZiAoIGpRdWVyeS5EZWZlcnJlZC5leGNlcHRpb25Ib29rICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0alF1ZXJ5LkRlZmVycmVkLmV4Y2VwdGlvbkhvb2soIGUsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHByb2Nlc3Muc3RhY2tUcmFjZSApO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IFByb21pc2VzL0ErIHNlY3Rpb24gMi4zLjMuMy40LjFcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBodHRwczovL3Byb21pc2VzYXBsdXMuY29tLyNwb2ludC02MVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdC8vIElnbm9yZSBwb3N0LXJlc29sdXRpb24gZXhjZXB0aW9uc1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdGlmICggZGVwdGggKyAxID49IG1heERlcHRoICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBPbmx5IHN1YnN0aXR1dGUgaGFuZGxlcnMgcGFzcyBvbiBjb250ZXh0XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBhbmQgbXVsdGlwbGUgdmFsdWVzIChub24tc3BlYyBiZWhhdmlvcilcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGlmICggaGFuZGxlciAhPT0gVGhyb3dlciApIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0dGhhdCA9IHVuZGVmaW5lZDtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0YXJncyA9IFsgZSBdO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRkZWZlcnJlZC5yZWplY3RXaXRoKCB0aGF0LCBhcmdzICk7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHR9O1xuXG5cdFx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IFByb21pc2VzL0ErIHNlY3Rpb24gMi4zLjMuMy4xXG5cdFx0XHRcdFx0XHRcdC8vIGh0dHBzOi8vcHJvbWlzZXNhcGx1cy5jb20vI3BvaW50LTU3XG5cdFx0XHRcdFx0XHRcdC8vIFJlLXJlc29sdmUgcHJvbWlzZXMgaW1tZWRpYXRlbHkgdG8gZG9kZ2UgZmFsc2UgcmVqZWN0aW9uIGZyb21cblx0XHRcdFx0XHRcdFx0Ly8gc3Vic2VxdWVudCBlcnJvcnNcblx0XHRcdFx0XHRcdFx0aWYgKCBkZXB0aCApIHtcblx0XHRcdFx0XHRcdFx0XHRwcm9jZXNzKCk7XG5cdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdFx0XHQvLyBDYWxsIGFuIG9wdGlvbmFsIGhvb2sgdG8gcmVjb3JkIHRoZSBzdGFjaywgaW4gY2FzZSBvZiBleGNlcHRpb25cblx0XHRcdFx0XHRcdFx0XHQvLyBzaW5jZSBpdCdzIG90aGVyd2lzZSBsb3N0IHdoZW4gZXhlY3V0aW9uIGdvZXMgYXN5bmNcblx0XHRcdFx0XHRcdFx0XHRpZiAoIGpRdWVyeS5EZWZlcnJlZC5nZXRTdGFja0hvb2sgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRwcm9jZXNzLnN0YWNrVHJhY2UgPSBqUXVlcnkuRGVmZXJyZWQuZ2V0U3RhY2tIb29rKCk7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdHdpbmRvdy5zZXRUaW1lb3V0KCBwcm9jZXNzICk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0cmV0dXJuIGpRdWVyeS5EZWZlcnJlZCggZnVuY3Rpb24oIG5ld0RlZmVyICkge1xuXG5cdFx0XHRcdFx0XHQvLyBwcm9ncmVzc19oYW5kbGVycy5hZGQoIC4uLiApXG5cdFx0XHRcdFx0XHR0dXBsZXNbIDAgXVsgMyBdLmFkZChcblx0XHRcdFx0XHRcdFx0cmVzb2x2ZShcblx0XHRcdFx0XHRcdFx0XHQwLFxuXHRcdFx0XHRcdFx0XHRcdG5ld0RlZmVyLFxuXHRcdFx0XHRcdFx0XHRcdGlzRnVuY3Rpb24oIG9uUHJvZ3Jlc3MgKSA/XG5cdFx0XHRcdFx0XHRcdFx0XHRvblByb2dyZXNzIDpcblx0XHRcdFx0XHRcdFx0XHRcdElkZW50aXR5LFxuXHRcdFx0XHRcdFx0XHRcdG5ld0RlZmVyLm5vdGlmeVdpdGhcblx0XHRcdFx0XHRcdFx0KVxuXHRcdFx0XHRcdFx0KTtcblxuXHRcdFx0XHRcdFx0Ly8gZnVsZmlsbGVkX2hhbmRsZXJzLmFkZCggLi4uIClcblx0XHRcdFx0XHRcdHR1cGxlc1sgMSBdWyAzIF0uYWRkKFxuXHRcdFx0XHRcdFx0XHRyZXNvbHZlKFxuXHRcdFx0XHRcdFx0XHRcdDAsXG5cdFx0XHRcdFx0XHRcdFx0bmV3RGVmZXIsXG5cdFx0XHRcdFx0XHRcdFx0aXNGdW5jdGlvbiggb25GdWxmaWxsZWQgKSA/XG5cdFx0XHRcdFx0XHRcdFx0XHRvbkZ1bGZpbGxlZCA6XG5cdFx0XHRcdFx0XHRcdFx0XHRJZGVudGl0eVxuXHRcdFx0XHRcdFx0XHQpXG5cdFx0XHRcdFx0XHQpO1xuXG5cdFx0XHRcdFx0XHQvLyByZWplY3RlZF9oYW5kbGVycy5hZGQoIC4uLiApXG5cdFx0XHRcdFx0XHR0dXBsZXNbIDIgXVsgMyBdLmFkZChcblx0XHRcdFx0XHRcdFx0cmVzb2x2ZShcblx0XHRcdFx0XHRcdFx0XHQwLFxuXHRcdFx0XHRcdFx0XHRcdG5ld0RlZmVyLFxuXHRcdFx0XHRcdFx0XHRcdGlzRnVuY3Rpb24oIG9uUmVqZWN0ZWQgKSA/XG5cdFx0XHRcdFx0XHRcdFx0XHRvblJlamVjdGVkIDpcblx0XHRcdFx0XHRcdFx0XHRcdFRocm93ZXJcblx0XHRcdFx0XHRcdFx0KVxuXHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHR9ICkucHJvbWlzZSgpO1xuXHRcdFx0XHR9LFxuXG5cdFx0XHRcdC8vIEdldCBhIHByb21pc2UgZm9yIHRoaXMgZGVmZXJyZWRcblx0XHRcdFx0Ly8gSWYgb2JqIGlzIHByb3ZpZGVkLCB0aGUgcHJvbWlzZSBhc3BlY3QgaXMgYWRkZWQgdG8gdGhlIG9iamVjdFxuXHRcdFx0XHRwcm9taXNlOiBmdW5jdGlvbiggb2JqICkge1xuXHRcdFx0XHRcdHJldHVybiBvYmogIT0gbnVsbCA/IGpRdWVyeS5leHRlbmQoIG9iaiwgcHJvbWlzZSApIDogcHJvbWlzZTtcblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdGRlZmVycmVkID0ge307XG5cblx0XHQvLyBBZGQgbGlzdC1zcGVjaWZpYyBtZXRob2RzXG5cdFx0alF1ZXJ5LmVhY2goIHR1cGxlcywgZnVuY3Rpb24oIGksIHR1cGxlICkge1xuXHRcdFx0dmFyIGxpc3QgPSB0dXBsZVsgMiBdLFxuXHRcdFx0XHRzdGF0ZVN0cmluZyA9IHR1cGxlWyA1IF07XG5cblx0XHRcdC8vIHByb21pc2UucHJvZ3Jlc3MgPSBsaXN0LmFkZFxuXHRcdFx0Ly8gcHJvbWlzZS5kb25lID0gbGlzdC5hZGRcblx0XHRcdC8vIHByb21pc2UuZmFpbCA9IGxpc3QuYWRkXG5cdFx0XHRwcm9taXNlWyB0dXBsZVsgMSBdIF0gPSBsaXN0LmFkZDtcblxuXHRcdFx0Ly8gSGFuZGxlIHN0YXRlXG5cdFx0XHRpZiAoIHN0YXRlU3RyaW5nICkge1xuXHRcdFx0XHRsaXN0LmFkZChcblx0XHRcdFx0XHRmdW5jdGlvbigpIHtcblxuXHRcdFx0XHRcdFx0Ly8gc3RhdGUgPSBcInJlc29sdmVkXCIgKGkuZS4sIGZ1bGZpbGxlZClcblx0XHRcdFx0XHRcdC8vIHN0YXRlID0gXCJyZWplY3RlZFwiXG5cdFx0XHRcdFx0XHRzdGF0ZSA9IHN0YXRlU3RyaW5nO1xuXHRcdFx0XHRcdH0sXG5cblx0XHRcdFx0XHQvLyByZWplY3RlZF9jYWxsYmFja3MuZGlzYWJsZVxuXHRcdFx0XHRcdC8vIGZ1bGZpbGxlZF9jYWxsYmFja3MuZGlzYWJsZVxuXHRcdFx0XHRcdHR1cGxlc1sgMyAtIGkgXVsgMiBdLmRpc2FibGUsXG5cblx0XHRcdFx0XHQvLyByZWplY3RlZF9oYW5kbGVycy5kaXNhYmxlXG5cdFx0XHRcdFx0Ly8gZnVsZmlsbGVkX2hhbmRsZXJzLmRpc2FibGVcblx0XHRcdFx0XHR0dXBsZXNbIDMgLSBpIF1bIDMgXS5kaXNhYmxlLFxuXG5cdFx0XHRcdFx0Ly8gcHJvZ3Jlc3NfY2FsbGJhY2tzLmxvY2tcblx0XHRcdFx0XHR0dXBsZXNbIDAgXVsgMiBdLmxvY2ssXG5cblx0XHRcdFx0XHQvLyBwcm9ncmVzc19oYW5kbGVycy5sb2NrXG5cdFx0XHRcdFx0dHVwbGVzWyAwIF1bIDMgXS5sb2NrXG5cdFx0XHRcdCk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIHByb2dyZXNzX2hhbmRsZXJzLmZpcmVcblx0XHRcdC8vIGZ1bGZpbGxlZF9oYW5kbGVycy5maXJlXG5cdFx0XHQvLyByZWplY3RlZF9oYW5kbGVycy5maXJlXG5cdFx0XHRsaXN0LmFkZCggdHVwbGVbIDMgXS5maXJlICk7XG5cblx0XHRcdC8vIGRlZmVycmVkLm5vdGlmeSA9IGZ1bmN0aW9uKCkgeyBkZWZlcnJlZC5ub3RpZnlXaXRoKC4uLikgfVxuXHRcdFx0Ly8gZGVmZXJyZWQucmVzb2x2ZSA9IGZ1bmN0aW9uKCkgeyBkZWZlcnJlZC5yZXNvbHZlV2l0aCguLi4pIH1cblx0XHRcdC8vIGRlZmVycmVkLnJlamVjdCA9IGZ1bmN0aW9uKCkgeyBkZWZlcnJlZC5yZWplY3RXaXRoKC4uLikgfVxuXHRcdFx0ZGVmZXJyZWRbIHR1cGxlWyAwIF0gXSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRkZWZlcnJlZFsgdHVwbGVbIDAgXSArIFwiV2l0aFwiIF0oIHRoaXMgPT09IGRlZmVycmVkID8gdW5kZWZpbmVkIDogdGhpcywgYXJndW1lbnRzICk7XG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fTtcblxuXHRcdFx0Ly8gZGVmZXJyZWQubm90aWZ5V2l0aCA9IGxpc3QuZmlyZVdpdGhcblx0XHRcdC8vIGRlZmVycmVkLnJlc29sdmVXaXRoID0gbGlzdC5maXJlV2l0aFxuXHRcdFx0Ly8gZGVmZXJyZWQucmVqZWN0V2l0aCA9IGxpc3QuZmlyZVdpdGhcblx0XHRcdGRlZmVycmVkWyB0dXBsZVsgMCBdICsgXCJXaXRoXCIgXSA9IGxpc3QuZmlyZVdpdGg7XG5cdFx0fSApO1xuXG5cdFx0Ly8gTWFrZSB0aGUgZGVmZXJyZWQgYSBwcm9taXNlXG5cdFx0cHJvbWlzZS5wcm9taXNlKCBkZWZlcnJlZCApO1xuXG5cdFx0Ly8gQ2FsbCBnaXZlbiBmdW5jIGlmIGFueVxuXHRcdGlmICggZnVuYyApIHtcblx0XHRcdGZ1bmMuY2FsbCggZGVmZXJyZWQsIGRlZmVycmVkICk7XG5cdFx0fVxuXG5cdFx0Ly8gQWxsIGRvbmUhXG5cdFx0cmV0dXJuIGRlZmVycmVkO1xuXHR9LFxuXG5cdC8vIERlZmVycmVkIGhlbHBlclxuXHR3aGVuOiBmdW5jdGlvbiggc2luZ2xlVmFsdWUgKSB7XG5cdFx0dmFyXG5cblx0XHRcdC8vIGNvdW50IG9mIHVuY29tcGxldGVkIHN1Ym9yZGluYXRlc1xuXHRcdFx0cmVtYWluaW5nID0gYXJndW1lbnRzLmxlbmd0aCxcblxuXHRcdFx0Ly8gY291bnQgb2YgdW5wcm9jZXNzZWQgYXJndW1lbnRzXG5cdFx0XHRpID0gcmVtYWluaW5nLFxuXG5cdFx0XHQvLyBzdWJvcmRpbmF0ZSBmdWxmaWxsbWVudCBkYXRhXG5cdFx0XHRyZXNvbHZlQ29udGV4dHMgPSBBcnJheSggaSApLFxuXHRcdFx0cmVzb2x2ZVZhbHVlcyA9IHNsaWNlLmNhbGwoIGFyZ3VtZW50cyApLFxuXG5cdFx0XHQvLyB0aGUgcHJpbWFyeSBEZWZlcnJlZFxuXHRcdFx0cHJpbWFyeSA9IGpRdWVyeS5EZWZlcnJlZCgpLFxuXG5cdFx0XHQvLyBzdWJvcmRpbmF0ZSBjYWxsYmFjayBmYWN0b3J5XG5cdFx0XHR1cGRhdGVGdW5jID0gZnVuY3Rpb24oIGkgKSB7XG5cdFx0XHRcdHJldHVybiBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0XHRcdFx0cmVzb2x2ZUNvbnRleHRzWyBpIF0gPSB0aGlzO1xuXHRcdFx0XHRcdHJlc29sdmVWYWx1ZXNbIGkgXSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxID8gc2xpY2UuY2FsbCggYXJndW1lbnRzICkgOiB2YWx1ZTtcblx0XHRcdFx0XHRpZiAoICEoIC0tcmVtYWluaW5nICkgKSB7XG5cdFx0XHRcdFx0XHRwcmltYXJ5LnJlc29sdmVXaXRoKCByZXNvbHZlQ29udGV4dHMsIHJlc29sdmVWYWx1ZXMgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH07XG5cdFx0XHR9O1xuXG5cdFx0Ly8gU2luZ2xlLSBhbmQgZW1wdHkgYXJndW1lbnRzIGFyZSBhZG9wdGVkIGxpa2UgUHJvbWlzZS5yZXNvbHZlXG5cdFx0aWYgKCByZW1haW5pbmcgPD0gMSApIHtcblx0XHRcdGFkb3B0VmFsdWUoIHNpbmdsZVZhbHVlLCBwcmltYXJ5LmRvbmUoIHVwZGF0ZUZ1bmMoIGkgKSApLnJlc29sdmUsIHByaW1hcnkucmVqZWN0LFxuXHRcdFx0XHQhcmVtYWluaW5nICk7XG5cblx0XHRcdC8vIFVzZSAudGhlbigpIHRvIHVud3JhcCBzZWNvbmRhcnkgdGhlbmFibGVzIChjZi4gZ2gtMzAwMClcblx0XHRcdGlmICggcHJpbWFyeS5zdGF0ZSgpID09PSBcInBlbmRpbmdcIiB8fFxuXHRcdFx0XHRpc0Z1bmN0aW9uKCByZXNvbHZlVmFsdWVzWyBpIF0gJiYgcmVzb2x2ZVZhbHVlc1sgaSBdLnRoZW4gKSApIHtcblxuXHRcdFx0XHRyZXR1cm4gcHJpbWFyeS50aGVuKCk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gTXVsdGlwbGUgYXJndW1lbnRzIGFyZSBhZ2dyZWdhdGVkIGxpa2UgUHJvbWlzZS5hbGwgYXJyYXkgZWxlbWVudHNcblx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdGFkb3B0VmFsdWUoIHJlc29sdmVWYWx1ZXNbIGkgXSwgdXBkYXRlRnVuYyggaSApLCBwcmltYXJ5LnJlamVjdCApO1xuXHRcdH1cblxuXHRcdHJldHVybiBwcmltYXJ5LnByb21pc2UoKTtcblx0fVxufSApO1xuXG5cbi8vIFRoZXNlIHVzdWFsbHkgaW5kaWNhdGUgYSBwcm9ncmFtbWVyIG1pc3Rha2UgZHVyaW5nIGRldmVsb3BtZW50LFxuLy8gd2FybiBhYm91dCB0aGVtIEFTQVAgcmF0aGVyIHRoYW4gc3dhbGxvd2luZyB0aGVtIGJ5IGRlZmF1bHQuXG52YXIgcmVycm9yTmFtZXMgPSAvXihFdmFsfEludGVybmFsfFJhbmdlfFJlZmVyZW5jZXxTeW50YXh8VHlwZXxVUkkpRXJyb3IkLztcblxualF1ZXJ5LkRlZmVycmVkLmV4Y2VwdGlvbkhvb2sgPSBmdW5jdGlvbiggZXJyb3IsIHN0YWNrICkge1xuXG5cdC8vIFN1cHBvcnQ6IElFIDggLSA5IG9ubHlcblx0Ly8gQ29uc29sZSBleGlzdHMgd2hlbiBkZXYgdG9vbHMgYXJlIG9wZW4sIHdoaWNoIGNhbiBoYXBwZW4gYXQgYW55IHRpbWVcblx0aWYgKCB3aW5kb3cuY29uc29sZSAmJiB3aW5kb3cuY29uc29sZS53YXJuICYmIGVycm9yICYmIHJlcnJvck5hbWVzLnRlc3QoIGVycm9yLm5hbWUgKSApIHtcblx0XHR3aW5kb3cuY29uc29sZS53YXJuKCBcImpRdWVyeS5EZWZlcnJlZCBleGNlcHRpb246IFwiICsgZXJyb3IubWVzc2FnZSwgZXJyb3Iuc3RhY2ssIHN0YWNrICk7XG5cdH1cbn07XG5cblxuXG5cbmpRdWVyeS5yZWFkeUV4Y2VwdGlvbiA9IGZ1bmN0aW9uKCBlcnJvciApIHtcblx0d2luZG93LnNldFRpbWVvdXQoIGZ1bmN0aW9uKCkge1xuXHRcdHRocm93IGVycm9yO1xuXHR9ICk7XG59O1xuXG5cblxuXG4vLyBUaGUgZGVmZXJyZWQgdXNlZCBvbiBET00gcmVhZHlcbnZhciByZWFkeUxpc3QgPSBqUXVlcnkuRGVmZXJyZWQoKTtcblxualF1ZXJ5LmZuLnJlYWR5ID0gZnVuY3Rpb24oIGZuICkge1xuXG5cdHJlYWR5TGlzdFxuXHRcdC50aGVuKCBmbiApXG5cblx0XHQvLyBXcmFwIGpRdWVyeS5yZWFkeUV4Y2VwdGlvbiBpbiBhIGZ1bmN0aW9uIHNvIHRoYXQgdGhlIGxvb2t1cFxuXHRcdC8vIGhhcHBlbnMgYXQgdGhlIHRpbWUgb2YgZXJyb3IgaGFuZGxpbmcgaW5zdGVhZCBvZiBjYWxsYmFja1xuXHRcdC8vIHJlZ2lzdHJhdGlvbi5cblx0XHQuY2F0Y2goIGZ1bmN0aW9uKCBlcnJvciApIHtcblx0XHRcdGpRdWVyeS5yZWFkeUV4Y2VwdGlvbiggZXJyb3IgKTtcblx0XHR9ICk7XG5cblx0cmV0dXJuIHRoaXM7XG59O1xuXG5qUXVlcnkuZXh0ZW5kKCB7XG5cblx0Ly8gSXMgdGhlIERPTSByZWFkeSB0byBiZSB1c2VkPyBTZXQgdG8gdHJ1ZSBvbmNlIGl0IG9jY3Vycy5cblx0aXNSZWFkeTogZmFsc2UsXG5cblx0Ly8gQSBjb3VudGVyIHRvIHRyYWNrIGhvdyBtYW55IGl0ZW1zIHRvIHdhaXQgZm9yIGJlZm9yZVxuXHQvLyB0aGUgcmVhZHkgZXZlbnQgZmlyZXMuIFNlZSAjNjc4MVxuXHRyZWFkeVdhaXQ6IDEsXG5cblx0Ly8gSGFuZGxlIHdoZW4gdGhlIERPTSBpcyByZWFkeVxuXHRyZWFkeTogZnVuY3Rpb24oIHdhaXQgKSB7XG5cblx0XHQvLyBBYm9ydCBpZiB0aGVyZSBhcmUgcGVuZGluZyBob2xkcyBvciB3ZSdyZSBhbHJlYWR5IHJlYWR5XG5cdFx0aWYgKCB3YWl0ID09PSB0cnVlID8gLS1qUXVlcnkucmVhZHlXYWl0IDogalF1ZXJ5LmlzUmVhZHkgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gUmVtZW1iZXIgdGhhdCB0aGUgRE9NIGlzIHJlYWR5XG5cdFx0alF1ZXJ5LmlzUmVhZHkgPSB0cnVlO1xuXG5cdFx0Ly8gSWYgYSBub3JtYWwgRE9NIFJlYWR5IGV2ZW50IGZpcmVkLCBkZWNyZW1lbnQsIGFuZCB3YWl0IGlmIG5lZWQgYmVcblx0XHRpZiAoIHdhaXQgIT09IHRydWUgJiYgLS1qUXVlcnkucmVhZHlXYWl0ID4gMCApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBJZiB0aGVyZSBhcmUgZnVuY3Rpb25zIGJvdW5kLCB0byBleGVjdXRlXG5cdFx0cmVhZHlMaXN0LnJlc29sdmVXaXRoKCBkb2N1bWVudCwgWyBqUXVlcnkgXSApO1xuXHR9XG59ICk7XG5cbmpRdWVyeS5yZWFkeS50aGVuID0gcmVhZHlMaXN0LnRoZW47XG5cbi8vIFRoZSByZWFkeSBldmVudCBoYW5kbGVyIGFuZCBzZWxmIGNsZWFudXAgbWV0aG9kXG5mdW5jdGlvbiBjb21wbGV0ZWQoKSB7XG5cdGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoIFwiRE9NQ29udGVudExvYWRlZFwiLCBjb21wbGV0ZWQgKTtcblx0d2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoIFwibG9hZFwiLCBjb21wbGV0ZWQgKTtcblx0alF1ZXJ5LnJlYWR5KCk7XG59XG5cbi8vIENhdGNoIGNhc2VzIHdoZXJlICQoZG9jdW1lbnQpLnJlYWR5KCkgaXMgY2FsbGVkXG4vLyBhZnRlciB0aGUgYnJvd3NlciBldmVudCBoYXMgYWxyZWFkeSBvY2N1cnJlZC5cbi8vIFN1cHBvcnQ6IElFIDw9OSAtIDEwIG9ubHlcbi8vIE9sZGVyIElFIHNvbWV0aW1lcyBzaWduYWxzIFwiaW50ZXJhY3RpdmVcIiB0b28gc29vblxuaWYgKCBkb2N1bWVudC5yZWFkeVN0YXRlID09PSBcImNvbXBsZXRlXCIgfHxcblx0KCBkb2N1bWVudC5yZWFkeVN0YXRlICE9PSBcImxvYWRpbmdcIiAmJiAhZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmRvU2Nyb2xsICkgKSB7XG5cblx0Ly8gSGFuZGxlIGl0IGFzeW5jaHJvbm91c2x5IHRvIGFsbG93IHNjcmlwdHMgdGhlIG9wcG9ydHVuaXR5IHRvIGRlbGF5IHJlYWR5XG5cdHdpbmRvdy5zZXRUaW1lb3V0KCBqUXVlcnkucmVhZHkgKTtcblxufSBlbHNlIHtcblxuXHQvLyBVc2UgdGhlIGhhbmR5IGV2ZW50IGNhbGxiYWNrXG5cdGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoIFwiRE9NQ29udGVudExvYWRlZFwiLCBjb21wbGV0ZWQgKTtcblxuXHQvLyBBIGZhbGxiYWNrIHRvIHdpbmRvdy5vbmxvYWQsIHRoYXQgd2lsbCBhbHdheXMgd29ya1xuXHR3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lciggXCJsb2FkXCIsIGNvbXBsZXRlZCApO1xufVxuXG5cblxuXG4vLyBNdWx0aWZ1bmN0aW9uYWwgbWV0aG9kIHRvIGdldCBhbmQgc2V0IHZhbHVlcyBvZiBhIGNvbGxlY3Rpb25cbi8vIFRoZSB2YWx1ZS9zIGNhbiBvcHRpb25hbGx5IGJlIGV4ZWN1dGVkIGlmIGl0J3MgYSBmdW5jdGlvblxudmFyIGFjY2VzcyA9IGZ1bmN0aW9uKCBlbGVtcywgZm4sIGtleSwgdmFsdWUsIGNoYWluYWJsZSwgZW1wdHlHZXQsIHJhdyApIHtcblx0dmFyIGkgPSAwLFxuXHRcdGxlbiA9IGVsZW1zLmxlbmd0aCxcblx0XHRidWxrID0ga2V5ID09IG51bGw7XG5cblx0Ly8gU2V0cyBtYW55IHZhbHVlc1xuXHRpZiAoIHRvVHlwZSgga2V5ICkgPT09IFwib2JqZWN0XCIgKSB7XG5cdFx0Y2hhaW5hYmxlID0gdHJ1ZTtcblx0XHRmb3IgKCBpIGluIGtleSApIHtcblx0XHRcdGFjY2VzcyggZWxlbXMsIGZuLCBpLCBrZXlbIGkgXSwgdHJ1ZSwgZW1wdHlHZXQsIHJhdyApO1xuXHRcdH1cblxuXHQvLyBTZXRzIG9uZSB2YWx1ZVxuXHR9IGVsc2UgaWYgKCB2YWx1ZSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdGNoYWluYWJsZSA9IHRydWU7XG5cblx0XHRpZiAoICFpc0Z1bmN0aW9uKCB2YWx1ZSApICkge1xuXHRcdFx0cmF3ID0gdHJ1ZTtcblx0XHR9XG5cblx0XHRpZiAoIGJ1bGsgKSB7XG5cblx0XHRcdC8vIEJ1bGsgb3BlcmF0aW9ucyBydW4gYWdhaW5zdCB0aGUgZW50aXJlIHNldFxuXHRcdFx0aWYgKCByYXcgKSB7XG5cdFx0XHRcdGZuLmNhbGwoIGVsZW1zLCB2YWx1ZSApO1xuXHRcdFx0XHRmbiA9IG51bGw7XG5cblx0XHRcdC8vIC4uLmV4Y2VwdCB3aGVuIGV4ZWN1dGluZyBmdW5jdGlvbiB2YWx1ZXNcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGJ1bGsgPSBmbjtcblx0XHRcdFx0Zm4gPSBmdW5jdGlvbiggZWxlbSwgX2tleSwgdmFsdWUgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGJ1bGsuY2FsbCggalF1ZXJ5KCBlbGVtICksIHZhbHVlICk7XG5cdFx0XHRcdH07XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKCBmbiApIHtcblx0XHRcdGZvciAoIDsgaSA8IGxlbjsgaSsrICkge1xuXHRcdFx0XHRmbihcblx0XHRcdFx0XHRlbGVtc1sgaSBdLCBrZXksIHJhdyA/XG5cdFx0XHRcdFx0XHR2YWx1ZSA6XG5cdFx0XHRcdFx0XHR2YWx1ZS5jYWxsKCBlbGVtc1sgaSBdLCBpLCBmbiggZWxlbXNbIGkgXSwga2V5ICkgKVxuXHRcdFx0XHQpO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdGlmICggY2hhaW5hYmxlICkge1xuXHRcdHJldHVybiBlbGVtcztcblx0fVxuXG5cdC8vIEdldHNcblx0aWYgKCBidWxrICkge1xuXHRcdHJldHVybiBmbi5jYWxsKCBlbGVtcyApO1xuXHR9XG5cblx0cmV0dXJuIGxlbiA/IGZuKCBlbGVtc1sgMCBdLCBrZXkgKSA6IGVtcHR5R2V0O1xufTtcblxuXG4vLyBNYXRjaGVzIGRhc2hlZCBzdHJpbmcgZm9yIGNhbWVsaXppbmdcbnZhciBybXNQcmVmaXggPSAvXi1tcy0vLFxuXHRyZGFzaEFscGhhID0gLy0oW2Etel0pL2c7XG5cbi8vIFVzZWQgYnkgY2FtZWxDYXNlIGFzIGNhbGxiYWNrIHRvIHJlcGxhY2UoKVxuZnVuY3Rpb24gZmNhbWVsQ2FzZSggX2FsbCwgbGV0dGVyICkge1xuXHRyZXR1cm4gbGV0dGVyLnRvVXBwZXJDYXNlKCk7XG59XG5cbi8vIENvbnZlcnQgZGFzaGVkIHRvIGNhbWVsQ2FzZTsgdXNlZCBieSB0aGUgY3NzIGFuZCBkYXRhIG1vZHVsZXNcbi8vIFN1cHBvcnQ6IElFIDw9OSAtIDExLCBFZGdlIDEyIC0gMTVcbi8vIE1pY3Jvc29mdCBmb3Jnb3QgdG8gaHVtcCB0aGVpciB2ZW5kb3IgcHJlZml4ICgjOTU3MilcbmZ1bmN0aW9uIGNhbWVsQ2FzZSggc3RyaW5nICkge1xuXHRyZXR1cm4gc3RyaW5nLnJlcGxhY2UoIHJtc1ByZWZpeCwgXCJtcy1cIiApLnJlcGxhY2UoIHJkYXNoQWxwaGEsIGZjYW1lbENhc2UgKTtcbn1cbnZhciBhY2NlcHREYXRhID0gZnVuY3Rpb24oIG93bmVyICkge1xuXG5cdC8vIEFjY2VwdHMgb25seTpcblx0Ly8gIC0gTm9kZVxuXHQvLyAgICAtIE5vZGUuRUxFTUVOVF9OT0RFXG5cdC8vICAgIC0gTm9kZS5ET0NVTUVOVF9OT0RFXG5cdC8vICAtIE9iamVjdFxuXHQvLyAgICAtIEFueVxuXHRyZXR1cm4gb3duZXIubm9kZVR5cGUgPT09IDEgfHwgb3duZXIubm9kZVR5cGUgPT09IDkgfHwgISggK293bmVyLm5vZGVUeXBlICk7XG59O1xuXG5cblxuXG5mdW5jdGlvbiBEYXRhKCkge1xuXHR0aGlzLmV4cGFuZG8gPSBqUXVlcnkuZXhwYW5kbyArIERhdGEudWlkKys7XG59XG5cbkRhdGEudWlkID0gMTtcblxuRGF0YS5wcm90b3R5cGUgPSB7XG5cblx0Y2FjaGU6IGZ1bmN0aW9uKCBvd25lciApIHtcblxuXHRcdC8vIENoZWNrIGlmIHRoZSBvd25lciBvYmplY3QgYWxyZWFkeSBoYXMgYSBjYWNoZVxuXHRcdHZhciB2YWx1ZSA9IG93bmVyWyB0aGlzLmV4cGFuZG8gXTtcblxuXHRcdC8vIElmIG5vdCwgY3JlYXRlIG9uZVxuXHRcdGlmICggIXZhbHVlICkge1xuXHRcdFx0dmFsdWUgPSB7fTtcblxuXHRcdFx0Ly8gV2UgY2FuIGFjY2VwdCBkYXRhIGZvciBub24tZWxlbWVudCBub2RlcyBpbiBtb2Rlcm4gYnJvd3NlcnMsXG5cdFx0XHQvLyBidXQgd2Ugc2hvdWxkIG5vdCwgc2VlICM4MzM1LlxuXHRcdFx0Ly8gQWx3YXlzIHJldHVybiBhbiBlbXB0eSBvYmplY3QuXG5cdFx0XHRpZiAoIGFjY2VwdERhdGEoIG93bmVyICkgKSB7XG5cblx0XHRcdFx0Ly8gSWYgaXQgaXMgYSBub2RlIHVubGlrZWx5IHRvIGJlIHN0cmluZ2lmeS1lZCBvciBsb29wZWQgb3ZlclxuXHRcdFx0XHQvLyB1c2UgcGxhaW4gYXNzaWdubWVudFxuXHRcdFx0XHRpZiAoIG93bmVyLm5vZGVUeXBlICkge1xuXHRcdFx0XHRcdG93bmVyWyB0aGlzLmV4cGFuZG8gXSA9IHZhbHVlO1xuXG5cdFx0XHRcdC8vIE90aGVyd2lzZSBzZWN1cmUgaXQgaW4gYSBub24tZW51bWVyYWJsZSBwcm9wZXJ0eVxuXHRcdFx0XHQvLyBjb25maWd1cmFibGUgbXVzdCBiZSB0cnVlIHRvIGFsbG93IHRoZSBwcm9wZXJ0eSB0byBiZVxuXHRcdFx0XHQvLyBkZWxldGVkIHdoZW4gZGF0YSBpcyByZW1vdmVkXG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KCBvd25lciwgdGhpcy5leHBhbmRvLCB7XG5cdFx0XHRcdFx0XHR2YWx1ZTogdmFsdWUsXG5cdFx0XHRcdFx0XHRjb25maWd1cmFibGU6IHRydWVcblx0XHRcdFx0XHR9ICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gdmFsdWU7XG5cdH0sXG5cdHNldDogZnVuY3Rpb24oIG93bmVyLCBkYXRhLCB2YWx1ZSApIHtcblx0XHR2YXIgcHJvcCxcblx0XHRcdGNhY2hlID0gdGhpcy5jYWNoZSggb3duZXIgKTtcblxuXHRcdC8vIEhhbmRsZTogWyBvd25lciwga2V5LCB2YWx1ZSBdIGFyZ3Ncblx0XHQvLyBBbHdheXMgdXNlIGNhbWVsQ2FzZSBrZXkgKGdoLTIyNTcpXG5cdFx0aWYgKCB0eXBlb2YgZGF0YSA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdGNhY2hlWyBjYW1lbENhc2UoIGRhdGEgKSBdID0gdmFsdWU7XG5cblx0XHQvLyBIYW5kbGU6IFsgb3duZXIsIHsgcHJvcGVydGllcyB9IF0gYXJnc1xuXHRcdH0gZWxzZSB7XG5cblx0XHRcdC8vIENvcHkgdGhlIHByb3BlcnRpZXMgb25lLWJ5LW9uZSB0byB0aGUgY2FjaGUgb2JqZWN0XG5cdFx0XHRmb3IgKCBwcm9wIGluIGRhdGEgKSB7XG5cdFx0XHRcdGNhY2hlWyBjYW1lbENhc2UoIHByb3AgKSBdID0gZGF0YVsgcHJvcCBdO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gY2FjaGU7XG5cdH0sXG5cdGdldDogZnVuY3Rpb24oIG93bmVyLCBrZXkgKSB7XG5cdFx0cmV0dXJuIGtleSA9PT0gdW5kZWZpbmVkID9cblx0XHRcdHRoaXMuY2FjaGUoIG93bmVyICkgOlxuXG5cdFx0XHQvLyBBbHdheXMgdXNlIGNhbWVsQ2FzZSBrZXkgKGdoLTIyNTcpXG5cdFx0XHRvd25lclsgdGhpcy5leHBhbmRvIF0gJiYgb3duZXJbIHRoaXMuZXhwYW5kbyBdWyBjYW1lbENhc2UoIGtleSApIF07XG5cdH0sXG5cdGFjY2VzczogZnVuY3Rpb24oIG93bmVyLCBrZXksIHZhbHVlICkge1xuXG5cdFx0Ly8gSW4gY2FzZXMgd2hlcmUgZWl0aGVyOlxuXHRcdC8vXG5cdFx0Ly8gICAxLiBObyBrZXkgd2FzIHNwZWNpZmllZFxuXHRcdC8vICAgMi4gQSBzdHJpbmcga2V5IHdhcyBzcGVjaWZpZWQsIGJ1dCBubyB2YWx1ZSBwcm92aWRlZFxuXHRcdC8vXG5cdFx0Ly8gVGFrZSB0aGUgXCJyZWFkXCIgcGF0aCBhbmQgYWxsb3cgdGhlIGdldCBtZXRob2QgdG8gZGV0ZXJtaW5lXG5cdFx0Ly8gd2hpY2ggdmFsdWUgdG8gcmV0dXJuLCByZXNwZWN0aXZlbHkgZWl0aGVyOlxuXHRcdC8vXG5cdFx0Ly8gICAxLiBUaGUgZW50aXJlIGNhY2hlIG9iamVjdFxuXHRcdC8vICAgMi4gVGhlIGRhdGEgc3RvcmVkIGF0IHRoZSBrZXlcblx0XHQvL1xuXHRcdGlmICgga2V5ID09PSB1bmRlZmluZWQgfHxcblx0XHRcdFx0KCAoIGtleSAmJiB0eXBlb2Yga2V5ID09PSBcInN0cmluZ1wiICkgJiYgdmFsdWUgPT09IHVuZGVmaW5lZCApICkge1xuXG5cdFx0XHRyZXR1cm4gdGhpcy5nZXQoIG93bmVyLCBrZXkgKTtcblx0XHR9XG5cblx0XHQvLyBXaGVuIHRoZSBrZXkgaXMgbm90IGEgc3RyaW5nLCBvciBib3RoIGEga2V5IGFuZCB2YWx1ZVxuXHRcdC8vIGFyZSBzcGVjaWZpZWQsIHNldCBvciBleHRlbmQgKGV4aXN0aW5nIG9iamVjdHMpIHdpdGggZWl0aGVyOlxuXHRcdC8vXG5cdFx0Ly8gICAxLiBBbiBvYmplY3Qgb2YgcHJvcGVydGllc1xuXHRcdC8vICAgMi4gQSBrZXkgYW5kIHZhbHVlXG5cdFx0Ly9cblx0XHR0aGlzLnNldCggb3duZXIsIGtleSwgdmFsdWUgKTtcblxuXHRcdC8vIFNpbmNlIHRoZSBcInNldFwiIHBhdGggY2FuIGhhdmUgdHdvIHBvc3NpYmxlIGVudHJ5IHBvaW50c1xuXHRcdC8vIHJldHVybiB0aGUgZXhwZWN0ZWQgZGF0YSBiYXNlZCBvbiB3aGljaCBwYXRoIHdhcyB0YWtlblsqXVxuXHRcdHJldHVybiB2YWx1ZSAhPT0gdW5kZWZpbmVkID8gdmFsdWUgOiBrZXk7XG5cdH0sXG5cdHJlbW92ZTogZnVuY3Rpb24oIG93bmVyLCBrZXkgKSB7XG5cdFx0dmFyIGksXG5cdFx0XHRjYWNoZSA9IG93bmVyWyB0aGlzLmV4cGFuZG8gXTtcblxuXHRcdGlmICggY2FjaGUgPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRpZiAoIGtleSAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHQvLyBTdXBwb3J0IGFycmF5IG9yIHNwYWNlIHNlcGFyYXRlZCBzdHJpbmcgb2Yga2V5c1xuXHRcdFx0aWYgKCBBcnJheS5pc0FycmF5KCBrZXkgKSApIHtcblxuXHRcdFx0XHQvLyBJZiBrZXkgaXMgYW4gYXJyYXkgb2Yga2V5cy4uLlxuXHRcdFx0XHQvLyBXZSBhbHdheXMgc2V0IGNhbWVsQ2FzZSBrZXlzLCBzbyByZW1vdmUgdGhhdC5cblx0XHRcdFx0a2V5ID0ga2V5Lm1hcCggY2FtZWxDYXNlICk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRrZXkgPSBjYW1lbENhc2UoIGtleSApO1xuXG5cdFx0XHRcdC8vIElmIGEga2V5IHdpdGggdGhlIHNwYWNlcyBleGlzdHMsIHVzZSBpdC5cblx0XHRcdFx0Ly8gT3RoZXJ3aXNlLCBjcmVhdGUgYW4gYXJyYXkgYnkgbWF0Y2hpbmcgbm9uLXdoaXRlc3BhY2Vcblx0XHRcdFx0a2V5ID0ga2V5IGluIGNhY2hlID9cblx0XHRcdFx0XHRbIGtleSBdIDpcblx0XHRcdFx0XHQoIGtleS5tYXRjaCggcm5vdGh0bWx3aGl0ZSApIHx8IFtdICk7XG5cdFx0XHR9XG5cblx0XHRcdGkgPSBrZXkubGVuZ3RoO1xuXG5cdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0ZGVsZXRlIGNhY2hlWyBrZXlbIGkgXSBdO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIFJlbW92ZSB0aGUgZXhwYW5kbyBpZiB0aGVyZSdzIG5vIG1vcmUgZGF0YVxuXHRcdGlmICgga2V5ID09PSB1bmRlZmluZWQgfHwgalF1ZXJ5LmlzRW1wdHlPYmplY3QoIGNhY2hlICkgKSB7XG5cblx0XHRcdC8vIFN1cHBvcnQ6IENocm9tZSA8PTM1IC0gNDVcblx0XHRcdC8vIFdlYmtpdCAmIEJsaW5rIHBlcmZvcm1hbmNlIHN1ZmZlcnMgd2hlbiBkZWxldGluZyBwcm9wZXJ0aWVzXG5cdFx0XHQvLyBmcm9tIERPTSBub2Rlcywgc28gc2V0IHRvIHVuZGVmaW5lZCBpbnN0ZWFkXG5cdFx0XHQvLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD0zNzg2MDcgKGJ1ZyByZXN0cmljdGVkKVxuXHRcdFx0aWYgKCBvd25lci5ub2RlVHlwZSApIHtcblx0XHRcdFx0b3duZXJbIHRoaXMuZXhwYW5kbyBdID0gdW5kZWZpbmVkO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0ZGVsZXRlIG93bmVyWyB0aGlzLmV4cGFuZG8gXTtcblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cdGhhc0RhdGE6IGZ1bmN0aW9uKCBvd25lciApIHtcblx0XHR2YXIgY2FjaGUgPSBvd25lclsgdGhpcy5leHBhbmRvIF07XG5cdFx0cmV0dXJuIGNhY2hlICE9PSB1bmRlZmluZWQgJiYgIWpRdWVyeS5pc0VtcHR5T2JqZWN0KCBjYWNoZSApO1xuXHR9XG59O1xudmFyIGRhdGFQcml2ID0gbmV3IERhdGEoKTtcblxudmFyIGRhdGFVc2VyID0gbmV3IERhdGEoKTtcblxuXG5cbi8vXHRJbXBsZW1lbnRhdGlvbiBTdW1tYXJ5XG4vL1xuLy9cdDEuIEVuZm9yY2UgQVBJIHN1cmZhY2UgYW5kIHNlbWFudGljIGNvbXBhdGliaWxpdHkgd2l0aCAxLjkueCBicmFuY2hcbi8vXHQyLiBJbXByb3ZlIHRoZSBtb2R1bGUncyBtYWludGFpbmFiaWxpdHkgYnkgcmVkdWNpbmcgdGhlIHN0b3JhZ2Vcbi8vXHRcdHBhdGhzIHRvIGEgc2luZ2xlIG1lY2hhbmlzbS5cbi8vXHQzLiBVc2UgdGhlIHNhbWUgc2luZ2xlIG1lY2hhbmlzbSB0byBzdXBwb3J0IFwicHJpdmF0ZVwiIGFuZCBcInVzZXJcIiBkYXRhLlxuLy9cdDQuIF9OZXZlcl8gZXhwb3NlIFwicHJpdmF0ZVwiIGRhdGEgdG8gdXNlciBjb2RlIChUT0RPOiBEcm9wIF9kYXRhLCBfcmVtb3ZlRGF0YSlcbi8vXHQ1LiBBdm9pZCBleHBvc2luZyBpbXBsZW1lbnRhdGlvbiBkZXRhaWxzIG9uIHVzZXIgb2JqZWN0cyAoZWcuIGV4cGFuZG8gcHJvcGVydGllcylcbi8vXHQ2LiBQcm92aWRlIGEgY2xlYXIgcGF0aCBmb3IgaW1wbGVtZW50YXRpb24gdXBncmFkZSB0byBXZWFrTWFwIGluIDIwMTRcblxudmFyIHJicmFjZSA9IC9eKD86XFx7W1xcd1xcV10qXFx9fFxcW1tcXHdcXFddKlxcXSkkLyxcblx0cm11bHRpRGFzaCA9IC9bQS1aXS9nO1xuXG5mdW5jdGlvbiBnZXREYXRhKCBkYXRhICkge1xuXHRpZiAoIGRhdGEgPT09IFwidHJ1ZVwiICkge1xuXHRcdHJldHVybiB0cnVlO1xuXHR9XG5cblx0aWYgKCBkYXRhID09PSBcImZhbHNlXCIgKSB7XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG5cblx0aWYgKCBkYXRhID09PSBcIm51bGxcIiApIHtcblx0XHRyZXR1cm4gbnVsbDtcblx0fVxuXG5cdC8vIE9ubHkgY29udmVydCB0byBhIG51bWJlciBpZiBpdCBkb2Vzbid0IGNoYW5nZSB0aGUgc3RyaW5nXG5cdGlmICggZGF0YSA9PT0gK2RhdGEgKyBcIlwiICkge1xuXHRcdHJldHVybiArZGF0YTtcblx0fVxuXG5cdGlmICggcmJyYWNlLnRlc3QoIGRhdGEgKSApIHtcblx0XHRyZXR1cm4gSlNPTi5wYXJzZSggZGF0YSApO1xuXHR9XG5cblx0cmV0dXJuIGRhdGE7XG59XG5cbmZ1bmN0aW9uIGRhdGFBdHRyKCBlbGVtLCBrZXksIGRhdGEgKSB7XG5cdHZhciBuYW1lO1xuXG5cdC8vIElmIG5vdGhpbmcgd2FzIGZvdW5kIGludGVybmFsbHksIHRyeSB0byBmZXRjaCBhbnlcblx0Ly8gZGF0YSBmcm9tIHRoZSBIVE1MNSBkYXRhLSogYXR0cmlidXRlXG5cdGlmICggZGF0YSA9PT0gdW5kZWZpbmVkICYmIGVsZW0ubm9kZVR5cGUgPT09IDEgKSB7XG5cdFx0bmFtZSA9IFwiZGF0YS1cIiArIGtleS5yZXBsYWNlKCBybXVsdGlEYXNoLCBcIi0kJlwiICkudG9Mb3dlckNhc2UoKTtcblx0XHRkYXRhID0gZWxlbS5nZXRBdHRyaWJ1dGUoIG5hbWUgKTtcblxuXHRcdGlmICggdHlwZW9mIGRhdGEgPT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHR0cnkge1xuXHRcdFx0XHRkYXRhID0gZ2V0RGF0YSggZGF0YSApO1xuXHRcdFx0fSBjYXRjaCAoIGUgKSB7fVxuXG5cdFx0XHQvLyBNYWtlIHN1cmUgd2Ugc2V0IHRoZSBkYXRhIHNvIGl0IGlzbid0IGNoYW5nZWQgbGF0ZXJcblx0XHRcdGRhdGFVc2VyLnNldCggZWxlbSwga2V5LCBkYXRhICk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGRhdGEgPSB1bmRlZmluZWQ7XG5cdFx0fVxuXHR9XG5cdHJldHVybiBkYXRhO1xufVxuXG5qUXVlcnkuZXh0ZW5kKCB7XG5cdGhhc0RhdGE6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHJldHVybiBkYXRhVXNlci5oYXNEYXRhKCBlbGVtICkgfHwgZGF0YVByaXYuaGFzRGF0YSggZWxlbSApO1xuXHR9LFxuXG5cdGRhdGE6IGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCBkYXRhICkge1xuXHRcdHJldHVybiBkYXRhVXNlci5hY2Nlc3MoIGVsZW0sIG5hbWUsIGRhdGEgKTtcblx0fSxcblxuXHRyZW1vdmVEYXRhOiBmdW5jdGlvbiggZWxlbSwgbmFtZSApIHtcblx0XHRkYXRhVXNlci5yZW1vdmUoIGVsZW0sIG5hbWUgKTtcblx0fSxcblxuXHQvLyBUT0RPOiBOb3cgdGhhdCBhbGwgY2FsbHMgdG8gX2RhdGEgYW5kIF9yZW1vdmVEYXRhIGhhdmUgYmVlbiByZXBsYWNlZFxuXHQvLyB3aXRoIGRpcmVjdCBjYWxscyB0byBkYXRhUHJpdiBtZXRob2RzLCB0aGVzZSBjYW4gYmUgZGVwcmVjYXRlZC5cblx0X2RhdGE6IGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCBkYXRhICkge1xuXHRcdHJldHVybiBkYXRhUHJpdi5hY2Nlc3MoIGVsZW0sIG5hbWUsIGRhdGEgKTtcblx0fSxcblxuXHRfcmVtb3ZlRGF0YTogZnVuY3Rpb24oIGVsZW0sIG5hbWUgKSB7XG5cdFx0ZGF0YVByaXYucmVtb3ZlKCBlbGVtLCBuYW1lICk7XG5cdH1cbn0gKTtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHRkYXRhOiBmdW5jdGlvbigga2V5LCB2YWx1ZSApIHtcblx0XHR2YXIgaSwgbmFtZSwgZGF0YSxcblx0XHRcdGVsZW0gPSB0aGlzWyAwIF0sXG5cdFx0XHRhdHRycyA9IGVsZW0gJiYgZWxlbS5hdHRyaWJ1dGVzO1xuXG5cdFx0Ly8gR2V0cyBhbGwgdmFsdWVzXG5cdFx0aWYgKCBrZXkgPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdGlmICggdGhpcy5sZW5ndGggKSB7XG5cdFx0XHRcdGRhdGEgPSBkYXRhVXNlci5nZXQoIGVsZW0gKTtcblxuXHRcdFx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDEgJiYgIWRhdGFQcml2LmdldCggZWxlbSwgXCJoYXNEYXRhQXR0cnNcIiApICkge1xuXHRcdFx0XHRcdGkgPSBhdHRycy5sZW5ndGg7XG5cdFx0XHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cblx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDExIG9ubHlcblx0XHRcdFx0XHRcdC8vIFRoZSBhdHRycyBlbGVtZW50cyBjYW4gYmUgbnVsbCAoIzE0ODk0KVxuXHRcdFx0XHRcdFx0aWYgKCBhdHRyc1sgaSBdICkge1xuXHRcdFx0XHRcdFx0XHRuYW1lID0gYXR0cnNbIGkgXS5uYW1lO1xuXHRcdFx0XHRcdFx0XHRpZiAoIG5hbWUuaW5kZXhPZiggXCJkYXRhLVwiICkgPT09IDAgKSB7XG5cdFx0XHRcdFx0XHRcdFx0bmFtZSA9IGNhbWVsQ2FzZSggbmFtZS5zbGljZSggNSApICk7XG5cdFx0XHRcdFx0XHRcdFx0ZGF0YUF0dHIoIGVsZW0sIG5hbWUsIGRhdGFbIG5hbWUgXSApO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGRhdGFQcml2LnNldCggZWxlbSwgXCJoYXNEYXRhQXR0cnNcIiwgdHJ1ZSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBkYXRhO1xuXHRcdH1cblxuXHRcdC8vIFNldHMgbXVsdGlwbGUgdmFsdWVzXG5cdFx0aWYgKCB0eXBlb2Yga2V5ID09PSBcIm9iamVjdFwiICkge1xuXHRcdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGRhdGFVc2VyLnNldCggdGhpcywga2V5ICk7XG5cdFx0XHR9ICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGFjY2VzcyggdGhpcywgZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdFx0dmFyIGRhdGE7XG5cblx0XHRcdC8vIFRoZSBjYWxsaW5nIGpRdWVyeSBvYmplY3QgKGVsZW1lbnQgbWF0Y2hlcykgaXMgbm90IGVtcHR5XG5cdFx0XHQvLyAoYW5kIHRoZXJlZm9yZSBoYXMgYW4gZWxlbWVudCBhcHBlYXJzIGF0IHRoaXNbIDAgXSkgYW5kIHRoZVxuXHRcdFx0Ly8gYHZhbHVlYCBwYXJhbWV0ZXIgd2FzIG5vdCB1bmRlZmluZWQuIEFuIGVtcHR5IGpRdWVyeSBvYmplY3Rcblx0XHRcdC8vIHdpbGwgcmVzdWx0IGluIGB1bmRlZmluZWRgIGZvciBlbGVtID0gdGhpc1sgMCBdIHdoaWNoIHdpbGxcblx0XHRcdC8vIHRocm93IGFuIGV4Y2VwdGlvbiBpZiBhbiBhdHRlbXB0IHRvIHJlYWQgYSBkYXRhIGNhY2hlIGlzIG1hZGUuXG5cdFx0XHRpZiAoIGVsZW0gJiYgdmFsdWUgPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHQvLyBBdHRlbXB0IHRvIGdldCBkYXRhIGZyb20gdGhlIGNhY2hlXG5cdFx0XHRcdC8vIFRoZSBrZXkgd2lsbCBhbHdheXMgYmUgY2FtZWxDYXNlZCBpbiBEYXRhXG5cdFx0XHRcdGRhdGEgPSBkYXRhVXNlci5nZXQoIGVsZW0sIGtleSApO1xuXHRcdFx0XHRpZiAoIGRhdGEgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHRyZXR1cm4gZGF0YTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIEF0dGVtcHQgdG8gXCJkaXNjb3ZlclwiIHRoZSBkYXRhIGluXG5cdFx0XHRcdC8vIEhUTUw1IGN1c3RvbSBkYXRhLSogYXR0cnNcblx0XHRcdFx0ZGF0YSA9IGRhdGFBdHRyKCBlbGVtLCBrZXkgKTtcblx0XHRcdFx0aWYgKCBkYXRhICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGRhdGE7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBXZSB0cmllZCByZWFsbHkgaGFyZCwgYnV0IHRoZSBkYXRhIGRvZXNuJ3QgZXhpc3QuXG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gU2V0IHRoZSBkYXRhLi4uXG5cdFx0XHR0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXG5cdFx0XHRcdC8vIFdlIGFsd2F5cyBzdG9yZSB0aGUgY2FtZWxDYXNlZCBrZXlcblx0XHRcdFx0ZGF0YVVzZXIuc2V0KCB0aGlzLCBrZXksIHZhbHVlICk7XG5cdFx0XHR9ICk7XG5cdFx0fSwgbnVsbCwgdmFsdWUsIGFyZ3VtZW50cy5sZW5ndGggPiAxLCBudWxsLCB0cnVlICk7XG5cdH0sXG5cblx0cmVtb3ZlRGF0YTogZnVuY3Rpb24oIGtleSApIHtcblx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdGRhdGFVc2VyLnJlbW92ZSggdGhpcywga2V5ICk7XG5cdFx0fSApO1xuXHR9XG59ICk7XG5cblxualF1ZXJ5LmV4dGVuZCgge1xuXHRxdWV1ZTogZnVuY3Rpb24oIGVsZW0sIHR5cGUsIGRhdGEgKSB7XG5cdFx0dmFyIHF1ZXVlO1xuXG5cdFx0aWYgKCBlbGVtICkge1xuXHRcdFx0dHlwZSA9ICggdHlwZSB8fCBcImZ4XCIgKSArIFwicXVldWVcIjtcblx0XHRcdHF1ZXVlID0gZGF0YVByaXYuZ2V0KCBlbGVtLCB0eXBlICk7XG5cblx0XHRcdC8vIFNwZWVkIHVwIGRlcXVldWUgYnkgZ2V0dGluZyBvdXQgcXVpY2tseSBpZiB0aGlzIGlzIGp1c3QgYSBsb29rdXBcblx0XHRcdGlmICggZGF0YSApIHtcblx0XHRcdFx0aWYgKCAhcXVldWUgfHwgQXJyYXkuaXNBcnJheSggZGF0YSApICkge1xuXHRcdFx0XHRcdHF1ZXVlID0gZGF0YVByaXYuYWNjZXNzKCBlbGVtLCB0eXBlLCBqUXVlcnkubWFrZUFycmF5KCBkYXRhICkgKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRxdWV1ZS5wdXNoKCBkYXRhICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiBxdWV1ZSB8fCBbXTtcblx0XHR9XG5cdH0sXG5cblx0ZGVxdWV1ZTogZnVuY3Rpb24oIGVsZW0sIHR5cGUgKSB7XG5cdFx0dHlwZSA9IHR5cGUgfHwgXCJmeFwiO1xuXG5cdFx0dmFyIHF1ZXVlID0galF1ZXJ5LnF1ZXVlKCBlbGVtLCB0eXBlICksXG5cdFx0XHRzdGFydExlbmd0aCA9IHF1ZXVlLmxlbmd0aCxcblx0XHRcdGZuID0gcXVldWUuc2hpZnQoKSxcblx0XHRcdGhvb2tzID0galF1ZXJ5Ll9xdWV1ZUhvb2tzKCBlbGVtLCB0eXBlICksXG5cdFx0XHRuZXh0ID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGpRdWVyeS5kZXF1ZXVlKCBlbGVtLCB0eXBlICk7XG5cdFx0XHR9O1xuXG5cdFx0Ly8gSWYgdGhlIGZ4IHF1ZXVlIGlzIGRlcXVldWVkLCBhbHdheXMgcmVtb3ZlIHRoZSBwcm9ncmVzcyBzZW50aW5lbFxuXHRcdGlmICggZm4gPT09IFwiaW5wcm9ncmVzc1wiICkge1xuXHRcdFx0Zm4gPSBxdWV1ZS5zaGlmdCgpO1xuXHRcdFx0c3RhcnRMZW5ndGgtLTtcblx0XHR9XG5cblx0XHRpZiAoIGZuICkge1xuXG5cdFx0XHQvLyBBZGQgYSBwcm9ncmVzcyBzZW50aW5lbCB0byBwcmV2ZW50IHRoZSBmeCBxdWV1ZSBmcm9tIGJlaW5nXG5cdFx0XHQvLyBhdXRvbWF0aWNhbGx5IGRlcXVldWVkXG5cdFx0XHRpZiAoIHR5cGUgPT09IFwiZnhcIiApIHtcblx0XHRcdFx0cXVldWUudW5zaGlmdCggXCJpbnByb2dyZXNzXCIgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQ2xlYXIgdXAgdGhlIGxhc3QgcXVldWUgc3RvcCBmdW5jdGlvblxuXHRcdFx0ZGVsZXRlIGhvb2tzLnN0b3A7XG5cdFx0XHRmbi5jYWxsKCBlbGVtLCBuZXh0LCBob29rcyApO1xuXHRcdH1cblxuXHRcdGlmICggIXN0YXJ0TGVuZ3RoICYmIGhvb2tzICkge1xuXHRcdFx0aG9va3MuZW1wdHkuZmlyZSgpO1xuXHRcdH1cblx0fSxcblxuXHQvLyBOb3QgcHVibGljIC0gZ2VuZXJhdGUgYSBxdWV1ZUhvb2tzIG9iamVjdCwgb3IgcmV0dXJuIHRoZSBjdXJyZW50IG9uZVxuXHRfcXVldWVIb29rczogZnVuY3Rpb24oIGVsZW0sIHR5cGUgKSB7XG5cdFx0dmFyIGtleSA9IHR5cGUgKyBcInF1ZXVlSG9va3NcIjtcblx0XHRyZXR1cm4gZGF0YVByaXYuZ2V0KCBlbGVtLCBrZXkgKSB8fCBkYXRhUHJpdi5hY2Nlc3MoIGVsZW0sIGtleSwge1xuXHRcdFx0ZW1wdHk6IGpRdWVyeS5DYWxsYmFja3MoIFwib25jZSBtZW1vcnlcIiApLmFkZCggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGRhdGFQcml2LnJlbW92ZSggZWxlbSwgWyB0eXBlICsgXCJxdWV1ZVwiLCBrZXkgXSApO1xuXHRcdFx0fSApXG5cdFx0fSApO1xuXHR9XG59ICk7XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0cXVldWU6IGZ1bmN0aW9uKCB0eXBlLCBkYXRhICkge1xuXHRcdHZhciBzZXR0ZXIgPSAyO1xuXG5cdFx0aWYgKCB0eXBlb2YgdHlwZSAhPT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdGRhdGEgPSB0eXBlO1xuXHRcdFx0dHlwZSA9IFwiZnhcIjtcblx0XHRcdHNldHRlci0tO1xuXHRcdH1cblxuXHRcdGlmICggYXJndW1lbnRzLmxlbmd0aCA8IHNldHRlciApIHtcblx0XHRcdHJldHVybiBqUXVlcnkucXVldWUoIHRoaXNbIDAgXSwgdHlwZSApO1xuXHRcdH1cblxuXHRcdHJldHVybiBkYXRhID09PSB1bmRlZmluZWQgP1xuXHRcdFx0dGhpcyA6XG5cdFx0XHR0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgcXVldWUgPSBqUXVlcnkucXVldWUoIHRoaXMsIHR5cGUsIGRhdGEgKTtcblxuXHRcdFx0XHQvLyBFbnN1cmUgYSBob29rcyBmb3IgdGhpcyBxdWV1ZVxuXHRcdFx0XHRqUXVlcnkuX3F1ZXVlSG9va3MoIHRoaXMsIHR5cGUgKTtcblxuXHRcdFx0XHRpZiAoIHR5cGUgPT09IFwiZnhcIiAmJiBxdWV1ZVsgMCBdICE9PSBcImlucHJvZ3Jlc3NcIiApIHtcblx0XHRcdFx0XHRqUXVlcnkuZGVxdWV1ZSggdGhpcywgdHlwZSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9ICk7XG5cdH0sXG5cdGRlcXVldWU6IGZ1bmN0aW9uKCB0eXBlICkge1xuXHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0alF1ZXJ5LmRlcXVldWUoIHRoaXMsIHR5cGUgKTtcblx0XHR9ICk7XG5cdH0sXG5cdGNsZWFyUXVldWU6IGZ1bmN0aW9uKCB0eXBlICkge1xuXHRcdHJldHVybiB0aGlzLnF1ZXVlKCB0eXBlIHx8IFwiZnhcIiwgW10gKTtcblx0fSxcblxuXHQvLyBHZXQgYSBwcm9taXNlIHJlc29sdmVkIHdoZW4gcXVldWVzIG9mIGEgY2VydGFpbiB0eXBlXG5cdC8vIGFyZSBlbXB0aWVkIChmeCBpcyB0aGUgdHlwZSBieSBkZWZhdWx0KVxuXHRwcm9taXNlOiBmdW5jdGlvbiggdHlwZSwgb2JqICkge1xuXHRcdHZhciB0bXAsXG5cdFx0XHRjb3VudCA9IDEsXG5cdFx0XHRkZWZlciA9IGpRdWVyeS5EZWZlcnJlZCgpLFxuXHRcdFx0ZWxlbWVudHMgPSB0aGlzLFxuXHRcdFx0aSA9IHRoaXMubGVuZ3RoLFxuXHRcdFx0cmVzb2x2ZSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAoICEoIC0tY291bnQgKSApIHtcblx0XHRcdFx0XHRkZWZlci5yZXNvbHZlV2l0aCggZWxlbWVudHMsIFsgZWxlbWVudHMgXSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXG5cdFx0aWYgKCB0eXBlb2YgdHlwZSAhPT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdG9iaiA9IHR5cGU7XG5cdFx0XHR0eXBlID0gdW5kZWZpbmVkO1xuXHRcdH1cblx0XHR0eXBlID0gdHlwZSB8fCBcImZ4XCI7XG5cblx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdHRtcCA9IGRhdGFQcml2LmdldCggZWxlbWVudHNbIGkgXSwgdHlwZSArIFwicXVldWVIb29rc1wiICk7XG5cdFx0XHRpZiAoIHRtcCAmJiB0bXAuZW1wdHkgKSB7XG5cdFx0XHRcdGNvdW50Kys7XG5cdFx0XHRcdHRtcC5lbXB0eS5hZGQoIHJlc29sdmUgKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmVzb2x2ZSgpO1xuXHRcdHJldHVybiBkZWZlci5wcm9taXNlKCBvYmogKTtcblx0fVxufSApO1xudmFyIHBudW0gPSAoIC9bKy1dPyg/OlxcZCpcXC58KVxcZCsoPzpbZUVdWystXT9cXGQrfCkvICkuc291cmNlO1xuXG52YXIgcmNzc051bSA9IG5ldyBSZWdFeHAoIFwiXig/OihbKy1dKT18KShcIiArIHBudW0gKyBcIikoW2EteiVdKikkXCIsIFwiaVwiICk7XG5cblxudmFyIGNzc0V4cGFuZCA9IFsgXCJUb3BcIiwgXCJSaWdodFwiLCBcIkJvdHRvbVwiLCBcIkxlZnRcIiBdO1xuXG52YXIgZG9jdW1lbnRFbGVtZW50ID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuXG5cblxuXHR2YXIgaXNBdHRhY2hlZCA9IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuIGpRdWVyeS5jb250YWlucyggZWxlbS5vd25lckRvY3VtZW50LCBlbGVtICk7XG5cdFx0fSxcblx0XHRjb21wb3NlZCA9IHsgY29tcG9zZWQ6IHRydWUgfTtcblxuXHQvLyBTdXBwb3J0OiBJRSA5IC0gMTErLCBFZGdlIDEyIC0gMTgrLCBpT1MgMTAuMCAtIDEwLjIgb25seVxuXHQvLyBDaGVjayBhdHRhY2htZW50IGFjcm9zcyBzaGFkb3cgRE9NIGJvdW5kYXJpZXMgd2hlbiBwb3NzaWJsZSAoZ2gtMzUwNClcblx0Ly8gU3VwcG9ydDogaU9TIDEwLjAtMTAuMiBvbmx5XG5cdC8vIEVhcmx5IGlPUyAxMCB2ZXJzaW9ucyBzdXBwb3J0IGBhdHRhY2hTaGFkb3dgIGJ1dCBub3QgYGdldFJvb3ROb2RlYCxcblx0Ly8gbGVhZGluZyB0byBlcnJvcnMuIFdlIG5lZWQgdG8gY2hlY2sgZm9yIGBnZXRSb290Tm9kZWAuXG5cdGlmICggZG9jdW1lbnRFbGVtZW50LmdldFJvb3ROb2RlICkge1xuXHRcdGlzQXR0YWNoZWQgPSBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiBqUXVlcnkuY29udGFpbnMoIGVsZW0ub3duZXJEb2N1bWVudCwgZWxlbSApIHx8XG5cdFx0XHRcdGVsZW0uZ2V0Um9vdE5vZGUoIGNvbXBvc2VkICkgPT09IGVsZW0ub3duZXJEb2N1bWVudDtcblx0XHR9O1xuXHR9XG52YXIgaXNIaWRkZW5XaXRoaW5UcmVlID0gZnVuY3Rpb24oIGVsZW0sIGVsICkge1xuXG5cdFx0Ly8gaXNIaWRkZW5XaXRoaW5UcmVlIG1pZ2h0IGJlIGNhbGxlZCBmcm9tIGpRdWVyeSNmaWx0ZXIgZnVuY3Rpb247XG5cdFx0Ly8gaW4gdGhhdCBjYXNlLCBlbGVtZW50IHdpbGwgYmUgc2Vjb25kIGFyZ3VtZW50XG5cdFx0ZWxlbSA9IGVsIHx8IGVsZW07XG5cblx0XHQvLyBJbmxpbmUgc3R5bGUgdHJ1bXBzIGFsbFxuXHRcdHJldHVybiBlbGVtLnN0eWxlLmRpc3BsYXkgPT09IFwibm9uZVwiIHx8XG5cdFx0XHRlbGVtLnN0eWxlLmRpc3BsYXkgPT09IFwiXCIgJiZcblxuXHRcdFx0Ly8gT3RoZXJ3aXNlLCBjaGVjayBjb21wdXRlZCBzdHlsZVxuXHRcdFx0Ly8gU3VwcG9ydDogRmlyZWZveCA8PTQzIC0gNDVcblx0XHRcdC8vIERpc2Nvbm5lY3RlZCBlbGVtZW50cyBjYW4gaGF2ZSBjb21wdXRlZCBkaXNwbGF5OiBub25lLCBzbyBmaXJzdCBjb25maXJtIHRoYXQgZWxlbSBpc1xuXHRcdFx0Ly8gaW4gdGhlIGRvY3VtZW50LlxuXHRcdFx0aXNBdHRhY2hlZCggZWxlbSApICYmXG5cblx0XHRcdGpRdWVyeS5jc3MoIGVsZW0sIFwiZGlzcGxheVwiICkgPT09IFwibm9uZVwiO1xuXHR9O1xuXG5cblxuZnVuY3Rpb24gYWRqdXN0Q1NTKCBlbGVtLCBwcm9wLCB2YWx1ZVBhcnRzLCB0d2VlbiApIHtcblx0dmFyIGFkanVzdGVkLCBzY2FsZSxcblx0XHRtYXhJdGVyYXRpb25zID0gMjAsXG5cdFx0Y3VycmVudFZhbHVlID0gdHdlZW4gP1xuXHRcdFx0ZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiB0d2Vlbi5jdXIoKTtcblx0XHRcdH0gOlxuXHRcdFx0ZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiBqUXVlcnkuY3NzKCBlbGVtLCBwcm9wLCBcIlwiICk7XG5cdFx0XHR9LFxuXHRcdGluaXRpYWwgPSBjdXJyZW50VmFsdWUoKSxcblx0XHR1bml0ID0gdmFsdWVQYXJ0cyAmJiB2YWx1ZVBhcnRzWyAzIF0gfHwgKCBqUXVlcnkuY3NzTnVtYmVyWyBwcm9wIF0gPyBcIlwiIDogXCJweFwiICksXG5cblx0XHQvLyBTdGFydGluZyB2YWx1ZSBjb21wdXRhdGlvbiBpcyByZXF1aXJlZCBmb3IgcG90ZW50aWFsIHVuaXQgbWlzbWF0Y2hlc1xuXHRcdGluaXRpYWxJblVuaXQgPSBlbGVtLm5vZGVUeXBlICYmXG5cdFx0XHQoIGpRdWVyeS5jc3NOdW1iZXJbIHByb3AgXSB8fCB1bml0ICE9PSBcInB4XCIgJiYgK2luaXRpYWwgKSAmJlxuXHRcdFx0cmNzc051bS5leGVjKCBqUXVlcnkuY3NzKCBlbGVtLCBwcm9wICkgKTtcblxuXHRpZiAoIGluaXRpYWxJblVuaXQgJiYgaW5pdGlhbEluVW5pdFsgMyBdICE9PSB1bml0ICkge1xuXG5cdFx0Ly8gU3VwcG9ydDogRmlyZWZveCA8PTU0XG5cdFx0Ly8gSGFsdmUgdGhlIGl0ZXJhdGlvbiB0YXJnZXQgdmFsdWUgdG8gcHJldmVudCBpbnRlcmZlcmVuY2UgZnJvbSBDU1MgdXBwZXIgYm91bmRzIChnaC0yMTQ0KVxuXHRcdGluaXRpYWwgPSBpbml0aWFsIC8gMjtcblxuXHRcdC8vIFRydXN0IHVuaXRzIHJlcG9ydGVkIGJ5IGpRdWVyeS5jc3Ncblx0XHR1bml0ID0gdW5pdCB8fCBpbml0aWFsSW5Vbml0WyAzIF07XG5cblx0XHQvLyBJdGVyYXRpdmVseSBhcHByb3hpbWF0ZSBmcm9tIGEgbm9uemVybyBzdGFydGluZyBwb2ludFxuXHRcdGluaXRpYWxJblVuaXQgPSAraW5pdGlhbCB8fCAxO1xuXG5cdFx0d2hpbGUgKCBtYXhJdGVyYXRpb25zLS0gKSB7XG5cblx0XHRcdC8vIEV2YWx1YXRlIGFuZCB1cGRhdGUgb3VyIGJlc3QgZ3Vlc3MgKGRvdWJsaW5nIGd1ZXNzZXMgdGhhdCB6ZXJvIG91dCkuXG5cdFx0XHQvLyBGaW5pc2ggaWYgdGhlIHNjYWxlIGVxdWFscyBvciBjcm9zc2VzIDEgKG1ha2luZyB0aGUgb2xkKm5ldyBwcm9kdWN0IG5vbi1wb3NpdGl2ZSkuXG5cdFx0XHRqUXVlcnkuc3R5bGUoIGVsZW0sIHByb3AsIGluaXRpYWxJblVuaXQgKyB1bml0ICk7XG5cdFx0XHRpZiAoICggMSAtIHNjYWxlICkgKiAoIDEgLSAoIHNjYWxlID0gY3VycmVudFZhbHVlKCkgLyBpbml0aWFsIHx8IDAuNSApICkgPD0gMCApIHtcblx0XHRcdFx0bWF4SXRlcmF0aW9ucyA9IDA7XG5cdFx0XHR9XG5cdFx0XHRpbml0aWFsSW5Vbml0ID0gaW5pdGlhbEluVW5pdCAvIHNjYWxlO1xuXG5cdFx0fVxuXG5cdFx0aW5pdGlhbEluVW5pdCA9IGluaXRpYWxJblVuaXQgKiAyO1xuXHRcdGpRdWVyeS5zdHlsZSggZWxlbSwgcHJvcCwgaW5pdGlhbEluVW5pdCArIHVuaXQgKTtcblxuXHRcdC8vIE1ha2Ugc3VyZSB3ZSB1cGRhdGUgdGhlIHR3ZWVuIHByb3BlcnRpZXMgbGF0ZXIgb25cblx0XHR2YWx1ZVBhcnRzID0gdmFsdWVQYXJ0cyB8fCBbXTtcblx0fVxuXG5cdGlmICggdmFsdWVQYXJ0cyApIHtcblx0XHRpbml0aWFsSW5Vbml0ID0gK2luaXRpYWxJblVuaXQgfHwgK2luaXRpYWwgfHwgMDtcblxuXHRcdC8vIEFwcGx5IHJlbGF0aXZlIG9mZnNldCAoKz0vLT0pIGlmIHNwZWNpZmllZFxuXHRcdGFkanVzdGVkID0gdmFsdWVQYXJ0c1sgMSBdID9cblx0XHRcdGluaXRpYWxJblVuaXQgKyAoIHZhbHVlUGFydHNbIDEgXSArIDEgKSAqIHZhbHVlUGFydHNbIDIgXSA6XG5cdFx0XHQrdmFsdWVQYXJ0c1sgMiBdO1xuXHRcdGlmICggdHdlZW4gKSB7XG5cdFx0XHR0d2Vlbi51bml0ID0gdW5pdDtcblx0XHRcdHR3ZWVuLnN0YXJ0ID0gaW5pdGlhbEluVW5pdDtcblx0XHRcdHR3ZWVuLmVuZCA9IGFkanVzdGVkO1xuXHRcdH1cblx0fVxuXHRyZXR1cm4gYWRqdXN0ZWQ7XG59XG5cblxudmFyIGRlZmF1bHREaXNwbGF5TWFwID0ge307XG5cbmZ1bmN0aW9uIGdldERlZmF1bHREaXNwbGF5KCBlbGVtICkge1xuXHR2YXIgdGVtcCxcblx0XHRkb2MgPSBlbGVtLm93bmVyRG9jdW1lbnQsXG5cdFx0bm9kZU5hbWUgPSBlbGVtLm5vZGVOYW1lLFxuXHRcdGRpc3BsYXkgPSBkZWZhdWx0RGlzcGxheU1hcFsgbm9kZU5hbWUgXTtcblxuXHRpZiAoIGRpc3BsYXkgKSB7XG5cdFx0cmV0dXJuIGRpc3BsYXk7XG5cdH1cblxuXHR0ZW1wID0gZG9jLmJvZHkuYXBwZW5kQ2hpbGQoIGRvYy5jcmVhdGVFbGVtZW50KCBub2RlTmFtZSApICk7XG5cdGRpc3BsYXkgPSBqUXVlcnkuY3NzKCB0ZW1wLCBcImRpc3BsYXlcIiApO1xuXG5cdHRlbXAucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCggdGVtcCApO1xuXG5cdGlmICggZGlzcGxheSA9PT0gXCJub25lXCIgKSB7XG5cdFx0ZGlzcGxheSA9IFwiYmxvY2tcIjtcblx0fVxuXHRkZWZhdWx0RGlzcGxheU1hcFsgbm9kZU5hbWUgXSA9IGRpc3BsYXk7XG5cblx0cmV0dXJuIGRpc3BsYXk7XG59XG5cbmZ1bmN0aW9uIHNob3dIaWRlKCBlbGVtZW50cywgc2hvdyApIHtcblx0dmFyIGRpc3BsYXksIGVsZW0sXG5cdFx0dmFsdWVzID0gW10sXG5cdFx0aW5kZXggPSAwLFxuXHRcdGxlbmd0aCA9IGVsZW1lbnRzLmxlbmd0aDtcblxuXHQvLyBEZXRlcm1pbmUgbmV3IGRpc3BsYXkgdmFsdWUgZm9yIGVsZW1lbnRzIHRoYXQgbmVlZCB0byBjaGFuZ2Vcblx0Zm9yICggOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKyApIHtcblx0XHRlbGVtID0gZWxlbWVudHNbIGluZGV4IF07XG5cdFx0aWYgKCAhZWxlbS5zdHlsZSApIHtcblx0XHRcdGNvbnRpbnVlO1xuXHRcdH1cblxuXHRcdGRpc3BsYXkgPSBlbGVtLnN0eWxlLmRpc3BsYXk7XG5cdFx0aWYgKCBzaG93ICkge1xuXG5cdFx0XHQvLyBTaW5jZSB3ZSBmb3JjZSB2aXNpYmlsaXR5IHVwb24gY2FzY2FkZS1oaWRkZW4gZWxlbWVudHMsIGFuIGltbWVkaWF0ZSAoYW5kIHNsb3cpXG5cdFx0XHQvLyBjaGVjayBpcyByZXF1aXJlZCBpbiB0aGlzIGZpcnN0IGxvb3AgdW5sZXNzIHdlIGhhdmUgYSBub25lbXB0eSBkaXNwbGF5IHZhbHVlIChlaXRoZXJcblx0XHRcdC8vIGlubGluZSBvciBhYm91dC10by1iZS1yZXN0b3JlZClcblx0XHRcdGlmICggZGlzcGxheSA9PT0gXCJub25lXCIgKSB7XG5cdFx0XHRcdHZhbHVlc1sgaW5kZXggXSA9IGRhdGFQcml2LmdldCggZWxlbSwgXCJkaXNwbGF5XCIgKSB8fCBudWxsO1xuXHRcdFx0XHRpZiAoICF2YWx1ZXNbIGluZGV4IF0gKSB7XG5cdFx0XHRcdFx0ZWxlbS5zdHlsZS5kaXNwbGF5ID0gXCJcIjtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0aWYgKCBlbGVtLnN0eWxlLmRpc3BsYXkgPT09IFwiXCIgJiYgaXNIaWRkZW5XaXRoaW5UcmVlKCBlbGVtICkgKSB7XG5cdFx0XHRcdHZhbHVlc1sgaW5kZXggXSA9IGdldERlZmF1bHREaXNwbGF5KCBlbGVtICk7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdGlmICggZGlzcGxheSAhPT0gXCJub25lXCIgKSB7XG5cdFx0XHRcdHZhbHVlc1sgaW5kZXggXSA9IFwibm9uZVwiO1xuXG5cdFx0XHRcdC8vIFJlbWVtYmVyIHdoYXQgd2UncmUgb3ZlcndyaXRpbmdcblx0XHRcdFx0ZGF0YVByaXYuc2V0KCBlbGVtLCBcImRpc3BsYXlcIiwgZGlzcGxheSApO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8vIFNldCB0aGUgZGlzcGxheSBvZiB0aGUgZWxlbWVudHMgaW4gYSBzZWNvbmQgbG9vcCB0byBhdm9pZCBjb25zdGFudCByZWZsb3dcblx0Zm9yICggaW5kZXggPSAwOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKyApIHtcblx0XHRpZiAoIHZhbHVlc1sgaW5kZXggXSAhPSBudWxsICkge1xuXHRcdFx0ZWxlbWVudHNbIGluZGV4IF0uc3R5bGUuZGlzcGxheSA9IHZhbHVlc1sgaW5kZXggXTtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gZWxlbWVudHM7XG59XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0c2hvdzogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHNob3dIaWRlKCB0aGlzLCB0cnVlICk7XG5cdH0sXG5cdGhpZGU6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBzaG93SGlkZSggdGhpcyApO1xuXHR9LFxuXHR0b2dnbGU6IGZ1bmN0aW9uKCBzdGF0ZSApIHtcblx0XHRpZiAoIHR5cGVvZiBzdGF0ZSA9PT0gXCJib29sZWFuXCIgKSB7XG5cdFx0XHRyZXR1cm4gc3RhdGUgPyB0aGlzLnNob3coKSA6IHRoaXMuaGlkZSgpO1xuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0aWYgKCBpc0hpZGRlbldpdGhpblRyZWUoIHRoaXMgKSApIHtcblx0XHRcdFx0alF1ZXJ5KCB0aGlzICkuc2hvdygpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0alF1ZXJ5KCB0aGlzICkuaGlkZSgpO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0fVxufSApO1xudmFyIHJjaGVja2FibGVUeXBlID0gKCAvXig/OmNoZWNrYm94fHJhZGlvKSQvaSApO1xuXG52YXIgcnRhZ05hbWUgPSAoIC88KFthLXpdW15cXC9cXDA+XFx4MjBcXHRcXHJcXG5cXGZdKikvaSApO1xuXG52YXIgcnNjcmlwdFR5cGUgPSAoIC9eJHxebW9kdWxlJHxcXC8oPzpqYXZhfGVjbWEpc2NyaXB0L2kgKTtcblxuXG5cbiggZnVuY3Rpb24oKSB7XG5cdHZhciBmcmFnbWVudCA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKSxcblx0XHRkaXYgPSBmcmFnbWVudC5hcHBlbmRDaGlsZCggZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJkaXZcIiApICksXG5cdFx0aW5wdXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImlucHV0XCIgKTtcblxuXHQvLyBTdXBwb3J0OiBBbmRyb2lkIDQuMCAtIDQuMyBvbmx5XG5cdC8vIENoZWNrIHN0YXRlIGxvc3QgaWYgdGhlIG5hbWUgaXMgc2V0ICgjMTEyMTcpXG5cdC8vIFN1cHBvcnQ6IFdpbmRvd3MgV2ViIEFwcHMgKFdXQSlcblx0Ly8gYG5hbWVgIGFuZCBgdHlwZWAgbXVzdCB1c2UgLnNldEF0dHJpYnV0ZSBmb3IgV1dBICgjMTQ5MDEpXG5cdGlucHV0LnNldEF0dHJpYnV0ZSggXCJ0eXBlXCIsIFwicmFkaW9cIiApO1xuXHRpbnB1dC5zZXRBdHRyaWJ1dGUoIFwiY2hlY2tlZFwiLCBcImNoZWNrZWRcIiApO1xuXHRpbnB1dC5zZXRBdHRyaWJ1dGUoIFwibmFtZVwiLCBcInRcIiApO1xuXG5cdGRpdi5hcHBlbmRDaGlsZCggaW5wdXQgKTtcblxuXHQvLyBTdXBwb3J0OiBBbmRyb2lkIDw9NC4xIG9ubHlcblx0Ly8gT2xkZXIgV2ViS2l0IGRvZXNuJ3QgY2xvbmUgY2hlY2tlZCBzdGF0ZSBjb3JyZWN0bHkgaW4gZnJhZ21lbnRzXG5cdHN1cHBvcnQuY2hlY2tDbG9uZSA9IGRpdi5jbG9uZU5vZGUoIHRydWUgKS5jbG9uZU5vZGUoIHRydWUgKS5sYXN0Q2hpbGQuY2hlY2tlZDtcblxuXHQvLyBTdXBwb3J0OiBJRSA8PTExIG9ubHlcblx0Ly8gTWFrZSBzdXJlIHRleHRhcmVhIChhbmQgY2hlY2tib3gpIGRlZmF1bHRWYWx1ZSBpcyBwcm9wZXJseSBjbG9uZWRcblx0ZGl2LmlubmVySFRNTCA9IFwiPHRleHRhcmVhPng8L3RleHRhcmVhPlwiO1xuXHRzdXBwb3J0Lm5vQ2xvbmVDaGVja2VkID0gISFkaXYuY2xvbmVOb2RlKCB0cnVlICkubGFzdENoaWxkLmRlZmF1bHRWYWx1ZTtcblxuXHQvLyBTdXBwb3J0OiBJRSA8PTkgb25seVxuXHQvLyBJRSA8PTkgcmVwbGFjZXMgPG9wdGlvbj4gdGFncyB3aXRoIHRoZWlyIGNvbnRlbnRzIHdoZW4gaW5zZXJ0ZWQgb3V0c2lkZSBvZlxuXHQvLyB0aGUgc2VsZWN0IGVsZW1lbnQuXG5cdGRpdi5pbm5lckhUTUwgPSBcIjxvcHRpb24+PC9vcHRpb24+XCI7XG5cdHN1cHBvcnQub3B0aW9uID0gISFkaXYubGFzdENoaWxkO1xufSApKCk7XG5cblxuLy8gV2UgaGF2ZSB0byBjbG9zZSB0aGVzZSB0YWdzIHRvIHN1cHBvcnQgWEhUTUwgKCMxMzIwMClcbnZhciB3cmFwTWFwID0ge1xuXG5cdC8vIFhIVE1MIHBhcnNlcnMgZG8gbm90IG1hZ2ljYWxseSBpbnNlcnQgZWxlbWVudHMgaW4gdGhlXG5cdC8vIHNhbWUgd2F5IHRoYXQgdGFnIHNvdXAgcGFyc2VycyBkby4gU28gd2UgY2Fubm90IHNob3J0ZW5cblx0Ly8gdGhpcyBieSBvbWl0dGluZyA8dGJvZHk+IG9yIG90aGVyIHJlcXVpcmVkIGVsZW1lbnRzLlxuXHR0aGVhZDogWyAxLCBcIjx0YWJsZT5cIiwgXCI8L3RhYmxlPlwiIF0sXG5cdGNvbDogWyAyLCBcIjx0YWJsZT48Y29sZ3JvdXA+XCIsIFwiPC9jb2xncm91cD48L3RhYmxlPlwiIF0sXG5cdHRyOiBbIDIsIFwiPHRhYmxlPjx0Ym9keT5cIiwgXCI8L3Rib2R5PjwvdGFibGU+XCIgXSxcblx0dGQ6IFsgMywgXCI8dGFibGU+PHRib2R5Pjx0cj5cIiwgXCI8L3RyPjwvdGJvZHk+PC90YWJsZT5cIiBdLFxuXG5cdF9kZWZhdWx0OiBbIDAsIFwiXCIsIFwiXCIgXVxufTtcblxud3JhcE1hcC50Ym9keSA9IHdyYXBNYXAudGZvb3QgPSB3cmFwTWFwLmNvbGdyb3VwID0gd3JhcE1hcC5jYXB0aW9uID0gd3JhcE1hcC50aGVhZDtcbndyYXBNYXAudGggPSB3cmFwTWFwLnRkO1xuXG4vLyBTdXBwb3J0OiBJRSA8PTkgb25seVxuaWYgKCAhc3VwcG9ydC5vcHRpb24gKSB7XG5cdHdyYXBNYXAub3B0Z3JvdXAgPSB3cmFwTWFwLm9wdGlvbiA9IFsgMSwgXCI8c2VsZWN0IG11bHRpcGxlPSdtdWx0aXBsZSc+XCIsIFwiPC9zZWxlY3Q+XCIgXTtcbn1cblxuXG5mdW5jdGlvbiBnZXRBbGwoIGNvbnRleHQsIHRhZyApIHtcblxuXHQvLyBTdXBwb3J0OiBJRSA8PTkgLSAxMSBvbmx5XG5cdC8vIFVzZSB0eXBlb2YgdG8gYXZvaWQgemVyby1hcmd1bWVudCBtZXRob2QgaW52b2NhdGlvbiBvbiBob3N0IG9iamVjdHMgKCMxNTE1MSlcblx0dmFyIHJldDtcblxuXHRpZiAoIHR5cGVvZiBjb250ZXh0LmdldEVsZW1lbnRzQnlUYWdOYW1lICE9PSBcInVuZGVmaW5lZFwiICkge1xuXHRcdHJldCA9IGNvbnRleHQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoIHRhZyB8fCBcIipcIiApO1xuXG5cdH0gZWxzZSBpZiAoIHR5cGVvZiBjb250ZXh0LnF1ZXJ5U2VsZWN0b3JBbGwgIT09IFwidW5kZWZpbmVkXCIgKSB7XG5cdFx0cmV0ID0gY29udGV4dC5xdWVyeVNlbGVjdG9yQWxsKCB0YWcgfHwgXCIqXCIgKTtcblxuXHR9IGVsc2Uge1xuXHRcdHJldCA9IFtdO1xuXHR9XG5cblx0aWYgKCB0YWcgPT09IHVuZGVmaW5lZCB8fCB0YWcgJiYgbm9kZU5hbWUoIGNvbnRleHQsIHRhZyApICkge1xuXHRcdHJldHVybiBqUXVlcnkubWVyZ2UoIFsgY29udGV4dCBdLCByZXQgKTtcblx0fVxuXG5cdHJldHVybiByZXQ7XG59XG5cblxuLy8gTWFyayBzY3JpcHRzIGFzIGhhdmluZyBhbHJlYWR5IGJlZW4gZXZhbHVhdGVkXG5mdW5jdGlvbiBzZXRHbG9iYWxFdmFsKCBlbGVtcywgcmVmRWxlbWVudHMgKSB7XG5cdHZhciBpID0gMCxcblx0XHRsID0gZWxlbXMubGVuZ3RoO1xuXG5cdGZvciAoIDsgaSA8IGw7IGkrKyApIHtcblx0XHRkYXRhUHJpdi5zZXQoXG5cdFx0XHRlbGVtc1sgaSBdLFxuXHRcdFx0XCJnbG9iYWxFdmFsXCIsXG5cdFx0XHQhcmVmRWxlbWVudHMgfHwgZGF0YVByaXYuZ2V0KCByZWZFbGVtZW50c1sgaSBdLCBcImdsb2JhbEV2YWxcIiApXG5cdFx0KTtcblx0fVxufVxuXG5cbnZhciByaHRtbCA9IC88fCYjP1xcdys7LztcblxuZnVuY3Rpb24gYnVpbGRGcmFnbWVudCggZWxlbXMsIGNvbnRleHQsIHNjcmlwdHMsIHNlbGVjdGlvbiwgaWdub3JlZCApIHtcblx0dmFyIGVsZW0sIHRtcCwgdGFnLCB3cmFwLCBhdHRhY2hlZCwgaixcblx0XHRmcmFnbWVudCA9IGNvbnRleHQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpLFxuXHRcdG5vZGVzID0gW10sXG5cdFx0aSA9IDAsXG5cdFx0bCA9IGVsZW1zLmxlbmd0aDtcblxuXHRmb3IgKCA7IGkgPCBsOyBpKysgKSB7XG5cdFx0ZWxlbSA9IGVsZW1zWyBpIF07XG5cblx0XHRpZiAoIGVsZW0gfHwgZWxlbSA9PT0gMCApIHtcblxuXHRcdFx0Ly8gQWRkIG5vZGVzIGRpcmVjdGx5XG5cdFx0XHRpZiAoIHRvVHlwZSggZWxlbSApID09PSBcIm9iamVjdFwiICkge1xuXG5cdFx0XHRcdC8vIFN1cHBvcnQ6IEFuZHJvaWQgPD00LjAgb25seSwgUGhhbnRvbUpTIDEgb25seVxuXHRcdFx0XHQvLyBwdXNoLmFwcGx5KF8sIGFycmF5bGlrZSkgdGhyb3dzIG9uIGFuY2llbnQgV2ViS2l0XG5cdFx0XHRcdGpRdWVyeS5tZXJnZSggbm9kZXMsIGVsZW0ubm9kZVR5cGUgPyBbIGVsZW0gXSA6IGVsZW0gKTtcblxuXHRcdFx0Ly8gQ29udmVydCBub24taHRtbCBpbnRvIGEgdGV4dCBub2RlXG5cdFx0XHR9IGVsc2UgaWYgKCAhcmh0bWwudGVzdCggZWxlbSApICkge1xuXHRcdFx0XHRub2Rlcy5wdXNoKCBjb250ZXh0LmNyZWF0ZVRleHROb2RlKCBlbGVtICkgKTtcblxuXHRcdFx0Ly8gQ29udmVydCBodG1sIGludG8gRE9NIG5vZGVzXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0bXAgPSB0bXAgfHwgZnJhZ21lbnQuYXBwZW5kQ2hpbGQoIGNvbnRleHQuY3JlYXRlRWxlbWVudCggXCJkaXZcIiApICk7XG5cblx0XHRcdFx0Ly8gRGVzZXJpYWxpemUgYSBzdGFuZGFyZCByZXByZXNlbnRhdGlvblxuXHRcdFx0XHR0YWcgPSAoIHJ0YWdOYW1lLmV4ZWMoIGVsZW0gKSB8fCBbIFwiXCIsIFwiXCIgXSApWyAxIF0udG9Mb3dlckNhc2UoKTtcblx0XHRcdFx0d3JhcCA9IHdyYXBNYXBbIHRhZyBdIHx8IHdyYXBNYXAuX2RlZmF1bHQ7XG5cdFx0XHRcdHRtcC5pbm5lckhUTUwgPSB3cmFwWyAxIF0gKyBqUXVlcnkuaHRtbFByZWZpbHRlciggZWxlbSApICsgd3JhcFsgMiBdO1xuXG5cdFx0XHRcdC8vIERlc2NlbmQgdGhyb3VnaCB3cmFwcGVycyB0byB0aGUgcmlnaHQgY29udGVudFxuXHRcdFx0XHRqID0gd3JhcFsgMCBdO1xuXHRcdFx0XHR3aGlsZSAoIGotLSApIHtcblx0XHRcdFx0XHR0bXAgPSB0bXAubGFzdENoaWxkO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gU3VwcG9ydDogQW5kcm9pZCA8PTQuMCBvbmx5LCBQaGFudG9tSlMgMSBvbmx5XG5cdFx0XHRcdC8vIHB1c2guYXBwbHkoXywgYXJyYXlsaWtlKSB0aHJvd3Mgb24gYW5jaWVudCBXZWJLaXRcblx0XHRcdFx0alF1ZXJ5Lm1lcmdlKCBub2RlcywgdG1wLmNoaWxkTm9kZXMgKTtcblxuXHRcdFx0XHQvLyBSZW1lbWJlciB0aGUgdG9wLWxldmVsIGNvbnRhaW5lclxuXHRcdFx0XHR0bXAgPSBmcmFnbWVudC5maXJzdENoaWxkO1xuXG5cdFx0XHRcdC8vIEVuc3VyZSB0aGUgY3JlYXRlZCBub2RlcyBhcmUgb3JwaGFuZWQgKCMxMjM5Milcblx0XHRcdFx0dG1wLnRleHRDb250ZW50ID0gXCJcIjtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvLyBSZW1vdmUgd3JhcHBlciBmcm9tIGZyYWdtZW50XG5cdGZyYWdtZW50LnRleHRDb250ZW50ID0gXCJcIjtcblxuXHRpID0gMDtcblx0d2hpbGUgKCAoIGVsZW0gPSBub2Rlc1sgaSsrIF0gKSApIHtcblxuXHRcdC8vIFNraXAgZWxlbWVudHMgYWxyZWFkeSBpbiB0aGUgY29udGV4dCBjb2xsZWN0aW9uICh0cmFjLTQwODcpXG5cdFx0aWYgKCBzZWxlY3Rpb24gJiYgalF1ZXJ5LmluQXJyYXkoIGVsZW0sIHNlbGVjdGlvbiApID4gLTEgKSB7XG5cdFx0XHRpZiAoIGlnbm9yZWQgKSB7XG5cdFx0XHRcdGlnbm9yZWQucHVzaCggZWxlbSApO1xuXHRcdFx0fVxuXHRcdFx0Y29udGludWU7XG5cdFx0fVxuXG5cdFx0YXR0YWNoZWQgPSBpc0F0dGFjaGVkKCBlbGVtICk7XG5cblx0XHQvLyBBcHBlbmQgdG8gZnJhZ21lbnRcblx0XHR0bXAgPSBnZXRBbGwoIGZyYWdtZW50LmFwcGVuZENoaWxkKCBlbGVtICksIFwic2NyaXB0XCIgKTtcblxuXHRcdC8vIFByZXNlcnZlIHNjcmlwdCBldmFsdWF0aW9uIGhpc3Rvcnlcblx0XHRpZiAoIGF0dGFjaGVkICkge1xuXHRcdFx0c2V0R2xvYmFsRXZhbCggdG1wICk7XG5cdFx0fVxuXG5cdFx0Ly8gQ2FwdHVyZSBleGVjdXRhYmxlc1xuXHRcdGlmICggc2NyaXB0cyApIHtcblx0XHRcdGogPSAwO1xuXHRcdFx0d2hpbGUgKCAoIGVsZW0gPSB0bXBbIGorKyBdICkgKSB7XG5cdFx0XHRcdGlmICggcnNjcmlwdFR5cGUudGVzdCggZWxlbS50eXBlIHx8IFwiXCIgKSApIHtcblx0XHRcdFx0XHRzY3JpcHRzLnB1c2goIGVsZW0gKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHJldHVybiBmcmFnbWVudDtcbn1cblxuXG52YXIgcnR5cGVuYW1lc3BhY2UgPSAvXihbXi5dKikoPzpcXC4oLispfCkvO1xuXG5mdW5jdGlvbiByZXR1cm5UcnVlKCkge1xuXHRyZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gcmV0dXJuRmFsc2UoKSB7XG5cdHJldHVybiBmYWxzZTtcbn1cblxuLy8gU3VwcG9ydDogSUUgPD05IC0gMTErXG4vLyBmb2N1cygpIGFuZCBibHVyKCkgYXJlIGFzeW5jaHJvbm91cywgZXhjZXB0IHdoZW4gdGhleSBhcmUgbm8tb3AuXG4vLyBTbyBleHBlY3QgZm9jdXMgdG8gYmUgc3luY2hyb25vdXMgd2hlbiB0aGUgZWxlbWVudCBpcyBhbHJlYWR5IGFjdGl2ZSxcbi8vIGFuZCBibHVyIHRvIGJlIHN5bmNocm9ub3VzIHdoZW4gdGhlIGVsZW1lbnQgaXMgbm90IGFscmVhZHkgYWN0aXZlLlxuLy8gKGZvY3VzIGFuZCBibHVyIGFyZSBhbHdheXMgc3luY2hyb25vdXMgaW4gb3RoZXIgc3VwcG9ydGVkIGJyb3dzZXJzLFxuLy8gdGhpcyBqdXN0IGRlZmluZXMgd2hlbiB3ZSBjYW4gY291bnQgb24gaXQpLlxuZnVuY3Rpb24gZXhwZWN0U3luYyggZWxlbSwgdHlwZSApIHtcblx0cmV0dXJuICggZWxlbSA9PT0gc2FmZUFjdGl2ZUVsZW1lbnQoKSApID09PSAoIHR5cGUgPT09IFwiZm9jdXNcIiApO1xufVxuXG4vLyBTdXBwb3J0OiBJRSA8PTkgb25seVxuLy8gQWNjZXNzaW5nIGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgY2FuIHRocm93IHVuZXhwZWN0ZWRseVxuLy8gaHR0cHM6Ly9idWdzLmpxdWVyeS5jb20vdGlja2V0LzEzMzkzXG5mdW5jdGlvbiBzYWZlQWN0aXZlRWxlbWVudCgpIHtcblx0dHJ5IHtcblx0XHRyZXR1cm4gZG9jdW1lbnQuYWN0aXZlRWxlbWVudDtcblx0fSBjYXRjaCAoIGVyciApIHsgfVxufVxuXG5mdW5jdGlvbiBvbiggZWxlbSwgdHlwZXMsIHNlbGVjdG9yLCBkYXRhLCBmbiwgb25lICkge1xuXHR2YXIgb3JpZ0ZuLCB0eXBlO1xuXG5cdC8vIFR5cGVzIGNhbiBiZSBhIG1hcCBvZiB0eXBlcy9oYW5kbGVyc1xuXHRpZiAoIHR5cGVvZiB0eXBlcyA9PT0gXCJvYmplY3RcIiApIHtcblxuXHRcdC8vICggdHlwZXMtT2JqZWN0LCBzZWxlY3RvciwgZGF0YSApXG5cdFx0aWYgKCB0eXBlb2Ygc2VsZWN0b3IgIT09IFwic3RyaW5nXCIgKSB7XG5cblx0XHRcdC8vICggdHlwZXMtT2JqZWN0LCBkYXRhIClcblx0XHRcdGRhdGEgPSBkYXRhIHx8IHNlbGVjdG9yO1xuXHRcdFx0c2VsZWN0b3IgPSB1bmRlZmluZWQ7XG5cdFx0fVxuXHRcdGZvciAoIHR5cGUgaW4gdHlwZXMgKSB7XG5cdFx0XHRvbiggZWxlbSwgdHlwZSwgc2VsZWN0b3IsIGRhdGEsIHR5cGVzWyB0eXBlIF0sIG9uZSApO1xuXHRcdH1cblx0XHRyZXR1cm4gZWxlbTtcblx0fVxuXG5cdGlmICggZGF0YSA9PSBudWxsICYmIGZuID09IG51bGwgKSB7XG5cblx0XHQvLyAoIHR5cGVzLCBmbiApXG5cdFx0Zm4gPSBzZWxlY3Rvcjtcblx0XHRkYXRhID0gc2VsZWN0b3IgPSB1bmRlZmluZWQ7XG5cdH0gZWxzZSBpZiAoIGZuID09IG51bGwgKSB7XG5cdFx0aWYgKCB0eXBlb2Ygc2VsZWN0b3IgPT09IFwic3RyaW5nXCIgKSB7XG5cblx0XHRcdC8vICggdHlwZXMsIHNlbGVjdG9yLCBmbiApXG5cdFx0XHRmbiA9IGRhdGE7XG5cdFx0XHRkYXRhID0gdW5kZWZpbmVkO1xuXHRcdH0gZWxzZSB7XG5cblx0XHRcdC8vICggdHlwZXMsIGRhdGEsIGZuIClcblx0XHRcdGZuID0gZGF0YTtcblx0XHRcdGRhdGEgPSBzZWxlY3Rvcjtcblx0XHRcdHNlbGVjdG9yID0gdW5kZWZpbmVkO1xuXHRcdH1cblx0fVxuXHRpZiAoIGZuID09PSBmYWxzZSApIHtcblx0XHRmbiA9IHJldHVybkZhbHNlO1xuXHR9IGVsc2UgaWYgKCAhZm4gKSB7XG5cdFx0cmV0dXJuIGVsZW07XG5cdH1cblxuXHRpZiAoIG9uZSA9PT0gMSApIHtcblx0XHRvcmlnRm4gPSBmbjtcblx0XHRmbiA9IGZ1bmN0aW9uKCBldmVudCApIHtcblxuXHRcdFx0Ly8gQ2FuIHVzZSBhbiBlbXB0eSBzZXQsIHNpbmNlIGV2ZW50IGNvbnRhaW5zIHRoZSBpbmZvXG5cdFx0XHRqUXVlcnkoKS5vZmYoIGV2ZW50ICk7XG5cdFx0XHRyZXR1cm4gb3JpZ0ZuLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKTtcblx0XHR9O1xuXG5cdFx0Ly8gVXNlIHNhbWUgZ3VpZCBzbyBjYWxsZXIgY2FuIHJlbW92ZSB1c2luZyBvcmlnRm5cblx0XHRmbi5ndWlkID0gb3JpZ0ZuLmd1aWQgfHwgKCBvcmlnRm4uZ3VpZCA9IGpRdWVyeS5ndWlkKysgKTtcblx0fVxuXHRyZXR1cm4gZWxlbS5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRqUXVlcnkuZXZlbnQuYWRkKCB0aGlzLCB0eXBlcywgZm4sIGRhdGEsIHNlbGVjdG9yICk7XG5cdH0gKTtcbn1cblxuLypcbiAqIEhlbHBlciBmdW5jdGlvbnMgZm9yIG1hbmFnaW5nIGV2ZW50cyAtLSBub3QgcGFydCBvZiB0aGUgcHVibGljIGludGVyZmFjZS5cbiAqIFByb3BzIHRvIERlYW4gRWR3YXJkcycgYWRkRXZlbnQgbGlicmFyeSBmb3IgbWFueSBvZiB0aGUgaWRlYXMuXG4gKi9cbmpRdWVyeS5ldmVudCA9IHtcblxuXHRnbG9iYWw6IHt9LFxuXG5cdGFkZDogZnVuY3Rpb24oIGVsZW0sIHR5cGVzLCBoYW5kbGVyLCBkYXRhLCBzZWxlY3RvciApIHtcblxuXHRcdHZhciBoYW5kbGVPYmpJbiwgZXZlbnRIYW5kbGUsIHRtcCxcblx0XHRcdGV2ZW50cywgdCwgaGFuZGxlT2JqLFxuXHRcdFx0c3BlY2lhbCwgaGFuZGxlcnMsIHR5cGUsIG5hbWVzcGFjZXMsIG9yaWdUeXBlLFxuXHRcdFx0ZWxlbURhdGEgPSBkYXRhUHJpdi5nZXQoIGVsZW0gKTtcblxuXHRcdC8vIE9ubHkgYXR0YWNoIGV2ZW50cyB0byBvYmplY3RzIHRoYXQgYWNjZXB0IGRhdGFcblx0XHRpZiAoICFhY2NlcHREYXRhKCBlbGVtICkgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gQ2FsbGVyIGNhbiBwYXNzIGluIGFuIG9iamVjdCBvZiBjdXN0b20gZGF0YSBpbiBsaWV1IG9mIHRoZSBoYW5kbGVyXG5cdFx0aWYgKCBoYW5kbGVyLmhhbmRsZXIgKSB7XG5cdFx0XHRoYW5kbGVPYmpJbiA9IGhhbmRsZXI7XG5cdFx0XHRoYW5kbGVyID0gaGFuZGxlT2JqSW4uaGFuZGxlcjtcblx0XHRcdHNlbGVjdG9yID0gaGFuZGxlT2JqSW4uc2VsZWN0b3I7XG5cdFx0fVxuXG5cdFx0Ly8gRW5zdXJlIHRoYXQgaW52YWxpZCBzZWxlY3RvcnMgdGhyb3cgZXhjZXB0aW9ucyBhdCBhdHRhY2ggdGltZVxuXHRcdC8vIEV2YWx1YXRlIGFnYWluc3QgZG9jdW1lbnRFbGVtZW50IGluIGNhc2UgZWxlbSBpcyBhIG5vbi1lbGVtZW50IG5vZGUgKGUuZy4sIGRvY3VtZW50KVxuXHRcdGlmICggc2VsZWN0b3IgKSB7XG5cdFx0XHRqUXVlcnkuZmluZC5tYXRjaGVzU2VsZWN0b3IoIGRvY3VtZW50RWxlbWVudCwgc2VsZWN0b3IgKTtcblx0XHR9XG5cblx0XHQvLyBNYWtlIHN1cmUgdGhhdCB0aGUgaGFuZGxlciBoYXMgYSB1bmlxdWUgSUQsIHVzZWQgdG8gZmluZC9yZW1vdmUgaXQgbGF0ZXJcblx0XHRpZiAoICFoYW5kbGVyLmd1aWQgKSB7XG5cdFx0XHRoYW5kbGVyLmd1aWQgPSBqUXVlcnkuZ3VpZCsrO1xuXHRcdH1cblxuXHRcdC8vIEluaXQgdGhlIGVsZW1lbnQncyBldmVudCBzdHJ1Y3R1cmUgYW5kIG1haW4gaGFuZGxlciwgaWYgdGhpcyBpcyB0aGUgZmlyc3Rcblx0XHRpZiAoICEoIGV2ZW50cyA9IGVsZW1EYXRhLmV2ZW50cyApICkge1xuXHRcdFx0ZXZlbnRzID0gZWxlbURhdGEuZXZlbnRzID0gT2JqZWN0LmNyZWF0ZSggbnVsbCApO1xuXHRcdH1cblx0XHRpZiAoICEoIGV2ZW50SGFuZGxlID0gZWxlbURhdGEuaGFuZGxlICkgKSB7XG5cdFx0XHRldmVudEhhbmRsZSA9IGVsZW1EYXRhLmhhbmRsZSA9IGZ1bmN0aW9uKCBlICkge1xuXG5cdFx0XHRcdC8vIERpc2NhcmQgdGhlIHNlY29uZCBldmVudCBvZiBhIGpRdWVyeS5ldmVudC50cmlnZ2VyKCkgYW5kXG5cdFx0XHRcdC8vIHdoZW4gYW4gZXZlbnQgaXMgY2FsbGVkIGFmdGVyIGEgcGFnZSBoYXMgdW5sb2FkZWRcblx0XHRcdFx0cmV0dXJuIHR5cGVvZiBqUXVlcnkgIT09IFwidW5kZWZpbmVkXCIgJiYgalF1ZXJ5LmV2ZW50LnRyaWdnZXJlZCAhPT0gZS50eXBlID9cblx0XHRcdFx0XHRqUXVlcnkuZXZlbnQuZGlzcGF0Y2guYXBwbHkoIGVsZW0sIGFyZ3VtZW50cyApIDogdW5kZWZpbmVkO1xuXHRcdFx0fTtcblx0XHR9XG5cblx0XHQvLyBIYW5kbGUgbXVsdGlwbGUgZXZlbnRzIHNlcGFyYXRlZCBieSBhIHNwYWNlXG5cdFx0dHlwZXMgPSAoIHR5cGVzIHx8IFwiXCIgKS5tYXRjaCggcm5vdGh0bWx3aGl0ZSApIHx8IFsgXCJcIiBdO1xuXHRcdHQgPSB0eXBlcy5sZW5ndGg7XG5cdFx0d2hpbGUgKCB0LS0gKSB7XG5cdFx0XHR0bXAgPSBydHlwZW5hbWVzcGFjZS5leGVjKCB0eXBlc1sgdCBdICkgfHwgW107XG5cdFx0XHR0eXBlID0gb3JpZ1R5cGUgPSB0bXBbIDEgXTtcblx0XHRcdG5hbWVzcGFjZXMgPSAoIHRtcFsgMiBdIHx8IFwiXCIgKS5zcGxpdCggXCIuXCIgKS5zb3J0KCk7XG5cblx0XHRcdC8vIFRoZXJlICptdXN0KiBiZSBhIHR5cGUsIG5vIGF0dGFjaGluZyBuYW1lc3BhY2Utb25seSBoYW5kbGVyc1xuXHRcdFx0aWYgKCAhdHlwZSApIHtcblx0XHRcdFx0Y29udGludWU7XG5cdFx0XHR9XG5cblx0XHRcdC8vIElmIGV2ZW50IGNoYW5nZXMgaXRzIHR5cGUsIHVzZSB0aGUgc3BlY2lhbCBldmVudCBoYW5kbGVycyBmb3IgdGhlIGNoYW5nZWQgdHlwZVxuXHRcdFx0c3BlY2lhbCA9IGpRdWVyeS5ldmVudC5zcGVjaWFsWyB0eXBlIF0gfHwge307XG5cblx0XHRcdC8vIElmIHNlbGVjdG9yIGRlZmluZWQsIGRldGVybWluZSBzcGVjaWFsIGV2ZW50IGFwaSB0eXBlLCBvdGhlcndpc2UgZ2l2ZW4gdHlwZVxuXHRcdFx0dHlwZSA9ICggc2VsZWN0b3IgPyBzcGVjaWFsLmRlbGVnYXRlVHlwZSA6IHNwZWNpYWwuYmluZFR5cGUgKSB8fCB0eXBlO1xuXG5cdFx0XHQvLyBVcGRhdGUgc3BlY2lhbCBiYXNlZCBvbiBuZXdseSByZXNldCB0eXBlXG5cdFx0XHRzcGVjaWFsID0galF1ZXJ5LmV2ZW50LnNwZWNpYWxbIHR5cGUgXSB8fCB7fTtcblxuXHRcdFx0Ly8gaGFuZGxlT2JqIGlzIHBhc3NlZCB0byBhbGwgZXZlbnQgaGFuZGxlcnNcblx0XHRcdGhhbmRsZU9iaiA9IGpRdWVyeS5leHRlbmQoIHtcblx0XHRcdFx0dHlwZTogdHlwZSxcblx0XHRcdFx0b3JpZ1R5cGU6IG9yaWdUeXBlLFxuXHRcdFx0XHRkYXRhOiBkYXRhLFxuXHRcdFx0XHRoYW5kbGVyOiBoYW5kbGVyLFxuXHRcdFx0XHRndWlkOiBoYW5kbGVyLmd1aWQsXG5cdFx0XHRcdHNlbGVjdG9yOiBzZWxlY3Rvcixcblx0XHRcdFx0bmVlZHNDb250ZXh0OiBzZWxlY3RvciAmJiBqUXVlcnkuZXhwci5tYXRjaC5uZWVkc0NvbnRleHQudGVzdCggc2VsZWN0b3IgKSxcblx0XHRcdFx0bmFtZXNwYWNlOiBuYW1lc3BhY2VzLmpvaW4oIFwiLlwiIClcblx0XHRcdH0sIGhhbmRsZU9iakluICk7XG5cblx0XHRcdC8vIEluaXQgdGhlIGV2ZW50IGhhbmRsZXIgcXVldWUgaWYgd2UncmUgdGhlIGZpcnN0XG5cdFx0XHRpZiAoICEoIGhhbmRsZXJzID0gZXZlbnRzWyB0eXBlIF0gKSApIHtcblx0XHRcdFx0aGFuZGxlcnMgPSBldmVudHNbIHR5cGUgXSA9IFtdO1xuXHRcdFx0XHRoYW5kbGVycy5kZWxlZ2F0ZUNvdW50ID0gMDtcblxuXHRcdFx0XHQvLyBPbmx5IHVzZSBhZGRFdmVudExpc3RlbmVyIGlmIHRoZSBzcGVjaWFsIGV2ZW50cyBoYW5kbGVyIHJldHVybnMgZmFsc2Vcblx0XHRcdFx0aWYgKCAhc3BlY2lhbC5zZXR1cCB8fFxuXHRcdFx0XHRcdHNwZWNpYWwuc2V0dXAuY2FsbCggZWxlbSwgZGF0YSwgbmFtZXNwYWNlcywgZXZlbnRIYW5kbGUgKSA9PT0gZmFsc2UgKSB7XG5cblx0XHRcdFx0XHRpZiAoIGVsZW0uYWRkRXZlbnRMaXN0ZW5lciApIHtcblx0XHRcdFx0XHRcdGVsZW0uYWRkRXZlbnRMaXN0ZW5lciggdHlwZSwgZXZlbnRIYW5kbGUgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0aWYgKCBzcGVjaWFsLmFkZCApIHtcblx0XHRcdFx0c3BlY2lhbC5hZGQuY2FsbCggZWxlbSwgaGFuZGxlT2JqICk7XG5cblx0XHRcdFx0aWYgKCAhaGFuZGxlT2JqLmhhbmRsZXIuZ3VpZCApIHtcblx0XHRcdFx0XHRoYW5kbGVPYmouaGFuZGxlci5ndWlkID0gaGFuZGxlci5ndWlkO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIEFkZCB0byB0aGUgZWxlbWVudCdzIGhhbmRsZXIgbGlzdCwgZGVsZWdhdGVzIGluIGZyb250XG5cdFx0XHRpZiAoIHNlbGVjdG9yICkge1xuXHRcdFx0XHRoYW5kbGVycy5zcGxpY2UoIGhhbmRsZXJzLmRlbGVnYXRlQ291bnQrKywgMCwgaGFuZGxlT2JqICk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRoYW5kbGVycy5wdXNoKCBoYW5kbGVPYmogKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gS2VlcCB0cmFjayBvZiB3aGljaCBldmVudHMgaGF2ZSBldmVyIGJlZW4gdXNlZCwgZm9yIGV2ZW50IG9wdGltaXphdGlvblxuXHRcdFx0alF1ZXJ5LmV2ZW50Lmdsb2JhbFsgdHlwZSBdID0gdHJ1ZTtcblx0XHR9XG5cblx0fSxcblxuXHQvLyBEZXRhY2ggYW4gZXZlbnQgb3Igc2V0IG9mIGV2ZW50cyBmcm9tIGFuIGVsZW1lbnRcblx0cmVtb3ZlOiBmdW5jdGlvbiggZWxlbSwgdHlwZXMsIGhhbmRsZXIsIHNlbGVjdG9yLCBtYXBwZWRUeXBlcyApIHtcblxuXHRcdHZhciBqLCBvcmlnQ291bnQsIHRtcCxcblx0XHRcdGV2ZW50cywgdCwgaGFuZGxlT2JqLFxuXHRcdFx0c3BlY2lhbCwgaGFuZGxlcnMsIHR5cGUsIG5hbWVzcGFjZXMsIG9yaWdUeXBlLFxuXHRcdFx0ZWxlbURhdGEgPSBkYXRhUHJpdi5oYXNEYXRhKCBlbGVtICkgJiYgZGF0YVByaXYuZ2V0KCBlbGVtICk7XG5cblx0XHRpZiAoICFlbGVtRGF0YSB8fCAhKCBldmVudHMgPSBlbGVtRGF0YS5ldmVudHMgKSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBPbmNlIGZvciBlYWNoIHR5cGUubmFtZXNwYWNlIGluIHR5cGVzOyB0eXBlIG1heSBiZSBvbWl0dGVkXG5cdFx0dHlwZXMgPSAoIHR5cGVzIHx8IFwiXCIgKS5tYXRjaCggcm5vdGh0bWx3aGl0ZSApIHx8IFsgXCJcIiBdO1xuXHRcdHQgPSB0eXBlcy5sZW5ndGg7XG5cdFx0d2hpbGUgKCB0LS0gKSB7XG5cdFx0XHR0bXAgPSBydHlwZW5hbWVzcGFjZS5leGVjKCB0eXBlc1sgdCBdICkgfHwgW107XG5cdFx0XHR0eXBlID0gb3JpZ1R5cGUgPSB0bXBbIDEgXTtcblx0XHRcdG5hbWVzcGFjZXMgPSAoIHRtcFsgMiBdIHx8IFwiXCIgKS5zcGxpdCggXCIuXCIgKS5zb3J0KCk7XG5cblx0XHRcdC8vIFVuYmluZCBhbGwgZXZlbnRzIChvbiB0aGlzIG5hbWVzcGFjZSwgaWYgcHJvdmlkZWQpIGZvciB0aGUgZWxlbWVudFxuXHRcdFx0aWYgKCAhdHlwZSApIHtcblx0XHRcdFx0Zm9yICggdHlwZSBpbiBldmVudHMgKSB7XG5cdFx0XHRcdFx0alF1ZXJ5LmV2ZW50LnJlbW92ZSggZWxlbSwgdHlwZSArIHR5cGVzWyB0IF0sIGhhbmRsZXIsIHNlbGVjdG9yLCB0cnVlICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0Y29udGludWU7XG5cdFx0XHR9XG5cblx0XHRcdHNwZWNpYWwgPSBqUXVlcnkuZXZlbnQuc3BlY2lhbFsgdHlwZSBdIHx8IHt9O1xuXHRcdFx0dHlwZSA9ICggc2VsZWN0b3IgPyBzcGVjaWFsLmRlbGVnYXRlVHlwZSA6IHNwZWNpYWwuYmluZFR5cGUgKSB8fCB0eXBlO1xuXHRcdFx0aGFuZGxlcnMgPSBldmVudHNbIHR5cGUgXSB8fCBbXTtcblx0XHRcdHRtcCA9IHRtcFsgMiBdICYmXG5cdFx0XHRcdG5ldyBSZWdFeHAoIFwiKF58XFxcXC4pXCIgKyBuYW1lc3BhY2VzLmpvaW4oIFwiXFxcXC4oPzouKlxcXFwufClcIiApICsgXCIoXFxcXC58JClcIiApO1xuXG5cdFx0XHQvLyBSZW1vdmUgbWF0Y2hpbmcgZXZlbnRzXG5cdFx0XHRvcmlnQ291bnQgPSBqID0gaGFuZGxlcnMubGVuZ3RoO1xuXHRcdFx0d2hpbGUgKCBqLS0gKSB7XG5cdFx0XHRcdGhhbmRsZU9iaiA9IGhhbmRsZXJzWyBqIF07XG5cblx0XHRcdFx0aWYgKCAoIG1hcHBlZFR5cGVzIHx8IG9yaWdUeXBlID09PSBoYW5kbGVPYmoub3JpZ1R5cGUgKSAmJlxuXHRcdFx0XHRcdCggIWhhbmRsZXIgfHwgaGFuZGxlci5ndWlkID09PSBoYW5kbGVPYmouZ3VpZCApICYmXG5cdFx0XHRcdFx0KCAhdG1wIHx8IHRtcC50ZXN0KCBoYW5kbGVPYmoubmFtZXNwYWNlICkgKSAmJlxuXHRcdFx0XHRcdCggIXNlbGVjdG9yIHx8IHNlbGVjdG9yID09PSBoYW5kbGVPYmouc2VsZWN0b3IgfHxcblx0XHRcdFx0XHRcdHNlbGVjdG9yID09PSBcIioqXCIgJiYgaGFuZGxlT2JqLnNlbGVjdG9yICkgKSB7XG5cdFx0XHRcdFx0aGFuZGxlcnMuc3BsaWNlKCBqLCAxICk7XG5cblx0XHRcdFx0XHRpZiAoIGhhbmRsZU9iai5zZWxlY3RvciApIHtcblx0XHRcdFx0XHRcdGhhbmRsZXJzLmRlbGVnYXRlQ291bnQtLTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKCBzcGVjaWFsLnJlbW92ZSApIHtcblx0XHRcdFx0XHRcdHNwZWNpYWwucmVtb3ZlLmNhbGwoIGVsZW0sIGhhbmRsZU9iaiApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBSZW1vdmUgZ2VuZXJpYyBldmVudCBoYW5kbGVyIGlmIHdlIHJlbW92ZWQgc29tZXRoaW5nIGFuZCBubyBtb3JlIGhhbmRsZXJzIGV4aXN0XG5cdFx0XHQvLyAoYXZvaWRzIHBvdGVudGlhbCBmb3IgZW5kbGVzcyByZWN1cnNpb24gZHVyaW5nIHJlbW92YWwgb2Ygc3BlY2lhbCBldmVudCBoYW5kbGVycylcblx0XHRcdGlmICggb3JpZ0NvdW50ICYmICFoYW5kbGVycy5sZW5ndGggKSB7XG5cdFx0XHRcdGlmICggIXNwZWNpYWwudGVhcmRvd24gfHxcblx0XHRcdFx0XHRzcGVjaWFsLnRlYXJkb3duLmNhbGwoIGVsZW0sIG5hbWVzcGFjZXMsIGVsZW1EYXRhLmhhbmRsZSApID09PSBmYWxzZSApIHtcblxuXHRcdFx0XHRcdGpRdWVyeS5yZW1vdmVFdmVudCggZWxlbSwgdHlwZSwgZWxlbURhdGEuaGFuZGxlICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRkZWxldGUgZXZlbnRzWyB0eXBlIF07XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gUmVtb3ZlIGRhdGEgYW5kIHRoZSBleHBhbmRvIGlmIGl0J3Mgbm8gbG9uZ2VyIHVzZWRcblx0XHRpZiAoIGpRdWVyeS5pc0VtcHR5T2JqZWN0KCBldmVudHMgKSApIHtcblx0XHRcdGRhdGFQcml2LnJlbW92ZSggZWxlbSwgXCJoYW5kbGUgZXZlbnRzXCIgKTtcblx0XHR9XG5cdH0sXG5cblx0ZGlzcGF0Y2g6IGZ1bmN0aW9uKCBuYXRpdmVFdmVudCApIHtcblxuXHRcdHZhciBpLCBqLCByZXQsIG1hdGNoZWQsIGhhbmRsZU9iaiwgaGFuZGxlclF1ZXVlLFxuXHRcdFx0YXJncyA9IG5ldyBBcnJheSggYXJndW1lbnRzLmxlbmd0aCApLFxuXG5cdFx0XHQvLyBNYWtlIGEgd3JpdGFibGUgalF1ZXJ5LkV2ZW50IGZyb20gdGhlIG5hdGl2ZSBldmVudCBvYmplY3Rcblx0XHRcdGV2ZW50ID0galF1ZXJ5LmV2ZW50LmZpeCggbmF0aXZlRXZlbnQgKSxcblxuXHRcdFx0aGFuZGxlcnMgPSAoXG5cdFx0XHRcdGRhdGFQcml2LmdldCggdGhpcywgXCJldmVudHNcIiApIHx8IE9iamVjdC5jcmVhdGUoIG51bGwgKVxuXHRcdFx0KVsgZXZlbnQudHlwZSBdIHx8IFtdLFxuXHRcdFx0c3BlY2lhbCA9IGpRdWVyeS5ldmVudC5zcGVjaWFsWyBldmVudC50eXBlIF0gfHwge307XG5cblx0XHQvLyBVc2UgdGhlIGZpeC1lZCBqUXVlcnkuRXZlbnQgcmF0aGVyIHRoYW4gdGhlIChyZWFkLW9ubHkpIG5hdGl2ZSBldmVudFxuXHRcdGFyZ3NbIDAgXSA9IGV2ZW50O1xuXG5cdFx0Zm9yICggaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKysgKSB7XG5cdFx0XHRhcmdzWyBpIF0gPSBhcmd1bWVudHNbIGkgXTtcblx0XHR9XG5cblx0XHRldmVudC5kZWxlZ2F0ZVRhcmdldCA9IHRoaXM7XG5cblx0XHQvLyBDYWxsIHRoZSBwcmVEaXNwYXRjaCBob29rIGZvciB0aGUgbWFwcGVkIHR5cGUsIGFuZCBsZXQgaXQgYmFpbCBpZiBkZXNpcmVkXG5cdFx0aWYgKCBzcGVjaWFsLnByZURpc3BhdGNoICYmIHNwZWNpYWwucHJlRGlzcGF0Y2guY2FsbCggdGhpcywgZXZlbnQgKSA9PT0gZmFsc2UgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gRGV0ZXJtaW5lIGhhbmRsZXJzXG5cdFx0aGFuZGxlclF1ZXVlID0galF1ZXJ5LmV2ZW50LmhhbmRsZXJzLmNhbGwoIHRoaXMsIGV2ZW50LCBoYW5kbGVycyApO1xuXG5cdFx0Ly8gUnVuIGRlbGVnYXRlcyBmaXJzdDsgdGhleSBtYXkgd2FudCB0byBzdG9wIHByb3BhZ2F0aW9uIGJlbmVhdGggdXNcblx0XHRpID0gMDtcblx0XHR3aGlsZSAoICggbWF0Y2hlZCA9IGhhbmRsZXJRdWV1ZVsgaSsrIF0gKSAmJiAhZXZlbnQuaXNQcm9wYWdhdGlvblN0b3BwZWQoKSApIHtcblx0XHRcdGV2ZW50LmN1cnJlbnRUYXJnZXQgPSBtYXRjaGVkLmVsZW07XG5cblx0XHRcdGogPSAwO1xuXHRcdFx0d2hpbGUgKCAoIGhhbmRsZU9iaiA9IG1hdGNoZWQuaGFuZGxlcnNbIGorKyBdICkgJiZcblx0XHRcdFx0IWV2ZW50LmlzSW1tZWRpYXRlUHJvcGFnYXRpb25TdG9wcGVkKCkgKSB7XG5cblx0XHRcdFx0Ly8gSWYgdGhlIGV2ZW50IGlzIG5hbWVzcGFjZWQsIHRoZW4gZWFjaCBoYW5kbGVyIGlzIG9ubHkgaW52b2tlZCBpZiBpdCBpc1xuXHRcdFx0XHQvLyBzcGVjaWFsbHkgdW5pdmVyc2FsIG9yIGl0cyBuYW1lc3BhY2VzIGFyZSBhIHN1cGVyc2V0IG9mIHRoZSBldmVudCdzLlxuXHRcdFx0XHRpZiAoICFldmVudC5ybmFtZXNwYWNlIHx8IGhhbmRsZU9iai5uYW1lc3BhY2UgPT09IGZhbHNlIHx8XG5cdFx0XHRcdFx0ZXZlbnQucm5hbWVzcGFjZS50ZXN0KCBoYW5kbGVPYmoubmFtZXNwYWNlICkgKSB7XG5cblx0XHRcdFx0XHRldmVudC5oYW5kbGVPYmogPSBoYW5kbGVPYmo7XG5cdFx0XHRcdFx0ZXZlbnQuZGF0YSA9IGhhbmRsZU9iai5kYXRhO1xuXG5cdFx0XHRcdFx0cmV0ID0gKCAoIGpRdWVyeS5ldmVudC5zcGVjaWFsWyBoYW5kbGVPYmoub3JpZ1R5cGUgXSB8fCB7fSApLmhhbmRsZSB8fFxuXHRcdFx0XHRcdFx0aGFuZGxlT2JqLmhhbmRsZXIgKS5hcHBseSggbWF0Y2hlZC5lbGVtLCBhcmdzICk7XG5cblx0XHRcdFx0XHRpZiAoIHJldCAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdFx0aWYgKCAoIGV2ZW50LnJlc3VsdCA9IHJldCApID09PSBmYWxzZSApIHtcblx0XHRcdFx0XHRcdFx0ZXZlbnQucHJldmVudERlZmF1bHQoKTtcblx0XHRcdFx0XHRcdFx0ZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gQ2FsbCB0aGUgcG9zdERpc3BhdGNoIGhvb2sgZm9yIHRoZSBtYXBwZWQgdHlwZVxuXHRcdGlmICggc3BlY2lhbC5wb3N0RGlzcGF0Y2ggKSB7XG5cdFx0XHRzcGVjaWFsLnBvc3REaXNwYXRjaC5jYWxsKCB0aGlzLCBldmVudCApO1xuXHRcdH1cblxuXHRcdHJldHVybiBldmVudC5yZXN1bHQ7XG5cdH0sXG5cblx0aGFuZGxlcnM6IGZ1bmN0aW9uKCBldmVudCwgaGFuZGxlcnMgKSB7XG5cdFx0dmFyIGksIGhhbmRsZU9iaiwgc2VsLCBtYXRjaGVkSGFuZGxlcnMsIG1hdGNoZWRTZWxlY3RvcnMsXG5cdFx0XHRoYW5kbGVyUXVldWUgPSBbXSxcblx0XHRcdGRlbGVnYXRlQ291bnQgPSBoYW5kbGVycy5kZWxlZ2F0ZUNvdW50LFxuXHRcdFx0Y3VyID0gZXZlbnQudGFyZ2V0O1xuXG5cdFx0Ly8gRmluZCBkZWxlZ2F0ZSBoYW5kbGVyc1xuXHRcdGlmICggZGVsZWdhdGVDb3VudCAmJlxuXG5cdFx0XHQvLyBTdXBwb3J0OiBJRSA8PTlcblx0XHRcdC8vIEJsYWNrLWhvbGUgU1ZHIDx1c2U+IGluc3RhbmNlIHRyZWVzICh0cmFjLTEzMTgwKVxuXHRcdFx0Y3VyLm5vZGVUeXBlICYmXG5cblx0XHRcdC8vIFN1cHBvcnQ6IEZpcmVmb3ggPD00MlxuXHRcdFx0Ly8gU3VwcHJlc3Mgc3BlYy12aW9sYXRpbmcgY2xpY2tzIGluZGljYXRpbmcgYSBub24tcHJpbWFyeSBwb2ludGVyIGJ1dHRvbiAodHJhYy0zODYxKVxuXHRcdFx0Ly8gaHR0cHM6Ly93d3cudzMub3JnL1RSL0RPTS1MZXZlbC0zLUV2ZW50cy8jZXZlbnQtdHlwZS1jbGlja1xuXHRcdFx0Ly8gU3VwcG9ydDogSUUgMTEgb25seVxuXHRcdFx0Ly8gLi4uYnV0IG5vdCBhcnJvdyBrZXkgXCJjbGlja3NcIiBvZiByYWRpbyBpbnB1dHMsIHdoaWNoIGNhbiBoYXZlIGBidXR0b25gIC0xIChnaC0yMzQzKVxuXHRcdFx0ISggZXZlbnQudHlwZSA9PT0gXCJjbGlja1wiICYmIGV2ZW50LmJ1dHRvbiA+PSAxICkgKSB7XG5cblx0XHRcdGZvciAoIDsgY3VyICE9PSB0aGlzOyBjdXIgPSBjdXIucGFyZW50Tm9kZSB8fCB0aGlzICkge1xuXG5cdFx0XHRcdC8vIERvbid0IGNoZWNrIG5vbi1lbGVtZW50cyAoIzEzMjA4KVxuXHRcdFx0XHQvLyBEb24ndCBwcm9jZXNzIGNsaWNrcyBvbiBkaXNhYmxlZCBlbGVtZW50cyAoIzY5MTEsICM4MTY1LCAjMTEzODIsICMxMTc2NClcblx0XHRcdFx0aWYgKCBjdXIubm9kZVR5cGUgPT09IDEgJiYgISggZXZlbnQudHlwZSA9PT0gXCJjbGlja1wiICYmIGN1ci5kaXNhYmxlZCA9PT0gdHJ1ZSApICkge1xuXHRcdFx0XHRcdG1hdGNoZWRIYW5kbGVycyA9IFtdO1xuXHRcdFx0XHRcdG1hdGNoZWRTZWxlY3RvcnMgPSB7fTtcblx0XHRcdFx0XHRmb3IgKCBpID0gMDsgaSA8IGRlbGVnYXRlQ291bnQ7IGkrKyApIHtcblx0XHRcdFx0XHRcdGhhbmRsZU9iaiA9IGhhbmRsZXJzWyBpIF07XG5cblx0XHRcdFx0XHRcdC8vIERvbid0IGNvbmZsaWN0IHdpdGggT2JqZWN0LnByb3RvdHlwZSBwcm9wZXJ0aWVzICgjMTMyMDMpXG5cdFx0XHRcdFx0XHRzZWwgPSBoYW5kbGVPYmouc2VsZWN0b3IgKyBcIiBcIjtcblxuXHRcdFx0XHRcdFx0aWYgKCBtYXRjaGVkU2VsZWN0b3JzWyBzZWwgXSA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdFx0XHRtYXRjaGVkU2VsZWN0b3JzWyBzZWwgXSA9IGhhbmRsZU9iai5uZWVkc0NvbnRleHQgP1xuXHRcdFx0XHRcdFx0XHRcdGpRdWVyeSggc2VsLCB0aGlzICkuaW5kZXgoIGN1ciApID4gLTEgOlxuXHRcdFx0XHRcdFx0XHRcdGpRdWVyeS5maW5kKCBzZWwsIHRoaXMsIG51bGwsIFsgY3VyIF0gKS5sZW5ndGg7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRpZiAoIG1hdGNoZWRTZWxlY3RvcnNbIHNlbCBdICkge1xuXHRcdFx0XHRcdFx0XHRtYXRjaGVkSGFuZGxlcnMucHVzaCggaGFuZGxlT2JqICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmICggbWF0Y2hlZEhhbmRsZXJzLmxlbmd0aCApIHtcblx0XHRcdFx0XHRcdGhhbmRsZXJRdWV1ZS5wdXNoKCB7IGVsZW06IGN1ciwgaGFuZGxlcnM6IG1hdGNoZWRIYW5kbGVycyB9ICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gQWRkIHRoZSByZW1haW5pbmcgKGRpcmVjdGx5LWJvdW5kKSBoYW5kbGVyc1xuXHRcdGN1ciA9IHRoaXM7XG5cdFx0aWYgKCBkZWxlZ2F0ZUNvdW50IDwgaGFuZGxlcnMubGVuZ3RoICkge1xuXHRcdFx0aGFuZGxlclF1ZXVlLnB1c2goIHsgZWxlbTogY3VyLCBoYW5kbGVyczogaGFuZGxlcnMuc2xpY2UoIGRlbGVnYXRlQ291bnQgKSB9ICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGhhbmRsZXJRdWV1ZTtcblx0fSxcblxuXHRhZGRQcm9wOiBmdW5jdGlvbiggbmFtZSwgaG9vayApIHtcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoIGpRdWVyeS5FdmVudC5wcm90b3R5cGUsIG5hbWUsIHtcblx0XHRcdGVudW1lcmFibGU6IHRydWUsXG5cdFx0XHRjb25maWd1cmFibGU6IHRydWUsXG5cblx0XHRcdGdldDogaXNGdW5jdGlvbiggaG9vayApID9cblx0XHRcdFx0ZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0aWYgKCB0aGlzLm9yaWdpbmFsRXZlbnQgKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gaG9vayggdGhpcy5vcmlnaW5hbEV2ZW50ICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IDpcblx0XHRcdFx0ZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0aWYgKCB0aGlzLm9yaWdpbmFsRXZlbnQgKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gdGhpcy5vcmlnaW5hbEV2ZW50WyBuYW1lIF07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9LFxuXG5cdFx0XHRzZXQ6IGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KCB0aGlzLCBuYW1lLCB7XG5cdFx0XHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcblx0XHRcdFx0XHRjb25maWd1cmFibGU6IHRydWUsXG5cdFx0XHRcdFx0d3JpdGFibGU6IHRydWUsXG5cdFx0XHRcdFx0dmFsdWU6IHZhbHVlXG5cdFx0XHRcdH0gKTtcblx0XHRcdH1cblx0XHR9ICk7XG5cdH0sXG5cblx0Zml4OiBmdW5jdGlvbiggb3JpZ2luYWxFdmVudCApIHtcblx0XHRyZXR1cm4gb3JpZ2luYWxFdmVudFsgalF1ZXJ5LmV4cGFuZG8gXSA/XG5cdFx0XHRvcmlnaW5hbEV2ZW50IDpcblx0XHRcdG5ldyBqUXVlcnkuRXZlbnQoIG9yaWdpbmFsRXZlbnQgKTtcblx0fSxcblxuXHRzcGVjaWFsOiB7XG5cdFx0bG9hZDoge1xuXG5cdFx0XHQvLyBQcmV2ZW50IHRyaWdnZXJlZCBpbWFnZS5sb2FkIGV2ZW50cyBmcm9tIGJ1YmJsaW5nIHRvIHdpbmRvdy5sb2FkXG5cdFx0XHRub0J1YmJsZTogdHJ1ZVxuXHRcdH0sXG5cdFx0Y2xpY2s6IHtcblxuXHRcdFx0Ly8gVXRpbGl6ZSBuYXRpdmUgZXZlbnQgdG8gZW5zdXJlIGNvcnJlY3Qgc3RhdGUgZm9yIGNoZWNrYWJsZSBpbnB1dHNcblx0XHRcdHNldHVwOiBmdW5jdGlvbiggZGF0YSApIHtcblxuXHRcdFx0XHQvLyBGb3IgbXV0dWFsIGNvbXByZXNzaWJpbGl0eSB3aXRoIF9kZWZhdWx0LCByZXBsYWNlIGB0aGlzYCBhY2Nlc3Mgd2l0aCBhIGxvY2FsIHZhci5cblx0XHRcdFx0Ly8gYHx8IGRhdGFgIGlzIGRlYWQgY29kZSBtZWFudCBvbmx5IHRvIHByZXNlcnZlIHRoZSB2YXJpYWJsZSB0aHJvdWdoIG1pbmlmaWNhdGlvbi5cblx0XHRcdFx0dmFyIGVsID0gdGhpcyB8fCBkYXRhO1xuXG5cdFx0XHRcdC8vIENsYWltIHRoZSBmaXJzdCBoYW5kbGVyXG5cdFx0XHRcdGlmICggcmNoZWNrYWJsZVR5cGUudGVzdCggZWwudHlwZSApICYmXG5cdFx0XHRcdFx0ZWwuY2xpY2sgJiYgbm9kZU5hbWUoIGVsLCBcImlucHV0XCIgKSApIHtcblxuXHRcdFx0XHRcdC8vIGRhdGFQcml2LnNldCggZWwsIFwiY2xpY2tcIiwgLi4uIClcblx0XHRcdFx0XHRsZXZlcmFnZU5hdGl2ZSggZWwsIFwiY2xpY2tcIiwgcmV0dXJuVHJ1ZSApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gUmV0dXJuIGZhbHNlIHRvIGFsbG93IG5vcm1hbCBwcm9jZXNzaW5nIGluIHRoZSBjYWxsZXJcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fSxcblx0XHRcdHRyaWdnZXI6IGZ1bmN0aW9uKCBkYXRhICkge1xuXG5cdFx0XHRcdC8vIEZvciBtdXR1YWwgY29tcHJlc3NpYmlsaXR5IHdpdGggX2RlZmF1bHQsIHJlcGxhY2UgYHRoaXNgIGFjY2VzcyB3aXRoIGEgbG9jYWwgdmFyLlxuXHRcdFx0XHQvLyBgfHwgZGF0YWAgaXMgZGVhZCBjb2RlIG1lYW50IG9ubHkgdG8gcHJlc2VydmUgdGhlIHZhcmlhYmxlIHRocm91Z2ggbWluaWZpY2F0aW9uLlxuXHRcdFx0XHR2YXIgZWwgPSB0aGlzIHx8IGRhdGE7XG5cblx0XHRcdFx0Ly8gRm9yY2Ugc2V0dXAgYmVmb3JlIHRyaWdnZXJpbmcgYSBjbGlja1xuXHRcdFx0XHRpZiAoIHJjaGVja2FibGVUeXBlLnRlc3QoIGVsLnR5cGUgKSAmJlxuXHRcdFx0XHRcdGVsLmNsaWNrICYmIG5vZGVOYW1lKCBlbCwgXCJpbnB1dFwiICkgKSB7XG5cblx0XHRcdFx0XHRsZXZlcmFnZU5hdGl2ZSggZWwsIFwiY2xpY2tcIiApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gUmV0dXJuIG5vbi1mYWxzZSB0byBhbGxvdyBub3JtYWwgZXZlbnQtcGF0aCBwcm9wYWdhdGlvblxuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH0sXG5cblx0XHRcdC8vIEZvciBjcm9zcy1icm93c2VyIGNvbnNpc3RlbmN5LCBzdXBwcmVzcyBuYXRpdmUgLmNsaWNrKCkgb24gbGlua3Ncblx0XHRcdC8vIEFsc28gcHJldmVudCBpdCBpZiB3ZSdyZSBjdXJyZW50bHkgaW5zaWRlIGEgbGV2ZXJhZ2VkIG5hdGl2ZS1ldmVudCBzdGFja1xuXHRcdFx0X2RlZmF1bHQ6IGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHRcdFx0dmFyIHRhcmdldCA9IGV2ZW50LnRhcmdldDtcblx0XHRcdFx0cmV0dXJuIHJjaGVja2FibGVUeXBlLnRlc3QoIHRhcmdldC50eXBlICkgJiZcblx0XHRcdFx0XHR0YXJnZXQuY2xpY2sgJiYgbm9kZU5hbWUoIHRhcmdldCwgXCJpbnB1dFwiICkgJiZcblx0XHRcdFx0XHRkYXRhUHJpdi5nZXQoIHRhcmdldCwgXCJjbGlja1wiICkgfHxcblx0XHRcdFx0XHRub2RlTmFtZSggdGFyZ2V0LCBcImFcIiApO1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHRiZWZvcmV1bmxvYWQ6IHtcblx0XHRcdHBvc3REaXNwYXRjaDogZnVuY3Rpb24oIGV2ZW50ICkge1xuXG5cdFx0XHRcdC8vIFN1cHBvcnQ6IEZpcmVmb3ggMjArXG5cdFx0XHRcdC8vIEZpcmVmb3ggZG9lc24ndCBhbGVydCBpZiB0aGUgcmV0dXJuVmFsdWUgZmllbGQgaXMgbm90IHNldC5cblx0XHRcdFx0aWYgKCBldmVudC5yZXN1bHQgIT09IHVuZGVmaW5lZCAmJiBldmVudC5vcmlnaW5hbEV2ZW50ICkge1xuXHRcdFx0XHRcdGV2ZW50Lm9yaWdpbmFsRXZlbnQucmV0dXJuVmFsdWUgPSBldmVudC5yZXN1bHQ7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cbn07XG5cbi8vIEVuc3VyZSB0aGUgcHJlc2VuY2Ugb2YgYW4gZXZlbnQgbGlzdGVuZXIgdGhhdCBoYW5kbGVzIG1hbnVhbGx5LXRyaWdnZXJlZFxuLy8gc3ludGhldGljIGV2ZW50cyBieSBpbnRlcnJ1cHRpbmcgcHJvZ3Jlc3MgdW50aWwgcmVpbnZva2VkIGluIHJlc3BvbnNlIHRvXG4vLyAqbmF0aXZlKiBldmVudHMgdGhhdCBpdCBmaXJlcyBkaXJlY3RseSwgZW5zdXJpbmcgdGhhdCBzdGF0ZSBjaGFuZ2VzIGhhdmVcbi8vIGFscmVhZHkgb2NjdXJyZWQgYmVmb3JlIG90aGVyIGxpc3RlbmVycyBhcmUgaW52b2tlZC5cbmZ1bmN0aW9uIGxldmVyYWdlTmF0aXZlKCBlbCwgdHlwZSwgZXhwZWN0U3luYyApIHtcblxuXHQvLyBNaXNzaW5nIGV4cGVjdFN5bmMgaW5kaWNhdGVzIGEgdHJpZ2dlciBjYWxsLCB3aGljaCBtdXN0IGZvcmNlIHNldHVwIHRocm91Z2ggalF1ZXJ5LmV2ZW50LmFkZFxuXHRpZiAoICFleHBlY3RTeW5jICkge1xuXHRcdGlmICggZGF0YVByaXYuZ2V0KCBlbCwgdHlwZSApID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRqUXVlcnkuZXZlbnQuYWRkKCBlbCwgdHlwZSwgcmV0dXJuVHJ1ZSApO1xuXHRcdH1cblx0XHRyZXR1cm47XG5cdH1cblxuXHQvLyBSZWdpc3RlciB0aGUgY29udHJvbGxlciBhcyBhIHNwZWNpYWwgdW5pdmVyc2FsIGhhbmRsZXIgZm9yIGFsbCBldmVudCBuYW1lc3BhY2VzXG5cdGRhdGFQcml2LnNldCggZWwsIHR5cGUsIGZhbHNlICk7XG5cdGpRdWVyeS5ldmVudC5hZGQoIGVsLCB0eXBlLCB7XG5cdFx0bmFtZXNwYWNlOiBmYWxzZSxcblx0XHRoYW5kbGVyOiBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0XHR2YXIgbm90QXN5bmMsIHJlc3VsdCxcblx0XHRcdFx0c2F2ZWQgPSBkYXRhUHJpdi5nZXQoIHRoaXMsIHR5cGUgKTtcblxuXHRcdFx0aWYgKCAoIGV2ZW50LmlzVHJpZ2dlciAmIDEgKSAmJiB0aGlzWyB0eXBlIF0gKSB7XG5cblx0XHRcdFx0Ly8gSW50ZXJydXB0IHByb2Nlc3Npbmcgb2YgdGhlIG91dGVyIHN5bnRoZXRpYyAudHJpZ2dlcigpZWQgZXZlbnRcblx0XHRcdFx0Ly8gU2F2ZWQgZGF0YSBzaG91bGQgYmUgZmFsc2UgaW4gc3VjaCBjYXNlcywgYnV0IG1pZ2h0IGJlIGEgbGVmdG92ZXIgY2FwdHVyZSBvYmplY3Rcblx0XHRcdFx0Ly8gZnJvbSBhbiBhc3luYyBuYXRpdmUgaGFuZGxlciAoZ2gtNDM1MClcblx0XHRcdFx0aWYgKCAhc2F2ZWQubGVuZ3RoICkge1xuXG5cdFx0XHRcdFx0Ly8gU3RvcmUgYXJndW1lbnRzIGZvciB1c2Ugd2hlbiBoYW5kbGluZyB0aGUgaW5uZXIgbmF0aXZlIGV2ZW50XG5cdFx0XHRcdFx0Ly8gVGhlcmUgd2lsbCBhbHdheXMgYmUgYXQgbGVhc3Qgb25lIGFyZ3VtZW50IChhbiBldmVudCBvYmplY3QpLCBzbyB0aGlzIGFycmF5XG5cdFx0XHRcdFx0Ly8gd2lsbCBub3QgYmUgY29uZnVzZWQgd2l0aCBhIGxlZnRvdmVyIGNhcHR1cmUgb2JqZWN0LlxuXHRcdFx0XHRcdHNhdmVkID0gc2xpY2UuY2FsbCggYXJndW1lbnRzICk7XG5cdFx0XHRcdFx0ZGF0YVByaXYuc2V0KCB0aGlzLCB0eXBlLCBzYXZlZCApO1xuXG5cdFx0XHRcdFx0Ly8gVHJpZ2dlciB0aGUgbmF0aXZlIGV2ZW50IGFuZCBjYXB0dXJlIGl0cyByZXN1bHRcblx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA8PTkgLSAxMStcblx0XHRcdFx0XHQvLyBmb2N1cygpIGFuZCBibHVyKCkgYXJlIGFzeW5jaHJvbm91c1xuXHRcdFx0XHRcdG5vdEFzeW5jID0gZXhwZWN0U3luYyggdGhpcywgdHlwZSApO1xuXHRcdFx0XHRcdHRoaXNbIHR5cGUgXSgpO1xuXHRcdFx0XHRcdHJlc3VsdCA9IGRhdGFQcml2LmdldCggdGhpcywgdHlwZSApO1xuXHRcdFx0XHRcdGlmICggc2F2ZWQgIT09IHJlc3VsdCB8fCBub3RBc3luYyApIHtcblx0XHRcdFx0XHRcdGRhdGFQcml2LnNldCggdGhpcywgdHlwZSwgZmFsc2UgKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0cmVzdWx0ID0ge307XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmICggc2F2ZWQgIT09IHJlc3VsdCApIHtcblxuXHRcdFx0XHRcdFx0Ly8gQ2FuY2VsIHRoZSBvdXRlciBzeW50aGV0aWMgZXZlbnRcblx0XHRcdFx0XHRcdGV2ZW50LnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xuXHRcdFx0XHRcdFx0ZXZlbnQucHJldmVudERlZmF1bHQoKTtcblxuXHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogQ2hyb21lIDg2K1xuXHRcdFx0XHRcdFx0Ly8gSW4gQ2hyb21lLCBpZiBhbiBlbGVtZW50IGhhdmluZyBhIGZvY3Vzb3V0IGhhbmRsZXIgaXMgYmx1cnJlZCBieVxuXHRcdFx0XHRcdFx0Ly8gY2xpY2tpbmcgb3V0c2lkZSBvZiBpdCwgaXQgaW52b2tlcyB0aGUgaGFuZGxlciBzeW5jaHJvbm91c2x5LiBJZlxuXHRcdFx0XHRcdFx0Ly8gdGhhdCBoYW5kbGVyIGNhbGxzIGAucmVtb3ZlKClgIG9uIHRoZSBlbGVtZW50LCB0aGUgZGF0YSBpcyBjbGVhcmVkLFxuXHRcdFx0XHRcdFx0Ly8gbGVhdmluZyBgcmVzdWx0YCB1bmRlZmluZWQuIFdlIG5lZWQgdG8gZ3VhcmQgYWdhaW5zdCB0aGlzLlxuXHRcdFx0XHRcdFx0cmV0dXJuIHJlc3VsdCAmJiByZXN1bHQudmFsdWU7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIElmIHRoaXMgaXMgYW4gaW5uZXIgc3ludGhldGljIGV2ZW50IGZvciBhbiBldmVudCB3aXRoIGEgYnViYmxpbmcgc3Vycm9nYXRlXG5cdFx0XHRcdC8vIChmb2N1cyBvciBibHVyKSwgYXNzdW1lIHRoYXQgdGhlIHN1cnJvZ2F0ZSBhbHJlYWR5IHByb3BhZ2F0ZWQgZnJvbSB0cmlnZ2VyaW5nIHRoZVxuXHRcdFx0XHQvLyBuYXRpdmUgZXZlbnQgYW5kIHByZXZlbnQgdGhhdCBmcm9tIGhhcHBlbmluZyBhZ2FpbiBoZXJlLlxuXHRcdFx0XHQvLyBUaGlzIHRlY2huaWNhbGx5IGdldHMgdGhlIG9yZGVyaW5nIHdyb25nIHcuci50LiB0byBgLnRyaWdnZXIoKWAgKGluIHdoaWNoIHRoZVxuXHRcdFx0XHQvLyBidWJibGluZyBzdXJyb2dhdGUgcHJvcGFnYXRlcyAqYWZ0ZXIqIHRoZSBub24tYnViYmxpbmcgYmFzZSksIGJ1dCB0aGF0IHNlZW1zXG5cdFx0XHRcdC8vIGxlc3MgYmFkIHRoYW4gZHVwbGljYXRpb24uXG5cdFx0XHRcdH0gZWxzZSBpZiAoICggalF1ZXJ5LmV2ZW50LnNwZWNpYWxbIHR5cGUgXSB8fCB7fSApLmRlbGVnYXRlVHlwZSApIHtcblx0XHRcdFx0XHRldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcblx0XHRcdFx0fVxuXG5cdFx0XHQvLyBJZiB0aGlzIGlzIGEgbmF0aXZlIGV2ZW50IHRyaWdnZXJlZCBhYm92ZSwgZXZlcnl0aGluZyBpcyBub3cgaW4gb3JkZXJcblx0XHRcdC8vIEZpcmUgYW4gaW5uZXIgc3ludGhldGljIGV2ZW50IHdpdGggdGhlIG9yaWdpbmFsIGFyZ3VtZW50c1xuXHRcdFx0fSBlbHNlIGlmICggc2F2ZWQubGVuZ3RoICkge1xuXG5cdFx0XHRcdC8vIC4uLmFuZCBjYXB0dXJlIHRoZSByZXN1bHRcblx0XHRcdFx0ZGF0YVByaXYuc2V0KCB0aGlzLCB0eXBlLCB7XG5cdFx0XHRcdFx0dmFsdWU6IGpRdWVyeS5ldmVudC50cmlnZ2VyKFxuXG5cdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA8PTkgLSAxMStcblx0XHRcdFx0XHRcdC8vIEV4dGVuZCB3aXRoIHRoZSBwcm90b3R5cGUgdG8gcmVzZXQgdGhlIGFib3ZlIHN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpXG5cdFx0XHRcdFx0XHRqUXVlcnkuZXh0ZW5kKCBzYXZlZFsgMCBdLCBqUXVlcnkuRXZlbnQucHJvdG90eXBlICksXG5cdFx0XHRcdFx0XHRzYXZlZC5zbGljZSggMSApLFxuXHRcdFx0XHRcdFx0dGhpc1xuXHRcdFx0XHRcdClcblx0XHRcdFx0fSApO1xuXG5cdFx0XHRcdC8vIEFib3J0IGhhbmRsaW5nIG9mIHRoZSBuYXRpdmUgZXZlbnRcblx0XHRcdFx0ZXZlbnQuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9ICk7XG59XG5cbmpRdWVyeS5yZW1vdmVFdmVudCA9IGZ1bmN0aW9uKCBlbGVtLCB0eXBlLCBoYW5kbGUgKSB7XG5cblx0Ly8gVGhpcyBcImlmXCIgaXMgbmVlZGVkIGZvciBwbGFpbiBvYmplY3RzXG5cdGlmICggZWxlbS5yZW1vdmVFdmVudExpc3RlbmVyICkge1xuXHRcdGVsZW0ucmVtb3ZlRXZlbnRMaXN0ZW5lciggdHlwZSwgaGFuZGxlICk7XG5cdH1cbn07XG5cbmpRdWVyeS5FdmVudCA9IGZ1bmN0aW9uKCBzcmMsIHByb3BzICkge1xuXG5cdC8vIEFsbG93IGluc3RhbnRpYXRpb24gd2l0aG91dCB0aGUgJ25ldycga2V5d29yZFxuXHRpZiAoICEoIHRoaXMgaW5zdGFuY2VvZiBqUXVlcnkuRXZlbnQgKSApIHtcblx0XHRyZXR1cm4gbmV3IGpRdWVyeS5FdmVudCggc3JjLCBwcm9wcyApO1xuXHR9XG5cblx0Ly8gRXZlbnQgb2JqZWN0XG5cdGlmICggc3JjICYmIHNyYy50eXBlICkge1xuXHRcdHRoaXMub3JpZ2luYWxFdmVudCA9IHNyYztcblx0XHR0aGlzLnR5cGUgPSBzcmMudHlwZTtcblxuXHRcdC8vIEV2ZW50cyBidWJibGluZyB1cCB0aGUgZG9jdW1lbnQgbWF5IGhhdmUgYmVlbiBtYXJrZWQgYXMgcHJldmVudGVkXG5cdFx0Ly8gYnkgYSBoYW5kbGVyIGxvd2VyIGRvd24gdGhlIHRyZWU7IHJlZmxlY3QgdGhlIGNvcnJlY3QgdmFsdWUuXG5cdFx0dGhpcy5pc0RlZmF1bHRQcmV2ZW50ZWQgPSBzcmMuZGVmYXVsdFByZXZlbnRlZCB8fFxuXHRcdFx0XHRzcmMuZGVmYXVsdFByZXZlbnRlZCA9PT0gdW5kZWZpbmVkICYmXG5cblx0XHRcdFx0Ly8gU3VwcG9ydDogQW5kcm9pZCA8PTIuMyBvbmx5XG5cdFx0XHRcdHNyYy5yZXR1cm5WYWx1ZSA9PT0gZmFsc2UgP1xuXHRcdFx0cmV0dXJuVHJ1ZSA6XG5cdFx0XHRyZXR1cm5GYWxzZTtcblxuXHRcdC8vIENyZWF0ZSB0YXJnZXQgcHJvcGVydGllc1xuXHRcdC8vIFN1cHBvcnQ6IFNhZmFyaSA8PTYgLSA3IG9ubHlcblx0XHQvLyBUYXJnZXQgc2hvdWxkIG5vdCBiZSBhIHRleHQgbm9kZSAoIzUwNCwgIzEzMTQzKVxuXHRcdHRoaXMudGFyZ2V0ID0gKCBzcmMudGFyZ2V0ICYmIHNyYy50YXJnZXQubm9kZVR5cGUgPT09IDMgKSA/XG5cdFx0XHRzcmMudGFyZ2V0LnBhcmVudE5vZGUgOlxuXHRcdFx0c3JjLnRhcmdldDtcblxuXHRcdHRoaXMuY3VycmVudFRhcmdldCA9IHNyYy5jdXJyZW50VGFyZ2V0O1xuXHRcdHRoaXMucmVsYXRlZFRhcmdldCA9IHNyYy5yZWxhdGVkVGFyZ2V0O1xuXG5cdC8vIEV2ZW50IHR5cGVcblx0fSBlbHNlIHtcblx0XHR0aGlzLnR5cGUgPSBzcmM7XG5cdH1cblxuXHQvLyBQdXQgZXhwbGljaXRseSBwcm92aWRlZCBwcm9wZXJ0aWVzIG9udG8gdGhlIGV2ZW50IG9iamVjdFxuXHRpZiAoIHByb3BzICkge1xuXHRcdGpRdWVyeS5leHRlbmQoIHRoaXMsIHByb3BzICk7XG5cdH1cblxuXHQvLyBDcmVhdGUgYSB0aW1lc3RhbXAgaWYgaW5jb21pbmcgZXZlbnQgZG9lc24ndCBoYXZlIG9uZVxuXHR0aGlzLnRpbWVTdGFtcCA9IHNyYyAmJiBzcmMudGltZVN0YW1wIHx8IERhdGUubm93KCk7XG5cblx0Ly8gTWFyayBpdCBhcyBmaXhlZFxuXHR0aGlzWyBqUXVlcnkuZXhwYW5kbyBdID0gdHJ1ZTtcbn07XG5cbi8vIGpRdWVyeS5FdmVudCBpcyBiYXNlZCBvbiBET00zIEV2ZW50cyBhcyBzcGVjaWZpZWQgYnkgdGhlIEVDTUFTY3JpcHQgTGFuZ3VhZ2UgQmluZGluZ1xuLy8gaHR0cHM6Ly93d3cudzMub3JnL1RSLzIwMDMvV0QtRE9NLUxldmVsLTMtRXZlbnRzLTIwMDMwMzMxL2VjbWEtc2NyaXB0LWJpbmRpbmcuaHRtbFxualF1ZXJ5LkV2ZW50LnByb3RvdHlwZSA9IHtcblx0Y29uc3RydWN0b3I6IGpRdWVyeS5FdmVudCxcblx0aXNEZWZhdWx0UHJldmVudGVkOiByZXR1cm5GYWxzZSxcblx0aXNQcm9wYWdhdGlvblN0b3BwZWQ6IHJldHVybkZhbHNlLFxuXHRpc0ltbWVkaWF0ZVByb3BhZ2F0aW9uU3RvcHBlZDogcmV0dXJuRmFsc2UsXG5cdGlzU2ltdWxhdGVkOiBmYWxzZSxcblxuXHRwcmV2ZW50RGVmYXVsdDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGUgPSB0aGlzLm9yaWdpbmFsRXZlbnQ7XG5cblx0XHR0aGlzLmlzRGVmYXVsdFByZXZlbnRlZCA9IHJldHVyblRydWU7XG5cblx0XHRpZiAoIGUgJiYgIXRoaXMuaXNTaW11bGF0ZWQgKSB7XG5cdFx0XHRlLnByZXZlbnREZWZhdWx0KCk7XG5cdFx0fVxuXHR9LFxuXHRzdG9wUHJvcGFnYXRpb246IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBlID0gdGhpcy5vcmlnaW5hbEV2ZW50O1xuXG5cdFx0dGhpcy5pc1Byb3BhZ2F0aW9uU3RvcHBlZCA9IHJldHVyblRydWU7XG5cblx0XHRpZiAoIGUgJiYgIXRoaXMuaXNTaW11bGF0ZWQgKSB7XG5cdFx0XHRlLnN0b3BQcm9wYWdhdGlvbigpO1xuXHRcdH1cblx0fSxcblx0c3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgZSA9IHRoaXMub3JpZ2luYWxFdmVudDtcblxuXHRcdHRoaXMuaXNJbW1lZGlhdGVQcm9wYWdhdGlvblN0b3BwZWQgPSByZXR1cm5UcnVlO1xuXG5cdFx0aWYgKCBlICYmICF0aGlzLmlzU2ltdWxhdGVkICkge1xuXHRcdFx0ZS5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcblx0XHR9XG5cblx0XHR0aGlzLnN0b3BQcm9wYWdhdGlvbigpO1xuXHR9XG59O1xuXG4vLyBJbmNsdWRlcyBhbGwgY29tbW9uIGV2ZW50IHByb3BzIGluY2x1ZGluZyBLZXlFdmVudCBhbmQgTW91c2VFdmVudCBzcGVjaWZpYyBwcm9wc1xualF1ZXJ5LmVhY2goIHtcblx0YWx0S2V5OiB0cnVlLFxuXHRidWJibGVzOiB0cnVlLFxuXHRjYW5jZWxhYmxlOiB0cnVlLFxuXHRjaGFuZ2VkVG91Y2hlczogdHJ1ZSxcblx0Y3RybEtleTogdHJ1ZSxcblx0ZGV0YWlsOiB0cnVlLFxuXHRldmVudFBoYXNlOiB0cnVlLFxuXHRtZXRhS2V5OiB0cnVlLFxuXHRwYWdlWDogdHJ1ZSxcblx0cGFnZVk6IHRydWUsXG5cdHNoaWZ0S2V5OiB0cnVlLFxuXHR2aWV3OiB0cnVlLFxuXHRcImNoYXJcIjogdHJ1ZSxcblx0Y29kZTogdHJ1ZSxcblx0Y2hhckNvZGU6IHRydWUsXG5cdGtleTogdHJ1ZSxcblx0a2V5Q29kZTogdHJ1ZSxcblx0YnV0dG9uOiB0cnVlLFxuXHRidXR0b25zOiB0cnVlLFxuXHRjbGllbnRYOiB0cnVlLFxuXHRjbGllbnRZOiB0cnVlLFxuXHRvZmZzZXRYOiB0cnVlLFxuXHRvZmZzZXRZOiB0cnVlLFxuXHRwb2ludGVySWQ6IHRydWUsXG5cdHBvaW50ZXJUeXBlOiB0cnVlLFxuXHRzY3JlZW5YOiB0cnVlLFxuXHRzY3JlZW5ZOiB0cnVlLFxuXHR0YXJnZXRUb3VjaGVzOiB0cnVlLFxuXHR0b0VsZW1lbnQ6IHRydWUsXG5cdHRvdWNoZXM6IHRydWUsXG5cdHdoaWNoOiB0cnVlXG59LCBqUXVlcnkuZXZlbnQuYWRkUHJvcCApO1xuXG5qUXVlcnkuZWFjaCggeyBmb2N1czogXCJmb2N1c2luXCIsIGJsdXI6IFwiZm9jdXNvdXRcIiB9LCBmdW5jdGlvbiggdHlwZSwgZGVsZWdhdGVUeXBlICkge1xuXHRqUXVlcnkuZXZlbnQuc3BlY2lhbFsgdHlwZSBdID0ge1xuXG5cdFx0Ly8gVXRpbGl6ZSBuYXRpdmUgZXZlbnQgaWYgcG9zc2libGUgc28gYmx1ci9mb2N1cyBzZXF1ZW5jZSBpcyBjb3JyZWN0XG5cdFx0c2V0dXA6IGZ1bmN0aW9uKCkge1xuXG5cdFx0XHQvLyBDbGFpbSB0aGUgZmlyc3QgaGFuZGxlclxuXHRcdFx0Ly8gZGF0YVByaXYuc2V0KCB0aGlzLCBcImZvY3VzXCIsIC4uLiApXG5cdFx0XHQvLyBkYXRhUHJpdi5zZXQoIHRoaXMsIFwiYmx1clwiLCAuLi4gKVxuXHRcdFx0bGV2ZXJhZ2VOYXRpdmUoIHRoaXMsIHR5cGUsIGV4cGVjdFN5bmMgKTtcblxuXHRcdFx0Ly8gUmV0dXJuIGZhbHNlIHRvIGFsbG93IG5vcm1hbCBwcm9jZXNzaW5nIGluIHRoZSBjYWxsZXJcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9LFxuXHRcdHRyaWdnZXI6IGZ1bmN0aW9uKCkge1xuXG5cdFx0XHQvLyBGb3JjZSBzZXR1cCBiZWZvcmUgdHJpZ2dlclxuXHRcdFx0bGV2ZXJhZ2VOYXRpdmUoIHRoaXMsIHR5cGUgKTtcblxuXHRcdFx0Ly8gUmV0dXJuIG5vbi1mYWxzZSB0byBhbGxvdyBub3JtYWwgZXZlbnQtcGF0aCBwcm9wYWdhdGlvblxuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fSxcblxuXHRcdC8vIFN1cHByZXNzIG5hdGl2ZSBmb2N1cyBvciBibHVyIGFzIGl0J3MgYWxyZWFkeSBiZWluZyBmaXJlZFxuXHRcdC8vIGluIGxldmVyYWdlTmF0aXZlLlxuXHRcdF9kZWZhdWx0OiBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH0sXG5cblx0XHRkZWxlZ2F0ZVR5cGU6IGRlbGVnYXRlVHlwZVxuXHR9O1xufSApO1xuXG4vLyBDcmVhdGUgbW91c2VlbnRlci9sZWF2ZSBldmVudHMgdXNpbmcgbW91c2VvdmVyL291dCBhbmQgZXZlbnQtdGltZSBjaGVja3Ncbi8vIHNvIHRoYXQgZXZlbnQgZGVsZWdhdGlvbiB3b3JrcyBpbiBqUXVlcnkuXG4vLyBEbyB0aGUgc2FtZSBmb3IgcG9pbnRlcmVudGVyL3BvaW50ZXJsZWF2ZSBhbmQgcG9pbnRlcm92ZXIvcG9pbnRlcm91dFxuLy9cbi8vIFN1cHBvcnQ6IFNhZmFyaSA3IG9ubHlcbi8vIFNhZmFyaSBzZW5kcyBtb3VzZWVudGVyIHRvbyBvZnRlbjsgc2VlOlxuLy8gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9NDcwMjU4XG4vLyBmb3IgdGhlIGRlc2NyaXB0aW9uIG9mIHRoZSBidWcgKGl0IGV4aXN0ZWQgaW4gb2xkZXIgQ2hyb21lIHZlcnNpb25zIGFzIHdlbGwpLlxualF1ZXJ5LmVhY2goIHtcblx0bW91c2VlbnRlcjogXCJtb3VzZW92ZXJcIixcblx0bW91c2VsZWF2ZTogXCJtb3VzZW91dFwiLFxuXHRwb2ludGVyZW50ZXI6IFwicG9pbnRlcm92ZXJcIixcblx0cG9pbnRlcmxlYXZlOiBcInBvaW50ZXJvdXRcIlxufSwgZnVuY3Rpb24oIG9yaWcsIGZpeCApIHtcblx0alF1ZXJ5LmV2ZW50LnNwZWNpYWxbIG9yaWcgXSA9IHtcblx0XHRkZWxlZ2F0ZVR5cGU6IGZpeCxcblx0XHRiaW5kVHlwZTogZml4LFxuXG5cdFx0aGFuZGxlOiBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0XHR2YXIgcmV0LFxuXHRcdFx0XHR0YXJnZXQgPSB0aGlzLFxuXHRcdFx0XHRyZWxhdGVkID0gZXZlbnQucmVsYXRlZFRhcmdldCxcblx0XHRcdFx0aGFuZGxlT2JqID0gZXZlbnQuaGFuZGxlT2JqO1xuXG5cdFx0XHQvLyBGb3IgbW91c2VlbnRlci9sZWF2ZSBjYWxsIHRoZSBoYW5kbGVyIGlmIHJlbGF0ZWQgaXMgb3V0c2lkZSB0aGUgdGFyZ2V0LlxuXHRcdFx0Ly8gTkI6IE5vIHJlbGF0ZWRUYXJnZXQgaWYgdGhlIG1vdXNlIGxlZnQvZW50ZXJlZCB0aGUgYnJvd3NlciB3aW5kb3dcblx0XHRcdGlmICggIXJlbGF0ZWQgfHwgKCByZWxhdGVkICE9PSB0YXJnZXQgJiYgIWpRdWVyeS5jb250YWlucyggdGFyZ2V0LCByZWxhdGVkICkgKSApIHtcblx0XHRcdFx0ZXZlbnQudHlwZSA9IGhhbmRsZU9iai5vcmlnVHlwZTtcblx0XHRcdFx0cmV0ID0gaGFuZGxlT2JqLmhhbmRsZXIuYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApO1xuXHRcdFx0XHRldmVudC50eXBlID0gZml4O1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHJldDtcblx0XHR9XG5cdH07XG59ICk7XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblxuXHRvbjogZnVuY3Rpb24oIHR5cGVzLCBzZWxlY3RvciwgZGF0YSwgZm4gKSB7XG5cdFx0cmV0dXJuIG9uKCB0aGlzLCB0eXBlcywgc2VsZWN0b3IsIGRhdGEsIGZuICk7XG5cdH0sXG5cdG9uZTogZnVuY3Rpb24oIHR5cGVzLCBzZWxlY3RvciwgZGF0YSwgZm4gKSB7XG5cdFx0cmV0dXJuIG9uKCB0aGlzLCB0eXBlcywgc2VsZWN0b3IsIGRhdGEsIGZuLCAxICk7XG5cdH0sXG5cdG9mZjogZnVuY3Rpb24oIHR5cGVzLCBzZWxlY3RvciwgZm4gKSB7XG5cdFx0dmFyIGhhbmRsZU9iaiwgdHlwZTtcblx0XHRpZiAoIHR5cGVzICYmIHR5cGVzLnByZXZlbnREZWZhdWx0ICYmIHR5cGVzLmhhbmRsZU9iaiApIHtcblxuXHRcdFx0Ly8gKCBldmVudCApICBkaXNwYXRjaGVkIGpRdWVyeS5FdmVudFxuXHRcdFx0aGFuZGxlT2JqID0gdHlwZXMuaGFuZGxlT2JqO1xuXHRcdFx0alF1ZXJ5KCB0eXBlcy5kZWxlZ2F0ZVRhcmdldCApLm9mZihcblx0XHRcdFx0aGFuZGxlT2JqLm5hbWVzcGFjZSA/XG5cdFx0XHRcdFx0aGFuZGxlT2JqLm9yaWdUeXBlICsgXCIuXCIgKyBoYW5kbGVPYmoubmFtZXNwYWNlIDpcblx0XHRcdFx0XHRoYW5kbGVPYmoub3JpZ1R5cGUsXG5cdFx0XHRcdGhhbmRsZU9iai5zZWxlY3Rvcixcblx0XHRcdFx0aGFuZGxlT2JqLmhhbmRsZXJcblx0XHRcdCk7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cdFx0aWYgKCB0eXBlb2YgdHlwZXMgPT09IFwib2JqZWN0XCIgKSB7XG5cblx0XHRcdC8vICggdHlwZXMtb2JqZWN0IFssIHNlbGVjdG9yXSApXG5cdFx0XHRmb3IgKCB0eXBlIGluIHR5cGVzICkge1xuXHRcdFx0XHR0aGlzLm9mZiggdHlwZSwgc2VsZWN0b3IsIHR5cGVzWyB0eXBlIF0gKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblx0XHRpZiAoIHNlbGVjdG9yID09PSBmYWxzZSB8fCB0eXBlb2Ygc2VsZWN0b3IgPT09IFwiZnVuY3Rpb25cIiApIHtcblxuXHRcdFx0Ly8gKCB0eXBlcyBbLCBmbl0gKVxuXHRcdFx0Zm4gPSBzZWxlY3Rvcjtcblx0XHRcdHNlbGVjdG9yID0gdW5kZWZpbmVkO1xuXHRcdH1cblx0XHRpZiAoIGZuID09PSBmYWxzZSApIHtcblx0XHRcdGZuID0gcmV0dXJuRmFsc2U7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0alF1ZXJ5LmV2ZW50LnJlbW92ZSggdGhpcywgdHlwZXMsIGZuLCBzZWxlY3RvciApO1xuXHRcdH0gKTtcblx0fVxufSApO1xuXG5cbnZhclxuXG5cdC8vIFN1cHBvcnQ6IElFIDw9MTAgLSAxMSwgRWRnZSAxMiAtIDEzIG9ubHlcblx0Ly8gSW4gSUUvRWRnZSB1c2luZyByZWdleCBncm91cHMgaGVyZSBjYXVzZXMgc2V2ZXJlIHNsb3dkb3ducy5cblx0Ly8gU2VlIGh0dHBzOi8vY29ubmVjdC5taWNyb3NvZnQuY29tL0lFL2ZlZWRiYWNrL2RldGFpbHMvMTczNjUxMi9cblx0cm5vSW5uZXJodG1sID0gLzxzY3JpcHR8PHN0eWxlfDxsaW5rL2ksXG5cblx0Ly8gY2hlY2tlZD1cImNoZWNrZWRcIiBvciBjaGVja2VkXG5cdHJjaGVja2VkID0gL2NoZWNrZWRcXHMqKD86W149XXw9XFxzKi5jaGVja2VkLikvaSxcblx0cmNsZWFuU2NyaXB0ID0gL15cXHMqPCEoPzpcXFtDREFUQVxcW3wtLSl8KD86XFxdXFxdfC0tKT5cXHMqJC9nO1xuXG4vLyBQcmVmZXIgYSB0Ym9keSBvdmVyIGl0cyBwYXJlbnQgdGFibGUgZm9yIGNvbnRhaW5pbmcgbmV3IHJvd3NcbmZ1bmN0aW9uIG1hbmlwdWxhdGlvblRhcmdldCggZWxlbSwgY29udGVudCApIHtcblx0aWYgKCBub2RlTmFtZSggZWxlbSwgXCJ0YWJsZVwiICkgJiZcblx0XHRub2RlTmFtZSggY29udGVudC5ub2RlVHlwZSAhPT0gMTEgPyBjb250ZW50IDogY29udGVudC5maXJzdENoaWxkLCBcInRyXCIgKSApIHtcblxuXHRcdHJldHVybiBqUXVlcnkoIGVsZW0gKS5jaGlsZHJlbiggXCJ0Ym9keVwiIClbIDAgXSB8fCBlbGVtO1xuXHR9XG5cblx0cmV0dXJuIGVsZW07XG59XG5cbi8vIFJlcGxhY2UvcmVzdG9yZSB0aGUgdHlwZSBhdHRyaWJ1dGUgb2Ygc2NyaXB0IGVsZW1lbnRzIGZvciBzYWZlIERPTSBtYW5pcHVsYXRpb25cbmZ1bmN0aW9uIGRpc2FibGVTY3JpcHQoIGVsZW0gKSB7XG5cdGVsZW0udHlwZSA9ICggZWxlbS5nZXRBdHRyaWJ1dGUoIFwidHlwZVwiICkgIT09IG51bGwgKSArIFwiL1wiICsgZWxlbS50eXBlO1xuXHRyZXR1cm4gZWxlbTtcbn1cbmZ1bmN0aW9uIHJlc3RvcmVTY3JpcHQoIGVsZW0gKSB7XG5cdGlmICggKCBlbGVtLnR5cGUgfHwgXCJcIiApLnNsaWNlKCAwLCA1ICkgPT09IFwidHJ1ZS9cIiApIHtcblx0XHRlbGVtLnR5cGUgPSBlbGVtLnR5cGUuc2xpY2UoIDUgKTtcblx0fSBlbHNlIHtcblx0XHRlbGVtLnJlbW92ZUF0dHJpYnV0ZSggXCJ0eXBlXCIgKTtcblx0fVxuXG5cdHJldHVybiBlbGVtO1xufVxuXG5mdW5jdGlvbiBjbG9uZUNvcHlFdmVudCggc3JjLCBkZXN0ICkge1xuXHR2YXIgaSwgbCwgdHlwZSwgcGRhdGFPbGQsIHVkYXRhT2xkLCB1ZGF0YUN1ciwgZXZlbnRzO1xuXG5cdGlmICggZGVzdC5ub2RlVHlwZSAhPT0gMSApIHtcblx0XHRyZXR1cm47XG5cdH1cblxuXHQvLyAxLiBDb3B5IHByaXZhdGUgZGF0YTogZXZlbnRzLCBoYW5kbGVycywgZXRjLlxuXHRpZiAoIGRhdGFQcml2Lmhhc0RhdGEoIHNyYyApICkge1xuXHRcdHBkYXRhT2xkID0gZGF0YVByaXYuZ2V0KCBzcmMgKTtcblx0XHRldmVudHMgPSBwZGF0YU9sZC5ldmVudHM7XG5cblx0XHRpZiAoIGV2ZW50cyApIHtcblx0XHRcdGRhdGFQcml2LnJlbW92ZSggZGVzdCwgXCJoYW5kbGUgZXZlbnRzXCIgKTtcblxuXHRcdFx0Zm9yICggdHlwZSBpbiBldmVudHMgKSB7XG5cdFx0XHRcdGZvciAoIGkgPSAwLCBsID0gZXZlbnRzWyB0eXBlIF0ubGVuZ3RoOyBpIDwgbDsgaSsrICkge1xuXHRcdFx0XHRcdGpRdWVyeS5ldmVudC5hZGQoIGRlc3QsIHR5cGUsIGV2ZW50c1sgdHlwZSBdWyBpIF0gKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8vIDIuIENvcHkgdXNlciBkYXRhXG5cdGlmICggZGF0YVVzZXIuaGFzRGF0YSggc3JjICkgKSB7XG5cdFx0dWRhdGFPbGQgPSBkYXRhVXNlci5hY2Nlc3MoIHNyYyApO1xuXHRcdHVkYXRhQ3VyID0galF1ZXJ5LmV4dGVuZCgge30sIHVkYXRhT2xkICk7XG5cblx0XHRkYXRhVXNlci5zZXQoIGRlc3QsIHVkYXRhQ3VyICk7XG5cdH1cbn1cblxuLy8gRml4IElFIGJ1Z3MsIHNlZSBzdXBwb3J0IHRlc3RzXG5mdW5jdGlvbiBmaXhJbnB1dCggc3JjLCBkZXN0ICkge1xuXHR2YXIgbm9kZU5hbWUgPSBkZXN0Lm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG5cblx0Ly8gRmFpbHMgdG8gcGVyc2lzdCB0aGUgY2hlY2tlZCBzdGF0ZSBvZiBhIGNsb25lZCBjaGVja2JveCBvciByYWRpbyBidXR0b24uXG5cdGlmICggbm9kZU5hbWUgPT09IFwiaW5wdXRcIiAmJiByY2hlY2thYmxlVHlwZS50ZXN0KCBzcmMudHlwZSApICkge1xuXHRcdGRlc3QuY2hlY2tlZCA9IHNyYy5jaGVja2VkO1xuXG5cdC8vIEZhaWxzIHRvIHJldHVybiB0aGUgc2VsZWN0ZWQgb3B0aW9uIHRvIHRoZSBkZWZhdWx0IHNlbGVjdGVkIHN0YXRlIHdoZW4gY2xvbmluZyBvcHRpb25zXG5cdH0gZWxzZSBpZiAoIG5vZGVOYW1lID09PSBcImlucHV0XCIgfHwgbm9kZU5hbWUgPT09IFwidGV4dGFyZWFcIiApIHtcblx0XHRkZXN0LmRlZmF1bHRWYWx1ZSA9IHNyYy5kZWZhdWx0VmFsdWU7XG5cdH1cbn1cblxuZnVuY3Rpb24gZG9tTWFuaXAoIGNvbGxlY3Rpb24sIGFyZ3MsIGNhbGxiYWNrLCBpZ25vcmVkICkge1xuXG5cdC8vIEZsYXR0ZW4gYW55IG5lc3RlZCBhcnJheXNcblx0YXJncyA9IGZsYXQoIGFyZ3MgKTtcblxuXHR2YXIgZnJhZ21lbnQsIGZpcnN0LCBzY3JpcHRzLCBoYXNTY3JpcHRzLCBub2RlLCBkb2MsXG5cdFx0aSA9IDAsXG5cdFx0bCA9IGNvbGxlY3Rpb24ubGVuZ3RoLFxuXHRcdGlOb0Nsb25lID0gbCAtIDEsXG5cdFx0dmFsdWUgPSBhcmdzWyAwIF0sXG5cdFx0dmFsdWVJc0Z1bmN0aW9uID0gaXNGdW5jdGlvbiggdmFsdWUgKTtcblxuXHQvLyBXZSBjYW4ndCBjbG9uZU5vZGUgZnJhZ21lbnRzIHRoYXQgY29udGFpbiBjaGVja2VkLCBpbiBXZWJLaXRcblx0aWYgKCB2YWx1ZUlzRnVuY3Rpb24gfHxcblx0XHRcdCggbCA+IDEgJiYgdHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiICYmXG5cdFx0XHRcdCFzdXBwb3J0LmNoZWNrQ2xvbmUgJiYgcmNoZWNrZWQudGVzdCggdmFsdWUgKSApICkge1xuXHRcdHJldHVybiBjb2xsZWN0aW9uLmVhY2goIGZ1bmN0aW9uKCBpbmRleCApIHtcblx0XHRcdHZhciBzZWxmID0gY29sbGVjdGlvbi5lcSggaW5kZXggKTtcblx0XHRcdGlmICggdmFsdWVJc0Z1bmN0aW9uICkge1xuXHRcdFx0XHRhcmdzWyAwIF0gPSB2YWx1ZS5jYWxsKCB0aGlzLCBpbmRleCwgc2VsZi5odG1sKCkgKTtcblx0XHRcdH1cblx0XHRcdGRvbU1hbmlwKCBzZWxmLCBhcmdzLCBjYWxsYmFjaywgaWdub3JlZCApO1xuXHRcdH0gKTtcblx0fVxuXG5cdGlmICggbCApIHtcblx0XHRmcmFnbWVudCA9IGJ1aWxkRnJhZ21lbnQoIGFyZ3MsIGNvbGxlY3Rpb25bIDAgXS5vd25lckRvY3VtZW50LCBmYWxzZSwgY29sbGVjdGlvbiwgaWdub3JlZCApO1xuXHRcdGZpcnN0ID0gZnJhZ21lbnQuZmlyc3RDaGlsZDtcblxuXHRcdGlmICggZnJhZ21lbnQuY2hpbGROb2Rlcy5sZW5ndGggPT09IDEgKSB7XG5cdFx0XHRmcmFnbWVudCA9IGZpcnN0O1xuXHRcdH1cblxuXHRcdC8vIFJlcXVpcmUgZWl0aGVyIG5ldyBjb250ZW50IG9yIGFuIGludGVyZXN0IGluIGlnbm9yZWQgZWxlbWVudHMgdG8gaW52b2tlIHRoZSBjYWxsYmFja1xuXHRcdGlmICggZmlyc3QgfHwgaWdub3JlZCApIHtcblx0XHRcdHNjcmlwdHMgPSBqUXVlcnkubWFwKCBnZXRBbGwoIGZyYWdtZW50LCBcInNjcmlwdFwiICksIGRpc2FibGVTY3JpcHQgKTtcblx0XHRcdGhhc1NjcmlwdHMgPSBzY3JpcHRzLmxlbmd0aDtcblxuXHRcdFx0Ly8gVXNlIHRoZSBvcmlnaW5hbCBmcmFnbWVudCBmb3IgdGhlIGxhc3QgaXRlbVxuXHRcdFx0Ly8gaW5zdGVhZCBvZiB0aGUgZmlyc3QgYmVjYXVzZSBpdCBjYW4gZW5kIHVwXG5cdFx0XHQvLyBiZWluZyBlbXB0aWVkIGluY29ycmVjdGx5IGluIGNlcnRhaW4gc2l0dWF0aW9ucyAoIzgwNzApLlxuXHRcdFx0Zm9yICggOyBpIDwgbDsgaSsrICkge1xuXHRcdFx0XHRub2RlID0gZnJhZ21lbnQ7XG5cblx0XHRcdFx0aWYgKCBpICE9PSBpTm9DbG9uZSApIHtcblx0XHRcdFx0XHRub2RlID0galF1ZXJ5LmNsb25lKCBub2RlLCB0cnVlLCB0cnVlICk7XG5cblx0XHRcdFx0XHQvLyBLZWVwIHJlZmVyZW5jZXMgdG8gY2xvbmVkIHNjcmlwdHMgZm9yIGxhdGVyIHJlc3RvcmF0aW9uXG5cdFx0XHRcdFx0aWYgKCBoYXNTY3JpcHRzICkge1xuXG5cdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBBbmRyb2lkIDw9NC4wIG9ubHksIFBoYW50b21KUyAxIG9ubHlcblx0XHRcdFx0XHRcdC8vIHB1c2guYXBwbHkoXywgYXJyYXlsaWtlKSB0aHJvd3Mgb24gYW5jaWVudCBXZWJLaXRcblx0XHRcdFx0XHRcdGpRdWVyeS5tZXJnZSggc2NyaXB0cywgZ2V0QWxsKCBub2RlLCBcInNjcmlwdFwiICkgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRjYWxsYmFjay5jYWxsKCBjb2xsZWN0aW9uWyBpIF0sIG5vZGUsIGkgKTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCBoYXNTY3JpcHRzICkge1xuXHRcdFx0XHRkb2MgPSBzY3JpcHRzWyBzY3JpcHRzLmxlbmd0aCAtIDEgXS5vd25lckRvY3VtZW50O1xuXG5cdFx0XHRcdC8vIFJlZW5hYmxlIHNjcmlwdHNcblx0XHRcdFx0alF1ZXJ5Lm1hcCggc2NyaXB0cywgcmVzdG9yZVNjcmlwdCApO1xuXG5cdFx0XHRcdC8vIEV2YWx1YXRlIGV4ZWN1dGFibGUgc2NyaXB0cyBvbiBmaXJzdCBkb2N1bWVudCBpbnNlcnRpb25cblx0XHRcdFx0Zm9yICggaSA9IDA7IGkgPCBoYXNTY3JpcHRzOyBpKysgKSB7XG5cdFx0XHRcdFx0bm9kZSA9IHNjcmlwdHNbIGkgXTtcblx0XHRcdFx0XHRpZiAoIHJzY3JpcHRUeXBlLnRlc3QoIG5vZGUudHlwZSB8fCBcIlwiICkgJiZcblx0XHRcdFx0XHRcdCFkYXRhUHJpdi5hY2Nlc3MoIG5vZGUsIFwiZ2xvYmFsRXZhbFwiICkgJiZcblx0XHRcdFx0XHRcdGpRdWVyeS5jb250YWlucyggZG9jLCBub2RlICkgKSB7XG5cblx0XHRcdFx0XHRcdGlmICggbm9kZS5zcmMgJiYgKCBub2RlLnR5cGUgfHwgXCJcIiApLnRvTG93ZXJDYXNlKCkgICE9PSBcIm1vZHVsZVwiICkge1xuXG5cdFx0XHRcdFx0XHRcdC8vIE9wdGlvbmFsIEFKQVggZGVwZW5kZW5jeSwgYnV0IHdvbid0IHJ1biBzY3JpcHRzIGlmIG5vdCBwcmVzZW50XG5cdFx0XHRcdFx0XHRcdGlmICggalF1ZXJ5Ll9ldmFsVXJsICYmICFub2RlLm5vTW9kdWxlICkge1xuXHRcdFx0XHRcdFx0XHRcdGpRdWVyeS5fZXZhbFVybCggbm9kZS5zcmMsIHtcblx0XHRcdFx0XHRcdFx0XHRcdG5vbmNlOiBub2RlLm5vbmNlIHx8IG5vZGUuZ2V0QXR0cmlidXRlKCBcIm5vbmNlXCIgKVxuXHRcdFx0XHRcdFx0XHRcdH0sIGRvYyApO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRET01FdmFsKCBub2RlLnRleHRDb250ZW50LnJlcGxhY2UoIHJjbGVhblNjcmlwdCwgXCJcIiApLCBub2RlLCBkb2MgKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gY29sbGVjdGlvbjtcbn1cblxuZnVuY3Rpb24gcmVtb3ZlKCBlbGVtLCBzZWxlY3Rvciwga2VlcERhdGEgKSB7XG5cdHZhciBub2RlLFxuXHRcdG5vZGVzID0gc2VsZWN0b3IgPyBqUXVlcnkuZmlsdGVyKCBzZWxlY3RvciwgZWxlbSApIDogZWxlbSxcblx0XHRpID0gMDtcblxuXHRmb3IgKCA7ICggbm9kZSA9IG5vZGVzWyBpIF0gKSAhPSBudWxsOyBpKysgKSB7XG5cdFx0aWYgKCAha2VlcERhdGEgJiYgbm9kZS5ub2RlVHlwZSA9PT0gMSApIHtcblx0XHRcdGpRdWVyeS5jbGVhbkRhdGEoIGdldEFsbCggbm9kZSApICk7XG5cdFx0fVxuXG5cdFx0aWYgKCBub2RlLnBhcmVudE5vZGUgKSB7XG5cdFx0XHRpZiAoIGtlZXBEYXRhICYmIGlzQXR0YWNoZWQoIG5vZGUgKSApIHtcblx0XHRcdFx0c2V0R2xvYmFsRXZhbCggZ2V0QWxsKCBub2RlLCBcInNjcmlwdFwiICkgKTtcblx0XHRcdH1cblx0XHRcdG5vZGUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCggbm9kZSApO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiBlbGVtO1xufVxuXG5qUXVlcnkuZXh0ZW5kKCB7XG5cdGh0bWxQcmVmaWx0ZXI6IGZ1bmN0aW9uKCBodG1sICkge1xuXHRcdHJldHVybiBodG1sO1xuXHR9LFxuXG5cdGNsb25lOiBmdW5jdGlvbiggZWxlbSwgZGF0YUFuZEV2ZW50cywgZGVlcERhdGFBbmRFdmVudHMgKSB7XG5cdFx0dmFyIGksIGwsIHNyY0VsZW1lbnRzLCBkZXN0RWxlbWVudHMsXG5cdFx0XHRjbG9uZSA9IGVsZW0uY2xvbmVOb2RlKCB0cnVlICksXG5cdFx0XHRpblBhZ2UgPSBpc0F0dGFjaGVkKCBlbGVtICk7XG5cblx0XHQvLyBGaXggSUUgY2xvbmluZyBpc3N1ZXNcblx0XHRpZiAoICFzdXBwb3J0Lm5vQ2xvbmVDaGVja2VkICYmICggZWxlbS5ub2RlVHlwZSA9PT0gMSB8fCBlbGVtLm5vZGVUeXBlID09PSAxMSApICYmXG5cdFx0XHRcdCFqUXVlcnkuaXNYTUxEb2MoIGVsZW0gKSApIHtcblxuXHRcdFx0Ly8gV2UgZXNjaGV3IFNpenpsZSBoZXJlIGZvciBwZXJmb3JtYW5jZSByZWFzb25zOiBodHRwczovL2pzcGVyZi5jb20vZ2V0YWxsLXZzLXNpenpsZS8yXG5cdFx0XHRkZXN0RWxlbWVudHMgPSBnZXRBbGwoIGNsb25lICk7XG5cdFx0XHRzcmNFbGVtZW50cyA9IGdldEFsbCggZWxlbSApO1xuXG5cdFx0XHRmb3IgKCBpID0gMCwgbCA9IHNyY0VsZW1lbnRzLmxlbmd0aDsgaSA8IGw7IGkrKyApIHtcblx0XHRcdFx0Zml4SW5wdXQoIHNyY0VsZW1lbnRzWyBpIF0sIGRlc3RFbGVtZW50c1sgaSBdICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gQ29weSB0aGUgZXZlbnRzIGZyb20gdGhlIG9yaWdpbmFsIHRvIHRoZSBjbG9uZVxuXHRcdGlmICggZGF0YUFuZEV2ZW50cyApIHtcblx0XHRcdGlmICggZGVlcERhdGFBbmRFdmVudHMgKSB7XG5cdFx0XHRcdHNyY0VsZW1lbnRzID0gc3JjRWxlbWVudHMgfHwgZ2V0QWxsKCBlbGVtICk7XG5cdFx0XHRcdGRlc3RFbGVtZW50cyA9IGRlc3RFbGVtZW50cyB8fCBnZXRBbGwoIGNsb25lICk7XG5cblx0XHRcdFx0Zm9yICggaSA9IDAsIGwgPSBzcmNFbGVtZW50cy5sZW5ndGg7IGkgPCBsOyBpKysgKSB7XG5cdFx0XHRcdFx0Y2xvbmVDb3B5RXZlbnQoIHNyY0VsZW1lbnRzWyBpIF0sIGRlc3RFbGVtZW50c1sgaSBdICk7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGNsb25lQ29weUV2ZW50KCBlbGVtLCBjbG9uZSApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIFByZXNlcnZlIHNjcmlwdCBldmFsdWF0aW9uIGhpc3Rvcnlcblx0XHRkZXN0RWxlbWVudHMgPSBnZXRBbGwoIGNsb25lLCBcInNjcmlwdFwiICk7XG5cdFx0aWYgKCBkZXN0RWxlbWVudHMubGVuZ3RoID4gMCApIHtcblx0XHRcdHNldEdsb2JhbEV2YWwoIGRlc3RFbGVtZW50cywgIWluUGFnZSAmJiBnZXRBbGwoIGVsZW0sIFwic2NyaXB0XCIgKSApO1xuXHRcdH1cblxuXHRcdC8vIFJldHVybiB0aGUgY2xvbmVkIHNldFxuXHRcdHJldHVybiBjbG9uZTtcblx0fSxcblxuXHRjbGVhbkRhdGE6IGZ1bmN0aW9uKCBlbGVtcyApIHtcblx0XHR2YXIgZGF0YSwgZWxlbSwgdHlwZSxcblx0XHRcdHNwZWNpYWwgPSBqUXVlcnkuZXZlbnQuc3BlY2lhbCxcblx0XHRcdGkgPSAwO1xuXG5cdFx0Zm9yICggOyAoIGVsZW0gPSBlbGVtc1sgaSBdICkgIT09IHVuZGVmaW5lZDsgaSsrICkge1xuXHRcdFx0aWYgKCBhY2NlcHREYXRhKCBlbGVtICkgKSB7XG5cdFx0XHRcdGlmICggKCBkYXRhID0gZWxlbVsgZGF0YVByaXYuZXhwYW5kbyBdICkgKSB7XG5cdFx0XHRcdFx0aWYgKCBkYXRhLmV2ZW50cyApIHtcblx0XHRcdFx0XHRcdGZvciAoIHR5cGUgaW4gZGF0YS5ldmVudHMgKSB7XG5cdFx0XHRcdFx0XHRcdGlmICggc3BlY2lhbFsgdHlwZSBdICkge1xuXHRcdFx0XHRcdFx0XHRcdGpRdWVyeS5ldmVudC5yZW1vdmUoIGVsZW0sIHR5cGUgKTtcblxuXHRcdFx0XHRcdFx0XHQvLyBUaGlzIGlzIGEgc2hvcnRjdXQgdG8gYXZvaWQgalF1ZXJ5LmV2ZW50LnJlbW92ZSdzIG92ZXJoZWFkXG5cdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0alF1ZXJ5LnJlbW92ZUV2ZW50KCBlbGVtLCB0eXBlLCBkYXRhLmhhbmRsZSApO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gU3VwcG9ydDogQ2hyb21lIDw9MzUgLSA0NStcblx0XHRcdFx0XHQvLyBBc3NpZ24gdW5kZWZpbmVkIGluc3RlYWQgb2YgdXNpbmcgZGVsZXRlLCBzZWUgRGF0YSNyZW1vdmVcblx0XHRcdFx0XHRlbGVtWyBkYXRhUHJpdi5leHBhbmRvIF0gPSB1bmRlZmluZWQ7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCBlbGVtWyBkYXRhVXNlci5leHBhbmRvIF0gKSB7XG5cblx0XHRcdFx0XHQvLyBTdXBwb3J0OiBDaHJvbWUgPD0zNSAtIDQ1K1xuXHRcdFx0XHRcdC8vIEFzc2lnbiB1bmRlZmluZWQgaW5zdGVhZCBvZiB1c2luZyBkZWxldGUsIHNlZSBEYXRhI3JlbW92ZVxuXHRcdFx0XHRcdGVsZW1bIGRhdGFVc2VyLmV4cGFuZG8gXSA9IHVuZGVmaW5lZDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxufSApO1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdGRldGFjaDogZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdHJldHVybiByZW1vdmUoIHRoaXMsIHNlbGVjdG9yLCB0cnVlICk7XG5cdH0sXG5cblx0cmVtb3ZlOiBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0cmV0dXJuIHJlbW92ZSggdGhpcywgc2VsZWN0b3IgKTtcblx0fSxcblxuXHR0ZXh0OiBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0cmV0dXJuIGFjY2VzcyggdGhpcywgZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdFx0cmV0dXJuIHZhbHVlID09PSB1bmRlZmluZWQgP1xuXHRcdFx0XHRqUXVlcnkudGV4dCggdGhpcyApIDpcblx0XHRcdFx0dGhpcy5lbXB0eSgpLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdGlmICggdGhpcy5ub2RlVHlwZSA9PT0gMSB8fCB0aGlzLm5vZGVUeXBlID09PSAxMSB8fCB0aGlzLm5vZGVUeXBlID09PSA5ICkge1xuXHRcdFx0XHRcdFx0dGhpcy50ZXh0Q29udGVudCA9IHZhbHVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSApO1xuXHRcdH0sIG51bGwsIHZhbHVlLCBhcmd1bWVudHMubGVuZ3RoICk7XG5cdH0sXG5cblx0YXBwZW5kOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gZG9tTWFuaXAoIHRoaXMsIGFyZ3VtZW50cywgZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRpZiAoIHRoaXMubm9kZVR5cGUgPT09IDEgfHwgdGhpcy5ub2RlVHlwZSA9PT0gMTEgfHwgdGhpcy5ub2RlVHlwZSA9PT0gOSApIHtcblx0XHRcdFx0dmFyIHRhcmdldCA9IG1hbmlwdWxhdGlvblRhcmdldCggdGhpcywgZWxlbSApO1xuXHRcdFx0XHR0YXJnZXQuYXBwZW5kQ2hpbGQoIGVsZW0gKTtcblx0XHRcdH1cblx0XHR9ICk7XG5cdH0sXG5cblx0cHJlcGVuZDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIGRvbU1hbmlwKCB0aGlzLCBhcmd1bWVudHMsIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0aWYgKCB0aGlzLm5vZGVUeXBlID09PSAxIHx8IHRoaXMubm9kZVR5cGUgPT09IDExIHx8IHRoaXMubm9kZVR5cGUgPT09IDkgKSB7XG5cdFx0XHRcdHZhciB0YXJnZXQgPSBtYW5pcHVsYXRpb25UYXJnZXQoIHRoaXMsIGVsZW0gKTtcblx0XHRcdFx0dGFyZ2V0Lmluc2VydEJlZm9yZSggZWxlbSwgdGFyZ2V0LmZpcnN0Q2hpbGQgKTtcblx0XHRcdH1cblx0XHR9ICk7XG5cdH0sXG5cblx0YmVmb3JlOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gZG9tTWFuaXAoIHRoaXMsIGFyZ3VtZW50cywgZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRpZiAoIHRoaXMucGFyZW50Tm9kZSApIHtcblx0XHRcdFx0dGhpcy5wYXJlbnROb2RlLmluc2VydEJlZm9yZSggZWxlbSwgdGhpcyApO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0fSxcblxuXHRhZnRlcjogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIGRvbU1hbmlwKCB0aGlzLCBhcmd1bWVudHMsIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0aWYgKCB0aGlzLnBhcmVudE5vZGUgKSB7XG5cdFx0XHRcdHRoaXMucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoIGVsZW0sIHRoaXMubmV4dFNpYmxpbmcgKTtcblx0XHRcdH1cblx0XHR9ICk7XG5cdH0sXG5cblx0ZW1wdHk6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBlbGVtLFxuXHRcdFx0aSA9IDA7XG5cblx0XHRmb3IgKCA7ICggZWxlbSA9IHRoaXNbIGkgXSApICE9IG51bGw7IGkrKyApIHtcblx0XHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSApIHtcblxuXHRcdFx0XHQvLyBQcmV2ZW50IG1lbW9yeSBsZWFrc1xuXHRcdFx0XHRqUXVlcnkuY2xlYW5EYXRhKCBnZXRBbGwoIGVsZW0sIGZhbHNlICkgKTtcblxuXHRcdFx0XHQvLyBSZW1vdmUgYW55IHJlbWFpbmluZyBub2Rlc1xuXHRcdFx0XHRlbGVtLnRleHRDb250ZW50ID0gXCJcIjtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRjbG9uZTogZnVuY3Rpb24oIGRhdGFBbmRFdmVudHMsIGRlZXBEYXRhQW5kRXZlbnRzICkge1xuXHRcdGRhdGFBbmRFdmVudHMgPSBkYXRhQW5kRXZlbnRzID09IG51bGwgPyBmYWxzZSA6IGRhdGFBbmRFdmVudHM7XG5cdFx0ZGVlcERhdGFBbmRFdmVudHMgPSBkZWVwRGF0YUFuZEV2ZW50cyA9PSBudWxsID8gZGF0YUFuZEV2ZW50cyA6IGRlZXBEYXRhQW5kRXZlbnRzO1xuXG5cdFx0cmV0dXJuIHRoaXMubWFwKCBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiBqUXVlcnkuY2xvbmUoIHRoaXMsIGRhdGFBbmRFdmVudHMsIGRlZXBEYXRhQW5kRXZlbnRzICk7XG5cdFx0fSApO1xuXHR9LFxuXG5cdGh0bWw6IGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHRyZXR1cm4gYWNjZXNzKCB0aGlzLCBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0XHR2YXIgZWxlbSA9IHRoaXNbIDAgXSB8fCB7fSxcblx0XHRcdFx0aSA9IDAsXG5cdFx0XHRcdGwgPSB0aGlzLmxlbmd0aDtcblxuXHRcdFx0aWYgKCB2YWx1ZSA9PT0gdW5kZWZpbmVkICYmIGVsZW0ubm9kZVR5cGUgPT09IDEgKSB7XG5cdFx0XHRcdHJldHVybiBlbGVtLmlubmVySFRNTDtcblx0XHRcdH1cblxuXHRcdFx0Ly8gU2VlIGlmIHdlIGNhbiB0YWtlIGEgc2hvcnRjdXQgYW5kIGp1c3QgdXNlIGlubmVySFRNTFxuXHRcdFx0aWYgKCB0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgJiYgIXJub0lubmVyaHRtbC50ZXN0KCB2YWx1ZSApICYmXG5cdFx0XHRcdCF3cmFwTWFwWyAoIHJ0YWdOYW1lLmV4ZWMoIHZhbHVlICkgfHwgWyBcIlwiLCBcIlwiIF0gKVsgMSBdLnRvTG93ZXJDYXNlKCkgXSApIHtcblxuXHRcdFx0XHR2YWx1ZSA9IGpRdWVyeS5odG1sUHJlZmlsdGVyKCB2YWx1ZSApO1xuXG5cdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0Zm9yICggOyBpIDwgbDsgaSsrICkge1xuXHRcdFx0XHRcdFx0ZWxlbSA9IHRoaXNbIGkgXSB8fCB7fTtcblxuXHRcdFx0XHRcdFx0Ly8gUmVtb3ZlIGVsZW1lbnQgbm9kZXMgYW5kIHByZXZlbnQgbWVtb3J5IGxlYWtzXG5cdFx0XHRcdFx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDEgKSB7XG5cdFx0XHRcdFx0XHRcdGpRdWVyeS5jbGVhbkRhdGEoIGdldEFsbCggZWxlbSwgZmFsc2UgKSApO1xuXHRcdFx0XHRcdFx0XHRlbGVtLmlubmVySFRNTCA9IHZhbHVlO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGVsZW0gPSAwO1xuXG5cdFx0XHRcdC8vIElmIHVzaW5nIGlubmVySFRNTCB0aHJvd3MgYW4gZXhjZXB0aW9uLCB1c2UgdGhlIGZhbGxiYWNrIG1ldGhvZFxuXHRcdFx0XHR9IGNhdGNoICggZSApIHt9XG5cdFx0XHR9XG5cblx0XHRcdGlmICggZWxlbSApIHtcblx0XHRcdFx0dGhpcy5lbXB0eSgpLmFwcGVuZCggdmFsdWUgKTtcblx0XHRcdH1cblx0XHR9LCBudWxsLCB2YWx1ZSwgYXJndW1lbnRzLmxlbmd0aCApO1xuXHR9LFxuXG5cdHJlcGxhY2VXaXRoOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgaWdub3JlZCA9IFtdO1xuXG5cdFx0Ly8gTWFrZSB0aGUgY2hhbmdlcywgcmVwbGFjaW5nIGVhY2ggbm9uLWlnbm9yZWQgY29udGV4dCBlbGVtZW50IHdpdGggdGhlIG5ldyBjb250ZW50XG5cdFx0cmV0dXJuIGRvbU1hbmlwKCB0aGlzLCBhcmd1bWVudHMsIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0dmFyIHBhcmVudCA9IHRoaXMucGFyZW50Tm9kZTtcblxuXHRcdFx0aWYgKCBqUXVlcnkuaW5BcnJheSggdGhpcywgaWdub3JlZCApIDwgMCApIHtcblx0XHRcdFx0alF1ZXJ5LmNsZWFuRGF0YSggZ2V0QWxsKCB0aGlzICkgKTtcblx0XHRcdFx0aWYgKCBwYXJlbnQgKSB7XG5cdFx0XHRcdFx0cGFyZW50LnJlcGxhY2VDaGlsZCggZWxlbSwgdGhpcyApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHQvLyBGb3JjZSBjYWxsYmFjayBpbnZvY2F0aW9uXG5cdFx0fSwgaWdub3JlZCApO1xuXHR9XG59ICk7XG5cbmpRdWVyeS5lYWNoKCB7XG5cdGFwcGVuZFRvOiBcImFwcGVuZFwiLFxuXHRwcmVwZW5kVG86IFwicHJlcGVuZFwiLFxuXHRpbnNlcnRCZWZvcmU6IFwiYmVmb3JlXCIsXG5cdGluc2VydEFmdGVyOiBcImFmdGVyXCIsXG5cdHJlcGxhY2VBbGw6IFwicmVwbGFjZVdpdGhcIlxufSwgZnVuY3Rpb24oIG5hbWUsIG9yaWdpbmFsICkge1xuXHRqUXVlcnkuZm5bIG5hbWUgXSA9IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHR2YXIgZWxlbXMsXG5cdFx0XHRyZXQgPSBbXSxcblx0XHRcdGluc2VydCA9IGpRdWVyeSggc2VsZWN0b3IgKSxcblx0XHRcdGxhc3QgPSBpbnNlcnQubGVuZ3RoIC0gMSxcblx0XHRcdGkgPSAwO1xuXG5cdFx0Zm9yICggOyBpIDw9IGxhc3Q7IGkrKyApIHtcblx0XHRcdGVsZW1zID0gaSA9PT0gbGFzdCA/IHRoaXMgOiB0aGlzLmNsb25lKCB0cnVlICk7XG5cdFx0XHRqUXVlcnkoIGluc2VydFsgaSBdIClbIG9yaWdpbmFsIF0oIGVsZW1zICk7XG5cblx0XHRcdC8vIFN1cHBvcnQ6IEFuZHJvaWQgPD00LjAgb25seSwgUGhhbnRvbUpTIDEgb25seVxuXHRcdFx0Ly8gLmdldCgpIGJlY2F1c2UgcHVzaC5hcHBseShfLCBhcnJheWxpa2UpIHRocm93cyBvbiBhbmNpZW50IFdlYktpdFxuXHRcdFx0cHVzaC5hcHBseSggcmV0LCBlbGVtcy5nZXQoKSApO1xuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzLnB1c2hTdGFjayggcmV0ICk7XG5cdH07XG59ICk7XG52YXIgcm51bW5vbnB4ID0gbmV3IFJlZ0V4cCggXCJeKFwiICsgcG51bSArIFwiKSg/IXB4KVthLXolXSskXCIsIFwiaVwiICk7XG5cbnZhciBnZXRTdHlsZXMgPSBmdW5jdGlvbiggZWxlbSApIHtcblxuXHRcdC8vIFN1cHBvcnQ6IElFIDw9MTEgb25seSwgRmlyZWZveCA8PTMwICgjMTUwOTgsICMxNDE1MClcblx0XHQvLyBJRSB0aHJvd3Mgb24gZWxlbWVudHMgY3JlYXRlZCBpbiBwb3B1cHNcblx0XHQvLyBGRiBtZWFud2hpbGUgdGhyb3dzIG9uIGZyYW1lIGVsZW1lbnRzIHRocm91Z2ggXCJkZWZhdWx0Vmlldy5nZXRDb21wdXRlZFN0eWxlXCJcblx0XHR2YXIgdmlldyA9IGVsZW0ub3duZXJEb2N1bWVudC5kZWZhdWx0VmlldztcblxuXHRcdGlmICggIXZpZXcgfHwgIXZpZXcub3BlbmVyICkge1xuXHRcdFx0dmlldyA9IHdpbmRvdztcblx0XHR9XG5cblx0XHRyZXR1cm4gdmlldy5nZXRDb21wdXRlZFN0eWxlKCBlbGVtICk7XG5cdH07XG5cbnZhciBzd2FwID0gZnVuY3Rpb24oIGVsZW0sIG9wdGlvbnMsIGNhbGxiYWNrICkge1xuXHR2YXIgcmV0LCBuYW1lLFxuXHRcdG9sZCA9IHt9O1xuXG5cdC8vIFJlbWVtYmVyIHRoZSBvbGQgdmFsdWVzLCBhbmQgaW5zZXJ0IHRoZSBuZXcgb25lc1xuXHRmb3IgKCBuYW1lIGluIG9wdGlvbnMgKSB7XG5cdFx0b2xkWyBuYW1lIF0gPSBlbGVtLnN0eWxlWyBuYW1lIF07XG5cdFx0ZWxlbS5zdHlsZVsgbmFtZSBdID0gb3B0aW9uc1sgbmFtZSBdO1xuXHR9XG5cblx0cmV0ID0gY2FsbGJhY2suY2FsbCggZWxlbSApO1xuXG5cdC8vIFJldmVydCB0aGUgb2xkIHZhbHVlc1xuXHRmb3IgKCBuYW1lIGluIG9wdGlvbnMgKSB7XG5cdFx0ZWxlbS5zdHlsZVsgbmFtZSBdID0gb2xkWyBuYW1lIF07XG5cdH1cblxuXHRyZXR1cm4gcmV0O1xufTtcblxuXG52YXIgcmJveFN0eWxlID0gbmV3IFJlZ0V4cCggY3NzRXhwYW5kLmpvaW4oIFwifFwiICksIFwiaVwiICk7XG5cblxuXG4oIGZ1bmN0aW9uKCkge1xuXG5cdC8vIEV4ZWN1dGluZyBib3RoIHBpeGVsUG9zaXRpb24gJiBib3hTaXppbmdSZWxpYWJsZSB0ZXN0cyByZXF1aXJlIG9ubHkgb25lIGxheW91dFxuXHQvLyBzbyB0aGV5J3JlIGV4ZWN1dGVkIGF0IHRoZSBzYW1lIHRpbWUgdG8gc2F2ZSB0aGUgc2Vjb25kIGNvbXB1dGF0aW9uLlxuXHRmdW5jdGlvbiBjb21wdXRlU3R5bGVUZXN0cygpIHtcblxuXHRcdC8vIFRoaXMgaXMgYSBzaW5nbGV0b24sIHdlIG5lZWQgdG8gZXhlY3V0ZSBpdCBvbmx5IG9uY2Vcblx0XHRpZiAoICFkaXYgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Y29udGFpbmVyLnN0eWxlLmNzc1RleHQgPSBcInBvc2l0aW9uOmFic29sdXRlO2xlZnQ6LTExMTExcHg7d2lkdGg6NjBweDtcIiArXG5cdFx0XHRcIm1hcmdpbi10b3A6MXB4O3BhZGRpbmc6MDtib3JkZXI6MFwiO1xuXHRcdGRpdi5zdHlsZS5jc3NUZXh0ID1cblx0XHRcdFwicG9zaXRpb246cmVsYXRpdmU7ZGlzcGxheTpibG9jaztib3gtc2l6aW5nOmJvcmRlci1ib3g7b3ZlcmZsb3c6c2Nyb2xsO1wiICtcblx0XHRcdFwibWFyZ2luOmF1dG87Ym9yZGVyOjFweDtwYWRkaW5nOjFweDtcIiArXG5cdFx0XHRcIndpZHRoOjYwJTt0b3A6MSVcIjtcblx0XHRkb2N1bWVudEVsZW1lbnQuYXBwZW5kQ2hpbGQoIGNvbnRhaW5lciApLmFwcGVuZENoaWxkKCBkaXYgKTtcblxuXHRcdHZhciBkaXZTdHlsZSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKCBkaXYgKTtcblx0XHRwaXhlbFBvc2l0aW9uVmFsID0gZGl2U3R5bGUudG9wICE9PSBcIjElXCI7XG5cblx0XHQvLyBTdXBwb3J0OiBBbmRyb2lkIDQuMCAtIDQuMyBvbmx5LCBGaXJlZm94IDw9MyAtIDQ0XG5cdFx0cmVsaWFibGVNYXJnaW5MZWZ0VmFsID0gcm91bmRQaXhlbE1lYXN1cmVzKCBkaXZTdHlsZS5tYXJnaW5MZWZ0ICkgPT09IDEyO1xuXG5cdFx0Ly8gU3VwcG9ydDogQW5kcm9pZCA0LjAgLSA0LjMgb25seSwgU2FmYXJpIDw9OS4xIC0gMTAuMSwgaU9TIDw9Ny4wIC0gOS4zXG5cdFx0Ly8gU29tZSBzdHlsZXMgY29tZSBiYWNrIHdpdGggcGVyY2VudGFnZSB2YWx1ZXMsIGV2ZW4gdGhvdWdoIHRoZXkgc2hvdWxkbid0XG5cdFx0ZGl2LnN0eWxlLnJpZ2h0ID0gXCI2MCVcIjtcblx0XHRwaXhlbEJveFN0eWxlc1ZhbCA9IHJvdW5kUGl4ZWxNZWFzdXJlcyggZGl2U3R5bGUucmlnaHQgKSA9PT0gMzY7XG5cblx0XHQvLyBTdXBwb3J0OiBJRSA5IC0gMTEgb25seVxuXHRcdC8vIERldGVjdCBtaXNyZXBvcnRpbmcgb2YgY29udGVudCBkaW1lbnNpb25zIGZvciBib3gtc2l6aW5nOmJvcmRlci1ib3ggZWxlbWVudHNcblx0XHRib3hTaXppbmdSZWxpYWJsZVZhbCA9IHJvdW5kUGl4ZWxNZWFzdXJlcyggZGl2U3R5bGUud2lkdGggKSA9PT0gMzY7XG5cblx0XHQvLyBTdXBwb3J0OiBJRSA5IG9ubHlcblx0XHQvLyBEZXRlY3Qgb3ZlcmZsb3c6c2Nyb2xsIHNjcmV3aW5lc3MgKGdoLTM2OTkpXG5cdFx0Ly8gU3VwcG9ydDogQ2hyb21lIDw9NjRcblx0XHQvLyBEb24ndCBnZXQgdHJpY2tlZCB3aGVuIHpvb20gYWZmZWN0cyBvZmZzZXRXaWR0aCAoZ2gtNDAyOSlcblx0XHRkaXYuc3R5bGUucG9zaXRpb24gPSBcImFic29sdXRlXCI7XG5cdFx0c2Nyb2xsYm94U2l6ZVZhbCA9IHJvdW5kUGl4ZWxNZWFzdXJlcyggZGl2Lm9mZnNldFdpZHRoIC8gMyApID09PSAxMjtcblxuXHRcdGRvY3VtZW50RWxlbWVudC5yZW1vdmVDaGlsZCggY29udGFpbmVyICk7XG5cblx0XHQvLyBOdWxsaWZ5IHRoZSBkaXYgc28gaXQgd291bGRuJ3QgYmUgc3RvcmVkIGluIHRoZSBtZW1vcnkgYW5kXG5cdFx0Ly8gaXQgd2lsbCBhbHNvIGJlIGEgc2lnbiB0aGF0IGNoZWNrcyBhbHJlYWR5IHBlcmZvcm1lZFxuXHRcdGRpdiA9IG51bGw7XG5cdH1cblxuXHRmdW5jdGlvbiByb3VuZFBpeGVsTWVhc3VyZXMoIG1lYXN1cmUgKSB7XG5cdFx0cmV0dXJuIE1hdGgucm91bmQoIHBhcnNlRmxvYXQoIG1lYXN1cmUgKSApO1xuXHR9XG5cblx0dmFyIHBpeGVsUG9zaXRpb25WYWwsIGJveFNpemluZ1JlbGlhYmxlVmFsLCBzY3JvbGxib3hTaXplVmFsLCBwaXhlbEJveFN0eWxlc1ZhbCxcblx0XHRyZWxpYWJsZVRyRGltZW5zaW9uc1ZhbCwgcmVsaWFibGVNYXJnaW5MZWZ0VmFsLFxuXHRcdGNvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiZGl2XCIgKSxcblx0XHRkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImRpdlwiICk7XG5cblx0Ly8gRmluaXNoIGVhcmx5IGluIGxpbWl0ZWQgKG5vbi1icm93c2VyKSBlbnZpcm9ubWVudHNcblx0aWYgKCAhZGl2LnN0eWxlICkge1xuXHRcdHJldHVybjtcblx0fVxuXG5cdC8vIFN1cHBvcnQ6IElFIDw9OSAtIDExIG9ubHlcblx0Ly8gU3R5bGUgb2YgY2xvbmVkIGVsZW1lbnQgYWZmZWN0cyBzb3VyY2UgZWxlbWVudCBjbG9uZWQgKCM4OTA4KVxuXHRkaXYuc3R5bGUuYmFja2dyb3VuZENsaXAgPSBcImNvbnRlbnQtYm94XCI7XG5cdGRpdi5jbG9uZU5vZGUoIHRydWUgKS5zdHlsZS5iYWNrZ3JvdW5kQ2xpcCA9IFwiXCI7XG5cdHN1cHBvcnQuY2xlYXJDbG9uZVN0eWxlID0gZGl2LnN0eWxlLmJhY2tncm91bmRDbGlwID09PSBcImNvbnRlbnQtYm94XCI7XG5cblx0alF1ZXJ5LmV4dGVuZCggc3VwcG9ydCwge1xuXHRcdGJveFNpemluZ1JlbGlhYmxlOiBmdW5jdGlvbigpIHtcblx0XHRcdGNvbXB1dGVTdHlsZVRlc3RzKCk7XG5cdFx0XHRyZXR1cm4gYm94U2l6aW5nUmVsaWFibGVWYWw7XG5cdFx0fSxcblx0XHRwaXhlbEJveFN0eWxlczogZnVuY3Rpb24oKSB7XG5cdFx0XHRjb21wdXRlU3R5bGVUZXN0cygpO1xuXHRcdFx0cmV0dXJuIHBpeGVsQm94U3R5bGVzVmFsO1xuXHRcdH0sXG5cdFx0cGl4ZWxQb3NpdGlvbjogZnVuY3Rpb24oKSB7XG5cdFx0XHRjb21wdXRlU3R5bGVUZXN0cygpO1xuXHRcdFx0cmV0dXJuIHBpeGVsUG9zaXRpb25WYWw7XG5cdFx0fSxcblx0XHRyZWxpYWJsZU1hcmdpbkxlZnQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0Y29tcHV0ZVN0eWxlVGVzdHMoKTtcblx0XHRcdHJldHVybiByZWxpYWJsZU1hcmdpbkxlZnRWYWw7XG5cdFx0fSxcblx0XHRzY3JvbGxib3hTaXplOiBmdW5jdGlvbigpIHtcblx0XHRcdGNvbXB1dGVTdHlsZVRlc3RzKCk7XG5cdFx0XHRyZXR1cm4gc2Nyb2xsYm94U2l6ZVZhbDtcblx0XHR9LFxuXG5cdFx0Ly8gU3VwcG9ydDogSUUgOSAtIDExKywgRWRnZSAxNSAtIDE4K1xuXHRcdC8vIElFL0VkZ2UgbWlzcmVwb3J0IGBnZXRDb21wdXRlZFN0eWxlYCBvZiB0YWJsZSByb3dzIHdpdGggd2lkdGgvaGVpZ2h0XG5cdFx0Ly8gc2V0IGluIENTUyB3aGlsZSBgb2Zmc2V0KmAgcHJvcGVydGllcyByZXBvcnQgY29ycmVjdCB2YWx1ZXMuXG5cdFx0Ly8gQmVoYXZpb3IgaW4gSUUgOSBpcyBtb3JlIHN1YnRsZSB0aGFuIGluIG5ld2VyIHZlcnNpb25zICYgaXQgcGFzc2VzXG5cdFx0Ly8gc29tZSB2ZXJzaW9ucyBvZiB0aGlzIHRlc3Q7IG1ha2Ugc3VyZSBub3QgdG8gbWFrZSBpdCBwYXNzIHRoZXJlIVxuXHRcdC8vXG5cdFx0Ly8gU3VwcG9ydDogRmlyZWZveCA3MCtcblx0XHQvLyBPbmx5IEZpcmVmb3ggaW5jbHVkZXMgYm9yZGVyIHdpZHRoc1xuXHRcdC8vIGluIGNvbXB1dGVkIGRpbWVuc2lvbnMuIChnaC00NTI5KVxuXHRcdHJlbGlhYmxlVHJEaW1lbnNpb25zOiBmdW5jdGlvbigpIHtcblx0XHRcdHZhciB0YWJsZSwgdHIsIHRyQ2hpbGQsIHRyU3R5bGU7XG5cdFx0XHRpZiAoIHJlbGlhYmxlVHJEaW1lbnNpb25zVmFsID09IG51bGwgKSB7XG5cdFx0XHRcdHRhYmxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJ0YWJsZVwiICk7XG5cdFx0XHRcdHRyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJ0clwiICk7XG5cdFx0XHRcdHRyQ2hpbGQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImRpdlwiICk7XG5cblx0XHRcdFx0dGFibGUuc3R5bGUuY3NzVGV4dCA9IFwicG9zaXRpb246YWJzb2x1dGU7bGVmdDotMTExMTFweDtib3JkZXItY29sbGFwc2U6c2VwYXJhdGVcIjtcblx0XHRcdFx0dHIuc3R5bGUuY3NzVGV4dCA9IFwiYm9yZGVyOjFweCBzb2xpZFwiO1xuXG5cdFx0XHRcdC8vIFN1cHBvcnQ6IENocm9tZSA4Nitcblx0XHRcdFx0Ly8gSGVpZ2h0IHNldCB0aHJvdWdoIGNzc1RleHQgZG9lcyBub3QgZ2V0IGFwcGxpZWQuXG5cdFx0XHRcdC8vIENvbXB1dGVkIGhlaWdodCB0aGVuIGNvbWVzIGJhY2sgYXMgMC5cblx0XHRcdFx0dHIuc3R5bGUuaGVpZ2h0ID0gXCIxcHhcIjtcblx0XHRcdFx0dHJDaGlsZC5zdHlsZS5oZWlnaHQgPSBcIjlweFwiO1xuXG5cdFx0XHRcdC8vIFN1cHBvcnQ6IEFuZHJvaWQgOCBDaHJvbWUgODYrXG5cdFx0XHRcdC8vIEluIG91ciBib2R5QmFja2dyb3VuZC5odG1sIGlmcmFtZSxcblx0XHRcdFx0Ly8gZGlzcGxheSBmb3IgYWxsIGRpdiBlbGVtZW50cyBpcyBzZXQgdG8gXCJpbmxpbmVcIixcblx0XHRcdFx0Ly8gd2hpY2ggY2F1c2VzIGEgcHJvYmxlbSBvbmx5IGluIEFuZHJvaWQgOCBDaHJvbWUgODYuXG5cdFx0XHRcdC8vIEVuc3VyaW5nIHRoZSBkaXYgaXMgZGlzcGxheTogYmxvY2tcblx0XHRcdFx0Ly8gZ2V0cyBhcm91bmQgdGhpcyBpc3N1ZS5cblx0XHRcdFx0dHJDaGlsZC5zdHlsZS5kaXNwbGF5ID0gXCJibG9ja1wiO1xuXG5cdFx0XHRcdGRvY3VtZW50RWxlbWVudFxuXHRcdFx0XHRcdC5hcHBlbmRDaGlsZCggdGFibGUgKVxuXHRcdFx0XHRcdC5hcHBlbmRDaGlsZCggdHIgKVxuXHRcdFx0XHRcdC5hcHBlbmRDaGlsZCggdHJDaGlsZCApO1xuXG5cdFx0XHRcdHRyU3R5bGUgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZSggdHIgKTtcblx0XHRcdFx0cmVsaWFibGVUckRpbWVuc2lvbnNWYWwgPSAoIHBhcnNlSW50KCB0clN0eWxlLmhlaWdodCwgMTAgKSArXG5cdFx0XHRcdFx0cGFyc2VJbnQoIHRyU3R5bGUuYm9yZGVyVG9wV2lkdGgsIDEwICkgK1xuXHRcdFx0XHRcdHBhcnNlSW50KCB0clN0eWxlLmJvcmRlckJvdHRvbVdpZHRoLCAxMCApICkgPT09IHRyLm9mZnNldEhlaWdodDtcblxuXHRcdFx0XHRkb2N1bWVudEVsZW1lbnQucmVtb3ZlQ2hpbGQoIHRhYmxlICk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcmVsaWFibGVUckRpbWVuc2lvbnNWYWw7XG5cdFx0fVxuXHR9ICk7XG59ICkoKTtcblxuXG5mdW5jdGlvbiBjdXJDU1MoIGVsZW0sIG5hbWUsIGNvbXB1dGVkICkge1xuXHR2YXIgd2lkdGgsIG1pbldpZHRoLCBtYXhXaWR0aCwgcmV0LFxuXG5cdFx0Ly8gU3VwcG9ydDogRmlyZWZveCA1MStcblx0XHQvLyBSZXRyaWV2aW5nIHN0eWxlIGJlZm9yZSBjb21wdXRlZCBzb21laG93XG5cdFx0Ly8gZml4ZXMgYW4gaXNzdWUgd2l0aCBnZXR0aW5nIHdyb25nIHZhbHVlc1xuXHRcdC8vIG9uIGRldGFjaGVkIGVsZW1lbnRzXG5cdFx0c3R5bGUgPSBlbGVtLnN0eWxlO1xuXG5cdGNvbXB1dGVkID0gY29tcHV0ZWQgfHwgZ2V0U3R5bGVzKCBlbGVtICk7XG5cblx0Ly8gZ2V0UHJvcGVydHlWYWx1ZSBpcyBuZWVkZWQgZm9yOlxuXHQvLyAgIC5jc3MoJ2ZpbHRlcicpIChJRSA5IG9ubHksICMxMjUzNylcblx0Ly8gICAuY3NzKCctLWN1c3RvbVByb3BlcnR5KSAoIzMxNDQpXG5cdGlmICggY29tcHV0ZWQgKSB7XG5cdFx0cmV0ID0gY29tcHV0ZWQuZ2V0UHJvcGVydHlWYWx1ZSggbmFtZSApIHx8IGNvbXB1dGVkWyBuYW1lIF07XG5cblx0XHRpZiAoIHJldCA9PT0gXCJcIiAmJiAhaXNBdHRhY2hlZCggZWxlbSApICkge1xuXHRcdFx0cmV0ID0galF1ZXJ5LnN0eWxlKCBlbGVtLCBuYW1lICk7XG5cdFx0fVxuXG5cdFx0Ly8gQSB0cmlidXRlIHRvIHRoZSBcImF3ZXNvbWUgaGFjayBieSBEZWFuIEVkd2FyZHNcIlxuXHRcdC8vIEFuZHJvaWQgQnJvd3NlciByZXR1cm5zIHBlcmNlbnRhZ2UgZm9yIHNvbWUgdmFsdWVzLFxuXHRcdC8vIGJ1dCB3aWR0aCBzZWVtcyB0byBiZSByZWxpYWJseSBwaXhlbHMuXG5cdFx0Ly8gVGhpcyBpcyBhZ2FpbnN0IHRoZSBDU1NPTSBkcmFmdCBzcGVjOlxuXHRcdC8vIGh0dHBzOi8vZHJhZnRzLmNzc3dnLm9yZy9jc3NvbS8jcmVzb2x2ZWQtdmFsdWVzXG5cdFx0aWYgKCAhc3VwcG9ydC5waXhlbEJveFN0eWxlcygpICYmIHJudW1ub25weC50ZXN0KCByZXQgKSAmJiByYm94U3R5bGUudGVzdCggbmFtZSApICkge1xuXG5cdFx0XHQvLyBSZW1lbWJlciB0aGUgb3JpZ2luYWwgdmFsdWVzXG5cdFx0XHR3aWR0aCA9IHN0eWxlLndpZHRoO1xuXHRcdFx0bWluV2lkdGggPSBzdHlsZS5taW5XaWR0aDtcblx0XHRcdG1heFdpZHRoID0gc3R5bGUubWF4V2lkdGg7XG5cblx0XHRcdC8vIFB1dCBpbiB0aGUgbmV3IHZhbHVlcyB0byBnZXQgYSBjb21wdXRlZCB2YWx1ZSBvdXRcblx0XHRcdHN0eWxlLm1pbldpZHRoID0gc3R5bGUubWF4V2lkdGggPSBzdHlsZS53aWR0aCA9IHJldDtcblx0XHRcdHJldCA9IGNvbXB1dGVkLndpZHRoO1xuXG5cdFx0XHQvLyBSZXZlcnQgdGhlIGNoYW5nZWQgdmFsdWVzXG5cdFx0XHRzdHlsZS53aWR0aCA9IHdpZHRoO1xuXHRcdFx0c3R5bGUubWluV2lkdGggPSBtaW5XaWR0aDtcblx0XHRcdHN0eWxlLm1heFdpZHRoID0gbWF4V2lkdGg7XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIHJldCAhPT0gdW5kZWZpbmVkID9cblxuXHRcdC8vIFN1cHBvcnQ6IElFIDw9OSAtIDExIG9ubHlcblx0XHQvLyBJRSByZXR1cm5zIHpJbmRleCB2YWx1ZSBhcyBhbiBpbnRlZ2VyLlxuXHRcdHJldCArIFwiXCIgOlxuXHRcdHJldDtcbn1cblxuXG5mdW5jdGlvbiBhZGRHZXRIb29rSWYoIGNvbmRpdGlvbkZuLCBob29rRm4gKSB7XG5cblx0Ly8gRGVmaW5lIHRoZSBob29rLCB3ZSdsbCBjaGVjayBvbiB0aGUgZmlyc3QgcnVuIGlmIGl0J3MgcmVhbGx5IG5lZWRlZC5cblx0cmV0dXJuIHtcblx0XHRnZXQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0aWYgKCBjb25kaXRpb25GbigpICkge1xuXG5cdFx0XHRcdC8vIEhvb2sgbm90IG5lZWRlZCAob3IgaXQncyBub3QgcG9zc2libGUgdG8gdXNlIGl0IGR1ZVxuXHRcdFx0XHQvLyB0byBtaXNzaW5nIGRlcGVuZGVuY3kpLCByZW1vdmUgaXQuXG5cdFx0XHRcdGRlbGV0ZSB0aGlzLmdldDtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBIb29rIG5lZWRlZDsgcmVkZWZpbmUgaXQgc28gdGhhdCB0aGUgc3VwcG9ydCB0ZXN0IGlzIG5vdCBleGVjdXRlZCBhZ2Fpbi5cblx0XHRcdHJldHVybiAoIHRoaXMuZ2V0ID0gaG9va0ZuICkuYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApO1xuXHRcdH1cblx0fTtcbn1cblxuXG52YXIgY3NzUHJlZml4ZXMgPSBbIFwiV2Via2l0XCIsIFwiTW96XCIsIFwibXNcIiBdLFxuXHRlbXB0eVN0eWxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJkaXZcIiApLnN0eWxlLFxuXHR2ZW5kb3JQcm9wcyA9IHt9O1xuXG4vLyBSZXR1cm4gYSB2ZW5kb3ItcHJlZml4ZWQgcHJvcGVydHkgb3IgdW5kZWZpbmVkXG5mdW5jdGlvbiB2ZW5kb3JQcm9wTmFtZSggbmFtZSApIHtcblxuXHQvLyBDaGVjayBmb3IgdmVuZG9yIHByZWZpeGVkIG5hbWVzXG5cdHZhciBjYXBOYW1lID0gbmFtZVsgMCBdLnRvVXBwZXJDYXNlKCkgKyBuYW1lLnNsaWNlKCAxICksXG5cdFx0aSA9IGNzc1ByZWZpeGVzLmxlbmd0aDtcblxuXHR3aGlsZSAoIGktLSApIHtcblx0XHRuYW1lID0gY3NzUHJlZml4ZXNbIGkgXSArIGNhcE5hbWU7XG5cdFx0aWYgKCBuYW1lIGluIGVtcHR5U3R5bGUgKSB7XG5cdFx0XHRyZXR1cm4gbmFtZTtcblx0XHR9XG5cdH1cbn1cblxuLy8gUmV0dXJuIGEgcG90ZW50aWFsbHktbWFwcGVkIGpRdWVyeS5jc3NQcm9wcyBvciB2ZW5kb3IgcHJlZml4ZWQgcHJvcGVydHlcbmZ1bmN0aW9uIGZpbmFsUHJvcE5hbWUoIG5hbWUgKSB7XG5cdHZhciBmaW5hbCA9IGpRdWVyeS5jc3NQcm9wc1sgbmFtZSBdIHx8IHZlbmRvclByb3BzWyBuYW1lIF07XG5cblx0aWYgKCBmaW5hbCApIHtcblx0XHRyZXR1cm4gZmluYWw7XG5cdH1cblx0aWYgKCBuYW1lIGluIGVtcHR5U3R5bGUgKSB7XG5cdFx0cmV0dXJuIG5hbWU7XG5cdH1cblx0cmV0dXJuIHZlbmRvclByb3BzWyBuYW1lIF0gPSB2ZW5kb3JQcm9wTmFtZSggbmFtZSApIHx8IG5hbWU7XG59XG5cblxudmFyXG5cblx0Ly8gU3dhcHBhYmxlIGlmIGRpc3BsYXkgaXMgbm9uZSBvciBzdGFydHMgd2l0aCB0YWJsZVxuXHQvLyBleGNlcHQgXCJ0YWJsZVwiLCBcInRhYmxlLWNlbGxcIiwgb3IgXCJ0YWJsZS1jYXB0aW9uXCJcblx0Ly8gU2VlIGhlcmUgZm9yIGRpc3BsYXkgdmFsdWVzOiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL0NTUy9kaXNwbGF5XG5cdHJkaXNwbGF5c3dhcCA9IC9eKG5vbmV8dGFibGUoPyEtY1tlYV0pLispLyxcblx0cmN1c3RvbVByb3AgPSAvXi0tLyxcblx0Y3NzU2hvdyA9IHsgcG9zaXRpb246IFwiYWJzb2x1dGVcIiwgdmlzaWJpbGl0eTogXCJoaWRkZW5cIiwgZGlzcGxheTogXCJibG9ja1wiIH0sXG5cdGNzc05vcm1hbFRyYW5zZm9ybSA9IHtcblx0XHRsZXR0ZXJTcGFjaW5nOiBcIjBcIixcblx0XHRmb250V2VpZ2h0OiBcIjQwMFwiXG5cdH07XG5cbmZ1bmN0aW9uIHNldFBvc2l0aXZlTnVtYmVyKCBfZWxlbSwgdmFsdWUsIHN1YnRyYWN0ICkge1xuXG5cdC8vIEFueSByZWxhdGl2ZSAoKy8tKSB2YWx1ZXMgaGF2ZSBhbHJlYWR5IGJlZW5cblx0Ly8gbm9ybWFsaXplZCBhdCB0aGlzIHBvaW50XG5cdHZhciBtYXRjaGVzID0gcmNzc051bS5leGVjKCB2YWx1ZSApO1xuXHRyZXR1cm4gbWF0Y2hlcyA/XG5cblx0XHQvLyBHdWFyZCBhZ2FpbnN0IHVuZGVmaW5lZCBcInN1YnRyYWN0XCIsIGUuZy4sIHdoZW4gdXNlZCBhcyBpbiBjc3NIb29rc1xuXHRcdE1hdGgubWF4KCAwLCBtYXRjaGVzWyAyIF0gLSAoIHN1YnRyYWN0IHx8IDAgKSApICsgKCBtYXRjaGVzWyAzIF0gfHwgXCJweFwiICkgOlxuXHRcdHZhbHVlO1xufVxuXG5mdW5jdGlvbiBib3hNb2RlbEFkanVzdG1lbnQoIGVsZW0sIGRpbWVuc2lvbiwgYm94LCBpc0JvcmRlckJveCwgc3R5bGVzLCBjb21wdXRlZFZhbCApIHtcblx0dmFyIGkgPSBkaW1lbnNpb24gPT09IFwid2lkdGhcIiA/IDEgOiAwLFxuXHRcdGV4dHJhID0gMCxcblx0XHRkZWx0YSA9IDA7XG5cblx0Ly8gQWRqdXN0bWVudCBtYXkgbm90IGJlIG5lY2Vzc2FyeVxuXHRpZiAoIGJveCA9PT0gKCBpc0JvcmRlckJveCA/IFwiYm9yZGVyXCIgOiBcImNvbnRlbnRcIiApICkge1xuXHRcdHJldHVybiAwO1xuXHR9XG5cblx0Zm9yICggOyBpIDwgNDsgaSArPSAyICkge1xuXG5cdFx0Ly8gQm90aCBib3ggbW9kZWxzIGV4Y2x1ZGUgbWFyZ2luXG5cdFx0aWYgKCBib3ggPT09IFwibWFyZ2luXCIgKSB7XG5cdFx0XHRkZWx0YSArPSBqUXVlcnkuY3NzKCBlbGVtLCBib3ggKyBjc3NFeHBhbmRbIGkgXSwgdHJ1ZSwgc3R5bGVzICk7XG5cdFx0fVxuXG5cdFx0Ly8gSWYgd2UgZ2V0IGhlcmUgd2l0aCBhIGNvbnRlbnQtYm94LCB3ZSdyZSBzZWVraW5nIFwicGFkZGluZ1wiIG9yIFwiYm9yZGVyXCIgb3IgXCJtYXJnaW5cIlxuXHRcdGlmICggIWlzQm9yZGVyQm94ICkge1xuXG5cdFx0XHQvLyBBZGQgcGFkZGluZ1xuXHRcdFx0ZGVsdGEgKz0galF1ZXJ5LmNzcyggZWxlbSwgXCJwYWRkaW5nXCIgKyBjc3NFeHBhbmRbIGkgXSwgdHJ1ZSwgc3R5bGVzICk7XG5cblx0XHRcdC8vIEZvciBcImJvcmRlclwiIG9yIFwibWFyZ2luXCIsIGFkZCBib3JkZXJcblx0XHRcdGlmICggYm94ICE9PSBcInBhZGRpbmdcIiApIHtcblx0XHRcdFx0ZGVsdGEgKz0galF1ZXJ5LmNzcyggZWxlbSwgXCJib3JkZXJcIiArIGNzc0V4cGFuZFsgaSBdICsgXCJXaWR0aFwiLCB0cnVlLCBzdHlsZXMgKTtcblxuXHRcdFx0Ly8gQnV0IHN0aWxsIGtlZXAgdHJhY2sgb2YgaXQgb3RoZXJ3aXNlXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRleHRyYSArPSBqUXVlcnkuY3NzKCBlbGVtLCBcImJvcmRlclwiICsgY3NzRXhwYW5kWyBpIF0gKyBcIldpZHRoXCIsIHRydWUsIHN0eWxlcyApO1xuXHRcdFx0fVxuXG5cdFx0Ly8gSWYgd2UgZ2V0IGhlcmUgd2l0aCBhIGJvcmRlci1ib3ggKGNvbnRlbnQgKyBwYWRkaW5nICsgYm9yZGVyKSwgd2UncmUgc2Vla2luZyBcImNvbnRlbnRcIiBvclxuXHRcdC8vIFwicGFkZGluZ1wiIG9yIFwibWFyZ2luXCJcblx0XHR9IGVsc2Uge1xuXG5cdFx0XHQvLyBGb3IgXCJjb250ZW50XCIsIHN1YnRyYWN0IHBhZGRpbmdcblx0XHRcdGlmICggYm94ID09PSBcImNvbnRlbnRcIiApIHtcblx0XHRcdFx0ZGVsdGEgLT0galF1ZXJ5LmNzcyggZWxlbSwgXCJwYWRkaW5nXCIgKyBjc3NFeHBhbmRbIGkgXSwgdHJ1ZSwgc3R5bGVzICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEZvciBcImNvbnRlbnRcIiBvciBcInBhZGRpbmdcIiwgc3VidHJhY3QgYm9yZGVyXG5cdFx0XHRpZiAoIGJveCAhPT0gXCJtYXJnaW5cIiApIHtcblx0XHRcdFx0ZGVsdGEgLT0galF1ZXJ5LmNzcyggZWxlbSwgXCJib3JkZXJcIiArIGNzc0V4cGFuZFsgaSBdICsgXCJXaWR0aFwiLCB0cnVlLCBzdHlsZXMgKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvLyBBY2NvdW50IGZvciBwb3NpdGl2ZSBjb250ZW50LWJveCBzY3JvbGwgZ3V0dGVyIHdoZW4gcmVxdWVzdGVkIGJ5IHByb3ZpZGluZyBjb21wdXRlZFZhbFxuXHRpZiAoICFpc0JvcmRlckJveCAmJiBjb21wdXRlZFZhbCA+PSAwICkge1xuXG5cdFx0Ly8gb2Zmc2V0V2lkdGgvb2Zmc2V0SGVpZ2h0IGlzIGEgcm91bmRlZCBzdW0gb2YgY29udGVudCwgcGFkZGluZywgc2Nyb2xsIGd1dHRlciwgYW5kIGJvcmRlclxuXHRcdC8vIEFzc3VtaW5nIGludGVnZXIgc2Nyb2xsIGd1dHRlciwgc3VidHJhY3QgdGhlIHJlc3QgYW5kIHJvdW5kIGRvd25cblx0XHRkZWx0YSArPSBNYXRoLm1heCggMCwgTWF0aC5jZWlsKFxuXHRcdFx0ZWxlbVsgXCJvZmZzZXRcIiArIGRpbWVuc2lvblsgMCBdLnRvVXBwZXJDYXNlKCkgKyBkaW1lbnNpb24uc2xpY2UoIDEgKSBdIC1cblx0XHRcdGNvbXB1dGVkVmFsIC1cblx0XHRcdGRlbHRhIC1cblx0XHRcdGV4dHJhIC1cblx0XHRcdDAuNVxuXG5cdFx0Ly8gSWYgb2Zmc2V0V2lkdGgvb2Zmc2V0SGVpZ2h0IGlzIHVua25vd24sIHRoZW4gd2UgY2FuJ3QgZGV0ZXJtaW5lIGNvbnRlbnQtYm94IHNjcm9sbCBndXR0ZXJcblx0XHQvLyBVc2UgYW4gZXhwbGljaXQgemVybyB0byBhdm9pZCBOYU4gKGdoLTM5NjQpXG5cdFx0KSApIHx8IDA7XG5cdH1cblxuXHRyZXR1cm4gZGVsdGE7XG59XG5cbmZ1bmN0aW9uIGdldFdpZHRoT3JIZWlnaHQoIGVsZW0sIGRpbWVuc2lvbiwgZXh0cmEgKSB7XG5cblx0Ly8gU3RhcnQgd2l0aCBjb21wdXRlZCBzdHlsZVxuXHR2YXIgc3R5bGVzID0gZ2V0U3R5bGVzKCBlbGVtICksXG5cblx0XHQvLyBUbyBhdm9pZCBmb3JjaW5nIGEgcmVmbG93LCBvbmx5IGZldGNoIGJveFNpemluZyBpZiB3ZSBuZWVkIGl0IChnaC00MzIyKS5cblx0XHQvLyBGYWtlIGNvbnRlbnQtYm94IHVudGlsIHdlIGtub3cgaXQncyBuZWVkZWQgdG8ga25vdyB0aGUgdHJ1ZSB2YWx1ZS5cblx0XHRib3hTaXppbmdOZWVkZWQgPSAhc3VwcG9ydC5ib3hTaXppbmdSZWxpYWJsZSgpIHx8IGV4dHJhLFxuXHRcdGlzQm9yZGVyQm94ID0gYm94U2l6aW5nTmVlZGVkICYmXG5cdFx0XHRqUXVlcnkuY3NzKCBlbGVtLCBcImJveFNpemluZ1wiLCBmYWxzZSwgc3R5bGVzICkgPT09IFwiYm9yZGVyLWJveFwiLFxuXHRcdHZhbHVlSXNCb3JkZXJCb3ggPSBpc0JvcmRlckJveCxcblxuXHRcdHZhbCA9IGN1ckNTUyggZWxlbSwgZGltZW5zaW9uLCBzdHlsZXMgKSxcblx0XHRvZmZzZXRQcm9wID0gXCJvZmZzZXRcIiArIGRpbWVuc2lvblsgMCBdLnRvVXBwZXJDYXNlKCkgKyBkaW1lbnNpb24uc2xpY2UoIDEgKTtcblxuXHQvLyBTdXBwb3J0OiBGaXJlZm94IDw9NTRcblx0Ly8gUmV0dXJuIGEgY29uZm91bmRpbmcgbm9uLXBpeGVsIHZhbHVlIG9yIGZlaWduIGlnbm9yYW5jZSwgYXMgYXBwcm9wcmlhdGUuXG5cdGlmICggcm51bW5vbnB4LnRlc3QoIHZhbCApICkge1xuXHRcdGlmICggIWV4dHJhICkge1xuXHRcdFx0cmV0dXJuIHZhbDtcblx0XHR9XG5cdFx0dmFsID0gXCJhdXRvXCI7XG5cdH1cblxuXG5cdC8vIFN1cHBvcnQ6IElFIDkgLSAxMSBvbmx5XG5cdC8vIFVzZSBvZmZzZXRXaWR0aC9vZmZzZXRIZWlnaHQgZm9yIHdoZW4gYm94IHNpemluZyBpcyB1bnJlbGlhYmxlLlxuXHQvLyBJbiB0aG9zZSBjYXNlcywgdGhlIGNvbXB1dGVkIHZhbHVlIGNhbiBiZSB0cnVzdGVkIHRvIGJlIGJvcmRlci1ib3guXG5cdGlmICggKCAhc3VwcG9ydC5ib3hTaXppbmdSZWxpYWJsZSgpICYmIGlzQm9yZGVyQm94IHx8XG5cblx0XHQvLyBTdXBwb3J0OiBJRSAxMCAtIDExKywgRWRnZSAxNSAtIDE4K1xuXHRcdC8vIElFL0VkZ2UgbWlzcmVwb3J0IGBnZXRDb21wdXRlZFN0eWxlYCBvZiB0YWJsZSByb3dzIHdpdGggd2lkdGgvaGVpZ2h0XG5cdFx0Ly8gc2V0IGluIENTUyB3aGlsZSBgb2Zmc2V0KmAgcHJvcGVydGllcyByZXBvcnQgY29ycmVjdCB2YWx1ZXMuXG5cdFx0Ly8gSW50ZXJlc3RpbmdseSwgaW4gc29tZSBjYXNlcyBJRSA5IGRvZXNuJ3Qgc3VmZmVyIGZyb20gdGhpcyBpc3N1ZS5cblx0XHQhc3VwcG9ydC5yZWxpYWJsZVRyRGltZW5zaW9ucygpICYmIG5vZGVOYW1lKCBlbGVtLCBcInRyXCIgKSB8fFxuXG5cdFx0Ly8gRmFsbCBiYWNrIHRvIG9mZnNldFdpZHRoL29mZnNldEhlaWdodCB3aGVuIHZhbHVlIGlzIFwiYXV0b1wiXG5cdFx0Ly8gVGhpcyBoYXBwZW5zIGZvciBpbmxpbmUgZWxlbWVudHMgd2l0aCBubyBleHBsaWNpdCBzZXR0aW5nIChnaC0zNTcxKVxuXHRcdHZhbCA9PT0gXCJhdXRvXCIgfHxcblxuXHRcdC8vIFN1cHBvcnQ6IEFuZHJvaWQgPD00LjEgLSA0LjMgb25seVxuXHRcdC8vIEFsc28gdXNlIG9mZnNldFdpZHRoL29mZnNldEhlaWdodCBmb3IgbWlzcmVwb3J0ZWQgaW5saW5lIGRpbWVuc2lvbnMgKGdoLTM2MDIpXG5cdFx0IXBhcnNlRmxvYXQoIHZhbCApICYmIGpRdWVyeS5jc3MoIGVsZW0sIFwiZGlzcGxheVwiLCBmYWxzZSwgc3R5bGVzICkgPT09IFwiaW5saW5lXCIgKSAmJlxuXG5cdFx0Ly8gTWFrZSBzdXJlIHRoZSBlbGVtZW50IGlzIHZpc2libGUgJiBjb25uZWN0ZWRcblx0XHRlbGVtLmdldENsaWVudFJlY3RzKCkubGVuZ3RoICkge1xuXG5cdFx0aXNCb3JkZXJCb3ggPSBqUXVlcnkuY3NzKCBlbGVtLCBcImJveFNpemluZ1wiLCBmYWxzZSwgc3R5bGVzICkgPT09IFwiYm9yZGVyLWJveFwiO1xuXG5cdFx0Ly8gV2hlcmUgYXZhaWxhYmxlLCBvZmZzZXRXaWR0aC9vZmZzZXRIZWlnaHQgYXBwcm94aW1hdGUgYm9yZGVyIGJveCBkaW1lbnNpb25zLlxuXHRcdC8vIFdoZXJlIG5vdCBhdmFpbGFibGUgKGUuZy4sIFNWRyksIGFzc3VtZSB1bnJlbGlhYmxlIGJveC1zaXppbmcgYW5kIGludGVycHJldCB0aGVcblx0XHQvLyByZXRyaWV2ZWQgdmFsdWUgYXMgYSBjb250ZW50IGJveCBkaW1lbnNpb24uXG5cdFx0dmFsdWVJc0JvcmRlckJveCA9IG9mZnNldFByb3AgaW4gZWxlbTtcblx0XHRpZiAoIHZhbHVlSXNCb3JkZXJCb3ggKSB7XG5cdFx0XHR2YWwgPSBlbGVtWyBvZmZzZXRQcm9wIF07XG5cdFx0fVxuXHR9XG5cblx0Ly8gTm9ybWFsaXplIFwiXCIgYW5kIGF1dG9cblx0dmFsID0gcGFyc2VGbG9hdCggdmFsICkgfHwgMDtcblxuXHQvLyBBZGp1c3QgZm9yIHRoZSBlbGVtZW50J3MgYm94IG1vZGVsXG5cdHJldHVybiAoIHZhbCArXG5cdFx0Ym94TW9kZWxBZGp1c3RtZW50KFxuXHRcdFx0ZWxlbSxcblx0XHRcdGRpbWVuc2lvbixcblx0XHRcdGV4dHJhIHx8ICggaXNCb3JkZXJCb3ggPyBcImJvcmRlclwiIDogXCJjb250ZW50XCIgKSxcblx0XHRcdHZhbHVlSXNCb3JkZXJCb3gsXG5cdFx0XHRzdHlsZXMsXG5cblx0XHRcdC8vIFByb3ZpZGUgdGhlIGN1cnJlbnQgY29tcHV0ZWQgc2l6ZSB0byByZXF1ZXN0IHNjcm9sbCBndXR0ZXIgY2FsY3VsYXRpb24gKGdoLTM1ODkpXG5cdFx0XHR2YWxcblx0XHQpXG5cdCkgKyBcInB4XCI7XG59XG5cbmpRdWVyeS5leHRlbmQoIHtcblxuXHQvLyBBZGQgaW4gc3R5bGUgcHJvcGVydHkgaG9va3MgZm9yIG92ZXJyaWRpbmcgdGhlIGRlZmF1bHRcblx0Ly8gYmVoYXZpb3Igb2YgZ2V0dGluZyBhbmQgc2V0dGluZyBhIHN0eWxlIHByb3BlcnR5XG5cdGNzc0hvb2tzOiB7XG5cdFx0b3BhY2l0eToge1xuXHRcdFx0Z2V0OiBmdW5jdGlvbiggZWxlbSwgY29tcHV0ZWQgKSB7XG5cdFx0XHRcdGlmICggY29tcHV0ZWQgKSB7XG5cblx0XHRcdFx0XHQvLyBXZSBzaG91bGQgYWx3YXlzIGdldCBhIG51bWJlciBiYWNrIGZyb20gb3BhY2l0eVxuXHRcdFx0XHRcdHZhciByZXQgPSBjdXJDU1MoIGVsZW0sIFwib3BhY2l0eVwiICk7XG5cdFx0XHRcdFx0cmV0dXJuIHJldCA9PT0gXCJcIiA/IFwiMVwiIDogcmV0O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdC8vIERvbid0IGF1dG9tYXRpY2FsbHkgYWRkIFwicHhcIiB0byB0aGVzZSBwb3NzaWJseS11bml0bGVzcyBwcm9wZXJ0aWVzXG5cdGNzc051bWJlcjoge1xuXHRcdFwiYW5pbWF0aW9uSXRlcmF0aW9uQ291bnRcIjogdHJ1ZSxcblx0XHRcImNvbHVtbkNvdW50XCI6IHRydWUsXG5cdFx0XCJmaWxsT3BhY2l0eVwiOiB0cnVlLFxuXHRcdFwiZmxleEdyb3dcIjogdHJ1ZSxcblx0XHRcImZsZXhTaHJpbmtcIjogdHJ1ZSxcblx0XHRcImZvbnRXZWlnaHRcIjogdHJ1ZSxcblx0XHRcImdyaWRBcmVhXCI6IHRydWUsXG5cdFx0XCJncmlkQ29sdW1uXCI6IHRydWUsXG5cdFx0XCJncmlkQ29sdW1uRW5kXCI6IHRydWUsXG5cdFx0XCJncmlkQ29sdW1uU3RhcnRcIjogdHJ1ZSxcblx0XHRcImdyaWRSb3dcIjogdHJ1ZSxcblx0XHRcImdyaWRSb3dFbmRcIjogdHJ1ZSxcblx0XHRcImdyaWRSb3dTdGFydFwiOiB0cnVlLFxuXHRcdFwibGluZUhlaWdodFwiOiB0cnVlLFxuXHRcdFwib3BhY2l0eVwiOiB0cnVlLFxuXHRcdFwib3JkZXJcIjogdHJ1ZSxcblx0XHRcIm9ycGhhbnNcIjogdHJ1ZSxcblx0XHRcIndpZG93c1wiOiB0cnVlLFxuXHRcdFwiekluZGV4XCI6IHRydWUsXG5cdFx0XCJ6b29tXCI6IHRydWVcblx0fSxcblxuXHQvLyBBZGQgaW4gcHJvcGVydGllcyB3aG9zZSBuYW1lcyB5b3Ugd2lzaCB0byBmaXggYmVmb3JlXG5cdC8vIHNldHRpbmcgb3IgZ2V0dGluZyB0aGUgdmFsdWVcblx0Y3NzUHJvcHM6IHt9LFxuXG5cdC8vIEdldCBhbmQgc2V0IHRoZSBzdHlsZSBwcm9wZXJ0eSBvbiBhIERPTSBOb2RlXG5cdHN0eWxlOiBmdW5jdGlvbiggZWxlbSwgbmFtZSwgdmFsdWUsIGV4dHJhICkge1xuXG5cdFx0Ly8gRG9uJ3Qgc2V0IHN0eWxlcyBvbiB0ZXh0IGFuZCBjb21tZW50IG5vZGVzXG5cdFx0aWYgKCAhZWxlbSB8fCBlbGVtLm5vZGVUeXBlID09PSAzIHx8IGVsZW0ubm9kZVR5cGUgPT09IDggfHwgIWVsZW0uc3R5bGUgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gTWFrZSBzdXJlIHRoYXQgd2UncmUgd29ya2luZyB3aXRoIHRoZSByaWdodCBuYW1lXG5cdFx0dmFyIHJldCwgdHlwZSwgaG9va3MsXG5cdFx0XHRvcmlnTmFtZSA9IGNhbWVsQ2FzZSggbmFtZSApLFxuXHRcdFx0aXNDdXN0b21Qcm9wID0gcmN1c3RvbVByb3AudGVzdCggbmFtZSApLFxuXHRcdFx0c3R5bGUgPSBlbGVtLnN0eWxlO1xuXG5cdFx0Ly8gTWFrZSBzdXJlIHRoYXQgd2UncmUgd29ya2luZyB3aXRoIHRoZSByaWdodCBuYW1lLiBXZSBkb24ndFxuXHRcdC8vIHdhbnQgdG8gcXVlcnkgdGhlIHZhbHVlIGlmIGl0IGlzIGEgQ1NTIGN1c3RvbSBwcm9wZXJ0eVxuXHRcdC8vIHNpbmNlIHRoZXkgYXJlIHVzZXItZGVmaW5lZC5cblx0XHRpZiAoICFpc0N1c3RvbVByb3AgKSB7XG5cdFx0XHRuYW1lID0gZmluYWxQcm9wTmFtZSggb3JpZ05hbWUgKTtcblx0XHR9XG5cblx0XHQvLyBHZXRzIGhvb2sgZm9yIHRoZSBwcmVmaXhlZCB2ZXJzaW9uLCB0aGVuIHVucHJlZml4ZWQgdmVyc2lvblxuXHRcdGhvb2tzID0galF1ZXJ5LmNzc0hvb2tzWyBuYW1lIF0gfHwgalF1ZXJ5LmNzc0hvb2tzWyBvcmlnTmFtZSBdO1xuXG5cdFx0Ly8gQ2hlY2sgaWYgd2UncmUgc2V0dGluZyBhIHZhbHVlXG5cdFx0aWYgKCB2YWx1ZSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0dHlwZSA9IHR5cGVvZiB2YWx1ZTtcblxuXHRcdFx0Ly8gQ29udmVydCBcIis9XCIgb3IgXCItPVwiIHRvIHJlbGF0aXZlIG51bWJlcnMgKCM3MzQ1KVxuXHRcdFx0aWYgKCB0eXBlID09PSBcInN0cmluZ1wiICYmICggcmV0ID0gcmNzc051bS5leGVjKCB2YWx1ZSApICkgJiYgcmV0WyAxIF0gKSB7XG5cdFx0XHRcdHZhbHVlID0gYWRqdXN0Q1NTKCBlbGVtLCBuYW1lLCByZXQgKTtcblxuXHRcdFx0XHQvLyBGaXhlcyBidWcgIzkyMzdcblx0XHRcdFx0dHlwZSA9IFwibnVtYmVyXCI7XG5cdFx0XHR9XG5cblx0XHRcdC8vIE1ha2Ugc3VyZSB0aGF0IG51bGwgYW5kIE5hTiB2YWx1ZXMgYXJlbid0IHNldCAoIzcxMTYpXG5cdFx0XHRpZiAoIHZhbHVlID09IG51bGwgfHwgdmFsdWUgIT09IHZhbHVlICkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdC8vIElmIGEgbnVtYmVyIHdhcyBwYXNzZWQgaW4sIGFkZCB0aGUgdW5pdCAoZXhjZXB0IGZvciBjZXJ0YWluIENTUyBwcm9wZXJ0aWVzKVxuXHRcdFx0Ly8gVGhlIGlzQ3VzdG9tUHJvcCBjaGVjayBjYW4gYmUgcmVtb3ZlZCBpbiBqUXVlcnkgNC4wIHdoZW4gd2Ugb25seSBhdXRvLWFwcGVuZFxuXHRcdFx0Ly8gXCJweFwiIHRvIGEgZmV3IGhhcmRjb2RlZCB2YWx1ZXMuXG5cdFx0XHRpZiAoIHR5cGUgPT09IFwibnVtYmVyXCIgJiYgIWlzQ3VzdG9tUHJvcCApIHtcblx0XHRcdFx0dmFsdWUgKz0gcmV0ICYmIHJldFsgMyBdIHx8ICggalF1ZXJ5LmNzc051bWJlclsgb3JpZ05hbWUgXSA/IFwiXCIgOiBcInB4XCIgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gYmFja2dyb3VuZC0qIHByb3BzIGFmZmVjdCBvcmlnaW5hbCBjbG9uZSdzIHZhbHVlc1xuXHRcdFx0aWYgKCAhc3VwcG9ydC5jbGVhckNsb25lU3R5bGUgJiYgdmFsdWUgPT09IFwiXCIgJiYgbmFtZS5pbmRleE9mKCBcImJhY2tncm91bmRcIiApID09PSAwICkge1xuXHRcdFx0XHRzdHlsZVsgbmFtZSBdID0gXCJpbmhlcml0XCI7XG5cdFx0XHR9XG5cblx0XHRcdC8vIElmIGEgaG9vayB3YXMgcHJvdmlkZWQsIHVzZSB0aGF0IHZhbHVlLCBvdGhlcndpc2UganVzdCBzZXQgdGhlIHNwZWNpZmllZCB2YWx1ZVxuXHRcdFx0aWYgKCAhaG9va3MgfHwgISggXCJzZXRcIiBpbiBob29rcyApIHx8XG5cdFx0XHRcdCggdmFsdWUgPSBob29rcy5zZXQoIGVsZW0sIHZhbHVlLCBleHRyYSApICkgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRpZiAoIGlzQ3VzdG9tUHJvcCApIHtcblx0XHRcdFx0XHRzdHlsZS5zZXRQcm9wZXJ0eSggbmFtZSwgdmFsdWUgKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRzdHlsZVsgbmFtZSBdID0gdmFsdWU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdC8vIElmIGEgaG9vayB3YXMgcHJvdmlkZWQgZ2V0IHRoZSBub24tY29tcHV0ZWQgdmFsdWUgZnJvbSB0aGVyZVxuXHRcdFx0aWYgKCBob29rcyAmJiBcImdldFwiIGluIGhvb2tzICYmXG5cdFx0XHRcdCggcmV0ID0gaG9va3MuZ2V0KCBlbGVtLCBmYWxzZSwgZXh0cmEgKSApICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0cmV0dXJuIHJldDtcblx0XHRcdH1cblxuXHRcdFx0Ly8gT3RoZXJ3aXNlIGp1c3QgZ2V0IHRoZSB2YWx1ZSBmcm9tIHRoZSBzdHlsZSBvYmplY3Rcblx0XHRcdHJldHVybiBzdHlsZVsgbmFtZSBdO1xuXHRcdH1cblx0fSxcblxuXHRjc3M6IGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCBleHRyYSwgc3R5bGVzICkge1xuXHRcdHZhciB2YWwsIG51bSwgaG9va3MsXG5cdFx0XHRvcmlnTmFtZSA9IGNhbWVsQ2FzZSggbmFtZSApLFxuXHRcdFx0aXNDdXN0b21Qcm9wID0gcmN1c3RvbVByb3AudGVzdCggbmFtZSApO1xuXG5cdFx0Ly8gTWFrZSBzdXJlIHRoYXQgd2UncmUgd29ya2luZyB3aXRoIHRoZSByaWdodCBuYW1lLiBXZSBkb24ndFxuXHRcdC8vIHdhbnQgdG8gbW9kaWZ5IHRoZSB2YWx1ZSBpZiBpdCBpcyBhIENTUyBjdXN0b20gcHJvcGVydHlcblx0XHQvLyBzaW5jZSB0aGV5IGFyZSB1c2VyLWRlZmluZWQuXG5cdFx0aWYgKCAhaXNDdXN0b21Qcm9wICkge1xuXHRcdFx0bmFtZSA9IGZpbmFsUHJvcE5hbWUoIG9yaWdOYW1lICk7XG5cdFx0fVxuXG5cdFx0Ly8gVHJ5IHByZWZpeGVkIG5hbWUgZm9sbG93ZWQgYnkgdGhlIHVucHJlZml4ZWQgbmFtZVxuXHRcdGhvb2tzID0galF1ZXJ5LmNzc0hvb2tzWyBuYW1lIF0gfHwgalF1ZXJ5LmNzc0hvb2tzWyBvcmlnTmFtZSBdO1xuXG5cdFx0Ly8gSWYgYSBob29rIHdhcyBwcm92aWRlZCBnZXQgdGhlIGNvbXB1dGVkIHZhbHVlIGZyb20gdGhlcmVcblx0XHRpZiAoIGhvb2tzICYmIFwiZ2V0XCIgaW4gaG9va3MgKSB7XG5cdFx0XHR2YWwgPSBob29rcy5nZXQoIGVsZW0sIHRydWUsIGV4dHJhICk7XG5cdFx0fVxuXG5cdFx0Ly8gT3RoZXJ3aXNlLCBpZiBhIHdheSB0byBnZXQgdGhlIGNvbXB1dGVkIHZhbHVlIGV4aXN0cywgdXNlIHRoYXRcblx0XHRpZiAoIHZhbCA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0dmFsID0gY3VyQ1NTKCBlbGVtLCBuYW1lLCBzdHlsZXMgKTtcblx0XHR9XG5cblx0XHQvLyBDb252ZXJ0IFwibm9ybWFsXCIgdG8gY29tcHV0ZWQgdmFsdWVcblx0XHRpZiAoIHZhbCA9PT0gXCJub3JtYWxcIiAmJiBuYW1lIGluIGNzc05vcm1hbFRyYW5zZm9ybSApIHtcblx0XHRcdHZhbCA9IGNzc05vcm1hbFRyYW5zZm9ybVsgbmFtZSBdO1xuXHRcdH1cblxuXHRcdC8vIE1ha2UgbnVtZXJpYyBpZiBmb3JjZWQgb3IgYSBxdWFsaWZpZXIgd2FzIHByb3ZpZGVkIGFuZCB2YWwgbG9va3MgbnVtZXJpY1xuXHRcdGlmICggZXh0cmEgPT09IFwiXCIgfHwgZXh0cmEgKSB7XG5cdFx0XHRudW0gPSBwYXJzZUZsb2F0KCB2YWwgKTtcblx0XHRcdHJldHVybiBleHRyYSA9PT0gdHJ1ZSB8fCBpc0Zpbml0ZSggbnVtICkgPyBudW0gfHwgMCA6IHZhbDtcblx0XHR9XG5cblx0XHRyZXR1cm4gdmFsO1xuXHR9XG59ICk7XG5cbmpRdWVyeS5lYWNoKCBbIFwiaGVpZ2h0XCIsIFwid2lkdGhcIiBdLCBmdW5jdGlvbiggX2ksIGRpbWVuc2lvbiApIHtcblx0alF1ZXJ5LmNzc0hvb2tzWyBkaW1lbnNpb24gXSA9IHtcblx0XHRnZXQ6IGZ1bmN0aW9uKCBlbGVtLCBjb21wdXRlZCwgZXh0cmEgKSB7XG5cdFx0XHRpZiAoIGNvbXB1dGVkICkge1xuXG5cdFx0XHRcdC8vIENlcnRhaW4gZWxlbWVudHMgY2FuIGhhdmUgZGltZW5zaW9uIGluZm8gaWYgd2UgaW52aXNpYmx5IHNob3cgdGhlbVxuXHRcdFx0XHQvLyBidXQgaXQgbXVzdCBoYXZlIGEgY3VycmVudCBkaXNwbGF5IHN0eWxlIHRoYXQgd291bGQgYmVuZWZpdFxuXHRcdFx0XHRyZXR1cm4gcmRpc3BsYXlzd2FwLnRlc3QoIGpRdWVyeS5jc3MoIGVsZW0sIFwiZGlzcGxheVwiICkgKSAmJlxuXG5cdFx0XHRcdFx0Ly8gU3VwcG9ydDogU2FmYXJpIDgrXG5cdFx0XHRcdFx0Ly8gVGFibGUgY29sdW1ucyBpbiBTYWZhcmkgaGF2ZSBub24temVybyBvZmZzZXRXaWR0aCAmIHplcm9cblx0XHRcdFx0XHQvLyBnZXRCb3VuZGluZ0NsaWVudFJlY3QoKS53aWR0aCB1bmxlc3MgZGlzcGxheSBpcyBjaGFuZ2VkLlxuXHRcdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDw9MTEgb25seVxuXHRcdFx0XHRcdC8vIFJ1bm5pbmcgZ2V0Qm91bmRpbmdDbGllbnRSZWN0IG9uIGEgZGlzY29ubmVjdGVkIG5vZGVcblx0XHRcdFx0XHQvLyBpbiBJRSB0aHJvd3MgYW4gZXJyb3IuXG5cdFx0XHRcdFx0KCAhZWxlbS5nZXRDbGllbnRSZWN0cygpLmxlbmd0aCB8fCAhZWxlbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS53aWR0aCApID9cblx0XHRcdFx0XHRzd2FwKCBlbGVtLCBjc3NTaG93LCBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdHJldHVybiBnZXRXaWR0aE9ySGVpZ2h0KCBlbGVtLCBkaW1lbnNpb24sIGV4dHJhICk7XG5cdFx0XHRcdFx0fSApIDpcblx0XHRcdFx0XHRnZXRXaWR0aE9ySGVpZ2h0KCBlbGVtLCBkaW1lbnNpb24sIGV4dHJhICk7XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdHNldDogZnVuY3Rpb24oIGVsZW0sIHZhbHVlLCBleHRyYSApIHtcblx0XHRcdHZhciBtYXRjaGVzLFxuXHRcdFx0XHRzdHlsZXMgPSBnZXRTdHlsZXMoIGVsZW0gKSxcblxuXHRcdFx0XHQvLyBPbmx5IHJlYWQgc3R5bGVzLnBvc2l0aW9uIGlmIHRoZSB0ZXN0IGhhcyBhIGNoYW5jZSB0byBmYWlsXG5cdFx0XHRcdC8vIHRvIGF2b2lkIGZvcmNpbmcgYSByZWZsb3cuXG5cdFx0XHRcdHNjcm9sbGJveFNpemVCdWdneSA9ICFzdXBwb3J0LnNjcm9sbGJveFNpemUoKSAmJlxuXHRcdFx0XHRcdHN0eWxlcy5wb3NpdGlvbiA9PT0gXCJhYnNvbHV0ZVwiLFxuXG5cdFx0XHRcdC8vIFRvIGF2b2lkIGZvcmNpbmcgYSByZWZsb3csIG9ubHkgZmV0Y2ggYm94U2l6aW5nIGlmIHdlIG5lZWQgaXQgKGdoLTM5OTEpXG5cdFx0XHRcdGJveFNpemluZ05lZWRlZCA9IHNjcm9sbGJveFNpemVCdWdneSB8fCBleHRyYSxcblx0XHRcdFx0aXNCb3JkZXJCb3ggPSBib3hTaXppbmdOZWVkZWQgJiZcblx0XHRcdFx0XHRqUXVlcnkuY3NzKCBlbGVtLCBcImJveFNpemluZ1wiLCBmYWxzZSwgc3R5bGVzICkgPT09IFwiYm9yZGVyLWJveFwiLFxuXHRcdFx0XHRzdWJ0cmFjdCA9IGV4dHJhID9cblx0XHRcdFx0XHRib3hNb2RlbEFkanVzdG1lbnQoXG5cdFx0XHRcdFx0XHRlbGVtLFxuXHRcdFx0XHRcdFx0ZGltZW5zaW9uLFxuXHRcdFx0XHRcdFx0ZXh0cmEsXG5cdFx0XHRcdFx0XHRpc0JvcmRlckJveCxcblx0XHRcdFx0XHRcdHN0eWxlc1xuXHRcdFx0XHRcdCkgOlxuXHRcdFx0XHRcdDA7XG5cblx0XHRcdC8vIEFjY291bnQgZm9yIHVucmVsaWFibGUgYm9yZGVyLWJveCBkaW1lbnNpb25zIGJ5IGNvbXBhcmluZyBvZmZzZXQqIHRvIGNvbXB1dGVkIGFuZFxuXHRcdFx0Ly8gZmFraW5nIGEgY29udGVudC1ib3ggdG8gZ2V0IGJvcmRlciBhbmQgcGFkZGluZyAoZ2gtMzY5OSlcblx0XHRcdGlmICggaXNCb3JkZXJCb3ggJiYgc2Nyb2xsYm94U2l6ZUJ1Z2d5ICkge1xuXHRcdFx0XHRzdWJ0cmFjdCAtPSBNYXRoLmNlaWwoXG5cdFx0XHRcdFx0ZWxlbVsgXCJvZmZzZXRcIiArIGRpbWVuc2lvblsgMCBdLnRvVXBwZXJDYXNlKCkgKyBkaW1lbnNpb24uc2xpY2UoIDEgKSBdIC1cblx0XHRcdFx0XHRwYXJzZUZsb2F0KCBzdHlsZXNbIGRpbWVuc2lvbiBdICkgLVxuXHRcdFx0XHRcdGJveE1vZGVsQWRqdXN0bWVudCggZWxlbSwgZGltZW5zaW9uLCBcImJvcmRlclwiLCBmYWxzZSwgc3R5bGVzICkgLVxuXHRcdFx0XHRcdDAuNVxuXHRcdFx0XHQpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBDb252ZXJ0IHRvIHBpeGVscyBpZiB2YWx1ZSBhZGp1c3RtZW50IGlzIG5lZWRlZFxuXHRcdFx0aWYgKCBzdWJ0cmFjdCAmJiAoIG1hdGNoZXMgPSByY3NzTnVtLmV4ZWMoIHZhbHVlICkgKSAmJlxuXHRcdFx0XHQoIG1hdGNoZXNbIDMgXSB8fCBcInB4XCIgKSAhPT0gXCJweFwiICkge1xuXG5cdFx0XHRcdGVsZW0uc3R5bGVbIGRpbWVuc2lvbiBdID0gdmFsdWU7XG5cdFx0XHRcdHZhbHVlID0galF1ZXJ5LmNzcyggZWxlbSwgZGltZW5zaW9uICk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBzZXRQb3NpdGl2ZU51bWJlciggZWxlbSwgdmFsdWUsIHN1YnRyYWN0ICk7XG5cdFx0fVxuXHR9O1xufSApO1xuXG5qUXVlcnkuY3NzSG9va3MubWFyZ2luTGVmdCA9IGFkZEdldEhvb2tJZiggc3VwcG9ydC5yZWxpYWJsZU1hcmdpbkxlZnQsXG5cdGZ1bmN0aW9uKCBlbGVtLCBjb21wdXRlZCApIHtcblx0XHRpZiAoIGNvbXB1dGVkICkge1xuXHRcdFx0cmV0dXJuICggcGFyc2VGbG9hdCggY3VyQ1NTKCBlbGVtLCBcIm1hcmdpbkxlZnRcIiApICkgfHxcblx0XHRcdFx0ZWxlbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5sZWZ0IC1cblx0XHRcdFx0XHRzd2FwKCBlbGVtLCB7IG1hcmdpbkxlZnQ6IDAgfSwgZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZWxlbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5sZWZ0O1xuXHRcdFx0XHRcdH0gKVxuXHRcdFx0KSArIFwicHhcIjtcblx0XHR9XG5cdH1cbik7XG5cbi8vIFRoZXNlIGhvb2tzIGFyZSB1c2VkIGJ5IGFuaW1hdGUgdG8gZXhwYW5kIHByb3BlcnRpZXNcbmpRdWVyeS5lYWNoKCB7XG5cdG1hcmdpbjogXCJcIixcblx0cGFkZGluZzogXCJcIixcblx0Ym9yZGVyOiBcIldpZHRoXCJcbn0sIGZ1bmN0aW9uKCBwcmVmaXgsIHN1ZmZpeCApIHtcblx0alF1ZXJ5LmNzc0hvb2tzWyBwcmVmaXggKyBzdWZmaXggXSA9IHtcblx0XHRleHBhbmQ6IGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHRcdHZhciBpID0gMCxcblx0XHRcdFx0ZXhwYW5kZWQgPSB7fSxcblxuXHRcdFx0XHQvLyBBc3N1bWVzIGEgc2luZ2xlIG51bWJlciBpZiBub3QgYSBzdHJpbmdcblx0XHRcdFx0cGFydHMgPSB0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgPyB2YWx1ZS5zcGxpdCggXCIgXCIgKSA6IFsgdmFsdWUgXTtcblxuXHRcdFx0Zm9yICggOyBpIDwgNDsgaSsrICkge1xuXHRcdFx0XHRleHBhbmRlZFsgcHJlZml4ICsgY3NzRXhwYW5kWyBpIF0gKyBzdWZmaXggXSA9XG5cdFx0XHRcdFx0cGFydHNbIGkgXSB8fCBwYXJ0c1sgaSAtIDIgXSB8fCBwYXJ0c1sgMCBdO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gZXhwYW5kZWQ7XG5cdFx0fVxuXHR9O1xuXG5cdGlmICggcHJlZml4ICE9PSBcIm1hcmdpblwiICkge1xuXHRcdGpRdWVyeS5jc3NIb29rc1sgcHJlZml4ICsgc3VmZml4IF0uc2V0ID0gc2V0UG9zaXRpdmVOdW1iZXI7XG5cdH1cbn0gKTtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHRjc3M6IGZ1bmN0aW9uKCBuYW1lLCB2YWx1ZSApIHtcblx0XHRyZXR1cm4gYWNjZXNzKCB0aGlzLCBmdW5jdGlvbiggZWxlbSwgbmFtZSwgdmFsdWUgKSB7XG5cdFx0XHR2YXIgc3R5bGVzLCBsZW4sXG5cdFx0XHRcdG1hcCA9IHt9LFxuXHRcdFx0XHRpID0gMDtcblxuXHRcdFx0aWYgKCBBcnJheS5pc0FycmF5KCBuYW1lICkgKSB7XG5cdFx0XHRcdHN0eWxlcyA9IGdldFN0eWxlcyggZWxlbSApO1xuXHRcdFx0XHRsZW4gPSBuYW1lLmxlbmd0aDtcblxuXHRcdFx0XHRmb3IgKCA7IGkgPCBsZW47IGkrKyApIHtcblx0XHRcdFx0XHRtYXBbIG5hbWVbIGkgXSBdID0galF1ZXJ5LmNzcyggZWxlbSwgbmFtZVsgaSBdLCBmYWxzZSwgc3R5bGVzICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gbWFwO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdmFsdWUgIT09IHVuZGVmaW5lZCA/XG5cdFx0XHRcdGpRdWVyeS5zdHlsZSggZWxlbSwgbmFtZSwgdmFsdWUgKSA6XG5cdFx0XHRcdGpRdWVyeS5jc3MoIGVsZW0sIG5hbWUgKTtcblx0XHR9LCBuYW1lLCB2YWx1ZSwgYXJndW1lbnRzLmxlbmd0aCA+IDEgKTtcblx0fVxufSApO1xuXG5cbmZ1bmN0aW9uIFR3ZWVuKCBlbGVtLCBvcHRpb25zLCBwcm9wLCBlbmQsIGVhc2luZyApIHtcblx0cmV0dXJuIG5ldyBUd2Vlbi5wcm90b3R5cGUuaW5pdCggZWxlbSwgb3B0aW9ucywgcHJvcCwgZW5kLCBlYXNpbmcgKTtcbn1cbmpRdWVyeS5Ud2VlbiA9IFR3ZWVuO1xuXG5Ud2Vlbi5wcm90b3R5cGUgPSB7XG5cdGNvbnN0cnVjdG9yOiBUd2Vlbixcblx0aW5pdDogZnVuY3Rpb24oIGVsZW0sIG9wdGlvbnMsIHByb3AsIGVuZCwgZWFzaW5nLCB1bml0ICkge1xuXHRcdHRoaXMuZWxlbSA9IGVsZW07XG5cdFx0dGhpcy5wcm9wID0gcHJvcDtcblx0XHR0aGlzLmVhc2luZyA9IGVhc2luZyB8fCBqUXVlcnkuZWFzaW5nLl9kZWZhdWx0O1xuXHRcdHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG5cdFx0dGhpcy5zdGFydCA9IHRoaXMubm93ID0gdGhpcy5jdXIoKTtcblx0XHR0aGlzLmVuZCA9IGVuZDtcblx0XHR0aGlzLnVuaXQgPSB1bml0IHx8ICggalF1ZXJ5LmNzc051bWJlclsgcHJvcCBdID8gXCJcIiA6IFwicHhcIiApO1xuXHR9LFxuXHRjdXI6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBob29rcyA9IFR3ZWVuLnByb3BIb29rc1sgdGhpcy5wcm9wIF07XG5cblx0XHRyZXR1cm4gaG9va3MgJiYgaG9va3MuZ2V0ID9cblx0XHRcdGhvb2tzLmdldCggdGhpcyApIDpcblx0XHRcdFR3ZWVuLnByb3BIb29rcy5fZGVmYXVsdC5nZXQoIHRoaXMgKTtcblx0fSxcblx0cnVuOiBmdW5jdGlvbiggcGVyY2VudCApIHtcblx0XHR2YXIgZWFzZWQsXG5cdFx0XHRob29rcyA9IFR3ZWVuLnByb3BIb29rc1sgdGhpcy5wcm9wIF07XG5cblx0XHRpZiAoIHRoaXMub3B0aW9ucy5kdXJhdGlvbiApIHtcblx0XHRcdHRoaXMucG9zID0gZWFzZWQgPSBqUXVlcnkuZWFzaW5nWyB0aGlzLmVhc2luZyBdKFxuXHRcdFx0XHRwZXJjZW50LCB0aGlzLm9wdGlvbnMuZHVyYXRpb24gKiBwZXJjZW50LCAwLCAxLCB0aGlzLm9wdGlvbnMuZHVyYXRpb25cblx0XHRcdCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMucG9zID0gZWFzZWQgPSBwZXJjZW50O1xuXHRcdH1cblx0XHR0aGlzLm5vdyA9ICggdGhpcy5lbmQgLSB0aGlzLnN0YXJ0ICkgKiBlYXNlZCArIHRoaXMuc3RhcnQ7XG5cblx0XHRpZiAoIHRoaXMub3B0aW9ucy5zdGVwICkge1xuXHRcdFx0dGhpcy5vcHRpb25zLnN0ZXAuY2FsbCggdGhpcy5lbGVtLCB0aGlzLm5vdywgdGhpcyApO1xuXHRcdH1cblxuXHRcdGlmICggaG9va3MgJiYgaG9va3Muc2V0ICkge1xuXHRcdFx0aG9va3Muc2V0KCB0aGlzICk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdFR3ZWVuLnByb3BIb29rcy5fZGVmYXVsdC5zZXQoIHRoaXMgKTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cbn07XG5cblR3ZWVuLnByb3RvdHlwZS5pbml0LnByb3RvdHlwZSA9IFR3ZWVuLnByb3RvdHlwZTtcblxuVHdlZW4ucHJvcEhvb2tzID0ge1xuXHRfZGVmYXVsdDoge1xuXHRcdGdldDogZnVuY3Rpb24oIHR3ZWVuICkge1xuXHRcdFx0dmFyIHJlc3VsdDtcblxuXHRcdFx0Ly8gVXNlIGEgcHJvcGVydHkgb24gdGhlIGVsZW1lbnQgZGlyZWN0bHkgd2hlbiBpdCBpcyBub3QgYSBET00gZWxlbWVudCxcblx0XHRcdC8vIG9yIHdoZW4gdGhlcmUgaXMgbm8gbWF0Y2hpbmcgc3R5bGUgcHJvcGVydHkgdGhhdCBleGlzdHMuXG5cdFx0XHRpZiAoIHR3ZWVuLmVsZW0ubm9kZVR5cGUgIT09IDEgfHxcblx0XHRcdFx0dHdlZW4uZWxlbVsgdHdlZW4ucHJvcCBdICE9IG51bGwgJiYgdHdlZW4uZWxlbS5zdHlsZVsgdHdlZW4ucHJvcCBdID09IG51bGwgKSB7XG5cdFx0XHRcdHJldHVybiB0d2Vlbi5lbGVtWyB0d2Vlbi5wcm9wIF07XG5cdFx0XHR9XG5cblx0XHRcdC8vIFBhc3NpbmcgYW4gZW1wdHkgc3RyaW5nIGFzIGEgM3JkIHBhcmFtZXRlciB0byAuY3NzIHdpbGwgYXV0b21hdGljYWxseVxuXHRcdFx0Ly8gYXR0ZW1wdCBhIHBhcnNlRmxvYXQgYW5kIGZhbGxiYWNrIHRvIGEgc3RyaW5nIGlmIHRoZSBwYXJzZSBmYWlscy5cblx0XHRcdC8vIFNpbXBsZSB2YWx1ZXMgc3VjaCBhcyBcIjEwcHhcIiBhcmUgcGFyc2VkIHRvIEZsb2F0O1xuXHRcdFx0Ly8gY29tcGxleCB2YWx1ZXMgc3VjaCBhcyBcInJvdGF0ZSgxcmFkKVwiIGFyZSByZXR1cm5lZCBhcy1pcy5cblx0XHRcdHJlc3VsdCA9IGpRdWVyeS5jc3MoIHR3ZWVuLmVsZW0sIHR3ZWVuLnByb3AsIFwiXCIgKTtcblxuXHRcdFx0Ly8gRW1wdHkgc3RyaW5ncywgbnVsbCwgdW5kZWZpbmVkIGFuZCBcImF1dG9cIiBhcmUgY29udmVydGVkIHRvIDAuXG5cdFx0XHRyZXR1cm4gIXJlc3VsdCB8fCByZXN1bHQgPT09IFwiYXV0b1wiID8gMCA6IHJlc3VsdDtcblx0XHR9LFxuXHRcdHNldDogZnVuY3Rpb24oIHR3ZWVuICkge1xuXG5cdFx0XHQvLyBVc2Ugc3RlcCBob29rIGZvciBiYWNrIGNvbXBhdC5cblx0XHRcdC8vIFVzZSBjc3NIb29rIGlmIGl0cyB0aGVyZS5cblx0XHRcdC8vIFVzZSAuc3R5bGUgaWYgYXZhaWxhYmxlIGFuZCB1c2UgcGxhaW4gcHJvcGVydGllcyB3aGVyZSBhdmFpbGFibGUuXG5cdFx0XHRpZiAoIGpRdWVyeS5meC5zdGVwWyB0d2Vlbi5wcm9wIF0gKSB7XG5cdFx0XHRcdGpRdWVyeS5meC5zdGVwWyB0d2Vlbi5wcm9wIF0oIHR3ZWVuICk7XG5cdFx0XHR9IGVsc2UgaWYgKCB0d2Vlbi5lbGVtLm5vZGVUeXBlID09PSAxICYmIChcblx0XHRcdFx0alF1ZXJ5LmNzc0hvb2tzWyB0d2Vlbi5wcm9wIF0gfHxcblx0XHRcdFx0XHR0d2Vlbi5lbGVtLnN0eWxlWyBmaW5hbFByb3BOYW1lKCB0d2Vlbi5wcm9wICkgXSAhPSBudWxsICkgKSB7XG5cdFx0XHRcdGpRdWVyeS5zdHlsZSggdHdlZW4uZWxlbSwgdHdlZW4ucHJvcCwgdHdlZW4ubm93ICsgdHdlZW4udW5pdCApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dHdlZW4uZWxlbVsgdHdlZW4ucHJvcCBdID0gdHdlZW4ubm93O1xuXHRcdFx0fVxuXHRcdH1cblx0fVxufTtcblxuLy8gU3VwcG9ydDogSUUgPD05IG9ubHlcbi8vIFBhbmljIGJhc2VkIGFwcHJvYWNoIHRvIHNldHRpbmcgdGhpbmdzIG9uIGRpc2Nvbm5lY3RlZCBub2Rlc1xuVHdlZW4ucHJvcEhvb2tzLnNjcm9sbFRvcCA9IFR3ZWVuLnByb3BIb29rcy5zY3JvbGxMZWZ0ID0ge1xuXHRzZXQ6IGZ1bmN0aW9uKCB0d2VlbiApIHtcblx0XHRpZiAoIHR3ZWVuLmVsZW0ubm9kZVR5cGUgJiYgdHdlZW4uZWxlbS5wYXJlbnROb2RlICkge1xuXHRcdFx0dHdlZW4uZWxlbVsgdHdlZW4ucHJvcCBdID0gdHdlZW4ubm93O1xuXHRcdH1cblx0fVxufTtcblxualF1ZXJ5LmVhc2luZyA9IHtcblx0bGluZWFyOiBmdW5jdGlvbiggcCApIHtcblx0XHRyZXR1cm4gcDtcblx0fSxcblx0c3dpbmc6IGZ1bmN0aW9uKCBwICkge1xuXHRcdHJldHVybiAwLjUgLSBNYXRoLmNvcyggcCAqIE1hdGguUEkgKSAvIDI7XG5cdH0sXG5cdF9kZWZhdWx0OiBcInN3aW5nXCJcbn07XG5cbmpRdWVyeS5meCA9IFR3ZWVuLnByb3RvdHlwZS5pbml0O1xuXG4vLyBCYWNrIGNvbXBhdCA8MS44IGV4dGVuc2lvbiBwb2ludFxualF1ZXJ5LmZ4LnN0ZXAgPSB7fTtcblxuXG5cblxudmFyXG5cdGZ4Tm93LCBpblByb2dyZXNzLFxuXHRyZnh0eXBlcyA9IC9eKD86dG9nZ2xlfHNob3d8aGlkZSkkLyxcblx0cnJ1biA9IC9xdWV1ZUhvb2tzJC87XG5cbmZ1bmN0aW9uIHNjaGVkdWxlKCkge1xuXHRpZiAoIGluUHJvZ3Jlc3MgKSB7XG5cdFx0aWYgKCBkb2N1bWVudC5oaWRkZW4gPT09IGZhbHNlICYmIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgKSB7XG5cdFx0XHR3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKCBzY2hlZHVsZSApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR3aW5kb3cuc2V0VGltZW91dCggc2NoZWR1bGUsIGpRdWVyeS5meC5pbnRlcnZhbCApO1xuXHRcdH1cblxuXHRcdGpRdWVyeS5meC50aWNrKCk7XG5cdH1cbn1cblxuLy8gQW5pbWF0aW9ucyBjcmVhdGVkIHN5bmNocm9ub3VzbHkgd2lsbCBydW4gc3luY2hyb25vdXNseVxuZnVuY3Rpb24gY3JlYXRlRnhOb3coKSB7XG5cdHdpbmRvdy5zZXRUaW1lb3V0KCBmdW5jdGlvbigpIHtcblx0XHRmeE5vdyA9IHVuZGVmaW5lZDtcblx0fSApO1xuXHRyZXR1cm4gKCBmeE5vdyA9IERhdGUubm93KCkgKTtcbn1cblxuLy8gR2VuZXJhdGUgcGFyYW1ldGVycyB0byBjcmVhdGUgYSBzdGFuZGFyZCBhbmltYXRpb25cbmZ1bmN0aW9uIGdlbkZ4KCB0eXBlLCBpbmNsdWRlV2lkdGggKSB7XG5cdHZhciB3aGljaCxcblx0XHRpID0gMCxcblx0XHRhdHRycyA9IHsgaGVpZ2h0OiB0eXBlIH07XG5cblx0Ly8gSWYgd2UgaW5jbHVkZSB3aWR0aCwgc3RlcCB2YWx1ZSBpcyAxIHRvIGRvIGFsbCBjc3NFeHBhbmQgdmFsdWVzLFxuXHQvLyBvdGhlcndpc2Ugc3RlcCB2YWx1ZSBpcyAyIHRvIHNraXAgb3ZlciBMZWZ0IGFuZCBSaWdodFxuXHRpbmNsdWRlV2lkdGggPSBpbmNsdWRlV2lkdGggPyAxIDogMDtcblx0Zm9yICggOyBpIDwgNDsgaSArPSAyIC0gaW5jbHVkZVdpZHRoICkge1xuXHRcdHdoaWNoID0gY3NzRXhwYW5kWyBpIF07XG5cdFx0YXR0cnNbIFwibWFyZ2luXCIgKyB3aGljaCBdID0gYXR0cnNbIFwicGFkZGluZ1wiICsgd2hpY2ggXSA9IHR5cGU7XG5cdH1cblxuXHRpZiAoIGluY2x1ZGVXaWR0aCApIHtcblx0XHRhdHRycy5vcGFjaXR5ID0gYXR0cnMud2lkdGggPSB0eXBlO1xuXHR9XG5cblx0cmV0dXJuIGF0dHJzO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVUd2VlbiggdmFsdWUsIHByb3AsIGFuaW1hdGlvbiApIHtcblx0dmFyIHR3ZWVuLFxuXHRcdGNvbGxlY3Rpb24gPSAoIEFuaW1hdGlvbi50d2VlbmVyc1sgcHJvcCBdIHx8IFtdICkuY29uY2F0KCBBbmltYXRpb24udHdlZW5lcnNbIFwiKlwiIF0gKSxcblx0XHRpbmRleCA9IDAsXG5cdFx0bGVuZ3RoID0gY29sbGVjdGlvbi5sZW5ndGg7XG5cdGZvciAoIDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KysgKSB7XG5cdFx0aWYgKCAoIHR3ZWVuID0gY29sbGVjdGlvblsgaW5kZXggXS5jYWxsKCBhbmltYXRpb24sIHByb3AsIHZhbHVlICkgKSApIHtcblxuXHRcdFx0Ly8gV2UncmUgZG9uZSB3aXRoIHRoaXMgcHJvcGVydHlcblx0XHRcdHJldHVybiB0d2Vlbjtcblx0XHR9XG5cdH1cbn1cblxuZnVuY3Rpb24gZGVmYXVsdFByZWZpbHRlciggZWxlbSwgcHJvcHMsIG9wdHMgKSB7XG5cdHZhciBwcm9wLCB2YWx1ZSwgdG9nZ2xlLCBob29rcywgb2xkZmlyZSwgcHJvcFR3ZWVuLCByZXN0b3JlRGlzcGxheSwgZGlzcGxheSxcblx0XHRpc0JveCA9IFwid2lkdGhcIiBpbiBwcm9wcyB8fCBcImhlaWdodFwiIGluIHByb3BzLFxuXHRcdGFuaW0gPSB0aGlzLFxuXHRcdG9yaWcgPSB7fSxcblx0XHRzdHlsZSA9IGVsZW0uc3R5bGUsXG5cdFx0aGlkZGVuID0gZWxlbS5ub2RlVHlwZSAmJiBpc0hpZGRlbldpdGhpblRyZWUoIGVsZW0gKSxcblx0XHRkYXRhU2hvdyA9IGRhdGFQcml2LmdldCggZWxlbSwgXCJmeHNob3dcIiApO1xuXG5cdC8vIFF1ZXVlLXNraXBwaW5nIGFuaW1hdGlvbnMgaGlqYWNrIHRoZSBmeCBob29rc1xuXHRpZiAoICFvcHRzLnF1ZXVlICkge1xuXHRcdGhvb2tzID0galF1ZXJ5Ll9xdWV1ZUhvb2tzKCBlbGVtLCBcImZ4XCIgKTtcblx0XHRpZiAoIGhvb2tzLnVucXVldWVkID09IG51bGwgKSB7XG5cdFx0XHRob29rcy51bnF1ZXVlZCA9IDA7XG5cdFx0XHRvbGRmaXJlID0gaG9va3MuZW1wdHkuZmlyZTtcblx0XHRcdGhvb2tzLmVtcHR5LmZpcmUgPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYgKCAhaG9va3MudW5xdWV1ZWQgKSB7XG5cdFx0XHRcdFx0b2xkZmlyZSgpO1xuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXHRcdH1cblx0XHRob29rcy51bnF1ZXVlZCsrO1xuXG5cdFx0YW5pbS5hbHdheXMoIGZ1bmN0aW9uKCkge1xuXG5cdFx0XHQvLyBFbnN1cmUgdGhlIGNvbXBsZXRlIGhhbmRsZXIgaXMgY2FsbGVkIGJlZm9yZSB0aGlzIGNvbXBsZXRlc1xuXHRcdFx0YW5pbS5hbHdheXMoIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRob29rcy51bnF1ZXVlZC0tO1xuXHRcdFx0XHRpZiAoICFqUXVlcnkucXVldWUoIGVsZW0sIFwiZnhcIiApLmxlbmd0aCApIHtcblx0XHRcdFx0XHRob29rcy5lbXB0eS5maXJlKCk7XG5cdFx0XHRcdH1cblx0XHRcdH0gKTtcblx0XHR9ICk7XG5cdH1cblxuXHQvLyBEZXRlY3Qgc2hvdy9oaWRlIGFuaW1hdGlvbnNcblx0Zm9yICggcHJvcCBpbiBwcm9wcyApIHtcblx0XHR2YWx1ZSA9IHByb3BzWyBwcm9wIF07XG5cdFx0aWYgKCByZnh0eXBlcy50ZXN0KCB2YWx1ZSApICkge1xuXHRcdFx0ZGVsZXRlIHByb3BzWyBwcm9wIF07XG5cdFx0XHR0b2dnbGUgPSB0b2dnbGUgfHwgdmFsdWUgPT09IFwidG9nZ2xlXCI7XG5cdFx0XHRpZiAoIHZhbHVlID09PSAoIGhpZGRlbiA/IFwiaGlkZVwiIDogXCJzaG93XCIgKSApIHtcblxuXHRcdFx0XHQvLyBQcmV0ZW5kIHRvIGJlIGhpZGRlbiBpZiB0aGlzIGlzIGEgXCJzaG93XCIgYW5kXG5cdFx0XHRcdC8vIHRoZXJlIGlzIHN0aWxsIGRhdGEgZnJvbSBhIHN0b3BwZWQgc2hvdy9oaWRlXG5cdFx0XHRcdGlmICggdmFsdWUgPT09IFwic2hvd1wiICYmIGRhdGFTaG93ICYmIGRhdGFTaG93WyBwcm9wIF0gIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHRoaWRkZW4gPSB0cnVlO1xuXG5cdFx0XHRcdC8vIElnbm9yZSBhbGwgb3RoZXIgbm8tb3Agc2hvdy9oaWRlIGRhdGFcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0b3JpZ1sgcHJvcCBdID0gZGF0YVNob3cgJiYgZGF0YVNob3dbIHByb3AgXSB8fCBqUXVlcnkuc3R5bGUoIGVsZW0sIHByb3AgKTtcblx0XHR9XG5cdH1cblxuXHQvLyBCYWlsIG91dCBpZiB0aGlzIGlzIGEgbm8tb3AgbGlrZSAuaGlkZSgpLmhpZGUoKVxuXHRwcm9wVHdlZW4gPSAhalF1ZXJ5LmlzRW1wdHlPYmplY3QoIHByb3BzICk7XG5cdGlmICggIXByb3BUd2VlbiAmJiBqUXVlcnkuaXNFbXB0eU9iamVjdCggb3JpZyApICkge1xuXHRcdHJldHVybjtcblx0fVxuXG5cdC8vIFJlc3RyaWN0IFwib3ZlcmZsb3dcIiBhbmQgXCJkaXNwbGF5XCIgc3R5bGVzIGR1cmluZyBib3ggYW5pbWF0aW9uc1xuXHRpZiAoIGlzQm94ICYmIGVsZW0ubm9kZVR5cGUgPT09IDEgKSB7XG5cblx0XHQvLyBTdXBwb3J0OiBJRSA8PTkgLSAxMSwgRWRnZSAxMiAtIDE1XG5cdFx0Ly8gUmVjb3JkIGFsbCAzIG92ZXJmbG93IGF0dHJpYnV0ZXMgYmVjYXVzZSBJRSBkb2VzIG5vdCBpbmZlciB0aGUgc2hvcnRoYW5kXG5cdFx0Ly8gZnJvbSBpZGVudGljYWxseS12YWx1ZWQgb3ZlcmZsb3dYIGFuZCBvdmVyZmxvd1kgYW5kIEVkZ2UganVzdCBtaXJyb3JzXG5cdFx0Ly8gdGhlIG92ZXJmbG93WCB2YWx1ZSB0aGVyZS5cblx0XHRvcHRzLm92ZXJmbG93ID0gWyBzdHlsZS5vdmVyZmxvdywgc3R5bGUub3ZlcmZsb3dYLCBzdHlsZS5vdmVyZmxvd1kgXTtcblxuXHRcdC8vIElkZW50aWZ5IGEgZGlzcGxheSB0eXBlLCBwcmVmZXJyaW5nIG9sZCBzaG93L2hpZGUgZGF0YSBvdmVyIHRoZSBDU1MgY2FzY2FkZVxuXHRcdHJlc3RvcmVEaXNwbGF5ID0gZGF0YVNob3cgJiYgZGF0YVNob3cuZGlzcGxheTtcblx0XHRpZiAoIHJlc3RvcmVEaXNwbGF5ID09IG51bGwgKSB7XG5cdFx0XHRyZXN0b3JlRGlzcGxheSA9IGRhdGFQcml2LmdldCggZWxlbSwgXCJkaXNwbGF5XCIgKTtcblx0XHR9XG5cdFx0ZGlzcGxheSA9IGpRdWVyeS5jc3MoIGVsZW0sIFwiZGlzcGxheVwiICk7XG5cdFx0aWYgKCBkaXNwbGF5ID09PSBcIm5vbmVcIiApIHtcblx0XHRcdGlmICggcmVzdG9yZURpc3BsYXkgKSB7XG5cdFx0XHRcdGRpc3BsYXkgPSByZXN0b3JlRGlzcGxheTtcblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0Ly8gR2V0IG5vbmVtcHR5IHZhbHVlKHMpIGJ5IHRlbXBvcmFyaWx5IGZvcmNpbmcgdmlzaWJpbGl0eVxuXHRcdFx0XHRzaG93SGlkZSggWyBlbGVtIF0sIHRydWUgKTtcblx0XHRcdFx0cmVzdG9yZURpc3BsYXkgPSBlbGVtLnN0eWxlLmRpc3BsYXkgfHwgcmVzdG9yZURpc3BsYXk7XG5cdFx0XHRcdGRpc3BsYXkgPSBqUXVlcnkuY3NzKCBlbGVtLCBcImRpc3BsYXlcIiApO1xuXHRcdFx0XHRzaG93SGlkZSggWyBlbGVtIF0gKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBBbmltYXRlIGlubGluZSBlbGVtZW50cyBhcyBpbmxpbmUtYmxvY2tcblx0XHRpZiAoIGRpc3BsYXkgPT09IFwiaW5saW5lXCIgfHwgZGlzcGxheSA9PT0gXCJpbmxpbmUtYmxvY2tcIiAmJiByZXN0b3JlRGlzcGxheSAhPSBudWxsICkge1xuXHRcdFx0aWYgKCBqUXVlcnkuY3NzKCBlbGVtLCBcImZsb2F0XCIgKSA9PT0gXCJub25lXCIgKSB7XG5cblx0XHRcdFx0Ly8gUmVzdG9yZSB0aGUgb3JpZ2luYWwgZGlzcGxheSB2YWx1ZSBhdCB0aGUgZW5kIG9mIHB1cmUgc2hvdy9oaWRlIGFuaW1hdGlvbnNcblx0XHRcdFx0aWYgKCAhcHJvcFR3ZWVuICkge1xuXHRcdFx0XHRcdGFuaW0uZG9uZSggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRzdHlsZS5kaXNwbGF5ID0gcmVzdG9yZURpc3BsYXk7XG5cdFx0XHRcdFx0fSApO1xuXHRcdFx0XHRcdGlmICggcmVzdG9yZURpc3BsYXkgPT0gbnVsbCApIHtcblx0XHRcdFx0XHRcdGRpc3BsYXkgPSBzdHlsZS5kaXNwbGF5O1xuXHRcdFx0XHRcdFx0cmVzdG9yZURpc3BsYXkgPSBkaXNwbGF5ID09PSBcIm5vbmVcIiA/IFwiXCIgOiBkaXNwbGF5O1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRzdHlsZS5kaXNwbGF5ID0gXCJpbmxpbmUtYmxvY2tcIjtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRpZiAoIG9wdHMub3ZlcmZsb3cgKSB7XG5cdFx0c3R5bGUub3ZlcmZsb3cgPSBcImhpZGRlblwiO1xuXHRcdGFuaW0uYWx3YXlzKCBmdW5jdGlvbigpIHtcblx0XHRcdHN0eWxlLm92ZXJmbG93ID0gb3B0cy5vdmVyZmxvd1sgMCBdO1xuXHRcdFx0c3R5bGUub3ZlcmZsb3dYID0gb3B0cy5vdmVyZmxvd1sgMSBdO1xuXHRcdFx0c3R5bGUub3ZlcmZsb3dZID0gb3B0cy5vdmVyZmxvd1sgMiBdO1xuXHRcdH0gKTtcblx0fVxuXG5cdC8vIEltcGxlbWVudCBzaG93L2hpZGUgYW5pbWF0aW9uc1xuXHRwcm9wVHdlZW4gPSBmYWxzZTtcblx0Zm9yICggcHJvcCBpbiBvcmlnICkge1xuXG5cdFx0Ly8gR2VuZXJhbCBzaG93L2hpZGUgc2V0dXAgZm9yIHRoaXMgZWxlbWVudCBhbmltYXRpb25cblx0XHRpZiAoICFwcm9wVHdlZW4gKSB7XG5cdFx0XHRpZiAoIGRhdGFTaG93ICkge1xuXHRcdFx0XHRpZiAoIFwiaGlkZGVuXCIgaW4gZGF0YVNob3cgKSB7XG5cdFx0XHRcdFx0aGlkZGVuID0gZGF0YVNob3cuaGlkZGVuO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRkYXRhU2hvdyA9IGRhdGFQcml2LmFjY2VzcyggZWxlbSwgXCJmeHNob3dcIiwgeyBkaXNwbGF5OiByZXN0b3JlRGlzcGxheSB9ICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFN0b3JlIGhpZGRlbi92aXNpYmxlIGZvciB0b2dnbGUgc28gYC5zdG9wKCkudG9nZ2xlKClgIFwicmV2ZXJzZXNcIlxuXHRcdFx0aWYgKCB0b2dnbGUgKSB7XG5cdFx0XHRcdGRhdGFTaG93LmhpZGRlbiA9ICFoaWRkZW47XG5cdFx0XHR9XG5cblx0XHRcdC8vIFNob3cgZWxlbWVudHMgYmVmb3JlIGFuaW1hdGluZyB0aGVtXG5cdFx0XHRpZiAoIGhpZGRlbiApIHtcblx0XHRcdFx0c2hvd0hpZGUoIFsgZWxlbSBdLCB0cnVlICk7XG5cdFx0XHR9XG5cblx0XHRcdC8qIGVzbGludC1kaXNhYmxlIG5vLWxvb3AtZnVuYyAqL1xuXG5cdFx0XHRhbmltLmRvbmUoIGZ1bmN0aW9uKCkge1xuXG5cdFx0XHRcdC8qIGVzbGludC1lbmFibGUgbm8tbG9vcC1mdW5jICovXG5cblx0XHRcdFx0Ly8gVGhlIGZpbmFsIHN0ZXAgb2YgYSBcImhpZGVcIiBhbmltYXRpb24gaXMgYWN0dWFsbHkgaGlkaW5nIHRoZSBlbGVtZW50XG5cdFx0XHRcdGlmICggIWhpZGRlbiApIHtcblx0XHRcdFx0XHRzaG93SGlkZSggWyBlbGVtIF0gKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRkYXRhUHJpdi5yZW1vdmUoIGVsZW0sIFwiZnhzaG93XCIgKTtcblx0XHRcdFx0Zm9yICggcHJvcCBpbiBvcmlnICkge1xuXHRcdFx0XHRcdGpRdWVyeS5zdHlsZSggZWxlbSwgcHJvcCwgb3JpZ1sgcHJvcCBdICk7XG5cdFx0XHRcdH1cblx0XHRcdH0gKTtcblx0XHR9XG5cblx0XHQvLyBQZXItcHJvcGVydHkgc2V0dXBcblx0XHRwcm9wVHdlZW4gPSBjcmVhdGVUd2VlbiggaGlkZGVuID8gZGF0YVNob3dbIHByb3AgXSA6IDAsIHByb3AsIGFuaW0gKTtcblx0XHRpZiAoICEoIHByb3AgaW4gZGF0YVNob3cgKSApIHtcblx0XHRcdGRhdGFTaG93WyBwcm9wIF0gPSBwcm9wVHdlZW4uc3RhcnQ7XG5cdFx0XHRpZiAoIGhpZGRlbiApIHtcblx0XHRcdFx0cHJvcFR3ZWVuLmVuZCA9IHByb3BUd2Vlbi5zdGFydDtcblx0XHRcdFx0cHJvcFR3ZWVuLnN0YXJ0ID0gMDtcblx0XHRcdH1cblx0XHR9XG5cdH1cbn1cblxuZnVuY3Rpb24gcHJvcEZpbHRlciggcHJvcHMsIHNwZWNpYWxFYXNpbmcgKSB7XG5cdHZhciBpbmRleCwgbmFtZSwgZWFzaW5nLCB2YWx1ZSwgaG9va3M7XG5cblx0Ly8gY2FtZWxDYXNlLCBzcGVjaWFsRWFzaW5nIGFuZCBleHBhbmQgY3NzSG9vayBwYXNzXG5cdGZvciAoIGluZGV4IGluIHByb3BzICkge1xuXHRcdG5hbWUgPSBjYW1lbENhc2UoIGluZGV4ICk7XG5cdFx0ZWFzaW5nID0gc3BlY2lhbEVhc2luZ1sgbmFtZSBdO1xuXHRcdHZhbHVlID0gcHJvcHNbIGluZGV4IF07XG5cdFx0aWYgKCBBcnJheS5pc0FycmF5KCB2YWx1ZSApICkge1xuXHRcdFx0ZWFzaW5nID0gdmFsdWVbIDEgXTtcblx0XHRcdHZhbHVlID0gcHJvcHNbIGluZGV4IF0gPSB2YWx1ZVsgMCBdO1xuXHRcdH1cblxuXHRcdGlmICggaW5kZXggIT09IG5hbWUgKSB7XG5cdFx0XHRwcm9wc1sgbmFtZSBdID0gdmFsdWU7XG5cdFx0XHRkZWxldGUgcHJvcHNbIGluZGV4IF07XG5cdFx0fVxuXG5cdFx0aG9va3MgPSBqUXVlcnkuY3NzSG9va3NbIG5hbWUgXTtcblx0XHRpZiAoIGhvb2tzICYmIFwiZXhwYW5kXCIgaW4gaG9va3MgKSB7XG5cdFx0XHR2YWx1ZSA9IGhvb2tzLmV4cGFuZCggdmFsdWUgKTtcblx0XHRcdGRlbGV0ZSBwcm9wc1sgbmFtZSBdO1xuXG5cdFx0XHQvLyBOb3QgcXVpdGUgJC5leHRlbmQsIHRoaXMgd29uJ3Qgb3ZlcndyaXRlIGV4aXN0aW5nIGtleXMuXG5cdFx0XHQvLyBSZXVzaW5nICdpbmRleCcgYmVjYXVzZSB3ZSBoYXZlIHRoZSBjb3JyZWN0IFwibmFtZVwiXG5cdFx0XHRmb3IgKCBpbmRleCBpbiB2YWx1ZSApIHtcblx0XHRcdFx0aWYgKCAhKCBpbmRleCBpbiBwcm9wcyApICkge1xuXHRcdFx0XHRcdHByb3BzWyBpbmRleCBdID0gdmFsdWVbIGluZGV4IF07XG5cdFx0XHRcdFx0c3BlY2lhbEVhc2luZ1sgaW5kZXggXSA9IGVhc2luZztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRzcGVjaWFsRWFzaW5nWyBuYW1lIF0gPSBlYXNpbmc7XG5cdFx0fVxuXHR9XG59XG5cbmZ1bmN0aW9uIEFuaW1hdGlvbiggZWxlbSwgcHJvcGVydGllcywgb3B0aW9ucyApIHtcblx0dmFyIHJlc3VsdCxcblx0XHRzdG9wcGVkLFxuXHRcdGluZGV4ID0gMCxcblx0XHRsZW5ndGggPSBBbmltYXRpb24ucHJlZmlsdGVycy5sZW5ndGgsXG5cdFx0ZGVmZXJyZWQgPSBqUXVlcnkuRGVmZXJyZWQoKS5hbHdheXMoIGZ1bmN0aW9uKCkge1xuXG5cdFx0XHQvLyBEb24ndCBtYXRjaCBlbGVtIGluIHRoZSA6YW5pbWF0ZWQgc2VsZWN0b3Jcblx0XHRcdGRlbGV0ZSB0aWNrLmVsZW07XG5cdFx0fSApLFxuXHRcdHRpY2sgPSBmdW5jdGlvbigpIHtcblx0XHRcdGlmICggc3RvcHBlZCApIHtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXHRcdFx0dmFyIGN1cnJlbnRUaW1lID0gZnhOb3cgfHwgY3JlYXRlRnhOb3coKSxcblx0XHRcdFx0cmVtYWluaW5nID0gTWF0aC5tYXgoIDAsIGFuaW1hdGlvbi5zdGFydFRpbWUgKyBhbmltYXRpb24uZHVyYXRpb24gLSBjdXJyZW50VGltZSApLFxuXG5cdFx0XHRcdC8vIFN1cHBvcnQ6IEFuZHJvaWQgMi4zIG9ubHlcblx0XHRcdFx0Ly8gQXJjaGFpYyBjcmFzaCBidWcgd29uJ3QgYWxsb3cgdXMgdG8gdXNlIGAxIC0gKCAwLjUgfHwgMCApYCAoIzEyNDk3KVxuXHRcdFx0XHR0ZW1wID0gcmVtYWluaW5nIC8gYW5pbWF0aW9uLmR1cmF0aW9uIHx8IDAsXG5cdFx0XHRcdHBlcmNlbnQgPSAxIC0gdGVtcCxcblx0XHRcdFx0aW5kZXggPSAwLFxuXHRcdFx0XHRsZW5ndGggPSBhbmltYXRpb24udHdlZW5zLmxlbmd0aDtcblxuXHRcdFx0Zm9yICggOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKyApIHtcblx0XHRcdFx0YW5pbWF0aW9uLnR3ZWVuc1sgaW5kZXggXS5ydW4oIHBlcmNlbnQgKTtcblx0XHRcdH1cblxuXHRcdFx0ZGVmZXJyZWQubm90aWZ5V2l0aCggZWxlbSwgWyBhbmltYXRpb24sIHBlcmNlbnQsIHJlbWFpbmluZyBdICk7XG5cblx0XHRcdC8vIElmIHRoZXJlJ3MgbW9yZSB0byBkbywgeWllbGRcblx0XHRcdGlmICggcGVyY2VudCA8IDEgJiYgbGVuZ3RoICkge1xuXHRcdFx0XHRyZXR1cm4gcmVtYWluaW5nO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBJZiB0aGlzIHdhcyBhbiBlbXB0eSBhbmltYXRpb24sIHN5bnRoZXNpemUgYSBmaW5hbCBwcm9ncmVzcyBub3RpZmljYXRpb25cblx0XHRcdGlmICggIWxlbmd0aCApIHtcblx0XHRcdFx0ZGVmZXJyZWQubm90aWZ5V2l0aCggZWxlbSwgWyBhbmltYXRpb24sIDEsIDAgXSApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBSZXNvbHZlIHRoZSBhbmltYXRpb24gYW5kIHJlcG9ydCBpdHMgY29uY2x1c2lvblxuXHRcdFx0ZGVmZXJyZWQucmVzb2x2ZVdpdGgoIGVsZW0sIFsgYW5pbWF0aW9uIF0gKTtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9LFxuXHRcdGFuaW1hdGlvbiA9IGRlZmVycmVkLnByb21pc2UoIHtcblx0XHRcdGVsZW06IGVsZW0sXG5cdFx0XHRwcm9wczogalF1ZXJ5LmV4dGVuZCgge30sIHByb3BlcnRpZXMgKSxcblx0XHRcdG9wdHM6IGpRdWVyeS5leHRlbmQoIHRydWUsIHtcblx0XHRcdFx0c3BlY2lhbEVhc2luZzoge30sXG5cdFx0XHRcdGVhc2luZzogalF1ZXJ5LmVhc2luZy5fZGVmYXVsdFxuXHRcdFx0fSwgb3B0aW9ucyApLFxuXHRcdFx0b3JpZ2luYWxQcm9wZXJ0aWVzOiBwcm9wZXJ0aWVzLFxuXHRcdFx0b3JpZ2luYWxPcHRpb25zOiBvcHRpb25zLFxuXHRcdFx0c3RhcnRUaW1lOiBmeE5vdyB8fCBjcmVhdGVGeE5vdygpLFxuXHRcdFx0ZHVyYXRpb246IG9wdGlvbnMuZHVyYXRpb24sXG5cdFx0XHR0d2VlbnM6IFtdLFxuXHRcdFx0Y3JlYXRlVHdlZW46IGZ1bmN0aW9uKCBwcm9wLCBlbmQgKSB7XG5cdFx0XHRcdHZhciB0d2VlbiA9IGpRdWVyeS5Ud2VlbiggZWxlbSwgYW5pbWF0aW9uLm9wdHMsIHByb3AsIGVuZCxcblx0XHRcdFx0XHRhbmltYXRpb24ub3B0cy5zcGVjaWFsRWFzaW5nWyBwcm9wIF0gfHwgYW5pbWF0aW9uLm9wdHMuZWFzaW5nICk7XG5cdFx0XHRcdGFuaW1hdGlvbi50d2VlbnMucHVzaCggdHdlZW4gKTtcblx0XHRcdFx0cmV0dXJuIHR3ZWVuO1xuXHRcdFx0fSxcblx0XHRcdHN0b3A6IGZ1bmN0aW9uKCBnb3RvRW5kICkge1xuXHRcdFx0XHR2YXIgaW5kZXggPSAwLFxuXG5cdFx0XHRcdFx0Ly8gSWYgd2UgYXJlIGdvaW5nIHRvIHRoZSBlbmQsIHdlIHdhbnQgdG8gcnVuIGFsbCB0aGUgdHdlZW5zXG5cdFx0XHRcdFx0Ly8gb3RoZXJ3aXNlIHdlIHNraXAgdGhpcyBwYXJ0XG5cdFx0XHRcdFx0bGVuZ3RoID0gZ290b0VuZCA/IGFuaW1hdGlvbi50d2VlbnMubGVuZ3RoIDogMDtcblx0XHRcdFx0aWYgKCBzdG9wcGVkICkge1xuXHRcdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHN0b3BwZWQgPSB0cnVlO1xuXHRcdFx0XHRmb3IgKCA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrICkge1xuXHRcdFx0XHRcdGFuaW1hdGlvbi50d2VlbnNbIGluZGV4IF0ucnVuKCAxICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBSZXNvbHZlIHdoZW4gd2UgcGxheWVkIHRoZSBsYXN0IGZyYW1lOyBvdGhlcndpc2UsIHJlamVjdFxuXHRcdFx0XHRpZiAoIGdvdG9FbmQgKSB7XG5cdFx0XHRcdFx0ZGVmZXJyZWQubm90aWZ5V2l0aCggZWxlbSwgWyBhbmltYXRpb24sIDEsIDAgXSApO1xuXHRcdFx0XHRcdGRlZmVycmVkLnJlc29sdmVXaXRoKCBlbGVtLCBbIGFuaW1hdGlvbiwgZ290b0VuZCBdICk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0ZGVmZXJyZWQucmVqZWN0V2l0aCggZWxlbSwgWyBhbmltYXRpb24sIGdvdG9FbmQgXSApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fVxuXHRcdH0gKSxcblx0XHRwcm9wcyA9IGFuaW1hdGlvbi5wcm9wcztcblxuXHRwcm9wRmlsdGVyKCBwcm9wcywgYW5pbWF0aW9uLm9wdHMuc3BlY2lhbEVhc2luZyApO1xuXG5cdGZvciAoIDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KysgKSB7XG5cdFx0cmVzdWx0ID0gQW5pbWF0aW9uLnByZWZpbHRlcnNbIGluZGV4IF0uY2FsbCggYW5pbWF0aW9uLCBlbGVtLCBwcm9wcywgYW5pbWF0aW9uLm9wdHMgKTtcblx0XHRpZiAoIHJlc3VsdCApIHtcblx0XHRcdGlmICggaXNGdW5jdGlvbiggcmVzdWx0LnN0b3AgKSApIHtcblx0XHRcdFx0alF1ZXJ5Ll9xdWV1ZUhvb2tzKCBhbmltYXRpb24uZWxlbSwgYW5pbWF0aW9uLm9wdHMucXVldWUgKS5zdG9wID1cblx0XHRcdFx0XHRyZXN1bHQuc3RvcC5iaW5kKCByZXN1bHQgKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiByZXN1bHQ7XG5cdFx0fVxuXHR9XG5cblx0alF1ZXJ5Lm1hcCggcHJvcHMsIGNyZWF0ZVR3ZWVuLCBhbmltYXRpb24gKTtcblxuXHRpZiAoIGlzRnVuY3Rpb24oIGFuaW1hdGlvbi5vcHRzLnN0YXJ0ICkgKSB7XG5cdFx0YW5pbWF0aW9uLm9wdHMuc3RhcnQuY2FsbCggZWxlbSwgYW5pbWF0aW9uICk7XG5cdH1cblxuXHQvLyBBdHRhY2ggY2FsbGJhY2tzIGZyb20gb3B0aW9uc1xuXHRhbmltYXRpb25cblx0XHQucHJvZ3Jlc3MoIGFuaW1hdGlvbi5vcHRzLnByb2dyZXNzIClcblx0XHQuZG9uZSggYW5pbWF0aW9uLm9wdHMuZG9uZSwgYW5pbWF0aW9uLm9wdHMuY29tcGxldGUgKVxuXHRcdC5mYWlsKCBhbmltYXRpb24ub3B0cy5mYWlsIClcblx0XHQuYWx3YXlzKCBhbmltYXRpb24ub3B0cy5hbHdheXMgKTtcblxuXHRqUXVlcnkuZngudGltZXIoXG5cdFx0alF1ZXJ5LmV4dGVuZCggdGljaywge1xuXHRcdFx0ZWxlbTogZWxlbSxcblx0XHRcdGFuaW06IGFuaW1hdGlvbixcblx0XHRcdHF1ZXVlOiBhbmltYXRpb24ub3B0cy5xdWV1ZVxuXHRcdH0gKVxuXHQpO1xuXG5cdHJldHVybiBhbmltYXRpb247XG59XG5cbmpRdWVyeS5BbmltYXRpb24gPSBqUXVlcnkuZXh0ZW5kKCBBbmltYXRpb24sIHtcblxuXHR0d2VlbmVyczoge1xuXHRcdFwiKlwiOiBbIGZ1bmN0aW9uKCBwcm9wLCB2YWx1ZSApIHtcblx0XHRcdHZhciB0d2VlbiA9IHRoaXMuY3JlYXRlVHdlZW4oIHByb3AsIHZhbHVlICk7XG5cdFx0XHRhZGp1c3RDU1MoIHR3ZWVuLmVsZW0sIHByb3AsIHJjc3NOdW0uZXhlYyggdmFsdWUgKSwgdHdlZW4gKTtcblx0XHRcdHJldHVybiB0d2Vlbjtcblx0XHR9IF1cblx0fSxcblxuXHR0d2VlbmVyOiBmdW5jdGlvbiggcHJvcHMsIGNhbGxiYWNrICkge1xuXHRcdGlmICggaXNGdW5jdGlvbiggcHJvcHMgKSApIHtcblx0XHRcdGNhbGxiYWNrID0gcHJvcHM7XG5cdFx0XHRwcm9wcyA9IFsgXCIqXCIgXTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cHJvcHMgPSBwcm9wcy5tYXRjaCggcm5vdGh0bWx3aGl0ZSApO1xuXHRcdH1cblxuXHRcdHZhciBwcm9wLFxuXHRcdFx0aW5kZXggPSAwLFxuXHRcdFx0bGVuZ3RoID0gcHJvcHMubGVuZ3RoO1xuXG5cdFx0Zm9yICggOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKyApIHtcblx0XHRcdHByb3AgPSBwcm9wc1sgaW5kZXggXTtcblx0XHRcdEFuaW1hdGlvbi50d2VlbmVyc1sgcHJvcCBdID0gQW5pbWF0aW9uLnR3ZWVuZXJzWyBwcm9wIF0gfHwgW107XG5cdFx0XHRBbmltYXRpb24udHdlZW5lcnNbIHByb3AgXS51bnNoaWZ0KCBjYWxsYmFjayApO1xuXHRcdH1cblx0fSxcblxuXHRwcmVmaWx0ZXJzOiBbIGRlZmF1bHRQcmVmaWx0ZXIgXSxcblxuXHRwcmVmaWx0ZXI6IGZ1bmN0aW9uKCBjYWxsYmFjaywgcHJlcGVuZCApIHtcblx0XHRpZiAoIHByZXBlbmQgKSB7XG5cdFx0XHRBbmltYXRpb24ucHJlZmlsdGVycy51bnNoaWZ0KCBjYWxsYmFjayApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRBbmltYXRpb24ucHJlZmlsdGVycy5wdXNoKCBjYWxsYmFjayApO1xuXHRcdH1cblx0fVxufSApO1xuXG5qUXVlcnkuc3BlZWQgPSBmdW5jdGlvbiggc3BlZWQsIGVhc2luZywgZm4gKSB7XG5cdHZhciBvcHQgPSBzcGVlZCAmJiB0eXBlb2Ygc3BlZWQgPT09IFwib2JqZWN0XCIgPyBqUXVlcnkuZXh0ZW5kKCB7fSwgc3BlZWQgKSA6IHtcblx0XHRjb21wbGV0ZTogZm4gfHwgIWZuICYmIGVhc2luZyB8fFxuXHRcdFx0aXNGdW5jdGlvbiggc3BlZWQgKSAmJiBzcGVlZCxcblx0XHRkdXJhdGlvbjogc3BlZWQsXG5cdFx0ZWFzaW5nOiBmbiAmJiBlYXNpbmcgfHwgZWFzaW5nICYmICFpc0Z1bmN0aW9uKCBlYXNpbmcgKSAmJiBlYXNpbmdcblx0fTtcblxuXHQvLyBHbyB0byB0aGUgZW5kIHN0YXRlIGlmIGZ4IGFyZSBvZmZcblx0aWYgKCBqUXVlcnkuZngub2ZmICkge1xuXHRcdG9wdC5kdXJhdGlvbiA9IDA7XG5cblx0fSBlbHNlIHtcblx0XHRpZiAoIHR5cGVvZiBvcHQuZHVyYXRpb24gIT09IFwibnVtYmVyXCIgKSB7XG5cdFx0XHRpZiAoIG9wdC5kdXJhdGlvbiBpbiBqUXVlcnkuZnguc3BlZWRzICkge1xuXHRcdFx0XHRvcHQuZHVyYXRpb24gPSBqUXVlcnkuZnguc3BlZWRzWyBvcHQuZHVyYXRpb24gXTtcblxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0b3B0LmR1cmF0aW9uID0galF1ZXJ5LmZ4LnNwZWVkcy5fZGVmYXVsdDtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvLyBOb3JtYWxpemUgb3B0LnF1ZXVlIC0gdHJ1ZS91bmRlZmluZWQvbnVsbCAtPiBcImZ4XCJcblx0aWYgKCBvcHQucXVldWUgPT0gbnVsbCB8fCBvcHQucXVldWUgPT09IHRydWUgKSB7XG5cdFx0b3B0LnF1ZXVlID0gXCJmeFwiO1xuXHR9XG5cblx0Ly8gUXVldWVpbmdcblx0b3B0Lm9sZCA9IG9wdC5jb21wbGV0ZTtcblxuXHRvcHQuY29tcGxldGUgPSBmdW5jdGlvbigpIHtcblx0XHRpZiAoIGlzRnVuY3Rpb24oIG9wdC5vbGQgKSApIHtcblx0XHRcdG9wdC5vbGQuY2FsbCggdGhpcyApO1xuXHRcdH1cblxuXHRcdGlmICggb3B0LnF1ZXVlICkge1xuXHRcdFx0alF1ZXJ5LmRlcXVldWUoIHRoaXMsIG9wdC5xdWV1ZSApO1xuXHRcdH1cblx0fTtcblxuXHRyZXR1cm4gb3B0O1xufTtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHRmYWRlVG86IGZ1bmN0aW9uKCBzcGVlZCwgdG8sIGVhc2luZywgY2FsbGJhY2sgKSB7XG5cblx0XHQvLyBTaG93IGFueSBoaWRkZW4gZWxlbWVudHMgYWZ0ZXIgc2V0dGluZyBvcGFjaXR5IHRvIDBcblx0XHRyZXR1cm4gdGhpcy5maWx0ZXIoIGlzSGlkZGVuV2l0aGluVHJlZSApLmNzcyggXCJvcGFjaXR5XCIsIDAgKS5zaG93KClcblxuXHRcdFx0Ly8gQW5pbWF0ZSB0byB0aGUgdmFsdWUgc3BlY2lmaWVkXG5cdFx0XHQuZW5kKCkuYW5pbWF0ZSggeyBvcGFjaXR5OiB0byB9LCBzcGVlZCwgZWFzaW5nLCBjYWxsYmFjayApO1xuXHR9LFxuXHRhbmltYXRlOiBmdW5jdGlvbiggcHJvcCwgc3BlZWQsIGVhc2luZywgY2FsbGJhY2sgKSB7XG5cdFx0dmFyIGVtcHR5ID0galF1ZXJ5LmlzRW1wdHlPYmplY3QoIHByb3AgKSxcblx0XHRcdG9wdGFsbCA9IGpRdWVyeS5zcGVlZCggc3BlZWQsIGVhc2luZywgY2FsbGJhY2sgKSxcblx0XHRcdGRvQW5pbWF0aW9uID0gZnVuY3Rpb24oKSB7XG5cblx0XHRcdFx0Ly8gT3BlcmF0ZSBvbiBhIGNvcHkgb2YgcHJvcCBzbyBwZXItcHJvcGVydHkgZWFzaW5nIHdvbid0IGJlIGxvc3Rcblx0XHRcdFx0dmFyIGFuaW0gPSBBbmltYXRpb24oIHRoaXMsIGpRdWVyeS5leHRlbmQoIHt9LCBwcm9wICksIG9wdGFsbCApO1xuXG5cdFx0XHRcdC8vIEVtcHR5IGFuaW1hdGlvbnMsIG9yIGZpbmlzaGluZyByZXNvbHZlcyBpbW1lZGlhdGVseVxuXHRcdFx0XHRpZiAoIGVtcHR5IHx8IGRhdGFQcml2LmdldCggdGhpcywgXCJmaW5pc2hcIiApICkge1xuXHRcdFx0XHRcdGFuaW0uc3RvcCggdHJ1ZSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXG5cdFx0ZG9BbmltYXRpb24uZmluaXNoID0gZG9BbmltYXRpb247XG5cblx0XHRyZXR1cm4gZW1wdHkgfHwgb3B0YWxsLnF1ZXVlID09PSBmYWxzZSA/XG5cdFx0XHR0aGlzLmVhY2goIGRvQW5pbWF0aW9uICkgOlxuXHRcdFx0dGhpcy5xdWV1ZSggb3B0YWxsLnF1ZXVlLCBkb0FuaW1hdGlvbiApO1xuXHR9LFxuXHRzdG9wOiBmdW5jdGlvbiggdHlwZSwgY2xlYXJRdWV1ZSwgZ290b0VuZCApIHtcblx0XHR2YXIgc3RvcFF1ZXVlID0gZnVuY3Rpb24oIGhvb2tzICkge1xuXHRcdFx0dmFyIHN0b3AgPSBob29rcy5zdG9wO1xuXHRcdFx0ZGVsZXRlIGhvb2tzLnN0b3A7XG5cdFx0XHRzdG9wKCBnb3RvRW5kICk7XG5cdFx0fTtcblxuXHRcdGlmICggdHlwZW9mIHR5cGUgIT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRnb3RvRW5kID0gY2xlYXJRdWV1ZTtcblx0XHRcdGNsZWFyUXVldWUgPSB0eXBlO1xuXHRcdFx0dHlwZSA9IHVuZGVmaW5lZDtcblx0XHR9XG5cdFx0aWYgKCBjbGVhclF1ZXVlICkge1xuXHRcdFx0dGhpcy5xdWV1ZSggdHlwZSB8fCBcImZ4XCIsIFtdICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgZGVxdWV1ZSA9IHRydWUsXG5cdFx0XHRcdGluZGV4ID0gdHlwZSAhPSBudWxsICYmIHR5cGUgKyBcInF1ZXVlSG9va3NcIixcblx0XHRcdFx0dGltZXJzID0galF1ZXJ5LnRpbWVycyxcblx0XHRcdFx0ZGF0YSA9IGRhdGFQcml2LmdldCggdGhpcyApO1xuXG5cdFx0XHRpZiAoIGluZGV4ICkge1xuXHRcdFx0XHRpZiAoIGRhdGFbIGluZGV4IF0gJiYgZGF0YVsgaW5kZXggXS5zdG9wICkge1xuXHRcdFx0XHRcdHN0b3BRdWV1ZSggZGF0YVsgaW5kZXggXSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRmb3IgKCBpbmRleCBpbiBkYXRhICkge1xuXHRcdFx0XHRcdGlmICggZGF0YVsgaW5kZXggXSAmJiBkYXRhWyBpbmRleCBdLnN0b3AgJiYgcnJ1bi50ZXN0KCBpbmRleCApICkge1xuXHRcdFx0XHRcdFx0c3RvcFF1ZXVlKCBkYXRhWyBpbmRleCBdICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGZvciAoIGluZGV4ID0gdGltZXJzLmxlbmd0aDsgaW5kZXgtLTsgKSB7XG5cdFx0XHRcdGlmICggdGltZXJzWyBpbmRleCBdLmVsZW0gPT09IHRoaXMgJiZcblx0XHRcdFx0XHQoIHR5cGUgPT0gbnVsbCB8fCB0aW1lcnNbIGluZGV4IF0ucXVldWUgPT09IHR5cGUgKSApIHtcblxuXHRcdFx0XHRcdHRpbWVyc1sgaW5kZXggXS5hbmltLnN0b3AoIGdvdG9FbmQgKTtcblx0XHRcdFx0XHRkZXF1ZXVlID0gZmFsc2U7XG5cdFx0XHRcdFx0dGltZXJzLnNwbGljZSggaW5kZXgsIDEgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBTdGFydCB0aGUgbmV4dCBpbiB0aGUgcXVldWUgaWYgdGhlIGxhc3Qgc3RlcCB3YXNuJ3QgZm9yY2VkLlxuXHRcdFx0Ly8gVGltZXJzIGN1cnJlbnRseSB3aWxsIGNhbGwgdGhlaXIgY29tcGxldGUgY2FsbGJhY2tzLCB3aGljaFxuXHRcdFx0Ly8gd2lsbCBkZXF1ZXVlIGJ1dCBvbmx5IGlmIHRoZXkgd2VyZSBnb3RvRW5kLlxuXHRcdFx0aWYgKCBkZXF1ZXVlIHx8ICFnb3RvRW5kICkge1xuXHRcdFx0XHRqUXVlcnkuZGVxdWV1ZSggdGhpcywgdHlwZSApO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0fSxcblx0ZmluaXNoOiBmdW5jdGlvbiggdHlwZSApIHtcblx0XHRpZiAoIHR5cGUgIT09IGZhbHNlICkge1xuXHRcdFx0dHlwZSA9IHR5cGUgfHwgXCJmeFwiO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBpbmRleCxcblx0XHRcdFx0ZGF0YSA9IGRhdGFQcml2LmdldCggdGhpcyApLFxuXHRcdFx0XHRxdWV1ZSA9IGRhdGFbIHR5cGUgKyBcInF1ZXVlXCIgXSxcblx0XHRcdFx0aG9va3MgPSBkYXRhWyB0eXBlICsgXCJxdWV1ZUhvb2tzXCIgXSxcblx0XHRcdFx0dGltZXJzID0galF1ZXJ5LnRpbWVycyxcblx0XHRcdFx0bGVuZ3RoID0gcXVldWUgPyBxdWV1ZS5sZW5ndGggOiAwO1xuXG5cdFx0XHQvLyBFbmFibGUgZmluaXNoaW5nIGZsYWcgb24gcHJpdmF0ZSBkYXRhXG5cdFx0XHRkYXRhLmZpbmlzaCA9IHRydWU7XG5cblx0XHRcdC8vIEVtcHR5IHRoZSBxdWV1ZSBmaXJzdFxuXHRcdFx0alF1ZXJ5LnF1ZXVlKCB0aGlzLCB0eXBlLCBbXSApO1xuXG5cdFx0XHRpZiAoIGhvb2tzICYmIGhvb2tzLnN0b3AgKSB7XG5cdFx0XHRcdGhvb2tzLnN0b3AuY2FsbCggdGhpcywgdHJ1ZSApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBMb29rIGZvciBhbnkgYWN0aXZlIGFuaW1hdGlvbnMsIGFuZCBmaW5pc2ggdGhlbVxuXHRcdFx0Zm9yICggaW5kZXggPSB0aW1lcnMubGVuZ3RoOyBpbmRleC0tOyApIHtcblx0XHRcdFx0aWYgKCB0aW1lcnNbIGluZGV4IF0uZWxlbSA9PT0gdGhpcyAmJiB0aW1lcnNbIGluZGV4IF0ucXVldWUgPT09IHR5cGUgKSB7XG5cdFx0XHRcdFx0dGltZXJzWyBpbmRleCBdLmFuaW0uc3RvcCggdHJ1ZSApO1xuXHRcdFx0XHRcdHRpbWVycy5zcGxpY2UoIGluZGV4LCAxICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gTG9vayBmb3IgYW55IGFuaW1hdGlvbnMgaW4gdGhlIG9sZCBxdWV1ZSBhbmQgZmluaXNoIHRoZW1cblx0XHRcdGZvciAoIGluZGV4ID0gMDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KysgKSB7XG5cdFx0XHRcdGlmICggcXVldWVbIGluZGV4IF0gJiYgcXVldWVbIGluZGV4IF0uZmluaXNoICkge1xuXHRcdFx0XHRcdHF1ZXVlWyBpbmRleCBdLmZpbmlzaC5jYWxsKCB0aGlzICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gVHVybiBvZmYgZmluaXNoaW5nIGZsYWdcblx0XHRcdGRlbGV0ZSBkYXRhLmZpbmlzaDtcblx0XHR9ICk7XG5cdH1cbn0gKTtcblxualF1ZXJ5LmVhY2goIFsgXCJ0b2dnbGVcIiwgXCJzaG93XCIsIFwiaGlkZVwiIF0sIGZ1bmN0aW9uKCBfaSwgbmFtZSApIHtcblx0dmFyIGNzc0ZuID0galF1ZXJ5LmZuWyBuYW1lIF07XG5cdGpRdWVyeS5mblsgbmFtZSBdID0gZnVuY3Rpb24oIHNwZWVkLCBlYXNpbmcsIGNhbGxiYWNrICkge1xuXHRcdHJldHVybiBzcGVlZCA9PSBudWxsIHx8IHR5cGVvZiBzcGVlZCA9PT0gXCJib29sZWFuXCIgP1xuXHRcdFx0Y3NzRm4uYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApIDpcblx0XHRcdHRoaXMuYW5pbWF0ZSggZ2VuRngoIG5hbWUsIHRydWUgKSwgc3BlZWQsIGVhc2luZywgY2FsbGJhY2sgKTtcblx0fTtcbn0gKTtcblxuLy8gR2VuZXJhdGUgc2hvcnRjdXRzIGZvciBjdXN0b20gYW5pbWF0aW9uc1xualF1ZXJ5LmVhY2goIHtcblx0c2xpZGVEb3duOiBnZW5GeCggXCJzaG93XCIgKSxcblx0c2xpZGVVcDogZ2VuRngoIFwiaGlkZVwiICksXG5cdHNsaWRlVG9nZ2xlOiBnZW5GeCggXCJ0b2dnbGVcIiApLFxuXHRmYWRlSW46IHsgb3BhY2l0eTogXCJzaG93XCIgfSxcblx0ZmFkZU91dDogeyBvcGFjaXR5OiBcImhpZGVcIiB9LFxuXHRmYWRlVG9nZ2xlOiB7IG9wYWNpdHk6IFwidG9nZ2xlXCIgfVxufSwgZnVuY3Rpb24oIG5hbWUsIHByb3BzICkge1xuXHRqUXVlcnkuZm5bIG5hbWUgXSA9IGZ1bmN0aW9uKCBzcGVlZCwgZWFzaW5nLCBjYWxsYmFjayApIHtcblx0XHRyZXR1cm4gdGhpcy5hbmltYXRlKCBwcm9wcywgc3BlZWQsIGVhc2luZywgY2FsbGJhY2sgKTtcblx0fTtcbn0gKTtcblxualF1ZXJ5LnRpbWVycyA9IFtdO1xualF1ZXJ5LmZ4LnRpY2sgPSBmdW5jdGlvbigpIHtcblx0dmFyIHRpbWVyLFxuXHRcdGkgPSAwLFxuXHRcdHRpbWVycyA9IGpRdWVyeS50aW1lcnM7XG5cblx0ZnhOb3cgPSBEYXRlLm5vdygpO1xuXG5cdGZvciAoIDsgaSA8IHRpbWVycy5sZW5ndGg7IGkrKyApIHtcblx0XHR0aW1lciA9IHRpbWVyc1sgaSBdO1xuXG5cdFx0Ly8gUnVuIHRoZSB0aW1lciBhbmQgc2FmZWx5IHJlbW92ZSBpdCB3aGVuIGRvbmUgKGFsbG93aW5nIGZvciBleHRlcm5hbCByZW1vdmFsKVxuXHRcdGlmICggIXRpbWVyKCkgJiYgdGltZXJzWyBpIF0gPT09IHRpbWVyICkge1xuXHRcdFx0dGltZXJzLnNwbGljZSggaS0tLCAxICk7XG5cdFx0fVxuXHR9XG5cblx0aWYgKCAhdGltZXJzLmxlbmd0aCApIHtcblx0XHRqUXVlcnkuZnguc3RvcCgpO1xuXHR9XG5cdGZ4Tm93ID0gdW5kZWZpbmVkO1xufTtcblxualF1ZXJ5LmZ4LnRpbWVyID0gZnVuY3Rpb24oIHRpbWVyICkge1xuXHRqUXVlcnkudGltZXJzLnB1c2goIHRpbWVyICk7XG5cdGpRdWVyeS5meC5zdGFydCgpO1xufTtcblxualF1ZXJ5LmZ4LmludGVydmFsID0gMTM7XG5qUXVlcnkuZnguc3RhcnQgPSBmdW5jdGlvbigpIHtcblx0aWYgKCBpblByb2dyZXNzICkge1xuXHRcdHJldHVybjtcblx0fVxuXG5cdGluUHJvZ3Jlc3MgPSB0cnVlO1xuXHRzY2hlZHVsZSgpO1xufTtcblxualF1ZXJ5LmZ4LnN0b3AgPSBmdW5jdGlvbigpIHtcblx0aW5Qcm9ncmVzcyA9IG51bGw7XG59O1xuXG5qUXVlcnkuZnguc3BlZWRzID0ge1xuXHRzbG93OiA2MDAsXG5cdGZhc3Q6IDIwMCxcblxuXHQvLyBEZWZhdWx0IHNwZWVkXG5cdF9kZWZhdWx0OiA0MDBcbn07XG5cblxuLy8gQmFzZWQgb2ZmIG9mIHRoZSBwbHVnaW4gYnkgQ2xpbnQgSGVsZmVycywgd2l0aCBwZXJtaXNzaW9uLlxuLy8gaHR0cHM6Ly93ZWIuYXJjaGl2ZS5vcmcvd2ViLzIwMTAwMzI0MDE0NzQ3L2h0dHA6Ly9ibGluZHNpZ25hbHMuY29tL2luZGV4LnBocC8yMDA5LzA3L2pxdWVyeS1kZWxheS9cbmpRdWVyeS5mbi5kZWxheSA9IGZ1bmN0aW9uKCB0aW1lLCB0eXBlICkge1xuXHR0aW1lID0galF1ZXJ5LmZ4ID8galF1ZXJ5LmZ4LnNwZWVkc1sgdGltZSBdIHx8IHRpbWUgOiB0aW1lO1xuXHR0eXBlID0gdHlwZSB8fCBcImZ4XCI7XG5cblx0cmV0dXJuIHRoaXMucXVldWUoIHR5cGUsIGZ1bmN0aW9uKCBuZXh0LCBob29rcyApIHtcblx0XHR2YXIgdGltZW91dCA9IHdpbmRvdy5zZXRUaW1lb3V0KCBuZXh0LCB0aW1lICk7XG5cdFx0aG9va3Muc3RvcCA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0d2luZG93LmNsZWFyVGltZW91dCggdGltZW91dCApO1xuXHRcdH07XG5cdH0gKTtcbn07XG5cblxuKCBmdW5jdGlvbigpIHtcblx0dmFyIGlucHV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJpbnB1dFwiICksXG5cdFx0c2VsZWN0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJzZWxlY3RcIiApLFxuXHRcdG9wdCA9IHNlbGVjdC5hcHBlbmRDaGlsZCggZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJvcHRpb25cIiApICk7XG5cblx0aW5wdXQudHlwZSA9IFwiY2hlY2tib3hcIjtcblxuXHQvLyBTdXBwb3J0OiBBbmRyb2lkIDw9NC4zIG9ubHlcblx0Ly8gRGVmYXVsdCB2YWx1ZSBmb3IgYSBjaGVja2JveCBzaG91bGQgYmUgXCJvblwiXG5cdHN1cHBvcnQuY2hlY2tPbiA9IGlucHV0LnZhbHVlICE9PSBcIlwiO1xuXG5cdC8vIFN1cHBvcnQ6IElFIDw9MTEgb25seVxuXHQvLyBNdXN0IGFjY2VzcyBzZWxlY3RlZEluZGV4IHRvIG1ha2UgZGVmYXVsdCBvcHRpb25zIHNlbGVjdFxuXHRzdXBwb3J0Lm9wdFNlbGVjdGVkID0gb3B0LnNlbGVjdGVkO1xuXG5cdC8vIFN1cHBvcnQ6IElFIDw9MTEgb25seVxuXHQvLyBBbiBpbnB1dCBsb3NlcyBpdHMgdmFsdWUgYWZ0ZXIgYmVjb21pbmcgYSByYWRpb1xuXHRpbnB1dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiaW5wdXRcIiApO1xuXHRpbnB1dC52YWx1ZSA9IFwidFwiO1xuXHRpbnB1dC50eXBlID0gXCJyYWRpb1wiO1xuXHRzdXBwb3J0LnJhZGlvVmFsdWUgPSBpbnB1dC52YWx1ZSA9PT0gXCJ0XCI7XG59ICkoKTtcblxuXG52YXIgYm9vbEhvb2ssXG5cdGF0dHJIYW5kbGUgPSBqUXVlcnkuZXhwci5hdHRySGFuZGxlO1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdGF0dHI6IGZ1bmN0aW9uKCBuYW1lLCB2YWx1ZSApIHtcblx0XHRyZXR1cm4gYWNjZXNzKCB0aGlzLCBqUXVlcnkuYXR0ciwgbmFtZSwgdmFsdWUsIGFyZ3VtZW50cy5sZW5ndGggPiAxICk7XG5cdH0sXG5cblx0cmVtb3ZlQXR0cjogZnVuY3Rpb24oIG5hbWUgKSB7XG5cdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRqUXVlcnkucmVtb3ZlQXR0ciggdGhpcywgbmFtZSApO1xuXHRcdH0gKTtcblx0fVxufSApO1xuXG5qUXVlcnkuZXh0ZW5kKCB7XG5cdGF0dHI6IGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCB2YWx1ZSApIHtcblx0XHR2YXIgcmV0LCBob29rcyxcblx0XHRcdG5UeXBlID0gZWxlbS5ub2RlVHlwZTtcblxuXHRcdC8vIERvbid0IGdldC9zZXQgYXR0cmlidXRlcyBvbiB0ZXh0LCBjb21tZW50IGFuZCBhdHRyaWJ1dGUgbm9kZXNcblx0XHRpZiAoIG5UeXBlID09PSAzIHx8IG5UeXBlID09PSA4IHx8IG5UeXBlID09PSAyICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIEZhbGxiYWNrIHRvIHByb3Agd2hlbiBhdHRyaWJ1dGVzIGFyZSBub3Qgc3VwcG9ydGVkXG5cdFx0aWYgKCB0eXBlb2YgZWxlbS5nZXRBdHRyaWJ1dGUgPT09IFwidW5kZWZpbmVkXCIgKSB7XG5cdFx0XHRyZXR1cm4galF1ZXJ5LnByb3AoIGVsZW0sIG5hbWUsIHZhbHVlICk7XG5cdFx0fVxuXG5cdFx0Ly8gQXR0cmlidXRlIGhvb2tzIGFyZSBkZXRlcm1pbmVkIGJ5IHRoZSBsb3dlcmNhc2UgdmVyc2lvblxuXHRcdC8vIEdyYWIgbmVjZXNzYXJ5IGhvb2sgaWYgb25lIGlzIGRlZmluZWRcblx0XHRpZiAoIG5UeXBlICE9PSAxIHx8ICFqUXVlcnkuaXNYTUxEb2MoIGVsZW0gKSApIHtcblx0XHRcdGhvb2tzID0galF1ZXJ5LmF0dHJIb29rc1sgbmFtZS50b0xvd2VyQ2FzZSgpIF0gfHxcblx0XHRcdFx0KCBqUXVlcnkuZXhwci5tYXRjaC5ib29sLnRlc3QoIG5hbWUgKSA/IGJvb2xIb29rIDogdW5kZWZpbmVkICk7XG5cdFx0fVxuXG5cdFx0aWYgKCB2YWx1ZSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0aWYgKCB2YWx1ZSA9PT0gbnVsbCApIHtcblx0XHRcdFx0alF1ZXJ5LnJlbW92ZUF0dHIoIGVsZW0sIG5hbWUgKTtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIGhvb2tzICYmIFwic2V0XCIgaW4gaG9va3MgJiZcblx0XHRcdFx0KCByZXQgPSBob29rcy5zZXQoIGVsZW0sIHZhbHVlLCBuYW1lICkgKSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRyZXR1cm4gcmV0O1xuXHRcdFx0fVxuXG5cdFx0XHRlbGVtLnNldEF0dHJpYnV0ZSggbmFtZSwgdmFsdWUgKyBcIlwiICk7XG5cdFx0XHRyZXR1cm4gdmFsdWU7XG5cdFx0fVxuXG5cdFx0aWYgKCBob29rcyAmJiBcImdldFwiIGluIGhvb2tzICYmICggcmV0ID0gaG9va3MuZ2V0KCBlbGVtLCBuYW1lICkgKSAhPT0gbnVsbCApIHtcblx0XHRcdHJldHVybiByZXQ7XG5cdFx0fVxuXG5cdFx0cmV0ID0galF1ZXJ5LmZpbmQuYXR0ciggZWxlbSwgbmFtZSApO1xuXG5cdFx0Ly8gTm9uLWV4aXN0ZW50IGF0dHJpYnV0ZXMgcmV0dXJuIG51bGwsIHdlIG5vcm1hbGl6ZSB0byB1bmRlZmluZWRcblx0XHRyZXR1cm4gcmV0ID09IG51bGwgPyB1bmRlZmluZWQgOiByZXQ7XG5cdH0sXG5cblx0YXR0ckhvb2tzOiB7XG5cdFx0dHlwZToge1xuXHRcdFx0c2V0OiBmdW5jdGlvbiggZWxlbSwgdmFsdWUgKSB7XG5cdFx0XHRcdGlmICggIXN1cHBvcnQucmFkaW9WYWx1ZSAmJiB2YWx1ZSA9PT0gXCJyYWRpb1wiICYmXG5cdFx0XHRcdFx0bm9kZU5hbWUoIGVsZW0sIFwiaW5wdXRcIiApICkge1xuXHRcdFx0XHRcdHZhciB2YWwgPSBlbGVtLnZhbHVlO1xuXHRcdFx0XHRcdGVsZW0uc2V0QXR0cmlidXRlKCBcInR5cGVcIiwgdmFsdWUgKTtcblx0XHRcdFx0XHRpZiAoIHZhbCApIHtcblx0XHRcdFx0XHRcdGVsZW0udmFsdWUgPSB2YWw7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiB2YWx1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHRyZW1vdmVBdHRyOiBmdW5jdGlvbiggZWxlbSwgdmFsdWUgKSB7XG5cdFx0dmFyIG5hbWUsXG5cdFx0XHRpID0gMCxcblxuXHRcdFx0Ly8gQXR0cmlidXRlIG5hbWVzIGNhbiBjb250YWluIG5vbi1IVE1MIHdoaXRlc3BhY2UgY2hhcmFjdGVyc1xuXHRcdFx0Ly8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjYXR0cmlidXRlcy0yXG5cdFx0XHRhdHRyTmFtZXMgPSB2YWx1ZSAmJiB2YWx1ZS5tYXRjaCggcm5vdGh0bWx3aGl0ZSApO1xuXG5cdFx0aWYgKCBhdHRyTmFtZXMgJiYgZWxlbS5ub2RlVHlwZSA9PT0gMSApIHtcblx0XHRcdHdoaWxlICggKCBuYW1lID0gYXR0ck5hbWVzWyBpKysgXSApICkge1xuXHRcdFx0XHRlbGVtLnJlbW92ZUF0dHJpYnV0ZSggbmFtZSApO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxufSApO1xuXG4vLyBIb29rcyBmb3IgYm9vbGVhbiBhdHRyaWJ1dGVzXG5ib29sSG9vayA9IHtcblx0c2V0OiBmdW5jdGlvbiggZWxlbSwgdmFsdWUsIG5hbWUgKSB7XG5cdFx0aWYgKCB2YWx1ZSA9PT0gZmFsc2UgKSB7XG5cblx0XHRcdC8vIFJlbW92ZSBib29sZWFuIGF0dHJpYnV0ZXMgd2hlbiBzZXQgdG8gZmFsc2Vcblx0XHRcdGpRdWVyeS5yZW1vdmVBdHRyKCBlbGVtLCBuYW1lICk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGVsZW0uc2V0QXR0cmlidXRlKCBuYW1lLCBuYW1lICk7XG5cdFx0fVxuXHRcdHJldHVybiBuYW1lO1xuXHR9XG59O1xuXG5qUXVlcnkuZWFjaCggalF1ZXJ5LmV4cHIubWF0Y2guYm9vbC5zb3VyY2UubWF0Y2goIC9cXHcrL2cgKSwgZnVuY3Rpb24oIF9pLCBuYW1lICkge1xuXHR2YXIgZ2V0dGVyID0gYXR0ckhhbmRsZVsgbmFtZSBdIHx8IGpRdWVyeS5maW5kLmF0dHI7XG5cblx0YXR0ckhhbmRsZVsgbmFtZSBdID0gZnVuY3Rpb24oIGVsZW0sIG5hbWUsIGlzWE1MICkge1xuXHRcdHZhciByZXQsIGhhbmRsZSxcblx0XHRcdGxvd2VyY2FzZU5hbWUgPSBuYW1lLnRvTG93ZXJDYXNlKCk7XG5cblx0XHRpZiAoICFpc1hNTCApIHtcblxuXHRcdFx0Ly8gQXZvaWQgYW4gaW5maW5pdGUgbG9vcCBieSB0ZW1wb3JhcmlseSByZW1vdmluZyB0aGlzIGZ1bmN0aW9uIGZyb20gdGhlIGdldHRlclxuXHRcdFx0aGFuZGxlID0gYXR0ckhhbmRsZVsgbG93ZXJjYXNlTmFtZSBdO1xuXHRcdFx0YXR0ckhhbmRsZVsgbG93ZXJjYXNlTmFtZSBdID0gcmV0O1xuXHRcdFx0cmV0ID0gZ2V0dGVyKCBlbGVtLCBuYW1lLCBpc1hNTCApICE9IG51bGwgP1xuXHRcdFx0XHRsb3dlcmNhc2VOYW1lIDpcblx0XHRcdFx0bnVsbDtcblx0XHRcdGF0dHJIYW5kbGVbIGxvd2VyY2FzZU5hbWUgXSA9IGhhbmRsZTtcblx0XHR9XG5cdFx0cmV0dXJuIHJldDtcblx0fTtcbn0gKTtcblxuXG5cblxudmFyIHJmb2N1c2FibGUgPSAvXig/OmlucHV0fHNlbGVjdHx0ZXh0YXJlYXxidXR0b24pJC9pLFxuXHRyY2xpY2thYmxlID0gL14oPzphfGFyZWEpJC9pO1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdHByb3A6IGZ1bmN0aW9uKCBuYW1lLCB2YWx1ZSApIHtcblx0XHRyZXR1cm4gYWNjZXNzKCB0aGlzLCBqUXVlcnkucHJvcCwgbmFtZSwgdmFsdWUsIGFyZ3VtZW50cy5sZW5ndGggPiAxICk7XG5cdH0sXG5cblx0cmVtb3ZlUHJvcDogZnVuY3Rpb24oIG5hbWUgKSB7XG5cdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRkZWxldGUgdGhpc1sgalF1ZXJ5LnByb3BGaXhbIG5hbWUgXSB8fCBuYW1lIF07XG5cdFx0fSApO1xuXHR9XG59ICk7XG5cbmpRdWVyeS5leHRlbmQoIHtcblx0cHJvcDogZnVuY3Rpb24oIGVsZW0sIG5hbWUsIHZhbHVlICkge1xuXHRcdHZhciByZXQsIGhvb2tzLFxuXHRcdFx0blR5cGUgPSBlbGVtLm5vZGVUeXBlO1xuXG5cdFx0Ly8gRG9uJ3QgZ2V0L3NldCBwcm9wZXJ0aWVzIG9uIHRleHQsIGNvbW1lbnQgYW5kIGF0dHJpYnV0ZSBub2Rlc1xuXHRcdGlmICggblR5cGUgPT09IDMgfHwgblR5cGUgPT09IDggfHwgblR5cGUgPT09IDIgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0aWYgKCBuVHlwZSAhPT0gMSB8fCAhalF1ZXJ5LmlzWE1MRG9jKCBlbGVtICkgKSB7XG5cblx0XHRcdC8vIEZpeCBuYW1lIGFuZCBhdHRhY2ggaG9va3Ncblx0XHRcdG5hbWUgPSBqUXVlcnkucHJvcEZpeFsgbmFtZSBdIHx8IG5hbWU7XG5cdFx0XHRob29rcyA9IGpRdWVyeS5wcm9wSG9va3NbIG5hbWUgXTtcblx0XHR9XG5cblx0XHRpZiAoIHZhbHVlICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRpZiAoIGhvb2tzICYmIFwic2V0XCIgaW4gaG9va3MgJiZcblx0XHRcdFx0KCByZXQgPSBob29rcy5zZXQoIGVsZW0sIHZhbHVlLCBuYW1lICkgKSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRyZXR1cm4gcmV0O1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gKCBlbGVtWyBuYW1lIF0gPSB2YWx1ZSApO1xuXHRcdH1cblxuXHRcdGlmICggaG9va3MgJiYgXCJnZXRcIiBpbiBob29rcyAmJiAoIHJldCA9IGhvb2tzLmdldCggZWxlbSwgbmFtZSApICkgIT09IG51bGwgKSB7XG5cdFx0XHRyZXR1cm4gcmV0O1xuXHRcdH1cblxuXHRcdHJldHVybiBlbGVtWyBuYW1lIF07XG5cdH0sXG5cblx0cHJvcEhvb2tzOiB7XG5cdFx0dGFiSW5kZXg6IHtcblx0XHRcdGdldDogZnVuY3Rpb24oIGVsZW0gKSB7XG5cblx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgPD05IC0gMTEgb25seVxuXHRcdFx0XHQvLyBlbGVtLnRhYkluZGV4IGRvZXNuJ3QgYWx3YXlzIHJldHVybiB0aGVcblx0XHRcdFx0Ly8gY29ycmVjdCB2YWx1ZSB3aGVuIGl0IGhhc24ndCBiZWVuIGV4cGxpY2l0bHkgc2V0XG5cdFx0XHRcdC8vIGh0dHBzOi8vd2ViLmFyY2hpdmUub3JnL3dlYi8yMDE0MTExNjIzMzM0Ny9odHRwOi8vZmx1aWRwcm9qZWN0Lm9yZy9ibG9nLzIwMDgvMDEvMDkvZ2V0dGluZy1zZXR0aW5nLWFuZC1yZW1vdmluZy10YWJpbmRleC12YWx1ZXMtd2l0aC1qYXZhc2NyaXB0L1xuXHRcdFx0XHQvLyBVc2UgcHJvcGVyIGF0dHJpYnV0ZSByZXRyaWV2YWwoIzEyMDcyKVxuXHRcdFx0XHR2YXIgdGFiaW5kZXggPSBqUXVlcnkuZmluZC5hdHRyKCBlbGVtLCBcInRhYmluZGV4XCIgKTtcblxuXHRcdFx0XHRpZiAoIHRhYmluZGV4ICkge1xuXHRcdFx0XHRcdHJldHVybiBwYXJzZUludCggdGFiaW5kZXgsIDEwICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoXG5cdFx0XHRcdFx0cmZvY3VzYWJsZS50ZXN0KCBlbGVtLm5vZGVOYW1lICkgfHxcblx0XHRcdFx0XHRyY2xpY2thYmxlLnRlc3QoIGVsZW0ubm9kZU5hbWUgKSAmJlxuXHRcdFx0XHRcdGVsZW0uaHJlZlxuXHRcdFx0XHQpIHtcblx0XHRcdFx0XHRyZXR1cm4gMDtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiAtMTtcblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblx0cHJvcEZpeDoge1xuXHRcdFwiZm9yXCI6IFwiaHRtbEZvclwiLFxuXHRcdFwiY2xhc3NcIjogXCJjbGFzc05hbWVcIlxuXHR9XG59ICk7XG5cbi8vIFN1cHBvcnQ6IElFIDw9MTEgb25seVxuLy8gQWNjZXNzaW5nIHRoZSBzZWxlY3RlZEluZGV4IHByb3BlcnR5XG4vLyBmb3JjZXMgdGhlIGJyb3dzZXIgdG8gcmVzcGVjdCBzZXR0aW5nIHNlbGVjdGVkXG4vLyBvbiB0aGUgb3B0aW9uXG4vLyBUaGUgZ2V0dGVyIGVuc3VyZXMgYSBkZWZhdWx0IG9wdGlvbiBpcyBzZWxlY3RlZFxuLy8gd2hlbiBpbiBhbiBvcHRncm91cFxuLy8gZXNsaW50IHJ1bGUgXCJuby11bnVzZWQtZXhwcmVzc2lvbnNcIiBpcyBkaXNhYmxlZCBmb3IgdGhpcyBjb2RlXG4vLyBzaW5jZSBpdCBjb25zaWRlcnMgc3VjaCBhY2Nlc3Npb25zIG5vb3BcbmlmICggIXN1cHBvcnQub3B0U2VsZWN0ZWQgKSB7XG5cdGpRdWVyeS5wcm9wSG9va3Muc2VsZWN0ZWQgPSB7XG5cdFx0Z2V0OiBmdW5jdGlvbiggZWxlbSApIHtcblxuXHRcdFx0LyogZXNsaW50IG5vLXVudXNlZC1leHByZXNzaW9uczogXCJvZmZcIiAqL1xuXG5cdFx0XHR2YXIgcGFyZW50ID0gZWxlbS5wYXJlbnROb2RlO1xuXHRcdFx0aWYgKCBwYXJlbnQgJiYgcGFyZW50LnBhcmVudE5vZGUgKSB7XG5cdFx0XHRcdHBhcmVudC5wYXJlbnROb2RlLnNlbGVjdGVkSW5kZXg7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gbnVsbDtcblx0XHR9LFxuXHRcdHNldDogZnVuY3Rpb24oIGVsZW0gKSB7XG5cblx0XHRcdC8qIGVzbGludCBuby11bnVzZWQtZXhwcmVzc2lvbnM6IFwib2ZmXCIgKi9cblxuXHRcdFx0dmFyIHBhcmVudCA9IGVsZW0ucGFyZW50Tm9kZTtcblx0XHRcdGlmICggcGFyZW50ICkge1xuXHRcdFx0XHRwYXJlbnQuc2VsZWN0ZWRJbmRleDtcblxuXHRcdFx0XHRpZiAoIHBhcmVudC5wYXJlbnROb2RlICkge1xuXHRcdFx0XHRcdHBhcmVudC5wYXJlbnROb2RlLnNlbGVjdGVkSW5kZXg7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH07XG59XG5cbmpRdWVyeS5lYWNoKCBbXG5cdFwidGFiSW5kZXhcIixcblx0XCJyZWFkT25seVwiLFxuXHRcIm1heExlbmd0aFwiLFxuXHRcImNlbGxTcGFjaW5nXCIsXG5cdFwiY2VsbFBhZGRpbmdcIixcblx0XCJyb3dTcGFuXCIsXG5cdFwiY29sU3BhblwiLFxuXHRcInVzZU1hcFwiLFxuXHRcImZyYW1lQm9yZGVyXCIsXG5cdFwiY29udGVudEVkaXRhYmxlXCJcbl0sIGZ1bmN0aW9uKCkge1xuXHRqUXVlcnkucHJvcEZpeFsgdGhpcy50b0xvd2VyQ2FzZSgpIF0gPSB0aGlzO1xufSApO1xuXG5cblxuXG5cdC8vIFN0cmlwIGFuZCBjb2xsYXBzZSB3aGl0ZXNwYWNlIGFjY29yZGluZyB0byBIVE1MIHNwZWNcblx0Ly8gaHR0cHM6Ly9pbmZyYS5zcGVjLndoYXR3Zy5vcmcvI3N0cmlwLWFuZC1jb2xsYXBzZS1hc2NpaS13aGl0ZXNwYWNlXG5cdGZ1bmN0aW9uIHN0cmlwQW5kQ29sbGFwc2UoIHZhbHVlICkge1xuXHRcdHZhciB0b2tlbnMgPSB2YWx1ZS5tYXRjaCggcm5vdGh0bWx3aGl0ZSApIHx8IFtdO1xuXHRcdHJldHVybiB0b2tlbnMuam9pbiggXCIgXCIgKTtcblx0fVxuXG5cbmZ1bmN0aW9uIGdldENsYXNzKCBlbGVtICkge1xuXHRyZXR1cm4gZWxlbS5nZXRBdHRyaWJ1dGUgJiYgZWxlbS5nZXRBdHRyaWJ1dGUoIFwiY2xhc3NcIiApIHx8IFwiXCI7XG59XG5cbmZ1bmN0aW9uIGNsYXNzZXNUb0FycmF5KCB2YWx1ZSApIHtcblx0aWYgKCBBcnJheS5pc0FycmF5KCB2YWx1ZSApICkge1xuXHRcdHJldHVybiB2YWx1ZTtcblx0fVxuXHRpZiAoIHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHRyZXR1cm4gdmFsdWUubWF0Y2goIHJub3RodG1sd2hpdGUgKSB8fCBbXTtcblx0fVxuXHRyZXR1cm4gW107XG59XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0YWRkQ2xhc3M6IGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHR2YXIgY2xhc3NlcywgZWxlbSwgY3VyLCBjdXJWYWx1ZSwgY2xhenosIGosIGZpbmFsVmFsdWUsXG5cdFx0XHRpID0gMDtcblxuXHRcdGlmICggaXNGdW5jdGlvbiggdmFsdWUgKSApIHtcblx0XHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCBqICkge1xuXHRcdFx0XHRqUXVlcnkoIHRoaXMgKS5hZGRDbGFzcyggdmFsdWUuY2FsbCggdGhpcywgaiwgZ2V0Q2xhc3MoIHRoaXMgKSApICk7XG5cdFx0XHR9ICk7XG5cdFx0fVxuXG5cdFx0Y2xhc3NlcyA9IGNsYXNzZXNUb0FycmF5KCB2YWx1ZSApO1xuXG5cdFx0aWYgKCBjbGFzc2VzLmxlbmd0aCApIHtcblx0XHRcdHdoaWxlICggKCBlbGVtID0gdGhpc1sgaSsrIF0gKSApIHtcblx0XHRcdFx0Y3VyVmFsdWUgPSBnZXRDbGFzcyggZWxlbSApO1xuXHRcdFx0XHRjdXIgPSBlbGVtLm5vZGVUeXBlID09PSAxICYmICggXCIgXCIgKyBzdHJpcEFuZENvbGxhcHNlKCBjdXJWYWx1ZSApICsgXCIgXCIgKTtcblxuXHRcdFx0XHRpZiAoIGN1ciApIHtcblx0XHRcdFx0XHRqID0gMDtcblx0XHRcdFx0XHR3aGlsZSAoICggY2xhenogPSBjbGFzc2VzWyBqKysgXSApICkge1xuXHRcdFx0XHRcdFx0aWYgKCBjdXIuaW5kZXhPZiggXCIgXCIgKyBjbGF6eiArIFwiIFwiICkgPCAwICkge1xuXHRcdFx0XHRcdFx0XHRjdXIgKz0gY2xhenogKyBcIiBcIjtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBPbmx5IGFzc2lnbiBpZiBkaWZmZXJlbnQgdG8gYXZvaWQgdW5uZWVkZWQgcmVuZGVyaW5nLlxuXHRcdFx0XHRcdGZpbmFsVmFsdWUgPSBzdHJpcEFuZENvbGxhcHNlKCBjdXIgKTtcblx0XHRcdFx0XHRpZiAoIGN1clZhbHVlICE9PSBmaW5hbFZhbHVlICkge1xuXHRcdFx0XHRcdFx0ZWxlbS5zZXRBdHRyaWJ1dGUoIFwiY2xhc3NcIiwgZmluYWxWYWx1ZSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdHJlbW92ZUNsYXNzOiBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0dmFyIGNsYXNzZXMsIGVsZW0sIGN1ciwgY3VyVmFsdWUsIGNsYXp6LCBqLCBmaW5hbFZhbHVlLFxuXHRcdFx0aSA9IDA7XG5cblx0XHRpZiAoIGlzRnVuY3Rpb24oIHZhbHVlICkgKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbiggaiApIHtcblx0XHRcdFx0alF1ZXJ5KCB0aGlzICkucmVtb3ZlQ2xhc3MoIHZhbHVlLmNhbGwoIHRoaXMsIGosIGdldENsYXNzKCB0aGlzICkgKSApO1xuXHRcdFx0fSApO1xuXHRcdH1cblxuXHRcdGlmICggIWFyZ3VtZW50cy5sZW5ndGggKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5hdHRyKCBcImNsYXNzXCIsIFwiXCIgKTtcblx0XHR9XG5cblx0XHRjbGFzc2VzID0gY2xhc3Nlc1RvQXJyYXkoIHZhbHVlICk7XG5cblx0XHRpZiAoIGNsYXNzZXMubGVuZ3RoICkge1xuXHRcdFx0d2hpbGUgKCAoIGVsZW0gPSB0aGlzWyBpKysgXSApICkge1xuXHRcdFx0XHRjdXJWYWx1ZSA9IGdldENsYXNzKCBlbGVtICk7XG5cblx0XHRcdFx0Ly8gVGhpcyBleHByZXNzaW9uIGlzIGhlcmUgZm9yIGJldHRlciBjb21wcmVzc2liaWxpdHkgKHNlZSBhZGRDbGFzcylcblx0XHRcdFx0Y3VyID0gZWxlbS5ub2RlVHlwZSA9PT0gMSAmJiAoIFwiIFwiICsgc3RyaXBBbmRDb2xsYXBzZSggY3VyVmFsdWUgKSArIFwiIFwiICk7XG5cblx0XHRcdFx0aWYgKCBjdXIgKSB7XG5cdFx0XHRcdFx0aiA9IDA7XG5cdFx0XHRcdFx0d2hpbGUgKCAoIGNsYXp6ID0gY2xhc3Nlc1sgaisrIF0gKSApIHtcblxuXHRcdFx0XHRcdFx0Ly8gUmVtb3ZlICphbGwqIGluc3RhbmNlc1xuXHRcdFx0XHRcdFx0d2hpbGUgKCBjdXIuaW5kZXhPZiggXCIgXCIgKyBjbGF6eiArIFwiIFwiICkgPiAtMSApIHtcblx0XHRcdFx0XHRcdFx0Y3VyID0gY3VyLnJlcGxhY2UoIFwiIFwiICsgY2xhenogKyBcIiBcIiwgXCIgXCIgKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBPbmx5IGFzc2lnbiBpZiBkaWZmZXJlbnQgdG8gYXZvaWQgdW5uZWVkZWQgcmVuZGVyaW5nLlxuXHRcdFx0XHRcdGZpbmFsVmFsdWUgPSBzdHJpcEFuZENvbGxhcHNlKCBjdXIgKTtcblx0XHRcdFx0XHRpZiAoIGN1clZhbHVlICE9PSBmaW5hbFZhbHVlICkge1xuXHRcdFx0XHRcdFx0ZWxlbS5zZXRBdHRyaWJ1dGUoIFwiY2xhc3NcIiwgZmluYWxWYWx1ZSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdHRvZ2dsZUNsYXNzOiBmdW5jdGlvbiggdmFsdWUsIHN0YXRlVmFsICkge1xuXHRcdHZhciB0eXBlID0gdHlwZW9mIHZhbHVlLFxuXHRcdFx0aXNWYWxpZFZhbHVlID0gdHlwZSA9PT0gXCJzdHJpbmdcIiB8fCBBcnJheS5pc0FycmF5KCB2YWx1ZSApO1xuXG5cdFx0aWYgKCB0eXBlb2Ygc3RhdGVWYWwgPT09IFwiYm9vbGVhblwiICYmIGlzVmFsaWRWYWx1ZSApIHtcblx0XHRcdHJldHVybiBzdGF0ZVZhbCA/IHRoaXMuYWRkQ2xhc3MoIHZhbHVlICkgOiB0aGlzLnJlbW92ZUNsYXNzKCB2YWx1ZSApO1xuXHRcdH1cblxuXHRcdGlmICggaXNGdW5jdGlvbiggdmFsdWUgKSApIHtcblx0XHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCBpICkge1xuXHRcdFx0XHRqUXVlcnkoIHRoaXMgKS50b2dnbGVDbGFzcyhcblx0XHRcdFx0XHR2YWx1ZS5jYWxsKCB0aGlzLCBpLCBnZXRDbGFzcyggdGhpcyApLCBzdGF0ZVZhbCApLFxuXHRcdFx0XHRcdHN0YXRlVmFsXG5cdFx0XHRcdCk7XG5cdFx0XHR9ICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgY2xhc3NOYW1lLCBpLCBzZWxmLCBjbGFzc05hbWVzO1xuXG5cdFx0XHRpZiAoIGlzVmFsaWRWYWx1ZSApIHtcblxuXHRcdFx0XHQvLyBUb2dnbGUgaW5kaXZpZHVhbCBjbGFzcyBuYW1lc1xuXHRcdFx0XHRpID0gMDtcblx0XHRcdFx0c2VsZiA9IGpRdWVyeSggdGhpcyApO1xuXHRcdFx0XHRjbGFzc05hbWVzID0gY2xhc3Nlc1RvQXJyYXkoIHZhbHVlICk7XG5cblx0XHRcdFx0d2hpbGUgKCAoIGNsYXNzTmFtZSA9IGNsYXNzTmFtZXNbIGkrKyBdICkgKSB7XG5cblx0XHRcdFx0XHQvLyBDaGVjayBlYWNoIGNsYXNzTmFtZSBnaXZlbiwgc3BhY2Ugc2VwYXJhdGVkIGxpc3Rcblx0XHRcdFx0XHRpZiAoIHNlbGYuaGFzQ2xhc3MoIGNsYXNzTmFtZSApICkge1xuXHRcdFx0XHRcdFx0c2VsZi5yZW1vdmVDbGFzcyggY2xhc3NOYW1lICk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHNlbGYuYWRkQ2xhc3MoIGNsYXNzTmFtZSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHQvLyBUb2dnbGUgd2hvbGUgY2xhc3MgbmFtZVxuXHRcdFx0fSBlbHNlIGlmICggdmFsdWUgPT09IHVuZGVmaW5lZCB8fCB0eXBlID09PSBcImJvb2xlYW5cIiApIHtcblx0XHRcdFx0Y2xhc3NOYW1lID0gZ2V0Q2xhc3MoIHRoaXMgKTtcblx0XHRcdFx0aWYgKCBjbGFzc05hbWUgKSB7XG5cblx0XHRcdFx0XHQvLyBTdG9yZSBjbGFzc05hbWUgaWYgc2V0XG5cdFx0XHRcdFx0ZGF0YVByaXYuc2V0KCB0aGlzLCBcIl9fY2xhc3NOYW1lX19cIiwgY2xhc3NOYW1lICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBJZiB0aGUgZWxlbWVudCBoYXMgYSBjbGFzcyBuYW1lIG9yIGlmIHdlJ3JlIHBhc3NlZCBgZmFsc2VgLFxuXHRcdFx0XHQvLyB0aGVuIHJlbW92ZSB0aGUgd2hvbGUgY2xhc3NuYW1lIChpZiB0aGVyZSB3YXMgb25lLCB0aGUgYWJvdmUgc2F2ZWQgaXQpLlxuXHRcdFx0XHQvLyBPdGhlcndpc2UgYnJpbmcgYmFjayB3aGF0ZXZlciB3YXMgcHJldmlvdXNseSBzYXZlZCAoaWYgYW55dGhpbmcpLFxuXHRcdFx0XHQvLyBmYWxsaW5nIGJhY2sgdG8gdGhlIGVtcHR5IHN0cmluZyBpZiBub3RoaW5nIHdhcyBzdG9yZWQuXG5cdFx0XHRcdGlmICggdGhpcy5zZXRBdHRyaWJ1dGUgKSB7XG5cdFx0XHRcdFx0dGhpcy5zZXRBdHRyaWJ1dGUoIFwiY2xhc3NcIixcblx0XHRcdFx0XHRcdGNsYXNzTmFtZSB8fCB2YWx1ZSA9PT0gZmFsc2UgP1xuXHRcdFx0XHRcdFx0XHRcIlwiIDpcblx0XHRcdFx0XHRcdFx0ZGF0YVByaXYuZ2V0KCB0aGlzLCBcIl9fY2xhc3NOYW1lX19cIiApIHx8IFwiXCJcblx0XHRcdFx0XHQpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSApO1xuXHR9LFxuXG5cdGhhc0NsYXNzOiBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0dmFyIGNsYXNzTmFtZSwgZWxlbSxcblx0XHRcdGkgPSAwO1xuXG5cdFx0Y2xhc3NOYW1lID0gXCIgXCIgKyBzZWxlY3RvciArIFwiIFwiO1xuXHRcdHdoaWxlICggKCBlbGVtID0gdGhpc1sgaSsrIF0gKSApIHtcblx0XHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSAmJlxuXHRcdFx0XHQoIFwiIFwiICsgc3RyaXBBbmRDb2xsYXBzZSggZ2V0Q2xhc3MoIGVsZW0gKSApICsgXCIgXCIgKS5pbmRleE9mKCBjbGFzc05hbWUgKSA+IC0xICkge1xuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cbn0gKTtcblxuXG5cblxudmFyIHJyZXR1cm4gPSAvXFxyL2c7XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0dmFsOiBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0dmFyIGhvb2tzLCByZXQsIHZhbHVlSXNGdW5jdGlvbixcblx0XHRcdGVsZW0gPSB0aGlzWyAwIF07XG5cblx0XHRpZiAoICFhcmd1bWVudHMubGVuZ3RoICkge1xuXHRcdFx0aWYgKCBlbGVtICkge1xuXHRcdFx0XHRob29rcyA9IGpRdWVyeS52YWxIb29rc1sgZWxlbS50eXBlIF0gfHxcblx0XHRcdFx0XHRqUXVlcnkudmFsSG9va3NbIGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSBdO1xuXG5cdFx0XHRcdGlmICggaG9va3MgJiZcblx0XHRcdFx0XHRcImdldFwiIGluIGhvb2tzICYmXG5cdFx0XHRcdFx0KCByZXQgPSBob29rcy5nZXQoIGVsZW0sIFwidmFsdWVcIiApICkgIT09IHVuZGVmaW5lZFxuXHRcdFx0XHQpIHtcblx0XHRcdFx0XHRyZXR1cm4gcmV0O1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0ID0gZWxlbS52YWx1ZTtcblxuXHRcdFx0XHQvLyBIYW5kbGUgbW9zdCBjb21tb24gc3RyaW5nIGNhc2VzXG5cdFx0XHRcdGlmICggdHlwZW9mIHJldCA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdFx0XHRyZXR1cm4gcmV0LnJlcGxhY2UoIHJyZXR1cm4sIFwiXCIgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIEhhbmRsZSBjYXNlcyB3aGVyZSB2YWx1ZSBpcyBudWxsL3VuZGVmIG9yIG51bWJlclxuXHRcdFx0XHRyZXR1cm4gcmV0ID09IG51bGwgPyBcIlwiIDogcmV0O1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0dmFsdWVJc0Z1bmN0aW9uID0gaXNGdW5jdGlvbiggdmFsdWUgKTtcblxuXHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCBpICkge1xuXHRcdFx0dmFyIHZhbDtcblxuXHRcdFx0aWYgKCB0aGlzLm5vZGVUeXBlICE9PSAxICkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdGlmICggdmFsdWVJc0Z1bmN0aW9uICkge1xuXHRcdFx0XHR2YWwgPSB2YWx1ZS5jYWxsKCB0aGlzLCBpLCBqUXVlcnkoIHRoaXMgKS52YWwoKSApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dmFsID0gdmFsdWU7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFRyZWF0IG51bGwvdW5kZWZpbmVkIGFzIFwiXCI7IGNvbnZlcnQgbnVtYmVycyB0byBzdHJpbmdcblx0XHRcdGlmICggdmFsID09IG51bGwgKSB7XG5cdFx0XHRcdHZhbCA9IFwiXCI7XG5cblx0XHRcdH0gZWxzZSBpZiAoIHR5cGVvZiB2YWwgPT09IFwibnVtYmVyXCIgKSB7XG5cdFx0XHRcdHZhbCArPSBcIlwiO1xuXG5cdFx0XHR9IGVsc2UgaWYgKCBBcnJheS5pc0FycmF5KCB2YWwgKSApIHtcblx0XHRcdFx0dmFsID0galF1ZXJ5Lm1hcCggdmFsLCBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHZhbHVlID09IG51bGwgPyBcIlwiIDogdmFsdWUgKyBcIlwiO1xuXHRcdFx0XHR9ICk7XG5cdFx0XHR9XG5cblx0XHRcdGhvb2tzID0galF1ZXJ5LnZhbEhvb2tzWyB0aGlzLnR5cGUgXSB8fCBqUXVlcnkudmFsSG9va3NbIHRoaXMubm9kZU5hbWUudG9Mb3dlckNhc2UoKSBdO1xuXG5cdFx0XHQvLyBJZiBzZXQgcmV0dXJucyB1bmRlZmluZWQsIGZhbGwgYmFjayB0byBub3JtYWwgc2V0dGluZ1xuXHRcdFx0aWYgKCAhaG9va3MgfHwgISggXCJzZXRcIiBpbiBob29rcyApIHx8IGhvb2tzLnNldCggdGhpcywgdmFsLCBcInZhbHVlXCIgKSA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHR0aGlzLnZhbHVlID0gdmFsO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0fVxufSApO1xuXG5qUXVlcnkuZXh0ZW5kKCB7XG5cdHZhbEhvb2tzOiB7XG5cdFx0b3B0aW9uOiB7XG5cdFx0XHRnZXQ6IGZ1bmN0aW9uKCBlbGVtICkge1xuXG5cdFx0XHRcdHZhciB2YWwgPSBqUXVlcnkuZmluZC5hdHRyKCBlbGVtLCBcInZhbHVlXCIgKTtcblx0XHRcdFx0cmV0dXJuIHZhbCAhPSBudWxsID9cblx0XHRcdFx0XHR2YWwgOlxuXG5cdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgPD0xMCAtIDExIG9ubHlcblx0XHRcdFx0XHQvLyBvcHRpb24udGV4dCB0aHJvd3MgZXhjZXB0aW9ucyAoIzE0Njg2LCAjMTQ4NTgpXG5cdFx0XHRcdFx0Ly8gU3RyaXAgYW5kIGNvbGxhcHNlIHdoaXRlc3BhY2Vcblx0XHRcdFx0XHQvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnLyNzdHJpcC1hbmQtY29sbGFwc2Utd2hpdGVzcGFjZVxuXHRcdFx0XHRcdHN0cmlwQW5kQ29sbGFwc2UoIGpRdWVyeS50ZXh0KCBlbGVtICkgKTtcblx0XHRcdH1cblx0XHR9LFxuXHRcdHNlbGVjdDoge1xuXHRcdFx0Z2V0OiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0dmFyIHZhbHVlLCBvcHRpb24sIGksXG5cdFx0XHRcdFx0b3B0aW9ucyA9IGVsZW0ub3B0aW9ucyxcblx0XHRcdFx0XHRpbmRleCA9IGVsZW0uc2VsZWN0ZWRJbmRleCxcblx0XHRcdFx0XHRvbmUgPSBlbGVtLnR5cGUgPT09IFwic2VsZWN0LW9uZVwiLFxuXHRcdFx0XHRcdHZhbHVlcyA9IG9uZSA/IG51bGwgOiBbXSxcblx0XHRcdFx0XHRtYXggPSBvbmUgPyBpbmRleCArIDEgOiBvcHRpb25zLmxlbmd0aDtcblxuXHRcdFx0XHRpZiAoIGluZGV4IDwgMCApIHtcblx0XHRcdFx0XHRpID0gbWF4O1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0aSA9IG9uZSA/IGluZGV4IDogMDtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIExvb3AgdGhyb3VnaCBhbGwgdGhlIHNlbGVjdGVkIG9wdGlvbnNcblx0XHRcdFx0Zm9yICggOyBpIDwgbWF4OyBpKysgKSB7XG5cdFx0XHRcdFx0b3B0aW9uID0gb3B0aW9uc1sgaSBdO1xuXG5cdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgPD05IG9ubHlcblx0XHRcdFx0XHQvLyBJRTgtOSBkb2Vzbid0IHVwZGF0ZSBzZWxlY3RlZCBhZnRlciBmb3JtIHJlc2V0ICgjMjU1MSlcblx0XHRcdFx0XHRpZiAoICggb3B0aW9uLnNlbGVjdGVkIHx8IGkgPT09IGluZGV4ICkgJiZcblxuXHRcdFx0XHRcdFx0XHQvLyBEb24ndCByZXR1cm4gb3B0aW9ucyB0aGF0IGFyZSBkaXNhYmxlZCBvciBpbiBhIGRpc2FibGVkIG9wdGdyb3VwXG5cdFx0XHRcdFx0XHRcdCFvcHRpb24uZGlzYWJsZWQgJiZcblx0XHRcdFx0XHRcdFx0KCAhb3B0aW9uLnBhcmVudE5vZGUuZGlzYWJsZWQgfHxcblx0XHRcdFx0XHRcdFx0XHQhbm9kZU5hbWUoIG9wdGlvbi5wYXJlbnROb2RlLCBcIm9wdGdyb3VwXCIgKSApICkge1xuXG5cdFx0XHRcdFx0XHQvLyBHZXQgdGhlIHNwZWNpZmljIHZhbHVlIGZvciB0aGUgb3B0aW9uXG5cdFx0XHRcdFx0XHR2YWx1ZSA9IGpRdWVyeSggb3B0aW9uICkudmFsKCk7XG5cblx0XHRcdFx0XHRcdC8vIFdlIGRvbid0IG5lZWQgYW4gYXJyYXkgZm9yIG9uZSBzZWxlY3RzXG5cdFx0XHRcdFx0XHRpZiAoIG9uZSApIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIHZhbHVlO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHQvLyBNdWx0aS1TZWxlY3RzIHJldHVybiBhbiBhcnJheVxuXHRcdFx0XHRcdFx0dmFsdWVzLnB1c2goIHZhbHVlICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIHZhbHVlcztcblx0XHRcdH0sXG5cblx0XHRcdHNldDogZnVuY3Rpb24oIGVsZW0sIHZhbHVlICkge1xuXHRcdFx0XHR2YXIgb3B0aW9uU2V0LCBvcHRpb24sXG5cdFx0XHRcdFx0b3B0aW9ucyA9IGVsZW0ub3B0aW9ucyxcblx0XHRcdFx0XHR2YWx1ZXMgPSBqUXVlcnkubWFrZUFycmF5KCB2YWx1ZSApLFxuXHRcdFx0XHRcdGkgPSBvcHRpb25zLmxlbmd0aDtcblxuXHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0XHRvcHRpb24gPSBvcHRpb25zWyBpIF07XG5cblx0XHRcdFx0XHQvKiBlc2xpbnQtZGlzYWJsZSBuby1jb25kLWFzc2lnbiAqL1xuXG5cdFx0XHRcdFx0aWYgKCBvcHRpb24uc2VsZWN0ZWQgPVxuXHRcdFx0XHRcdFx0alF1ZXJ5LmluQXJyYXkoIGpRdWVyeS52YWxIb29rcy5vcHRpb24uZ2V0KCBvcHRpb24gKSwgdmFsdWVzICkgPiAtMVxuXHRcdFx0XHRcdCkge1xuXHRcdFx0XHRcdFx0b3B0aW9uU2V0ID0gdHJ1ZTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvKiBlc2xpbnQtZW5hYmxlIG5vLWNvbmQtYXNzaWduICovXG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBGb3JjZSBicm93c2VycyB0byBiZWhhdmUgY29uc2lzdGVudGx5IHdoZW4gbm9uLW1hdGNoaW5nIHZhbHVlIGlzIHNldFxuXHRcdFx0XHRpZiAoICFvcHRpb25TZXQgKSB7XG5cdFx0XHRcdFx0ZWxlbS5zZWxlY3RlZEluZGV4ID0gLTE7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHZhbHVlcztcblx0XHRcdH1cblx0XHR9XG5cdH1cbn0gKTtcblxuLy8gUmFkaW9zIGFuZCBjaGVja2JveGVzIGdldHRlci9zZXR0ZXJcbmpRdWVyeS5lYWNoKCBbIFwicmFkaW9cIiwgXCJjaGVja2JveFwiIF0sIGZ1bmN0aW9uKCkge1xuXHRqUXVlcnkudmFsSG9va3NbIHRoaXMgXSA9IHtcblx0XHRzZXQ6IGZ1bmN0aW9uKCBlbGVtLCB2YWx1ZSApIHtcblx0XHRcdGlmICggQXJyYXkuaXNBcnJheSggdmFsdWUgKSApIHtcblx0XHRcdFx0cmV0dXJuICggZWxlbS5jaGVja2VkID0galF1ZXJ5LmluQXJyYXkoIGpRdWVyeSggZWxlbSApLnZhbCgpLCB2YWx1ZSApID4gLTEgKTtcblx0XHRcdH1cblx0XHR9XG5cdH07XG5cdGlmICggIXN1cHBvcnQuY2hlY2tPbiApIHtcblx0XHRqUXVlcnkudmFsSG9va3NbIHRoaXMgXS5nZXQgPSBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiBlbGVtLmdldEF0dHJpYnV0ZSggXCJ2YWx1ZVwiICkgPT09IG51bGwgPyBcIm9uXCIgOiBlbGVtLnZhbHVlO1xuXHRcdH07XG5cdH1cbn0gKTtcblxuXG5cblxuLy8gUmV0dXJuIGpRdWVyeSBmb3IgYXR0cmlidXRlcy1vbmx5IGluY2x1c2lvblxuXG5cbnN1cHBvcnQuZm9jdXNpbiA9IFwib25mb2N1c2luXCIgaW4gd2luZG93O1xuXG5cbnZhciByZm9jdXNNb3JwaCA9IC9eKD86Zm9jdXNpbmZvY3VzfGZvY3Vzb3V0Ymx1cikkLyxcblx0c3RvcFByb3BhZ2F0aW9uQ2FsbGJhY2sgPSBmdW5jdGlvbiggZSApIHtcblx0XHRlLnN0b3BQcm9wYWdhdGlvbigpO1xuXHR9O1xuXG5qUXVlcnkuZXh0ZW5kKCBqUXVlcnkuZXZlbnQsIHtcblxuXHR0cmlnZ2VyOiBmdW5jdGlvbiggZXZlbnQsIGRhdGEsIGVsZW0sIG9ubHlIYW5kbGVycyApIHtcblxuXHRcdHZhciBpLCBjdXIsIHRtcCwgYnViYmxlVHlwZSwgb250eXBlLCBoYW5kbGUsIHNwZWNpYWwsIGxhc3RFbGVtZW50LFxuXHRcdFx0ZXZlbnRQYXRoID0gWyBlbGVtIHx8IGRvY3VtZW50IF0sXG5cdFx0XHR0eXBlID0gaGFzT3duLmNhbGwoIGV2ZW50LCBcInR5cGVcIiApID8gZXZlbnQudHlwZSA6IGV2ZW50LFxuXHRcdFx0bmFtZXNwYWNlcyA9IGhhc093bi5jYWxsKCBldmVudCwgXCJuYW1lc3BhY2VcIiApID8gZXZlbnQubmFtZXNwYWNlLnNwbGl0KCBcIi5cIiApIDogW107XG5cblx0XHRjdXIgPSBsYXN0RWxlbWVudCA9IHRtcCA9IGVsZW0gPSBlbGVtIHx8IGRvY3VtZW50O1xuXG5cdFx0Ly8gRG9uJ3QgZG8gZXZlbnRzIG9uIHRleHQgYW5kIGNvbW1lbnQgbm9kZXNcblx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDMgfHwgZWxlbS5ub2RlVHlwZSA9PT0gOCApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBmb2N1cy9ibHVyIG1vcnBocyB0byBmb2N1c2luL291dDsgZW5zdXJlIHdlJ3JlIG5vdCBmaXJpbmcgdGhlbSByaWdodCBub3dcblx0XHRpZiAoIHJmb2N1c01vcnBoLnRlc3QoIHR5cGUgKyBqUXVlcnkuZXZlbnQudHJpZ2dlcmVkICkgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0aWYgKCB0eXBlLmluZGV4T2YoIFwiLlwiICkgPiAtMSApIHtcblxuXHRcdFx0Ly8gTmFtZXNwYWNlZCB0cmlnZ2VyOyBjcmVhdGUgYSByZWdleHAgdG8gbWF0Y2ggZXZlbnQgdHlwZSBpbiBoYW5kbGUoKVxuXHRcdFx0bmFtZXNwYWNlcyA9IHR5cGUuc3BsaXQoIFwiLlwiICk7XG5cdFx0XHR0eXBlID0gbmFtZXNwYWNlcy5zaGlmdCgpO1xuXHRcdFx0bmFtZXNwYWNlcy5zb3J0KCk7XG5cdFx0fVxuXHRcdG9udHlwZSA9IHR5cGUuaW5kZXhPZiggXCI6XCIgKSA8IDAgJiYgXCJvblwiICsgdHlwZTtcblxuXHRcdC8vIENhbGxlciBjYW4gcGFzcyBpbiBhIGpRdWVyeS5FdmVudCBvYmplY3QsIE9iamVjdCwgb3IganVzdCBhbiBldmVudCB0eXBlIHN0cmluZ1xuXHRcdGV2ZW50ID0gZXZlbnRbIGpRdWVyeS5leHBhbmRvIF0gP1xuXHRcdFx0ZXZlbnQgOlxuXHRcdFx0bmV3IGpRdWVyeS5FdmVudCggdHlwZSwgdHlwZW9mIGV2ZW50ID09PSBcIm9iamVjdFwiICYmIGV2ZW50ICk7XG5cblx0XHQvLyBUcmlnZ2VyIGJpdG1hc2s6ICYgMSBmb3IgbmF0aXZlIGhhbmRsZXJzOyAmIDIgZm9yIGpRdWVyeSAoYWx3YXlzIHRydWUpXG5cdFx0ZXZlbnQuaXNUcmlnZ2VyID0gb25seUhhbmRsZXJzID8gMiA6IDM7XG5cdFx0ZXZlbnQubmFtZXNwYWNlID0gbmFtZXNwYWNlcy5qb2luKCBcIi5cIiApO1xuXHRcdGV2ZW50LnJuYW1lc3BhY2UgPSBldmVudC5uYW1lc3BhY2UgP1xuXHRcdFx0bmV3IFJlZ0V4cCggXCIoXnxcXFxcLilcIiArIG5hbWVzcGFjZXMuam9pbiggXCJcXFxcLig/Oi4qXFxcXC58KVwiICkgKyBcIihcXFxcLnwkKVwiICkgOlxuXHRcdFx0bnVsbDtcblxuXHRcdC8vIENsZWFuIHVwIHRoZSBldmVudCBpbiBjYXNlIGl0IGlzIGJlaW5nIHJldXNlZFxuXHRcdGV2ZW50LnJlc3VsdCA9IHVuZGVmaW5lZDtcblx0XHRpZiAoICFldmVudC50YXJnZXQgKSB7XG5cdFx0XHRldmVudC50YXJnZXQgPSBlbGVtO1xuXHRcdH1cblxuXHRcdC8vIENsb25lIGFueSBpbmNvbWluZyBkYXRhIGFuZCBwcmVwZW5kIHRoZSBldmVudCwgY3JlYXRpbmcgdGhlIGhhbmRsZXIgYXJnIGxpc3Rcblx0XHRkYXRhID0gZGF0YSA9PSBudWxsID9cblx0XHRcdFsgZXZlbnQgXSA6XG5cdFx0XHRqUXVlcnkubWFrZUFycmF5KCBkYXRhLCBbIGV2ZW50IF0gKTtcblxuXHRcdC8vIEFsbG93IHNwZWNpYWwgZXZlbnRzIHRvIGRyYXcgb3V0c2lkZSB0aGUgbGluZXNcblx0XHRzcGVjaWFsID0galF1ZXJ5LmV2ZW50LnNwZWNpYWxbIHR5cGUgXSB8fCB7fTtcblx0XHRpZiAoICFvbmx5SGFuZGxlcnMgJiYgc3BlY2lhbC50cmlnZ2VyICYmIHNwZWNpYWwudHJpZ2dlci5hcHBseSggZWxlbSwgZGF0YSApID09PSBmYWxzZSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBEZXRlcm1pbmUgZXZlbnQgcHJvcGFnYXRpb24gcGF0aCBpbiBhZHZhbmNlLCBwZXIgVzNDIGV2ZW50cyBzcGVjICgjOTk1MSlcblx0XHQvLyBCdWJibGUgdXAgdG8gZG9jdW1lbnQsIHRoZW4gdG8gd2luZG93OyB3YXRjaCBmb3IgYSBnbG9iYWwgb3duZXJEb2N1bWVudCB2YXIgKCM5NzI0KVxuXHRcdGlmICggIW9ubHlIYW5kbGVycyAmJiAhc3BlY2lhbC5ub0J1YmJsZSAmJiAhaXNXaW5kb3coIGVsZW0gKSApIHtcblxuXHRcdFx0YnViYmxlVHlwZSA9IHNwZWNpYWwuZGVsZWdhdGVUeXBlIHx8IHR5cGU7XG5cdFx0XHRpZiAoICFyZm9jdXNNb3JwaC50ZXN0KCBidWJibGVUeXBlICsgdHlwZSApICkge1xuXHRcdFx0XHRjdXIgPSBjdXIucGFyZW50Tm9kZTtcblx0XHRcdH1cblx0XHRcdGZvciAoIDsgY3VyOyBjdXIgPSBjdXIucGFyZW50Tm9kZSApIHtcblx0XHRcdFx0ZXZlbnRQYXRoLnB1c2goIGN1ciApO1xuXHRcdFx0XHR0bXAgPSBjdXI7XG5cdFx0XHR9XG5cblx0XHRcdC8vIE9ubHkgYWRkIHdpbmRvdyBpZiB3ZSBnb3QgdG8gZG9jdW1lbnQgKGUuZy4sIG5vdCBwbGFpbiBvYmogb3IgZGV0YWNoZWQgRE9NKVxuXHRcdFx0aWYgKCB0bXAgPT09ICggZWxlbS5vd25lckRvY3VtZW50IHx8IGRvY3VtZW50ICkgKSB7XG5cdFx0XHRcdGV2ZW50UGF0aC5wdXNoKCB0bXAuZGVmYXVsdFZpZXcgfHwgdG1wLnBhcmVudFdpbmRvdyB8fCB3aW5kb3cgKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBGaXJlIGhhbmRsZXJzIG9uIHRoZSBldmVudCBwYXRoXG5cdFx0aSA9IDA7XG5cdFx0d2hpbGUgKCAoIGN1ciA9IGV2ZW50UGF0aFsgaSsrIF0gKSAmJiAhZXZlbnQuaXNQcm9wYWdhdGlvblN0b3BwZWQoKSApIHtcblx0XHRcdGxhc3RFbGVtZW50ID0gY3VyO1xuXHRcdFx0ZXZlbnQudHlwZSA9IGkgPiAxID9cblx0XHRcdFx0YnViYmxlVHlwZSA6XG5cdFx0XHRcdHNwZWNpYWwuYmluZFR5cGUgfHwgdHlwZTtcblxuXHRcdFx0Ly8galF1ZXJ5IGhhbmRsZXJcblx0XHRcdGhhbmRsZSA9ICggZGF0YVByaXYuZ2V0KCBjdXIsIFwiZXZlbnRzXCIgKSB8fCBPYmplY3QuY3JlYXRlKCBudWxsICkgKVsgZXZlbnQudHlwZSBdICYmXG5cdFx0XHRcdGRhdGFQcml2LmdldCggY3VyLCBcImhhbmRsZVwiICk7XG5cdFx0XHRpZiAoIGhhbmRsZSApIHtcblx0XHRcdFx0aGFuZGxlLmFwcGx5KCBjdXIsIGRhdGEgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gTmF0aXZlIGhhbmRsZXJcblx0XHRcdGhhbmRsZSA9IG9udHlwZSAmJiBjdXJbIG9udHlwZSBdO1xuXHRcdFx0aWYgKCBoYW5kbGUgJiYgaGFuZGxlLmFwcGx5ICYmIGFjY2VwdERhdGEoIGN1ciApICkge1xuXHRcdFx0XHRldmVudC5yZXN1bHQgPSBoYW5kbGUuYXBwbHkoIGN1ciwgZGF0YSApO1xuXHRcdFx0XHRpZiAoIGV2ZW50LnJlc3VsdCA9PT0gZmFsc2UgKSB7XG5cdFx0XHRcdFx0ZXZlbnQucHJldmVudERlZmF1bHQoKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XHRldmVudC50eXBlID0gdHlwZTtcblxuXHRcdC8vIElmIG5vYm9keSBwcmV2ZW50ZWQgdGhlIGRlZmF1bHQgYWN0aW9uLCBkbyBpdCBub3dcblx0XHRpZiAoICFvbmx5SGFuZGxlcnMgJiYgIWV2ZW50LmlzRGVmYXVsdFByZXZlbnRlZCgpICkge1xuXG5cdFx0XHRpZiAoICggIXNwZWNpYWwuX2RlZmF1bHQgfHxcblx0XHRcdFx0c3BlY2lhbC5fZGVmYXVsdC5hcHBseSggZXZlbnRQYXRoLnBvcCgpLCBkYXRhICkgPT09IGZhbHNlICkgJiZcblx0XHRcdFx0YWNjZXB0RGF0YSggZWxlbSApICkge1xuXG5cdFx0XHRcdC8vIENhbGwgYSBuYXRpdmUgRE9NIG1ldGhvZCBvbiB0aGUgdGFyZ2V0IHdpdGggdGhlIHNhbWUgbmFtZSBhcyB0aGUgZXZlbnQuXG5cdFx0XHRcdC8vIERvbid0IGRvIGRlZmF1bHQgYWN0aW9ucyBvbiB3aW5kb3csIHRoYXQncyB3aGVyZSBnbG9iYWwgdmFyaWFibGVzIGJlICgjNjE3MClcblx0XHRcdFx0aWYgKCBvbnR5cGUgJiYgaXNGdW5jdGlvbiggZWxlbVsgdHlwZSBdICkgJiYgIWlzV2luZG93KCBlbGVtICkgKSB7XG5cblx0XHRcdFx0XHQvLyBEb24ndCByZS10cmlnZ2VyIGFuIG9uRk9PIGV2ZW50IHdoZW4gd2UgY2FsbCBpdHMgRk9PKCkgbWV0aG9kXG5cdFx0XHRcdFx0dG1wID0gZWxlbVsgb250eXBlIF07XG5cblx0XHRcdFx0XHRpZiAoIHRtcCApIHtcblx0XHRcdFx0XHRcdGVsZW1bIG9udHlwZSBdID0gbnVsbDtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBQcmV2ZW50IHJlLXRyaWdnZXJpbmcgb2YgdGhlIHNhbWUgZXZlbnQsIHNpbmNlIHdlIGFscmVhZHkgYnViYmxlZCBpdCBhYm92ZVxuXHRcdFx0XHRcdGpRdWVyeS5ldmVudC50cmlnZ2VyZWQgPSB0eXBlO1xuXG5cdFx0XHRcdFx0aWYgKCBldmVudC5pc1Byb3BhZ2F0aW9uU3RvcHBlZCgpICkge1xuXHRcdFx0XHRcdFx0bGFzdEVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lciggdHlwZSwgc3RvcFByb3BhZ2F0aW9uQ2FsbGJhY2sgKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRlbGVtWyB0eXBlIF0oKTtcblxuXHRcdFx0XHRcdGlmICggZXZlbnQuaXNQcm9wYWdhdGlvblN0b3BwZWQoKSApIHtcblx0XHRcdFx0XHRcdGxhc3RFbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoIHR5cGUsIHN0b3BQcm9wYWdhdGlvbkNhbGxiYWNrICk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0alF1ZXJ5LmV2ZW50LnRyaWdnZXJlZCA9IHVuZGVmaW5lZDtcblxuXHRcdFx0XHRcdGlmICggdG1wICkge1xuXHRcdFx0XHRcdFx0ZWxlbVsgb250eXBlIF0gPSB0bXA7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGV2ZW50LnJlc3VsdDtcblx0fSxcblxuXHQvLyBQaWdneWJhY2sgb24gYSBkb25vciBldmVudCB0byBzaW11bGF0ZSBhIGRpZmZlcmVudCBvbmVcblx0Ly8gVXNlZCBvbmx5IGZvciBgZm9jdXMoaW4gfCBvdXQpYCBldmVudHNcblx0c2ltdWxhdGU6IGZ1bmN0aW9uKCB0eXBlLCBlbGVtLCBldmVudCApIHtcblx0XHR2YXIgZSA9IGpRdWVyeS5leHRlbmQoXG5cdFx0XHRuZXcgalF1ZXJ5LkV2ZW50KCksXG5cdFx0XHRldmVudCxcblx0XHRcdHtcblx0XHRcdFx0dHlwZTogdHlwZSxcblx0XHRcdFx0aXNTaW11bGF0ZWQ6IHRydWVcblx0XHRcdH1cblx0XHQpO1xuXG5cdFx0alF1ZXJ5LmV2ZW50LnRyaWdnZXIoIGUsIG51bGwsIGVsZW0gKTtcblx0fVxuXG59ICk7XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblxuXHR0cmlnZ2VyOiBmdW5jdGlvbiggdHlwZSwgZGF0YSApIHtcblx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdGpRdWVyeS5ldmVudC50cmlnZ2VyKCB0eXBlLCBkYXRhLCB0aGlzICk7XG5cdFx0fSApO1xuXHR9LFxuXHR0cmlnZ2VySGFuZGxlcjogZnVuY3Rpb24oIHR5cGUsIGRhdGEgKSB7XG5cdFx0dmFyIGVsZW0gPSB0aGlzWyAwIF07XG5cdFx0aWYgKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuIGpRdWVyeS5ldmVudC50cmlnZ2VyKCB0eXBlLCBkYXRhLCBlbGVtLCB0cnVlICk7XG5cdFx0fVxuXHR9XG59ICk7XG5cblxuLy8gU3VwcG9ydDogRmlyZWZveCA8PTQ0XG4vLyBGaXJlZm94IGRvZXNuJ3QgaGF2ZSBmb2N1cyhpbiB8IG91dCkgZXZlbnRzXG4vLyBSZWxhdGVkIHRpY2tldCAtIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTY4Nzc4N1xuLy9cbi8vIFN1cHBvcnQ6IENocm9tZSA8PTQ4IC0gNDksIFNhZmFyaSA8PTkuMCAtIDkuMVxuLy8gZm9jdXMoaW4gfCBvdXQpIGV2ZW50cyBmaXJlIGFmdGVyIGZvY3VzICYgYmx1ciBldmVudHMsXG4vLyB3aGljaCBpcyBzcGVjIHZpb2xhdGlvbiAtIGh0dHA6Ly93d3cudzMub3JnL1RSL0RPTS1MZXZlbC0zLUV2ZW50cy8jZXZlbnRzLWZvY3VzZXZlbnQtZXZlbnQtb3JkZXJcbi8vIFJlbGF0ZWQgdGlja2V0IC0gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9NDQ5ODU3XG5pZiAoICFzdXBwb3J0LmZvY3VzaW4gKSB7XG5cdGpRdWVyeS5lYWNoKCB7IGZvY3VzOiBcImZvY3VzaW5cIiwgYmx1cjogXCJmb2N1c291dFwiIH0sIGZ1bmN0aW9uKCBvcmlnLCBmaXggKSB7XG5cblx0XHQvLyBBdHRhY2ggYSBzaW5nbGUgY2FwdHVyaW5nIGhhbmRsZXIgb24gdGhlIGRvY3VtZW50IHdoaWxlIHNvbWVvbmUgd2FudHMgZm9jdXNpbi9mb2N1c291dFxuXHRcdHZhciBoYW5kbGVyID0gZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdFx0alF1ZXJ5LmV2ZW50LnNpbXVsYXRlKCBmaXgsIGV2ZW50LnRhcmdldCwgalF1ZXJ5LmV2ZW50LmZpeCggZXZlbnQgKSApO1xuXHRcdH07XG5cblx0XHRqUXVlcnkuZXZlbnQuc3BlY2lhbFsgZml4IF0gPSB7XG5cdFx0XHRzZXR1cDogZnVuY3Rpb24oKSB7XG5cblx0XHRcdFx0Ly8gSGFuZGxlOiByZWd1bGFyIG5vZGVzICh2aWEgYHRoaXMub3duZXJEb2N1bWVudGApLCB3aW5kb3dcblx0XHRcdFx0Ly8gKHZpYSBgdGhpcy5kb2N1bWVudGApICYgZG9jdW1lbnQgKHZpYSBgdGhpc2ApLlxuXHRcdFx0XHR2YXIgZG9jID0gdGhpcy5vd25lckRvY3VtZW50IHx8IHRoaXMuZG9jdW1lbnQgfHwgdGhpcyxcblx0XHRcdFx0XHRhdHRhY2hlcyA9IGRhdGFQcml2LmFjY2VzcyggZG9jLCBmaXggKTtcblxuXHRcdFx0XHRpZiAoICFhdHRhY2hlcyApIHtcblx0XHRcdFx0XHRkb2MuYWRkRXZlbnRMaXN0ZW5lciggb3JpZywgaGFuZGxlciwgdHJ1ZSApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGRhdGFQcml2LmFjY2VzcyggZG9jLCBmaXgsICggYXR0YWNoZXMgfHwgMCApICsgMSApO1xuXHRcdFx0fSxcblx0XHRcdHRlYXJkb3duOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0dmFyIGRvYyA9IHRoaXMub3duZXJEb2N1bWVudCB8fCB0aGlzLmRvY3VtZW50IHx8IHRoaXMsXG5cdFx0XHRcdFx0YXR0YWNoZXMgPSBkYXRhUHJpdi5hY2Nlc3MoIGRvYywgZml4ICkgLSAxO1xuXG5cdFx0XHRcdGlmICggIWF0dGFjaGVzICkge1xuXHRcdFx0XHRcdGRvYy5yZW1vdmVFdmVudExpc3RlbmVyKCBvcmlnLCBoYW5kbGVyLCB0cnVlICk7XG5cdFx0XHRcdFx0ZGF0YVByaXYucmVtb3ZlKCBkb2MsIGZpeCApO1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0ZGF0YVByaXYuYWNjZXNzKCBkb2MsIGZpeCwgYXR0YWNoZXMgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH07XG5cdH0gKTtcbn1cbnZhciBsb2NhdGlvbiA9IHdpbmRvdy5sb2NhdGlvbjtcblxudmFyIG5vbmNlID0geyBndWlkOiBEYXRlLm5vdygpIH07XG5cbnZhciBycXVlcnkgPSAoIC9cXD8vICk7XG5cblxuXG4vLyBDcm9zcy1icm93c2VyIHhtbCBwYXJzaW5nXG5qUXVlcnkucGFyc2VYTUwgPSBmdW5jdGlvbiggZGF0YSApIHtcblx0dmFyIHhtbCwgcGFyc2VyRXJyb3JFbGVtO1xuXHRpZiAoICFkYXRhIHx8IHR5cGVvZiBkYXRhICE9PSBcInN0cmluZ1wiICkge1xuXHRcdHJldHVybiBudWxsO1xuXHR9XG5cblx0Ly8gU3VwcG9ydDogSUUgOSAtIDExIG9ubHlcblx0Ly8gSUUgdGhyb3dzIG9uIHBhcnNlRnJvbVN0cmluZyB3aXRoIGludmFsaWQgaW5wdXQuXG5cdHRyeSB7XG5cdFx0eG1sID0gKCBuZXcgd2luZG93LkRPTVBhcnNlcigpICkucGFyc2VGcm9tU3RyaW5nKCBkYXRhLCBcInRleHQveG1sXCIgKTtcblx0fSBjYXRjaCAoIGUgKSB7fVxuXG5cdHBhcnNlckVycm9yRWxlbSA9IHhtbCAmJiB4bWwuZ2V0RWxlbWVudHNCeVRhZ05hbWUoIFwicGFyc2VyZXJyb3JcIiApWyAwIF07XG5cdGlmICggIXhtbCB8fCBwYXJzZXJFcnJvckVsZW0gKSB7XG5cdFx0alF1ZXJ5LmVycm9yKCBcIkludmFsaWQgWE1MOiBcIiArIChcblx0XHRcdHBhcnNlckVycm9yRWxlbSA/XG5cdFx0XHRcdGpRdWVyeS5tYXAoIHBhcnNlckVycm9yRWxlbS5jaGlsZE5vZGVzLCBmdW5jdGlvbiggZWwgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGVsLnRleHRDb250ZW50O1xuXHRcdFx0XHR9ICkuam9pbiggXCJcXG5cIiApIDpcblx0XHRcdFx0ZGF0YVxuXHRcdCkgKTtcblx0fVxuXHRyZXR1cm4geG1sO1xufTtcblxuXG52YXJcblx0cmJyYWNrZXQgPSAvXFxbXFxdJC8sXG5cdHJDUkxGID0gL1xccj9cXG4vZyxcblx0cnN1Ym1pdHRlclR5cGVzID0gL14oPzpzdWJtaXR8YnV0dG9ufGltYWdlfHJlc2V0fGZpbGUpJC9pLFxuXHRyc3VibWl0dGFibGUgPSAvXig/OmlucHV0fHNlbGVjdHx0ZXh0YXJlYXxrZXlnZW4pL2k7XG5cbmZ1bmN0aW9uIGJ1aWxkUGFyYW1zKCBwcmVmaXgsIG9iaiwgdHJhZGl0aW9uYWwsIGFkZCApIHtcblx0dmFyIG5hbWU7XG5cblx0aWYgKCBBcnJheS5pc0FycmF5KCBvYmogKSApIHtcblxuXHRcdC8vIFNlcmlhbGl6ZSBhcnJheSBpdGVtLlxuXHRcdGpRdWVyeS5lYWNoKCBvYmosIGZ1bmN0aW9uKCBpLCB2ICkge1xuXHRcdFx0aWYgKCB0cmFkaXRpb25hbCB8fCByYnJhY2tldC50ZXN0KCBwcmVmaXggKSApIHtcblxuXHRcdFx0XHQvLyBUcmVhdCBlYWNoIGFycmF5IGl0ZW0gYXMgYSBzY2FsYXIuXG5cdFx0XHRcdGFkZCggcHJlZml4LCB2ICk7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0Ly8gSXRlbSBpcyBub24tc2NhbGFyIChhcnJheSBvciBvYmplY3QpLCBlbmNvZGUgaXRzIG51bWVyaWMgaW5kZXguXG5cdFx0XHRcdGJ1aWxkUGFyYW1zKFxuXHRcdFx0XHRcdHByZWZpeCArIFwiW1wiICsgKCB0eXBlb2YgdiA9PT0gXCJvYmplY3RcIiAmJiB2ICE9IG51bGwgPyBpIDogXCJcIiApICsgXCJdXCIsXG5cdFx0XHRcdFx0dixcblx0XHRcdFx0XHR0cmFkaXRpb25hbCxcblx0XHRcdFx0XHRhZGRcblx0XHRcdFx0KTtcblx0XHRcdH1cblx0XHR9ICk7XG5cblx0fSBlbHNlIGlmICggIXRyYWRpdGlvbmFsICYmIHRvVHlwZSggb2JqICkgPT09IFwib2JqZWN0XCIgKSB7XG5cblx0XHQvLyBTZXJpYWxpemUgb2JqZWN0IGl0ZW0uXG5cdFx0Zm9yICggbmFtZSBpbiBvYmogKSB7XG5cdFx0XHRidWlsZFBhcmFtcyggcHJlZml4ICsgXCJbXCIgKyBuYW1lICsgXCJdXCIsIG9ialsgbmFtZSBdLCB0cmFkaXRpb25hbCwgYWRkICk7XG5cdFx0fVxuXG5cdH0gZWxzZSB7XG5cblx0XHQvLyBTZXJpYWxpemUgc2NhbGFyIGl0ZW0uXG5cdFx0YWRkKCBwcmVmaXgsIG9iaiApO1xuXHR9XG59XG5cbi8vIFNlcmlhbGl6ZSBhbiBhcnJheSBvZiBmb3JtIGVsZW1lbnRzIG9yIGEgc2V0IG9mXG4vLyBrZXkvdmFsdWVzIGludG8gYSBxdWVyeSBzdHJpbmdcbmpRdWVyeS5wYXJhbSA9IGZ1bmN0aW9uKCBhLCB0cmFkaXRpb25hbCApIHtcblx0dmFyIHByZWZpeCxcblx0XHRzID0gW10sXG5cdFx0YWRkID0gZnVuY3Rpb24oIGtleSwgdmFsdWVPckZ1bmN0aW9uICkge1xuXG5cdFx0XHQvLyBJZiB2YWx1ZSBpcyBhIGZ1bmN0aW9uLCBpbnZva2UgaXQgYW5kIHVzZSBpdHMgcmV0dXJuIHZhbHVlXG5cdFx0XHR2YXIgdmFsdWUgPSBpc0Z1bmN0aW9uKCB2YWx1ZU9yRnVuY3Rpb24gKSA/XG5cdFx0XHRcdHZhbHVlT3JGdW5jdGlvbigpIDpcblx0XHRcdFx0dmFsdWVPckZ1bmN0aW9uO1xuXG5cdFx0XHRzWyBzLmxlbmd0aCBdID0gZW5jb2RlVVJJQ29tcG9uZW50KCBrZXkgKSArIFwiPVwiICtcblx0XHRcdFx0ZW5jb2RlVVJJQ29tcG9uZW50KCB2YWx1ZSA9PSBudWxsID8gXCJcIiA6IHZhbHVlICk7XG5cdFx0fTtcblxuXHRpZiAoIGEgPT0gbnVsbCApIHtcblx0XHRyZXR1cm4gXCJcIjtcblx0fVxuXG5cdC8vIElmIGFuIGFycmF5IHdhcyBwYXNzZWQgaW4sIGFzc3VtZSB0aGF0IGl0IGlzIGFuIGFycmF5IG9mIGZvcm0gZWxlbWVudHMuXG5cdGlmICggQXJyYXkuaXNBcnJheSggYSApIHx8ICggYS5qcXVlcnkgJiYgIWpRdWVyeS5pc1BsYWluT2JqZWN0KCBhICkgKSApIHtcblxuXHRcdC8vIFNlcmlhbGl6ZSB0aGUgZm9ybSBlbGVtZW50c1xuXHRcdGpRdWVyeS5lYWNoKCBhLCBmdW5jdGlvbigpIHtcblx0XHRcdGFkZCggdGhpcy5uYW1lLCB0aGlzLnZhbHVlICk7XG5cdFx0fSApO1xuXG5cdH0gZWxzZSB7XG5cblx0XHQvLyBJZiB0cmFkaXRpb25hbCwgZW5jb2RlIHRoZSBcIm9sZFwiIHdheSAodGhlIHdheSAxLjMuMiBvciBvbGRlclxuXHRcdC8vIGRpZCBpdCksIG90aGVyd2lzZSBlbmNvZGUgcGFyYW1zIHJlY3Vyc2l2ZWx5LlxuXHRcdGZvciAoIHByZWZpeCBpbiBhICkge1xuXHRcdFx0YnVpbGRQYXJhbXMoIHByZWZpeCwgYVsgcHJlZml4IF0sIHRyYWRpdGlvbmFsLCBhZGQgKTtcblx0XHR9XG5cdH1cblxuXHQvLyBSZXR1cm4gdGhlIHJlc3VsdGluZyBzZXJpYWxpemF0aW9uXG5cdHJldHVybiBzLmpvaW4oIFwiJlwiICk7XG59O1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdHNlcmlhbGl6ZTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIGpRdWVyeS5wYXJhbSggdGhpcy5zZXJpYWxpemVBcnJheSgpICk7XG5cdH0sXG5cdHNlcmlhbGl6ZUFycmF5OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5tYXAoIGZ1bmN0aW9uKCkge1xuXG5cdFx0XHQvLyBDYW4gYWRkIHByb3BIb29rIGZvciBcImVsZW1lbnRzXCIgdG8gZmlsdGVyIG9yIGFkZCBmb3JtIGVsZW1lbnRzXG5cdFx0XHR2YXIgZWxlbWVudHMgPSBqUXVlcnkucHJvcCggdGhpcywgXCJlbGVtZW50c1wiICk7XG5cdFx0XHRyZXR1cm4gZWxlbWVudHMgPyBqUXVlcnkubWFrZUFycmF5KCBlbGVtZW50cyApIDogdGhpcztcblx0XHR9ICkuZmlsdGVyKCBmdW5jdGlvbigpIHtcblx0XHRcdHZhciB0eXBlID0gdGhpcy50eXBlO1xuXG5cdFx0XHQvLyBVc2UgLmlzKCBcIjpkaXNhYmxlZFwiICkgc28gdGhhdCBmaWVsZHNldFtkaXNhYmxlZF0gd29ya3Ncblx0XHRcdHJldHVybiB0aGlzLm5hbWUgJiYgIWpRdWVyeSggdGhpcyApLmlzKCBcIjpkaXNhYmxlZFwiICkgJiZcblx0XHRcdFx0cnN1Ym1pdHRhYmxlLnRlc3QoIHRoaXMubm9kZU5hbWUgKSAmJiAhcnN1Ym1pdHRlclR5cGVzLnRlc3QoIHR5cGUgKSAmJlxuXHRcdFx0XHQoIHRoaXMuY2hlY2tlZCB8fCAhcmNoZWNrYWJsZVR5cGUudGVzdCggdHlwZSApICk7XG5cdFx0fSApLm1hcCggZnVuY3Rpb24oIF9pLCBlbGVtICkge1xuXHRcdFx0dmFyIHZhbCA9IGpRdWVyeSggdGhpcyApLnZhbCgpO1xuXG5cdFx0XHRpZiAoIHZhbCA9PSBudWxsICkge1xuXHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCBBcnJheS5pc0FycmF5KCB2YWwgKSApIHtcblx0XHRcdFx0cmV0dXJuIGpRdWVyeS5tYXAoIHZhbCwgZnVuY3Rpb24oIHZhbCApIHtcblx0XHRcdFx0XHRyZXR1cm4geyBuYW1lOiBlbGVtLm5hbWUsIHZhbHVlOiB2YWwucmVwbGFjZSggckNSTEYsIFwiXFxyXFxuXCIgKSB9O1xuXHRcdFx0XHR9ICk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB7IG5hbWU6IGVsZW0ubmFtZSwgdmFsdWU6IHZhbC5yZXBsYWNlKCByQ1JMRiwgXCJcXHJcXG5cIiApIH07XG5cdFx0fSApLmdldCgpO1xuXHR9XG59ICk7XG5cblxudmFyXG5cdHIyMCA9IC8lMjAvZyxcblx0cmhhc2ggPSAvIy4qJC8sXG5cdHJhbnRpQ2FjaGUgPSAvKFs/Jl0pXz1bXiZdKi8sXG5cdHJoZWFkZXJzID0gL14oLio/KTpbIFxcdF0qKFteXFxyXFxuXSopJC9tZyxcblxuXHQvLyAjNzY1MywgIzgxMjUsICM4MTUyOiBsb2NhbCBwcm90b2NvbCBkZXRlY3Rpb25cblx0cmxvY2FsUHJvdG9jb2wgPSAvXig/OmFib3V0fGFwcHxhcHAtc3RvcmFnZXwuKy1leHRlbnNpb258ZmlsZXxyZXN8d2lkZ2V0KTokLyxcblx0cm5vQ29udGVudCA9IC9eKD86R0VUfEhFQUQpJC8sXG5cdHJwcm90b2NvbCA9IC9eXFwvXFwvLyxcblxuXHQvKiBQcmVmaWx0ZXJzXG5cdCAqIDEpIFRoZXkgYXJlIHVzZWZ1bCB0byBpbnRyb2R1Y2UgY3VzdG9tIGRhdGFUeXBlcyAoc2VlIGFqYXgvanNvbnAuanMgZm9yIGFuIGV4YW1wbGUpXG5cdCAqIDIpIFRoZXNlIGFyZSBjYWxsZWQ6XG5cdCAqICAgIC0gQkVGT1JFIGFza2luZyBmb3IgYSB0cmFuc3BvcnRcblx0ICogICAgLSBBRlRFUiBwYXJhbSBzZXJpYWxpemF0aW9uIChzLmRhdGEgaXMgYSBzdHJpbmcgaWYgcy5wcm9jZXNzRGF0YSBpcyB0cnVlKVxuXHQgKiAzKSBrZXkgaXMgdGhlIGRhdGFUeXBlXG5cdCAqIDQpIHRoZSBjYXRjaGFsbCBzeW1ib2wgXCIqXCIgY2FuIGJlIHVzZWRcblx0ICogNSkgZXhlY3V0aW9uIHdpbGwgc3RhcnQgd2l0aCB0cmFuc3BvcnQgZGF0YVR5cGUgYW5kIFRIRU4gY29udGludWUgZG93biB0byBcIipcIiBpZiBuZWVkZWRcblx0ICovXG5cdHByZWZpbHRlcnMgPSB7fSxcblxuXHQvKiBUcmFuc3BvcnRzIGJpbmRpbmdzXG5cdCAqIDEpIGtleSBpcyB0aGUgZGF0YVR5cGVcblx0ICogMikgdGhlIGNhdGNoYWxsIHN5bWJvbCBcIipcIiBjYW4gYmUgdXNlZFxuXHQgKiAzKSBzZWxlY3Rpb24gd2lsbCBzdGFydCB3aXRoIHRyYW5zcG9ydCBkYXRhVHlwZSBhbmQgVEhFTiBnbyB0byBcIipcIiBpZiBuZWVkZWRcblx0ICovXG5cdHRyYW5zcG9ydHMgPSB7fSxcblxuXHQvLyBBdm9pZCBjb21tZW50LXByb2xvZyBjaGFyIHNlcXVlbmNlICgjMTAwOTgpOyBtdXN0IGFwcGVhc2UgbGludCBhbmQgZXZhZGUgY29tcHJlc3Npb25cblx0YWxsVHlwZXMgPSBcIiovXCIuY29uY2F0KCBcIipcIiApLFxuXG5cdC8vIEFuY2hvciB0YWcgZm9yIHBhcnNpbmcgdGhlIGRvY3VtZW50IG9yaWdpblxuXHRvcmlnaW5BbmNob3IgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImFcIiApO1xuXG5vcmlnaW5BbmNob3IuaHJlZiA9IGxvY2F0aW9uLmhyZWY7XG5cbi8vIEJhc2UgXCJjb25zdHJ1Y3RvclwiIGZvciBqUXVlcnkuYWpheFByZWZpbHRlciBhbmQgalF1ZXJ5LmFqYXhUcmFuc3BvcnRcbmZ1bmN0aW9uIGFkZFRvUHJlZmlsdGVyc09yVHJhbnNwb3J0cyggc3RydWN0dXJlICkge1xuXG5cdC8vIGRhdGFUeXBlRXhwcmVzc2lvbiBpcyBvcHRpb25hbCBhbmQgZGVmYXVsdHMgdG8gXCIqXCJcblx0cmV0dXJuIGZ1bmN0aW9uKCBkYXRhVHlwZUV4cHJlc3Npb24sIGZ1bmMgKSB7XG5cblx0XHRpZiAoIHR5cGVvZiBkYXRhVHlwZUV4cHJlc3Npb24gIT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRmdW5jID0gZGF0YVR5cGVFeHByZXNzaW9uO1xuXHRcdFx0ZGF0YVR5cGVFeHByZXNzaW9uID0gXCIqXCI7XG5cdFx0fVxuXG5cdFx0dmFyIGRhdGFUeXBlLFxuXHRcdFx0aSA9IDAsXG5cdFx0XHRkYXRhVHlwZXMgPSBkYXRhVHlwZUV4cHJlc3Npb24udG9Mb3dlckNhc2UoKS5tYXRjaCggcm5vdGh0bWx3aGl0ZSApIHx8IFtdO1xuXG5cdFx0aWYgKCBpc0Z1bmN0aW9uKCBmdW5jICkgKSB7XG5cblx0XHRcdC8vIEZvciBlYWNoIGRhdGFUeXBlIGluIHRoZSBkYXRhVHlwZUV4cHJlc3Npb25cblx0XHRcdHdoaWxlICggKCBkYXRhVHlwZSA9IGRhdGFUeXBlc1sgaSsrIF0gKSApIHtcblxuXHRcdFx0XHQvLyBQcmVwZW5kIGlmIHJlcXVlc3RlZFxuXHRcdFx0XHRpZiAoIGRhdGFUeXBlWyAwIF0gPT09IFwiK1wiICkge1xuXHRcdFx0XHRcdGRhdGFUeXBlID0gZGF0YVR5cGUuc2xpY2UoIDEgKSB8fCBcIipcIjtcblx0XHRcdFx0XHQoIHN0cnVjdHVyZVsgZGF0YVR5cGUgXSA9IHN0cnVjdHVyZVsgZGF0YVR5cGUgXSB8fCBbXSApLnVuc2hpZnQoIGZ1bmMgKTtcblxuXHRcdFx0XHQvLyBPdGhlcndpc2UgYXBwZW5kXG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0KCBzdHJ1Y3R1cmVbIGRhdGFUeXBlIF0gPSBzdHJ1Y3R1cmVbIGRhdGFUeXBlIF0gfHwgW10gKS5wdXNoKCBmdW5jICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH07XG59XG5cbi8vIEJhc2UgaW5zcGVjdGlvbiBmdW5jdGlvbiBmb3IgcHJlZmlsdGVycyBhbmQgdHJhbnNwb3J0c1xuZnVuY3Rpb24gaW5zcGVjdFByZWZpbHRlcnNPclRyYW5zcG9ydHMoIHN0cnVjdHVyZSwgb3B0aW9ucywgb3JpZ2luYWxPcHRpb25zLCBqcVhIUiApIHtcblxuXHR2YXIgaW5zcGVjdGVkID0ge30sXG5cdFx0c2Vla2luZ1RyYW5zcG9ydCA9ICggc3RydWN0dXJlID09PSB0cmFuc3BvcnRzICk7XG5cblx0ZnVuY3Rpb24gaW5zcGVjdCggZGF0YVR5cGUgKSB7XG5cdFx0dmFyIHNlbGVjdGVkO1xuXHRcdGluc3BlY3RlZFsgZGF0YVR5cGUgXSA9IHRydWU7XG5cdFx0alF1ZXJ5LmVhY2goIHN0cnVjdHVyZVsgZGF0YVR5cGUgXSB8fCBbXSwgZnVuY3Rpb24oIF8sIHByZWZpbHRlck9yRmFjdG9yeSApIHtcblx0XHRcdHZhciBkYXRhVHlwZU9yVHJhbnNwb3J0ID0gcHJlZmlsdGVyT3JGYWN0b3J5KCBvcHRpb25zLCBvcmlnaW5hbE9wdGlvbnMsIGpxWEhSICk7XG5cdFx0XHRpZiAoIHR5cGVvZiBkYXRhVHlwZU9yVHJhbnNwb3J0ID09PSBcInN0cmluZ1wiICYmXG5cdFx0XHRcdCFzZWVraW5nVHJhbnNwb3J0ICYmICFpbnNwZWN0ZWRbIGRhdGFUeXBlT3JUcmFuc3BvcnQgXSApIHtcblxuXHRcdFx0XHRvcHRpb25zLmRhdGFUeXBlcy51bnNoaWZ0KCBkYXRhVHlwZU9yVHJhbnNwb3J0ICk7XG5cdFx0XHRcdGluc3BlY3QoIGRhdGFUeXBlT3JUcmFuc3BvcnQgKTtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fSBlbHNlIGlmICggc2Vla2luZ1RyYW5zcG9ydCApIHtcblx0XHRcdFx0cmV0dXJuICEoIHNlbGVjdGVkID0gZGF0YVR5cGVPclRyYW5zcG9ydCApO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0XHRyZXR1cm4gc2VsZWN0ZWQ7XG5cdH1cblxuXHRyZXR1cm4gaW5zcGVjdCggb3B0aW9ucy5kYXRhVHlwZXNbIDAgXSApIHx8ICFpbnNwZWN0ZWRbIFwiKlwiIF0gJiYgaW5zcGVjdCggXCIqXCIgKTtcbn1cblxuLy8gQSBzcGVjaWFsIGV4dGVuZCBmb3IgYWpheCBvcHRpb25zXG4vLyB0aGF0IHRha2VzIFwiZmxhdFwiIG9wdGlvbnMgKG5vdCB0byBiZSBkZWVwIGV4dGVuZGVkKVxuLy8gRml4ZXMgIzk4ODdcbmZ1bmN0aW9uIGFqYXhFeHRlbmQoIHRhcmdldCwgc3JjICkge1xuXHR2YXIga2V5LCBkZWVwLFxuXHRcdGZsYXRPcHRpb25zID0galF1ZXJ5LmFqYXhTZXR0aW5ncy5mbGF0T3B0aW9ucyB8fCB7fTtcblxuXHRmb3IgKCBrZXkgaW4gc3JjICkge1xuXHRcdGlmICggc3JjWyBrZXkgXSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0KCBmbGF0T3B0aW9uc1sga2V5IF0gPyB0YXJnZXQgOiAoIGRlZXAgfHwgKCBkZWVwID0ge30gKSApIClbIGtleSBdID0gc3JjWyBrZXkgXTtcblx0XHR9XG5cdH1cblx0aWYgKCBkZWVwICkge1xuXHRcdGpRdWVyeS5leHRlbmQoIHRydWUsIHRhcmdldCwgZGVlcCApO1xuXHR9XG5cblx0cmV0dXJuIHRhcmdldDtcbn1cblxuLyogSGFuZGxlcyByZXNwb25zZXMgdG8gYW4gYWpheCByZXF1ZXN0OlxuICogLSBmaW5kcyB0aGUgcmlnaHQgZGF0YVR5cGUgKG1lZGlhdGVzIGJldHdlZW4gY29udGVudC10eXBlIGFuZCBleHBlY3RlZCBkYXRhVHlwZSlcbiAqIC0gcmV0dXJucyB0aGUgY29ycmVzcG9uZGluZyByZXNwb25zZVxuICovXG5mdW5jdGlvbiBhamF4SGFuZGxlUmVzcG9uc2VzKCBzLCBqcVhIUiwgcmVzcG9uc2VzICkge1xuXG5cdHZhciBjdCwgdHlwZSwgZmluYWxEYXRhVHlwZSwgZmlyc3REYXRhVHlwZSxcblx0XHRjb250ZW50cyA9IHMuY29udGVudHMsXG5cdFx0ZGF0YVR5cGVzID0gcy5kYXRhVHlwZXM7XG5cblx0Ly8gUmVtb3ZlIGF1dG8gZGF0YVR5cGUgYW5kIGdldCBjb250ZW50LXR5cGUgaW4gdGhlIHByb2Nlc3Ncblx0d2hpbGUgKCBkYXRhVHlwZXNbIDAgXSA9PT0gXCIqXCIgKSB7XG5cdFx0ZGF0YVR5cGVzLnNoaWZ0KCk7XG5cdFx0aWYgKCBjdCA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0Y3QgPSBzLm1pbWVUeXBlIHx8IGpxWEhSLmdldFJlc3BvbnNlSGVhZGVyKCBcIkNvbnRlbnQtVHlwZVwiICk7XG5cdFx0fVxuXHR9XG5cblx0Ly8gQ2hlY2sgaWYgd2UncmUgZGVhbGluZyB3aXRoIGEga25vd24gY29udGVudC10eXBlXG5cdGlmICggY3QgKSB7XG5cdFx0Zm9yICggdHlwZSBpbiBjb250ZW50cyApIHtcblx0XHRcdGlmICggY29udGVudHNbIHR5cGUgXSAmJiBjb250ZW50c1sgdHlwZSBdLnRlc3QoIGN0ICkgKSB7XG5cdFx0XHRcdGRhdGFUeXBlcy51bnNoaWZ0KCB0eXBlICk7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8vIENoZWNrIHRvIHNlZSBpZiB3ZSBoYXZlIGEgcmVzcG9uc2UgZm9yIHRoZSBleHBlY3RlZCBkYXRhVHlwZVxuXHRpZiAoIGRhdGFUeXBlc1sgMCBdIGluIHJlc3BvbnNlcyApIHtcblx0XHRmaW5hbERhdGFUeXBlID0gZGF0YVR5cGVzWyAwIF07XG5cdH0gZWxzZSB7XG5cblx0XHQvLyBUcnkgY29udmVydGlibGUgZGF0YVR5cGVzXG5cdFx0Zm9yICggdHlwZSBpbiByZXNwb25zZXMgKSB7XG5cdFx0XHRpZiAoICFkYXRhVHlwZXNbIDAgXSB8fCBzLmNvbnZlcnRlcnNbIHR5cGUgKyBcIiBcIiArIGRhdGFUeXBlc1sgMCBdIF0gKSB7XG5cdFx0XHRcdGZpbmFsRGF0YVR5cGUgPSB0eXBlO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHRcdGlmICggIWZpcnN0RGF0YVR5cGUgKSB7XG5cdFx0XHRcdGZpcnN0RGF0YVR5cGUgPSB0eXBlO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIE9yIGp1c3QgdXNlIGZpcnN0IG9uZVxuXHRcdGZpbmFsRGF0YVR5cGUgPSBmaW5hbERhdGFUeXBlIHx8IGZpcnN0RGF0YVR5cGU7XG5cdH1cblxuXHQvLyBJZiB3ZSBmb3VuZCBhIGRhdGFUeXBlXG5cdC8vIFdlIGFkZCB0aGUgZGF0YVR5cGUgdG8gdGhlIGxpc3QgaWYgbmVlZGVkXG5cdC8vIGFuZCByZXR1cm4gdGhlIGNvcnJlc3BvbmRpbmcgcmVzcG9uc2Vcblx0aWYgKCBmaW5hbERhdGFUeXBlICkge1xuXHRcdGlmICggZmluYWxEYXRhVHlwZSAhPT0gZGF0YVR5cGVzWyAwIF0gKSB7XG5cdFx0XHRkYXRhVHlwZXMudW5zaGlmdCggZmluYWxEYXRhVHlwZSApO1xuXHRcdH1cblx0XHRyZXR1cm4gcmVzcG9uc2VzWyBmaW5hbERhdGFUeXBlIF07XG5cdH1cbn1cblxuLyogQ2hhaW4gY29udmVyc2lvbnMgZ2l2ZW4gdGhlIHJlcXVlc3QgYW5kIHRoZSBvcmlnaW5hbCByZXNwb25zZVxuICogQWxzbyBzZXRzIHRoZSByZXNwb25zZVhYWCBmaWVsZHMgb24gdGhlIGpxWEhSIGluc3RhbmNlXG4gKi9cbmZ1bmN0aW9uIGFqYXhDb252ZXJ0KCBzLCByZXNwb25zZSwganFYSFIsIGlzU3VjY2VzcyApIHtcblx0dmFyIGNvbnYyLCBjdXJyZW50LCBjb252LCB0bXAsIHByZXYsXG5cdFx0Y29udmVydGVycyA9IHt9LFxuXG5cdFx0Ly8gV29yayB3aXRoIGEgY29weSBvZiBkYXRhVHlwZXMgaW4gY2FzZSB3ZSBuZWVkIHRvIG1vZGlmeSBpdCBmb3IgY29udmVyc2lvblxuXHRcdGRhdGFUeXBlcyA9IHMuZGF0YVR5cGVzLnNsaWNlKCk7XG5cblx0Ly8gQ3JlYXRlIGNvbnZlcnRlcnMgbWFwIHdpdGggbG93ZXJjYXNlZCBrZXlzXG5cdGlmICggZGF0YVR5cGVzWyAxIF0gKSB7XG5cdFx0Zm9yICggY29udiBpbiBzLmNvbnZlcnRlcnMgKSB7XG5cdFx0XHRjb252ZXJ0ZXJzWyBjb252LnRvTG93ZXJDYXNlKCkgXSA9IHMuY29udmVydGVyc1sgY29udiBdO1xuXHRcdH1cblx0fVxuXG5cdGN1cnJlbnQgPSBkYXRhVHlwZXMuc2hpZnQoKTtcblxuXHQvLyBDb252ZXJ0IHRvIGVhY2ggc2VxdWVudGlhbCBkYXRhVHlwZVxuXHR3aGlsZSAoIGN1cnJlbnQgKSB7XG5cblx0XHRpZiAoIHMucmVzcG9uc2VGaWVsZHNbIGN1cnJlbnQgXSApIHtcblx0XHRcdGpxWEhSWyBzLnJlc3BvbnNlRmllbGRzWyBjdXJyZW50IF0gXSA9IHJlc3BvbnNlO1xuXHRcdH1cblxuXHRcdC8vIEFwcGx5IHRoZSBkYXRhRmlsdGVyIGlmIHByb3ZpZGVkXG5cdFx0aWYgKCAhcHJldiAmJiBpc1N1Y2Nlc3MgJiYgcy5kYXRhRmlsdGVyICkge1xuXHRcdFx0cmVzcG9uc2UgPSBzLmRhdGFGaWx0ZXIoIHJlc3BvbnNlLCBzLmRhdGFUeXBlICk7XG5cdFx0fVxuXG5cdFx0cHJldiA9IGN1cnJlbnQ7XG5cdFx0Y3VycmVudCA9IGRhdGFUeXBlcy5zaGlmdCgpO1xuXG5cdFx0aWYgKCBjdXJyZW50ICkge1xuXG5cdFx0XHQvLyBUaGVyZSdzIG9ubHkgd29yayB0byBkbyBpZiBjdXJyZW50IGRhdGFUeXBlIGlzIG5vbi1hdXRvXG5cdFx0XHRpZiAoIGN1cnJlbnQgPT09IFwiKlwiICkge1xuXG5cdFx0XHRcdGN1cnJlbnQgPSBwcmV2O1xuXG5cdFx0XHQvLyBDb252ZXJ0IHJlc3BvbnNlIGlmIHByZXYgZGF0YVR5cGUgaXMgbm9uLWF1dG8gYW5kIGRpZmZlcnMgZnJvbSBjdXJyZW50XG5cdFx0XHR9IGVsc2UgaWYgKCBwcmV2ICE9PSBcIipcIiAmJiBwcmV2ICE9PSBjdXJyZW50ICkge1xuXG5cdFx0XHRcdC8vIFNlZWsgYSBkaXJlY3QgY29udmVydGVyXG5cdFx0XHRcdGNvbnYgPSBjb252ZXJ0ZXJzWyBwcmV2ICsgXCIgXCIgKyBjdXJyZW50IF0gfHwgY29udmVydGVyc1sgXCIqIFwiICsgY3VycmVudCBdO1xuXG5cdFx0XHRcdC8vIElmIG5vbmUgZm91bmQsIHNlZWsgYSBwYWlyXG5cdFx0XHRcdGlmICggIWNvbnYgKSB7XG5cdFx0XHRcdFx0Zm9yICggY29udjIgaW4gY29udmVydGVycyApIHtcblxuXHRcdFx0XHRcdFx0Ly8gSWYgY29udjIgb3V0cHV0cyBjdXJyZW50XG5cdFx0XHRcdFx0XHR0bXAgPSBjb252Mi5zcGxpdCggXCIgXCIgKTtcblx0XHRcdFx0XHRcdGlmICggdG1wWyAxIF0gPT09IGN1cnJlbnQgKSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gSWYgcHJldiBjYW4gYmUgY29udmVydGVkIHRvIGFjY2VwdGVkIGlucHV0XG5cdFx0XHRcdFx0XHRcdGNvbnYgPSBjb252ZXJ0ZXJzWyBwcmV2ICsgXCIgXCIgKyB0bXBbIDAgXSBdIHx8XG5cdFx0XHRcdFx0XHRcdFx0Y29udmVydGVyc1sgXCIqIFwiICsgdG1wWyAwIF0gXTtcblx0XHRcdFx0XHRcdFx0aWYgKCBjb252ICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gQ29uZGVuc2UgZXF1aXZhbGVuY2UgY29udmVydGVyc1xuXHRcdFx0XHRcdFx0XHRcdGlmICggY29udiA9PT0gdHJ1ZSApIHtcblx0XHRcdFx0XHRcdFx0XHRcdGNvbnYgPSBjb252ZXJ0ZXJzWyBjb252MiBdO1xuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gT3RoZXJ3aXNlLCBpbnNlcnQgdGhlIGludGVybWVkaWF0ZSBkYXRhVHlwZVxuXHRcdFx0XHRcdFx0XHRcdH0gZWxzZSBpZiAoIGNvbnZlcnRlcnNbIGNvbnYyIF0gIT09IHRydWUgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRjdXJyZW50ID0gdG1wWyAwIF07XG5cdFx0XHRcdFx0XHRcdFx0XHRkYXRhVHlwZXMudW5zaGlmdCggdG1wWyAxIF0gKTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBBcHBseSBjb252ZXJ0ZXIgKGlmIG5vdCBhbiBlcXVpdmFsZW5jZSlcblx0XHRcdFx0aWYgKCBjb252ICE9PSB0cnVlICkge1xuXG5cdFx0XHRcdFx0Ly8gVW5sZXNzIGVycm9ycyBhcmUgYWxsb3dlZCB0byBidWJibGUsIGNhdGNoIGFuZCByZXR1cm4gdGhlbVxuXHRcdFx0XHRcdGlmICggY29udiAmJiBzLnRocm93cyApIHtcblx0XHRcdFx0XHRcdHJlc3BvbnNlID0gY29udiggcmVzcG9uc2UgKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRcdFx0cmVzcG9uc2UgPSBjb252KCByZXNwb25zZSApO1xuXHRcdFx0XHRcdFx0fSBjYXRjaCAoIGUgKSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybiB7XG5cdFx0XHRcdFx0XHRcdFx0c3RhdGU6IFwicGFyc2VyZXJyb3JcIixcblx0XHRcdFx0XHRcdFx0XHRlcnJvcjogY29udiA/IGUgOiBcIk5vIGNvbnZlcnNpb24gZnJvbSBcIiArIHByZXYgKyBcIiB0byBcIiArIGN1cnJlbnRcblx0XHRcdFx0XHRcdFx0fTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRyZXR1cm4geyBzdGF0ZTogXCJzdWNjZXNzXCIsIGRhdGE6IHJlc3BvbnNlIH07XG59XG5cbmpRdWVyeS5leHRlbmQoIHtcblxuXHQvLyBDb3VudGVyIGZvciBob2xkaW5nIHRoZSBudW1iZXIgb2YgYWN0aXZlIHF1ZXJpZXNcblx0YWN0aXZlOiAwLFxuXG5cdC8vIExhc3QtTW9kaWZpZWQgaGVhZGVyIGNhY2hlIGZvciBuZXh0IHJlcXVlc3Rcblx0bGFzdE1vZGlmaWVkOiB7fSxcblx0ZXRhZzoge30sXG5cblx0YWpheFNldHRpbmdzOiB7XG5cdFx0dXJsOiBsb2NhdGlvbi5ocmVmLFxuXHRcdHR5cGU6IFwiR0VUXCIsXG5cdFx0aXNMb2NhbDogcmxvY2FsUHJvdG9jb2wudGVzdCggbG9jYXRpb24ucHJvdG9jb2wgKSxcblx0XHRnbG9iYWw6IHRydWUsXG5cdFx0cHJvY2Vzc0RhdGE6IHRydWUsXG5cdFx0YXN5bmM6IHRydWUsXG5cdFx0Y29udGVudFR5cGU6IFwiYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkOyBjaGFyc2V0PVVURi04XCIsXG5cblx0XHQvKlxuXHRcdHRpbWVvdXQ6IDAsXG5cdFx0ZGF0YTogbnVsbCxcblx0XHRkYXRhVHlwZTogbnVsbCxcblx0XHR1c2VybmFtZTogbnVsbCxcblx0XHRwYXNzd29yZDogbnVsbCxcblx0XHRjYWNoZTogbnVsbCxcblx0XHR0aHJvd3M6IGZhbHNlLFxuXHRcdHRyYWRpdGlvbmFsOiBmYWxzZSxcblx0XHRoZWFkZXJzOiB7fSxcblx0XHQqL1xuXG5cdFx0YWNjZXB0czoge1xuXHRcdFx0XCIqXCI6IGFsbFR5cGVzLFxuXHRcdFx0dGV4dDogXCJ0ZXh0L3BsYWluXCIsXG5cdFx0XHRodG1sOiBcInRleHQvaHRtbFwiLFxuXHRcdFx0eG1sOiBcImFwcGxpY2F0aW9uL3htbCwgdGV4dC94bWxcIixcblx0XHRcdGpzb246IFwiYXBwbGljYXRpb24vanNvbiwgdGV4dC9qYXZhc2NyaXB0XCJcblx0XHR9LFxuXG5cdFx0Y29udGVudHM6IHtcblx0XHRcdHhtbDogL1xcYnhtbFxcYi8sXG5cdFx0XHRodG1sOiAvXFxiaHRtbC8sXG5cdFx0XHRqc29uOiAvXFxianNvblxcYi9cblx0XHR9LFxuXG5cdFx0cmVzcG9uc2VGaWVsZHM6IHtcblx0XHRcdHhtbDogXCJyZXNwb25zZVhNTFwiLFxuXHRcdFx0dGV4dDogXCJyZXNwb25zZVRleHRcIixcblx0XHRcdGpzb246IFwicmVzcG9uc2VKU09OXCJcblx0XHR9LFxuXG5cdFx0Ly8gRGF0YSBjb252ZXJ0ZXJzXG5cdFx0Ly8gS2V5cyBzZXBhcmF0ZSBzb3VyY2UgKG9yIGNhdGNoYWxsIFwiKlwiKSBhbmQgZGVzdGluYXRpb24gdHlwZXMgd2l0aCBhIHNpbmdsZSBzcGFjZVxuXHRcdGNvbnZlcnRlcnM6IHtcblxuXHRcdFx0Ly8gQ29udmVydCBhbnl0aGluZyB0byB0ZXh0XG5cdFx0XHRcIiogdGV4dFwiOiBTdHJpbmcsXG5cblx0XHRcdC8vIFRleHQgdG8gaHRtbCAodHJ1ZSA9IG5vIHRyYW5zZm9ybWF0aW9uKVxuXHRcdFx0XCJ0ZXh0IGh0bWxcIjogdHJ1ZSxcblxuXHRcdFx0Ly8gRXZhbHVhdGUgdGV4dCBhcyBhIGpzb24gZXhwcmVzc2lvblxuXHRcdFx0XCJ0ZXh0IGpzb25cIjogSlNPTi5wYXJzZSxcblxuXHRcdFx0Ly8gUGFyc2UgdGV4dCBhcyB4bWxcblx0XHRcdFwidGV4dCB4bWxcIjogalF1ZXJ5LnBhcnNlWE1MXG5cdFx0fSxcblxuXHRcdC8vIEZvciBvcHRpb25zIHRoYXQgc2hvdWxkbid0IGJlIGRlZXAgZXh0ZW5kZWQ6XG5cdFx0Ly8geW91IGNhbiBhZGQgeW91ciBvd24gY3VzdG9tIG9wdGlvbnMgaGVyZSBpZlxuXHRcdC8vIGFuZCB3aGVuIHlvdSBjcmVhdGUgb25lIHRoYXQgc2hvdWxkbid0IGJlXG5cdFx0Ly8gZGVlcCBleHRlbmRlZCAoc2VlIGFqYXhFeHRlbmQpXG5cdFx0ZmxhdE9wdGlvbnM6IHtcblx0XHRcdHVybDogdHJ1ZSxcblx0XHRcdGNvbnRleHQ6IHRydWVcblx0XHR9XG5cdH0sXG5cblx0Ly8gQ3JlYXRlcyBhIGZ1bGwgZmxlZGdlZCBzZXR0aW5ncyBvYmplY3QgaW50byB0YXJnZXRcblx0Ly8gd2l0aCBib3RoIGFqYXhTZXR0aW5ncyBhbmQgc2V0dGluZ3MgZmllbGRzLlxuXHQvLyBJZiB0YXJnZXQgaXMgb21pdHRlZCwgd3JpdGVzIGludG8gYWpheFNldHRpbmdzLlxuXHRhamF4U2V0dXA6IGZ1bmN0aW9uKCB0YXJnZXQsIHNldHRpbmdzICkge1xuXHRcdHJldHVybiBzZXR0aW5ncyA/XG5cblx0XHRcdC8vIEJ1aWxkaW5nIGEgc2V0dGluZ3Mgb2JqZWN0XG5cdFx0XHRhamF4RXh0ZW5kKCBhamF4RXh0ZW5kKCB0YXJnZXQsIGpRdWVyeS5hamF4U2V0dGluZ3MgKSwgc2V0dGluZ3MgKSA6XG5cblx0XHRcdC8vIEV4dGVuZGluZyBhamF4U2V0dGluZ3Ncblx0XHRcdGFqYXhFeHRlbmQoIGpRdWVyeS5hamF4U2V0dGluZ3MsIHRhcmdldCApO1xuXHR9LFxuXG5cdGFqYXhQcmVmaWx0ZXI6IGFkZFRvUHJlZmlsdGVyc09yVHJhbnNwb3J0cyggcHJlZmlsdGVycyApLFxuXHRhamF4VHJhbnNwb3J0OiBhZGRUb1ByZWZpbHRlcnNPclRyYW5zcG9ydHMoIHRyYW5zcG9ydHMgKSxcblxuXHQvLyBNYWluIG1ldGhvZFxuXHRhamF4OiBmdW5jdGlvbiggdXJsLCBvcHRpb25zICkge1xuXG5cdFx0Ly8gSWYgdXJsIGlzIGFuIG9iamVjdCwgc2ltdWxhdGUgcHJlLTEuNSBzaWduYXR1cmVcblx0XHRpZiAoIHR5cGVvZiB1cmwgPT09IFwib2JqZWN0XCIgKSB7XG5cdFx0XHRvcHRpb25zID0gdXJsO1xuXHRcdFx0dXJsID0gdW5kZWZpbmVkO1xuXHRcdH1cblxuXHRcdC8vIEZvcmNlIG9wdGlvbnMgdG8gYmUgYW4gb2JqZWN0XG5cdFx0b3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cblx0XHR2YXIgdHJhbnNwb3J0LFxuXG5cdFx0XHQvLyBVUkwgd2l0aG91dCBhbnRpLWNhY2hlIHBhcmFtXG5cdFx0XHRjYWNoZVVSTCxcblxuXHRcdFx0Ly8gUmVzcG9uc2UgaGVhZGVyc1xuXHRcdFx0cmVzcG9uc2VIZWFkZXJzU3RyaW5nLFxuXHRcdFx0cmVzcG9uc2VIZWFkZXJzLFxuXG5cdFx0XHQvLyB0aW1lb3V0IGhhbmRsZVxuXHRcdFx0dGltZW91dFRpbWVyLFxuXG5cdFx0XHQvLyBVcmwgY2xlYW51cCB2YXJcblx0XHRcdHVybEFuY2hvcixcblxuXHRcdFx0Ly8gUmVxdWVzdCBzdGF0ZSAoYmVjb21lcyBmYWxzZSB1cG9uIHNlbmQgYW5kIHRydWUgdXBvbiBjb21wbGV0aW9uKVxuXHRcdFx0Y29tcGxldGVkLFxuXG5cdFx0XHQvLyBUbyBrbm93IGlmIGdsb2JhbCBldmVudHMgYXJlIHRvIGJlIGRpc3BhdGNoZWRcblx0XHRcdGZpcmVHbG9iYWxzLFxuXG5cdFx0XHQvLyBMb29wIHZhcmlhYmxlXG5cdFx0XHRpLFxuXG5cdFx0XHQvLyB1bmNhY2hlZCBwYXJ0IG9mIHRoZSB1cmxcblx0XHRcdHVuY2FjaGVkLFxuXG5cdFx0XHQvLyBDcmVhdGUgdGhlIGZpbmFsIG9wdGlvbnMgb2JqZWN0XG5cdFx0XHRzID0galF1ZXJ5LmFqYXhTZXR1cCgge30sIG9wdGlvbnMgKSxcblxuXHRcdFx0Ly8gQ2FsbGJhY2tzIGNvbnRleHRcblx0XHRcdGNhbGxiYWNrQ29udGV4dCA9IHMuY29udGV4dCB8fCBzLFxuXG5cdFx0XHQvLyBDb250ZXh0IGZvciBnbG9iYWwgZXZlbnRzIGlzIGNhbGxiYWNrQ29udGV4dCBpZiBpdCBpcyBhIERPTSBub2RlIG9yIGpRdWVyeSBjb2xsZWN0aW9uXG5cdFx0XHRnbG9iYWxFdmVudENvbnRleHQgPSBzLmNvbnRleHQgJiZcblx0XHRcdFx0KCBjYWxsYmFja0NvbnRleHQubm9kZVR5cGUgfHwgY2FsbGJhY2tDb250ZXh0LmpxdWVyeSApID9cblx0XHRcdFx0alF1ZXJ5KCBjYWxsYmFja0NvbnRleHQgKSA6XG5cdFx0XHRcdGpRdWVyeS5ldmVudCxcblxuXHRcdFx0Ly8gRGVmZXJyZWRzXG5cdFx0XHRkZWZlcnJlZCA9IGpRdWVyeS5EZWZlcnJlZCgpLFxuXHRcdFx0Y29tcGxldGVEZWZlcnJlZCA9IGpRdWVyeS5DYWxsYmFja3MoIFwib25jZSBtZW1vcnlcIiApLFxuXG5cdFx0XHQvLyBTdGF0dXMtZGVwZW5kZW50IGNhbGxiYWNrc1xuXHRcdFx0c3RhdHVzQ29kZSA9IHMuc3RhdHVzQ29kZSB8fCB7fSxcblxuXHRcdFx0Ly8gSGVhZGVycyAodGhleSBhcmUgc2VudCBhbGwgYXQgb25jZSlcblx0XHRcdHJlcXVlc3RIZWFkZXJzID0ge30sXG5cdFx0XHRyZXF1ZXN0SGVhZGVyc05hbWVzID0ge30sXG5cblx0XHRcdC8vIERlZmF1bHQgYWJvcnQgbWVzc2FnZVxuXHRcdFx0c3RyQWJvcnQgPSBcImNhbmNlbGVkXCIsXG5cblx0XHRcdC8vIEZha2UgeGhyXG5cdFx0XHRqcVhIUiA9IHtcblx0XHRcdFx0cmVhZHlTdGF0ZTogMCxcblxuXHRcdFx0XHQvLyBCdWlsZHMgaGVhZGVycyBoYXNodGFibGUgaWYgbmVlZGVkXG5cdFx0XHRcdGdldFJlc3BvbnNlSGVhZGVyOiBmdW5jdGlvbigga2V5ICkge1xuXHRcdFx0XHRcdHZhciBtYXRjaDtcblx0XHRcdFx0XHRpZiAoIGNvbXBsZXRlZCApIHtcblx0XHRcdFx0XHRcdGlmICggIXJlc3BvbnNlSGVhZGVycyApIHtcblx0XHRcdFx0XHRcdFx0cmVzcG9uc2VIZWFkZXJzID0ge307XG5cdFx0XHRcdFx0XHRcdHdoaWxlICggKCBtYXRjaCA9IHJoZWFkZXJzLmV4ZWMoIHJlc3BvbnNlSGVhZGVyc1N0cmluZyApICkgKSB7XG5cdFx0XHRcdFx0XHRcdFx0cmVzcG9uc2VIZWFkZXJzWyBtYXRjaFsgMSBdLnRvTG93ZXJDYXNlKCkgKyBcIiBcIiBdID1cblx0XHRcdFx0XHRcdFx0XHRcdCggcmVzcG9uc2VIZWFkZXJzWyBtYXRjaFsgMSBdLnRvTG93ZXJDYXNlKCkgKyBcIiBcIiBdIHx8IFtdIClcblx0XHRcdFx0XHRcdFx0XHRcdFx0LmNvbmNhdCggbWF0Y2hbIDIgXSApO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRtYXRjaCA9IHJlc3BvbnNlSGVhZGVyc1sga2V5LnRvTG93ZXJDYXNlKCkgKyBcIiBcIiBdO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gbWF0Y2ggPT0gbnVsbCA/IG51bGwgOiBtYXRjaC5qb2luKCBcIiwgXCIgKTtcblx0XHRcdFx0fSxcblxuXHRcdFx0XHQvLyBSYXcgc3RyaW5nXG5cdFx0XHRcdGdldEFsbFJlc3BvbnNlSGVhZGVyczogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGNvbXBsZXRlZCA/IHJlc3BvbnNlSGVhZGVyc1N0cmluZyA6IG51bGw7XG5cdFx0XHRcdH0sXG5cblx0XHRcdFx0Ly8gQ2FjaGVzIHRoZSBoZWFkZXJcblx0XHRcdFx0c2V0UmVxdWVzdEhlYWRlcjogZnVuY3Rpb24oIG5hbWUsIHZhbHVlICkge1xuXHRcdFx0XHRcdGlmICggY29tcGxldGVkID09IG51bGwgKSB7XG5cdFx0XHRcdFx0XHRuYW1lID0gcmVxdWVzdEhlYWRlcnNOYW1lc1sgbmFtZS50b0xvd2VyQ2FzZSgpIF0gPVxuXHRcdFx0XHRcdFx0XHRyZXF1ZXN0SGVhZGVyc05hbWVzWyBuYW1lLnRvTG93ZXJDYXNlKCkgXSB8fCBuYW1lO1xuXHRcdFx0XHRcdFx0cmVxdWVzdEhlYWRlcnNbIG5hbWUgXSA9IHZhbHVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdFx0fSxcblxuXHRcdFx0XHQvLyBPdmVycmlkZXMgcmVzcG9uc2UgY29udGVudC10eXBlIGhlYWRlclxuXHRcdFx0XHRvdmVycmlkZU1pbWVUeXBlOiBmdW5jdGlvbiggdHlwZSApIHtcblx0XHRcdFx0XHRpZiAoIGNvbXBsZXRlZCA9PSBudWxsICkge1xuXHRcdFx0XHRcdFx0cy5taW1lVHlwZSA9IHR5cGU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0XHR9LFxuXG5cdFx0XHRcdC8vIFN0YXR1cy1kZXBlbmRlbnQgY2FsbGJhY2tzXG5cdFx0XHRcdHN0YXR1c0NvZGU6IGZ1bmN0aW9uKCBtYXAgKSB7XG5cdFx0XHRcdFx0dmFyIGNvZGU7XG5cdFx0XHRcdFx0aWYgKCBtYXAgKSB7XG5cdFx0XHRcdFx0XHRpZiAoIGNvbXBsZXRlZCApIHtcblxuXHRcdFx0XHRcdFx0XHQvLyBFeGVjdXRlIHRoZSBhcHByb3ByaWF0ZSBjYWxsYmFja3Ncblx0XHRcdFx0XHRcdFx0anFYSFIuYWx3YXlzKCBtYXBbIGpxWEhSLnN0YXR1cyBdICk7XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHRcdC8vIExhenktYWRkIHRoZSBuZXcgY2FsbGJhY2tzIGluIGEgd2F5IHRoYXQgcHJlc2VydmVzIG9sZCBvbmVzXG5cdFx0XHRcdFx0XHRcdGZvciAoIGNvZGUgaW4gbWFwICkge1xuXHRcdFx0XHRcdFx0XHRcdHN0YXR1c0NvZGVbIGNvZGUgXSA9IFsgc3RhdHVzQ29kZVsgY29kZSBdLCBtYXBbIGNvZGUgXSBdO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0XHR9LFxuXG5cdFx0XHRcdC8vIENhbmNlbCB0aGUgcmVxdWVzdFxuXHRcdFx0XHRhYm9ydDogZnVuY3Rpb24oIHN0YXR1c1RleHQgKSB7XG5cdFx0XHRcdFx0dmFyIGZpbmFsVGV4dCA9IHN0YXR1c1RleHQgfHwgc3RyQWJvcnQ7XG5cdFx0XHRcdFx0aWYgKCB0cmFuc3BvcnQgKSB7XG5cdFx0XHRcdFx0XHR0cmFuc3BvcnQuYWJvcnQoIGZpbmFsVGV4dCApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRkb25lKCAwLCBmaW5hbFRleHQgKTtcblx0XHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdFx0fVxuXHRcdFx0fTtcblxuXHRcdC8vIEF0dGFjaCBkZWZlcnJlZHNcblx0XHRkZWZlcnJlZC5wcm9taXNlKCBqcVhIUiApO1xuXG5cdFx0Ly8gQWRkIHByb3RvY29sIGlmIG5vdCBwcm92aWRlZCAocHJlZmlsdGVycyBtaWdodCBleHBlY3QgaXQpXG5cdFx0Ly8gSGFuZGxlIGZhbHN5IHVybCBpbiB0aGUgc2V0dGluZ3Mgb2JqZWN0ICgjMTAwOTM6IGNvbnNpc3RlbmN5IHdpdGggb2xkIHNpZ25hdHVyZSlcblx0XHQvLyBXZSBhbHNvIHVzZSB0aGUgdXJsIHBhcmFtZXRlciBpZiBhdmFpbGFibGVcblx0XHRzLnVybCA9ICggKCB1cmwgfHwgcy51cmwgfHwgbG9jYXRpb24uaHJlZiApICsgXCJcIiApXG5cdFx0XHQucmVwbGFjZSggcnByb3RvY29sLCBsb2NhdGlvbi5wcm90b2NvbCArIFwiLy9cIiApO1xuXG5cdFx0Ly8gQWxpYXMgbWV0aG9kIG9wdGlvbiB0byB0eXBlIGFzIHBlciB0aWNrZXQgIzEyMDA0XG5cdFx0cy50eXBlID0gb3B0aW9ucy5tZXRob2QgfHwgb3B0aW9ucy50eXBlIHx8IHMubWV0aG9kIHx8IHMudHlwZTtcblxuXHRcdC8vIEV4dHJhY3QgZGF0YVR5cGVzIGxpc3Rcblx0XHRzLmRhdGFUeXBlcyA9ICggcy5kYXRhVHlwZSB8fCBcIipcIiApLnRvTG93ZXJDYXNlKCkubWF0Y2goIHJub3RodG1sd2hpdGUgKSB8fCBbIFwiXCIgXTtcblxuXHRcdC8vIEEgY3Jvc3MtZG9tYWluIHJlcXVlc3QgaXMgaW4gb3JkZXIgd2hlbiB0aGUgb3JpZ2luIGRvZXNuJ3QgbWF0Y2ggdGhlIGN1cnJlbnQgb3JpZ2luLlxuXHRcdGlmICggcy5jcm9zc0RvbWFpbiA9PSBudWxsICkge1xuXHRcdFx0dXJsQW5jaG9yID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJhXCIgKTtcblxuXHRcdFx0Ly8gU3VwcG9ydDogSUUgPD04IC0gMTEsIEVkZ2UgMTIgLSAxNVxuXHRcdFx0Ly8gSUUgdGhyb3dzIGV4Y2VwdGlvbiBvbiBhY2Nlc3NpbmcgdGhlIGhyZWYgcHJvcGVydHkgaWYgdXJsIGlzIG1hbGZvcm1lZCxcblx0XHRcdC8vIGUuZy4gaHR0cDovL2V4YW1wbGUuY29tOjgweC9cblx0XHRcdHRyeSB7XG5cdFx0XHRcdHVybEFuY2hvci5ocmVmID0gcy51cmw7XG5cblx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgPD04IC0gMTEgb25seVxuXHRcdFx0XHQvLyBBbmNob3IncyBob3N0IHByb3BlcnR5IGlzbid0IGNvcnJlY3RseSBzZXQgd2hlbiBzLnVybCBpcyByZWxhdGl2ZVxuXHRcdFx0XHR1cmxBbmNob3IuaHJlZiA9IHVybEFuY2hvci5ocmVmO1xuXHRcdFx0XHRzLmNyb3NzRG9tYWluID0gb3JpZ2luQW5jaG9yLnByb3RvY29sICsgXCIvL1wiICsgb3JpZ2luQW5jaG9yLmhvc3QgIT09XG5cdFx0XHRcdFx0dXJsQW5jaG9yLnByb3RvY29sICsgXCIvL1wiICsgdXJsQW5jaG9yLmhvc3Q7XG5cdFx0XHR9IGNhdGNoICggZSApIHtcblxuXHRcdFx0XHQvLyBJZiB0aGVyZSBpcyBhbiBlcnJvciBwYXJzaW5nIHRoZSBVUkwsIGFzc3VtZSBpdCBpcyBjcm9zc0RvbWFpbixcblx0XHRcdFx0Ly8gaXQgY2FuIGJlIHJlamVjdGVkIGJ5IHRoZSB0cmFuc3BvcnQgaWYgaXQgaXMgaW52YWxpZFxuXHRcdFx0XHRzLmNyb3NzRG9tYWluID0gdHJ1ZTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBDb252ZXJ0IGRhdGEgaWYgbm90IGFscmVhZHkgYSBzdHJpbmdcblx0XHRpZiAoIHMuZGF0YSAmJiBzLnByb2Nlc3NEYXRhICYmIHR5cGVvZiBzLmRhdGEgIT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRzLmRhdGEgPSBqUXVlcnkucGFyYW0oIHMuZGF0YSwgcy50cmFkaXRpb25hbCApO1xuXHRcdH1cblxuXHRcdC8vIEFwcGx5IHByZWZpbHRlcnNcblx0XHRpbnNwZWN0UHJlZmlsdGVyc09yVHJhbnNwb3J0cyggcHJlZmlsdGVycywgcywgb3B0aW9ucywganFYSFIgKTtcblxuXHRcdC8vIElmIHJlcXVlc3Qgd2FzIGFib3J0ZWQgaW5zaWRlIGEgcHJlZmlsdGVyLCBzdG9wIHRoZXJlXG5cdFx0aWYgKCBjb21wbGV0ZWQgKSB7XG5cdFx0XHRyZXR1cm4ganFYSFI7XG5cdFx0fVxuXG5cdFx0Ly8gV2UgY2FuIGZpcmUgZ2xvYmFsIGV2ZW50cyBhcyBvZiBub3cgaWYgYXNrZWQgdG9cblx0XHQvLyBEb24ndCBmaXJlIGV2ZW50cyBpZiBqUXVlcnkuZXZlbnQgaXMgdW5kZWZpbmVkIGluIGFuIEFNRC11c2FnZSBzY2VuYXJpbyAoIzE1MTE4KVxuXHRcdGZpcmVHbG9iYWxzID0galF1ZXJ5LmV2ZW50ICYmIHMuZ2xvYmFsO1xuXG5cdFx0Ly8gV2F0Y2ggZm9yIGEgbmV3IHNldCBvZiByZXF1ZXN0c1xuXHRcdGlmICggZmlyZUdsb2JhbHMgJiYgalF1ZXJ5LmFjdGl2ZSsrID09PSAwICkge1xuXHRcdFx0alF1ZXJ5LmV2ZW50LnRyaWdnZXIoIFwiYWpheFN0YXJ0XCIgKTtcblx0XHR9XG5cblx0XHQvLyBVcHBlcmNhc2UgdGhlIHR5cGVcblx0XHRzLnR5cGUgPSBzLnR5cGUudG9VcHBlckNhc2UoKTtcblxuXHRcdC8vIERldGVybWluZSBpZiByZXF1ZXN0IGhhcyBjb250ZW50XG5cdFx0cy5oYXNDb250ZW50ID0gIXJub0NvbnRlbnQudGVzdCggcy50eXBlICk7XG5cblx0XHQvLyBTYXZlIHRoZSBVUkwgaW4gY2FzZSB3ZSdyZSB0b3lpbmcgd2l0aCB0aGUgSWYtTW9kaWZpZWQtU2luY2Vcblx0XHQvLyBhbmQvb3IgSWYtTm9uZS1NYXRjaCBoZWFkZXIgbGF0ZXIgb25cblx0XHQvLyBSZW1vdmUgaGFzaCB0byBzaW1wbGlmeSB1cmwgbWFuaXB1bGF0aW9uXG5cdFx0Y2FjaGVVUkwgPSBzLnVybC5yZXBsYWNlKCByaGFzaCwgXCJcIiApO1xuXG5cdFx0Ly8gTW9yZSBvcHRpb25zIGhhbmRsaW5nIGZvciByZXF1ZXN0cyB3aXRoIG5vIGNvbnRlbnRcblx0XHRpZiAoICFzLmhhc0NvbnRlbnQgKSB7XG5cblx0XHRcdC8vIFJlbWVtYmVyIHRoZSBoYXNoIHNvIHdlIGNhbiBwdXQgaXQgYmFja1xuXHRcdFx0dW5jYWNoZWQgPSBzLnVybC5zbGljZSggY2FjaGVVUkwubGVuZ3RoICk7XG5cblx0XHRcdC8vIElmIGRhdGEgaXMgYXZhaWxhYmxlIGFuZCBzaG91bGQgYmUgcHJvY2Vzc2VkLCBhcHBlbmQgZGF0YSB0byB1cmxcblx0XHRcdGlmICggcy5kYXRhICYmICggcy5wcm9jZXNzRGF0YSB8fCB0eXBlb2Ygcy5kYXRhID09PSBcInN0cmluZ1wiICkgKSB7XG5cdFx0XHRcdGNhY2hlVVJMICs9ICggcnF1ZXJ5LnRlc3QoIGNhY2hlVVJMICkgPyBcIiZcIiA6IFwiP1wiICkgKyBzLmRhdGE7XG5cblx0XHRcdFx0Ly8gIzk2ODI6IHJlbW92ZSBkYXRhIHNvIHRoYXQgaXQncyBub3QgdXNlZCBpbiBhbiBldmVudHVhbCByZXRyeVxuXHRcdFx0XHRkZWxldGUgcy5kYXRhO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBBZGQgb3IgdXBkYXRlIGFudGktY2FjaGUgcGFyYW0gaWYgbmVlZGVkXG5cdFx0XHRpZiAoIHMuY2FjaGUgPT09IGZhbHNlICkge1xuXHRcdFx0XHRjYWNoZVVSTCA9IGNhY2hlVVJMLnJlcGxhY2UoIHJhbnRpQ2FjaGUsIFwiJDFcIiApO1xuXHRcdFx0XHR1bmNhY2hlZCA9ICggcnF1ZXJ5LnRlc3QoIGNhY2hlVVJMICkgPyBcIiZcIiA6IFwiP1wiICkgKyBcIl89XCIgKyAoIG5vbmNlLmd1aWQrKyApICtcblx0XHRcdFx0XHR1bmNhY2hlZDtcblx0XHRcdH1cblxuXHRcdFx0Ly8gUHV0IGhhc2ggYW5kIGFudGktY2FjaGUgb24gdGhlIFVSTCB0aGF0IHdpbGwgYmUgcmVxdWVzdGVkIChnaC0xNzMyKVxuXHRcdFx0cy51cmwgPSBjYWNoZVVSTCArIHVuY2FjaGVkO1xuXG5cdFx0Ly8gQ2hhbmdlICclMjAnIHRvICcrJyBpZiB0aGlzIGlzIGVuY29kZWQgZm9ybSBib2R5IGNvbnRlbnQgKGdoLTI2NTgpXG5cdFx0fSBlbHNlIGlmICggcy5kYXRhICYmIHMucHJvY2Vzc0RhdGEgJiZcblx0XHRcdCggcy5jb250ZW50VHlwZSB8fCBcIlwiICkuaW5kZXhPZiggXCJhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWRcIiApID09PSAwICkge1xuXHRcdFx0cy5kYXRhID0gcy5kYXRhLnJlcGxhY2UoIHIyMCwgXCIrXCIgKTtcblx0XHR9XG5cblx0XHQvLyBTZXQgdGhlIElmLU1vZGlmaWVkLVNpbmNlIGFuZC9vciBJZi1Ob25lLU1hdGNoIGhlYWRlciwgaWYgaW4gaWZNb2RpZmllZCBtb2RlLlxuXHRcdGlmICggcy5pZk1vZGlmaWVkICkge1xuXHRcdFx0aWYgKCBqUXVlcnkubGFzdE1vZGlmaWVkWyBjYWNoZVVSTCBdICkge1xuXHRcdFx0XHRqcVhIUi5zZXRSZXF1ZXN0SGVhZGVyKCBcIklmLU1vZGlmaWVkLVNpbmNlXCIsIGpRdWVyeS5sYXN0TW9kaWZpZWRbIGNhY2hlVVJMIF0gKTtcblx0XHRcdH1cblx0XHRcdGlmICggalF1ZXJ5LmV0YWdbIGNhY2hlVVJMIF0gKSB7XG5cdFx0XHRcdGpxWEhSLnNldFJlcXVlc3RIZWFkZXIoIFwiSWYtTm9uZS1NYXRjaFwiLCBqUXVlcnkuZXRhZ1sgY2FjaGVVUkwgXSApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIFNldCB0aGUgY29ycmVjdCBoZWFkZXIsIGlmIGRhdGEgaXMgYmVpbmcgc2VudFxuXHRcdGlmICggcy5kYXRhICYmIHMuaGFzQ29udGVudCAmJiBzLmNvbnRlbnRUeXBlICE9PSBmYWxzZSB8fCBvcHRpb25zLmNvbnRlbnRUeXBlICkge1xuXHRcdFx0anFYSFIuc2V0UmVxdWVzdEhlYWRlciggXCJDb250ZW50LVR5cGVcIiwgcy5jb250ZW50VHlwZSApO1xuXHRcdH1cblxuXHRcdC8vIFNldCB0aGUgQWNjZXB0cyBoZWFkZXIgZm9yIHRoZSBzZXJ2ZXIsIGRlcGVuZGluZyBvbiB0aGUgZGF0YVR5cGVcblx0XHRqcVhIUi5zZXRSZXF1ZXN0SGVhZGVyKFxuXHRcdFx0XCJBY2NlcHRcIixcblx0XHRcdHMuZGF0YVR5cGVzWyAwIF0gJiYgcy5hY2NlcHRzWyBzLmRhdGFUeXBlc1sgMCBdIF0gP1xuXHRcdFx0XHRzLmFjY2VwdHNbIHMuZGF0YVR5cGVzWyAwIF0gXSArXG5cdFx0XHRcdFx0KCBzLmRhdGFUeXBlc1sgMCBdICE9PSBcIipcIiA/IFwiLCBcIiArIGFsbFR5cGVzICsgXCI7IHE9MC4wMVwiIDogXCJcIiApIDpcblx0XHRcdFx0cy5hY2NlcHRzWyBcIipcIiBdXG5cdFx0KTtcblxuXHRcdC8vIENoZWNrIGZvciBoZWFkZXJzIG9wdGlvblxuXHRcdGZvciAoIGkgaW4gcy5oZWFkZXJzICkge1xuXHRcdFx0anFYSFIuc2V0UmVxdWVzdEhlYWRlciggaSwgcy5oZWFkZXJzWyBpIF0gKTtcblx0XHR9XG5cblx0XHQvLyBBbGxvdyBjdXN0b20gaGVhZGVycy9taW1ldHlwZXMgYW5kIGVhcmx5IGFib3J0XG5cdFx0aWYgKCBzLmJlZm9yZVNlbmQgJiZcblx0XHRcdCggcy5iZWZvcmVTZW5kLmNhbGwoIGNhbGxiYWNrQ29udGV4dCwganFYSFIsIHMgKSA9PT0gZmFsc2UgfHwgY29tcGxldGVkICkgKSB7XG5cblx0XHRcdC8vIEFib3J0IGlmIG5vdCBkb25lIGFscmVhZHkgYW5kIHJldHVyblxuXHRcdFx0cmV0dXJuIGpxWEhSLmFib3J0KCk7XG5cdFx0fVxuXG5cdFx0Ly8gQWJvcnRpbmcgaXMgbm8gbG9uZ2VyIGEgY2FuY2VsbGF0aW9uXG5cdFx0c3RyQWJvcnQgPSBcImFib3J0XCI7XG5cblx0XHQvLyBJbnN0YWxsIGNhbGxiYWNrcyBvbiBkZWZlcnJlZHNcblx0XHRjb21wbGV0ZURlZmVycmVkLmFkZCggcy5jb21wbGV0ZSApO1xuXHRcdGpxWEhSLmRvbmUoIHMuc3VjY2VzcyApO1xuXHRcdGpxWEhSLmZhaWwoIHMuZXJyb3IgKTtcblxuXHRcdC8vIEdldCB0cmFuc3BvcnRcblx0XHR0cmFuc3BvcnQgPSBpbnNwZWN0UHJlZmlsdGVyc09yVHJhbnNwb3J0cyggdHJhbnNwb3J0cywgcywgb3B0aW9ucywganFYSFIgKTtcblxuXHRcdC8vIElmIG5vIHRyYW5zcG9ydCwgd2UgYXV0by1hYm9ydFxuXHRcdGlmICggIXRyYW5zcG9ydCApIHtcblx0XHRcdGRvbmUoIC0xLCBcIk5vIFRyYW5zcG9ydFwiICk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGpxWEhSLnJlYWR5U3RhdGUgPSAxO1xuXG5cdFx0XHQvLyBTZW5kIGdsb2JhbCBldmVudFxuXHRcdFx0aWYgKCBmaXJlR2xvYmFscyApIHtcblx0XHRcdFx0Z2xvYmFsRXZlbnRDb250ZXh0LnRyaWdnZXIoIFwiYWpheFNlbmRcIiwgWyBqcVhIUiwgcyBdICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIElmIHJlcXVlc3Qgd2FzIGFib3J0ZWQgaW5zaWRlIGFqYXhTZW5kLCBzdG9wIHRoZXJlXG5cdFx0XHRpZiAoIGNvbXBsZXRlZCApIHtcblx0XHRcdFx0cmV0dXJuIGpxWEhSO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBUaW1lb3V0XG5cdFx0XHRpZiAoIHMuYXN5bmMgJiYgcy50aW1lb3V0ID4gMCApIHtcblx0XHRcdFx0dGltZW91dFRpbWVyID0gd2luZG93LnNldFRpbWVvdXQoIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdGpxWEhSLmFib3J0KCBcInRpbWVvdXRcIiApO1xuXHRcdFx0XHR9LCBzLnRpbWVvdXQgKTtcblx0XHRcdH1cblxuXHRcdFx0dHJ5IHtcblx0XHRcdFx0Y29tcGxldGVkID0gZmFsc2U7XG5cdFx0XHRcdHRyYW5zcG9ydC5zZW5kKCByZXF1ZXN0SGVhZGVycywgZG9uZSApO1xuXHRcdFx0fSBjYXRjaCAoIGUgKSB7XG5cblx0XHRcdFx0Ly8gUmV0aHJvdyBwb3N0LWNvbXBsZXRpb24gZXhjZXB0aW9uc1xuXHRcdFx0XHRpZiAoIGNvbXBsZXRlZCApIHtcblx0XHRcdFx0XHR0aHJvdyBlO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gUHJvcGFnYXRlIG90aGVycyBhcyByZXN1bHRzXG5cdFx0XHRcdGRvbmUoIC0xLCBlICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gQ2FsbGJhY2sgZm9yIHdoZW4gZXZlcnl0aGluZyBpcyBkb25lXG5cdFx0ZnVuY3Rpb24gZG9uZSggc3RhdHVzLCBuYXRpdmVTdGF0dXNUZXh0LCByZXNwb25zZXMsIGhlYWRlcnMgKSB7XG5cdFx0XHR2YXIgaXNTdWNjZXNzLCBzdWNjZXNzLCBlcnJvciwgcmVzcG9uc2UsIG1vZGlmaWVkLFxuXHRcdFx0XHRzdGF0dXNUZXh0ID0gbmF0aXZlU3RhdHVzVGV4dDtcblxuXHRcdFx0Ly8gSWdub3JlIHJlcGVhdCBpbnZvY2F0aW9uc1xuXHRcdFx0aWYgKCBjb21wbGV0ZWQgKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0Y29tcGxldGVkID0gdHJ1ZTtcblxuXHRcdFx0Ly8gQ2xlYXIgdGltZW91dCBpZiBpdCBleGlzdHNcblx0XHRcdGlmICggdGltZW91dFRpbWVyICkge1xuXHRcdFx0XHR3aW5kb3cuY2xlYXJUaW1lb3V0KCB0aW1lb3V0VGltZXIgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gRGVyZWZlcmVuY2UgdHJhbnNwb3J0IGZvciBlYXJseSBnYXJiYWdlIGNvbGxlY3Rpb25cblx0XHRcdC8vIChubyBtYXR0ZXIgaG93IGxvbmcgdGhlIGpxWEhSIG9iamVjdCB3aWxsIGJlIHVzZWQpXG5cdFx0XHR0cmFuc3BvcnQgPSB1bmRlZmluZWQ7XG5cblx0XHRcdC8vIENhY2hlIHJlc3BvbnNlIGhlYWRlcnNcblx0XHRcdHJlc3BvbnNlSGVhZGVyc1N0cmluZyA9IGhlYWRlcnMgfHwgXCJcIjtcblxuXHRcdFx0Ly8gU2V0IHJlYWR5U3RhdGVcblx0XHRcdGpxWEhSLnJlYWR5U3RhdGUgPSBzdGF0dXMgPiAwID8gNCA6IDA7XG5cblx0XHRcdC8vIERldGVybWluZSBpZiBzdWNjZXNzZnVsXG5cdFx0XHRpc1N1Y2Nlc3MgPSBzdGF0dXMgPj0gMjAwICYmIHN0YXR1cyA8IDMwMCB8fCBzdGF0dXMgPT09IDMwNDtcblxuXHRcdFx0Ly8gR2V0IHJlc3BvbnNlIGRhdGFcblx0XHRcdGlmICggcmVzcG9uc2VzICkge1xuXHRcdFx0XHRyZXNwb25zZSA9IGFqYXhIYW5kbGVSZXNwb25zZXMoIHMsIGpxWEhSLCByZXNwb25zZXMgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gVXNlIGEgbm9vcCBjb252ZXJ0ZXIgZm9yIG1pc3Npbmcgc2NyaXB0IGJ1dCBub3QgaWYganNvbnBcblx0XHRcdGlmICggIWlzU3VjY2VzcyAmJlxuXHRcdFx0XHRqUXVlcnkuaW5BcnJheSggXCJzY3JpcHRcIiwgcy5kYXRhVHlwZXMgKSA+IC0xICYmXG5cdFx0XHRcdGpRdWVyeS5pbkFycmF5KCBcImpzb25cIiwgcy5kYXRhVHlwZXMgKSA8IDAgKSB7XG5cdFx0XHRcdHMuY29udmVydGVyc1sgXCJ0ZXh0IHNjcmlwdFwiIF0gPSBmdW5jdGlvbigpIHt9O1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBDb252ZXJ0IG5vIG1hdHRlciB3aGF0ICh0aGF0IHdheSByZXNwb25zZVhYWCBmaWVsZHMgYXJlIGFsd2F5cyBzZXQpXG5cdFx0XHRyZXNwb25zZSA9IGFqYXhDb252ZXJ0KCBzLCByZXNwb25zZSwganFYSFIsIGlzU3VjY2VzcyApO1xuXG5cdFx0XHQvLyBJZiBzdWNjZXNzZnVsLCBoYW5kbGUgdHlwZSBjaGFpbmluZ1xuXHRcdFx0aWYgKCBpc1N1Y2Nlc3MgKSB7XG5cblx0XHRcdFx0Ly8gU2V0IHRoZSBJZi1Nb2RpZmllZC1TaW5jZSBhbmQvb3IgSWYtTm9uZS1NYXRjaCBoZWFkZXIsIGlmIGluIGlmTW9kaWZpZWQgbW9kZS5cblx0XHRcdFx0aWYgKCBzLmlmTW9kaWZpZWQgKSB7XG5cdFx0XHRcdFx0bW9kaWZpZWQgPSBqcVhIUi5nZXRSZXNwb25zZUhlYWRlciggXCJMYXN0LU1vZGlmaWVkXCIgKTtcblx0XHRcdFx0XHRpZiAoIG1vZGlmaWVkICkge1xuXHRcdFx0XHRcdFx0alF1ZXJ5Lmxhc3RNb2RpZmllZFsgY2FjaGVVUkwgXSA9IG1vZGlmaWVkO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRtb2RpZmllZCA9IGpxWEhSLmdldFJlc3BvbnNlSGVhZGVyKCBcImV0YWdcIiApO1xuXHRcdFx0XHRcdGlmICggbW9kaWZpZWQgKSB7XG5cdFx0XHRcdFx0XHRqUXVlcnkuZXRhZ1sgY2FjaGVVUkwgXSA9IG1vZGlmaWVkO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIGlmIG5vIGNvbnRlbnRcblx0XHRcdFx0aWYgKCBzdGF0dXMgPT09IDIwNCB8fCBzLnR5cGUgPT09IFwiSEVBRFwiICkge1xuXHRcdFx0XHRcdHN0YXR1c1RleHQgPSBcIm5vY29udGVudFwiO1xuXG5cdFx0XHRcdC8vIGlmIG5vdCBtb2RpZmllZFxuXHRcdFx0XHR9IGVsc2UgaWYgKCBzdGF0dXMgPT09IDMwNCApIHtcblx0XHRcdFx0XHRzdGF0dXNUZXh0ID0gXCJub3Rtb2RpZmllZFwiO1xuXG5cdFx0XHRcdC8vIElmIHdlIGhhdmUgZGF0YSwgbGV0J3MgY29udmVydCBpdFxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHN0YXR1c1RleHQgPSByZXNwb25zZS5zdGF0ZTtcblx0XHRcdFx0XHRzdWNjZXNzID0gcmVzcG9uc2UuZGF0YTtcblx0XHRcdFx0XHRlcnJvciA9IHJlc3BvbnNlLmVycm9yO1xuXHRcdFx0XHRcdGlzU3VjY2VzcyA9ICFlcnJvcjtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHQvLyBFeHRyYWN0IGVycm9yIGZyb20gc3RhdHVzVGV4dCBhbmQgbm9ybWFsaXplIGZvciBub24tYWJvcnRzXG5cdFx0XHRcdGVycm9yID0gc3RhdHVzVGV4dDtcblx0XHRcdFx0aWYgKCBzdGF0dXMgfHwgIXN0YXR1c1RleHQgKSB7XG5cdFx0XHRcdFx0c3RhdHVzVGV4dCA9IFwiZXJyb3JcIjtcblx0XHRcdFx0XHRpZiAoIHN0YXR1cyA8IDAgKSB7XG5cdFx0XHRcdFx0XHRzdGF0dXMgPSAwO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBTZXQgZGF0YSBmb3IgdGhlIGZha2UgeGhyIG9iamVjdFxuXHRcdFx0anFYSFIuc3RhdHVzID0gc3RhdHVzO1xuXHRcdFx0anFYSFIuc3RhdHVzVGV4dCA9ICggbmF0aXZlU3RhdHVzVGV4dCB8fCBzdGF0dXNUZXh0ICkgKyBcIlwiO1xuXG5cdFx0XHQvLyBTdWNjZXNzL0Vycm9yXG5cdFx0XHRpZiAoIGlzU3VjY2VzcyApIHtcblx0XHRcdFx0ZGVmZXJyZWQucmVzb2x2ZVdpdGgoIGNhbGxiYWNrQ29udGV4dCwgWyBzdWNjZXNzLCBzdGF0dXNUZXh0LCBqcVhIUiBdICk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRkZWZlcnJlZC5yZWplY3RXaXRoKCBjYWxsYmFja0NvbnRleHQsIFsganFYSFIsIHN0YXR1c1RleHQsIGVycm9yIF0gKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gU3RhdHVzLWRlcGVuZGVudCBjYWxsYmFja3Ncblx0XHRcdGpxWEhSLnN0YXR1c0NvZGUoIHN0YXR1c0NvZGUgKTtcblx0XHRcdHN0YXR1c0NvZGUgPSB1bmRlZmluZWQ7XG5cblx0XHRcdGlmICggZmlyZUdsb2JhbHMgKSB7XG5cdFx0XHRcdGdsb2JhbEV2ZW50Q29udGV4dC50cmlnZ2VyKCBpc1N1Y2Nlc3MgPyBcImFqYXhTdWNjZXNzXCIgOiBcImFqYXhFcnJvclwiLFxuXHRcdFx0XHRcdFsganFYSFIsIHMsIGlzU3VjY2VzcyA/IHN1Y2Nlc3MgOiBlcnJvciBdICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIENvbXBsZXRlXG5cdFx0XHRjb21wbGV0ZURlZmVycmVkLmZpcmVXaXRoKCBjYWxsYmFja0NvbnRleHQsIFsganFYSFIsIHN0YXR1c1RleHQgXSApO1xuXG5cdFx0XHRpZiAoIGZpcmVHbG9iYWxzICkge1xuXHRcdFx0XHRnbG9iYWxFdmVudENvbnRleHQudHJpZ2dlciggXCJhamF4Q29tcGxldGVcIiwgWyBqcVhIUiwgcyBdICk7XG5cblx0XHRcdFx0Ly8gSGFuZGxlIHRoZSBnbG9iYWwgQUpBWCBjb3VudGVyXG5cdFx0XHRcdGlmICggISggLS1qUXVlcnkuYWN0aXZlICkgKSB7XG5cdFx0XHRcdFx0alF1ZXJ5LmV2ZW50LnRyaWdnZXIoIFwiYWpheFN0b3BcIiApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGpxWEhSO1xuXHR9LFxuXG5cdGdldEpTT046IGZ1bmN0aW9uKCB1cmwsIGRhdGEsIGNhbGxiYWNrICkge1xuXHRcdHJldHVybiBqUXVlcnkuZ2V0KCB1cmwsIGRhdGEsIGNhbGxiYWNrLCBcImpzb25cIiApO1xuXHR9LFxuXG5cdGdldFNjcmlwdDogZnVuY3Rpb24oIHVybCwgY2FsbGJhY2sgKSB7XG5cdFx0cmV0dXJuIGpRdWVyeS5nZXQoIHVybCwgdW5kZWZpbmVkLCBjYWxsYmFjaywgXCJzY3JpcHRcIiApO1xuXHR9XG59ICk7XG5cbmpRdWVyeS5lYWNoKCBbIFwiZ2V0XCIsIFwicG9zdFwiIF0sIGZ1bmN0aW9uKCBfaSwgbWV0aG9kICkge1xuXHRqUXVlcnlbIG1ldGhvZCBdID0gZnVuY3Rpb24oIHVybCwgZGF0YSwgY2FsbGJhY2ssIHR5cGUgKSB7XG5cblx0XHQvLyBTaGlmdCBhcmd1bWVudHMgaWYgZGF0YSBhcmd1bWVudCB3YXMgb21pdHRlZFxuXHRcdGlmICggaXNGdW5jdGlvbiggZGF0YSApICkge1xuXHRcdFx0dHlwZSA9IHR5cGUgfHwgY2FsbGJhY2s7XG5cdFx0XHRjYWxsYmFjayA9IGRhdGE7XG5cdFx0XHRkYXRhID0gdW5kZWZpbmVkO1xuXHRcdH1cblxuXHRcdC8vIFRoZSB1cmwgY2FuIGJlIGFuIG9wdGlvbnMgb2JqZWN0ICh3aGljaCB0aGVuIG11c3QgaGF2ZSAudXJsKVxuXHRcdHJldHVybiBqUXVlcnkuYWpheCggalF1ZXJ5LmV4dGVuZCgge1xuXHRcdFx0dXJsOiB1cmwsXG5cdFx0XHR0eXBlOiBtZXRob2QsXG5cdFx0XHRkYXRhVHlwZTogdHlwZSxcblx0XHRcdGRhdGE6IGRhdGEsXG5cdFx0XHRzdWNjZXNzOiBjYWxsYmFja1xuXHRcdH0sIGpRdWVyeS5pc1BsYWluT2JqZWN0KCB1cmwgKSAmJiB1cmwgKSApO1xuXHR9O1xufSApO1xuXG5qUXVlcnkuYWpheFByZWZpbHRlciggZnVuY3Rpb24oIHMgKSB7XG5cdHZhciBpO1xuXHRmb3IgKCBpIGluIHMuaGVhZGVycyApIHtcblx0XHRpZiAoIGkudG9Mb3dlckNhc2UoKSA9PT0gXCJjb250ZW50LXR5cGVcIiApIHtcblx0XHRcdHMuY29udGVudFR5cGUgPSBzLmhlYWRlcnNbIGkgXSB8fCBcIlwiO1xuXHRcdH1cblx0fVxufSApO1xuXG5cbmpRdWVyeS5fZXZhbFVybCA9IGZ1bmN0aW9uKCB1cmwsIG9wdGlvbnMsIGRvYyApIHtcblx0cmV0dXJuIGpRdWVyeS5hamF4KCB7XG5cdFx0dXJsOiB1cmwsXG5cblx0XHQvLyBNYWtlIHRoaXMgZXhwbGljaXQsIHNpbmNlIHVzZXIgY2FuIG92ZXJyaWRlIHRoaXMgdGhyb3VnaCBhamF4U2V0dXAgKCMxMTI2NClcblx0XHR0eXBlOiBcIkdFVFwiLFxuXHRcdGRhdGFUeXBlOiBcInNjcmlwdFwiLFxuXHRcdGNhY2hlOiB0cnVlLFxuXHRcdGFzeW5jOiBmYWxzZSxcblx0XHRnbG9iYWw6IGZhbHNlLFxuXG5cdFx0Ly8gT25seSBldmFsdWF0ZSB0aGUgcmVzcG9uc2UgaWYgaXQgaXMgc3VjY2Vzc2Z1bCAoZ2gtNDEyNilcblx0XHQvLyBkYXRhRmlsdGVyIGlzIG5vdCBpbnZva2VkIGZvciBmYWlsdXJlIHJlc3BvbnNlcywgc28gdXNpbmcgaXQgaW5zdGVhZFxuXHRcdC8vIG9mIHRoZSBkZWZhdWx0IGNvbnZlcnRlciBpcyBrbHVkZ3kgYnV0IGl0IHdvcmtzLlxuXHRcdGNvbnZlcnRlcnM6IHtcblx0XHRcdFwidGV4dCBzY3JpcHRcIjogZnVuY3Rpb24oKSB7fVxuXHRcdH0sXG5cdFx0ZGF0YUZpbHRlcjogZnVuY3Rpb24oIHJlc3BvbnNlICkge1xuXHRcdFx0alF1ZXJ5Lmdsb2JhbEV2YWwoIHJlc3BvbnNlLCBvcHRpb25zLCBkb2MgKTtcblx0XHR9XG5cdH0gKTtcbn07XG5cblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHR3cmFwQWxsOiBmdW5jdGlvbiggaHRtbCApIHtcblx0XHR2YXIgd3JhcDtcblxuXHRcdGlmICggdGhpc1sgMCBdICkge1xuXHRcdFx0aWYgKCBpc0Z1bmN0aW9uKCBodG1sICkgKSB7XG5cdFx0XHRcdGh0bWwgPSBodG1sLmNhbGwoIHRoaXNbIDAgXSApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBUaGUgZWxlbWVudHMgdG8gd3JhcCB0aGUgdGFyZ2V0IGFyb3VuZFxuXHRcdFx0d3JhcCA9IGpRdWVyeSggaHRtbCwgdGhpc1sgMCBdLm93bmVyRG9jdW1lbnQgKS5lcSggMCApLmNsb25lKCB0cnVlICk7XG5cblx0XHRcdGlmICggdGhpc1sgMCBdLnBhcmVudE5vZGUgKSB7XG5cdFx0XHRcdHdyYXAuaW5zZXJ0QmVmb3JlKCB0aGlzWyAwIF0gKTtcblx0XHRcdH1cblxuXHRcdFx0d3JhcC5tYXAoIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgZWxlbSA9IHRoaXM7XG5cblx0XHRcdFx0d2hpbGUgKCBlbGVtLmZpcnN0RWxlbWVudENoaWxkICkge1xuXHRcdFx0XHRcdGVsZW0gPSBlbGVtLmZpcnN0RWxlbWVudENoaWxkO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIGVsZW07XG5cdFx0XHR9ICkuYXBwZW5kKCB0aGlzICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0d3JhcElubmVyOiBmdW5jdGlvbiggaHRtbCApIHtcblx0XHRpZiAoIGlzRnVuY3Rpb24oIGh0bWwgKSApIHtcblx0XHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCBpICkge1xuXHRcdFx0XHRqUXVlcnkoIHRoaXMgKS53cmFwSW5uZXIoIGh0bWwuY2FsbCggdGhpcywgaSApICk7XG5cdFx0XHR9ICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgc2VsZiA9IGpRdWVyeSggdGhpcyApLFxuXHRcdFx0XHRjb250ZW50cyA9IHNlbGYuY29udGVudHMoKTtcblxuXHRcdFx0aWYgKCBjb250ZW50cy5sZW5ndGggKSB7XG5cdFx0XHRcdGNvbnRlbnRzLndyYXBBbGwoIGh0bWwgKTtcblxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0c2VsZi5hcHBlbmQoIGh0bWwgKTtcblx0XHRcdH1cblx0XHR9ICk7XG5cdH0sXG5cblx0d3JhcDogZnVuY3Rpb24oIGh0bWwgKSB7XG5cdFx0dmFyIGh0bWxJc0Z1bmN0aW9uID0gaXNGdW5jdGlvbiggaHRtbCApO1xuXG5cdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oIGkgKSB7XG5cdFx0XHRqUXVlcnkoIHRoaXMgKS53cmFwQWxsKCBodG1sSXNGdW5jdGlvbiA/IGh0bWwuY2FsbCggdGhpcywgaSApIDogaHRtbCApO1xuXHRcdH0gKTtcblx0fSxcblxuXHR1bndyYXA6IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHR0aGlzLnBhcmVudCggc2VsZWN0b3IgKS5ub3QoIFwiYm9keVwiICkuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRqUXVlcnkoIHRoaXMgKS5yZXBsYWNlV2l0aCggdGhpcy5jaGlsZE5vZGVzICk7XG5cdFx0fSApO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG59ICk7XG5cblxualF1ZXJ5LmV4cHIucHNldWRvcy5oaWRkZW4gPSBmdW5jdGlvbiggZWxlbSApIHtcblx0cmV0dXJuICFqUXVlcnkuZXhwci5wc2V1ZG9zLnZpc2libGUoIGVsZW0gKTtcbn07XG5qUXVlcnkuZXhwci5wc2V1ZG9zLnZpc2libGUgPSBmdW5jdGlvbiggZWxlbSApIHtcblx0cmV0dXJuICEhKCBlbGVtLm9mZnNldFdpZHRoIHx8IGVsZW0ub2Zmc2V0SGVpZ2h0IHx8IGVsZW0uZ2V0Q2xpZW50UmVjdHMoKS5sZW5ndGggKTtcbn07XG5cblxuXG5cbmpRdWVyeS5hamF4U2V0dGluZ3MueGhyID0gZnVuY3Rpb24oKSB7XG5cdHRyeSB7XG5cdFx0cmV0dXJuIG5ldyB3aW5kb3cuWE1MSHR0cFJlcXVlc3QoKTtcblx0fSBjYXRjaCAoIGUgKSB7fVxufTtcblxudmFyIHhoclN1Y2Nlc3NTdGF0dXMgPSB7XG5cblx0XHQvLyBGaWxlIHByb3RvY29sIGFsd2F5cyB5aWVsZHMgc3RhdHVzIGNvZGUgMCwgYXNzdW1lIDIwMFxuXHRcdDA6IDIwMCxcblxuXHRcdC8vIFN1cHBvcnQ6IElFIDw9OSBvbmx5XG5cdFx0Ly8gIzE0NTA6IHNvbWV0aW1lcyBJRSByZXR1cm5zIDEyMjMgd2hlbiBpdCBzaG91bGQgYmUgMjA0XG5cdFx0MTIyMzogMjA0XG5cdH0sXG5cdHhoclN1cHBvcnRlZCA9IGpRdWVyeS5hamF4U2V0dGluZ3MueGhyKCk7XG5cbnN1cHBvcnQuY29ycyA9ICEheGhyU3VwcG9ydGVkICYmICggXCJ3aXRoQ3JlZGVudGlhbHNcIiBpbiB4aHJTdXBwb3J0ZWQgKTtcbnN1cHBvcnQuYWpheCA9IHhoclN1cHBvcnRlZCA9ICEheGhyU3VwcG9ydGVkO1xuXG5qUXVlcnkuYWpheFRyYW5zcG9ydCggZnVuY3Rpb24oIG9wdGlvbnMgKSB7XG5cdHZhciBjYWxsYmFjaywgZXJyb3JDYWxsYmFjaztcblxuXHQvLyBDcm9zcyBkb21haW4gb25seSBhbGxvd2VkIGlmIHN1cHBvcnRlZCB0aHJvdWdoIFhNTEh0dHBSZXF1ZXN0XG5cdGlmICggc3VwcG9ydC5jb3JzIHx8IHhoclN1cHBvcnRlZCAmJiAhb3B0aW9ucy5jcm9zc0RvbWFpbiApIHtcblx0XHRyZXR1cm4ge1xuXHRcdFx0c2VuZDogZnVuY3Rpb24oIGhlYWRlcnMsIGNvbXBsZXRlICkge1xuXHRcdFx0XHR2YXIgaSxcblx0XHRcdFx0XHR4aHIgPSBvcHRpb25zLnhocigpO1xuXG5cdFx0XHRcdHhoci5vcGVuKFxuXHRcdFx0XHRcdG9wdGlvbnMudHlwZSxcblx0XHRcdFx0XHRvcHRpb25zLnVybCxcblx0XHRcdFx0XHRvcHRpb25zLmFzeW5jLFxuXHRcdFx0XHRcdG9wdGlvbnMudXNlcm5hbWUsXG5cdFx0XHRcdFx0b3B0aW9ucy5wYXNzd29yZFxuXHRcdFx0XHQpO1xuXG5cdFx0XHRcdC8vIEFwcGx5IGN1c3RvbSBmaWVsZHMgaWYgcHJvdmlkZWRcblx0XHRcdFx0aWYgKCBvcHRpb25zLnhockZpZWxkcyApIHtcblx0XHRcdFx0XHRmb3IgKCBpIGluIG9wdGlvbnMueGhyRmllbGRzICkge1xuXHRcdFx0XHRcdFx0eGhyWyBpIF0gPSBvcHRpb25zLnhockZpZWxkc1sgaSBdO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIE92ZXJyaWRlIG1pbWUgdHlwZSBpZiBuZWVkZWRcblx0XHRcdFx0aWYgKCBvcHRpb25zLm1pbWVUeXBlICYmIHhoci5vdmVycmlkZU1pbWVUeXBlICkge1xuXHRcdFx0XHRcdHhoci5vdmVycmlkZU1pbWVUeXBlKCBvcHRpb25zLm1pbWVUeXBlICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBYLVJlcXVlc3RlZC1XaXRoIGhlYWRlclxuXHRcdFx0XHQvLyBGb3IgY3Jvc3MtZG9tYWluIHJlcXVlc3RzLCBzZWVpbmcgYXMgY29uZGl0aW9ucyBmb3IgYSBwcmVmbGlnaHQgYXJlXG5cdFx0XHRcdC8vIGFraW4gdG8gYSBqaWdzYXcgcHV6emxlLCB3ZSBzaW1wbHkgbmV2ZXIgc2V0IGl0IHRvIGJlIHN1cmUuXG5cdFx0XHRcdC8vIChpdCBjYW4gYWx3YXlzIGJlIHNldCBvbiBhIHBlci1yZXF1ZXN0IGJhc2lzIG9yIGV2ZW4gdXNpbmcgYWpheFNldHVwKVxuXHRcdFx0XHQvLyBGb3Igc2FtZS1kb21haW4gcmVxdWVzdHMsIHdvbid0IGNoYW5nZSBoZWFkZXIgaWYgYWxyZWFkeSBwcm92aWRlZC5cblx0XHRcdFx0aWYgKCAhb3B0aW9ucy5jcm9zc0RvbWFpbiAmJiAhaGVhZGVyc1sgXCJYLVJlcXVlc3RlZC1XaXRoXCIgXSApIHtcblx0XHRcdFx0XHRoZWFkZXJzWyBcIlgtUmVxdWVzdGVkLVdpdGhcIiBdID0gXCJYTUxIdHRwUmVxdWVzdFwiO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gU2V0IGhlYWRlcnNcblx0XHRcdFx0Zm9yICggaSBpbiBoZWFkZXJzICkge1xuXHRcdFx0XHRcdHhoci5zZXRSZXF1ZXN0SGVhZGVyKCBpLCBoZWFkZXJzWyBpIF0gKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIENhbGxiYWNrXG5cdFx0XHRcdGNhbGxiYWNrID0gZnVuY3Rpb24oIHR5cGUgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0aWYgKCBjYWxsYmFjayApIHtcblx0XHRcdFx0XHRcdFx0Y2FsbGJhY2sgPSBlcnJvckNhbGxiYWNrID0geGhyLm9ubG9hZCA9XG5cdFx0XHRcdFx0XHRcdFx0eGhyLm9uZXJyb3IgPSB4aHIub25hYm9ydCA9IHhoci5vbnRpbWVvdXQgPVxuXHRcdFx0XHRcdFx0XHRcdFx0eGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IG51bGw7XG5cblx0XHRcdFx0XHRcdFx0aWYgKCB0eXBlID09PSBcImFib3J0XCIgKSB7XG5cdFx0XHRcdFx0XHRcdFx0eGhyLmFib3J0KCk7XG5cdFx0XHRcdFx0XHRcdH0gZWxzZSBpZiAoIHR5cGUgPT09IFwiZXJyb3JcIiApIHtcblxuXHRcdFx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDw9OSBvbmx5XG5cdFx0XHRcdFx0XHRcdFx0Ly8gT24gYSBtYW51YWwgbmF0aXZlIGFib3J0LCBJRTkgdGhyb3dzXG5cdFx0XHRcdFx0XHRcdFx0Ly8gZXJyb3JzIG9uIGFueSBwcm9wZXJ0eSBhY2Nlc3MgdGhhdCBpcyBub3QgcmVhZHlTdGF0ZVxuXHRcdFx0XHRcdFx0XHRcdGlmICggdHlwZW9mIHhoci5zdGF0dXMgIT09IFwibnVtYmVyXCIgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRjb21wbGV0ZSggMCwgXCJlcnJvclwiICk7XG5cdFx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHRcdGNvbXBsZXRlKFxuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8vIEZpbGU6IHByb3RvY29sIGFsd2F5cyB5aWVsZHMgc3RhdHVzIDA7IHNlZSAjODYwNSwgIzE0MjA3XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHhoci5zdGF0dXMsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHhoci5zdGF0dXNUZXh0XG5cdFx0XHRcdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHRjb21wbGV0ZShcblx0XHRcdFx0XHRcdFx0XHRcdHhoclN1Y2Nlc3NTdGF0dXNbIHhoci5zdGF0dXMgXSB8fCB4aHIuc3RhdHVzLFxuXHRcdFx0XHRcdFx0XHRcdFx0eGhyLnN0YXR1c1RleHQsXG5cblx0XHRcdFx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDw9OSBvbmx5XG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBJRTkgaGFzIG5vIFhIUjIgYnV0IHRocm93cyBvbiBiaW5hcnkgKHRyYWMtMTE0MjYpXG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBGb3IgWEhSMiBub24tdGV4dCwgbGV0IHRoZSBjYWxsZXIgaGFuZGxlIGl0IChnaC0yNDk4KVxuXHRcdFx0XHRcdFx0XHRcdFx0KCB4aHIucmVzcG9uc2VUeXBlIHx8IFwidGV4dFwiICkgIT09IFwidGV4dFwiICB8fFxuXHRcdFx0XHRcdFx0XHRcdFx0dHlwZW9mIHhoci5yZXNwb25zZVRleHQgIT09IFwic3RyaW5nXCIgP1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR7IGJpbmFyeTogeGhyLnJlc3BvbnNlIH0gOlxuXHRcdFx0XHRcdFx0XHRcdFx0XHR7IHRleHQ6IHhoci5yZXNwb25zZVRleHQgfSxcblx0XHRcdFx0XHRcdFx0XHRcdHhoci5nZXRBbGxSZXNwb25zZUhlYWRlcnMoKVxuXHRcdFx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9O1xuXHRcdFx0XHR9O1xuXG5cdFx0XHRcdC8vIExpc3RlbiB0byBldmVudHNcblx0XHRcdFx0eGhyLm9ubG9hZCA9IGNhbGxiYWNrKCk7XG5cdFx0XHRcdGVycm9yQ2FsbGJhY2sgPSB4aHIub25lcnJvciA9IHhoci5vbnRpbWVvdXQgPSBjYWxsYmFjayggXCJlcnJvclwiICk7XG5cblx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgOSBvbmx5XG5cdFx0XHRcdC8vIFVzZSBvbnJlYWR5c3RhdGVjaGFuZ2UgdG8gcmVwbGFjZSBvbmFib3J0XG5cdFx0XHRcdC8vIHRvIGhhbmRsZSB1bmNhdWdodCBhYm9ydHNcblx0XHRcdFx0aWYgKCB4aHIub25hYm9ydCAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdHhoci5vbmFib3J0ID0gZXJyb3JDYWxsYmFjaztcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR4aHIub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24oKSB7XG5cblx0XHRcdFx0XHRcdC8vIENoZWNrIHJlYWR5U3RhdGUgYmVmb3JlIHRpbWVvdXQgYXMgaXQgY2hhbmdlc1xuXHRcdFx0XHRcdFx0aWYgKCB4aHIucmVhZHlTdGF0ZSA9PT0gNCApIHtcblxuXHRcdFx0XHRcdFx0XHQvLyBBbGxvdyBvbmVycm9yIHRvIGJlIGNhbGxlZCBmaXJzdCxcblx0XHRcdFx0XHRcdFx0Ly8gYnV0IHRoYXQgd2lsbCBub3QgaGFuZGxlIGEgbmF0aXZlIGFib3J0XG5cdFx0XHRcdFx0XHRcdC8vIEFsc28sIHNhdmUgZXJyb3JDYWxsYmFjayB0byBhIHZhcmlhYmxlXG5cdFx0XHRcdFx0XHRcdC8vIGFzIHhoci5vbmVycm9yIGNhbm5vdCBiZSBhY2Nlc3NlZFxuXHRcdFx0XHRcdFx0XHR3aW5kb3cuc2V0VGltZW91dCggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRcdFx0aWYgKCBjYWxsYmFjayApIHtcblx0XHRcdFx0XHRcdFx0XHRcdGVycm9yQ2FsbGJhY2soKTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH0gKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9O1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gQ3JlYXRlIHRoZSBhYm9ydCBjYWxsYmFja1xuXHRcdFx0XHRjYWxsYmFjayA9IGNhbGxiYWNrKCBcImFib3J0XCIgKTtcblxuXHRcdFx0XHR0cnkge1xuXG5cdFx0XHRcdFx0Ly8gRG8gc2VuZCB0aGUgcmVxdWVzdCAodGhpcyBtYXkgcmFpc2UgYW4gZXhjZXB0aW9uKVxuXHRcdFx0XHRcdHhoci5zZW5kKCBvcHRpb25zLmhhc0NvbnRlbnQgJiYgb3B0aW9ucy5kYXRhIHx8IG51bGwgKTtcblx0XHRcdFx0fSBjYXRjaCAoIGUgKSB7XG5cblx0XHRcdFx0XHQvLyAjMTQ2ODM6IE9ubHkgcmV0aHJvdyBpZiB0aGlzIGhhc24ndCBiZWVuIG5vdGlmaWVkIGFzIGFuIGVycm9yIHlldFxuXHRcdFx0XHRcdGlmICggY2FsbGJhY2sgKSB7XG5cdFx0XHRcdFx0XHR0aHJvdyBlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSxcblxuXHRcdFx0YWJvcnQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAoIGNhbGxiYWNrICkge1xuXHRcdFx0XHRcdGNhbGxiYWNrKCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9O1xuXHR9XG59ICk7XG5cblxuXG5cbi8vIFByZXZlbnQgYXV0by1leGVjdXRpb24gb2Ygc2NyaXB0cyB3aGVuIG5vIGV4cGxpY2l0IGRhdGFUeXBlIHdhcyBwcm92aWRlZCAoU2VlIGdoLTI0MzIpXG5qUXVlcnkuYWpheFByZWZpbHRlciggZnVuY3Rpb24oIHMgKSB7XG5cdGlmICggcy5jcm9zc0RvbWFpbiApIHtcblx0XHRzLmNvbnRlbnRzLnNjcmlwdCA9IGZhbHNlO1xuXHR9XG59ICk7XG5cbi8vIEluc3RhbGwgc2NyaXB0IGRhdGFUeXBlXG5qUXVlcnkuYWpheFNldHVwKCB7XG5cdGFjY2VwdHM6IHtcblx0XHRzY3JpcHQ6IFwidGV4dC9qYXZhc2NyaXB0LCBhcHBsaWNhdGlvbi9qYXZhc2NyaXB0LCBcIiArXG5cdFx0XHRcImFwcGxpY2F0aW9uL2VjbWFzY3JpcHQsIGFwcGxpY2F0aW9uL3gtZWNtYXNjcmlwdFwiXG5cdH0sXG5cdGNvbnRlbnRzOiB7XG5cdFx0c2NyaXB0OiAvXFxiKD86amF2YXxlY21hKXNjcmlwdFxcYi9cblx0fSxcblx0Y29udmVydGVyczoge1xuXHRcdFwidGV4dCBzY3JpcHRcIjogZnVuY3Rpb24oIHRleHQgKSB7XG5cdFx0XHRqUXVlcnkuZ2xvYmFsRXZhbCggdGV4dCApO1xuXHRcdFx0cmV0dXJuIHRleHQ7XG5cdFx0fVxuXHR9XG59ICk7XG5cbi8vIEhhbmRsZSBjYWNoZSdzIHNwZWNpYWwgY2FzZSBhbmQgY3Jvc3NEb21haW5cbmpRdWVyeS5hamF4UHJlZmlsdGVyKCBcInNjcmlwdFwiLCBmdW5jdGlvbiggcyApIHtcblx0aWYgKCBzLmNhY2hlID09PSB1bmRlZmluZWQgKSB7XG5cdFx0cy5jYWNoZSA9IGZhbHNlO1xuXHR9XG5cdGlmICggcy5jcm9zc0RvbWFpbiApIHtcblx0XHRzLnR5cGUgPSBcIkdFVFwiO1xuXHR9XG59ICk7XG5cbi8vIEJpbmQgc2NyaXB0IHRhZyBoYWNrIHRyYW5zcG9ydFxualF1ZXJ5LmFqYXhUcmFuc3BvcnQoIFwic2NyaXB0XCIsIGZ1bmN0aW9uKCBzICkge1xuXG5cdC8vIFRoaXMgdHJhbnNwb3J0IG9ubHkgZGVhbHMgd2l0aCBjcm9zcyBkb21haW4gb3IgZm9yY2VkLWJ5LWF0dHJzIHJlcXVlc3RzXG5cdGlmICggcy5jcm9zc0RvbWFpbiB8fCBzLnNjcmlwdEF0dHJzICkge1xuXHRcdHZhciBzY3JpcHQsIGNhbGxiYWNrO1xuXHRcdHJldHVybiB7XG5cdFx0XHRzZW5kOiBmdW5jdGlvbiggXywgY29tcGxldGUgKSB7XG5cdFx0XHRcdHNjcmlwdCA9IGpRdWVyeSggXCI8c2NyaXB0PlwiIClcblx0XHRcdFx0XHQuYXR0ciggcy5zY3JpcHRBdHRycyB8fCB7fSApXG5cdFx0XHRcdFx0LnByb3AoIHsgY2hhcnNldDogcy5zY3JpcHRDaGFyc2V0LCBzcmM6IHMudXJsIH0gKVxuXHRcdFx0XHRcdC5vbiggXCJsb2FkIGVycm9yXCIsIGNhbGxiYWNrID0gZnVuY3Rpb24oIGV2dCApIHtcblx0XHRcdFx0XHRcdHNjcmlwdC5yZW1vdmUoKTtcblx0XHRcdFx0XHRcdGNhbGxiYWNrID0gbnVsbDtcblx0XHRcdFx0XHRcdGlmICggZXZ0ICkge1xuXHRcdFx0XHRcdFx0XHRjb21wbGV0ZSggZXZ0LnR5cGUgPT09IFwiZXJyb3JcIiA/IDQwNCA6IDIwMCwgZXZ0LnR5cGUgKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9ICk7XG5cblx0XHRcdFx0Ly8gVXNlIG5hdGl2ZSBET00gbWFuaXB1bGF0aW9uIHRvIGF2b2lkIG91ciBkb21NYW5pcCBBSkFYIHRyaWNrZXJ5XG5cdFx0XHRcdGRvY3VtZW50LmhlYWQuYXBwZW5kQ2hpbGQoIHNjcmlwdFsgMCBdICk7XG5cdFx0XHR9LFxuXHRcdFx0YWJvcnQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAoIGNhbGxiYWNrICkge1xuXHRcdFx0XHRcdGNhbGxiYWNrKCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9O1xuXHR9XG59ICk7XG5cblxuXG5cbnZhciBvbGRDYWxsYmFja3MgPSBbXSxcblx0cmpzb25wID0gLyg9KVxcPyg/PSZ8JCl8XFw/XFw/LztcblxuLy8gRGVmYXVsdCBqc29ucCBzZXR0aW5nc1xualF1ZXJ5LmFqYXhTZXR1cCgge1xuXHRqc29ucDogXCJjYWxsYmFja1wiLFxuXHRqc29ucENhbGxiYWNrOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgY2FsbGJhY2sgPSBvbGRDYWxsYmFja3MucG9wKCkgfHwgKCBqUXVlcnkuZXhwYW5kbyArIFwiX1wiICsgKCBub25jZS5ndWlkKysgKSApO1xuXHRcdHRoaXNbIGNhbGxiYWNrIF0gPSB0cnVlO1xuXHRcdHJldHVybiBjYWxsYmFjaztcblx0fVxufSApO1xuXG4vLyBEZXRlY3QsIG5vcm1hbGl6ZSBvcHRpb25zIGFuZCBpbnN0YWxsIGNhbGxiYWNrcyBmb3IganNvbnAgcmVxdWVzdHNcbmpRdWVyeS5hamF4UHJlZmlsdGVyKCBcImpzb24ganNvbnBcIiwgZnVuY3Rpb24oIHMsIG9yaWdpbmFsU2V0dGluZ3MsIGpxWEhSICkge1xuXG5cdHZhciBjYWxsYmFja05hbWUsIG92ZXJ3cml0dGVuLCByZXNwb25zZUNvbnRhaW5lcixcblx0XHRqc29uUHJvcCA9IHMuanNvbnAgIT09IGZhbHNlICYmICggcmpzb25wLnRlc3QoIHMudXJsICkgP1xuXHRcdFx0XCJ1cmxcIiA6XG5cdFx0XHR0eXBlb2Ygcy5kYXRhID09PSBcInN0cmluZ1wiICYmXG5cdFx0XHRcdCggcy5jb250ZW50VHlwZSB8fCBcIlwiIClcblx0XHRcdFx0XHQuaW5kZXhPZiggXCJhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWRcIiApID09PSAwICYmXG5cdFx0XHRcdHJqc29ucC50ZXN0KCBzLmRhdGEgKSAmJiBcImRhdGFcIlxuXHRcdCk7XG5cblx0Ly8gSGFuZGxlIGlmZiB0aGUgZXhwZWN0ZWQgZGF0YSB0eXBlIGlzIFwianNvbnBcIiBvciB3ZSBoYXZlIGEgcGFyYW1ldGVyIHRvIHNldFxuXHRpZiAoIGpzb25Qcm9wIHx8IHMuZGF0YVR5cGVzWyAwIF0gPT09IFwianNvbnBcIiApIHtcblxuXHRcdC8vIEdldCBjYWxsYmFjayBuYW1lLCByZW1lbWJlcmluZyBwcmVleGlzdGluZyB2YWx1ZSBhc3NvY2lhdGVkIHdpdGggaXRcblx0XHRjYWxsYmFja05hbWUgPSBzLmpzb25wQ2FsbGJhY2sgPSBpc0Z1bmN0aW9uKCBzLmpzb25wQ2FsbGJhY2sgKSA/XG5cdFx0XHRzLmpzb25wQ2FsbGJhY2soKSA6XG5cdFx0XHRzLmpzb25wQ2FsbGJhY2s7XG5cblx0XHQvLyBJbnNlcnQgY2FsbGJhY2sgaW50byB1cmwgb3IgZm9ybSBkYXRhXG5cdFx0aWYgKCBqc29uUHJvcCApIHtcblx0XHRcdHNbIGpzb25Qcm9wIF0gPSBzWyBqc29uUHJvcCBdLnJlcGxhY2UoIHJqc29ucCwgXCIkMVwiICsgY2FsbGJhY2tOYW1lICk7XG5cdFx0fSBlbHNlIGlmICggcy5qc29ucCAhPT0gZmFsc2UgKSB7XG5cdFx0XHRzLnVybCArPSAoIHJxdWVyeS50ZXN0KCBzLnVybCApID8gXCImXCIgOiBcIj9cIiApICsgcy5qc29ucCArIFwiPVwiICsgY2FsbGJhY2tOYW1lO1xuXHRcdH1cblxuXHRcdC8vIFVzZSBkYXRhIGNvbnZlcnRlciB0byByZXRyaWV2ZSBqc29uIGFmdGVyIHNjcmlwdCBleGVjdXRpb25cblx0XHRzLmNvbnZlcnRlcnNbIFwic2NyaXB0IGpzb25cIiBdID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRpZiAoICFyZXNwb25zZUNvbnRhaW5lciApIHtcblx0XHRcdFx0alF1ZXJ5LmVycm9yKCBjYWxsYmFja05hbWUgKyBcIiB3YXMgbm90IGNhbGxlZFwiICk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcmVzcG9uc2VDb250YWluZXJbIDAgXTtcblx0XHR9O1xuXG5cdFx0Ly8gRm9yY2UganNvbiBkYXRhVHlwZVxuXHRcdHMuZGF0YVR5cGVzWyAwIF0gPSBcImpzb25cIjtcblxuXHRcdC8vIEluc3RhbGwgY2FsbGJhY2tcblx0XHRvdmVyd3JpdHRlbiA9IHdpbmRvd1sgY2FsbGJhY2tOYW1lIF07XG5cdFx0d2luZG93WyBjYWxsYmFja05hbWUgXSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0cmVzcG9uc2VDb250YWluZXIgPSBhcmd1bWVudHM7XG5cdFx0fTtcblxuXHRcdC8vIENsZWFuLXVwIGZ1bmN0aW9uIChmaXJlcyBhZnRlciBjb252ZXJ0ZXJzKVxuXHRcdGpxWEhSLmFsd2F5cyggZnVuY3Rpb24oKSB7XG5cblx0XHRcdC8vIElmIHByZXZpb3VzIHZhbHVlIGRpZG4ndCBleGlzdCAtIHJlbW92ZSBpdFxuXHRcdFx0aWYgKCBvdmVyd3JpdHRlbiA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRqUXVlcnkoIHdpbmRvdyApLnJlbW92ZVByb3AoIGNhbGxiYWNrTmFtZSApO1xuXG5cdFx0XHQvLyBPdGhlcndpc2UgcmVzdG9yZSBwcmVleGlzdGluZyB2YWx1ZVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0d2luZG93WyBjYWxsYmFja05hbWUgXSA9IG92ZXJ3cml0dGVuO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTYXZlIGJhY2sgYXMgZnJlZVxuXHRcdFx0aWYgKCBzWyBjYWxsYmFja05hbWUgXSApIHtcblxuXHRcdFx0XHQvLyBNYWtlIHN1cmUgdGhhdCByZS11c2luZyB0aGUgb3B0aW9ucyBkb2Vzbid0IHNjcmV3IHRoaW5ncyBhcm91bmRcblx0XHRcdFx0cy5qc29ucENhbGxiYWNrID0gb3JpZ2luYWxTZXR0aW5ncy5qc29ucENhbGxiYWNrO1xuXG5cdFx0XHRcdC8vIFNhdmUgdGhlIGNhbGxiYWNrIG5hbWUgZm9yIGZ1dHVyZSB1c2Vcblx0XHRcdFx0b2xkQ2FsbGJhY2tzLnB1c2goIGNhbGxiYWNrTmFtZSApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBDYWxsIGlmIGl0IHdhcyBhIGZ1bmN0aW9uIGFuZCB3ZSBoYXZlIGEgcmVzcG9uc2Vcblx0XHRcdGlmICggcmVzcG9uc2VDb250YWluZXIgJiYgaXNGdW5jdGlvbiggb3ZlcndyaXR0ZW4gKSApIHtcblx0XHRcdFx0b3ZlcndyaXR0ZW4oIHJlc3BvbnNlQ29udGFpbmVyWyAwIF0gKTtcblx0XHRcdH1cblxuXHRcdFx0cmVzcG9uc2VDb250YWluZXIgPSBvdmVyd3JpdHRlbiA9IHVuZGVmaW5lZDtcblx0XHR9ICk7XG5cblx0XHQvLyBEZWxlZ2F0ZSB0byBzY3JpcHRcblx0XHRyZXR1cm4gXCJzY3JpcHRcIjtcblx0fVxufSApO1xuXG5cblxuXG4vLyBTdXBwb3J0OiBTYWZhcmkgOCBvbmx5XG4vLyBJbiBTYWZhcmkgOCBkb2N1bWVudHMgY3JlYXRlZCB2aWEgZG9jdW1lbnQuaW1wbGVtZW50YXRpb24uY3JlYXRlSFRNTERvY3VtZW50XG4vLyBjb2xsYXBzZSBzaWJsaW5nIGZvcm1zOiB0aGUgc2Vjb25kIG9uZSBiZWNvbWVzIGEgY2hpbGQgb2YgdGhlIGZpcnN0IG9uZS5cbi8vIEJlY2F1c2Ugb2YgdGhhdCwgdGhpcyBzZWN1cml0eSBtZWFzdXJlIGhhcyB0byBiZSBkaXNhYmxlZCBpbiBTYWZhcmkgOC5cbi8vIGh0dHBzOi8vYnVncy53ZWJraXQub3JnL3Nob3dfYnVnLmNnaT9pZD0xMzczMzdcbnN1cHBvcnQuY3JlYXRlSFRNTERvY3VtZW50ID0gKCBmdW5jdGlvbigpIHtcblx0dmFyIGJvZHkgPSBkb2N1bWVudC5pbXBsZW1lbnRhdGlvbi5jcmVhdGVIVE1MRG9jdW1lbnQoIFwiXCIgKS5ib2R5O1xuXHRib2R5LmlubmVySFRNTCA9IFwiPGZvcm0+PC9mb3JtPjxmb3JtPjwvZm9ybT5cIjtcblx0cmV0dXJuIGJvZHkuY2hpbGROb2Rlcy5sZW5ndGggPT09IDI7XG59ICkoKTtcblxuXG4vLyBBcmd1bWVudCBcImRhdGFcIiBzaG91bGQgYmUgc3RyaW5nIG9mIGh0bWxcbi8vIGNvbnRleHQgKG9wdGlvbmFsKTogSWYgc3BlY2lmaWVkLCB0aGUgZnJhZ21lbnQgd2lsbCBiZSBjcmVhdGVkIGluIHRoaXMgY29udGV4dCxcbi8vIGRlZmF1bHRzIHRvIGRvY3VtZW50XG4vLyBrZWVwU2NyaXB0cyAob3B0aW9uYWwpOiBJZiB0cnVlLCB3aWxsIGluY2x1ZGUgc2NyaXB0cyBwYXNzZWQgaW4gdGhlIGh0bWwgc3RyaW5nXG5qUXVlcnkucGFyc2VIVE1MID0gZnVuY3Rpb24oIGRhdGEsIGNvbnRleHQsIGtlZXBTY3JpcHRzICkge1xuXHRpZiAoIHR5cGVvZiBkYXRhICE9PSBcInN0cmluZ1wiICkge1xuXHRcdHJldHVybiBbXTtcblx0fVxuXHRpZiAoIHR5cGVvZiBjb250ZXh0ID09PSBcImJvb2xlYW5cIiApIHtcblx0XHRrZWVwU2NyaXB0cyA9IGNvbnRleHQ7XG5cdFx0Y29udGV4dCA9IGZhbHNlO1xuXHR9XG5cblx0dmFyIGJhc2UsIHBhcnNlZCwgc2NyaXB0cztcblxuXHRpZiAoICFjb250ZXh0ICkge1xuXG5cdFx0Ly8gU3RvcCBzY3JpcHRzIG9yIGlubGluZSBldmVudCBoYW5kbGVycyBmcm9tIGJlaW5nIGV4ZWN1dGVkIGltbWVkaWF0ZWx5XG5cdFx0Ly8gYnkgdXNpbmcgZG9jdW1lbnQuaW1wbGVtZW50YXRpb25cblx0XHRpZiAoIHN1cHBvcnQuY3JlYXRlSFRNTERvY3VtZW50ICkge1xuXHRcdFx0Y29udGV4dCA9IGRvY3VtZW50LmltcGxlbWVudGF0aW9uLmNyZWF0ZUhUTUxEb2N1bWVudCggXCJcIiApO1xuXG5cdFx0XHQvLyBTZXQgdGhlIGJhc2UgaHJlZiBmb3IgdGhlIGNyZWF0ZWQgZG9jdW1lbnRcblx0XHRcdC8vIHNvIGFueSBwYXJzZWQgZWxlbWVudHMgd2l0aCBVUkxzXG5cdFx0XHQvLyBhcmUgYmFzZWQgb24gdGhlIGRvY3VtZW50J3MgVVJMIChnaC0yOTY1KVxuXHRcdFx0YmFzZSA9IGNvbnRleHQuY3JlYXRlRWxlbWVudCggXCJiYXNlXCIgKTtcblx0XHRcdGJhc2UuaHJlZiA9IGRvY3VtZW50LmxvY2F0aW9uLmhyZWY7XG5cdFx0XHRjb250ZXh0LmhlYWQuYXBwZW5kQ2hpbGQoIGJhc2UgKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Y29udGV4dCA9IGRvY3VtZW50O1xuXHRcdH1cblx0fVxuXG5cdHBhcnNlZCA9IHJzaW5nbGVUYWcuZXhlYyggZGF0YSApO1xuXHRzY3JpcHRzID0gIWtlZXBTY3JpcHRzICYmIFtdO1xuXG5cdC8vIFNpbmdsZSB0YWdcblx0aWYgKCBwYXJzZWQgKSB7XG5cdFx0cmV0dXJuIFsgY29udGV4dC5jcmVhdGVFbGVtZW50KCBwYXJzZWRbIDEgXSApIF07XG5cdH1cblxuXHRwYXJzZWQgPSBidWlsZEZyYWdtZW50KCBbIGRhdGEgXSwgY29udGV4dCwgc2NyaXB0cyApO1xuXG5cdGlmICggc2NyaXB0cyAmJiBzY3JpcHRzLmxlbmd0aCApIHtcblx0XHRqUXVlcnkoIHNjcmlwdHMgKS5yZW1vdmUoKTtcblx0fVxuXG5cdHJldHVybiBqUXVlcnkubWVyZ2UoIFtdLCBwYXJzZWQuY2hpbGROb2RlcyApO1xufTtcblxuXG4vKipcbiAqIExvYWQgYSB1cmwgaW50byBhIHBhZ2VcbiAqL1xualF1ZXJ5LmZuLmxvYWQgPSBmdW5jdGlvbiggdXJsLCBwYXJhbXMsIGNhbGxiYWNrICkge1xuXHR2YXIgc2VsZWN0b3IsIHR5cGUsIHJlc3BvbnNlLFxuXHRcdHNlbGYgPSB0aGlzLFxuXHRcdG9mZiA9IHVybC5pbmRleE9mKCBcIiBcIiApO1xuXG5cdGlmICggb2ZmID4gLTEgKSB7XG5cdFx0c2VsZWN0b3IgPSBzdHJpcEFuZENvbGxhcHNlKCB1cmwuc2xpY2UoIG9mZiApICk7XG5cdFx0dXJsID0gdXJsLnNsaWNlKCAwLCBvZmYgKTtcblx0fVxuXG5cdC8vIElmIGl0J3MgYSBmdW5jdGlvblxuXHRpZiAoIGlzRnVuY3Rpb24oIHBhcmFtcyApICkge1xuXG5cdFx0Ly8gV2UgYXNzdW1lIHRoYXQgaXQncyB0aGUgY2FsbGJhY2tcblx0XHRjYWxsYmFjayA9IHBhcmFtcztcblx0XHRwYXJhbXMgPSB1bmRlZmluZWQ7XG5cblx0Ly8gT3RoZXJ3aXNlLCBidWlsZCBhIHBhcmFtIHN0cmluZ1xuXHR9IGVsc2UgaWYgKCBwYXJhbXMgJiYgdHlwZW9mIHBhcmFtcyA9PT0gXCJvYmplY3RcIiApIHtcblx0XHR0eXBlID0gXCJQT1NUXCI7XG5cdH1cblxuXHQvLyBJZiB3ZSBoYXZlIGVsZW1lbnRzIHRvIG1vZGlmeSwgbWFrZSB0aGUgcmVxdWVzdFxuXHRpZiAoIHNlbGYubGVuZ3RoID4gMCApIHtcblx0XHRqUXVlcnkuYWpheCgge1xuXHRcdFx0dXJsOiB1cmwsXG5cblx0XHRcdC8vIElmIFwidHlwZVwiIHZhcmlhYmxlIGlzIHVuZGVmaW5lZCwgdGhlbiBcIkdFVFwiIG1ldGhvZCB3aWxsIGJlIHVzZWQuXG5cdFx0XHQvLyBNYWtlIHZhbHVlIG9mIHRoaXMgZmllbGQgZXhwbGljaXQgc2luY2Vcblx0XHRcdC8vIHVzZXIgY2FuIG92ZXJyaWRlIGl0IHRocm91Z2ggYWpheFNldHVwIG1ldGhvZFxuXHRcdFx0dHlwZTogdHlwZSB8fCBcIkdFVFwiLFxuXHRcdFx0ZGF0YVR5cGU6IFwiaHRtbFwiLFxuXHRcdFx0ZGF0YTogcGFyYW1zXG5cdFx0fSApLmRvbmUoIGZ1bmN0aW9uKCByZXNwb25zZVRleHQgKSB7XG5cblx0XHRcdC8vIFNhdmUgcmVzcG9uc2UgZm9yIHVzZSBpbiBjb21wbGV0ZSBjYWxsYmFja1xuXHRcdFx0cmVzcG9uc2UgPSBhcmd1bWVudHM7XG5cblx0XHRcdHNlbGYuaHRtbCggc2VsZWN0b3IgP1xuXG5cdFx0XHRcdC8vIElmIGEgc2VsZWN0b3Igd2FzIHNwZWNpZmllZCwgbG9jYXRlIHRoZSByaWdodCBlbGVtZW50cyBpbiBhIGR1bW15IGRpdlxuXHRcdFx0XHQvLyBFeGNsdWRlIHNjcmlwdHMgdG8gYXZvaWQgSUUgJ1Blcm1pc3Npb24gRGVuaWVkJyBlcnJvcnNcblx0XHRcdFx0alF1ZXJ5KCBcIjxkaXY+XCIgKS5hcHBlbmQoIGpRdWVyeS5wYXJzZUhUTUwoIHJlc3BvbnNlVGV4dCApICkuZmluZCggc2VsZWN0b3IgKSA6XG5cblx0XHRcdFx0Ly8gT3RoZXJ3aXNlIHVzZSB0aGUgZnVsbCByZXN1bHRcblx0XHRcdFx0cmVzcG9uc2VUZXh0ICk7XG5cblx0XHQvLyBJZiB0aGUgcmVxdWVzdCBzdWNjZWVkcywgdGhpcyBmdW5jdGlvbiBnZXRzIFwiZGF0YVwiLCBcInN0YXR1c1wiLCBcImpxWEhSXCJcblx0XHQvLyBidXQgdGhleSBhcmUgaWdub3JlZCBiZWNhdXNlIHJlc3BvbnNlIHdhcyBzZXQgYWJvdmUuXG5cdFx0Ly8gSWYgaXQgZmFpbHMsIHRoaXMgZnVuY3Rpb24gZ2V0cyBcImpxWEhSXCIsIFwic3RhdHVzXCIsIFwiZXJyb3JcIlxuXHRcdH0gKS5hbHdheXMoIGNhbGxiYWNrICYmIGZ1bmN0aW9uKCBqcVhIUiwgc3RhdHVzICkge1xuXHRcdFx0c2VsZi5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0Y2FsbGJhY2suYXBwbHkoIHRoaXMsIHJlc3BvbnNlIHx8IFsganFYSFIucmVzcG9uc2VUZXh0LCBzdGF0dXMsIGpxWEhSIF0gKTtcblx0XHRcdH0gKTtcblx0XHR9ICk7XG5cdH1cblxuXHRyZXR1cm4gdGhpcztcbn07XG5cblxuXG5cbmpRdWVyeS5leHByLnBzZXVkb3MuYW5pbWF0ZWQgPSBmdW5jdGlvbiggZWxlbSApIHtcblx0cmV0dXJuIGpRdWVyeS5ncmVwKCBqUXVlcnkudGltZXJzLCBmdW5jdGlvbiggZm4gKSB7XG5cdFx0cmV0dXJuIGVsZW0gPT09IGZuLmVsZW07XG5cdH0gKS5sZW5ndGg7XG59O1xuXG5cblxuXG5qUXVlcnkub2Zmc2V0ID0ge1xuXHRzZXRPZmZzZXQ6IGZ1bmN0aW9uKCBlbGVtLCBvcHRpb25zLCBpICkge1xuXHRcdHZhciBjdXJQb3NpdGlvbiwgY3VyTGVmdCwgY3VyQ1NTVG9wLCBjdXJUb3AsIGN1ck9mZnNldCwgY3VyQ1NTTGVmdCwgY2FsY3VsYXRlUG9zaXRpb24sXG5cdFx0XHRwb3NpdGlvbiA9IGpRdWVyeS5jc3MoIGVsZW0sIFwicG9zaXRpb25cIiApLFxuXHRcdFx0Y3VyRWxlbSA9IGpRdWVyeSggZWxlbSApLFxuXHRcdFx0cHJvcHMgPSB7fTtcblxuXHRcdC8vIFNldCBwb3NpdGlvbiBmaXJzdCwgaW4tY2FzZSB0b3AvbGVmdCBhcmUgc2V0IGV2ZW4gb24gc3RhdGljIGVsZW1cblx0XHRpZiAoIHBvc2l0aW9uID09PSBcInN0YXRpY1wiICkge1xuXHRcdFx0ZWxlbS5zdHlsZS5wb3NpdGlvbiA9IFwicmVsYXRpdmVcIjtcblx0XHR9XG5cblx0XHRjdXJPZmZzZXQgPSBjdXJFbGVtLm9mZnNldCgpO1xuXHRcdGN1ckNTU1RvcCA9IGpRdWVyeS5jc3MoIGVsZW0sIFwidG9wXCIgKTtcblx0XHRjdXJDU1NMZWZ0ID0galF1ZXJ5LmNzcyggZWxlbSwgXCJsZWZ0XCIgKTtcblx0XHRjYWxjdWxhdGVQb3NpdGlvbiA9ICggcG9zaXRpb24gPT09IFwiYWJzb2x1dGVcIiB8fCBwb3NpdGlvbiA9PT0gXCJmaXhlZFwiICkgJiZcblx0XHRcdCggY3VyQ1NTVG9wICsgY3VyQ1NTTGVmdCApLmluZGV4T2YoIFwiYXV0b1wiICkgPiAtMTtcblxuXHRcdC8vIE5lZWQgdG8gYmUgYWJsZSB0byBjYWxjdWxhdGUgcG9zaXRpb24gaWYgZWl0aGVyXG5cdFx0Ly8gdG9wIG9yIGxlZnQgaXMgYXV0byBhbmQgcG9zaXRpb24gaXMgZWl0aGVyIGFic29sdXRlIG9yIGZpeGVkXG5cdFx0aWYgKCBjYWxjdWxhdGVQb3NpdGlvbiApIHtcblx0XHRcdGN1clBvc2l0aW9uID0gY3VyRWxlbS5wb3NpdGlvbigpO1xuXHRcdFx0Y3VyVG9wID0gY3VyUG9zaXRpb24udG9wO1xuXHRcdFx0Y3VyTGVmdCA9IGN1clBvc2l0aW9uLmxlZnQ7XG5cblx0XHR9IGVsc2Uge1xuXHRcdFx0Y3VyVG9wID0gcGFyc2VGbG9hdCggY3VyQ1NTVG9wICkgfHwgMDtcblx0XHRcdGN1ckxlZnQgPSBwYXJzZUZsb2F0KCBjdXJDU1NMZWZ0ICkgfHwgMDtcblx0XHR9XG5cblx0XHRpZiAoIGlzRnVuY3Rpb24oIG9wdGlvbnMgKSApIHtcblxuXHRcdFx0Ly8gVXNlIGpRdWVyeS5leHRlbmQgaGVyZSB0byBhbGxvdyBtb2RpZmljYXRpb24gb2YgY29vcmRpbmF0ZXMgYXJndW1lbnQgKGdoLTE4NDgpXG5cdFx0XHRvcHRpb25zID0gb3B0aW9ucy5jYWxsKCBlbGVtLCBpLCBqUXVlcnkuZXh0ZW5kKCB7fSwgY3VyT2Zmc2V0ICkgKTtcblx0XHR9XG5cblx0XHRpZiAoIG9wdGlvbnMudG9wICE9IG51bGwgKSB7XG5cdFx0XHRwcm9wcy50b3AgPSAoIG9wdGlvbnMudG9wIC0gY3VyT2Zmc2V0LnRvcCApICsgY3VyVG9wO1xuXHRcdH1cblx0XHRpZiAoIG9wdGlvbnMubGVmdCAhPSBudWxsICkge1xuXHRcdFx0cHJvcHMubGVmdCA9ICggb3B0aW9ucy5sZWZ0IC0gY3VyT2Zmc2V0LmxlZnQgKSArIGN1ckxlZnQ7XG5cdFx0fVxuXG5cdFx0aWYgKCBcInVzaW5nXCIgaW4gb3B0aW9ucyApIHtcblx0XHRcdG9wdGlvbnMudXNpbmcuY2FsbCggZWxlbSwgcHJvcHMgKTtcblxuXHRcdH0gZWxzZSB7XG5cdFx0XHRjdXJFbGVtLmNzcyggcHJvcHMgKTtcblx0XHR9XG5cdH1cbn07XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblxuXHQvLyBvZmZzZXQoKSByZWxhdGVzIGFuIGVsZW1lbnQncyBib3JkZXIgYm94IHRvIHRoZSBkb2N1bWVudCBvcmlnaW5cblx0b2Zmc2V0OiBmdW5jdGlvbiggb3B0aW9ucyApIHtcblxuXHRcdC8vIFByZXNlcnZlIGNoYWluaW5nIGZvciBzZXR0ZXJcblx0XHRpZiAoIGFyZ3VtZW50cy5sZW5ndGggKSB7XG5cdFx0XHRyZXR1cm4gb3B0aW9ucyA9PT0gdW5kZWZpbmVkID9cblx0XHRcdFx0dGhpcyA6XG5cdFx0XHRcdHRoaXMuZWFjaCggZnVuY3Rpb24oIGkgKSB7XG5cdFx0XHRcdFx0alF1ZXJ5Lm9mZnNldC5zZXRPZmZzZXQoIHRoaXMsIG9wdGlvbnMsIGkgKTtcblx0XHRcdFx0fSApO1xuXHRcdH1cblxuXHRcdHZhciByZWN0LCB3aW4sXG5cdFx0XHRlbGVtID0gdGhpc1sgMCBdO1xuXG5cdFx0aWYgKCAhZWxlbSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBSZXR1cm4gemVyb3MgZm9yIGRpc2Nvbm5lY3RlZCBhbmQgaGlkZGVuIChkaXNwbGF5OiBub25lKSBlbGVtZW50cyAoZ2gtMjMxMClcblx0XHQvLyBTdXBwb3J0OiBJRSA8PTExIG9ubHlcblx0XHQvLyBSdW5uaW5nIGdldEJvdW5kaW5nQ2xpZW50UmVjdCBvbiBhXG5cdFx0Ly8gZGlzY29ubmVjdGVkIG5vZGUgaW4gSUUgdGhyb3dzIGFuIGVycm9yXG5cdFx0aWYgKCAhZWxlbS5nZXRDbGllbnRSZWN0cygpLmxlbmd0aCApIHtcblx0XHRcdHJldHVybiB7IHRvcDogMCwgbGVmdDogMCB9O1xuXHRcdH1cblxuXHRcdC8vIEdldCBkb2N1bWVudC1yZWxhdGl2ZSBwb3NpdGlvbiBieSBhZGRpbmcgdmlld3BvcnQgc2Nyb2xsIHRvIHZpZXdwb3J0LXJlbGF0aXZlIGdCQ1Jcblx0XHRyZWN0ID0gZWxlbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblx0XHR3aW4gPSBlbGVtLm93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXc7XG5cdFx0cmV0dXJuIHtcblx0XHRcdHRvcDogcmVjdC50b3AgKyB3aW4ucGFnZVlPZmZzZXQsXG5cdFx0XHRsZWZ0OiByZWN0LmxlZnQgKyB3aW4ucGFnZVhPZmZzZXRcblx0XHR9O1xuXHR9LFxuXG5cdC8vIHBvc2l0aW9uKCkgcmVsYXRlcyBhbiBlbGVtZW50J3MgbWFyZ2luIGJveCB0byBpdHMgb2Zmc2V0IHBhcmVudCdzIHBhZGRpbmcgYm94XG5cdC8vIFRoaXMgY29ycmVzcG9uZHMgdG8gdGhlIGJlaGF2aW9yIG9mIENTUyBhYnNvbHV0ZSBwb3NpdGlvbmluZ1xuXHRwb3NpdGlvbjogZnVuY3Rpb24oKSB7XG5cdFx0aWYgKCAhdGhpc1sgMCBdICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdHZhciBvZmZzZXRQYXJlbnQsIG9mZnNldCwgZG9jLFxuXHRcdFx0ZWxlbSA9IHRoaXNbIDAgXSxcblx0XHRcdHBhcmVudE9mZnNldCA9IHsgdG9wOiAwLCBsZWZ0OiAwIH07XG5cblx0XHQvLyBwb3NpdGlvbjpmaXhlZCBlbGVtZW50cyBhcmUgb2Zmc2V0IGZyb20gdGhlIHZpZXdwb3J0LCB3aGljaCBpdHNlbGYgYWx3YXlzIGhhcyB6ZXJvIG9mZnNldFxuXHRcdGlmICggalF1ZXJ5LmNzcyggZWxlbSwgXCJwb3NpdGlvblwiICkgPT09IFwiZml4ZWRcIiApIHtcblxuXHRcdFx0Ly8gQXNzdW1lIHBvc2l0aW9uOmZpeGVkIGltcGxpZXMgYXZhaWxhYmlsaXR5IG9mIGdldEJvdW5kaW5nQ2xpZW50UmVjdFxuXHRcdFx0b2Zmc2V0ID0gZWxlbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblxuXHRcdH0gZWxzZSB7XG5cdFx0XHRvZmZzZXQgPSB0aGlzLm9mZnNldCgpO1xuXG5cdFx0XHQvLyBBY2NvdW50IGZvciB0aGUgKnJlYWwqIG9mZnNldCBwYXJlbnQsIHdoaWNoIGNhbiBiZSB0aGUgZG9jdW1lbnQgb3IgaXRzIHJvb3QgZWxlbWVudFxuXHRcdFx0Ly8gd2hlbiBhIHN0YXRpY2FsbHkgcG9zaXRpb25lZCBlbGVtZW50IGlzIGlkZW50aWZpZWRcblx0XHRcdGRvYyA9IGVsZW0ub3duZXJEb2N1bWVudDtcblx0XHRcdG9mZnNldFBhcmVudCA9IGVsZW0ub2Zmc2V0UGFyZW50IHx8IGRvYy5kb2N1bWVudEVsZW1lbnQ7XG5cdFx0XHR3aGlsZSAoIG9mZnNldFBhcmVudCAmJlxuXHRcdFx0XHQoIG9mZnNldFBhcmVudCA9PT0gZG9jLmJvZHkgfHwgb2Zmc2V0UGFyZW50ID09PSBkb2MuZG9jdW1lbnRFbGVtZW50ICkgJiZcblx0XHRcdFx0alF1ZXJ5LmNzcyggb2Zmc2V0UGFyZW50LCBcInBvc2l0aW9uXCIgKSA9PT0gXCJzdGF0aWNcIiApIHtcblxuXHRcdFx0XHRvZmZzZXRQYXJlbnQgPSBvZmZzZXRQYXJlbnQucGFyZW50Tm9kZTtcblx0XHRcdH1cblx0XHRcdGlmICggb2Zmc2V0UGFyZW50ICYmIG9mZnNldFBhcmVudCAhPT0gZWxlbSAmJiBvZmZzZXRQYXJlbnQubm9kZVR5cGUgPT09IDEgKSB7XG5cblx0XHRcdFx0Ly8gSW5jb3Jwb3JhdGUgYm9yZGVycyBpbnRvIGl0cyBvZmZzZXQsIHNpbmNlIHRoZXkgYXJlIG91dHNpZGUgaXRzIGNvbnRlbnQgb3JpZ2luXG5cdFx0XHRcdHBhcmVudE9mZnNldCA9IGpRdWVyeSggb2Zmc2V0UGFyZW50ICkub2Zmc2V0KCk7XG5cdFx0XHRcdHBhcmVudE9mZnNldC50b3AgKz0galF1ZXJ5LmNzcyggb2Zmc2V0UGFyZW50LCBcImJvcmRlclRvcFdpZHRoXCIsIHRydWUgKTtcblx0XHRcdFx0cGFyZW50T2Zmc2V0LmxlZnQgKz0galF1ZXJ5LmNzcyggb2Zmc2V0UGFyZW50LCBcImJvcmRlckxlZnRXaWR0aFwiLCB0cnVlICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gU3VidHJhY3QgcGFyZW50IG9mZnNldHMgYW5kIGVsZW1lbnQgbWFyZ2luc1xuXHRcdHJldHVybiB7XG5cdFx0XHR0b3A6IG9mZnNldC50b3AgLSBwYXJlbnRPZmZzZXQudG9wIC0galF1ZXJ5LmNzcyggZWxlbSwgXCJtYXJnaW5Ub3BcIiwgdHJ1ZSApLFxuXHRcdFx0bGVmdDogb2Zmc2V0LmxlZnQgLSBwYXJlbnRPZmZzZXQubGVmdCAtIGpRdWVyeS5jc3MoIGVsZW0sIFwibWFyZ2luTGVmdFwiLCB0cnVlIClcblx0XHR9O1xuXHR9LFxuXG5cdC8vIFRoaXMgbWV0aG9kIHdpbGwgcmV0dXJuIGRvY3VtZW50RWxlbWVudCBpbiB0aGUgZm9sbG93aW5nIGNhc2VzOlxuXHQvLyAxKSBGb3IgdGhlIGVsZW1lbnQgaW5zaWRlIHRoZSBpZnJhbWUgd2l0aG91dCBvZmZzZXRQYXJlbnQsIHRoaXMgbWV0aG9kIHdpbGwgcmV0dXJuXG5cdC8vICAgIGRvY3VtZW50RWxlbWVudCBvZiB0aGUgcGFyZW50IHdpbmRvd1xuXHQvLyAyKSBGb3IgdGhlIGhpZGRlbiBvciBkZXRhY2hlZCBlbGVtZW50XG5cdC8vIDMpIEZvciBib2R5IG9yIGh0bWwgZWxlbWVudCwgaS5lLiBpbiBjYXNlIG9mIHRoZSBodG1sIG5vZGUgLSBpdCB3aWxsIHJldHVybiBpdHNlbGZcblx0Ly9cblx0Ly8gYnV0IHRob3NlIGV4Y2VwdGlvbnMgd2VyZSBuZXZlciBwcmVzZW50ZWQgYXMgYSByZWFsIGxpZmUgdXNlLWNhc2VzXG5cdC8vIGFuZCBtaWdodCBiZSBjb25zaWRlcmVkIGFzIG1vcmUgcHJlZmVyYWJsZSByZXN1bHRzLlxuXHQvL1xuXHQvLyBUaGlzIGxvZ2ljLCBob3dldmVyLCBpcyBub3QgZ3VhcmFudGVlZCBhbmQgY2FuIGNoYW5nZSBhdCBhbnkgcG9pbnQgaW4gdGhlIGZ1dHVyZVxuXHRvZmZzZXRQYXJlbnQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLm1hcCggZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgb2Zmc2V0UGFyZW50ID0gdGhpcy5vZmZzZXRQYXJlbnQ7XG5cblx0XHRcdHdoaWxlICggb2Zmc2V0UGFyZW50ICYmIGpRdWVyeS5jc3MoIG9mZnNldFBhcmVudCwgXCJwb3NpdGlvblwiICkgPT09IFwic3RhdGljXCIgKSB7XG5cdFx0XHRcdG9mZnNldFBhcmVudCA9IG9mZnNldFBhcmVudC5vZmZzZXRQYXJlbnQ7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBvZmZzZXRQYXJlbnQgfHwgZG9jdW1lbnRFbGVtZW50O1xuXHRcdH0gKTtcblx0fVxufSApO1xuXG4vLyBDcmVhdGUgc2Nyb2xsTGVmdCBhbmQgc2Nyb2xsVG9wIG1ldGhvZHNcbmpRdWVyeS5lYWNoKCB7IHNjcm9sbExlZnQ6IFwicGFnZVhPZmZzZXRcIiwgc2Nyb2xsVG9wOiBcInBhZ2VZT2Zmc2V0XCIgfSwgZnVuY3Rpb24oIG1ldGhvZCwgcHJvcCApIHtcblx0dmFyIHRvcCA9IFwicGFnZVlPZmZzZXRcIiA9PT0gcHJvcDtcblxuXHRqUXVlcnkuZm5bIG1ldGhvZCBdID0gZnVuY3Rpb24oIHZhbCApIHtcblx0XHRyZXR1cm4gYWNjZXNzKCB0aGlzLCBmdW5jdGlvbiggZWxlbSwgbWV0aG9kLCB2YWwgKSB7XG5cblx0XHRcdC8vIENvYWxlc2NlIGRvY3VtZW50cyBhbmQgd2luZG93c1xuXHRcdFx0dmFyIHdpbjtcblx0XHRcdGlmICggaXNXaW5kb3coIGVsZW0gKSApIHtcblx0XHRcdFx0d2luID0gZWxlbTtcblx0XHRcdH0gZWxzZSBpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDkgKSB7XG5cdFx0XHRcdHdpbiA9IGVsZW0uZGVmYXVsdFZpZXc7XG5cdFx0XHR9XG5cblx0XHRcdGlmICggdmFsID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdHJldHVybiB3aW4gPyB3aW5bIHByb3AgXSA6IGVsZW1bIG1ldGhvZCBdO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIHdpbiApIHtcblx0XHRcdFx0d2luLnNjcm9sbFRvKFxuXHRcdFx0XHRcdCF0b3AgPyB2YWwgOiB3aW4ucGFnZVhPZmZzZXQsXG5cdFx0XHRcdFx0dG9wID8gdmFsIDogd2luLnBhZ2VZT2Zmc2V0XG5cdFx0XHRcdCk7XG5cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGVsZW1bIG1ldGhvZCBdID0gdmFsO1xuXHRcdFx0fVxuXHRcdH0sIG1ldGhvZCwgdmFsLCBhcmd1bWVudHMubGVuZ3RoICk7XG5cdH07XG59ICk7XG5cbi8vIFN1cHBvcnQ6IFNhZmFyaSA8PTcgLSA5LjEsIENocm9tZSA8PTM3IC0gNDlcbi8vIEFkZCB0aGUgdG9wL2xlZnQgY3NzSG9va3MgdXNpbmcgalF1ZXJ5LmZuLnBvc2l0aW9uXG4vLyBXZWJraXQgYnVnOiBodHRwczovL2J1Z3Mud2Via2l0Lm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MjkwODRcbi8vIEJsaW5rIGJ1ZzogaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9NTg5MzQ3XG4vLyBnZXRDb21wdXRlZFN0eWxlIHJldHVybnMgcGVyY2VudCB3aGVuIHNwZWNpZmllZCBmb3IgdG9wL2xlZnQvYm90dG9tL3JpZ2h0O1xuLy8gcmF0aGVyIHRoYW4gbWFrZSB0aGUgY3NzIG1vZHVsZSBkZXBlbmQgb24gdGhlIG9mZnNldCBtb2R1bGUsIGp1c3QgY2hlY2sgZm9yIGl0IGhlcmVcbmpRdWVyeS5lYWNoKCBbIFwidG9wXCIsIFwibGVmdFwiIF0sIGZ1bmN0aW9uKCBfaSwgcHJvcCApIHtcblx0alF1ZXJ5LmNzc0hvb2tzWyBwcm9wIF0gPSBhZGRHZXRIb29rSWYoIHN1cHBvcnQucGl4ZWxQb3NpdGlvbixcblx0XHRmdW5jdGlvbiggZWxlbSwgY29tcHV0ZWQgKSB7XG5cdFx0XHRpZiAoIGNvbXB1dGVkICkge1xuXHRcdFx0XHRjb21wdXRlZCA9IGN1ckNTUyggZWxlbSwgcHJvcCApO1xuXG5cdFx0XHRcdC8vIElmIGN1ckNTUyByZXR1cm5zIHBlcmNlbnRhZ2UsIGZhbGxiYWNrIHRvIG9mZnNldFxuXHRcdFx0XHRyZXR1cm4gcm51bW5vbnB4LnRlc3QoIGNvbXB1dGVkICkgP1xuXHRcdFx0XHRcdGpRdWVyeSggZWxlbSApLnBvc2l0aW9uKClbIHByb3AgXSArIFwicHhcIiA6XG5cdFx0XHRcdFx0Y29tcHV0ZWQ7XG5cdFx0XHR9XG5cdFx0fVxuXHQpO1xufSApO1xuXG5cbi8vIENyZWF0ZSBpbm5lckhlaWdodCwgaW5uZXJXaWR0aCwgaGVpZ2h0LCB3aWR0aCwgb3V0ZXJIZWlnaHQgYW5kIG91dGVyV2lkdGggbWV0aG9kc1xualF1ZXJ5LmVhY2goIHsgSGVpZ2h0OiBcImhlaWdodFwiLCBXaWR0aDogXCJ3aWR0aFwiIH0sIGZ1bmN0aW9uKCBuYW1lLCB0eXBlICkge1xuXHRqUXVlcnkuZWFjaCgge1xuXHRcdHBhZGRpbmc6IFwiaW5uZXJcIiArIG5hbWUsXG5cdFx0Y29udGVudDogdHlwZSxcblx0XHRcIlwiOiBcIm91dGVyXCIgKyBuYW1lXG5cdH0sIGZ1bmN0aW9uKCBkZWZhdWx0RXh0cmEsIGZ1bmNOYW1lICkge1xuXG5cdFx0Ly8gTWFyZ2luIGlzIG9ubHkgZm9yIG91dGVySGVpZ2h0LCBvdXRlcldpZHRoXG5cdFx0alF1ZXJ5LmZuWyBmdW5jTmFtZSBdID0gZnVuY3Rpb24oIG1hcmdpbiwgdmFsdWUgKSB7XG5cdFx0XHR2YXIgY2hhaW5hYmxlID0gYXJndW1lbnRzLmxlbmd0aCAmJiAoIGRlZmF1bHRFeHRyYSB8fCB0eXBlb2YgbWFyZ2luICE9PSBcImJvb2xlYW5cIiApLFxuXHRcdFx0XHRleHRyYSA9IGRlZmF1bHRFeHRyYSB8fCAoIG1hcmdpbiA9PT0gdHJ1ZSB8fCB2YWx1ZSA9PT0gdHJ1ZSA/IFwibWFyZ2luXCIgOiBcImJvcmRlclwiICk7XG5cblx0XHRcdHJldHVybiBhY2Nlc3MoIHRoaXMsIGZ1bmN0aW9uKCBlbGVtLCB0eXBlLCB2YWx1ZSApIHtcblx0XHRcdFx0dmFyIGRvYztcblxuXHRcdFx0XHRpZiAoIGlzV2luZG93KCBlbGVtICkgKSB7XG5cblx0XHRcdFx0XHQvLyAkKCB3aW5kb3cgKS5vdXRlcldpZHRoL0hlaWdodCByZXR1cm4gdy9oIGluY2x1ZGluZyBzY3JvbGxiYXJzIChnaC0xNzI5KVxuXHRcdFx0XHRcdHJldHVybiBmdW5jTmFtZS5pbmRleE9mKCBcIm91dGVyXCIgKSA9PT0gMCA/XG5cdFx0XHRcdFx0XHRlbGVtWyBcImlubmVyXCIgKyBuYW1lIF0gOlxuXHRcdFx0XHRcdFx0ZWxlbS5kb2N1bWVudC5kb2N1bWVudEVsZW1lbnRbIFwiY2xpZW50XCIgKyBuYW1lIF07XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBHZXQgZG9jdW1lbnQgd2lkdGggb3IgaGVpZ2h0XG5cdFx0XHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gOSApIHtcblx0XHRcdFx0XHRkb2MgPSBlbGVtLmRvY3VtZW50RWxlbWVudDtcblxuXHRcdFx0XHRcdC8vIEVpdGhlciBzY3JvbGxbV2lkdGgvSGVpZ2h0XSBvciBvZmZzZXRbV2lkdGgvSGVpZ2h0XSBvciBjbGllbnRbV2lkdGgvSGVpZ2h0XSxcblx0XHRcdFx0XHQvLyB3aGljaGV2ZXIgaXMgZ3JlYXRlc3Rcblx0XHRcdFx0XHRyZXR1cm4gTWF0aC5tYXgoXG5cdFx0XHRcdFx0XHRlbGVtLmJvZHlbIFwic2Nyb2xsXCIgKyBuYW1lIF0sIGRvY1sgXCJzY3JvbGxcIiArIG5hbWUgXSxcblx0XHRcdFx0XHRcdGVsZW0uYm9keVsgXCJvZmZzZXRcIiArIG5hbWUgXSwgZG9jWyBcIm9mZnNldFwiICsgbmFtZSBdLFxuXHRcdFx0XHRcdFx0ZG9jWyBcImNsaWVudFwiICsgbmFtZSBdXG5cdFx0XHRcdFx0KTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiB2YWx1ZSA9PT0gdW5kZWZpbmVkID9cblxuXHRcdFx0XHRcdC8vIEdldCB3aWR0aCBvciBoZWlnaHQgb24gdGhlIGVsZW1lbnQsIHJlcXVlc3RpbmcgYnV0IG5vdCBmb3JjaW5nIHBhcnNlRmxvYXRcblx0XHRcdFx0XHRqUXVlcnkuY3NzKCBlbGVtLCB0eXBlLCBleHRyYSApIDpcblxuXHRcdFx0XHRcdC8vIFNldCB3aWR0aCBvciBoZWlnaHQgb24gdGhlIGVsZW1lbnRcblx0XHRcdFx0XHRqUXVlcnkuc3R5bGUoIGVsZW0sIHR5cGUsIHZhbHVlLCBleHRyYSApO1xuXHRcdFx0fSwgdHlwZSwgY2hhaW5hYmxlID8gbWFyZ2luIDogdW5kZWZpbmVkLCBjaGFpbmFibGUgKTtcblx0XHR9O1xuXHR9ICk7XG59ICk7XG5cblxualF1ZXJ5LmVhY2goIFtcblx0XCJhamF4U3RhcnRcIixcblx0XCJhamF4U3RvcFwiLFxuXHRcImFqYXhDb21wbGV0ZVwiLFxuXHRcImFqYXhFcnJvclwiLFxuXHRcImFqYXhTdWNjZXNzXCIsXG5cdFwiYWpheFNlbmRcIlxuXSwgZnVuY3Rpb24oIF9pLCB0eXBlICkge1xuXHRqUXVlcnkuZm5bIHR5cGUgXSA9IGZ1bmN0aW9uKCBmbiApIHtcblx0XHRyZXR1cm4gdGhpcy5vbiggdHlwZSwgZm4gKTtcblx0fTtcbn0gKTtcblxuXG5cblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXG5cdGJpbmQ6IGZ1bmN0aW9uKCB0eXBlcywgZGF0YSwgZm4gKSB7XG5cdFx0cmV0dXJuIHRoaXMub24oIHR5cGVzLCBudWxsLCBkYXRhLCBmbiApO1xuXHR9LFxuXHR1bmJpbmQ6IGZ1bmN0aW9uKCB0eXBlcywgZm4gKSB7XG5cdFx0cmV0dXJuIHRoaXMub2ZmKCB0eXBlcywgbnVsbCwgZm4gKTtcblx0fSxcblxuXHRkZWxlZ2F0ZTogZnVuY3Rpb24oIHNlbGVjdG9yLCB0eXBlcywgZGF0YSwgZm4gKSB7XG5cdFx0cmV0dXJuIHRoaXMub24oIHR5cGVzLCBzZWxlY3RvciwgZGF0YSwgZm4gKTtcblx0fSxcblx0dW5kZWxlZ2F0ZTogZnVuY3Rpb24oIHNlbGVjdG9yLCB0eXBlcywgZm4gKSB7XG5cblx0XHQvLyAoIG5hbWVzcGFjZSApIG9yICggc2VsZWN0b3IsIHR5cGVzIFssIGZuXSApXG5cdFx0cmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPT09IDEgP1xuXHRcdFx0dGhpcy5vZmYoIHNlbGVjdG9yLCBcIioqXCIgKSA6XG5cdFx0XHR0aGlzLm9mZiggdHlwZXMsIHNlbGVjdG9yIHx8IFwiKipcIiwgZm4gKTtcblx0fSxcblxuXHRob3ZlcjogZnVuY3Rpb24oIGZuT3ZlciwgZm5PdXQgKSB7XG5cdFx0cmV0dXJuIHRoaXMubW91c2VlbnRlciggZm5PdmVyICkubW91c2VsZWF2ZSggZm5PdXQgfHwgZm5PdmVyICk7XG5cdH1cbn0gKTtcblxualF1ZXJ5LmVhY2goXG5cdCggXCJibHVyIGZvY3VzIGZvY3VzaW4gZm9jdXNvdXQgcmVzaXplIHNjcm9sbCBjbGljayBkYmxjbGljayBcIiArXG5cdFwibW91c2Vkb3duIG1vdXNldXAgbW91c2Vtb3ZlIG1vdXNlb3ZlciBtb3VzZW91dCBtb3VzZWVudGVyIG1vdXNlbGVhdmUgXCIgK1xuXHRcImNoYW5nZSBzZWxlY3Qgc3VibWl0IGtleWRvd24ga2V5cHJlc3Mga2V5dXAgY29udGV4dG1lbnVcIiApLnNwbGl0KCBcIiBcIiApLFxuXHRmdW5jdGlvbiggX2ksIG5hbWUgKSB7XG5cblx0XHQvLyBIYW5kbGUgZXZlbnQgYmluZGluZ1xuXHRcdGpRdWVyeS5mblsgbmFtZSBdID0gZnVuY3Rpb24oIGRhdGEsIGZuICkge1xuXHRcdFx0cmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPiAwID9cblx0XHRcdFx0dGhpcy5vbiggbmFtZSwgbnVsbCwgZGF0YSwgZm4gKSA6XG5cdFx0XHRcdHRoaXMudHJpZ2dlciggbmFtZSApO1xuXHRcdH07XG5cdH1cbik7XG5cblxuXG5cbi8vIFN1cHBvcnQ6IEFuZHJvaWQgPD00LjAgb25seVxuLy8gTWFrZSBzdXJlIHdlIHRyaW0gQk9NIGFuZCBOQlNQXG52YXIgcnRyaW0gPSAvXltcXHNcXHVGRUZGXFx4QTBdK3xbXFxzXFx1RkVGRlxceEEwXSskL2c7XG5cbi8vIEJpbmQgYSBmdW5jdGlvbiB0byBhIGNvbnRleHQsIG9wdGlvbmFsbHkgcGFydGlhbGx5IGFwcGx5aW5nIGFueVxuLy8gYXJndW1lbnRzLlxuLy8galF1ZXJ5LnByb3h5IGlzIGRlcHJlY2F0ZWQgdG8gcHJvbW90ZSBzdGFuZGFyZHMgKHNwZWNpZmljYWxseSBGdW5jdGlvbiNiaW5kKVxuLy8gSG93ZXZlciwgaXQgaXMgbm90IHNsYXRlZCBmb3IgcmVtb3ZhbCBhbnkgdGltZSBzb29uXG5qUXVlcnkucHJveHkgPSBmdW5jdGlvbiggZm4sIGNvbnRleHQgKSB7XG5cdHZhciB0bXAsIGFyZ3MsIHByb3h5O1xuXG5cdGlmICggdHlwZW9mIGNvbnRleHQgPT09IFwic3RyaW5nXCIgKSB7XG5cdFx0dG1wID0gZm5bIGNvbnRleHQgXTtcblx0XHRjb250ZXh0ID0gZm47XG5cdFx0Zm4gPSB0bXA7XG5cdH1cblxuXHQvLyBRdWljayBjaGVjayB0byBkZXRlcm1pbmUgaWYgdGFyZ2V0IGlzIGNhbGxhYmxlLCBpbiB0aGUgc3BlY1xuXHQvLyB0aGlzIHRocm93cyBhIFR5cGVFcnJvciwgYnV0IHdlIHdpbGwganVzdCByZXR1cm4gdW5kZWZpbmVkLlxuXHRpZiAoICFpc0Z1bmN0aW9uKCBmbiApICkge1xuXHRcdHJldHVybiB1bmRlZmluZWQ7XG5cdH1cblxuXHQvLyBTaW11bGF0ZWQgYmluZFxuXHRhcmdzID0gc2xpY2UuY2FsbCggYXJndW1lbnRzLCAyICk7XG5cdHByb3h5ID0gZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIGZuLmFwcGx5KCBjb250ZXh0IHx8IHRoaXMsIGFyZ3MuY29uY2F0KCBzbGljZS5jYWxsKCBhcmd1bWVudHMgKSApICk7XG5cdH07XG5cblx0Ly8gU2V0IHRoZSBndWlkIG9mIHVuaXF1ZSBoYW5kbGVyIHRvIHRoZSBzYW1lIG9mIG9yaWdpbmFsIGhhbmRsZXIsIHNvIGl0IGNhbiBiZSByZW1vdmVkXG5cdHByb3h5Lmd1aWQgPSBmbi5ndWlkID0gZm4uZ3VpZCB8fCBqUXVlcnkuZ3VpZCsrO1xuXG5cdHJldHVybiBwcm94eTtcbn07XG5cbmpRdWVyeS5ob2xkUmVhZHkgPSBmdW5jdGlvbiggaG9sZCApIHtcblx0aWYgKCBob2xkICkge1xuXHRcdGpRdWVyeS5yZWFkeVdhaXQrKztcblx0fSBlbHNlIHtcblx0XHRqUXVlcnkucmVhZHkoIHRydWUgKTtcblx0fVxufTtcbmpRdWVyeS5pc0FycmF5ID0gQXJyYXkuaXNBcnJheTtcbmpRdWVyeS5wYXJzZUpTT04gPSBKU09OLnBhcnNlO1xualF1ZXJ5Lm5vZGVOYW1lID0gbm9kZU5hbWU7XG5qUXVlcnkuaXNGdW5jdGlvbiA9IGlzRnVuY3Rpb247XG5qUXVlcnkuaXNXaW5kb3cgPSBpc1dpbmRvdztcbmpRdWVyeS5jYW1lbENhc2UgPSBjYW1lbENhc2U7XG5qUXVlcnkudHlwZSA9IHRvVHlwZTtcblxualF1ZXJ5Lm5vdyA9IERhdGUubm93O1xuXG5qUXVlcnkuaXNOdW1lcmljID0gZnVuY3Rpb24oIG9iaiApIHtcblxuXHQvLyBBcyBvZiBqUXVlcnkgMy4wLCBpc051bWVyaWMgaXMgbGltaXRlZCB0b1xuXHQvLyBzdHJpbmdzIGFuZCBudW1iZXJzIChwcmltaXRpdmVzIG9yIG9iamVjdHMpXG5cdC8vIHRoYXQgY2FuIGJlIGNvZXJjZWQgdG8gZmluaXRlIG51bWJlcnMgKGdoLTI2NjIpXG5cdHZhciB0eXBlID0galF1ZXJ5LnR5cGUoIG9iaiApO1xuXHRyZXR1cm4gKCB0eXBlID09PSBcIm51bWJlclwiIHx8IHR5cGUgPT09IFwic3RyaW5nXCIgKSAmJlxuXG5cdFx0Ly8gcGFyc2VGbG9hdCBOYU5zIG51bWVyaWMtY2FzdCBmYWxzZSBwb3NpdGl2ZXMgKFwiXCIpXG5cdFx0Ly8gLi4uYnV0IG1pc2ludGVycHJldHMgbGVhZGluZy1udW1iZXIgc3RyaW5ncywgcGFydGljdWxhcmx5IGhleCBsaXRlcmFscyAoXCIweC4uLlwiKVxuXHRcdC8vIHN1YnRyYWN0aW9uIGZvcmNlcyBpbmZpbml0aWVzIHRvIE5hTlxuXHRcdCFpc05hTiggb2JqIC0gcGFyc2VGbG9hdCggb2JqICkgKTtcbn07XG5cbmpRdWVyeS50cmltID0gZnVuY3Rpb24oIHRleHQgKSB7XG5cdHJldHVybiB0ZXh0ID09IG51bGwgP1xuXHRcdFwiXCIgOlxuXHRcdCggdGV4dCArIFwiXCIgKS5yZXBsYWNlKCBydHJpbSwgXCJcIiApO1xufTtcblxuXG5cbi8vIFJlZ2lzdGVyIGFzIGEgbmFtZWQgQU1EIG1vZHVsZSwgc2luY2UgalF1ZXJ5IGNhbiBiZSBjb25jYXRlbmF0ZWQgd2l0aCBvdGhlclxuLy8gZmlsZXMgdGhhdCBtYXkgdXNlIGRlZmluZSwgYnV0IG5vdCB2aWEgYSBwcm9wZXIgY29uY2F0ZW5hdGlvbiBzY3JpcHQgdGhhdFxuLy8gdW5kZXJzdGFuZHMgYW5vbnltb3VzIEFNRCBtb2R1bGVzLiBBIG5hbWVkIEFNRCBpcyBzYWZlc3QgYW5kIG1vc3Qgcm9idXN0XG4vLyB3YXkgdG8gcmVnaXN0ZXIuIExvd2VyY2FzZSBqcXVlcnkgaXMgdXNlZCBiZWNhdXNlIEFNRCBtb2R1bGUgbmFtZXMgYXJlXG4vLyBkZXJpdmVkIGZyb20gZmlsZSBuYW1lcywgYW5kIGpRdWVyeSBpcyBub3JtYWxseSBkZWxpdmVyZWQgaW4gYSBsb3dlcmNhc2Vcbi8vIGZpbGUgbmFtZS4gRG8gdGhpcyBhZnRlciBjcmVhdGluZyB0aGUgZ2xvYmFsIHNvIHRoYXQgaWYgYW4gQU1EIG1vZHVsZSB3YW50c1xuLy8gdG8gY2FsbCBub0NvbmZsaWN0IHRvIGhpZGUgdGhpcyB2ZXJzaW9uIG9mIGpRdWVyeSwgaXQgd2lsbCB3b3JrLlxuXG4vLyBOb3RlIHRoYXQgZm9yIG1heGltdW0gcG9ydGFiaWxpdHksIGxpYnJhcmllcyB0aGF0IGFyZSBub3QgalF1ZXJ5IHNob3VsZFxuLy8gZGVjbGFyZSB0aGVtc2VsdmVzIGFzIGFub255bW91cyBtb2R1bGVzLCBhbmQgYXZvaWQgc2V0dGluZyBhIGdsb2JhbCBpZiBhblxuLy8gQU1EIGxvYWRlciBpcyBwcmVzZW50LiBqUXVlcnkgaXMgYSBzcGVjaWFsIGNhc2UuIEZvciBtb3JlIGluZm9ybWF0aW9uLCBzZWVcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9qcmJ1cmtlL3JlcXVpcmVqcy93aWtpL1VwZGF0aW5nLWV4aXN0aW5nLWxpYnJhcmllcyN3aWtpLWFub25cblxuaWYgKCB0eXBlb2YgZGVmaW5lID09PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCApIHtcblx0ZGVmaW5lKCBcImpxdWVyeVwiLCBbXSwgZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIGpRdWVyeTtcblx0fSApO1xufVxuXG5cblxuXG52YXJcblxuXHQvLyBNYXAgb3ZlciBqUXVlcnkgaW4gY2FzZSBvZiBvdmVyd3JpdGVcblx0X2pRdWVyeSA9IHdpbmRvdy5qUXVlcnksXG5cblx0Ly8gTWFwIG92ZXIgdGhlICQgaW4gY2FzZSBvZiBvdmVyd3JpdGVcblx0XyQgPSB3aW5kb3cuJDtcblxualF1ZXJ5Lm5vQ29uZmxpY3QgPSBmdW5jdGlvbiggZGVlcCApIHtcblx0aWYgKCB3aW5kb3cuJCA9PT0galF1ZXJ5ICkge1xuXHRcdHdpbmRvdy4kID0gXyQ7XG5cdH1cblxuXHRpZiAoIGRlZXAgJiYgd2luZG93LmpRdWVyeSA9PT0galF1ZXJ5ICkge1xuXHRcdHdpbmRvdy5qUXVlcnkgPSBfalF1ZXJ5O1xuXHR9XG5cblx0cmV0dXJuIGpRdWVyeTtcbn07XG5cbi8vIEV4cG9zZSBqUXVlcnkgYW5kICQgaWRlbnRpZmllcnMsIGV2ZW4gaW4gQU1EXG4vLyAoIzcxMDIjY29tbWVudDoxMCwgaHR0cHM6Ly9naXRodWIuY29tL2pxdWVyeS9qcXVlcnkvcHVsbC81NTcpXG4vLyBhbmQgQ29tbW9uSlMgZm9yIGJyb3dzZXIgZW11bGF0b3JzICgjMTM1NjYpXG5pZiAoIHR5cGVvZiBub0dsb2JhbCA9PT0gXCJ1bmRlZmluZWRcIiApIHtcblx0d2luZG93LmpRdWVyeSA9IHdpbmRvdy4kID0galF1ZXJ5O1xufVxuXG5cblxuXG5yZXR1cm4galF1ZXJ5O1xufSApO1xuIiwiLypcbiAgICAgXyBfICAgICAgXyAgICAgICBfXG4gX19ffCAoXykgX19ffCB8IF9fICAoXylfX19cbi8gX198IHwgfC8gX198IHwvIC8gIHwgLyBfX3xcblxcX18gXFwgfCB8IChfX3wgICA8IF8gfCBcXF9fIFxcXG58X19fL198X3xcXF9fX3xffFxcXyhfKS8gfF9fXy9cbiAgICAgICAgICAgICAgICAgICB8X18vXG5cbiBWZXJzaW9uOiAxLjguMVxuICBBdXRob3I6IEtlbiBXaGVlbGVyXG4gV2Vic2l0ZTogaHR0cDovL2tlbndoZWVsZXIuZ2l0aHViLmlvXG4gICAgRG9jczogaHR0cDovL2tlbndoZWVsZXIuZ2l0aHViLmlvL3NsaWNrXG4gICAgUmVwbzogaHR0cDovL2dpdGh1Yi5jb20va2Vud2hlZWxlci9zbGlja1xuICBJc3N1ZXM6IGh0dHA6Ly9naXRodWIuY29tL2tlbndoZWVsZXIvc2xpY2svaXNzdWVzXG5cbiAqL1xuLyogZ2xvYmFsIHdpbmRvdywgZG9jdW1lbnQsIGRlZmluZSwgalF1ZXJ5LCBzZXRJbnRlcnZhbCwgY2xlYXJJbnRlcnZhbCAqL1xuOyhmdW5jdGlvbihmYWN0b3J5KSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuICAgIGlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpIHtcbiAgICAgICAgZGVmaW5lKFsnanF1ZXJ5J10sIGZhY3RvcnkpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGV4cG9ydHMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeShyZXF1aXJlKCdqcXVlcnknKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgZmFjdG9yeShqUXVlcnkpO1xuICAgIH1cblxufShmdW5jdGlvbigkKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuICAgIHZhciBTbGljayA9IHdpbmRvdy5TbGljayB8fCB7fTtcblxuICAgIFNsaWNrID0gKGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHZhciBpbnN0YW5jZVVpZCA9IDA7XG5cbiAgICAgICAgZnVuY3Rpb24gU2xpY2soZWxlbWVudCwgc2V0dGluZ3MpIHtcblxuICAgICAgICAgICAgdmFyIF8gPSB0aGlzLCBkYXRhU2V0dGluZ3M7XG5cbiAgICAgICAgICAgIF8uZGVmYXVsdHMgPSB7XG4gICAgICAgICAgICAgICAgYWNjZXNzaWJpbGl0eTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBhZGFwdGl2ZUhlaWdodDogZmFsc2UsXG4gICAgICAgICAgICAgICAgYXBwZW5kQXJyb3dzOiAkKGVsZW1lbnQpLFxuICAgICAgICAgICAgICAgIGFwcGVuZERvdHM6ICQoZWxlbWVudCksXG4gICAgICAgICAgICAgICAgYXJyb3dzOiB0cnVlLFxuICAgICAgICAgICAgICAgIGFzTmF2Rm9yOiBudWxsLFxuICAgICAgICAgICAgICAgIHByZXZBcnJvdzogJzxidXR0b24gY2xhc3M9XCJzbGljay1wcmV2XCIgYXJpYS1sYWJlbD1cIlByZXZpb3VzXCIgdHlwZT1cImJ1dHRvblwiPlByZXZpb3VzPC9idXR0b24+JyxcbiAgICAgICAgICAgICAgICBuZXh0QXJyb3c6ICc8YnV0dG9uIGNsYXNzPVwic2xpY2stbmV4dFwiIGFyaWEtbGFiZWw9XCJOZXh0XCIgdHlwZT1cImJ1dHRvblwiPk5leHQ8L2J1dHRvbj4nLFxuICAgICAgICAgICAgICAgIGF1dG9wbGF5OiBmYWxzZSxcbiAgICAgICAgICAgICAgICBhdXRvcGxheVNwZWVkOiAzMDAwLFxuICAgICAgICAgICAgICAgIGNlbnRlck1vZGU6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGNlbnRlclBhZGRpbmc6ICc1MHB4JyxcbiAgICAgICAgICAgICAgICBjc3NFYXNlOiAnZWFzZScsXG4gICAgICAgICAgICAgICAgY3VzdG9tUGFnaW5nOiBmdW5jdGlvbihzbGlkZXIsIGkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICQoJzxidXR0b24gdHlwZT1cImJ1dHRvblwiIC8+JykudGV4dChpICsgMSk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBkb3RzOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBkb3RzQ2xhc3M6ICdzbGljay1kb3RzJyxcbiAgICAgICAgICAgICAgICBkcmFnZ2FibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgZWFzaW5nOiAnbGluZWFyJyxcbiAgICAgICAgICAgICAgICBlZGdlRnJpY3Rpb246IDAuMzUsXG4gICAgICAgICAgICAgICAgZmFkZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgZm9jdXNPblNlbGVjdDogZmFsc2UsXG4gICAgICAgICAgICAgICAgZm9jdXNPbkNoYW5nZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgaW5maW5pdGU6IHRydWUsXG4gICAgICAgICAgICAgICAgaW5pdGlhbFNsaWRlOiAwLFxuICAgICAgICAgICAgICAgIGxhenlMb2FkOiAnb25kZW1hbmQnLFxuICAgICAgICAgICAgICAgIG1vYmlsZUZpcnN0OiBmYWxzZSxcbiAgICAgICAgICAgICAgICBwYXVzZU9uSG92ZXI6IHRydWUsXG4gICAgICAgICAgICAgICAgcGF1c2VPbkZvY3VzOiB0cnVlLFxuICAgICAgICAgICAgICAgIHBhdXNlT25Eb3RzSG92ZXI6IGZhbHNlLFxuICAgICAgICAgICAgICAgIHJlc3BvbmRUbzogJ3dpbmRvdycsXG4gICAgICAgICAgICAgICAgcmVzcG9uc2l2ZTogbnVsbCxcbiAgICAgICAgICAgICAgICByb3dzOiAxLFxuICAgICAgICAgICAgICAgIHJ0bDogZmFsc2UsXG4gICAgICAgICAgICAgICAgc2xpZGU6ICcnLFxuICAgICAgICAgICAgICAgIHNsaWRlc1BlclJvdzogMSxcbiAgICAgICAgICAgICAgICBzbGlkZXNUb1Nob3c6IDEsXG4gICAgICAgICAgICAgICAgc2xpZGVzVG9TY3JvbGw6IDEsXG4gICAgICAgICAgICAgICAgc3BlZWQ6IDUwMCxcbiAgICAgICAgICAgICAgICBzd2lwZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBzd2lwZVRvU2xpZGU6IGZhbHNlLFxuICAgICAgICAgICAgICAgIHRvdWNoTW92ZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICB0b3VjaFRocmVzaG9sZDogNSxcbiAgICAgICAgICAgICAgICB1c2VDU1M6IHRydWUsXG4gICAgICAgICAgICAgICAgdXNlVHJhbnNmb3JtOiB0cnVlLFxuICAgICAgICAgICAgICAgIHZhcmlhYmxlV2lkdGg6IGZhbHNlLFxuICAgICAgICAgICAgICAgIHZlcnRpY2FsOiBmYWxzZSxcbiAgICAgICAgICAgICAgICB2ZXJ0aWNhbFN3aXBpbmc6IGZhbHNlLFxuICAgICAgICAgICAgICAgIHdhaXRGb3JBbmltYXRlOiB0cnVlLFxuICAgICAgICAgICAgICAgIHpJbmRleDogMTAwMFxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgXy5pbml0aWFscyA9IHtcbiAgICAgICAgICAgICAgICBhbmltYXRpbmc6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGRyYWdnaW5nOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBhdXRvUGxheVRpbWVyOiBudWxsLFxuICAgICAgICAgICAgICAgIGN1cnJlbnREaXJlY3Rpb246IDAsXG4gICAgICAgICAgICAgICAgY3VycmVudExlZnQ6IG51bGwsXG4gICAgICAgICAgICAgICAgY3VycmVudFNsaWRlOiAwLFxuICAgICAgICAgICAgICAgIGRpcmVjdGlvbjogMSxcbiAgICAgICAgICAgICAgICAkZG90czogbnVsbCxcbiAgICAgICAgICAgICAgICBsaXN0V2lkdGg6IG51bGwsXG4gICAgICAgICAgICAgICAgbGlzdEhlaWdodDogbnVsbCxcbiAgICAgICAgICAgICAgICBsb2FkSW5kZXg6IDAsXG4gICAgICAgICAgICAgICAgJG5leHRBcnJvdzogbnVsbCxcbiAgICAgICAgICAgICAgICAkcHJldkFycm93OiBudWxsLFxuICAgICAgICAgICAgICAgIHNjcm9sbGluZzogZmFsc2UsXG4gICAgICAgICAgICAgICAgc2xpZGVDb3VudDogbnVsbCxcbiAgICAgICAgICAgICAgICBzbGlkZVdpZHRoOiBudWxsLFxuICAgICAgICAgICAgICAgICRzbGlkZVRyYWNrOiBudWxsLFxuICAgICAgICAgICAgICAgICRzbGlkZXM6IG51bGwsXG4gICAgICAgICAgICAgICAgc2xpZGluZzogZmFsc2UsXG4gICAgICAgICAgICAgICAgc2xpZGVPZmZzZXQ6IDAsXG4gICAgICAgICAgICAgICAgc3dpcGVMZWZ0OiBudWxsLFxuICAgICAgICAgICAgICAgIHN3aXBpbmc6IGZhbHNlLFxuICAgICAgICAgICAgICAgICRsaXN0OiBudWxsLFxuICAgICAgICAgICAgICAgIHRvdWNoT2JqZWN0OiB7fSxcbiAgICAgICAgICAgICAgICB0cmFuc2Zvcm1zRW5hYmxlZDogZmFsc2UsXG4gICAgICAgICAgICAgICAgdW5zbGlja2VkOiBmYWxzZVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgJC5leHRlbmQoXywgXy5pbml0aWFscyk7XG5cbiAgICAgICAgICAgIF8uYWN0aXZlQnJlYWtwb2ludCA9IG51bGw7XG4gICAgICAgICAgICBfLmFuaW1UeXBlID0gbnVsbDtcbiAgICAgICAgICAgIF8uYW5pbVByb3AgPSBudWxsO1xuICAgICAgICAgICAgXy5icmVha3BvaW50cyA9IFtdO1xuICAgICAgICAgICAgXy5icmVha3BvaW50U2V0dGluZ3MgPSBbXTtcbiAgICAgICAgICAgIF8uY3NzVHJhbnNpdGlvbnMgPSBmYWxzZTtcbiAgICAgICAgICAgIF8uZm9jdXNzZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIF8uaW50ZXJydXB0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIF8uaGlkZGVuID0gJ2hpZGRlbic7XG4gICAgICAgICAgICBfLnBhdXNlZCA9IHRydWU7XG4gICAgICAgICAgICBfLnBvc2l0aW9uUHJvcCA9IG51bGw7XG4gICAgICAgICAgICBfLnJlc3BvbmRUbyA9IG51bGw7XG4gICAgICAgICAgICBfLnJvd0NvdW50ID0gMTtcbiAgICAgICAgICAgIF8uc2hvdWxkQ2xpY2sgPSB0cnVlO1xuICAgICAgICAgICAgXy4kc2xpZGVyID0gJChlbGVtZW50KTtcbiAgICAgICAgICAgIF8uJHNsaWRlc0NhY2hlID0gbnVsbDtcbiAgICAgICAgICAgIF8udHJhbnNmb3JtVHlwZSA9IG51bGw7XG4gICAgICAgICAgICBfLnRyYW5zaXRpb25UeXBlID0gbnVsbDtcbiAgICAgICAgICAgIF8udmlzaWJpbGl0eUNoYW5nZSA9ICd2aXNpYmlsaXR5Y2hhbmdlJztcbiAgICAgICAgICAgIF8ud2luZG93V2lkdGggPSAwO1xuICAgICAgICAgICAgXy53aW5kb3dUaW1lciA9IG51bGw7XG5cbiAgICAgICAgICAgIGRhdGFTZXR0aW5ncyA9ICQoZWxlbWVudCkuZGF0YSgnc2xpY2snKSB8fCB7fTtcblxuICAgICAgICAgICAgXy5vcHRpb25zID0gJC5leHRlbmQoe30sIF8uZGVmYXVsdHMsIHNldHRpbmdzLCBkYXRhU2V0dGluZ3MpO1xuXG4gICAgICAgICAgICBfLmN1cnJlbnRTbGlkZSA9IF8ub3B0aW9ucy5pbml0aWFsU2xpZGU7XG5cbiAgICAgICAgICAgIF8ub3JpZ2luYWxTZXR0aW5ncyA9IF8ub3B0aW9ucztcblxuICAgICAgICAgICAgaWYgKHR5cGVvZiBkb2N1bWVudC5tb3pIaWRkZW4gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgXy5oaWRkZW4gPSAnbW96SGlkZGVuJztcbiAgICAgICAgICAgICAgICBfLnZpc2liaWxpdHlDaGFuZ2UgPSAnbW96dmlzaWJpbGl0eWNoYW5nZSc7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBkb2N1bWVudC53ZWJraXRIaWRkZW4gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgXy5oaWRkZW4gPSAnd2Via2l0SGlkZGVuJztcbiAgICAgICAgICAgICAgICBfLnZpc2liaWxpdHlDaGFuZ2UgPSAnd2Via2l0dmlzaWJpbGl0eWNoYW5nZSc7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIF8uYXV0b1BsYXkgPSAkLnByb3h5KF8uYXV0b1BsYXksIF8pO1xuICAgICAgICAgICAgXy5hdXRvUGxheUNsZWFyID0gJC5wcm94eShfLmF1dG9QbGF5Q2xlYXIsIF8pO1xuICAgICAgICAgICAgXy5hdXRvUGxheUl0ZXJhdG9yID0gJC5wcm94eShfLmF1dG9QbGF5SXRlcmF0b3IsIF8pO1xuICAgICAgICAgICAgXy5jaGFuZ2VTbGlkZSA9ICQucHJveHkoXy5jaGFuZ2VTbGlkZSwgXyk7XG4gICAgICAgICAgICBfLmNsaWNrSGFuZGxlciA9ICQucHJveHkoXy5jbGlja0hhbmRsZXIsIF8pO1xuICAgICAgICAgICAgXy5zZWxlY3RIYW5kbGVyID0gJC5wcm94eShfLnNlbGVjdEhhbmRsZXIsIF8pO1xuICAgICAgICAgICAgXy5zZXRQb3NpdGlvbiA9ICQucHJveHkoXy5zZXRQb3NpdGlvbiwgXyk7XG4gICAgICAgICAgICBfLnN3aXBlSGFuZGxlciA9ICQucHJveHkoXy5zd2lwZUhhbmRsZXIsIF8pO1xuICAgICAgICAgICAgXy5kcmFnSGFuZGxlciA9ICQucHJveHkoXy5kcmFnSGFuZGxlciwgXyk7XG4gICAgICAgICAgICBfLmtleUhhbmRsZXIgPSAkLnByb3h5KF8ua2V5SGFuZGxlciwgXyk7XG5cbiAgICAgICAgICAgIF8uaW5zdGFuY2VVaWQgPSBpbnN0YW5jZVVpZCsrO1xuXG4gICAgICAgICAgICAvLyBBIHNpbXBsZSB3YXkgdG8gY2hlY2sgZm9yIEhUTUwgc3RyaW5nc1xuICAgICAgICAgICAgLy8gU3RyaWN0IEhUTUwgcmVjb2duaXRpb24gKG11c3Qgc3RhcnQgd2l0aCA8KVxuICAgICAgICAgICAgLy8gRXh0cmFjdGVkIGZyb20galF1ZXJ5IHYxLjExIHNvdXJjZVxuICAgICAgICAgICAgXy5odG1sRXhwciA9IC9eKD86XFxzKig8W1xcd1xcV10rPilbXj5dKikkLztcblxuXG4gICAgICAgICAgICBfLnJlZ2lzdGVyQnJlYWtwb2ludHMoKTtcbiAgICAgICAgICAgIF8uaW5pdCh0cnVlKTtcblxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIFNsaWNrO1xuXG4gICAgfSgpKTtcblxuICAgIFNsaWNrLnByb3RvdHlwZS5hY3RpdmF0ZUFEQSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgXyA9IHRoaXM7XG5cbiAgICAgICAgXy4kc2xpZGVUcmFjay5maW5kKCcuc2xpY2stYWN0aXZlJykuYXR0cih7XG4gICAgICAgICAgICAnYXJpYS1oaWRkZW4nOiAnZmFsc2UnXG4gICAgICAgIH0pLmZpbmQoJ2EsIGlucHV0LCBidXR0b24sIHNlbGVjdCcpLmF0dHIoe1xuICAgICAgICAgICAgJ3RhYmluZGV4JzogJzAnXG4gICAgICAgIH0pO1xuXG4gICAgfTtcblxuICAgIFNsaWNrLnByb3RvdHlwZS5hZGRTbGlkZSA9IFNsaWNrLnByb3RvdHlwZS5zbGlja0FkZCA9IGZ1bmN0aW9uKG1hcmt1cCwgaW5kZXgsIGFkZEJlZm9yZSkge1xuXG4gICAgICAgIHZhciBfID0gdGhpcztcblxuICAgICAgICBpZiAodHlwZW9mKGluZGV4KSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICBhZGRCZWZvcmUgPSBpbmRleDtcbiAgICAgICAgICAgIGluZGV4ID0gbnVsbDtcbiAgICAgICAgfSBlbHNlIGlmIChpbmRleCA8IDAgfHwgKGluZGV4ID49IF8uc2xpZGVDb3VudCkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIF8udW5sb2FkKCk7XG5cbiAgICAgICAgaWYgKHR5cGVvZihpbmRleCkgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICBpZiAoaW5kZXggPT09IDAgJiYgXy4kc2xpZGVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICQobWFya3VwKS5hcHBlbmRUbyhfLiRzbGlkZVRyYWNrKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoYWRkQmVmb3JlKSB7XG4gICAgICAgICAgICAgICAgJChtYXJrdXApLmluc2VydEJlZm9yZShfLiRzbGlkZXMuZXEoaW5kZXgpKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgJChtYXJrdXApLmluc2VydEFmdGVyKF8uJHNsaWRlcy5lcShpbmRleCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKGFkZEJlZm9yZSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgICQobWFya3VwKS5wcmVwZW5kVG8oXy4kc2xpZGVUcmFjayk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICQobWFya3VwKS5hcHBlbmRUbyhfLiRzbGlkZVRyYWNrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIF8uJHNsaWRlcyA9IF8uJHNsaWRlVHJhY2suY2hpbGRyZW4odGhpcy5vcHRpb25zLnNsaWRlKTtcblxuICAgICAgICBfLiRzbGlkZVRyYWNrLmNoaWxkcmVuKHRoaXMub3B0aW9ucy5zbGlkZSkuZGV0YWNoKCk7XG5cbiAgICAgICAgXy4kc2xpZGVUcmFjay5hcHBlbmQoXy4kc2xpZGVzKTtcblxuICAgICAgICBfLiRzbGlkZXMuZWFjaChmdW5jdGlvbihpbmRleCwgZWxlbWVudCkge1xuICAgICAgICAgICAgJChlbGVtZW50KS5hdHRyKCdkYXRhLXNsaWNrLWluZGV4JywgaW5kZXgpO1xuICAgICAgICB9KTtcblxuICAgICAgICBfLiRzbGlkZXNDYWNoZSA9IF8uJHNsaWRlcztcblxuICAgICAgICBfLnJlaW5pdCgpO1xuXG4gICAgfTtcblxuICAgIFNsaWNrLnByb3RvdHlwZS5hbmltYXRlSGVpZ2h0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBfID0gdGhpcztcbiAgICAgICAgaWYgKF8ub3B0aW9ucy5zbGlkZXNUb1Nob3cgPT09IDEgJiYgXy5vcHRpb25zLmFkYXB0aXZlSGVpZ2h0ID09PSB0cnVlICYmIF8ub3B0aW9ucy52ZXJ0aWNhbCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHZhciB0YXJnZXRIZWlnaHQgPSBfLiRzbGlkZXMuZXEoXy5jdXJyZW50U2xpZGUpLm91dGVySGVpZ2h0KHRydWUpO1xuICAgICAgICAgICAgXy4kbGlzdC5hbmltYXRlKHtcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IHRhcmdldEhlaWdodFxuICAgICAgICAgICAgfSwgXy5vcHRpb25zLnNwZWVkKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBTbGljay5wcm90b3R5cGUuYW5pbWF0ZVNsaWRlID0gZnVuY3Rpb24odGFyZ2V0TGVmdCwgY2FsbGJhY2spIHtcblxuICAgICAgICB2YXIgYW5pbVByb3BzID0ge30sXG4gICAgICAgICAgICBfID0gdGhpcztcblxuICAgICAgICBfLmFuaW1hdGVIZWlnaHQoKTtcblxuICAgICAgICBpZiAoXy5vcHRpb25zLnJ0bCA9PT0gdHJ1ZSAmJiBfLm9wdGlvbnMudmVydGljYWwgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICB0YXJnZXRMZWZ0ID0gLXRhcmdldExlZnQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKF8udHJhbnNmb3Jtc0VuYWJsZWQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICBpZiAoXy5vcHRpb25zLnZlcnRpY2FsID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIF8uJHNsaWRlVHJhY2suYW5pbWF0ZSh7XG4gICAgICAgICAgICAgICAgICAgIGxlZnQ6IHRhcmdldExlZnRcbiAgICAgICAgICAgICAgICB9LCBfLm9wdGlvbnMuc3BlZWQsIF8ub3B0aW9ucy5lYXNpbmcsIGNhbGxiYWNrKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgXy4kc2xpZGVUcmFjay5hbmltYXRlKHtcbiAgICAgICAgICAgICAgICAgICAgdG9wOiB0YXJnZXRMZWZ0XG4gICAgICAgICAgICAgICAgfSwgXy5vcHRpb25zLnNwZWVkLCBfLm9wdGlvbnMuZWFzaW5nLCBjYWxsYmFjayk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgaWYgKF8uY3NzVHJhbnNpdGlvbnMgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgaWYgKF8ub3B0aW9ucy5ydGwgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgXy5jdXJyZW50TGVmdCA9IC0oXy5jdXJyZW50TGVmdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICQoe1xuICAgICAgICAgICAgICAgICAgICBhbmltU3RhcnQ6IF8uY3VycmVudExlZnRcbiAgICAgICAgICAgICAgICB9KS5hbmltYXRlKHtcbiAgICAgICAgICAgICAgICAgICAgYW5pbVN0YXJ0OiB0YXJnZXRMZWZ0XG4gICAgICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgICAgICBkdXJhdGlvbjogXy5vcHRpb25zLnNwZWVkLFxuICAgICAgICAgICAgICAgICAgICBlYXNpbmc6IF8ub3B0aW9ucy5lYXNpbmcsXG4gICAgICAgICAgICAgICAgICAgIHN0ZXA6IGZ1bmN0aW9uKG5vdykge1xuICAgICAgICAgICAgICAgICAgICAgICAgbm93ID0gTWF0aC5jZWlsKG5vdyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoXy5vcHRpb25zLnZlcnRpY2FsID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFuaW1Qcm9wc1tfLmFuaW1UeXBlXSA9ICd0cmFuc2xhdGUoJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vdyArICdweCwgMHB4KSc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXy4kc2xpZGVUcmFjay5jc3MoYW5pbVByb3BzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYW5pbVByb3BzW18uYW5pbVR5cGVdID0gJ3RyYW5zbGF0ZSgwcHgsJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vdyArICdweCknO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF8uJHNsaWRlVHJhY2suY3NzKGFuaW1Qcm9wcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIGNvbXBsZXRlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrLmNhbGwoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICAgICAgXy5hcHBseVRyYW5zaXRpb24oKTtcbiAgICAgICAgICAgICAgICB0YXJnZXRMZWZ0ID0gTWF0aC5jZWlsKHRhcmdldExlZnQpO1xuXG4gICAgICAgICAgICAgICAgaWYgKF8ub3B0aW9ucy52ZXJ0aWNhbCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgYW5pbVByb3BzW18uYW5pbVR5cGVdID0gJ3RyYW5zbGF0ZTNkKCcgKyB0YXJnZXRMZWZ0ICsgJ3B4LCAwcHgsIDBweCknO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGFuaW1Qcm9wc1tfLmFuaW1UeXBlXSA9ICd0cmFuc2xhdGUzZCgwcHgsJyArIHRhcmdldExlZnQgKyAncHgsIDBweCknO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBfLiRzbGlkZVRyYWNrLmNzcyhhbmltUHJvcHMpO1xuXG4gICAgICAgICAgICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIF8uZGlzYWJsZVRyYW5zaXRpb24oKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2suY2FsbCgpO1xuICAgICAgICAgICAgICAgICAgICB9LCBfLm9wdGlvbnMuc3BlZWQpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuICAgIH07XG5cbiAgICBTbGljay5wcm90b3R5cGUuZ2V0TmF2VGFyZ2V0ID0gZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdmFyIF8gPSB0aGlzLFxuICAgICAgICAgICAgYXNOYXZGb3IgPSBfLm9wdGlvbnMuYXNOYXZGb3I7XG5cbiAgICAgICAgaWYgKCBhc05hdkZvciAmJiBhc05hdkZvciAhPT0gbnVsbCApIHtcbiAgICAgICAgICAgIGFzTmF2Rm9yID0gJChhc05hdkZvcikubm90KF8uJHNsaWRlcik7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYXNOYXZGb3I7XG5cbiAgICB9O1xuXG4gICAgU2xpY2sucHJvdG90eXBlLmFzTmF2Rm9yID0gZnVuY3Rpb24oaW5kZXgpIHtcblxuICAgICAgICB2YXIgXyA9IHRoaXMsXG4gICAgICAgICAgICBhc05hdkZvciA9IF8uZ2V0TmF2VGFyZ2V0KCk7XG5cbiAgICAgICAgaWYgKCBhc05hdkZvciAhPT0gbnVsbCAmJiB0eXBlb2YgYXNOYXZGb3IgPT09ICdvYmplY3QnICkge1xuICAgICAgICAgICAgYXNOYXZGb3IuZWFjaChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB2YXIgdGFyZ2V0ID0gJCh0aGlzKS5zbGljaygnZ2V0U2xpY2snKTtcbiAgICAgICAgICAgICAgICBpZighdGFyZ2V0LnVuc2xpY2tlZCkge1xuICAgICAgICAgICAgICAgICAgICB0YXJnZXQuc2xpZGVIYW5kbGVyKGluZGV4LCB0cnVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgfTtcblxuICAgIFNsaWNrLnByb3RvdHlwZS5hcHBseVRyYW5zaXRpb24gPSBmdW5jdGlvbihzbGlkZSkge1xuXG4gICAgICAgIHZhciBfID0gdGhpcyxcbiAgICAgICAgICAgIHRyYW5zaXRpb24gPSB7fTtcblxuICAgICAgICBpZiAoXy5vcHRpb25zLmZhZGUgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICB0cmFuc2l0aW9uW18udHJhbnNpdGlvblR5cGVdID0gXy50cmFuc2Zvcm1UeXBlICsgJyAnICsgXy5vcHRpb25zLnNwZWVkICsgJ21zICcgKyBfLm9wdGlvbnMuY3NzRWFzZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRyYW5zaXRpb25bXy50cmFuc2l0aW9uVHlwZV0gPSAnb3BhY2l0eSAnICsgXy5vcHRpb25zLnNwZWVkICsgJ21zICcgKyBfLm9wdGlvbnMuY3NzRWFzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChfLm9wdGlvbnMuZmFkZSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIF8uJHNsaWRlVHJhY2suY3NzKHRyYW5zaXRpb24pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgXy4kc2xpZGVzLmVxKHNsaWRlKS5jc3ModHJhbnNpdGlvbik7XG4gICAgICAgIH1cblxuICAgIH07XG5cbiAgICBTbGljay5wcm90b3R5cGUuYXV0b1BsYXkgPSBmdW5jdGlvbigpIHtcblxuICAgICAgICB2YXIgXyA9IHRoaXM7XG5cbiAgICAgICAgXy5hdXRvUGxheUNsZWFyKCk7XG5cbiAgICAgICAgaWYgKCBfLnNsaWRlQ291bnQgPiBfLm9wdGlvbnMuc2xpZGVzVG9TaG93ICkge1xuICAgICAgICAgICAgXy5hdXRvUGxheVRpbWVyID0gc2V0SW50ZXJ2YWwoIF8uYXV0b1BsYXlJdGVyYXRvciwgXy5vcHRpb25zLmF1dG9wbGF5U3BlZWQgKTtcbiAgICAgICAgfVxuXG4gICAgfTtcblxuICAgIFNsaWNrLnByb3RvdHlwZS5hdXRvUGxheUNsZWFyID0gZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdmFyIF8gPSB0aGlzO1xuXG4gICAgICAgIGlmIChfLmF1dG9QbGF5VGltZXIpIHtcbiAgICAgICAgICAgIGNsZWFySW50ZXJ2YWwoXy5hdXRvUGxheVRpbWVyKTtcbiAgICAgICAgfVxuXG4gICAgfTtcblxuICAgIFNsaWNrLnByb3RvdHlwZS5hdXRvUGxheUl0ZXJhdG9yID0gZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdmFyIF8gPSB0aGlzLFxuICAgICAgICAgICAgc2xpZGVUbyA9IF8uY3VycmVudFNsaWRlICsgXy5vcHRpb25zLnNsaWRlc1RvU2Nyb2xsO1xuXG4gICAgICAgIGlmICggIV8ucGF1c2VkICYmICFfLmludGVycnVwdGVkICYmICFfLmZvY3Vzc2VkICkge1xuXG4gICAgICAgICAgICBpZiAoIF8ub3B0aW9ucy5pbmZpbml0ZSA9PT0gZmFsc2UgKSB7XG5cbiAgICAgICAgICAgICAgICBpZiAoIF8uZGlyZWN0aW9uID09PSAxICYmICggXy5jdXJyZW50U2xpZGUgKyAxICkgPT09ICggXy5zbGlkZUNvdW50IC0gMSApKSB7XG4gICAgICAgICAgICAgICAgICAgIF8uZGlyZWN0aW9uID0gMDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBlbHNlIGlmICggXy5kaXJlY3Rpb24gPT09IDAgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgc2xpZGVUbyA9IF8uY3VycmVudFNsaWRlIC0gXy5vcHRpb25zLnNsaWRlc1RvU2Nyb2xsO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICggXy5jdXJyZW50U2xpZGUgLSAxID09PSAwICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgXy5kaXJlY3Rpb24gPSAxO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgXy5zbGlkZUhhbmRsZXIoIHNsaWRlVG8gKTtcblxuICAgICAgICB9XG5cbiAgICB9O1xuXG4gICAgU2xpY2sucHJvdG90eXBlLmJ1aWxkQXJyb3dzID0gZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdmFyIF8gPSB0aGlzO1xuXG4gICAgICAgIGlmIChfLm9wdGlvbnMuYXJyb3dzID09PSB0cnVlICkge1xuXG4gICAgICAgICAgICBfLiRwcmV2QXJyb3cgPSAkKF8ub3B0aW9ucy5wcmV2QXJyb3cpLmFkZENsYXNzKCdzbGljay1hcnJvdycpO1xuICAgICAgICAgICAgXy4kbmV4dEFycm93ID0gJChfLm9wdGlvbnMubmV4dEFycm93KS5hZGRDbGFzcygnc2xpY2stYXJyb3cnKTtcblxuICAgICAgICAgICAgaWYoIF8uc2xpZGVDb3VudCA+IF8ub3B0aW9ucy5zbGlkZXNUb1Nob3cgKSB7XG5cbiAgICAgICAgICAgICAgICBfLiRwcmV2QXJyb3cucmVtb3ZlQ2xhc3MoJ3NsaWNrLWhpZGRlbicpLnJlbW92ZUF0dHIoJ2FyaWEtaGlkZGVuIHRhYmluZGV4Jyk7XG4gICAgICAgICAgICAgICAgXy4kbmV4dEFycm93LnJlbW92ZUNsYXNzKCdzbGljay1oaWRkZW4nKS5yZW1vdmVBdHRyKCdhcmlhLWhpZGRlbiB0YWJpbmRleCcpO1xuXG4gICAgICAgICAgICAgICAgaWYgKF8uaHRtbEV4cHIudGVzdChfLm9wdGlvbnMucHJldkFycm93KSkge1xuICAgICAgICAgICAgICAgICAgICBfLiRwcmV2QXJyb3cucHJlcGVuZFRvKF8ub3B0aW9ucy5hcHBlbmRBcnJvd3MpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChfLmh0bWxFeHByLnRlc3QoXy5vcHRpb25zLm5leHRBcnJvdykpIHtcbiAgICAgICAgICAgICAgICAgICAgXy4kbmV4dEFycm93LmFwcGVuZFRvKF8ub3B0aW9ucy5hcHBlbmRBcnJvd3MpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChfLm9wdGlvbnMuaW5maW5pdGUgIT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgXy4kcHJldkFycm93XG4gICAgICAgICAgICAgICAgICAgICAgICAuYWRkQ2xhc3MoJ3NsaWNrLWRpc2FibGVkJylcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKCdhcmlhLWRpc2FibGVkJywgJ3RydWUnKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgICAgICBfLiRwcmV2QXJyb3cuYWRkKCBfLiRuZXh0QXJyb3cgKVxuXG4gICAgICAgICAgICAgICAgICAgIC5hZGRDbGFzcygnc2xpY2staGlkZGVuJylcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoe1xuICAgICAgICAgICAgICAgICAgICAgICAgJ2FyaWEtZGlzYWJsZWQnOiAndHJ1ZScsXG4gICAgICAgICAgICAgICAgICAgICAgICAndGFiaW5kZXgnOiAnLTEnXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgfTtcblxuICAgIFNsaWNrLnByb3RvdHlwZS5idWlsZERvdHMgPSBmdW5jdGlvbigpIHtcblxuICAgICAgICB2YXIgXyA9IHRoaXMsXG4gICAgICAgICAgICBpLCBkb3Q7XG5cbiAgICAgICAgaWYgKF8ub3B0aW9ucy5kb3RzID09PSB0cnVlICYmIF8uc2xpZGVDb3VudCA+IF8ub3B0aW9ucy5zbGlkZXNUb1Nob3cpIHtcblxuICAgICAgICAgICAgXy4kc2xpZGVyLmFkZENsYXNzKCdzbGljay1kb3R0ZWQnKTtcblxuICAgICAgICAgICAgZG90ID0gJCgnPHVsIC8+JykuYWRkQ2xhc3MoXy5vcHRpb25zLmRvdHNDbGFzcyk7XG5cbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPD0gXy5nZXREb3RDb3VudCgpOyBpICs9IDEpIHtcbiAgICAgICAgICAgICAgICBkb3QuYXBwZW5kKCQoJzxsaSAvPicpLmFwcGVuZChfLm9wdGlvbnMuY3VzdG9tUGFnaW5nLmNhbGwodGhpcywgXywgaSkpKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgXy4kZG90cyA9IGRvdC5hcHBlbmRUbyhfLm9wdGlvbnMuYXBwZW5kRG90cyk7XG5cbiAgICAgICAgICAgIF8uJGRvdHMuZmluZCgnbGknKS5maXJzdCgpLmFkZENsYXNzKCdzbGljay1hY3RpdmUnKTtcblxuICAgICAgICB9XG5cbiAgICB9O1xuXG4gICAgU2xpY2sucHJvdG90eXBlLmJ1aWxkT3V0ID0gZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdmFyIF8gPSB0aGlzO1xuXG4gICAgICAgIF8uJHNsaWRlcyA9XG4gICAgICAgICAgICBfLiRzbGlkZXJcbiAgICAgICAgICAgICAgICAuY2hpbGRyZW4oIF8ub3B0aW9ucy5zbGlkZSArICc6bm90KC5zbGljay1jbG9uZWQpJylcbiAgICAgICAgICAgICAgICAuYWRkQ2xhc3MoJ3NsaWNrLXNsaWRlJyk7XG5cbiAgICAgICAgXy5zbGlkZUNvdW50ID0gXy4kc2xpZGVzLmxlbmd0aDtcblxuICAgICAgICBfLiRzbGlkZXMuZWFjaChmdW5jdGlvbihpbmRleCwgZWxlbWVudCkge1xuICAgICAgICAgICAgJChlbGVtZW50KVxuICAgICAgICAgICAgICAgIC5hdHRyKCdkYXRhLXNsaWNrLWluZGV4JywgaW5kZXgpXG4gICAgICAgICAgICAgICAgLmRhdGEoJ29yaWdpbmFsU3R5bGluZycsICQoZWxlbWVudCkuYXR0cignc3R5bGUnKSB8fCAnJyk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIF8uJHNsaWRlci5hZGRDbGFzcygnc2xpY2stc2xpZGVyJyk7XG5cbiAgICAgICAgXy4kc2xpZGVUcmFjayA9IChfLnNsaWRlQ291bnQgPT09IDApID9cbiAgICAgICAgICAgICQoJzxkaXYgY2xhc3M9XCJzbGljay10cmFja1wiLz4nKS5hcHBlbmRUbyhfLiRzbGlkZXIpIDpcbiAgICAgICAgICAgIF8uJHNsaWRlcy53cmFwQWxsKCc8ZGl2IGNsYXNzPVwic2xpY2stdHJhY2tcIi8+JykucGFyZW50KCk7XG5cbiAgICAgICAgXy4kbGlzdCA9IF8uJHNsaWRlVHJhY2sud3JhcChcbiAgICAgICAgICAgICc8ZGl2IGNsYXNzPVwic2xpY2stbGlzdFwiLz4nKS5wYXJlbnQoKTtcbiAgICAgICAgXy4kc2xpZGVUcmFjay5jc3MoJ29wYWNpdHknLCAwKTtcblxuICAgICAgICBpZiAoXy5vcHRpb25zLmNlbnRlck1vZGUgPT09IHRydWUgfHwgXy5vcHRpb25zLnN3aXBlVG9TbGlkZSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgXy5vcHRpb25zLnNsaWRlc1RvU2Nyb2xsID0gMTtcbiAgICAgICAgfVxuXG4gICAgICAgICQoJ2ltZ1tkYXRhLWxhenldJywgXy4kc2xpZGVyKS5ub3QoJ1tzcmNdJykuYWRkQ2xhc3MoJ3NsaWNrLWxvYWRpbmcnKTtcblxuICAgICAgICBfLnNldHVwSW5maW5pdGUoKTtcblxuICAgICAgICBfLmJ1aWxkQXJyb3dzKCk7XG5cbiAgICAgICAgXy5idWlsZERvdHMoKTtcblxuICAgICAgICBfLnVwZGF0ZURvdHMoKTtcblxuXG4gICAgICAgIF8uc2V0U2xpZGVDbGFzc2VzKHR5cGVvZiBfLmN1cnJlbnRTbGlkZSA9PT0gJ251bWJlcicgPyBfLmN1cnJlbnRTbGlkZSA6IDApO1xuXG4gICAgICAgIGlmIChfLm9wdGlvbnMuZHJhZ2dhYmxlID09PSB0cnVlKSB7XG4gICAgICAgICAgICBfLiRsaXN0LmFkZENsYXNzKCdkcmFnZ2FibGUnKTtcbiAgICAgICAgfVxuXG4gICAgfTtcblxuICAgIFNsaWNrLnByb3RvdHlwZS5idWlsZFJvd3MgPSBmdW5jdGlvbigpIHtcblxuICAgICAgICB2YXIgXyA9IHRoaXMsIGEsIGIsIGMsIG5ld1NsaWRlcywgbnVtT2ZTbGlkZXMsIG9yaWdpbmFsU2xpZGVzLHNsaWRlc1BlclNlY3Rpb247XG5cbiAgICAgICAgbmV3U2xpZGVzID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO1xuICAgICAgICBvcmlnaW5hbFNsaWRlcyA9IF8uJHNsaWRlci5jaGlsZHJlbigpO1xuXG4gICAgICAgIGlmKF8ub3B0aW9ucy5yb3dzID4gMCkge1xuXG4gICAgICAgICAgICBzbGlkZXNQZXJTZWN0aW9uID0gXy5vcHRpb25zLnNsaWRlc1BlclJvdyAqIF8ub3B0aW9ucy5yb3dzO1xuICAgICAgICAgICAgbnVtT2ZTbGlkZXMgPSBNYXRoLmNlaWwoXG4gICAgICAgICAgICAgICAgb3JpZ2luYWxTbGlkZXMubGVuZ3RoIC8gc2xpZGVzUGVyU2VjdGlvblxuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgZm9yKGEgPSAwOyBhIDwgbnVtT2ZTbGlkZXM7IGErKyl7XG4gICAgICAgICAgICAgICAgdmFyIHNsaWRlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgICAgICAgICAgZm9yKGIgPSAwOyBiIDwgXy5vcHRpb25zLnJvd3M7IGIrKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcm93ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgICAgICAgICAgICAgIGZvcihjID0gMDsgYyA8IF8ub3B0aW9ucy5zbGlkZXNQZXJSb3c7IGMrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRhcmdldCA9IChhICogc2xpZGVzUGVyU2VjdGlvbiArICgoYiAqIF8ub3B0aW9ucy5zbGlkZXNQZXJSb3cpICsgYykpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9yaWdpbmFsU2xpZGVzLmdldCh0YXJnZXQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcm93LmFwcGVuZENoaWxkKG9yaWdpbmFsU2xpZGVzLmdldCh0YXJnZXQpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBzbGlkZS5hcHBlbmRDaGlsZChyb3cpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBuZXdTbGlkZXMuYXBwZW5kQ2hpbGQoc2xpZGUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBfLiRzbGlkZXIuZW1wdHkoKS5hcHBlbmQobmV3U2xpZGVzKTtcbiAgICAgICAgICAgIF8uJHNsaWRlci5jaGlsZHJlbigpLmNoaWxkcmVuKCkuY2hpbGRyZW4oKVxuICAgICAgICAgICAgICAgIC5jc3Moe1xuICAgICAgICAgICAgICAgICAgICAnd2lkdGgnOigxMDAgLyBfLm9wdGlvbnMuc2xpZGVzUGVyUm93KSArICclJyxcbiAgICAgICAgICAgICAgICAgICAgJ2Rpc3BsYXknOiAnaW5saW5lLWJsb2NrJ1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgIH1cblxuICAgIH07XG5cbiAgICBTbGljay5wcm90b3R5cGUuY2hlY2tSZXNwb25zaXZlID0gZnVuY3Rpb24oaW5pdGlhbCwgZm9yY2VVcGRhdGUpIHtcblxuICAgICAgICB2YXIgXyA9IHRoaXMsXG4gICAgICAgICAgICBicmVha3BvaW50LCB0YXJnZXRCcmVha3BvaW50LCByZXNwb25kVG9XaWR0aCwgdHJpZ2dlckJyZWFrcG9pbnQgPSBmYWxzZTtcbiAgICAgICAgdmFyIHNsaWRlcldpZHRoID0gXy4kc2xpZGVyLndpZHRoKCk7XG4gICAgICAgIHZhciB3aW5kb3dXaWR0aCA9IHdpbmRvdy5pbm5lcldpZHRoIHx8ICQod2luZG93KS53aWR0aCgpO1xuXG4gICAgICAgIGlmIChfLnJlc3BvbmRUbyA9PT0gJ3dpbmRvdycpIHtcbiAgICAgICAgICAgIHJlc3BvbmRUb1dpZHRoID0gd2luZG93V2lkdGg7XG4gICAgICAgIH0gZWxzZSBpZiAoXy5yZXNwb25kVG8gPT09ICdzbGlkZXInKSB7XG4gICAgICAgICAgICByZXNwb25kVG9XaWR0aCA9IHNsaWRlcldpZHRoO1xuICAgICAgICB9IGVsc2UgaWYgKF8ucmVzcG9uZFRvID09PSAnbWluJykge1xuICAgICAgICAgICAgcmVzcG9uZFRvV2lkdGggPSBNYXRoLm1pbih3aW5kb3dXaWR0aCwgc2xpZGVyV2lkdGgpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCBfLm9wdGlvbnMucmVzcG9uc2l2ZSAmJlxuICAgICAgICAgICAgXy5vcHRpb25zLnJlc3BvbnNpdmUubGVuZ3RoICYmXG4gICAgICAgICAgICBfLm9wdGlvbnMucmVzcG9uc2l2ZSAhPT0gbnVsbCkge1xuXG4gICAgICAgICAgICB0YXJnZXRCcmVha3BvaW50ID0gbnVsbDtcblxuICAgICAgICAgICAgZm9yIChicmVha3BvaW50IGluIF8uYnJlYWtwb2ludHMpIHtcbiAgICAgICAgICAgICAgICBpZiAoXy5icmVha3BvaW50cy5oYXNPd25Qcm9wZXJ0eShicmVha3BvaW50KSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoXy5vcmlnaW5hbFNldHRpbmdzLm1vYmlsZUZpcnN0ID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3BvbmRUb1dpZHRoIDwgXy5icmVha3BvaW50c1ticmVha3BvaW50XSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldEJyZWFrcG9pbnQgPSBfLmJyZWFrcG9pbnRzW2JyZWFrcG9pbnRdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3BvbmRUb1dpZHRoID4gXy5icmVha3BvaW50c1ticmVha3BvaW50XSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldEJyZWFrcG9pbnQgPSBfLmJyZWFrcG9pbnRzW2JyZWFrcG9pbnRdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodGFyZ2V0QnJlYWtwb2ludCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGlmIChfLmFjdGl2ZUJyZWFrcG9pbnQgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRhcmdldEJyZWFrcG9pbnQgIT09IF8uYWN0aXZlQnJlYWtwb2ludCB8fCBmb3JjZVVwZGF0ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgXy5hY3RpdmVCcmVha3BvaW50ID1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXRCcmVha3BvaW50O1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF8uYnJlYWtwb2ludFNldHRpbmdzW3RhcmdldEJyZWFrcG9pbnRdID09PSAndW5zbGljaycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfLnVuc2xpY2sodGFyZ2V0QnJlYWtwb2ludCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF8ub3B0aW9ucyA9ICQuZXh0ZW5kKHt9LCBfLm9yaWdpbmFsU2V0dGluZ3MsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF8uYnJlYWtwb2ludFNldHRpbmdzW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0QnJlYWtwb2ludF0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbml0aWFsID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF8uY3VycmVudFNsaWRlID0gXy5vcHRpb25zLmluaXRpYWxTbGlkZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXy5yZWZyZXNoKGluaXRpYWwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgdHJpZ2dlckJyZWFrcG9pbnQgPSB0YXJnZXRCcmVha3BvaW50O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgXy5hY3RpdmVCcmVha3BvaW50ID0gdGFyZ2V0QnJlYWtwb2ludDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKF8uYnJlYWtwb2ludFNldHRpbmdzW3RhcmdldEJyZWFrcG9pbnRdID09PSAndW5zbGljaycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF8udW5zbGljayh0YXJnZXRCcmVha3BvaW50KTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF8ub3B0aW9ucyA9ICQuZXh0ZW5kKHt9LCBfLm9yaWdpbmFsU2V0dGluZ3MsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXy5icmVha3BvaW50U2V0dGluZ3NbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldEJyZWFrcG9pbnRdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbml0aWFsID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXy5jdXJyZW50U2xpZGUgPSBfLm9wdGlvbnMuaW5pdGlhbFNsaWRlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgXy5yZWZyZXNoKGluaXRpYWwpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRyaWdnZXJCcmVha3BvaW50ID0gdGFyZ2V0QnJlYWtwb2ludDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChfLmFjdGl2ZUJyZWFrcG9pbnQgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgXy5hY3RpdmVCcmVha3BvaW50ID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgXy5vcHRpb25zID0gXy5vcmlnaW5hbFNldHRpbmdzO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaW5pdGlhbCA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgXy5jdXJyZW50U2xpZGUgPSBfLm9wdGlvbnMuaW5pdGlhbFNsaWRlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIF8ucmVmcmVzaChpbml0aWFsKTtcbiAgICAgICAgICAgICAgICAgICAgdHJpZ2dlckJyZWFrcG9pbnQgPSB0YXJnZXRCcmVha3BvaW50O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gb25seSB0cmlnZ2VyIGJyZWFrcG9pbnRzIGR1cmluZyBhbiBhY3R1YWwgYnJlYWsuIG5vdCBvbiBpbml0aWFsaXplLlxuICAgICAgICAgICAgaWYoICFpbml0aWFsICYmIHRyaWdnZXJCcmVha3BvaW50ICE9PSBmYWxzZSApIHtcbiAgICAgICAgICAgICAgICBfLiRzbGlkZXIudHJpZ2dlcignYnJlYWtwb2ludCcsIFtfLCB0cmlnZ2VyQnJlYWtwb2ludF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICB9O1xuXG4gICAgU2xpY2sucHJvdG90eXBlLmNoYW5nZVNsaWRlID0gZnVuY3Rpb24oZXZlbnQsIGRvbnRBbmltYXRlKSB7XG5cbiAgICAgICAgdmFyIF8gPSB0aGlzLFxuICAgICAgICAgICAgJHRhcmdldCA9ICQoZXZlbnQuY3VycmVudFRhcmdldCksXG4gICAgICAgICAgICBpbmRleE9mZnNldCwgc2xpZGVPZmZzZXQsIHVuZXZlbk9mZnNldDtcblxuICAgICAgICAvLyBJZiB0YXJnZXQgaXMgYSBsaW5rLCBwcmV2ZW50IGRlZmF1bHQgYWN0aW9uLlxuICAgICAgICBpZigkdGFyZ2V0LmlzKCdhJykpIHtcbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJZiB0YXJnZXQgaXMgbm90IHRoZSA8bGk+IGVsZW1lbnQgKGllOiBhIGNoaWxkKSwgZmluZCB0aGUgPGxpPi5cbiAgICAgICAgaWYoISR0YXJnZXQuaXMoJ2xpJykpIHtcbiAgICAgICAgICAgICR0YXJnZXQgPSAkdGFyZ2V0LmNsb3Nlc3QoJ2xpJyk7XG4gICAgICAgIH1cblxuICAgICAgICB1bmV2ZW5PZmZzZXQgPSAoXy5zbGlkZUNvdW50ICUgXy5vcHRpb25zLnNsaWRlc1RvU2Nyb2xsICE9PSAwKTtcbiAgICAgICAgaW5kZXhPZmZzZXQgPSB1bmV2ZW5PZmZzZXQgPyAwIDogKF8uc2xpZGVDb3VudCAtIF8uY3VycmVudFNsaWRlKSAlIF8ub3B0aW9ucy5zbGlkZXNUb1Njcm9sbDtcblxuICAgICAgICBzd2l0Y2ggKGV2ZW50LmRhdGEubWVzc2FnZSkge1xuXG4gICAgICAgICAgICBjYXNlICdwcmV2aW91cyc6XG4gICAgICAgICAgICAgICAgc2xpZGVPZmZzZXQgPSBpbmRleE9mZnNldCA9PT0gMCA/IF8ub3B0aW9ucy5zbGlkZXNUb1Njcm9sbCA6IF8ub3B0aW9ucy5zbGlkZXNUb1Nob3cgLSBpbmRleE9mZnNldDtcbiAgICAgICAgICAgICAgICBpZiAoXy5zbGlkZUNvdW50ID4gXy5vcHRpb25zLnNsaWRlc1RvU2hvdykge1xuICAgICAgICAgICAgICAgICAgICBfLnNsaWRlSGFuZGxlcihfLmN1cnJlbnRTbGlkZSAtIHNsaWRlT2Zmc2V0LCBmYWxzZSwgZG9udEFuaW1hdGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSAnbmV4dCc6XG4gICAgICAgICAgICAgICAgc2xpZGVPZmZzZXQgPSBpbmRleE9mZnNldCA9PT0gMCA/IF8ub3B0aW9ucy5zbGlkZXNUb1Njcm9sbCA6IGluZGV4T2Zmc2V0O1xuICAgICAgICAgICAgICAgIGlmIChfLnNsaWRlQ291bnQgPiBfLm9wdGlvbnMuc2xpZGVzVG9TaG93KSB7XG4gICAgICAgICAgICAgICAgICAgIF8uc2xpZGVIYW5kbGVyKF8uY3VycmVudFNsaWRlICsgc2xpZGVPZmZzZXQsIGZhbHNlLCBkb250QW5pbWF0ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlICdpbmRleCc6XG4gICAgICAgICAgICAgICAgdmFyIGluZGV4ID0gZXZlbnQuZGF0YS5pbmRleCA9PT0gMCA/IDAgOlxuICAgICAgICAgICAgICAgICAgICBldmVudC5kYXRhLmluZGV4IHx8ICR0YXJnZXQuaW5kZXgoKSAqIF8ub3B0aW9ucy5zbGlkZXNUb1Njcm9sbDtcblxuICAgICAgICAgICAgICAgIF8uc2xpZGVIYW5kbGVyKF8uY2hlY2tOYXZpZ2FibGUoaW5kZXgpLCBmYWxzZSwgZG9udEFuaW1hdGUpO1xuICAgICAgICAgICAgICAgICR0YXJnZXQuY2hpbGRyZW4oKS50cmlnZ2VyKCdmb2N1cycpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgfTtcblxuICAgIFNsaWNrLnByb3RvdHlwZS5jaGVja05hdmlnYWJsZSA9IGZ1bmN0aW9uKGluZGV4KSB7XG5cbiAgICAgICAgdmFyIF8gPSB0aGlzLFxuICAgICAgICAgICAgbmF2aWdhYmxlcywgcHJldk5hdmlnYWJsZTtcblxuICAgICAgICBuYXZpZ2FibGVzID0gXy5nZXROYXZpZ2FibGVJbmRleGVzKCk7XG4gICAgICAgIHByZXZOYXZpZ2FibGUgPSAwO1xuICAgICAgICBpZiAoaW5kZXggPiBuYXZpZ2FibGVzW25hdmlnYWJsZXMubGVuZ3RoIC0gMV0pIHtcbiAgICAgICAgICAgIGluZGV4ID0gbmF2aWdhYmxlc1tuYXZpZ2FibGVzLmxlbmd0aCAtIDFdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZm9yICh2YXIgbiBpbiBuYXZpZ2FibGVzKSB7XG4gICAgICAgICAgICAgICAgaWYgKGluZGV4IDwgbmF2aWdhYmxlc1tuXSkge1xuICAgICAgICAgICAgICAgICAgICBpbmRleCA9IHByZXZOYXZpZ2FibGU7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBwcmV2TmF2aWdhYmxlID0gbmF2aWdhYmxlc1tuXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBpbmRleDtcbiAgICB9O1xuXG4gICAgU2xpY2sucHJvdG90eXBlLmNsZWFuVXBFdmVudHMgPSBmdW5jdGlvbigpIHtcblxuICAgICAgICB2YXIgXyA9IHRoaXM7XG5cbiAgICAgICAgaWYgKF8ub3B0aW9ucy5kb3RzICYmIF8uJGRvdHMgIT09IG51bGwpIHtcblxuICAgICAgICAgICAgJCgnbGknLCBfLiRkb3RzKVxuICAgICAgICAgICAgICAgIC5vZmYoJ2NsaWNrLnNsaWNrJywgXy5jaGFuZ2VTbGlkZSlcbiAgICAgICAgICAgICAgICAub2ZmKCdtb3VzZWVudGVyLnNsaWNrJywgJC5wcm94eShfLmludGVycnVwdCwgXywgdHJ1ZSkpXG4gICAgICAgICAgICAgICAgLm9mZignbW91c2VsZWF2ZS5zbGljaycsICQucHJveHkoXy5pbnRlcnJ1cHQsIF8sIGZhbHNlKSk7XG5cbiAgICAgICAgICAgIGlmIChfLm9wdGlvbnMuYWNjZXNzaWJpbGl0eSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgIF8uJGRvdHMub2ZmKCdrZXlkb3duLnNsaWNrJywgXy5rZXlIYW5kbGVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIF8uJHNsaWRlci5vZmYoJ2ZvY3VzLnNsaWNrIGJsdXIuc2xpY2snKTtcblxuICAgICAgICBpZiAoXy5vcHRpb25zLmFycm93cyA9PT0gdHJ1ZSAmJiBfLnNsaWRlQ291bnQgPiBfLm9wdGlvbnMuc2xpZGVzVG9TaG93KSB7XG4gICAgICAgICAgICBfLiRwcmV2QXJyb3cgJiYgXy4kcHJldkFycm93Lm9mZignY2xpY2suc2xpY2snLCBfLmNoYW5nZVNsaWRlKTtcbiAgICAgICAgICAgIF8uJG5leHRBcnJvdyAmJiBfLiRuZXh0QXJyb3cub2ZmKCdjbGljay5zbGljaycsIF8uY2hhbmdlU2xpZGUpO1xuXG4gICAgICAgICAgICBpZiAoXy5vcHRpb25zLmFjY2Vzc2liaWxpdHkgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICBfLiRwcmV2QXJyb3cgJiYgXy4kcHJldkFycm93Lm9mZigna2V5ZG93bi5zbGljaycsIF8ua2V5SGFuZGxlcik7XG4gICAgICAgICAgICAgICAgXy4kbmV4dEFycm93ICYmIF8uJG5leHRBcnJvdy5vZmYoJ2tleWRvd24uc2xpY2snLCBfLmtleUhhbmRsZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgXy4kbGlzdC5vZmYoJ3RvdWNoc3RhcnQuc2xpY2sgbW91c2Vkb3duLnNsaWNrJywgXy5zd2lwZUhhbmRsZXIpO1xuICAgICAgICBfLiRsaXN0Lm9mZigndG91Y2htb3ZlLnNsaWNrIG1vdXNlbW92ZS5zbGljaycsIF8uc3dpcGVIYW5kbGVyKTtcbiAgICAgICAgXy4kbGlzdC5vZmYoJ3RvdWNoZW5kLnNsaWNrIG1vdXNldXAuc2xpY2snLCBfLnN3aXBlSGFuZGxlcik7XG4gICAgICAgIF8uJGxpc3Qub2ZmKCd0b3VjaGNhbmNlbC5zbGljayBtb3VzZWxlYXZlLnNsaWNrJywgXy5zd2lwZUhhbmRsZXIpO1xuXG4gICAgICAgIF8uJGxpc3Qub2ZmKCdjbGljay5zbGljaycsIF8uY2xpY2tIYW5kbGVyKTtcblxuICAgICAgICAkKGRvY3VtZW50KS5vZmYoXy52aXNpYmlsaXR5Q2hhbmdlLCBfLnZpc2liaWxpdHkpO1xuXG4gICAgICAgIF8uY2xlYW5VcFNsaWRlRXZlbnRzKCk7XG5cbiAgICAgICAgaWYgKF8ub3B0aW9ucy5hY2Nlc3NpYmlsaXR5ID09PSB0cnVlKSB7XG4gICAgICAgICAgICBfLiRsaXN0Lm9mZigna2V5ZG93bi5zbGljaycsIF8ua2V5SGFuZGxlcik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoXy5vcHRpb25zLmZvY3VzT25TZWxlY3QgPT09IHRydWUpIHtcbiAgICAgICAgICAgICQoXy4kc2xpZGVUcmFjaykuY2hpbGRyZW4oKS5vZmYoJ2NsaWNrLnNsaWNrJywgXy5zZWxlY3RIYW5kbGVyKTtcbiAgICAgICAgfVxuXG4gICAgICAgICQod2luZG93KS5vZmYoJ29yaWVudGF0aW9uY2hhbmdlLnNsaWNrLnNsaWNrLScgKyBfLmluc3RhbmNlVWlkLCBfLm9yaWVudGF0aW9uQ2hhbmdlKTtcblxuICAgICAgICAkKHdpbmRvdykub2ZmKCdyZXNpemUuc2xpY2suc2xpY2stJyArIF8uaW5zdGFuY2VVaWQsIF8ucmVzaXplKTtcblxuICAgICAgICAkKCdbZHJhZ2dhYmxlIT10cnVlXScsIF8uJHNsaWRlVHJhY2spLm9mZignZHJhZ3N0YXJ0JywgXy5wcmV2ZW50RGVmYXVsdCk7XG5cbiAgICAgICAgJCh3aW5kb3cpLm9mZignbG9hZC5zbGljay5zbGljay0nICsgXy5pbnN0YW5jZVVpZCwgXy5zZXRQb3NpdGlvbik7XG5cbiAgICB9O1xuXG4gICAgU2xpY2sucHJvdG90eXBlLmNsZWFuVXBTbGlkZUV2ZW50cyA9IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHZhciBfID0gdGhpcztcblxuICAgICAgICBfLiRsaXN0Lm9mZignbW91c2VlbnRlci5zbGljaycsICQucHJveHkoXy5pbnRlcnJ1cHQsIF8sIHRydWUpKTtcbiAgICAgICAgXy4kbGlzdC5vZmYoJ21vdXNlbGVhdmUuc2xpY2snLCAkLnByb3h5KF8uaW50ZXJydXB0LCBfLCBmYWxzZSkpO1xuXG4gICAgfTtcblxuICAgIFNsaWNrLnByb3RvdHlwZS5jbGVhblVwUm93cyA9IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHZhciBfID0gdGhpcywgb3JpZ2luYWxTbGlkZXM7XG5cbiAgICAgICAgaWYoXy5vcHRpb25zLnJvd3MgPiAwKSB7XG4gICAgICAgICAgICBvcmlnaW5hbFNsaWRlcyA9IF8uJHNsaWRlcy5jaGlsZHJlbigpLmNoaWxkcmVuKCk7XG4gICAgICAgICAgICBvcmlnaW5hbFNsaWRlcy5yZW1vdmVBdHRyKCdzdHlsZScpO1xuICAgICAgICAgICAgXy4kc2xpZGVyLmVtcHR5KCkuYXBwZW5kKG9yaWdpbmFsU2xpZGVzKTtcbiAgICAgICAgfVxuXG4gICAgfTtcblxuICAgIFNsaWNrLnByb3RvdHlwZS5jbGlja0hhbmRsZXIgPSBmdW5jdGlvbihldmVudCkge1xuXG4gICAgICAgIHZhciBfID0gdGhpcztcblxuICAgICAgICBpZiAoXy5zaG91bGRDbGljayA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIGV2ZW50LnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB9XG5cbiAgICB9O1xuXG4gICAgU2xpY2sucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbihyZWZyZXNoKSB7XG5cbiAgICAgICAgdmFyIF8gPSB0aGlzO1xuXG4gICAgICAgIF8uYXV0b1BsYXlDbGVhcigpO1xuXG4gICAgICAgIF8udG91Y2hPYmplY3QgPSB7fTtcblxuICAgICAgICBfLmNsZWFuVXBFdmVudHMoKTtcblxuICAgICAgICAkKCcuc2xpY2stY2xvbmVkJywgXy4kc2xpZGVyKS5kZXRhY2goKTtcblxuICAgICAgICBpZiAoXy4kZG90cykge1xuICAgICAgICAgICAgXy4kZG90cy5yZW1vdmUoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICggXy4kcHJldkFycm93ICYmIF8uJHByZXZBcnJvdy5sZW5ndGggKSB7XG5cbiAgICAgICAgICAgIF8uJHByZXZBcnJvd1xuICAgICAgICAgICAgICAgIC5yZW1vdmVDbGFzcygnc2xpY2stZGlzYWJsZWQgc2xpY2stYXJyb3cgc2xpY2staGlkZGVuJylcbiAgICAgICAgICAgICAgICAucmVtb3ZlQXR0cignYXJpYS1oaWRkZW4gYXJpYS1kaXNhYmxlZCB0YWJpbmRleCcpXG4gICAgICAgICAgICAgICAgLmNzcygnZGlzcGxheScsJycpO1xuXG4gICAgICAgICAgICBpZiAoIF8uaHRtbEV4cHIudGVzdCggXy5vcHRpb25zLnByZXZBcnJvdyApKSB7XG4gICAgICAgICAgICAgICAgXy4kcHJldkFycm93LnJlbW92ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCBfLiRuZXh0QXJyb3cgJiYgXy4kbmV4dEFycm93Lmxlbmd0aCApIHtcblxuICAgICAgICAgICAgXy4kbmV4dEFycm93XG4gICAgICAgICAgICAgICAgLnJlbW92ZUNsYXNzKCdzbGljay1kaXNhYmxlZCBzbGljay1hcnJvdyBzbGljay1oaWRkZW4nKVxuICAgICAgICAgICAgICAgIC5yZW1vdmVBdHRyKCdhcmlhLWhpZGRlbiBhcmlhLWRpc2FibGVkIHRhYmluZGV4JylcbiAgICAgICAgICAgICAgICAuY3NzKCdkaXNwbGF5JywnJyk7XG5cbiAgICAgICAgICAgIGlmICggXy5odG1sRXhwci50ZXN0KCBfLm9wdGlvbnMubmV4dEFycm93ICkpIHtcbiAgICAgICAgICAgICAgICBfLiRuZXh0QXJyb3cucmVtb3ZlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuXG4gICAgICAgIGlmIChfLiRzbGlkZXMpIHtcblxuICAgICAgICAgICAgXy4kc2xpZGVzXG4gICAgICAgICAgICAgICAgLnJlbW92ZUNsYXNzKCdzbGljay1zbGlkZSBzbGljay1hY3RpdmUgc2xpY2stY2VudGVyIHNsaWNrLXZpc2libGUgc2xpY2stY3VycmVudCcpXG4gICAgICAgICAgICAgICAgLnJlbW92ZUF0dHIoJ2FyaWEtaGlkZGVuJylcbiAgICAgICAgICAgICAgICAucmVtb3ZlQXR0cignZGF0YS1zbGljay1pbmRleCcpXG4gICAgICAgICAgICAgICAgLmVhY2goZnVuY3Rpb24oKXtcbiAgICAgICAgICAgICAgICAgICAgJCh0aGlzKS5hdHRyKCdzdHlsZScsICQodGhpcykuZGF0YSgnb3JpZ2luYWxTdHlsaW5nJykpO1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBfLiRzbGlkZVRyYWNrLmNoaWxkcmVuKHRoaXMub3B0aW9ucy5zbGlkZSkuZGV0YWNoKCk7XG5cbiAgICAgICAgICAgIF8uJHNsaWRlVHJhY2suZGV0YWNoKCk7XG5cbiAgICAgICAgICAgIF8uJGxpc3QuZGV0YWNoKCk7XG5cbiAgICAgICAgICAgIF8uJHNsaWRlci5hcHBlbmQoXy4kc2xpZGVzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIF8uY2xlYW5VcFJvd3MoKTtcblxuICAgICAgICBfLiRzbGlkZXIucmVtb3ZlQ2xhc3MoJ3NsaWNrLXNsaWRlcicpO1xuICAgICAgICBfLiRzbGlkZXIucmVtb3ZlQ2xhc3MoJ3NsaWNrLWluaXRpYWxpemVkJyk7XG4gICAgICAgIF8uJHNsaWRlci5yZW1vdmVDbGFzcygnc2xpY2stZG90dGVkJyk7XG5cbiAgICAgICAgXy51bnNsaWNrZWQgPSB0cnVlO1xuXG4gICAgICAgIGlmKCFyZWZyZXNoKSB7XG4gICAgICAgICAgICBfLiRzbGlkZXIudHJpZ2dlcignZGVzdHJveScsIFtfXSk7XG4gICAgICAgIH1cblxuICAgIH07XG5cbiAgICBTbGljay5wcm90b3R5cGUuZGlzYWJsZVRyYW5zaXRpb24gPSBmdW5jdGlvbihzbGlkZSkge1xuXG4gICAgICAgIHZhciBfID0gdGhpcyxcbiAgICAgICAgICAgIHRyYW5zaXRpb24gPSB7fTtcblxuICAgICAgICB0cmFuc2l0aW9uW18udHJhbnNpdGlvblR5cGVdID0gJyc7XG5cbiAgICAgICAgaWYgKF8ub3B0aW9ucy5mYWRlID09PSBmYWxzZSkge1xuICAgICAgICAgICAgXy4kc2xpZGVUcmFjay5jc3ModHJhbnNpdGlvbik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBfLiRzbGlkZXMuZXEoc2xpZGUpLmNzcyh0cmFuc2l0aW9uKTtcbiAgICAgICAgfVxuXG4gICAgfTtcblxuICAgIFNsaWNrLnByb3RvdHlwZS5mYWRlU2xpZGUgPSBmdW5jdGlvbihzbGlkZUluZGV4LCBjYWxsYmFjaykge1xuXG4gICAgICAgIHZhciBfID0gdGhpcztcblxuICAgICAgICBpZiAoXy5jc3NUcmFuc2l0aW9ucyA9PT0gZmFsc2UpIHtcblxuICAgICAgICAgICAgXy4kc2xpZGVzLmVxKHNsaWRlSW5kZXgpLmNzcyh7XG4gICAgICAgICAgICAgICAgekluZGV4OiBfLm9wdGlvbnMuekluZGV4XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgXy4kc2xpZGVzLmVxKHNsaWRlSW5kZXgpLmFuaW1hdGUoe1xuICAgICAgICAgICAgICAgIG9wYWNpdHk6IDFcbiAgICAgICAgICAgIH0sIF8ub3B0aW9ucy5zcGVlZCwgXy5vcHRpb25zLmVhc2luZywgY2FsbGJhY2spO1xuXG4gICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgIF8uYXBwbHlUcmFuc2l0aW9uKHNsaWRlSW5kZXgpO1xuXG4gICAgICAgICAgICBfLiRzbGlkZXMuZXEoc2xpZGVJbmRleCkuY3NzKHtcbiAgICAgICAgICAgICAgICBvcGFjaXR5OiAxLFxuICAgICAgICAgICAgICAgIHpJbmRleDogXy5vcHRpb25zLnpJbmRleFxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgXy5kaXNhYmxlVHJhbnNpdGlvbihzbGlkZUluZGV4KTtcblxuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjay5jYWxsKCk7XG4gICAgICAgICAgICAgICAgfSwgXy5vcHRpb25zLnNwZWVkKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICB9O1xuXG4gICAgU2xpY2sucHJvdG90eXBlLmZhZGVTbGlkZU91dCA9IGZ1bmN0aW9uKHNsaWRlSW5kZXgpIHtcblxuICAgICAgICB2YXIgXyA9IHRoaXM7XG5cbiAgICAgICAgaWYgKF8uY3NzVHJhbnNpdGlvbnMgPT09IGZhbHNlKSB7XG5cbiAgICAgICAgICAgIF8uJHNsaWRlcy5lcShzbGlkZUluZGV4KS5hbmltYXRlKHtcbiAgICAgICAgICAgICAgICBvcGFjaXR5OiAwLFxuICAgICAgICAgICAgICAgIHpJbmRleDogXy5vcHRpb25zLnpJbmRleCAtIDJcbiAgICAgICAgICAgIH0sIF8ub3B0aW9ucy5zcGVlZCwgXy5vcHRpb25zLmVhc2luZyk7XG5cbiAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgXy5hcHBseVRyYW5zaXRpb24oc2xpZGVJbmRleCk7XG5cbiAgICAgICAgICAgIF8uJHNsaWRlcy5lcShzbGlkZUluZGV4KS5jc3Moe1xuICAgICAgICAgICAgICAgIG9wYWNpdHk6IDAsXG4gICAgICAgICAgICAgICAgekluZGV4OiBfLm9wdGlvbnMuekluZGV4IC0gMlxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgfVxuXG4gICAgfTtcblxuICAgIFNsaWNrLnByb3RvdHlwZS5maWx0ZXJTbGlkZXMgPSBTbGljay5wcm90b3R5cGUuc2xpY2tGaWx0ZXIgPSBmdW5jdGlvbihmaWx0ZXIpIHtcblxuICAgICAgICB2YXIgXyA9IHRoaXM7XG5cbiAgICAgICAgaWYgKGZpbHRlciAhPT0gbnVsbCkge1xuXG4gICAgICAgICAgICBfLiRzbGlkZXNDYWNoZSA9IF8uJHNsaWRlcztcblxuICAgICAgICAgICAgXy51bmxvYWQoKTtcblxuICAgICAgICAgICAgXy4kc2xpZGVUcmFjay5jaGlsZHJlbih0aGlzLm9wdGlvbnMuc2xpZGUpLmRldGFjaCgpO1xuXG4gICAgICAgICAgICBfLiRzbGlkZXNDYWNoZS5maWx0ZXIoZmlsdGVyKS5hcHBlbmRUbyhfLiRzbGlkZVRyYWNrKTtcblxuICAgICAgICAgICAgXy5yZWluaXQoKTtcblxuICAgICAgICB9XG5cbiAgICB9O1xuXG4gICAgU2xpY2sucHJvdG90eXBlLmZvY3VzSGFuZGxlciA9IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHZhciBfID0gdGhpcztcblxuICAgICAgICBfLiRzbGlkZXJcbiAgICAgICAgICAgIC5vZmYoJ2ZvY3VzLnNsaWNrIGJsdXIuc2xpY2snKVxuICAgICAgICAgICAgLm9uKCdmb2N1cy5zbGljayBibHVyLnNsaWNrJywgJyonLCBmdW5jdGlvbihldmVudCkge1xuXG4gICAgICAgICAgICBldmVudC5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgIHZhciAkc2YgPSAkKHRoaXMpO1xuXG4gICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuXG4gICAgICAgICAgICAgICAgaWYoIF8ub3B0aW9ucy5wYXVzZU9uRm9jdXMgKSB7XG4gICAgICAgICAgICAgICAgICAgIF8uZm9jdXNzZWQgPSAkc2YuaXMoJzpmb2N1cycpO1xuICAgICAgICAgICAgICAgICAgICBfLmF1dG9QbGF5KCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9LCAwKTtcblxuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgU2xpY2sucHJvdG90eXBlLmdldEN1cnJlbnQgPSBTbGljay5wcm90b3R5cGUuc2xpY2tDdXJyZW50U2xpZGUgPSBmdW5jdGlvbigpIHtcblxuICAgICAgICB2YXIgXyA9IHRoaXM7XG4gICAgICAgIHJldHVybiBfLmN1cnJlbnRTbGlkZTtcblxuICAgIH07XG5cbiAgICBTbGljay5wcm90b3R5cGUuZ2V0RG90Q291bnQgPSBmdW5jdGlvbigpIHtcblxuICAgICAgICB2YXIgXyA9IHRoaXM7XG5cbiAgICAgICAgdmFyIGJyZWFrUG9pbnQgPSAwO1xuICAgICAgICB2YXIgY291bnRlciA9IDA7XG4gICAgICAgIHZhciBwYWdlclF0eSA9IDA7XG5cbiAgICAgICAgaWYgKF8ub3B0aW9ucy5pbmZpbml0ZSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgaWYgKF8uc2xpZGVDb3VudCA8PSBfLm9wdGlvbnMuc2xpZGVzVG9TaG93KSB7XG4gICAgICAgICAgICAgICAgICsrcGFnZXJRdHk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHdoaWxlIChicmVha1BvaW50IDwgXy5zbGlkZUNvdW50KSB7XG4gICAgICAgICAgICAgICAgICAgICsrcGFnZXJRdHk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrUG9pbnQgPSBjb3VudGVyICsgXy5vcHRpb25zLnNsaWRlc1RvU2Nyb2xsO1xuICAgICAgICAgICAgICAgICAgICBjb3VudGVyICs9IF8ub3B0aW9ucy5zbGlkZXNUb1Njcm9sbCA8PSBfLm9wdGlvbnMuc2xpZGVzVG9TaG93ID8gXy5vcHRpb25zLnNsaWRlc1RvU2Nyb2xsIDogXy5vcHRpb25zLnNsaWRlc1RvU2hvdztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoXy5vcHRpb25zLmNlbnRlck1vZGUgPT09IHRydWUpIHtcbiAgICAgICAgICAgIHBhZ2VyUXR5ID0gXy5zbGlkZUNvdW50O1xuICAgICAgICB9IGVsc2UgaWYoIV8ub3B0aW9ucy5hc05hdkZvcikge1xuICAgICAgICAgICAgcGFnZXJRdHkgPSAxICsgTWF0aC5jZWlsKChfLnNsaWRlQ291bnQgLSBfLm9wdGlvbnMuc2xpZGVzVG9TaG93KSAvIF8ub3B0aW9ucy5zbGlkZXNUb1Njcm9sbCk7XG4gICAgICAgIH1lbHNlIHtcbiAgICAgICAgICAgIHdoaWxlIChicmVha1BvaW50IDwgXy5zbGlkZUNvdW50KSB7XG4gICAgICAgICAgICAgICAgKytwYWdlclF0eTtcbiAgICAgICAgICAgICAgICBicmVha1BvaW50ID0gY291bnRlciArIF8ub3B0aW9ucy5zbGlkZXNUb1Njcm9sbDtcbiAgICAgICAgICAgICAgICBjb3VudGVyICs9IF8ub3B0aW9ucy5zbGlkZXNUb1Njcm9sbCA8PSBfLm9wdGlvbnMuc2xpZGVzVG9TaG93ID8gXy5vcHRpb25zLnNsaWRlc1RvU2Nyb2xsIDogXy5vcHRpb25zLnNsaWRlc1RvU2hvdztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBwYWdlclF0eSAtIDE7XG5cbiAgICB9O1xuXG4gICAgU2xpY2sucHJvdG90eXBlLmdldExlZnQgPSBmdW5jdGlvbihzbGlkZUluZGV4KSB7XG5cbiAgICAgICAgdmFyIF8gPSB0aGlzLFxuICAgICAgICAgICAgdGFyZ2V0TGVmdCxcbiAgICAgICAgICAgIHZlcnRpY2FsSGVpZ2h0LFxuICAgICAgICAgICAgdmVydGljYWxPZmZzZXQgPSAwLFxuICAgICAgICAgICAgdGFyZ2V0U2xpZGUsXG4gICAgICAgICAgICBjb2VmO1xuXG4gICAgICAgIF8uc2xpZGVPZmZzZXQgPSAwO1xuICAgICAgICB2ZXJ0aWNhbEhlaWdodCA9IF8uJHNsaWRlcy5maXJzdCgpLm91dGVySGVpZ2h0KHRydWUpO1xuXG4gICAgICAgIGlmIChfLm9wdGlvbnMuaW5maW5pdGUgPT09IHRydWUpIHtcbiAgICAgICAgICAgIGlmIChfLnNsaWRlQ291bnQgPiBfLm9wdGlvbnMuc2xpZGVzVG9TaG93KSB7XG4gICAgICAgICAgICAgICAgXy5zbGlkZU9mZnNldCA9IChfLnNsaWRlV2lkdGggKiBfLm9wdGlvbnMuc2xpZGVzVG9TaG93KSAqIC0xO1xuICAgICAgICAgICAgICAgIGNvZWYgPSAtMVxuXG4gICAgICAgICAgICAgICAgaWYgKF8ub3B0aW9ucy52ZXJ0aWNhbCA9PT0gdHJ1ZSAmJiBfLm9wdGlvbnMuY2VudGVyTW9kZSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoXy5vcHRpb25zLnNsaWRlc1RvU2hvdyA9PT0gMikge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29lZiA9IC0xLjU7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoXy5vcHRpb25zLnNsaWRlc1RvU2hvdyA9PT0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29lZiA9IC0yXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmVydGljYWxPZmZzZXQgPSAodmVydGljYWxIZWlnaHQgKiBfLm9wdGlvbnMuc2xpZGVzVG9TaG93KSAqIGNvZWY7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoXy5zbGlkZUNvdW50ICUgXy5vcHRpb25zLnNsaWRlc1RvU2Nyb2xsICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNsaWRlSW5kZXggKyBfLm9wdGlvbnMuc2xpZGVzVG9TY3JvbGwgPiBfLnNsaWRlQ291bnQgJiYgXy5zbGlkZUNvdW50ID4gXy5vcHRpb25zLnNsaWRlc1RvU2hvdykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2xpZGVJbmRleCA+IF8uc2xpZGVDb3VudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgXy5zbGlkZU9mZnNldCA9ICgoXy5vcHRpb25zLnNsaWRlc1RvU2hvdyAtIChzbGlkZUluZGV4IC0gXy5zbGlkZUNvdW50KSkgKiBfLnNsaWRlV2lkdGgpICogLTE7XG4gICAgICAgICAgICAgICAgICAgICAgICB2ZXJ0aWNhbE9mZnNldCA9ICgoXy5vcHRpb25zLnNsaWRlc1RvU2hvdyAtIChzbGlkZUluZGV4IC0gXy5zbGlkZUNvdW50KSkgKiB2ZXJ0aWNhbEhlaWdodCkgKiAtMTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF8uc2xpZGVPZmZzZXQgPSAoKF8uc2xpZGVDb3VudCAlIF8ub3B0aW9ucy5zbGlkZXNUb1Njcm9sbCkgKiBfLnNsaWRlV2lkdGgpICogLTE7XG4gICAgICAgICAgICAgICAgICAgICAgICB2ZXJ0aWNhbE9mZnNldCA9ICgoXy5zbGlkZUNvdW50ICUgXy5vcHRpb25zLnNsaWRlc1RvU2Nyb2xsKSAqIHZlcnRpY2FsSGVpZ2h0KSAqIC0xO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKHNsaWRlSW5kZXggKyBfLm9wdGlvbnMuc2xpZGVzVG9TaG93ID4gXy5zbGlkZUNvdW50KSB7XG4gICAgICAgICAgICAgICAgXy5zbGlkZU9mZnNldCA9ICgoc2xpZGVJbmRleCArIF8ub3B0aW9ucy5zbGlkZXNUb1Nob3cpIC0gXy5zbGlkZUNvdW50KSAqIF8uc2xpZGVXaWR0aDtcbiAgICAgICAgICAgICAgICB2ZXJ0aWNhbE9mZnNldCA9ICgoc2xpZGVJbmRleCArIF8ub3B0aW9ucy5zbGlkZXNUb1Nob3cpIC0gXy5zbGlkZUNvdW50KSAqIHZlcnRpY2FsSGVpZ2h0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKF8uc2xpZGVDb3VudCA8PSBfLm9wdGlvbnMuc2xpZGVzVG9TaG93KSB7XG4gICAgICAgICAgICBfLnNsaWRlT2Zmc2V0ID0gMDtcbiAgICAgICAgICAgIHZlcnRpY2FsT2Zmc2V0ID0gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChfLm9wdGlvbnMuY2VudGVyTW9kZSA9PT0gdHJ1ZSAmJiBfLnNsaWRlQ291bnQgPD0gXy5vcHRpb25zLnNsaWRlc1RvU2hvdykge1xuICAgICAgICAgICAgXy5zbGlkZU9mZnNldCA9ICgoXy5zbGlkZVdpZHRoICogTWF0aC5mbG9vcihfLm9wdGlvbnMuc2xpZGVzVG9TaG93KSkgLyAyKSAtICgoXy5zbGlkZVdpZHRoICogXy5zbGlkZUNvdW50KSAvIDIpO1xuICAgICAgICB9IGVsc2UgaWYgKF8ub3B0aW9ucy5jZW50ZXJNb2RlID09PSB0cnVlICYmIF8ub3B0aW9ucy5pbmZpbml0ZSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgXy5zbGlkZU9mZnNldCArPSBfLnNsaWRlV2lkdGggKiBNYXRoLmZsb29yKF8ub3B0aW9ucy5zbGlkZXNUb1Nob3cgLyAyKSAtIF8uc2xpZGVXaWR0aDtcbiAgICAgICAgfSBlbHNlIGlmIChfLm9wdGlvbnMuY2VudGVyTW9kZSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgXy5zbGlkZU9mZnNldCA9IDA7XG4gICAgICAgICAgICBfLnNsaWRlT2Zmc2V0ICs9IF8uc2xpZGVXaWR0aCAqIE1hdGguZmxvb3IoXy5vcHRpb25zLnNsaWRlc1RvU2hvdyAvIDIpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKF8ub3B0aW9ucy52ZXJ0aWNhbCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHRhcmdldExlZnQgPSAoKHNsaWRlSW5kZXggKiBfLnNsaWRlV2lkdGgpICogLTEpICsgXy5zbGlkZU9mZnNldDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRhcmdldExlZnQgPSAoKHNsaWRlSW5kZXggKiB2ZXJ0aWNhbEhlaWdodCkgKiAtMSkgKyB2ZXJ0aWNhbE9mZnNldDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChfLm9wdGlvbnMudmFyaWFibGVXaWR0aCA9PT0gdHJ1ZSkge1xuXG4gICAgICAgICAgICBpZiAoXy5zbGlkZUNvdW50IDw9IF8ub3B0aW9ucy5zbGlkZXNUb1Nob3cgfHwgXy5vcHRpb25zLmluZmluaXRlID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIHRhcmdldFNsaWRlID0gXy4kc2xpZGVUcmFjay5jaGlsZHJlbignLnNsaWNrLXNsaWRlJykuZXEoc2xpZGVJbmRleCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRhcmdldFNsaWRlID0gXy4kc2xpZGVUcmFjay5jaGlsZHJlbignLnNsaWNrLXNsaWRlJykuZXEoc2xpZGVJbmRleCArIF8ub3B0aW9ucy5zbGlkZXNUb1Nob3cpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoXy5vcHRpb25zLnJ0bCA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgIGlmICh0YXJnZXRTbGlkZVswXSkge1xuICAgICAgICAgICAgICAgICAgICB0YXJnZXRMZWZ0ID0gKF8uJHNsaWRlVHJhY2sud2lkdGgoKSAtIHRhcmdldFNsaWRlWzBdLm9mZnNldExlZnQgLSB0YXJnZXRTbGlkZS53aWR0aCgpKSAqIC0xO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRhcmdldExlZnQgPSAgMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRhcmdldExlZnQgPSB0YXJnZXRTbGlkZVswXSA/IHRhcmdldFNsaWRlWzBdLm9mZnNldExlZnQgKiAtMSA6IDA7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChfLm9wdGlvbnMuY2VudGVyTW9kZSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgIGlmIChfLnNsaWRlQ291bnQgPD0gXy5vcHRpb25zLnNsaWRlc1RvU2hvdyB8fCBfLm9wdGlvbnMuaW5maW5pdGUgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRhcmdldFNsaWRlID0gXy4kc2xpZGVUcmFjay5jaGlsZHJlbignLnNsaWNrLXNsaWRlJykuZXEoc2xpZGVJbmRleCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0U2xpZGUgPSBfLiRzbGlkZVRyYWNrLmNoaWxkcmVuKCcuc2xpY2stc2xpZGUnKS5lcShzbGlkZUluZGV4ICsgXy5vcHRpb25zLnNsaWRlc1RvU2hvdyArIDEpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChfLm9wdGlvbnMucnRsID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0YXJnZXRTbGlkZVswXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0TGVmdCA9IChfLiRzbGlkZVRyYWNrLndpZHRoKCkgLSB0YXJnZXRTbGlkZVswXS5vZmZzZXRMZWZ0IC0gdGFyZ2V0U2xpZGUud2lkdGgoKSkgKiAtMTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldExlZnQgPSAgMDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRhcmdldExlZnQgPSB0YXJnZXRTbGlkZVswXSA/IHRhcmdldFNsaWRlWzBdLm9mZnNldExlZnQgKiAtMSA6IDA7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdGFyZ2V0TGVmdCArPSAoXy4kbGlzdC53aWR0aCgpIC0gdGFyZ2V0U2xpZGUub3V0ZXJXaWR0aCgpKSAvIDI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGFyZ2V0TGVmdDtcblxuICAgIH07XG5cbiAgICBTbGljay5wcm90b3R5cGUuZ2V0T3B0aW9uID0gU2xpY2sucHJvdG90eXBlLnNsaWNrR2V0T3B0aW9uID0gZnVuY3Rpb24ob3B0aW9uKSB7XG5cbiAgICAgICAgdmFyIF8gPSB0aGlzO1xuXG4gICAgICAgIHJldHVybiBfLm9wdGlvbnNbb3B0aW9uXTtcblxuICAgIH07XG5cbiAgICBTbGljay5wcm90b3R5cGUuZ2V0TmF2aWdhYmxlSW5kZXhlcyA9IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHZhciBfID0gdGhpcyxcbiAgICAgICAgICAgIGJyZWFrUG9pbnQgPSAwLFxuICAgICAgICAgICAgY291bnRlciA9IDAsXG4gICAgICAgICAgICBpbmRleGVzID0gW10sXG4gICAgICAgICAgICBtYXg7XG5cbiAgICAgICAgaWYgKF8ub3B0aW9ucy5pbmZpbml0ZSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIG1heCA9IF8uc2xpZGVDb3VudDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGJyZWFrUG9pbnQgPSBfLm9wdGlvbnMuc2xpZGVzVG9TY3JvbGwgKiAtMTtcbiAgICAgICAgICAgIGNvdW50ZXIgPSBfLm9wdGlvbnMuc2xpZGVzVG9TY3JvbGwgKiAtMTtcbiAgICAgICAgICAgIG1heCA9IF8uc2xpZGVDb3VudCAqIDI7XG4gICAgICAgIH1cblxuICAgICAgICB3aGlsZSAoYnJlYWtQb2ludCA8IG1heCkge1xuICAgICAgICAgICAgaW5kZXhlcy5wdXNoKGJyZWFrUG9pbnQpO1xuICAgICAgICAgICAgYnJlYWtQb2ludCA9IGNvdW50ZXIgKyBfLm9wdGlvbnMuc2xpZGVzVG9TY3JvbGw7XG4gICAgICAgICAgICBjb3VudGVyICs9IF8ub3B0aW9ucy5zbGlkZXNUb1Njcm9sbCA8PSBfLm9wdGlvbnMuc2xpZGVzVG9TaG93ID8gXy5vcHRpb25zLnNsaWRlc1RvU2Nyb2xsIDogXy5vcHRpb25zLnNsaWRlc1RvU2hvdztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBpbmRleGVzO1xuXG4gICAgfTtcblxuICAgIFNsaWNrLnByb3RvdHlwZS5nZXRTbGljayA9IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfTtcblxuICAgIFNsaWNrLnByb3RvdHlwZS5nZXRTbGlkZUNvdW50ID0gZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdmFyIF8gPSB0aGlzLFxuICAgICAgICAgICAgc2xpZGVzVHJhdmVyc2VkLCBzd2lwZWRTbGlkZSwgY2VudGVyT2Zmc2V0O1xuXG4gICAgICAgIGNlbnRlck9mZnNldCA9IF8ub3B0aW9ucy5jZW50ZXJNb2RlID09PSB0cnVlID8gXy5zbGlkZVdpZHRoICogTWF0aC5mbG9vcihfLm9wdGlvbnMuc2xpZGVzVG9TaG93IC8gMikgOiAwO1xuXG4gICAgICAgIGlmIChfLm9wdGlvbnMuc3dpcGVUb1NsaWRlID09PSB0cnVlKSB7XG4gICAgICAgICAgICBfLiRzbGlkZVRyYWNrLmZpbmQoJy5zbGljay1zbGlkZScpLmVhY2goZnVuY3Rpb24oaW5kZXgsIHNsaWRlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNsaWRlLm9mZnNldExlZnQgLSBjZW50ZXJPZmZzZXQgKyAoJChzbGlkZSkub3V0ZXJXaWR0aCgpIC8gMikgPiAoXy5zd2lwZUxlZnQgKiAtMSkpIHtcbiAgICAgICAgICAgICAgICAgICAgc3dpcGVkU2xpZGUgPSBzbGlkZTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBzbGlkZXNUcmF2ZXJzZWQgPSBNYXRoLmFicygkKHN3aXBlZFNsaWRlKS5hdHRyKCdkYXRhLXNsaWNrLWluZGV4JykgLSBfLmN1cnJlbnRTbGlkZSkgfHwgMTtcblxuICAgICAgICAgICAgcmV0dXJuIHNsaWRlc1RyYXZlcnNlZDtcblxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIF8ub3B0aW9ucy5zbGlkZXNUb1Njcm9sbDtcbiAgICAgICAgfVxuXG4gICAgfTtcblxuICAgIFNsaWNrLnByb3RvdHlwZS5nb1RvID0gU2xpY2sucHJvdG90eXBlLnNsaWNrR29UbyA9IGZ1bmN0aW9uKHNsaWRlLCBkb250QW5pbWF0ZSkge1xuXG4gICAgICAgIHZhciBfID0gdGhpcztcblxuICAgICAgICBfLmNoYW5nZVNsaWRlKHtcbiAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiAnaW5kZXgnLFxuICAgICAgICAgICAgICAgIGluZGV4OiBwYXJzZUludChzbGlkZSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgZG9udEFuaW1hdGUpO1xuXG4gICAgfTtcblxuICAgIFNsaWNrLnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24oY3JlYXRpb24pIHtcblxuICAgICAgICB2YXIgXyA9IHRoaXM7XG5cbiAgICAgICAgaWYgKCEkKF8uJHNsaWRlcikuaGFzQ2xhc3MoJ3NsaWNrLWluaXRpYWxpemVkJykpIHtcblxuICAgICAgICAgICAgJChfLiRzbGlkZXIpLmFkZENsYXNzKCdzbGljay1pbml0aWFsaXplZCcpO1xuXG4gICAgICAgICAgICBfLmJ1aWxkUm93cygpO1xuICAgICAgICAgICAgXy5idWlsZE91dCgpO1xuICAgICAgICAgICAgXy5zZXRQcm9wcygpO1xuICAgICAgICAgICAgXy5zdGFydExvYWQoKTtcbiAgICAgICAgICAgIF8ubG9hZFNsaWRlcigpO1xuICAgICAgICAgICAgXy5pbml0aWFsaXplRXZlbnRzKCk7XG4gICAgICAgICAgICBfLnVwZGF0ZUFycm93cygpO1xuICAgICAgICAgICAgXy51cGRhdGVEb3RzKCk7XG4gICAgICAgICAgICBfLmNoZWNrUmVzcG9uc2l2ZSh0cnVlKTtcbiAgICAgICAgICAgIF8uZm9jdXNIYW5kbGVyKCk7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjcmVhdGlvbikge1xuICAgICAgICAgICAgXy4kc2xpZGVyLnRyaWdnZXIoJ2luaXQnLCBbX10pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKF8ub3B0aW9ucy5hY2Nlc3NpYmlsaXR5ID09PSB0cnVlKSB7XG4gICAgICAgICAgICBfLmluaXRBREEoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICggXy5vcHRpb25zLmF1dG9wbGF5ICkge1xuXG4gICAgICAgICAgICBfLnBhdXNlZCA9IGZhbHNlO1xuICAgICAgICAgICAgXy5hdXRvUGxheSgpO1xuXG4gICAgICAgIH1cblxuICAgIH07XG5cbiAgICBTbGljay5wcm90b3R5cGUuaW5pdEFEQSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgXyA9IHRoaXMsXG4gICAgICAgICAgICAgICAgbnVtRG90R3JvdXBzID0gTWF0aC5jZWlsKF8uc2xpZGVDb3VudCAvIF8ub3B0aW9ucy5zbGlkZXNUb1Nob3cpLFxuICAgICAgICAgICAgICAgIHRhYkNvbnRyb2xJbmRleGVzID0gXy5nZXROYXZpZ2FibGVJbmRleGVzKCkuZmlsdGVyKGZ1bmN0aW9uKHZhbCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKHZhbCA+PSAwKSAmJiAodmFsIDwgXy5zbGlkZUNvdW50KTtcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICBfLiRzbGlkZXMuYWRkKF8uJHNsaWRlVHJhY2suZmluZCgnLnNsaWNrLWNsb25lZCcpKS5hdHRyKHtcbiAgICAgICAgICAgICdhcmlhLWhpZGRlbic6ICd0cnVlJyxcbiAgICAgICAgICAgICd0YWJpbmRleCc6ICctMSdcbiAgICAgICAgfSkuZmluZCgnYSwgaW5wdXQsIGJ1dHRvbiwgc2VsZWN0JykuYXR0cih7XG4gICAgICAgICAgICAndGFiaW5kZXgnOiAnLTEnXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmIChfLiRkb3RzICE9PSBudWxsKSB7XG4gICAgICAgICAgICBfLiRzbGlkZXMubm90KF8uJHNsaWRlVHJhY2suZmluZCgnLnNsaWNrLWNsb25lZCcpKS5lYWNoKGZ1bmN0aW9uKGkpIHtcbiAgICAgICAgICAgICAgICB2YXIgc2xpZGVDb250cm9sSW5kZXggPSB0YWJDb250cm9sSW5kZXhlcy5pbmRleE9mKGkpO1xuXG4gICAgICAgICAgICAgICAgJCh0aGlzKS5hdHRyKHtcbiAgICAgICAgICAgICAgICAgICAgJ3JvbGUnOiAndGFicGFuZWwnLFxuICAgICAgICAgICAgICAgICAgICAnaWQnOiAnc2xpY2stc2xpZGUnICsgXy5pbnN0YW5jZVVpZCArIGksXG4gICAgICAgICAgICAgICAgICAgICd0YWJpbmRleCc6IC0xXG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICBpZiAoc2xpZGVDb250cm9sSW5kZXggIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgdmFyIGFyaWFCdXR0b25Db250cm9sID0gJ3NsaWNrLXNsaWRlLWNvbnRyb2wnICsgXy5pbnN0YW5jZVVpZCArIHNsaWRlQ29udHJvbEluZGV4XG4gICAgICAgICAgICAgICAgICAgaWYgKCQoJyMnICsgYXJpYUJ1dHRvbkNvbnRyb2wpLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgJCh0aGlzKS5hdHRyKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAnYXJpYS1kZXNjcmliZWRieSc6IGFyaWFCdXR0b25Db250cm9sXG4gICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIF8uJGRvdHMuYXR0cigncm9sZScsICd0YWJsaXN0JykuZmluZCgnbGknKS5lYWNoKGZ1bmN0aW9uKGkpIHtcbiAgICAgICAgICAgICAgICB2YXIgbWFwcGVkU2xpZGVJbmRleCA9IHRhYkNvbnRyb2xJbmRleGVzW2ldO1xuXG4gICAgICAgICAgICAgICAgJCh0aGlzKS5hdHRyKHtcbiAgICAgICAgICAgICAgICAgICAgJ3JvbGUnOiAncHJlc2VudGF0aW9uJ1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgJCh0aGlzKS5maW5kKCdidXR0b24nKS5maXJzdCgpLmF0dHIoe1xuICAgICAgICAgICAgICAgICAgICAncm9sZSc6ICd0YWInLFxuICAgICAgICAgICAgICAgICAgICAnaWQnOiAnc2xpY2stc2xpZGUtY29udHJvbCcgKyBfLmluc3RhbmNlVWlkICsgaSxcbiAgICAgICAgICAgICAgICAgICAgJ2FyaWEtY29udHJvbHMnOiAnc2xpY2stc2xpZGUnICsgXy5pbnN0YW5jZVVpZCArIG1hcHBlZFNsaWRlSW5kZXgsXG4gICAgICAgICAgICAgICAgICAgICdhcmlhLWxhYmVsJzogKGkgKyAxKSArICcgb2YgJyArIG51bURvdEdyb3VwcyxcbiAgICAgICAgICAgICAgICAgICAgJ2FyaWEtc2VsZWN0ZWQnOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICAndGFiaW5kZXgnOiAnLTEnXG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIH0pLmVxKF8uY3VycmVudFNsaWRlKS5maW5kKCdidXR0b24nKS5hdHRyKHtcbiAgICAgICAgICAgICAgICAnYXJpYS1zZWxlY3RlZCc6ICd0cnVlJyxcbiAgICAgICAgICAgICAgICAndGFiaW5kZXgnOiAnMCdcbiAgICAgICAgICAgIH0pLmVuZCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yICh2YXIgaT1fLmN1cnJlbnRTbGlkZSwgbWF4PWkrXy5vcHRpb25zLnNsaWRlc1RvU2hvdzsgaSA8IG1heDsgaSsrKSB7XG4gICAgICAgICAgaWYgKF8ub3B0aW9ucy5mb2N1c09uQ2hhbmdlKSB7XG4gICAgICAgICAgICBfLiRzbGlkZXMuZXEoaSkuYXR0cih7J3RhYmluZGV4JzogJzAnfSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIF8uJHNsaWRlcy5lcShpKS5yZW1vdmVBdHRyKCd0YWJpbmRleCcpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIF8uYWN0aXZhdGVBREEoKTtcblxuICAgIH07XG5cbiAgICBTbGljay5wcm90b3R5cGUuaW5pdEFycm93RXZlbnRzID0gZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdmFyIF8gPSB0aGlzO1xuXG4gICAgICAgIGlmIChfLm9wdGlvbnMuYXJyb3dzID09PSB0cnVlICYmIF8uc2xpZGVDb3VudCA+IF8ub3B0aW9ucy5zbGlkZXNUb1Nob3cpIHtcbiAgICAgICAgICAgIF8uJHByZXZBcnJvd1xuICAgICAgICAgICAgICAgLm9mZignY2xpY2suc2xpY2snKVxuICAgICAgICAgICAgICAgLm9uKCdjbGljay5zbGljaycsIHtcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogJ3ByZXZpb3VzJ1xuICAgICAgICAgICAgICAgfSwgXy5jaGFuZ2VTbGlkZSk7XG4gICAgICAgICAgICBfLiRuZXh0QXJyb3dcbiAgICAgICAgICAgICAgIC5vZmYoJ2NsaWNrLnNsaWNrJylcbiAgICAgICAgICAgICAgIC5vbignY2xpY2suc2xpY2snLCB7XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6ICduZXh0J1xuICAgICAgICAgICAgICAgfSwgXy5jaGFuZ2VTbGlkZSk7XG5cbiAgICAgICAgICAgIGlmIChfLm9wdGlvbnMuYWNjZXNzaWJpbGl0eSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgIF8uJHByZXZBcnJvdy5vbigna2V5ZG93bi5zbGljaycsIF8ua2V5SGFuZGxlcik7XG4gICAgICAgICAgICAgICAgXy4kbmV4dEFycm93Lm9uKCdrZXlkb3duLnNsaWNrJywgXy5rZXlIYW5kbGVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgfTtcblxuICAgIFNsaWNrLnByb3RvdHlwZS5pbml0RG90RXZlbnRzID0gZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdmFyIF8gPSB0aGlzO1xuXG4gICAgICAgIGlmIChfLm9wdGlvbnMuZG90cyA9PT0gdHJ1ZSAmJiBfLnNsaWRlQ291bnQgPiBfLm9wdGlvbnMuc2xpZGVzVG9TaG93KSB7XG4gICAgICAgICAgICAkKCdsaScsIF8uJGRvdHMpLm9uKCdjbGljay5zbGljaycsIHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiAnaW5kZXgnXG4gICAgICAgICAgICB9LCBfLmNoYW5nZVNsaWRlKTtcblxuICAgICAgICAgICAgaWYgKF8ub3B0aW9ucy5hY2Nlc3NpYmlsaXR5ID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgXy4kZG90cy5vbigna2V5ZG93bi5zbGljaycsIF8ua2V5SGFuZGxlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoXy5vcHRpb25zLmRvdHMgPT09IHRydWUgJiYgXy5vcHRpb25zLnBhdXNlT25Eb3RzSG92ZXIgPT09IHRydWUgJiYgXy5zbGlkZUNvdW50ID4gXy5vcHRpb25zLnNsaWRlc1RvU2hvdykge1xuXG4gICAgICAgICAgICAkKCdsaScsIF8uJGRvdHMpXG4gICAgICAgICAgICAgICAgLm9uKCdtb3VzZWVudGVyLnNsaWNrJywgJC5wcm94eShfLmludGVycnVwdCwgXywgdHJ1ZSkpXG4gICAgICAgICAgICAgICAgLm9uKCdtb3VzZWxlYXZlLnNsaWNrJywgJC5wcm94eShfLmludGVycnVwdCwgXywgZmFsc2UpKTtcblxuICAgICAgICB9XG5cbiAgICB9O1xuXG4gICAgU2xpY2sucHJvdG90eXBlLmluaXRTbGlkZUV2ZW50cyA9IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHZhciBfID0gdGhpcztcblxuICAgICAgICBpZiAoIF8ub3B0aW9ucy5wYXVzZU9uSG92ZXIgKSB7XG5cbiAgICAgICAgICAgIF8uJGxpc3Qub24oJ21vdXNlZW50ZXIuc2xpY2snLCAkLnByb3h5KF8uaW50ZXJydXB0LCBfLCB0cnVlKSk7XG4gICAgICAgICAgICBfLiRsaXN0Lm9uKCdtb3VzZWxlYXZlLnNsaWNrJywgJC5wcm94eShfLmludGVycnVwdCwgXywgZmFsc2UpKTtcblxuICAgICAgICB9XG5cbiAgICB9O1xuXG4gICAgU2xpY2sucHJvdG90eXBlLmluaXRpYWxpemVFdmVudHMgPSBmdW5jdGlvbigpIHtcblxuICAgICAgICB2YXIgXyA9IHRoaXM7XG5cbiAgICAgICAgXy5pbml0QXJyb3dFdmVudHMoKTtcblxuICAgICAgICBfLmluaXREb3RFdmVudHMoKTtcbiAgICAgICAgXy5pbml0U2xpZGVFdmVudHMoKTtcblxuICAgICAgICBfLiRsaXN0Lm9uKCd0b3VjaHN0YXJ0LnNsaWNrIG1vdXNlZG93bi5zbGljaycsIHtcbiAgICAgICAgICAgIGFjdGlvbjogJ3N0YXJ0J1xuICAgICAgICB9LCBfLnN3aXBlSGFuZGxlcik7XG4gICAgICAgIF8uJGxpc3Qub24oJ3RvdWNobW92ZS5zbGljayBtb3VzZW1vdmUuc2xpY2snLCB7XG4gICAgICAgICAgICBhY3Rpb246ICdtb3ZlJ1xuICAgICAgICB9LCBfLnN3aXBlSGFuZGxlcik7XG4gICAgICAgIF8uJGxpc3Qub24oJ3RvdWNoZW5kLnNsaWNrIG1vdXNldXAuc2xpY2snLCB7XG4gICAgICAgICAgICBhY3Rpb246ICdlbmQnXG4gICAgICAgIH0sIF8uc3dpcGVIYW5kbGVyKTtcbiAgICAgICAgXy4kbGlzdC5vbigndG91Y2hjYW5jZWwuc2xpY2sgbW91c2VsZWF2ZS5zbGljaycsIHtcbiAgICAgICAgICAgIGFjdGlvbjogJ2VuZCdcbiAgICAgICAgfSwgXy5zd2lwZUhhbmRsZXIpO1xuXG4gICAgICAgIF8uJGxpc3Qub24oJ2NsaWNrLnNsaWNrJywgXy5jbGlja0hhbmRsZXIpO1xuXG4gICAgICAgICQoZG9jdW1lbnQpLm9uKF8udmlzaWJpbGl0eUNoYW5nZSwgJC5wcm94eShfLnZpc2liaWxpdHksIF8pKTtcblxuICAgICAgICBpZiAoXy5vcHRpb25zLmFjY2Vzc2liaWxpdHkgPT09IHRydWUpIHtcbiAgICAgICAgICAgIF8uJGxpc3Qub24oJ2tleWRvd24uc2xpY2snLCBfLmtleUhhbmRsZXIpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKF8ub3B0aW9ucy5mb2N1c09uU2VsZWN0ID09PSB0cnVlKSB7XG4gICAgICAgICAgICAkKF8uJHNsaWRlVHJhY2spLmNoaWxkcmVuKCkub24oJ2NsaWNrLnNsaWNrJywgXy5zZWxlY3RIYW5kbGVyKTtcbiAgICAgICAgfVxuXG4gICAgICAgICQod2luZG93KS5vbignb3JpZW50YXRpb25jaGFuZ2Uuc2xpY2suc2xpY2stJyArIF8uaW5zdGFuY2VVaWQsICQucHJveHkoXy5vcmllbnRhdGlvbkNoYW5nZSwgXykpO1xuXG4gICAgICAgICQod2luZG93KS5vbigncmVzaXplLnNsaWNrLnNsaWNrLScgKyBfLmluc3RhbmNlVWlkLCAkLnByb3h5KF8ucmVzaXplLCBfKSk7XG5cbiAgICAgICAgJCgnW2RyYWdnYWJsZSE9dHJ1ZV0nLCBfLiRzbGlkZVRyYWNrKS5vbignZHJhZ3N0YXJ0JywgXy5wcmV2ZW50RGVmYXVsdCk7XG5cbiAgICAgICAgJCh3aW5kb3cpLm9uKCdsb2FkLnNsaWNrLnNsaWNrLScgKyBfLmluc3RhbmNlVWlkLCBfLnNldFBvc2l0aW9uKTtcbiAgICAgICAgJChfLnNldFBvc2l0aW9uKTtcblxuICAgIH07XG5cbiAgICBTbGljay5wcm90b3R5cGUuaW5pdFVJID0gZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdmFyIF8gPSB0aGlzO1xuXG4gICAgICAgIGlmIChfLm9wdGlvbnMuYXJyb3dzID09PSB0cnVlICYmIF8uc2xpZGVDb3VudCA+IF8ub3B0aW9ucy5zbGlkZXNUb1Nob3cpIHtcblxuICAgICAgICAgICAgXy4kcHJldkFycm93LnNob3coKTtcbiAgICAgICAgICAgIF8uJG5leHRBcnJvdy5zaG93KCk7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChfLm9wdGlvbnMuZG90cyA9PT0gdHJ1ZSAmJiBfLnNsaWRlQ291bnQgPiBfLm9wdGlvbnMuc2xpZGVzVG9TaG93KSB7XG5cbiAgICAgICAgICAgIF8uJGRvdHMuc2hvdygpO1xuXG4gICAgICAgIH1cblxuICAgIH07XG5cbiAgICBTbGljay5wcm90b3R5cGUua2V5SGFuZGxlciA9IGZ1bmN0aW9uKGV2ZW50KSB7XG5cbiAgICAgICAgdmFyIF8gPSB0aGlzO1xuICAgICAgICAgLy9Eb250IHNsaWRlIGlmIHRoZSBjdXJzb3IgaXMgaW5zaWRlIHRoZSBmb3JtIGZpZWxkcyBhbmQgYXJyb3cga2V5cyBhcmUgcHJlc3NlZFxuICAgICAgICBpZighZXZlbnQudGFyZ2V0LnRhZ05hbWUubWF0Y2goJ1RFWFRBUkVBfElOUFVUfFNFTEVDVCcpKSB7XG4gICAgICAgICAgICBpZiAoZXZlbnQua2V5Q29kZSA9PT0gMzcgJiYgXy5vcHRpb25zLmFjY2Vzc2liaWxpdHkgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICBfLmNoYW5nZVNsaWRlKHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogXy5vcHRpb25zLnJ0bCA9PT0gdHJ1ZSA/ICduZXh0JyA6ICAncHJldmlvdXMnXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZXZlbnQua2V5Q29kZSA9PT0gMzkgJiYgXy5vcHRpb25zLmFjY2Vzc2liaWxpdHkgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICBfLmNoYW5nZVNsaWRlKHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogXy5vcHRpb25zLnJ0bCA9PT0gdHJ1ZSA/ICdwcmV2aW91cycgOiAnbmV4dCdcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICB9O1xuXG4gICAgU2xpY2sucHJvdG90eXBlLmxhenlMb2FkID0gZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdmFyIF8gPSB0aGlzLFxuICAgICAgICAgICAgbG9hZFJhbmdlLCBjbG9uZVJhbmdlLCByYW5nZVN0YXJ0LCByYW5nZUVuZDtcblxuICAgICAgICBmdW5jdGlvbiBsb2FkSW1hZ2VzKGltYWdlc1Njb3BlKSB7XG5cbiAgICAgICAgICAgICQoJ2ltZ1tkYXRhLWxhenldJywgaW1hZ2VzU2NvcGUpLmVhY2goZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgICAgICAgICB2YXIgaW1hZ2UgPSAkKHRoaXMpLFxuICAgICAgICAgICAgICAgICAgICBpbWFnZVNvdXJjZSA9ICQodGhpcykuYXR0cignZGF0YS1sYXp5JyksXG4gICAgICAgICAgICAgICAgICAgIGltYWdlU3JjU2V0ID0gJCh0aGlzKS5hdHRyKCdkYXRhLXNyY3NldCcpLFxuICAgICAgICAgICAgICAgICAgICBpbWFnZVNpemVzICA9ICQodGhpcykuYXR0cignZGF0YS1zaXplcycpIHx8IF8uJHNsaWRlci5hdHRyKCdkYXRhLXNpemVzJyksXG4gICAgICAgICAgICAgICAgICAgIGltYWdlVG9Mb2FkID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW1nJyk7XG5cbiAgICAgICAgICAgICAgICBpbWFnZVRvTG9hZC5vbmxvYWQgPSBmdW5jdGlvbigpIHtcblxuICAgICAgICAgICAgICAgICAgICBpbWFnZVxuICAgICAgICAgICAgICAgICAgICAgICAgLmFuaW1hdGUoeyBvcGFjaXR5OiAwIH0sIDEwMCwgZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW1hZ2VTcmNTZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW1hZ2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKCdzcmNzZXQnLCBpbWFnZVNyY1NldCApO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbWFnZVNpemVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbWFnZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKCdzaXplcycsIGltYWdlU2l6ZXMgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGltYWdlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKCdzcmMnLCBpbWFnZVNvdXJjZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLmFuaW1hdGUoeyBvcGFjaXR5OiAxIH0sIDIwMCwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbWFnZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5yZW1vdmVBdHRyKCdkYXRhLWxhenkgZGF0YS1zcmNzZXQgZGF0YS1zaXplcycpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnJlbW92ZUNsYXNzKCdzbGljay1sb2FkaW5nJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF8uJHNsaWRlci50cmlnZ2VyKCdsYXp5TG9hZGVkJywgW18sIGltYWdlLCBpbWFnZVNvdXJjZV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgaW1hZ2VUb0xvYWQub25lcnJvciA9IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgICAgICAgICAgICAgIGltYWdlXG4gICAgICAgICAgICAgICAgICAgICAgICAucmVtb3ZlQXR0ciggJ2RhdGEtbGF6eScgKVxuICAgICAgICAgICAgICAgICAgICAgICAgLnJlbW92ZUNsYXNzKCAnc2xpY2stbG9hZGluZycgKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmFkZENsYXNzKCAnc2xpY2stbGF6eWxvYWQtZXJyb3InICk7XG5cbiAgICAgICAgICAgICAgICAgICAgXy4kc2xpZGVyLnRyaWdnZXIoJ2xhenlMb2FkRXJyb3InLCBbIF8sIGltYWdlLCBpbWFnZVNvdXJjZSBdKTtcblxuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICBpbWFnZVRvTG9hZC5zcmMgPSBpbWFnZVNvdXJjZTtcblxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChfLm9wdGlvbnMuY2VudGVyTW9kZSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgaWYgKF8ub3B0aW9ucy5pbmZpbml0ZSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgIHJhbmdlU3RhcnQgPSBfLmN1cnJlbnRTbGlkZSArIChfLm9wdGlvbnMuc2xpZGVzVG9TaG93IC8gMiArIDEpO1xuICAgICAgICAgICAgICAgIHJhbmdlRW5kID0gcmFuZ2VTdGFydCArIF8ub3B0aW9ucy5zbGlkZXNUb1Nob3cgKyAyO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByYW5nZVN0YXJ0ID0gTWF0aC5tYXgoMCwgXy5jdXJyZW50U2xpZGUgLSAoXy5vcHRpb25zLnNsaWRlc1RvU2hvdyAvIDIgKyAxKSk7XG4gICAgICAgICAgICAgICAgcmFuZ2VFbmQgPSAyICsgKF8ub3B0aW9ucy5zbGlkZXNUb1Nob3cgLyAyICsgMSkgKyBfLmN1cnJlbnRTbGlkZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJhbmdlU3RhcnQgPSBfLm9wdGlvbnMuaW5maW5pdGUgPyBfLm9wdGlvbnMuc2xpZGVzVG9TaG93ICsgXy5jdXJyZW50U2xpZGUgOiBfLmN1cnJlbnRTbGlkZTtcbiAgICAgICAgICAgIHJhbmdlRW5kID0gTWF0aC5jZWlsKHJhbmdlU3RhcnQgKyBfLm9wdGlvbnMuc2xpZGVzVG9TaG93KTtcbiAgICAgICAgICAgIGlmIChfLm9wdGlvbnMuZmFkZSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgIGlmIChyYW5nZVN0YXJ0ID4gMCkgcmFuZ2VTdGFydC0tO1xuICAgICAgICAgICAgICAgIGlmIChyYW5nZUVuZCA8PSBfLnNsaWRlQ291bnQpIHJhbmdlRW5kKys7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBsb2FkUmFuZ2UgPSBfLiRzbGlkZXIuZmluZCgnLnNsaWNrLXNsaWRlJykuc2xpY2UocmFuZ2VTdGFydCwgcmFuZ2VFbmQpO1xuXG4gICAgICAgIGlmIChfLm9wdGlvbnMubGF6eUxvYWQgPT09ICdhbnRpY2lwYXRlZCcpIHtcbiAgICAgICAgICAgIHZhciBwcmV2U2xpZGUgPSByYW5nZVN0YXJ0IC0gMSxcbiAgICAgICAgICAgICAgICBuZXh0U2xpZGUgPSByYW5nZUVuZCxcbiAgICAgICAgICAgICAgICAkc2xpZGVzID0gXy4kc2xpZGVyLmZpbmQoJy5zbGljay1zbGlkZScpO1xuXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IF8ub3B0aW9ucy5zbGlkZXNUb1Njcm9sbDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKHByZXZTbGlkZSA8IDApIHByZXZTbGlkZSA9IF8uc2xpZGVDb3VudCAtIDE7XG4gICAgICAgICAgICAgICAgbG9hZFJhbmdlID0gbG9hZFJhbmdlLmFkZCgkc2xpZGVzLmVxKHByZXZTbGlkZSkpO1xuICAgICAgICAgICAgICAgIGxvYWRSYW5nZSA9IGxvYWRSYW5nZS5hZGQoJHNsaWRlcy5lcShuZXh0U2xpZGUpKTtcbiAgICAgICAgICAgICAgICBwcmV2U2xpZGUtLTtcbiAgICAgICAgICAgICAgICBuZXh0U2xpZGUrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGxvYWRJbWFnZXMobG9hZFJhbmdlKTtcblxuICAgICAgICBpZiAoXy5zbGlkZUNvdW50IDw9IF8ub3B0aW9ucy5zbGlkZXNUb1Nob3cpIHtcbiAgICAgICAgICAgIGNsb25lUmFuZ2UgPSBfLiRzbGlkZXIuZmluZCgnLnNsaWNrLXNsaWRlJyk7XG4gICAgICAgICAgICBsb2FkSW1hZ2VzKGNsb25lUmFuZ2UpO1xuICAgICAgICB9IGVsc2VcbiAgICAgICAgaWYgKF8uY3VycmVudFNsaWRlID49IF8uc2xpZGVDb3VudCAtIF8ub3B0aW9ucy5zbGlkZXNUb1Nob3cpIHtcbiAgICAgICAgICAgIGNsb25lUmFuZ2UgPSBfLiRzbGlkZXIuZmluZCgnLnNsaWNrLWNsb25lZCcpLnNsaWNlKDAsIF8ub3B0aW9ucy5zbGlkZXNUb1Nob3cpO1xuICAgICAgICAgICAgbG9hZEltYWdlcyhjbG9uZVJhbmdlKTtcbiAgICAgICAgfSBlbHNlIGlmIChfLmN1cnJlbnRTbGlkZSA9PT0gMCkge1xuICAgICAgICAgICAgY2xvbmVSYW5nZSA9IF8uJHNsaWRlci5maW5kKCcuc2xpY2stY2xvbmVkJykuc2xpY2UoXy5vcHRpb25zLnNsaWRlc1RvU2hvdyAqIC0xKTtcbiAgICAgICAgICAgIGxvYWRJbWFnZXMoY2xvbmVSYW5nZSk7XG4gICAgICAgIH1cblxuICAgIH07XG5cbiAgICBTbGljay5wcm90b3R5cGUubG9hZFNsaWRlciA9IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHZhciBfID0gdGhpcztcblxuICAgICAgICBfLnNldFBvc2l0aW9uKCk7XG5cbiAgICAgICAgXy4kc2xpZGVUcmFjay5jc3Moe1xuICAgICAgICAgICAgb3BhY2l0eTogMVxuICAgICAgICB9KTtcblxuICAgICAgICBfLiRzbGlkZXIucmVtb3ZlQ2xhc3MoJ3NsaWNrLWxvYWRpbmcnKTtcblxuICAgICAgICBfLmluaXRVSSgpO1xuXG4gICAgICAgIGlmIChfLm9wdGlvbnMubGF6eUxvYWQgPT09ICdwcm9ncmVzc2l2ZScpIHtcbiAgICAgICAgICAgIF8ucHJvZ3Jlc3NpdmVMYXp5TG9hZCgpO1xuICAgICAgICB9XG5cbiAgICB9O1xuXG4gICAgU2xpY2sucHJvdG90eXBlLm5leHQgPSBTbGljay5wcm90b3R5cGUuc2xpY2tOZXh0ID0gZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdmFyIF8gPSB0aGlzO1xuXG4gICAgICAgIF8uY2hhbmdlU2xpZGUoe1xuICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgIG1lc3NhZ2U6ICduZXh0J1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgIH07XG5cbiAgICBTbGljay5wcm90b3R5cGUub3JpZW50YXRpb25DaGFuZ2UgPSBmdW5jdGlvbigpIHtcblxuICAgICAgICB2YXIgXyA9IHRoaXM7XG5cbiAgICAgICAgXy5jaGVja1Jlc3BvbnNpdmUoKTtcbiAgICAgICAgXy5zZXRQb3NpdGlvbigpO1xuXG4gICAgfTtcblxuICAgIFNsaWNrLnByb3RvdHlwZS5wYXVzZSA9IFNsaWNrLnByb3RvdHlwZS5zbGlja1BhdXNlID0gZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdmFyIF8gPSB0aGlzO1xuXG4gICAgICAgIF8uYXV0b1BsYXlDbGVhcigpO1xuICAgICAgICBfLnBhdXNlZCA9IHRydWU7XG5cbiAgICB9O1xuXG4gICAgU2xpY2sucHJvdG90eXBlLnBsYXkgPSBTbGljay5wcm90b3R5cGUuc2xpY2tQbGF5ID0gZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdmFyIF8gPSB0aGlzO1xuXG4gICAgICAgIF8uYXV0b1BsYXkoKTtcbiAgICAgICAgXy5vcHRpb25zLmF1dG9wbGF5ID0gdHJ1ZTtcbiAgICAgICAgXy5wYXVzZWQgPSBmYWxzZTtcbiAgICAgICAgXy5mb2N1c3NlZCA9IGZhbHNlO1xuICAgICAgICBfLmludGVycnVwdGVkID0gZmFsc2U7XG5cbiAgICB9O1xuXG4gICAgU2xpY2sucHJvdG90eXBlLnBvc3RTbGlkZSA9IGZ1bmN0aW9uKGluZGV4KSB7XG5cbiAgICAgICAgdmFyIF8gPSB0aGlzO1xuXG4gICAgICAgIGlmKCAhXy51bnNsaWNrZWQgKSB7XG5cbiAgICAgICAgICAgIF8uJHNsaWRlci50cmlnZ2VyKCdhZnRlckNoYW5nZScsIFtfLCBpbmRleF0pO1xuXG4gICAgICAgICAgICBfLmFuaW1hdGluZyA9IGZhbHNlO1xuXG4gICAgICAgICAgICBpZiAoXy5zbGlkZUNvdW50ID4gXy5vcHRpb25zLnNsaWRlc1RvU2hvdykge1xuICAgICAgICAgICAgICAgIF8uc2V0UG9zaXRpb24oKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgXy5zd2lwZUxlZnQgPSBudWxsO1xuXG4gICAgICAgICAgICBpZiAoIF8ub3B0aW9ucy5hdXRvcGxheSApIHtcbiAgICAgICAgICAgICAgICBfLmF1dG9QbGF5KCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChfLm9wdGlvbnMuYWNjZXNzaWJpbGl0eSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgIF8uaW5pdEFEQSgpO1xuXG4gICAgICAgICAgICAgICAgaWYgKF8ub3B0aW9ucy5mb2N1c09uQ2hhbmdlKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciAkY3VycmVudFNsaWRlID0gJChfLiRzbGlkZXMuZ2V0KF8uY3VycmVudFNsaWRlKSk7XG4gICAgICAgICAgICAgICAgICAgICRjdXJyZW50U2xpZGUuYXR0cigndGFiaW5kZXgnLCAwKS5mb2N1cygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICB9O1xuXG4gICAgU2xpY2sucHJvdG90eXBlLnByZXYgPSBTbGljay5wcm90b3R5cGUuc2xpY2tQcmV2ID0gZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdmFyIF8gPSB0aGlzO1xuXG4gICAgICAgIF8uY2hhbmdlU2xpZGUoe1xuICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgIG1lc3NhZ2U6ICdwcmV2aW91cydcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICB9O1xuXG4gICAgU2xpY2sucHJvdG90eXBlLnByZXZlbnREZWZhdWx0ID0gZnVuY3Rpb24oZXZlbnQpIHtcblxuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgfTtcblxuICAgIFNsaWNrLnByb3RvdHlwZS5wcm9ncmVzc2l2ZUxhenlMb2FkID0gZnVuY3Rpb24oIHRyeUNvdW50ICkge1xuXG4gICAgICAgIHRyeUNvdW50ID0gdHJ5Q291bnQgfHwgMTtcblxuICAgICAgICB2YXIgXyA9IHRoaXMsXG4gICAgICAgICAgICAkaW1nc1RvTG9hZCA9ICQoICdpbWdbZGF0YS1sYXp5XScsIF8uJHNsaWRlciApLFxuICAgICAgICAgICAgaW1hZ2UsXG4gICAgICAgICAgICBpbWFnZVNvdXJjZSxcbiAgICAgICAgICAgIGltYWdlU3JjU2V0LFxuICAgICAgICAgICAgaW1hZ2VTaXplcyxcbiAgICAgICAgICAgIGltYWdlVG9Mb2FkO1xuXG4gICAgICAgIGlmICggJGltZ3NUb0xvYWQubGVuZ3RoICkge1xuXG4gICAgICAgICAgICBpbWFnZSA9ICRpbWdzVG9Mb2FkLmZpcnN0KCk7XG4gICAgICAgICAgICBpbWFnZVNvdXJjZSA9IGltYWdlLmF0dHIoJ2RhdGEtbGF6eScpO1xuICAgICAgICAgICAgaW1hZ2VTcmNTZXQgPSBpbWFnZS5hdHRyKCdkYXRhLXNyY3NldCcpO1xuICAgICAgICAgICAgaW1hZ2VTaXplcyAgPSBpbWFnZS5hdHRyKCdkYXRhLXNpemVzJykgfHwgXy4kc2xpZGVyLmF0dHIoJ2RhdGEtc2l6ZXMnKTtcbiAgICAgICAgICAgIGltYWdlVG9Mb2FkID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW1nJyk7XG5cbiAgICAgICAgICAgIGltYWdlVG9Mb2FkLm9ubG9hZCA9IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgICAgICAgICAgaWYgKGltYWdlU3JjU2V0KSB7XG4gICAgICAgICAgICAgICAgICAgIGltYWdlXG4gICAgICAgICAgICAgICAgICAgICAgICAuYXR0cignc3Jjc2V0JywgaW1hZ2VTcmNTZXQgKTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoaW1hZ2VTaXplcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaW1hZ2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuYXR0cignc2l6ZXMnLCBpbWFnZVNpemVzICk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpbWFnZVxuICAgICAgICAgICAgICAgICAgICAuYXR0ciggJ3NyYycsIGltYWdlU291cmNlIClcbiAgICAgICAgICAgICAgICAgICAgLnJlbW92ZUF0dHIoJ2RhdGEtbGF6eSBkYXRhLXNyY3NldCBkYXRhLXNpemVzJylcbiAgICAgICAgICAgICAgICAgICAgLnJlbW92ZUNsYXNzKCdzbGljay1sb2FkaW5nJyk7XG5cbiAgICAgICAgICAgICAgICBpZiAoIF8ub3B0aW9ucy5hZGFwdGl2ZUhlaWdodCA9PT0gdHJ1ZSApIHtcbiAgICAgICAgICAgICAgICAgICAgXy5zZXRQb3NpdGlvbigpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIF8uJHNsaWRlci50cmlnZ2VyKCdsYXp5TG9hZGVkJywgWyBfLCBpbWFnZSwgaW1hZ2VTb3VyY2UgXSk7XG4gICAgICAgICAgICAgICAgXy5wcm9ncmVzc2l2ZUxhenlMb2FkKCk7XG5cbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIGltYWdlVG9Mb2FkLm9uZXJyb3IgPSBmdW5jdGlvbigpIHtcblxuICAgICAgICAgICAgICAgIGlmICggdHJ5Q291bnQgPCAzICkge1xuXG4gICAgICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAgICAgKiB0cnkgdG8gbG9hZCB0aGUgaW1hZ2UgMyB0aW1lcyxcbiAgICAgICAgICAgICAgICAgICAgICogbGVhdmUgYSBzbGlnaHQgZGVsYXkgc28gd2UgZG9uJ3QgZ2V0XG4gICAgICAgICAgICAgICAgICAgICAqIHNlcnZlcnMgYmxvY2tpbmcgdGhlIHJlcXVlc3QuXG4gICAgICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF8ucHJvZ3Jlc3NpdmVMYXp5TG9hZCggdHJ5Q291bnQgKyAxICk7XG4gICAgICAgICAgICAgICAgICAgIH0sIDUwMCApO1xuXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgICAgICAgICBpbWFnZVxuICAgICAgICAgICAgICAgICAgICAgICAgLnJlbW92ZUF0dHIoICdkYXRhLWxhenknIClcbiAgICAgICAgICAgICAgICAgICAgICAgIC5yZW1vdmVDbGFzcyggJ3NsaWNrLWxvYWRpbmcnIClcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hZGRDbGFzcyggJ3NsaWNrLWxhenlsb2FkLWVycm9yJyApO1xuXG4gICAgICAgICAgICAgICAgICAgIF8uJHNsaWRlci50cmlnZ2VyKCdsYXp5TG9hZEVycm9yJywgWyBfLCBpbWFnZSwgaW1hZ2VTb3VyY2UgXSk7XG5cbiAgICAgICAgICAgICAgICAgICAgXy5wcm9ncmVzc2l2ZUxhenlMb2FkKCk7XG5cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIGltYWdlVG9Mb2FkLnNyYyA9IGltYWdlU291cmNlO1xuXG4gICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgIF8uJHNsaWRlci50cmlnZ2VyKCdhbGxJbWFnZXNMb2FkZWQnLCBbIF8gXSk7XG5cbiAgICAgICAgfVxuXG4gICAgfTtcblxuICAgIFNsaWNrLnByb3RvdHlwZS5yZWZyZXNoID0gZnVuY3Rpb24oIGluaXRpYWxpemluZyApIHtcblxuICAgICAgICB2YXIgXyA9IHRoaXMsIGN1cnJlbnRTbGlkZSwgbGFzdFZpc2libGVJbmRleDtcblxuICAgICAgICBsYXN0VmlzaWJsZUluZGV4ID0gXy5zbGlkZUNvdW50IC0gXy5vcHRpb25zLnNsaWRlc1RvU2hvdztcblxuICAgICAgICAvLyBpbiBub24taW5maW5pdGUgc2xpZGVycywgd2UgZG9uJ3Qgd2FudCB0byBnbyBwYXN0IHRoZVxuICAgICAgICAvLyBsYXN0IHZpc2libGUgaW5kZXguXG4gICAgICAgIGlmKCAhXy5vcHRpb25zLmluZmluaXRlICYmICggXy5jdXJyZW50U2xpZGUgPiBsYXN0VmlzaWJsZUluZGV4ICkpIHtcbiAgICAgICAgICAgIF8uY3VycmVudFNsaWRlID0gbGFzdFZpc2libGVJbmRleDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGlmIGxlc3Mgc2xpZGVzIHRoYW4gdG8gc2hvdywgZ28gdG8gc3RhcnQuXG4gICAgICAgIGlmICggXy5zbGlkZUNvdW50IDw9IF8ub3B0aW9ucy5zbGlkZXNUb1Nob3cgKSB7XG4gICAgICAgICAgICBfLmN1cnJlbnRTbGlkZSA9IDA7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIGN1cnJlbnRTbGlkZSA9IF8uY3VycmVudFNsaWRlO1xuXG4gICAgICAgIF8uZGVzdHJveSh0cnVlKTtcblxuICAgICAgICAkLmV4dGVuZChfLCBfLmluaXRpYWxzLCB7IGN1cnJlbnRTbGlkZTogY3VycmVudFNsaWRlIH0pO1xuXG4gICAgICAgIF8uaW5pdCgpO1xuXG4gICAgICAgIGlmKCAhaW5pdGlhbGl6aW5nICkge1xuXG4gICAgICAgICAgICBfLmNoYW5nZVNsaWRlKHtcbiAgICAgICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6ICdpbmRleCcsXG4gICAgICAgICAgICAgICAgICAgIGluZGV4OiBjdXJyZW50U2xpZGVcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCBmYWxzZSk7XG5cbiAgICAgICAgfVxuXG4gICAgfTtcblxuICAgIFNsaWNrLnByb3RvdHlwZS5yZWdpc3RlckJyZWFrcG9pbnRzID0gZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdmFyIF8gPSB0aGlzLCBicmVha3BvaW50LCBjdXJyZW50QnJlYWtwb2ludCwgbCxcbiAgICAgICAgICAgIHJlc3BvbnNpdmVTZXR0aW5ncyA9IF8ub3B0aW9ucy5yZXNwb25zaXZlIHx8IG51bGw7XG5cbiAgICAgICAgaWYgKCAkLnR5cGUocmVzcG9uc2l2ZVNldHRpbmdzKSA9PT0gJ2FycmF5JyAmJiByZXNwb25zaXZlU2V0dGluZ3MubGVuZ3RoICkge1xuXG4gICAgICAgICAgICBfLnJlc3BvbmRUbyA9IF8ub3B0aW9ucy5yZXNwb25kVG8gfHwgJ3dpbmRvdyc7XG5cbiAgICAgICAgICAgIGZvciAoIGJyZWFrcG9pbnQgaW4gcmVzcG9uc2l2ZVNldHRpbmdzICkge1xuXG4gICAgICAgICAgICAgICAgbCA9IF8uYnJlYWtwb2ludHMubGVuZ3RoLTE7XG5cbiAgICAgICAgICAgICAgICBpZiAocmVzcG9uc2l2ZVNldHRpbmdzLmhhc093blByb3BlcnR5KGJyZWFrcG9pbnQpKSB7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRCcmVha3BvaW50ID0gcmVzcG9uc2l2ZVNldHRpbmdzW2JyZWFrcG9pbnRdLmJyZWFrcG9pbnQ7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gbG9vcCB0aHJvdWdoIHRoZSBicmVha3BvaW50cyBhbmQgY3V0IG91dCBhbnkgZXhpc3RpbmdcbiAgICAgICAgICAgICAgICAgICAgLy8gb25lcyB3aXRoIHRoZSBzYW1lIGJyZWFrcG9pbnQgbnVtYmVyLCB3ZSBkb24ndCB3YW50IGR1cGVzLlxuICAgICAgICAgICAgICAgICAgICB3aGlsZSggbCA+PSAwICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYoIF8uYnJlYWtwb2ludHNbbF0gJiYgXy5icmVha3BvaW50c1tsXSA9PT0gY3VycmVudEJyZWFrcG9pbnQgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXy5icmVha3BvaW50cy5zcGxpY2UobCwxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGwtLTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIF8uYnJlYWtwb2ludHMucHVzaChjdXJyZW50QnJlYWtwb2ludCk7XG4gICAgICAgICAgICAgICAgICAgIF8uYnJlYWtwb2ludFNldHRpbmdzW2N1cnJlbnRCcmVha3BvaW50XSA9IHJlc3BvbnNpdmVTZXR0aW5nc1ticmVha3BvaW50XS5zZXR0aW5ncztcblxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBfLmJyZWFrcG9pbnRzLnNvcnQoZnVuY3Rpb24oYSwgYikge1xuICAgICAgICAgICAgICAgIHJldHVybiAoIF8ub3B0aW9ucy5tb2JpbGVGaXJzdCApID8gYS1iIDogYi1hO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgfVxuXG4gICAgfTtcblxuICAgIFNsaWNrLnByb3RvdHlwZS5yZWluaXQgPSBmdW5jdGlvbigpIHtcblxuICAgICAgICB2YXIgXyA9IHRoaXM7XG5cbiAgICAgICAgXy4kc2xpZGVzID1cbiAgICAgICAgICAgIF8uJHNsaWRlVHJhY2tcbiAgICAgICAgICAgICAgICAuY2hpbGRyZW4oXy5vcHRpb25zLnNsaWRlKVxuICAgICAgICAgICAgICAgIC5hZGRDbGFzcygnc2xpY2stc2xpZGUnKTtcblxuICAgICAgICBfLnNsaWRlQ291bnQgPSBfLiRzbGlkZXMubGVuZ3RoO1xuXG4gICAgICAgIGlmIChfLmN1cnJlbnRTbGlkZSA+PSBfLnNsaWRlQ291bnQgJiYgXy5jdXJyZW50U2xpZGUgIT09IDApIHtcbiAgICAgICAgICAgIF8uY3VycmVudFNsaWRlID0gXy5jdXJyZW50U2xpZGUgLSBfLm9wdGlvbnMuc2xpZGVzVG9TY3JvbGw7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoXy5zbGlkZUNvdW50IDw9IF8ub3B0aW9ucy5zbGlkZXNUb1Nob3cpIHtcbiAgICAgICAgICAgIF8uY3VycmVudFNsaWRlID0gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIF8ucmVnaXN0ZXJCcmVha3BvaW50cygpO1xuXG4gICAgICAgIF8uc2V0UHJvcHMoKTtcbiAgICAgICAgXy5zZXR1cEluZmluaXRlKCk7XG4gICAgICAgIF8uYnVpbGRBcnJvd3MoKTtcbiAgICAgICAgXy51cGRhdGVBcnJvd3MoKTtcbiAgICAgICAgXy5pbml0QXJyb3dFdmVudHMoKTtcbiAgICAgICAgXy5idWlsZERvdHMoKTtcbiAgICAgICAgXy51cGRhdGVEb3RzKCk7XG4gICAgICAgIF8uaW5pdERvdEV2ZW50cygpO1xuICAgICAgICBfLmNsZWFuVXBTbGlkZUV2ZW50cygpO1xuICAgICAgICBfLmluaXRTbGlkZUV2ZW50cygpO1xuXG4gICAgICAgIF8uY2hlY2tSZXNwb25zaXZlKGZhbHNlLCB0cnVlKTtcblxuICAgICAgICBpZiAoXy5vcHRpb25zLmZvY3VzT25TZWxlY3QgPT09IHRydWUpIHtcbiAgICAgICAgICAgICQoXy4kc2xpZGVUcmFjaykuY2hpbGRyZW4oKS5vbignY2xpY2suc2xpY2snLCBfLnNlbGVjdEhhbmRsZXIpO1xuICAgICAgICB9XG5cbiAgICAgICAgXy5zZXRTbGlkZUNsYXNzZXModHlwZW9mIF8uY3VycmVudFNsaWRlID09PSAnbnVtYmVyJyA/IF8uY3VycmVudFNsaWRlIDogMCk7XG5cbiAgICAgICAgXy5zZXRQb3NpdGlvbigpO1xuICAgICAgICBfLmZvY3VzSGFuZGxlcigpO1xuXG4gICAgICAgIF8ucGF1c2VkID0gIV8ub3B0aW9ucy5hdXRvcGxheTtcbiAgICAgICAgXy5hdXRvUGxheSgpO1xuXG4gICAgICAgIF8uJHNsaWRlci50cmlnZ2VyKCdyZUluaXQnLCBbX10pO1xuXG4gICAgfTtcblxuICAgIFNsaWNrLnByb3RvdHlwZS5yZXNpemUgPSBmdW5jdGlvbigpIHtcblxuICAgICAgICB2YXIgXyA9IHRoaXM7XG5cbiAgICAgICAgaWYgKCQod2luZG93KS53aWR0aCgpICE9PSBfLndpbmRvd1dpZHRoKSB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQoXy53aW5kb3dEZWxheSk7XG4gICAgICAgICAgICBfLndpbmRvd0RlbGF5ID0gd2luZG93LnNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgXy53aW5kb3dXaWR0aCA9ICQod2luZG93KS53aWR0aCgpO1xuICAgICAgICAgICAgICAgIF8uY2hlY2tSZXNwb25zaXZlKCk7XG4gICAgICAgICAgICAgICAgaWYoICFfLnVuc2xpY2tlZCApIHsgXy5zZXRQb3NpdGlvbigpOyB9XG4gICAgICAgICAgICB9LCA1MCk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgU2xpY2sucHJvdG90eXBlLnJlbW92ZVNsaWRlID0gU2xpY2sucHJvdG90eXBlLnNsaWNrUmVtb3ZlID0gZnVuY3Rpb24oaW5kZXgsIHJlbW92ZUJlZm9yZSwgcmVtb3ZlQWxsKSB7XG5cbiAgICAgICAgdmFyIF8gPSB0aGlzO1xuXG4gICAgICAgIGlmICh0eXBlb2YoaW5kZXgpID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgIHJlbW92ZUJlZm9yZSA9IGluZGV4O1xuICAgICAgICAgICAgaW5kZXggPSByZW1vdmVCZWZvcmUgPT09IHRydWUgPyAwIDogXy5zbGlkZUNvdW50IC0gMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGluZGV4ID0gcmVtb3ZlQmVmb3JlID09PSB0cnVlID8gLS1pbmRleCA6IGluZGV4O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKF8uc2xpZGVDb3VudCA8IDEgfHwgaW5kZXggPCAwIHx8IGluZGV4ID4gXy5zbGlkZUNvdW50IC0gMSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgXy51bmxvYWQoKTtcblxuICAgICAgICBpZiAocmVtb3ZlQWxsID09PSB0cnVlKSB7XG4gICAgICAgICAgICBfLiRzbGlkZVRyYWNrLmNoaWxkcmVuKCkucmVtb3ZlKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBfLiRzbGlkZVRyYWNrLmNoaWxkcmVuKHRoaXMub3B0aW9ucy5zbGlkZSkuZXEoaW5kZXgpLnJlbW92ZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgXy4kc2xpZGVzID0gXy4kc2xpZGVUcmFjay5jaGlsZHJlbih0aGlzLm9wdGlvbnMuc2xpZGUpO1xuXG4gICAgICAgIF8uJHNsaWRlVHJhY2suY2hpbGRyZW4odGhpcy5vcHRpb25zLnNsaWRlKS5kZXRhY2goKTtcblxuICAgICAgICBfLiRzbGlkZVRyYWNrLmFwcGVuZChfLiRzbGlkZXMpO1xuXG4gICAgICAgIF8uJHNsaWRlc0NhY2hlID0gXy4kc2xpZGVzO1xuXG4gICAgICAgIF8ucmVpbml0KCk7XG5cbiAgICB9O1xuXG4gICAgU2xpY2sucHJvdG90eXBlLnNldENTUyA9IGZ1bmN0aW9uKHBvc2l0aW9uKSB7XG5cbiAgICAgICAgdmFyIF8gPSB0aGlzLFxuICAgICAgICAgICAgcG9zaXRpb25Qcm9wcyA9IHt9LFxuICAgICAgICAgICAgeCwgeTtcblxuICAgICAgICBpZiAoXy5vcHRpb25zLnJ0bCA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgcG9zaXRpb24gPSAtcG9zaXRpb247XG4gICAgICAgIH1cbiAgICAgICAgeCA9IF8ucG9zaXRpb25Qcm9wID09ICdsZWZ0JyA/IE1hdGguY2VpbChwb3NpdGlvbikgKyAncHgnIDogJzBweCc7XG4gICAgICAgIHkgPSBfLnBvc2l0aW9uUHJvcCA9PSAndG9wJyA/IE1hdGguY2VpbChwb3NpdGlvbikgKyAncHgnIDogJzBweCc7XG5cbiAgICAgICAgcG9zaXRpb25Qcm9wc1tfLnBvc2l0aW9uUHJvcF0gPSBwb3NpdGlvbjtcblxuICAgICAgICBpZiAoXy50cmFuc2Zvcm1zRW5hYmxlZCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIF8uJHNsaWRlVHJhY2suY3NzKHBvc2l0aW9uUHJvcHMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcG9zaXRpb25Qcm9wcyA9IHt9O1xuICAgICAgICAgICAgaWYgKF8uY3NzVHJhbnNpdGlvbnMgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgcG9zaXRpb25Qcm9wc1tfLmFuaW1UeXBlXSA9ICd0cmFuc2xhdGUoJyArIHggKyAnLCAnICsgeSArICcpJztcbiAgICAgICAgICAgICAgICBfLiRzbGlkZVRyYWNrLmNzcyhwb3NpdGlvblByb3BzKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcG9zaXRpb25Qcm9wc1tfLmFuaW1UeXBlXSA9ICd0cmFuc2xhdGUzZCgnICsgeCArICcsICcgKyB5ICsgJywgMHB4KSc7XG4gICAgICAgICAgICAgICAgXy4kc2xpZGVUcmFjay5jc3MocG9zaXRpb25Qcm9wcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgIH07XG5cbiAgICBTbGljay5wcm90b3R5cGUuc2V0RGltZW5zaW9ucyA9IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHZhciBfID0gdGhpcztcblxuICAgICAgICBpZiAoXy5vcHRpb25zLnZlcnRpY2FsID09PSBmYWxzZSkge1xuICAgICAgICAgICAgaWYgKF8ub3B0aW9ucy5jZW50ZXJNb2RlID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgXy4kbGlzdC5jc3Moe1xuICAgICAgICAgICAgICAgICAgICBwYWRkaW5nOiAoJzBweCAnICsgXy5vcHRpb25zLmNlbnRlclBhZGRpbmcpXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBfLiRsaXN0LmhlaWdodChfLiRzbGlkZXMuZmlyc3QoKS5vdXRlckhlaWdodCh0cnVlKSAqIF8ub3B0aW9ucy5zbGlkZXNUb1Nob3cpO1xuICAgICAgICAgICAgaWYgKF8ub3B0aW9ucy5jZW50ZXJNb2RlID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgXy4kbGlzdC5jc3Moe1xuICAgICAgICAgICAgICAgICAgICBwYWRkaW5nOiAoXy5vcHRpb25zLmNlbnRlclBhZGRpbmcgKyAnIDBweCcpXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBfLmxpc3RXaWR0aCA9IF8uJGxpc3Qud2lkdGgoKTtcbiAgICAgICAgXy5saXN0SGVpZ2h0ID0gXy4kbGlzdC5oZWlnaHQoKTtcblxuXG4gICAgICAgIGlmIChfLm9wdGlvbnMudmVydGljYWwgPT09IGZhbHNlICYmIF8ub3B0aW9ucy52YXJpYWJsZVdpZHRoID09PSBmYWxzZSkge1xuICAgICAgICAgICAgXy5zbGlkZVdpZHRoID0gTWF0aC5jZWlsKF8ubGlzdFdpZHRoIC8gXy5vcHRpb25zLnNsaWRlc1RvU2hvdyk7XG4gICAgICAgICAgICBfLiRzbGlkZVRyYWNrLndpZHRoKE1hdGguY2VpbCgoXy5zbGlkZVdpZHRoICogXy4kc2xpZGVUcmFjay5jaGlsZHJlbignLnNsaWNrLXNsaWRlJykubGVuZ3RoKSkpO1xuXG4gICAgICAgIH0gZWxzZSBpZiAoXy5vcHRpb25zLnZhcmlhYmxlV2lkdGggPT09IHRydWUpIHtcbiAgICAgICAgICAgIF8uJHNsaWRlVHJhY2sud2lkdGgoNTAwMCAqIF8uc2xpZGVDb3VudCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBfLnNsaWRlV2lkdGggPSBNYXRoLmNlaWwoXy5saXN0V2lkdGgpO1xuICAgICAgICAgICAgXy4kc2xpZGVUcmFjay5oZWlnaHQoTWF0aC5jZWlsKChfLiRzbGlkZXMuZmlyc3QoKS5vdXRlckhlaWdodCh0cnVlKSAqIF8uJHNsaWRlVHJhY2suY2hpbGRyZW4oJy5zbGljay1zbGlkZScpLmxlbmd0aCkpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBvZmZzZXQgPSBfLiRzbGlkZXMuZmlyc3QoKS5vdXRlcldpZHRoKHRydWUpIC0gXy4kc2xpZGVzLmZpcnN0KCkud2lkdGgoKTtcbiAgICAgICAgaWYgKF8ub3B0aW9ucy52YXJpYWJsZVdpZHRoID09PSBmYWxzZSkgXy4kc2xpZGVUcmFjay5jaGlsZHJlbignLnNsaWNrLXNsaWRlJykud2lkdGgoXy5zbGlkZVdpZHRoIC0gb2Zmc2V0KTtcblxuICAgIH07XG5cbiAgICBTbGljay5wcm90b3R5cGUuc2V0RmFkZSA9IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHZhciBfID0gdGhpcyxcbiAgICAgICAgICAgIHRhcmdldExlZnQ7XG5cbiAgICAgICAgXy4kc2xpZGVzLmVhY2goZnVuY3Rpb24oaW5kZXgsIGVsZW1lbnQpIHtcbiAgICAgICAgICAgIHRhcmdldExlZnQgPSAoXy5zbGlkZVdpZHRoICogaW5kZXgpICogLTE7XG4gICAgICAgICAgICBpZiAoXy5vcHRpb25zLnJ0bCA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgICQoZWxlbWVudCkuY3NzKHtcbiAgICAgICAgICAgICAgICAgICAgcG9zaXRpb246ICdyZWxhdGl2ZScsXG4gICAgICAgICAgICAgICAgICAgIHJpZ2h0OiB0YXJnZXRMZWZ0LFxuICAgICAgICAgICAgICAgICAgICB0b3A6IDAsXG4gICAgICAgICAgICAgICAgICAgIHpJbmRleDogXy5vcHRpb25zLnpJbmRleCAtIDIsXG4gICAgICAgICAgICAgICAgICAgIG9wYWNpdHk6IDBcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgJChlbGVtZW50KS5jc3Moe1xuICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbjogJ3JlbGF0aXZlJyxcbiAgICAgICAgICAgICAgICAgICAgbGVmdDogdGFyZ2V0TGVmdCxcbiAgICAgICAgICAgICAgICAgICAgdG9wOiAwLFxuICAgICAgICAgICAgICAgICAgICB6SW5kZXg6IF8ub3B0aW9ucy56SW5kZXggLSAyLFxuICAgICAgICAgICAgICAgICAgICBvcGFjaXR5OiAwXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIF8uJHNsaWRlcy5lcShfLmN1cnJlbnRTbGlkZSkuY3NzKHtcbiAgICAgICAgICAgIHpJbmRleDogXy5vcHRpb25zLnpJbmRleCAtIDEsXG4gICAgICAgICAgICBvcGFjaXR5OiAxXG4gICAgICAgIH0pO1xuXG4gICAgfTtcblxuICAgIFNsaWNrLnByb3RvdHlwZS5zZXRIZWlnaHQgPSBmdW5jdGlvbigpIHtcblxuICAgICAgICB2YXIgXyA9IHRoaXM7XG5cbiAgICAgICAgaWYgKF8ub3B0aW9ucy5zbGlkZXNUb1Nob3cgPT09IDEgJiYgXy5vcHRpb25zLmFkYXB0aXZlSGVpZ2h0ID09PSB0cnVlICYmIF8ub3B0aW9ucy52ZXJ0aWNhbCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHZhciB0YXJnZXRIZWlnaHQgPSBfLiRzbGlkZXMuZXEoXy5jdXJyZW50U2xpZGUpLm91dGVySGVpZ2h0KHRydWUpO1xuICAgICAgICAgICAgXy4kbGlzdC5jc3MoJ2hlaWdodCcsIHRhcmdldEhlaWdodCk7XG4gICAgICAgIH1cblxuICAgIH07XG5cbiAgICBTbGljay5wcm90b3R5cGUuc2V0T3B0aW9uID1cbiAgICBTbGljay5wcm90b3R5cGUuc2xpY2tTZXRPcHRpb24gPSBmdW5jdGlvbigpIHtcblxuICAgICAgICAvKipcbiAgICAgICAgICogYWNjZXB0cyBhcmd1bWVudHMgaW4gZm9ybWF0IG9mOlxuICAgICAgICAgKlxuICAgICAgICAgKiAgLSBmb3IgY2hhbmdpbmcgYSBzaW5nbGUgb3B0aW9uJ3MgdmFsdWU6XG4gICAgICAgICAqICAgICAuc2xpY2soXCJzZXRPcHRpb25cIiwgb3B0aW9uLCB2YWx1ZSwgcmVmcmVzaCApXG4gICAgICAgICAqXG4gICAgICAgICAqICAtIGZvciBjaGFuZ2luZyBhIHNldCBvZiByZXNwb25zaXZlIG9wdGlvbnM6XG4gICAgICAgICAqICAgICAuc2xpY2soXCJzZXRPcHRpb25cIiwgJ3Jlc3BvbnNpdmUnLCBbe30sIC4uLl0sIHJlZnJlc2ggKVxuICAgICAgICAgKlxuICAgICAgICAgKiAgLSBmb3IgdXBkYXRpbmcgbXVsdGlwbGUgdmFsdWVzIGF0IG9uY2UgKG5vdCByZXNwb25zaXZlKVxuICAgICAgICAgKiAgICAgLnNsaWNrKFwic2V0T3B0aW9uXCIsIHsgJ29wdGlvbic6IHZhbHVlLCAuLi4gfSwgcmVmcmVzaCApXG4gICAgICAgICAqL1xuXG4gICAgICAgIHZhciBfID0gdGhpcywgbCwgaXRlbSwgb3B0aW9uLCB2YWx1ZSwgcmVmcmVzaCA9IGZhbHNlLCB0eXBlO1xuXG4gICAgICAgIGlmKCAkLnR5cGUoIGFyZ3VtZW50c1swXSApID09PSAnb2JqZWN0JyApIHtcblxuICAgICAgICAgICAgb3B0aW9uID0gIGFyZ3VtZW50c1swXTtcbiAgICAgICAgICAgIHJlZnJlc2ggPSBhcmd1bWVudHNbMV07XG4gICAgICAgICAgICB0eXBlID0gJ211bHRpcGxlJztcblxuICAgICAgICB9IGVsc2UgaWYgKCAkLnR5cGUoIGFyZ3VtZW50c1swXSApID09PSAnc3RyaW5nJyApIHtcblxuICAgICAgICAgICAgb3B0aW9uID0gIGFyZ3VtZW50c1swXTtcbiAgICAgICAgICAgIHZhbHVlID0gYXJndW1lbnRzWzFdO1xuICAgICAgICAgICAgcmVmcmVzaCA9IGFyZ3VtZW50c1syXTtcblxuICAgICAgICAgICAgaWYgKCBhcmd1bWVudHNbMF0gPT09ICdyZXNwb25zaXZlJyAmJiAkLnR5cGUoIGFyZ3VtZW50c1sxXSApID09PSAnYXJyYXknICkge1xuXG4gICAgICAgICAgICAgICAgdHlwZSA9ICdyZXNwb25zaXZlJztcblxuICAgICAgICAgICAgfSBlbHNlIGlmICggdHlwZW9mIGFyZ3VtZW50c1sxXSAhPT0gJ3VuZGVmaW5lZCcgKSB7XG5cbiAgICAgICAgICAgICAgICB0eXBlID0gJ3NpbmdsZSc7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCB0eXBlID09PSAnc2luZ2xlJyApIHtcblxuICAgICAgICAgICAgXy5vcHRpb25zW29wdGlvbl0gPSB2YWx1ZTtcblxuXG4gICAgICAgIH0gZWxzZSBpZiAoIHR5cGUgPT09ICdtdWx0aXBsZScgKSB7XG5cbiAgICAgICAgICAgICQuZWFjaCggb3B0aW9uICwgZnVuY3Rpb24oIG9wdCwgdmFsICkge1xuXG4gICAgICAgICAgICAgICAgXy5vcHRpb25zW29wdF0gPSB2YWw7XG5cbiAgICAgICAgICAgIH0pO1xuXG5cbiAgICAgICAgfSBlbHNlIGlmICggdHlwZSA9PT0gJ3Jlc3BvbnNpdmUnICkge1xuXG4gICAgICAgICAgICBmb3IgKCBpdGVtIGluIHZhbHVlICkge1xuXG4gICAgICAgICAgICAgICAgaWYoICQudHlwZSggXy5vcHRpb25zLnJlc3BvbnNpdmUgKSAhPT0gJ2FycmF5JyApIHtcblxuICAgICAgICAgICAgICAgICAgICBfLm9wdGlvbnMucmVzcG9uc2l2ZSA9IFsgdmFsdWVbaXRlbV0gXTtcblxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgICAgICAgICAgbCA9IF8ub3B0aW9ucy5yZXNwb25zaXZlLmxlbmd0aC0xO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIGxvb3AgdGhyb3VnaCB0aGUgcmVzcG9uc2l2ZSBvYmplY3QgYW5kIHNwbGljZSBvdXQgZHVwbGljYXRlcy5cbiAgICAgICAgICAgICAgICAgICAgd2hpbGUoIGwgPj0gMCApIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYoIF8ub3B0aW9ucy5yZXNwb25zaXZlW2xdLmJyZWFrcG9pbnQgPT09IHZhbHVlW2l0ZW1dLmJyZWFrcG9pbnQgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfLm9wdGlvbnMucmVzcG9uc2l2ZS5zcGxpY2UobCwxKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBsLS07XG5cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIF8ub3B0aW9ucy5yZXNwb25zaXZlLnB1c2goIHZhbHVlW2l0ZW1dICk7XG5cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCByZWZyZXNoICkge1xuXG4gICAgICAgICAgICBfLnVubG9hZCgpO1xuICAgICAgICAgICAgXy5yZWluaXQoKTtcblxuICAgICAgICB9XG5cbiAgICB9O1xuXG4gICAgU2xpY2sucHJvdG90eXBlLnNldFBvc2l0aW9uID0gZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdmFyIF8gPSB0aGlzO1xuXG4gICAgICAgIF8uc2V0RGltZW5zaW9ucygpO1xuXG4gICAgICAgIF8uc2V0SGVpZ2h0KCk7XG5cbiAgICAgICAgaWYgKF8ub3B0aW9ucy5mYWRlID09PSBmYWxzZSkge1xuICAgICAgICAgICAgXy5zZXRDU1MoXy5nZXRMZWZ0KF8uY3VycmVudFNsaWRlKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBfLnNldEZhZGUoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIF8uJHNsaWRlci50cmlnZ2VyKCdzZXRQb3NpdGlvbicsIFtfXSk7XG5cbiAgICB9O1xuXG4gICAgU2xpY2sucHJvdG90eXBlLnNldFByb3BzID0gZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdmFyIF8gPSB0aGlzLFxuICAgICAgICAgICAgYm9keVN0eWxlID0gZG9jdW1lbnQuYm9keS5zdHlsZTtcblxuICAgICAgICBfLnBvc2l0aW9uUHJvcCA9IF8ub3B0aW9ucy52ZXJ0aWNhbCA9PT0gdHJ1ZSA/ICd0b3AnIDogJ2xlZnQnO1xuXG4gICAgICAgIGlmIChfLnBvc2l0aW9uUHJvcCA9PT0gJ3RvcCcpIHtcbiAgICAgICAgICAgIF8uJHNsaWRlci5hZGRDbGFzcygnc2xpY2stdmVydGljYWwnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIF8uJHNsaWRlci5yZW1vdmVDbGFzcygnc2xpY2stdmVydGljYWwnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChib2R5U3R5bGUuV2Via2l0VHJhbnNpdGlvbiAhPT0gdW5kZWZpbmVkIHx8XG4gICAgICAgICAgICBib2R5U3R5bGUuTW96VHJhbnNpdGlvbiAhPT0gdW5kZWZpbmVkIHx8XG4gICAgICAgICAgICBib2R5U3R5bGUubXNUcmFuc2l0aW9uICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGlmIChfLm9wdGlvbnMudXNlQ1NTID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgXy5jc3NUcmFuc2l0aW9ucyA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIF8ub3B0aW9ucy5mYWRlICkge1xuICAgICAgICAgICAgaWYgKCB0eXBlb2YgXy5vcHRpb25zLnpJbmRleCA9PT0gJ251bWJlcicgKSB7XG4gICAgICAgICAgICAgICAgaWYoIF8ub3B0aW9ucy56SW5kZXggPCAzICkge1xuICAgICAgICAgICAgICAgICAgICBfLm9wdGlvbnMuekluZGV4ID0gMztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIF8ub3B0aW9ucy56SW5kZXggPSBfLmRlZmF1bHRzLnpJbmRleDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChib2R5U3R5bGUuT1RyYW5zZm9ybSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBfLmFuaW1UeXBlID0gJ09UcmFuc2Zvcm0nO1xuICAgICAgICAgICAgXy50cmFuc2Zvcm1UeXBlID0gJy1vLXRyYW5zZm9ybSc7XG4gICAgICAgICAgICBfLnRyYW5zaXRpb25UeXBlID0gJ09UcmFuc2l0aW9uJztcbiAgICAgICAgICAgIGlmIChib2R5U3R5bGUucGVyc3BlY3RpdmVQcm9wZXJ0eSA9PT0gdW5kZWZpbmVkICYmIGJvZHlTdHlsZS53ZWJraXRQZXJzcGVjdGl2ZSA9PT0gdW5kZWZpbmVkKSBfLmFuaW1UeXBlID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGJvZHlTdHlsZS5Nb3pUcmFuc2Zvcm0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgXy5hbmltVHlwZSA9ICdNb3pUcmFuc2Zvcm0nO1xuICAgICAgICAgICAgXy50cmFuc2Zvcm1UeXBlID0gJy1tb3otdHJhbnNmb3JtJztcbiAgICAgICAgICAgIF8udHJhbnNpdGlvblR5cGUgPSAnTW96VHJhbnNpdGlvbic7XG4gICAgICAgICAgICBpZiAoYm9keVN0eWxlLnBlcnNwZWN0aXZlUHJvcGVydHkgPT09IHVuZGVmaW5lZCAmJiBib2R5U3R5bGUuTW96UGVyc3BlY3RpdmUgPT09IHVuZGVmaW5lZCkgXy5hbmltVHlwZSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChib2R5U3R5bGUud2Via2l0VHJhbnNmb3JtICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIF8uYW5pbVR5cGUgPSAnd2Via2l0VHJhbnNmb3JtJztcbiAgICAgICAgICAgIF8udHJhbnNmb3JtVHlwZSA9ICctd2Via2l0LXRyYW5zZm9ybSc7XG4gICAgICAgICAgICBfLnRyYW5zaXRpb25UeXBlID0gJ3dlYmtpdFRyYW5zaXRpb24nO1xuICAgICAgICAgICAgaWYgKGJvZHlTdHlsZS5wZXJzcGVjdGl2ZVByb3BlcnR5ID09PSB1bmRlZmluZWQgJiYgYm9keVN0eWxlLndlYmtpdFBlcnNwZWN0aXZlID09PSB1bmRlZmluZWQpIF8uYW5pbVR5cGUgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYm9keVN0eWxlLm1zVHJhbnNmb3JtICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIF8uYW5pbVR5cGUgPSAnbXNUcmFuc2Zvcm0nO1xuICAgICAgICAgICAgXy50cmFuc2Zvcm1UeXBlID0gJy1tcy10cmFuc2Zvcm0nO1xuICAgICAgICAgICAgXy50cmFuc2l0aW9uVHlwZSA9ICdtc1RyYW5zaXRpb24nO1xuICAgICAgICAgICAgaWYgKGJvZHlTdHlsZS5tc1RyYW5zZm9ybSA9PT0gdW5kZWZpbmVkKSBfLmFuaW1UeXBlID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGJvZHlTdHlsZS50cmFuc2Zvcm0gIT09IHVuZGVmaW5lZCAmJiBfLmFuaW1UeXBlICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgXy5hbmltVHlwZSA9ICd0cmFuc2Zvcm0nO1xuICAgICAgICAgICAgXy50cmFuc2Zvcm1UeXBlID0gJ3RyYW5zZm9ybSc7XG4gICAgICAgICAgICBfLnRyYW5zaXRpb25UeXBlID0gJ3RyYW5zaXRpb24nO1xuICAgICAgICB9XG4gICAgICAgIF8udHJhbnNmb3Jtc0VuYWJsZWQgPSBfLm9wdGlvbnMudXNlVHJhbnNmb3JtICYmIChfLmFuaW1UeXBlICE9PSBudWxsICYmIF8uYW5pbVR5cGUgIT09IGZhbHNlKTtcbiAgICB9O1xuXG5cbiAgICBTbGljay5wcm90b3R5cGUuc2V0U2xpZGVDbGFzc2VzID0gZnVuY3Rpb24oaW5kZXgpIHtcblxuICAgICAgICB2YXIgXyA9IHRoaXMsXG4gICAgICAgICAgICBjZW50ZXJPZmZzZXQsIGFsbFNsaWRlcywgaW5kZXhPZmZzZXQsIHJlbWFpbmRlcjtcblxuICAgICAgICBhbGxTbGlkZXMgPSBfLiRzbGlkZXJcbiAgICAgICAgICAgIC5maW5kKCcuc2xpY2stc2xpZGUnKVxuICAgICAgICAgICAgLnJlbW92ZUNsYXNzKCdzbGljay1hY3RpdmUgc2xpY2stY2VudGVyIHNsaWNrLWN1cnJlbnQnKVxuICAgICAgICAgICAgLmF0dHIoJ2FyaWEtaGlkZGVuJywgJ3RydWUnKTtcblxuICAgICAgICBfLiRzbGlkZXNcbiAgICAgICAgICAgIC5lcShpbmRleClcbiAgICAgICAgICAgIC5hZGRDbGFzcygnc2xpY2stY3VycmVudCcpO1xuXG4gICAgICAgIGlmIChfLm9wdGlvbnMuY2VudGVyTW9kZSA9PT0gdHJ1ZSkge1xuXG4gICAgICAgICAgICB2YXIgZXZlbkNvZWYgPSBfLm9wdGlvbnMuc2xpZGVzVG9TaG93ICUgMiA9PT0gMCA/IDEgOiAwO1xuXG4gICAgICAgICAgICBjZW50ZXJPZmZzZXQgPSBNYXRoLmZsb29yKF8ub3B0aW9ucy5zbGlkZXNUb1Nob3cgLyAyKTtcblxuICAgICAgICAgICAgaWYgKF8ub3B0aW9ucy5pbmZpbml0ZSA9PT0gdHJ1ZSkge1xuXG4gICAgICAgICAgICAgICAgaWYgKGluZGV4ID49IGNlbnRlck9mZnNldCAmJiBpbmRleCA8PSAoXy5zbGlkZUNvdW50IC0gMSkgLSBjZW50ZXJPZmZzZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgXy4kc2xpZGVzXG4gICAgICAgICAgICAgICAgICAgICAgICAuc2xpY2UoaW5kZXggLSBjZW50ZXJPZmZzZXQgKyBldmVuQ29lZiwgaW5kZXggKyBjZW50ZXJPZmZzZXQgKyAxKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmFkZENsYXNzKCdzbGljay1hY3RpdmUnKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ2FyaWEtaGlkZGVuJywgJ2ZhbHNlJyk7XG5cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICAgICAgICAgIGluZGV4T2Zmc2V0ID0gXy5vcHRpb25zLnNsaWRlc1RvU2hvdyArIGluZGV4O1xuICAgICAgICAgICAgICAgICAgICBhbGxTbGlkZXNcbiAgICAgICAgICAgICAgICAgICAgICAgIC5zbGljZShpbmRleE9mZnNldCAtIGNlbnRlck9mZnNldCArIDEgKyBldmVuQ29lZiwgaW5kZXhPZmZzZXQgKyBjZW50ZXJPZmZzZXQgKyAyKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmFkZENsYXNzKCdzbGljay1hY3RpdmUnKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ2FyaWEtaGlkZGVuJywgJ2ZhbHNlJyk7XG5cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoaW5kZXggPT09IDApIHtcblxuICAgICAgICAgICAgICAgICAgICBhbGxTbGlkZXNcbiAgICAgICAgICAgICAgICAgICAgICAgIC5lcShhbGxTbGlkZXMubGVuZ3RoIC0gMSAtIF8ub3B0aW9ucy5zbGlkZXNUb1Nob3cpXG4gICAgICAgICAgICAgICAgICAgICAgICAuYWRkQ2xhc3MoJ3NsaWNrLWNlbnRlcicpO1xuXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChpbmRleCA9PT0gXy5zbGlkZUNvdW50IC0gMSkge1xuXG4gICAgICAgICAgICAgICAgICAgIGFsbFNsaWRlc1xuICAgICAgICAgICAgICAgICAgICAgICAgLmVxKF8ub3B0aW9ucy5zbGlkZXNUb1Nob3cpXG4gICAgICAgICAgICAgICAgICAgICAgICAuYWRkQ2xhc3MoJ3NsaWNrLWNlbnRlcicpO1xuXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIF8uJHNsaWRlc1xuICAgICAgICAgICAgICAgIC5lcShpbmRleClcbiAgICAgICAgICAgICAgICAuYWRkQ2xhc3MoJ3NsaWNrLWNlbnRlcicpO1xuXG4gICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgIGlmIChpbmRleCA+PSAwICYmIGluZGV4IDw9IChfLnNsaWRlQ291bnQgLSBfLm9wdGlvbnMuc2xpZGVzVG9TaG93KSkge1xuXG4gICAgICAgICAgICAgICAgXy4kc2xpZGVzXG4gICAgICAgICAgICAgICAgICAgIC5zbGljZShpbmRleCwgaW5kZXggKyBfLm9wdGlvbnMuc2xpZGVzVG9TaG93KVxuICAgICAgICAgICAgICAgICAgICAuYWRkQ2xhc3MoJ3NsaWNrLWFjdGl2ZScpXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCdhcmlhLWhpZGRlbicsICdmYWxzZScpO1xuXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGFsbFNsaWRlcy5sZW5ndGggPD0gXy5vcHRpb25zLnNsaWRlc1RvU2hvdykge1xuXG4gICAgICAgICAgICAgICAgYWxsU2xpZGVzXG4gICAgICAgICAgICAgICAgICAgIC5hZGRDbGFzcygnc2xpY2stYWN0aXZlJylcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ2FyaWEtaGlkZGVuJywgJ2ZhbHNlJyk7XG5cbiAgICAgICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgICAgICByZW1haW5kZXIgPSBfLnNsaWRlQ291bnQgJSBfLm9wdGlvbnMuc2xpZGVzVG9TaG93O1xuICAgICAgICAgICAgICAgIGluZGV4T2Zmc2V0ID0gXy5vcHRpb25zLmluZmluaXRlID09PSB0cnVlID8gXy5vcHRpb25zLnNsaWRlc1RvU2hvdyArIGluZGV4IDogaW5kZXg7XG5cbiAgICAgICAgICAgICAgICBpZiAoXy5vcHRpb25zLnNsaWRlc1RvU2hvdyA9PSBfLm9wdGlvbnMuc2xpZGVzVG9TY3JvbGwgJiYgKF8uc2xpZGVDb3VudCAtIGluZGV4KSA8IF8ub3B0aW9ucy5zbGlkZXNUb1Nob3cpIHtcblxuICAgICAgICAgICAgICAgICAgICBhbGxTbGlkZXNcbiAgICAgICAgICAgICAgICAgICAgICAgIC5zbGljZShpbmRleE9mZnNldCAtIChfLm9wdGlvbnMuc2xpZGVzVG9TaG93IC0gcmVtYWluZGVyKSwgaW5kZXhPZmZzZXQgKyByZW1haW5kZXIpXG4gICAgICAgICAgICAgICAgICAgICAgICAuYWRkQ2xhc3MoJ3NsaWNrLWFjdGl2ZScpXG4gICAgICAgICAgICAgICAgICAgICAgICAuYXR0cignYXJpYS1oaWRkZW4nLCAnZmFsc2UnKTtcblxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgICAgICAgICAgYWxsU2xpZGVzXG4gICAgICAgICAgICAgICAgICAgICAgICAuc2xpY2UoaW5kZXhPZmZzZXQsIGluZGV4T2Zmc2V0ICsgXy5vcHRpb25zLnNsaWRlc1RvU2hvdylcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hZGRDbGFzcygnc2xpY2stYWN0aXZlJylcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKCdhcmlhLWhpZGRlbicsICdmYWxzZScpO1xuXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChfLm9wdGlvbnMubGF6eUxvYWQgPT09ICdvbmRlbWFuZCcgfHwgXy5vcHRpb25zLmxhenlMb2FkID09PSAnYW50aWNpcGF0ZWQnKSB7XG4gICAgICAgICAgICBfLmxhenlMb2FkKCk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgU2xpY2sucHJvdG90eXBlLnNldHVwSW5maW5pdGUgPSBmdW5jdGlvbigpIHtcblxuICAgICAgICB2YXIgXyA9IHRoaXMsXG4gICAgICAgICAgICBpLCBzbGlkZUluZGV4LCBpbmZpbml0ZUNvdW50O1xuXG4gICAgICAgIGlmIChfLm9wdGlvbnMuZmFkZSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgXy5vcHRpb25zLmNlbnRlck1vZGUgPSBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChfLm9wdGlvbnMuaW5maW5pdGUgPT09IHRydWUgJiYgXy5vcHRpb25zLmZhZGUgPT09IGZhbHNlKSB7XG5cbiAgICAgICAgICAgIHNsaWRlSW5kZXggPSBudWxsO1xuXG4gICAgICAgICAgICBpZiAoXy5zbGlkZUNvdW50ID4gXy5vcHRpb25zLnNsaWRlc1RvU2hvdykge1xuXG4gICAgICAgICAgICAgICAgaWYgKF8ub3B0aW9ucy5jZW50ZXJNb2RlID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgIGluZmluaXRlQ291bnQgPSBfLm9wdGlvbnMuc2xpZGVzVG9TaG93ICsgMTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpbmZpbml0ZUNvdW50ID0gXy5vcHRpb25zLnNsaWRlc1RvU2hvdztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBmb3IgKGkgPSBfLnNsaWRlQ291bnQ7IGkgPiAoXy5zbGlkZUNvdW50IC1cbiAgICAgICAgICAgICAgICAgICAgICAgIGluZmluaXRlQ291bnQpOyBpIC09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgc2xpZGVJbmRleCA9IGkgLSAxO1xuICAgICAgICAgICAgICAgICAgICAkKF8uJHNsaWRlc1tzbGlkZUluZGV4XSkuY2xvbmUodHJ1ZSkuYXR0cignaWQnLCAnJylcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKCdkYXRhLXNsaWNrLWluZGV4Jywgc2xpZGVJbmRleCAtIF8uc2xpZGVDb3VudClcbiAgICAgICAgICAgICAgICAgICAgICAgIC5wcmVwZW5kVG8oXy4kc2xpZGVUcmFjaykuYWRkQ2xhc3MoJ3NsaWNrLWNsb25lZCcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgaW5maW5pdGVDb3VudCAgKyBfLnNsaWRlQ291bnQ7IGkgKz0gMSkge1xuICAgICAgICAgICAgICAgICAgICBzbGlkZUluZGV4ID0gaTtcbiAgICAgICAgICAgICAgICAgICAgJChfLiRzbGlkZXNbc2xpZGVJbmRleF0pLmNsb25lKHRydWUpLmF0dHIoJ2lkJywgJycpXG4gICAgICAgICAgICAgICAgICAgICAgICAuYXR0cignZGF0YS1zbGljay1pbmRleCcsIHNsaWRlSW5kZXggKyBfLnNsaWRlQ291bnQpXG4gICAgICAgICAgICAgICAgICAgICAgICAuYXBwZW5kVG8oXy4kc2xpZGVUcmFjaykuYWRkQ2xhc3MoJ3NsaWNrLWNsb25lZCcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBfLiRzbGlkZVRyYWNrLmZpbmQoJy5zbGljay1jbG9uZWQnKS5maW5kKCdbaWRdJykuZWFjaChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgJCh0aGlzKS5hdHRyKCdpZCcsICcnKTtcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuICAgIH07XG5cbiAgICBTbGljay5wcm90b3R5cGUuaW50ZXJydXB0ID0gZnVuY3Rpb24oIHRvZ2dsZSApIHtcblxuICAgICAgICB2YXIgXyA9IHRoaXM7XG5cbiAgICAgICAgaWYoICF0b2dnbGUgKSB7XG4gICAgICAgICAgICBfLmF1dG9QbGF5KCk7XG4gICAgICAgIH1cbiAgICAgICAgXy5pbnRlcnJ1cHRlZCA9IHRvZ2dsZTtcblxuICAgIH07XG5cbiAgICBTbGljay5wcm90b3R5cGUuc2VsZWN0SGFuZGxlciA9IGZ1bmN0aW9uKGV2ZW50KSB7XG5cbiAgICAgICAgdmFyIF8gPSB0aGlzO1xuXG4gICAgICAgIHZhciB0YXJnZXRFbGVtZW50ID1cbiAgICAgICAgICAgICQoZXZlbnQudGFyZ2V0KS5pcygnLnNsaWNrLXNsaWRlJykgP1xuICAgICAgICAgICAgICAgICQoZXZlbnQudGFyZ2V0KSA6XG4gICAgICAgICAgICAgICAgJChldmVudC50YXJnZXQpLnBhcmVudHMoJy5zbGljay1zbGlkZScpO1xuXG4gICAgICAgIHZhciBpbmRleCA9IHBhcnNlSW50KHRhcmdldEVsZW1lbnQuYXR0cignZGF0YS1zbGljay1pbmRleCcpKTtcblxuICAgICAgICBpZiAoIWluZGV4KSBpbmRleCA9IDA7XG5cbiAgICAgICAgaWYgKF8uc2xpZGVDb3VudCA8PSBfLm9wdGlvbnMuc2xpZGVzVG9TaG93KSB7XG5cbiAgICAgICAgICAgIF8uc2xpZGVIYW5kbGVyKGluZGV4LCBmYWxzZSwgdHJ1ZSk7XG4gICAgICAgICAgICByZXR1cm47XG5cbiAgICAgICAgfVxuXG4gICAgICAgIF8uc2xpZGVIYW5kbGVyKGluZGV4KTtcblxuICAgIH07XG5cbiAgICBTbGljay5wcm90b3R5cGUuc2xpZGVIYW5kbGVyID0gZnVuY3Rpb24oaW5kZXgsIHN5bmMsIGRvbnRBbmltYXRlKSB7XG5cbiAgICAgICAgdmFyIHRhcmdldFNsaWRlLCBhbmltU2xpZGUsIG9sZFNsaWRlLCBzbGlkZUxlZnQsIHRhcmdldExlZnQgPSBudWxsLFxuICAgICAgICAgICAgXyA9IHRoaXMsIG5hdlRhcmdldDtcblxuICAgICAgICBzeW5jID0gc3luYyB8fCBmYWxzZTtcblxuICAgICAgICBpZiAoXy5hbmltYXRpbmcgPT09IHRydWUgJiYgXy5vcHRpb25zLndhaXRGb3JBbmltYXRlID09PSB0cnVlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoXy5vcHRpb25zLmZhZGUgPT09IHRydWUgJiYgXy5jdXJyZW50U2xpZGUgPT09IGluZGV4KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc3luYyA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIF8uYXNOYXZGb3IoaW5kZXgpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGFyZ2V0U2xpZGUgPSBpbmRleDtcbiAgICAgICAgdGFyZ2V0TGVmdCA9IF8uZ2V0TGVmdCh0YXJnZXRTbGlkZSk7XG4gICAgICAgIHNsaWRlTGVmdCA9IF8uZ2V0TGVmdChfLmN1cnJlbnRTbGlkZSk7XG5cbiAgICAgICAgXy5jdXJyZW50TGVmdCA9IF8uc3dpcGVMZWZ0ID09PSBudWxsID8gc2xpZGVMZWZ0IDogXy5zd2lwZUxlZnQ7XG5cbiAgICAgICAgaWYgKF8ub3B0aW9ucy5pbmZpbml0ZSA9PT0gZmFsc2UgJiYgXy5vcHRpb25zLmNlbnRlck1vZGUgPT09IGZhbHNlICYmIChpbmRleCA8IDAgfHwgaW5kZXggPiBfLmdldERvdENvdW50KCkgKiBfLm9wdGlvbnMuc2xpZGVzVG9TY3JvbGwpKSB7XG4gICAgICAgICAgICBpZiAoXy5vcHRpb25zLmZhZGUgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0U2xpZGUgPSBfLmN1cnJlbnRTbGlkZTtcbiAgICAgICAgICAgICAgICBpZiAoZG9udEFuaW1hdGUgIT09IHRydWUgJiYgXy5zbGlkZUNvdW50ID4gXy5vcHRpb25zLnNsaWRlc1RvU2hvdykge1xuICAgICAgICAgICAgICAgICAgICBfLmFuaW1hdGVTbGlkZShzbGlkZUxlZnQsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgXy5wb3N0U2xpZGUodGFyZ2V0U2xpZGUpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBfLnBvc3RTbGlkZSh0YXJnZXRTbGlkZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9IGVsc2UgaWYgKF8ub3B0aW9ucy5pbmZpbml0ZSA9PT0gZmFsc2UgJiYgXy5vcHRpb25zLmNlbnRlck1vZGUgPT09IHRydWUgJiYgKGluZGV4IDwgMCB8fCBpbmRleCA+IChfLnNsaWRlQ291bnQgLSBfLm9wdGlvbnMuc2xpZGVzVG9TY3JvbGwpKSkge1xuICAgICAgICAgICAgaWYgKF8ub3B0aW9ucy5mYWRlID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIHRhcmdldFNsaWRlID0gXy5jdXJyZW50U2xpZGU7XG4gICAgICAgICAgICAgICAgaWYgKGRvbnRBbmltYXRlICE9PSB0cnVlICYmIF8uc2xpZGVDb3VudCA+IF8ub3B0aW9ucy5zbGlkZXNUb1Nob3cpIHtcbiAgICAgICAgICAgICAgICAgICAgXy5hbmltYXRlU2xpZGUoc2xpZGVMZWZ0LCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF8ucG9zdFNsaWRlKHRhcmdldFNsaWRlKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgXy5wb3N0U2xpZGUodGFyZ2V0U2xpZGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICggXy5vcHRpb25zLmF1dG9wbGF5ICkge1xuICAgICAgICAgICAgY2xlYXJJbnRlcnZhbChfLmF1dG9QbGF5VGltZXIpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRhcmdldFNsaWRlIDwgMCkge1xuICAgICAgICAgICAgaWYgKF8uc2xpZGVDb3VudCAlIF8ub3B0aW9ucy5zbGlkZXNUb1Njcm9sbCAhPT0gMCkge1xuICAgICAgICAgICAgICAgIGFuaW1TbGlkZSA9IF8uc2xpZGVDb3VudCAtIChfLnNsaWRlQ291bnQgJSBfLm9wdGlvbnMuc2xpZGVzVG9TY3JvbGwpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBhbmltU2xpZGUgPSBfLnNsaWRlQ291bnQgKyB0YXJnZXRTbGlkZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICh0YXJnZXRTbGlkZSA+PSBfLnNsaWRlQ291bnQpIHtcbiAgICAgICAgICAgIGlmIChfLnNsaWRlQ291bnQgJSBfLm9wdGlvbnMuc2xpZGVzVG9TY3JvbGwgIT09IDApIHtcbiAgICAgICAgICAgICAgICBhbmltU2xpZGUgPSAwO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBhbmltU2xpZGUgPSB0YXJnZXRTbGlkZSAtIF8uc2xpZGVDb3VudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGFuaW1TbGlkZSA9IHRhcmdldFNsaWRlO1xuICAgICAgICB9XG5cbiAgICAgICAgXy5hbmltYXRpbmcgPSB0cnVlO1xuXG4gICAgICAgIF8uJHNsaWRlci50cmlnZ2VyKCdiZWZvcmVDaGFuZ2UnLCBbXywgXy5jdXJyZW50U2xpZGUsIGFuaW1TbGlkZV0pO1xuXG4gICAgICAgIG9sZFNsaWRlID0gXy5jdXJyZW50U2xpZGU7XG4gICAgICAgIF8uY3VycmVudFNsaWRlID0gYW5pbVNsaWRlO1xuXG4gICAgICAgIF8uc2V0U2xpZGVDbGFzc2VzKF8uY3VycmVudFNsaWRlKTtcblxuICAgICAgICBpZiAoIF8ub3B0aW9ucy5hc05hdkZvciApIHtcblxuICAgICAgICAgICAgbmF2VGFyZ2V0ID0gXy5nZXROYXZUYXJnZXQoKTtcbiAgICAgICAgICAgIG5hdlRhcmdldCA9IG5hdlRhcmdldC5zbGljaygnZ2V0U2xpY2snKTtcblxuICAgICAgICAgICAgaWYgKCBuYXZUYXJnZXQuc2xpZGVDb3VudCA8PSBuYXZUYXJnZXQub3B0aW9ucy5zbGlkZXNUb1Nob3cgKSB7XG4gICAgICAgICAgICAgICAgbmF2VGFyZ2V0LnNldFNsaWRlQ2xhc3NlcyhfLmN1cnJlbnRTbGlkZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgICAgIF8udXBkYXRlRG90cygpO1xuICAgICAgICBfLnVwZGF0ZUFycm93cygpO1xuXG4gICAgICAgIGlmIChfLm9wdGlvbnMuZmFkZSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgaWYgKGRvbnRBbmltYXRlICE9PSB0cnVlKSB7XG5cbiAgICAgICAgICAgICAgICBfLmZhZGVTbGlkZU91dChvbGRTbGlkZSk7XG5cbiAgICAgICAgICAgICAgICBfLmZhZGVTbGlkZShhbmltU2xpZGUsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBfLnBvc3RTbGlkZShhbmltU2xpZGUpO1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIF8ucG9zdFNsaWRlKGFuaW1TbGlkZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBfLmFuaW1hdGVIZWlnaHQoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChkb250QW5pbWF0ZSAhPT0gdHJ1ZSAmJiBfLnNsaWRlQ291bnQgPiBfLm9wdGlvbnMuc2xpZGVzVG9TaG93KSB7XG4gICAgICAgICAgICBfLmFuaW1hdGVTbGlkZSh0YXJnZXRMZWZ0LCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBfLnBvc3RTbGlkZShhbmltU2xpZGUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBfLnBvc3RTbGlkZShhbmltU2xpZGUpO1xuICAgICAgICB9XG5cbiAgICB9O1xuXG4gICAgU2xpY2sucHJvdG90eXBlLnN0YXJ0TG9hZCA9IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHZhciBfID0gdGhpcztcblxuICAgICAgICBpZiAoXy5vcHRpb25zLmFycm93cyA9PT0gdHJ1ZSAmJiBfLnNsaWRlQ291bnQgPiBfLm9wdGlvbnMuc2xpZGVzVG9TaG93KSB7XG5cbiAgICAgICAgICAgIF8uJHByZXZBcnJvdy5oaWRlKCk7XG4gICAgICAgICAgICBfLiRuZXh0QXJyb3cuaGlkZSgpO1xuXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoXy5vcHRpb25zLmRvdHMgPT09IHRydWUgJiYgXy5zbGlkZUNvdW50ID4gXy5vcHRpb25zLnNsaWRlc1RvU2hvdykge1xuXG4gICAgICAgICAgICBfLiRkb3RzLmhpZGUoKTtcblxuICAgICAgICB9XG5cbiAgICAgICAgXy4kc2xpZGVyLmFkZENsYXNzKCdzbGljay1sb2FkaW5nJyk7XG5cbiAgICB9O1xuXG4gICAgU2xpY2sucHJvdG90eXBlLnN3aXBlRGlyZWN0aW9uID0gZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdmFyIHhEaXN0LCB5RGlzdCwgciwgc3dpcGVBbmdsZSwgXyA9IHRoaXM7XG5cbiAgICAgICAgeERpc3QgPSBfLnRvdWNoT2JqZWN0LnN0YXJ0WCAtIF8udG91Y2hPYmplY3QuY3VyWDtcbiAgICAgICAgeURpc3QgPSBfLnRvdWNoT2JqZWN0LnN0YXJ0WSAtIF8udG91Y2hPYmplY3QuY3VyWTtcbiAgICAgICAgciA9IE1hdGguYXRhbjIoeURpc3QsIHhEaXN0KTtcblxuICAgICAgICBzd2lwZUFuZ2xlID0gTWF0aC5yb3VuZChyICogMTgwIC8gTWF0aC5QSSk7XG4gICAgICAgIGlmIChzd2lwZUFuZ2xlIDwgMCkge1xuICAgICAgICAgICAgc3dpcGVBbmdsZSA9IDM2MCAtIE1hdGguYWJzKHN3aXBlQW5nbGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKChzd2lwZUFuZ2xlIDw9IDQ1KSAmJiAoc3dpcGVBbmdsZSA+PSAwKSkge1xuICAgICAgICAgICAgcmV0dXJuIChfLm9wdGlvbnMucnRsID09PSBmYWxzZSA/ICdsZWZ0JyA6ICdyaWdodCcpO1xuICAgICAgICB9XG4gICAgICAgIGlmICgoc3dpcGVBbmdsZSA8PSAzNjApICYmIChzd2lwZUFuZ2xlID49IDMxNSkpIHtcbiAgICAgICAgICAgIHJldHVybiAoXy5vcHRpb25zLnJ0bCA9PT0gZmFsc2UgPyAnbGVmdCcgOiAncmlnaHQnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoKHN3aXBlQW5nbGUgPj0gMTM1KSAmJiAoc3dpcGVBbmdsZSA8PSAyMjUpKSB7XG4gICAgICAgICAgICByZXR1cm4gKF8ub3B0aW9ucy5ydGwgPT09IGZhbHNlID8gJ3JpZ2h0JyA6ICdsZWZ0Jyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKF8ub3B0aW9ucy52ZXJ0aWNhbFN3aXBpbmcgPT09IHRydWUpIHtcbiAgICAgICAgICAgIGlmICgoc3dpcGVBbmdsZSA+PSAzNSkgJiYgKHN3aXBlQW5nbGUgPD0gMTM1KSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAnZG93bic7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiAndXAnO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuICd2ZXJ0aWNhbCc7XG5cbiAgICB9O1xuXG4gICAgU2xpY2sucHJvdG90eXBlLnN3aXBlRW5kID0gZnVuY3Rpb24oZXZlbnQpIHtcblxuICAgICAgICB2YXIgXyA9IHRoaXMsXG4gICAgICAgICAgICBzbGlkZUNvdW50LFxuICAgICAgICAgICAgZGlyZWN0aW9uO1xuXG4gICAgICAgIF8uZHJhZ2dpbmcgPSBmYWxzZTtcbiAgICAgICAgXy5zd2lwaW5nID0gZmFsc2U7XG5cbiAgICAgICAgaWYgKF8uc2Nyb2xsaW5nKSB7XG4gICAgICAgICAgICBfLnNjcm9sbGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgXy5pbnRlcnJ1cHRlZCA9IGZhbHNlO1xuICAgICAgICBfLnNob3VsZENsaWNrID0gKCBfLnRvdWNoT2JqZWN0LnN3aXBlTGVuZ3RoID4gMTAgKSA/IGZhbHNlIDogdHJ1ZTtcblxuICAgICAgICBpZiAoIF8udG91Y2hPYmplY3QuY3VyWCA9PT0gdW5kZWZpbmVkICkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCBfLnRvdWNoT2JqZWN0LmVkZ2VIaXQgPT09IHRydWUgKSB7XG4gICAgICAgICAgICBfLiRzbGlkZXIudHJpZ2dlcignZWRnZScsIFtfLCBfLnN3aXBlRGlyZWN0aW9uKCkgXSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIF8udG91Y2hPYmplY3Quc3dpcGVMZW5ndGggPj0gXy50b3VjaE9iamVjdC5taW5Td2lwZSApIHtcblxuICAgICAgICAgICAgZGlyZWN0aW9uID0gXy5zd2lwZURpcmVjdGlvbigpO1xuXG4gICAgICAgICAgICBzd2l0Y2ggKCBkaXJlY3Rpb24gKSB7XG5cbiAgICAgICAgICAgICAgICBjYXNlICdsZWZ0JzpcbiAgICAgICAgICAgICAgICBjYXNlICdkb3duJzpcblxuICAgICAgICAgICAgICAgICAgICBzbGlkZUNvdW50ID1cbiAgICAgICAgICAgICAgICAgICAgICAgIF8ub3B0aW9ucy5zd2lwZVRvU2xpZGUgP1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF8uY2hlY2tOYXZpZ2FibGUoIF8uY3VycmVudFNsaWRlICsgXy5nZXRTbGlkZUNvdW50KCkgKSA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXy5jdXJyZW50U2xpZGUgKyBfLmdldFNsaWRlQ291bnQoKTtcblxuICAgICAgICAgICAgICAgICAgICBfLmN1cnJlbnREaXJlY3Rpb24gPSAwO1xuXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgY2FzZSAncmlnaHQnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ3VwJzpcblxuICAgICAgICAgICAgICAgICAgICBzbGlkZUNvdW50ID1cbiAgICAgICAgICAgICAgICAgICAgICAgIF8ub3B0aW9ucy5zd2lwZVRvU2xpZGUgP1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF8uY2hlY2tOYXZpZ2FibGUoIF8uY3VycmVudFNsaWRlIC0gXy5nZXRTbGlkZUNvdW50KCkgKSA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXy5jdXJyZW50U2xpZGUgLSBfLmdldFNsaWRlQ291bnQoKTtcblxuICAgICAgICAgICAgICAgICAgICBfLmN1cnJlbnREaXJlY3Rpb24gPSAxO1xuXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcblxuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmKCBkaXJlY3Rpb24gIT0gJ3ZlcnRpY2FsJyApIHtcblxuICAgICAgICAgICAgICAgIF8uc2xpZGVIYW5kbGVyKCBzbGlkZUNvdW50ICk7XG4gICAgICAgICAgICAgICAgXy50b3VjaE9iamVjdCA9IHt9O1xuICAgICAgICAgICAgICAgIF8uJHNsaWRlci50cmlnZ2VyKCdzd2lwZScsIFtfLCBkaXJlY3Rpb24gXSk7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICBpZiAoIF8udG91Y2hPYmplY3Quc3RhcnRYICE9PSBfLnRvdWNoT2JqZWN0LmN1clggKSB7XG5cbiAgICAgICAgICAgICAgICBfLnNsaWRlSGFuZGxlciggXy5jdXJyZW50U2xpZGUgKTtcbiAgICAgICAgICAgICAgICBfLnRvdWNoT2JqZWN0ID0ge307XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICB9O1xuXG4gICAgU2xpY2sucHJvdG90eXBlLnN3aXBlSGFuZGxlciA9IGZ1bmN0aW9uKGV2ZW50KSB7XG5cbiAgICAgICAgdmFyIF8gPSB0aGlzO1xuXG4gICAgICAgIGlmICgoXy5vcHRpb25zLnN3aXBlID09PSBmYWxzZSkgfHwgKCdvbnRvdWNoZW5kJyBpbiBkb2N1bWVudCAmJiBfLm9wdGlvbnMuc3dpcGUgPT09IGZhbHNlKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9IGVsc2UgaWYgKF8ub3B0aW9ucy5kcmFnZ2FibGUgPT09IGZhbHNlICYmIGV2ZW50LnR5cGUuaW5kZXhPZignbW91c2UnKSAhPT0gLTEpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIF8udG91Y2hPYmplY3QuZmluZ2VyQ291bnQgPSBldmVudC5vcmlnaW5hbEV2ZW50ICYmIGV2ZW50Lm9yaWdpbmFsRXZlbnQudG91Y2hlcyAhPT0gdW5kZWZpbmVkID9cbiAgICAgICAgICAgIGV2ZW50Lm9yaWdpbmFsRXZlbnQudG91Y2hlcy5sZW5ndGggOiAxO1xuXG4gICAgICAgIF8udG91Y2hPYmplY3QubWluU3dpcGUgPSBfLmxpc3RXaWR0aCAvIF8ub3B0aW9uc1xuICAgICAgICAgICAgLnRvdWNoVGhyZXNob2xkO1xuXG4gICAgICAgIGlmIChfLm9wdGlvbnMudmVydGljYWxTd2lwaW5nID09PSB0cnVlKSB7XG4gICAgICAgICAgICBfLnRvdWNoT2JqZWN0Lm1pblN3aXBlID0gXy5saXN0SGVpZ2h0IC8gXy5vcHRpb25zXG4gICAgICAgICAgICAgICAgLnRvdWNoVGhyZXNob2xkO1xuICAgICAgICB9XG5cbiAgICAgICAgc3dpdGNoIChldmVudC5kYXRhLmFjdGlvbikge1xuXG4gICAgICAgICAgICBjYXNlICdzdGFydCc6XG4gICAgICAgICAgICAgICAgXy5zd2lwZVN0YXJ0KGV2ZW50KTtcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSAnbW92ZSc6XG4gICAgICAgICAgICAgICAgXy5zd2lwZU1vdmUoZXZlbnQpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlICdlbmQnOlxuICAgICAgICAgICAgICAgIF8uc3dpcGVFbmQoZXZlbnQpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIH1cblxuICAgIH07XG5cbiAgICBTbGljay5wcm90b3R5cGUuc3dpcGVNb3ZlID0gZnVuY3Rpb24oZXZlbnQpIHtcblxuICAgICAgICB2YXIgXyA9IHRoaXMsXG4gICAgICAgICAgICBlZGdlV2FzSGl0ID0gZmFsc2UsXG4gICAgICAgICAgICBjdXJMZWZ0LCBzd2lwZURpcmVjdGlvbiwgc3dpcGVMZW5ndGgsIHBvc2l0aW9uT2Zmc2V0LCB0b3VjaGVzLCB2ZXJ0aWNhbFN3aXBlTGVuZ3RoO1xuXG4gICAgICAgIHRvdWNoZXMgPSBldmVudC5vcmlnaW5hbEV2ZW50ICE9PSB1bmRlZmluZWQgPyBldmVudC5vcmlnaW5hbEV2ZW50LnRvdWNoZXMgOiBudWxsO1xuXG4gICAgICAgIGlmICghXy5kcmFnZ2luZyB8fCBfLnNjcm9sbGluZyB8fCB0b3VjaGVzICYmIHRvdWNoZXMubGVuZ3RoICE9PSAxKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBjdXJMZWZ0ID0gXy5nZXRMZWZ0KF8uY3VycmVudFNsaWRlKTtcblxuICAgICAgICBfLnRvdWNoT2JqZWN0LmN1clggPSB0b3VjaGVzICE9PSB1bmRlZmluZWQgPyB0b3VjaGVzWzBdLnBhZ2VYIDogZXZlbnQuY2xpZW50WDtcbiAgICAgICAgXy50b3VjaE9iamVjdC5jdXJZID0gdG91Y2hlcyAhPT0gdW5kZWZpbmVkID8gdG91Y2hlc1swXS5wYWdlWSA6IGV2ZW50LmNsaWVudFk7XG5cbiAgICAgICAgXy50b3VjaE9iamVjdC5zd2lwZUxlbmd0aCA9IE1hdGgucm91bmQoTWF0aC5zcXJ0KFxuICAgICAgICAgICAgTWF0aC5wb3coXy50b3VjaE9iamVjdC5jdXJYIC0gXy50b3VjaE9iamVjdC5zdGFydFgsIDIpKSk7XG5cbiAgICAgICAgdmVydGljYWxTd2lwZUxlbmd0aCA9IE1hdGgucm91bmQoTWF0aC5zcXJ0KFxuICAgICAgICAgICAgTWF0aC5wb3coXy50b3VjaE9iamVjdC5jdXJZIC0gXy50b3VjaE9iamVjdC5zdGFydFksIDIpKSk7XG5cbiAgICAgICAgaWYgKCFfLm9wdGlvbnMudmVydGljYWxTd2lwaW5nICYmICFfLnN3aXBpbmcgJiYgdmVydGljYWxTd2lwZUxlbmd0aCA+IDQpIHtcbiAgICAgICAgICAgIF8uc2Nyb2xsaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChfLm9wdGlvbnMudmVydGljYWxTd2lwaW5nID09PSB0cnVlKSB7XG4gICAgICAgICAgICBfLnRvdWNoT2JqZWN0LnN3aXBlTGVuZ3RoID0gdmVydGljYWxTd2lwZUxlbmd0aDtcbiAgICAgICAgfVxuXG4gICAgICAgIHN3aXBlRGlyZWN0aW9uID0gXy5zd2lwZURpcmVjdGlvbigpO1xuXG4gICAgICAgIGlmIChldmVudC5vcmlnaW5hbEV2ZW50ICE9PSB1bmRlZmluZWQgJiYgXy50b3VjaE9iamVjdC5zd2lwZUxlbmd0aCA+IDQpIHtcbiAgICAgICAgICAgIF8uc3dpcGluZyA9IHRydWU7XG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgcG9zaXRpb25PZmZzZXQgPSAoXy5vcHRpb25zLnJ0bCA9PT0gZmFsc2UgPyAxIDogLTEpICogKF8udG91Y2hPYmplY3QuY3VyWCA+IF8udG91Y2hPYmplY3Quc3RhcnRYID8gMSA6IC0xKTtcbiAgICAgICAgaWYgKF8ub3B0aW9ucy52ZXJ0aWNhbFN3aXBpbmcgPT09IHRydWUpIHtcbiAgICAgICAgICAgIHBvc2l0aW9uT2Zmc2V0ID0gXy50b3VjaE9iamVjdC5jdXJZID4gXy50b3VjaE9iamVjdC5zdGFydFkgPyAxIDogLTE7XG4gICAgICAgIH1cblxuXG4gICAgICAgIHN3aXBlTGVuZ3RoID0gXy50b3VjaE9iamVjdC5zd2lwZUxlbmd0aDtcblxuICAgICAgICBfLnRvdWNoT2JqZWN0LmVkZ2VIaXQgPSBmYWxzZTtcblxuICAgICAgICBpZiAoXy5vcHRpb25zLmluZmluaXRlID09PSBmYWxzZSkge1xuICAgICAgICAgICAgaWYgKChfLmN1cnJlbnRTbGlkZSA9PT0gMCAmJiBzd2lwZURpcmVjdGlvbiA9PT0gJ3JpZ2h0JykgfHwgKF8uY3VycmVudFNsaWRlID49IF8uZ2V0RG90Q291bnQoKSAmJiBzd2lwZURpcmVjdGlvbiA9PT0gJ2xlZnQnKSkge1xuICAgICAgICAgICAgICAgIHN3aXBlTGVuZ3RoID0gXy50b3VjaE9iamVjdC5zd2lwZUxlbmd0aCAqIF8ub3B0aW9ucy5lZGdlRnJpY3Rpb247XG4gICAgICAgICAgICAgICAgXy50b3VjaE9iamVjdC5lZGdlSGl0ID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChfLm9wdGlvbnMudmVydGljYWwgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICBfLnN3aXBlTGVmdCA9IGN1ckxlZnQgKyBzd2lwZUxlbmd0aCAqIHBvc2l0aW9uT2Zmc2V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgXy5zd2lwZUxlZnQgPSBjdXJMZWZ0ICsgKHN3aXBlTGVuZ3RoICogKF8uJGxpc3QuaGVpZ2h0KCkgLyBfLmxpc3RXaWR0aCkpICogcG9zaXRpb25PZmZzZXQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKF8ub3B0aW9ucy52ZXJ0aWNhbFN3aXBpbmcgPT09IHRydWUpIHtcbiAgICAgICAgICAgIF8uc3dpcGVMZWZ0ID0gY3VyTGVmdCArIHN3aXBlTGVuZ3RoICogcG9zaXRpb25PZmZzZXQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoXy5vcHRpb25zLmZhZGUgPT09IHRydWUgfHwgXy5vcHRpb25zLnRvdWNoTW92ZSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChfLmFuaW1hdGluZyA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgXy5zd2lwZUxlZnQgPSBudWxsO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgXy5zZXRDU1MoXy5zd2lwZUxlZnQpO1xuXG4gICAgfTtcblxuICAgIFNsaWNrLnByb3RvdHlwZS5zd2lwZVN0YXJ0ID0gZnVuY3Rpb24oZXZlbnQpIHtcblxuICAgICAgICB2YXIgXyA9IHRoaXMsXG4gICAgICAgICAgICB0b3VjaGVzO1xuXG4gICAgICAgIF8uaW50ZXJydXB0ZWQgPSB0cnVlO1xuXG4gICAgICAgIGlmIChfLnRvdWNoT2JqZWN0LmZpbmdlckNvdW50ICE9PSAxIHx8IF8uc2xpZGVDb3VudCA8PSBfLm9wdGlvbnMuc2xpZGVzVG9TaG93KSB7XG4gICAgICAgICAgICBfLnRvdWNoT2JqZWN0ID0ge307XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZXZlbnQub3JpZ2luYWxFdmVudCAhPT0gdW5kZWZpbmVkICYmIGV2ZW50Lm9yaWdpbmFsRXZlbnQudG91Y2hlcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0b3VjaGVzID0gZXZlbnQub3JpZ2luYWxFdmVudC50b3VjaGVzWzBdO1xuICAgICAgICB9XG5cbiAgICAgICAgXy50b3VjaE9iamVjdC5zdGFydFggPSBfLnRvdWNoT2JqZWN0LmN1clggPSB0b3VjaGVzICE9PSB1bmRlZmluZWQgPyB0b3VjaGVzLnBhZ2VYIDogZXZlbnQuY2xpZW50WDtcbiAgICAgICAgXy50b3VjaE9iamVjdC5zdGFydFkgPSBfLnRvdWNoT2JqZWN0LmN1clkgPSB0b3VjaGVzICE9PSB1bmRlZmluZWQgPyB0b3VjaGVzLnBhZ2VZIDogZXZlbnQuY2xpZW50WTtcblxuICAgICAgICBfLmRyYWdnaW5nID0gdHJ1ZTtcblxuICAgIH07XG5cbiAgICBTbGljay5wcm90b3R5cGUudW5maWx0ZXJTbGlkZXMgPSBTbGljay5wcm90b3R5cGUuc2xpY2tVbmZpbHRlciA9IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHZhciBfID0gdGhpcztcblxuICAgICAgICBpZiAoXy4kc2xpZGVzQ2FjaGUgIT09IG51bGwpIHtcblxuICAgICAgICAgICAgXy51bmxvYWQoKTtcblxuICAgICAgICAgICAgXy4kc2xpZGVUcmFjay5jaGlsZHJlbih0aGlzLm9wdGlvbnMuc2xpZGUpLmRldGFjaCgpO1xuXG4gICAgICAgICAgICBfLiRzbGlkZXNDYWNoZS5hcHBlbmRUbyhfLiRzbGlkZVRyYWNrKTtcblxuICAgICAgICAgICAgXy5yZWluaXQoKTtcblxuICAgICAgICB9XG5cbiAgICB9O1xuXG4gICAgU2xpY2sucHJvdG90eXBlLnVubG9hZCA9IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHZhciBfID0gdGhpcztcblxuICAgICAgICAkKCcuc2xpY2stY2xvbmVkJywgXy4kc2xpZGVyKS5yZW1vdmUoKTtcblxuICAgICAgICBpZiAoXy4kZG90cykge1xuICAgICAgICAgICAgXy4kZG90cy5yZW1vdmUoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChfLiRwcmV2QXJyb3cgJiYgXy5odG1sRXhwci50ZXN0KF8ub3B0aW9ucy5wcmV2QXJyb3cpKSB7XG4gICAgICAgICAgICBfLiRwcmV2QXJyb3cucmVtb3ZlKCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoXy4kbmV4dEFycm93ICYmIF8uaHRtbEV4cHIudGVzdChfLm9wdGlvbnMubmV4dEFycm93KSkge1xuICAgICAgICAgICAgXy4kbmV4dEFycm93LnJlbW92ZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgXy4kc2xpZGVzXG4gICAgICAgICAgICAucmVtb3ZlQ2xhc3MoJ3NsaWNrLXNsaWRlIHNsaWNrLWFjdGl2ZSBzbGljay12aXNpYmxlIHNsaWNrLWN1cnJlbnQnKVxuICAgICAgICAgICAgLmF0dHIoJ2FyaWEtaGlkZGVuJywgJ3RydWUnKVxuICAgICAgICAgICAgLmNzcygnd2lkdGgnLCAnJyk7XG5cbiAgICB9O1xuXG4gICAgU2xpY2sucHJvdG90eXBlLnVuc2xpY2sgPSBmdW5jdGlvbihmcm9tQnJlYWtwb2ludCkge1xuXG4gICAgICAgIHZhciBfID0gdGhpcztcbiAgICAgICAgXy4kc2xpZGVyLnRyaWdnZXIoJ3Vuc2xpY2snLCBbXywgZnJvbUJyZWFrcG9pbnRdKTtcbiAgICAgICAgXy5kZXN0cm95KCk7XG5cbiAgICB9O1xuXG4gICAgU2xpY2sucHJvdG90eXBlLnVwZGF0ZUFycm93cyA9IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHZhciBfID0gdGhpcyxcbiAgICAgICAgICAgIGNlbnRlck9mZnNldDtcblxuICAgICAgICBjZW50ZXJPZmZzZXQgPSBNYXRoLmZsb29yKF8ub3B0aW9ucy5zbGlkZXNUb1Nob3cgLyAyKTtcblxuICAgICAgICBpZiAoIF8ub3B0aW9ucy5hcnJvd3MgPT09IHRydWUgJiZcbiAgICAgICAgICAgIF8uc2xpZGVDb3VudCA+IF8ub3B0aW9ucy5zbGlkZXNUb1Nob3cgJiZcbiAgICAgICAgICAgICFfLm9wdGlvbnMuaW5maW5pdGUgKSB7XG5cbiAgICAgICAgICAgIF8uJHByZXZBcnJvdy5yZW1vdmVDbGFzcygnc2xpY2stZGlzYWJsZWQnKS5hdHRyKCdhcmlhLWRpc2FibGVkJywgJ2ZhbHNlJyk7XG4gICAgICAgICAgICBfLiRuZXh0QXJyb3cucmVtb3ZlQ2xhc3MoJ3NsaWNrLWRpc2FibGVkJykuYXR0cignYXJpYS1kaXNhYmxlZCcsICdmYWxzZScpO1xuXG4gICAgICAgICAgICBpZiAoXy5jdXJyZW50U2xpZGUgPT09IDApIHtcblxuICAgICAgICAgICAgICAgIF8uJHByZXZBcnJvdy5hZGRDbGFzcygnc2xpY2stZGlzYWJsZWQnKS5hdHRyKCdhcmlhLWRpc2FibGVkJywgJ3RydWUnKTtcbiAgICAgICAgICAgICAgICBfLiRuZXh0QXJyb3cucmVtb3ZlQ2xhc3MoJ3NsaWNrLWRpc2FibGVkJykuYXR0cignYXJpYS1kaXNhYmxlZCcsICdmYWxzZScpO1xuXG4gICAgICAgICAgICB9IGVsc2UgaWYgKF8uY3VycmVudFNsaWRlID49IF8uc2xpZGVDb3VudCAtIF8ub3B0aW9ucy5zbGlkZXNUb1Nob3cgJiYgXy5vcHRpb25zLmNlbnRlck1vZGUgPT09IGZhbHNlKSB7XG5cbiAgICAgICAgICAgICAgICBfLiRuZXh0QXJyb3cuYWRkQ2xhc3MoJ3NsaWNrLWRpc2FibGVkJykuYXR0cignYXJpYS1kaXNhYmxlZCcsICd0cnVlJyk7XG4gICAgICAgICAgICAgICAgXy4kcHJldkFycm93LnJlbW92ZUNsYXNzKCdzbGljay1kaXNhYmxlZCcpLmF0dHIoJ2FyaWEtZGlzYWJsZWQnLCAnZmFsc2UnKTtcblxuICAgICAgICAgICAgfSBlbHNlIGlmIChfLmN1cnJlbnRTbGlkZSA+PSBfLnNsaWRlQ291bnQgLSAxICYmIF8ub3B0aW9ucy5jZW50ZXJNb2RlID09PSB0cnVlKSB7XG5cbiAgICAgICAgICAgICAgICBfLiRuZXh0QXJyb3cuYWRkQ2xhc3MoJ3NsaWNrLWRpc2FibGVkJykuYXR0cignYXJpYS1kaXNhYmxlZCcsICd0cnVlJyk7XG4gICAgICAgICAgICAgICAgXy4kcHJldkFycm93LnJlbW92ZUNsYXNzKCdzbGljay1kaXNhYmxlZCcpLmF0dHIoJ2FyaWEtZGlzYWJsZWQnLCAnZmFsc2UnKTtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuICAgIH07XG5cbiAgICBTbGljay5wcm90b3R5cGUudXBkYXRlRG90cyA9IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHZhciBfID0gdGhpcztcblxuICAgICAgICBpZiAoXy4kZG90cyAhPT0gbnVsbCkge1xuXG4gICAgICAgICAgICBfLiRkb3RzXG4gICAgICAgICAgICAgICAgLmZpbmQoJ2xpJylcbiAgICAgICAgICAgICAgICAgICAgLnJlbW92ZUNsYXNzKCdzbGljay1hY3RpdmUnKVxuICAgICAgICAgICAgICAgICAgICAuZW5kKCk7XG5cbiAgICAgICAgICAgIF8uJGRvdHNcbiAgICAgICAgICAgICAgICAuZmluZCgnbGknKVxuICAgICAgICAgICAgICAgIC5lcShNYXRoLmZsb29yKF8uY3VycmVudFNsaWRlIC8gXy5vcHRpb25zLnNsaWRlc1RvU2Nyb2xsKSlcbiAgICAgICAgICAgICAgICAuYWRkQ2xhc3MoJ3NsaWNrLWFjdGl2ZScpO1xuXG4gICAgICAgIH1cblxuICAgIH07XG5cbiAgICBTbGljay5wcm90b3R5cGUudmlzaWJpbGl0eSA9IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHZhciBfID0gdGhpcztcblxuICAgICAgICBpZiAoIF8ub3B0aW9ucy5hdXRvcGxheSApIHtcblxuICAgICAgICAgICAgaWYgKCBkb2N1bWVudFtfLmhpZGRlbl0gKSB7XG5cbiAgICAgICAgICAgICAgICBfLmludGVycnVwdGVkID0gdHJ1ZTtcblxuICAgICAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgICAgIF8uaW50ZXJydXB0ZWQgPSBmYWxzZTtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuICAgIH07XG5cbiAgICAkLmZuLnNsaWNrID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBfID0gdGhpcyxcbiAgICAgICAgICAgIG9wdCA9IGFyZ3VtZW50c1swXSxcbiAgICAgICAgICAgIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpLFxuICAgICAgICAgICAgbCA9IF8ubGVuZ3RoLFxuICAgICAgICAgICAgaSxcbiAgICAgICAgICAgIHJldDtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBvcHQgPT0gJ29iamVjdCcgfHwgdHlwZW9mIG9wdCA9PSAndW5kZWZpbmVkJylcbiAgICAgICAgICAgICAgICBfW2ldLnNsaWNrID0gbmV3IFNsaWNrKF9baV0sIG9wdCk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgcmV0ID0gX1tpXS5zbGlja1tvcHRdLmFwcGx5KF9baV0uc2xpY2ssIGFyZ3MpO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiByZXQgIT0gJ3VuZGVmaW5lZCcpIHJldHVybiByZXQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIF87XG4gICAgfTtcblxufSkpO1xuIl0sIm5hbWVzIjpbIl9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQiLCJzZWxmIiwiUmVmZXJlbmNlRXJyb3IiLCJfaW5oZXJpdHNMb29zZSIsInN1YkNsYXNzIiwic3VwZXJDbGFzcyIsInByb3RvdHlwZSIsIk9iamVjdCIsImNyZWF0ZSIsImNvbnN0cnVjdG9yIiwiX19wcm90b19fIiwiZ2V0R2xvYmFsTWF0cml4IiwiTWF0cml4MkQiLCJnc2FwIiwiX3dpbiIsIl9kb2MiLCJfZG9jRWxlbWVudCIsIl9ib2R5IiwiX3RlbXBEaXYiLCJfcGxhY2Vob2xkZXJEaXYiLCJfY29yZUluaXR0ZWQiLCJfY2hlY2tQcmVmaXgiLCJfdG9BcnJheSIsIl9zdXBwb3J0c1Bhc3NpdmUiLCJfaXNUb3VjaERldmljZSIsIl90b3VjaEV2ZW50TG9va3VwIiwiX2RyYWdDb3VudCIsIl9pc011bHRpVG91Y2hpbmciLCJfaXNBbmRyb2lkIiwiSW5lcnRpYVBsdWdpbiIsIl9kZWZhdWx0Q3Vyc29yIiwiX3N1cHBvcnRzUG9pbnRlciIsIl93aW5kb3dFeGlzdHMiLCJ3aW5kb3ciLCJfZ2V0R1NBUCIsInJlZ2lzdGVyUGx1Z2luIiwiX2lzRnVuY3Rpb24iLCJ2YWx1ZSIsIl9pc09iamVjdCIsIl9pc1VuZGVmaW5lZCIsIl9lbXB0eUZ1bmMiLCJfdHJhbnNmb3JtUHJvcCIsIl90cmFuc2Zvcm1PcmlnaW5Qcm9wIiwiX3JvdW5kIiwiTWF0aCIsInJvdW5kIiwiX2lzQXJyYXkiLCJBcnJheSIsImlzQXJyYXkiLCJfY3JlYXRlRWxlbWVudCIsInR5cGUiLCJucyIsImUiLCJjcmVhdGVFbGVtZW50TlMiLCJyZXBsYWNlIiwiY3JlYXRlRWxlbWVudCIsInN0eWxlIiwiX1JBRDJERUciLCJQSSIsIl9iaWdOdW0iLCJfaWRlbnRpdHlNYXRyaXgiLCJfZ2V0VGltZSIsIkRhdGUiLCJub3ciLCJnZXRUaW1lIiwiX3JlbmRlclF1ZXVlIiwiX2xvb2t1cCIsIl9sb29rdXBDb3VudCIsIl9jbGlja2FibGVUYWdFeHAiLCJfbGFzdERyYWdUaW1lIiwiX3RlbXAxIiwiX3dpbmRvd1Byb3h5IiwiX2NvcHkiLCJvYmoiLCJmYWN0b3IiLCJjb3B5IiwicCIsIl9leHRlbmQiLCJkZWZhdWx0cyIsIl9zZXRUb3VjaEFjdGlvbkZvckFsbERlc2NlbmRhbnRzIiwiZWxlbWVudHMiLCJpIiwibGVuZ3RoIiwiY2hpbGRyZW4iLCJ0b3VjaEFjdGlvbiIsInJlbW92ZVByb3BlcnR5IiwiX3JlbmRlclF1ZXVlVGljayIsImZvckVhY2giLCJmdW5jIiwiX2FkZFRvUmVuZGVyUXVldWUiLCJwdXNoIiwidGlja2VyIiwiYWRkIiwiX3JlbmRlclF1ZXVlVGltZW91dCIsInJlbW92ZSIsIl9yZW1vdmVGcm9tUmVuZGVyUXVldWUiLCJzcGxpY2UiLCJ0byIsIm92ZXJ3cml0ZSIsImRlbGF5IiwiZHVyYXRpb24iLCJvbkNvbXBsZXRlIiwiZGF0YSIsIl9zZXREZWZhdWx0cyIsIl9hZGRMaXN0ZW5lciIsImVsZW1lbnQiLCJjYXB0dXJlIiwiYWRkRXZlbnRMaXN0ZW5lciIsInRvdWNoVHlwZSIsInBhc3NpdmUiLCJfcmVtb3ZlTGlzdGVuZXIiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwiX3ByZXZlbnREZWZhdWx0IiwiZXZlbnQiLCJwcmV2ZW50RGVmYXVsdCIsInByZXZlbnRNYW5pcHVsYXRpb24iLCJfaGFzVG91Y2hJRCIsImxpc3QiLCJJRCIsImlkZW50aWZpZXIiLCJfb25NdWx0aVRvdWNoRG9jdW1lbnRFbmQiLCJ0b3VjaGVzIiwidGFyZ2V0IiwiX29uTXVsdGlUb3VjaERvY3VtZW50IiwiX2dldERvY1Njcm9sbFRvcCIsImRvYyIsInBhZ2VZT2Zmc2V0Iiwic2Nyb2xsVG9wIiwiZG9jdW1lbnRFbGVtZW50IiwiYm9keSIsIl9nZXREb2NTY3JvbGxMZWZ0IiwicGFnZVhPZmZzZXQiLCJzY3JvbGxMZWZ0IiwiX2FkZFNjcm9sbExpc3RlbmVyIiwiY2FsbGJhY2siLCJfaXNSb290IiwicGFyZW50Tm9kZSIsIl9yZW1vdmVTY3JvbGxMaXN0ZW5lciIsIm5vZGVUeXBlIiwiX2dldE1heFNjcm9sbCIsImF4aXMiLCJkaW0iLCJzY3JvbGwiLCJjbGllbnQiLCJtYXgiLCJfcmVjb3JkTWF4U2Nyb2xscyIsInNraXBDdXJyZW50IiwieCIsInkiLCJfZ3NNYXhTY3JvbGxYIiwiX2dzTWF4U2Nyb2xsWSIsIl9nc1Njcm9sbFgiLCJfZ3NTY3JvbGxZIiwiX3NldFN0eWxlIiwicHJvcGVydHkiLCJ0b0xvd2VyQ2FzZSIsIl9nZXRDb21wdXRlZFN0eWxlIiwiZ2V0Q29tcHV0ZWRTdHlsZSIsIkVsZW1lbnQiLCJob3N0IiwiX3RlbXBSZWN0IiwiX3BhcnNlUmVjdCIsImxlZnQiLCJ0b3AiLCJ3aWR0aCIsInJpZ2h0IiwiY2xpZW50V2lkdGgiLCJpbm5lcldpZHRoIiwiaGVpZ2h0IiwiYm90dG9tIiwiaW5uZXJIZWlnaHQiLCJjbGllbnRIZWlnaHQiLCJvd25lckRvY3VtZW50IiwiciIsInBhZ2VYIiwicGFnZVkiLCJnZXRCb3VuZGluZ0NsaWVudFJlY3QiLCJfZGlzcGF0Y2hFdmVudCIsImNhbGxiYWNrTmFtZSIsInZhcnMiLCJsaXN0ZW5lcnMiLCJfbGlzdGVuZXJzIiwicmVzdWx0IiwiYXBwbHkiLCJjYWxsYmFja1Njb3BlIiwicG9pbnRlckV2ZW50IiwiZGlzcGF0Y2hFdmVudCIsIl9nZXRCb3VuZHMiLCJjb250ZXh0Iiwib2Zmc2V0IiwibWluIiwibWluWCIsIm1pblJvdGF0aW9uIiwibWluWSIsIm1heFgiLCJtYXhSb3RhdGlvbiIsIm1heFkiLCJfZ2V0RWxlbWVudEJvdW5kcyIsIl9wb2ludDEiLCJpc1NWRyIsImdldEJCb3giLCJvd25lclNWR0VsZW1lbnQiLCJtYXRyaXgiLCJwMSIsInAyIiwicDMiLCJwNCIsImJib3giLCJjcyIsImNvbnRleHRQYXJlbnQiLCJ2aWV3Qm94IiwiYmFzZVZhbCIsImJveFNpemluZyIsInBhcnNlRmxvYXQiLCJib3JkZXJMZWZ0V2lkdGgiLCJib3JkZXJSaWdodFdpZHRoIiwiYm9yZGVyVG9wV2lkdGgiLCJib3JkZXJCb3R0b21XaWR0aCIsIm11bHRpcGx5IiwiX3BhcnNlSW5lcnRpYSIsImRyYWdnYWJsZSIsInNuYXAiLCJmb3JjZVplcm9WZWxvY2l0eSIsImEiLCJsIiwiZW5kIiwiY2FsbCIsInZlbG9jaXR5IiwiX2lzQ2xpY2thYmxlIiwiZ2V0QXR0cmlidXRlIiwib25jbGljayIsInRlc3QiLCJub2RlTmFtZSIsIl9zZXRTZWxlY3RhYmxlIiwic2VsZWN0YWJsZSIsIm9uZHJhZ3N0YXJ0Iiwib25zZWxlY3RzdGFydCIsInNldCIsImxhenkiLCJ1c2VyU2VsZWN0IiwiX2lzRml4ZWQiLCJwb3NpdGlvbiIsIl9zdXBwb3J0czNEIiwiX2FkZFBhZGRpbmdCUiIsIlNjcm9sbFByb3h5IiwidXRpbHMiLCJ0b0FycmF5IiwiY29udGVudCIsImRvY3VtZW50Iiwibm9kZSIsImZpcnN0Q2hpbGQiLCJvZmZzZXRUb3AiLCJvZmZzZXRMZWZ0IiwicHJldlRvcCIsInByZXZMZWZ0Iiwic2Nyb2xsV2lkdGgiLCJzY3JvbGxIZWlnaHQiLCJleHRyYVBhZFJpZ2h0IiwibWF4TGVmdCIsIm1heFRvcCIsImVsZW1lbnRXaWR0aCIsImVsZW1lbnRIZWlnaHQiLCJjb250ZW50SGVpZ2h0IiwibmV4dE5vZGUiLCJ0cmFuc2Zvcm1TdGFydCIsInRyYW5zZm9ybUVuZCIsImZvcmNlM0QiLCJmb3JjZSIsImFyZ3VtZW50cyIsImRpZiIsIm9sZE9mZnNldCIsImtpbGxUd2VlbnNPZiIsIm9uS2lsbCIsIl9za2lwIiwicGFkZGluZ1JpZ2h0IiwibWF4U2Nyb2xsVG9wIiwibWF4U2Nyb2xsTGVmdCIsImRpc2FibGUiLCJuZXh0U2libGluZyIsImFwcGVuZENoaWxkIiwicmVtb3ZlQ2hpbGQiLCJlbmFibGUiLCJjYWxpYnJhdGUiLCJ3aWR0aE1hdGNoZXMiLCJvZmZzZXRIZWlnaHQiLCJkaXNwbGF5IiwicGFkZGluZ0xlZnQiLCJvdmVyZmxvdyIsInZlcnRpY2FsQWxpZ24iLCJwYWRkaW5nQm90dG9tIiwiX2luaXRDb3JlIiwicmVxdWlyZWQiLCJuYXYiLCJuYXZpZ2F0b3IiLCJQb2ludGVyRXZlbnQiLCJjc3NUZXh0IiwiY3Vyc29yIiwidXNlckFnZW50IiwiaW5kZXhPZiIsIk1heFRvdWNoUG9pbnRzIiwibXNNYXhUb3VjaFBvaW50cyIsImRpdiIsImNoaWxkIiwiY2hpbGRTdHlsZSIsInBhcmVudCIsInZhbCIsImlubmVySFRNTCIsInR5cGVzIiwic3RhbmRhcmQiLCJzcGxpdCIsImNvbnZlcnRlZCIsImRlZmluZVByb3BlcnR5IiwiZ2V0IiwiaXNQcmVzc2VkIiwiZW5kRHJhZyIsInBsdWdpbnMiLCJpbmVydGlhIiwiY2hlY2tQcmVmaXgiLCJjb25zb2xlIiwid2FybiIsIkV2ZW50RGlzcGF0Y2hlciIsIl9wcm90byIsIl90aGlzIiwiRHJhZ2dhYmxlIiwiX0V2ZW50RGlzcGF0Y2hlciIsIl90aGlzMiIsInJvdGF0aW9uIiwiZHJhZ1Jlc2lzdGFuY2UiLCJlZGdlUmVzaXN0YW5jZSIsImlzTmFOIiwibG9ja0F4aXMiLCJhdXRvU2Nyb2xsIiwibG9ja2VkQXhpcyIsImFsbG93RXZlbnREZWZhdWx0IiwiZ2V0UHJvcGVydHkiLCJ4eU1vZGUiLCJyb3RhdGlvbk1vZGUiLCJ4UHJvcCIsInlQcm9wIiwiYWxsb3dYIiwiYWxsb3dZIiwibWluaW11bU1vdmVtZW50IiwidHJpZ2dlcnMiLCJ0cmlnZ2VyIiwiaGFuZGxlIiwia2lsbFByb3BzIiwiZHJhZ0VuZFRpbWUiLCJjaGVja0F1dG9TY3JvbGxCb3VuZHMiLCJhdXRvU2Nyb2xsTWFyZ2luVG9wIiwiYXV0b1Njcm9sbE1hcmdpblJpZ2h0IiwiYXV0b1Njcm9sbE1hcmdpbkJvdHRvbSIsImF1dG9TY3JvbGxNYXJnaW5MZWZ0IiwiaXNDbGlja2FibGUiLCJjbGlja2FibGVUZXN0IiwiY2xpY2tUaW1lIiwiZ3NDYWNoZSIsIl9nc2FwIiwiY29yZSIsImdldENhY2hlIiwiaXNGaXhlZCIsImdldFByb3BBc051bSIsInVuaXQiLCJvd25lckRvYyIsImVuYWJsZWQiLCJzY3JvbGxQcm94eSIsInN0YXJ0UG9pbnRlclgiLCJzdGFydFBvaW50ZXJZIiwic3RhcnRFbGVtZW50WCIsInN0YXJ0RWxlbWVudFkiLCJoYXNCb3VuZHMiLCJoYXNEcmFnQ2FsbGJhY2siLCJoYXNNb3ZlQ2FsbGJhY2siLCJ0b3VjaCIsInRvdWNoSUQiLCJyb3RhdGlvbk9yaWdpbiIsImRpcnR5Iiwib2xkIiwic25hcFgiLCJzbmFwWSIsInNuYXBYWSIsImlzQ2xpY2tpbmciLCJ0b3VjaEV2ZW50VGFyZ2V0IiwiaW50ZXJydXB0ZWQiLCJhbGxvd05hdGl2ZVRvdWNoU2Nyb2xsaW5nIiwidG91Y2hEcmFnQXhpcyIsImlzRGlzcGF0Y2hpbmciLCJjbGlja0Rpc3BhdGNoIiwidHJ1c3RlZENsaWNrRGlzcGF0Y2giLCJpc1ByZXZlbnRpbmdEZWZhdWx0IiwiaW5uZXJNYXRyaXgiLCJvbkNvbnRleHRNZW51Iiwic3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uIiwicmVuZGVyIiwic3VwcHJlc3NFdmVudHMiLCJpc0RyYWdnaW5nIiwiYXV0b1Njcm9sbEZhY3RvciIsImlzUm9vdCIsInJlY3QiLCJwb2ludGVyWCIsInBvaW50ZXJZIiwiY2hhbmdlWCIsImNoYW5nZVkiLCJnYXAiLCJzY3JvbGxUbyIsInNldFBvaW50ZXJQb3NpdGlvbiIsImRlbHRhWCIsInJlbmRlclRyYW5zZm9ybSIsImRlbHRhWSIsInN5bmNYWSIsInNraXBPblVwZGF0ZSIsInNraXBTbmFwIiwic25hcHBlZFZhbHVlIiwidW5jYWNoZSIsImlzVGhyb3dpbmciLCJidWlsZFNuYXBGdW5jIiwibiIsImVkZ2VUb2xlcmFuY2UiLCJjbG9zZXN0IiwiYWJzRGlmIiwiYnVpbGRQb2ludFNuYXBGdW5jIiwicmFkaXVzIiwicG9pbnQiLCJkeCIsImR5IiwibWluRGlzdCIsImRpc3QiLCJjYWxjdWxhdGVCb3VuZHMiLCJib3VuZHMiLCJ0YXJnZXRCb3VuZHMiLCJzbmFwSXNSYXciLCJsaXZlU25hcCIsInBvaW50cyIsIm9uVGhyb3dDb21wbGV0ZSIsIm9uVGhyb3dJbnRlcnJ1cHQiLCJhbmltYXRlIiwidHdlZW4iLCJvdmVyc2hvb3RUb2xlcmFuY2UiLCJyZXNpc3RhbmNlIiwidGhyb3dSZXNpc3RhbmNlIiwibGlua2VkUHJvcHMiLCJtaW5EdXJhdGlvbiIsIm1heER1cmF0aW9uIiwib3ZlcnNob290Iiwib25JbnRlcnJ1cHQiLCJvblVwZGF0ZSIsImZhc3RNb2RlIiwib25VcGRhdGVQYXJhbXMiLCJlbmRYIiwiZW5kWSIsImVuZFJvdGF0aW9uIiwicGxheSIsImFwcGx5Qm91bmRzIiwidXBkYXRlTWF0cml4Iiwic2hpZnRTdGFydCIsInN0YXJ0IiwiZXF1YWxzIiwiaW52ZXJzZSIsInJlY29yZFN0YXJ0UG9zaXRpb25zIiwib2Zmc2V0WCIsIm9mZnNldFkiLCJwYXJzZWRPcmlnaW4iLCJpc1R3ZWVuaW5nIiwieE9yaWdpbiIsInlPcmlnaW4iLCJhdGFuMiIsInN0YXJ0WCIsInN0YXJ0WSIsImlzQWN0aXZlIiwicmVtb3ZlUGxhY2Vob2xkZXIiLCJvblByZXNzIiwiY3VycmVudFRhcmdldCIsIm9uUmVsZWFzZSIsIm9uTW92ZSIsImRyYWdDbGlja2FibGVzIiwiYWxsb3dDb250ZXh0TWVudSIsImN0cmxLZXkiLCJ3aGljaCIsImNoYW5nZWRUb3VjaGVzIiwicG9pbnRlcklkIiwia2lsbCIsInpJbmRleEJvb3N0IiwiekluZGV4Iiwib25EcmFnIiwiZHJhZyIsIm1vdmUiLCJhY3RpdmVDdXJzb3IiLCJvcmlnaW5hbEV2ZW50IiwiYWJzIiwibG9ja0F4aXNPblRvdWNoU2Nyb2xsIiwib25Mb2NrQXhpcyIsImNhbmNlbGFibGUiLCJpbnZva2VPbk1vdmUiLCJkcmFnVG9sZXJhbmNlIiwicHJldlBvaW50ZXJYIiwicHJldlBvaW50ZXJZIiwicHJldlN0YXJ0RWxlbWVudFkiLCJwcmV2WCIsInByZXZZIiwicHJldkVuZFgiLCJwcmV2RW5kWSIsInByZXZFbmRSb3RhdGlvbiIsInByZXZEaXJ0eSIsInhDaGFuZ2UiLCJ5Q2hhbmdlIiwidGVtcCIsImMiLCJiIiwiZCIsImYiLCJ3YXNEcmFnZ2luZyIsImlzQ29udGV4dE1lbnVSZWxlYXNlIiwicGxhY2Vob2xkZXJEZWxheWVkQ2FsbCIsImRlbGF5ZWRDYWxsIiwic3ludGhldGljRXZlbnQiLCJldmVudFRhcmdldCIsInN5bnRoZXRpY0NsaWNrIiwidGhyb3dQcm9wcyIsImRlZmF1bHRQcmV2ZW50ZWQiLCJjbGljayIsImNyZWF0ZUV2ZW50IiwiaW5pdE1vdXNlRXZlbnQiLCJzY3JlZW5YIiwic2NyZWVuWSIsInVwZGF0ZVNjcm9sbCIsIm9uQ2xpY2siLCJ0aW1lIiwicmVjZW50bHlDbGlja2VkIiwicmVjZW50bHlEcmFnZ2VkIiwiYWxyZWFkeURpc3BhdGNoZWQiLCJhbHJlYWR5RGlzcGF0Y2hlZFRydXN0ZWQiLCJ0cnVzdGVkIiwiaXNUcnVzdGVkIiwic3VwcHJlc3NDbGlja09uRHJhZyIsImRldGFpbCIsImxvY2FsaXplUG9pbnQiLCJzdGFydERyYWciLCJhbGlnbiIsInIxIiwicjIiLCJoaXRUZXN0IiwidGltZVNpbmNlRHJhZyIsInRpbWVTaW5jZUNsaWNrIiwidGhyZXNob2xkIiwiZ2V0RGlyZWN0aW9uIiwiZnJvbSIsImRpYWdvbmFsVGhyZXNob2xkIiwibW9kZSIsInJhdGlvIiwiZGlyZWN0aW9uIiwiZ2V0VmVsb2NpdHkiLCJuZXdCb3VuZHMiLCJzdGlja3kiLCJ1cGRhdGUiLCJpZ25vcmVFeHRlcm5hbENoYW5nZXMiLCJtIiwibTIiLCJzZXRWYXJzIiwiaWQiLCJ0b3VjaENhbGxvdXQiLCJ0cmFjayIsIl9nc0RyYWdJRCIsImRyYWdnaW5nIiwidW50cmFjayIsImNsZWFyUHJvcHMiLCJvdmVyZmxvd1kiLCJvdmVyZmxvd1giLCJyZWdpc3RlciIsInRhcmdldHMiLCJtYXAiLCJvYmoxIiwib2JqMiIsImlzT3V0c2lkZSIsIm92ZXJsYXAiLCJhcmVhIiwiaXNSYXRpbyIsInZlcnNpb24iLCJkZWZhdWx0IiwiX3N2Z1BhdGhFeHAiLCJfbnVtYmVyc0V4cCIsIl9zY2llbnRpZmljIiwiX3NlbGVjdG9yRXhwIiwiX0RFRzJSQUQiLCJfc2luIiwic2luIiwiX2NvcyIsImNvcyIsIl9hYnMiLCJfc3FydCIsInNxcnQiLCJfYXRhbjIiLCJfbGFyZ2VOdW0iLCJfaXNTdHJpbmciLCJfaXNOdW1iZXIiLCJfdGVtcCIsIl90ZW1wMiIsIl9yb3VuZGluZ051bSIsIl93cmFwUHJvZ3Jlc3MiLCJwcm9ncmVzcyIsIl9yb3VuZFByZWNpc2UiLCJfc3BsaXRTZWdtZW50IiwicmF3UGF0aCIsInNlZ0luZGV4IiwidCIsInNlZ21lbnQiLCJzaGlmdCIsInN1YmRpdmlkZVNlZ21lbnQiLCJzbGljZSIsIl9nZXRTYW1wbGVJbmRleCIsInNhbXBsZXMiLCJfcmV2ZXJzZVJhd1BhdGgiLCJza2lwT3V0ZXIiLCJyZXZlcnNlIiwicmV2ZXJzZWQiLCJyZXZlcnNlU2VnbWVudCIsIl9jb3B5TWV0YURhdGEiLCJzb3VyY2UiLCJ0b3RhbExlbmd0aCIsImxvb2t1cCIsIm1pbkxlbmd0aCIsInJlc29sdXRpb24iLCJ0b3RhbFBvaW50cyIsIl9hcHBlbmRPck1lcmdlIiwiaW5kZXgiLCJwcmV2U2VnIiwiY29uY2F0IiwiX2Jlc3REaXN0YW5jZSIsImdldFJhd1BhdGgiLCJxdWVyeVNlbGVjdG9yIiwiX2dzUGF0aCIsIl9kaXJ0eSIsInN0cmluZ1RvUmF3UGF0aCIsImNvcHlSYXdQYXRoIiwiX2NyZWF0ZVBhdGgiLCJpZ25vcmUiLCJwYXRoIiwiYXR0ciIsImF0dHJpYnV0ZXMiLCJuYW1lIiwic2V0QXR0cmlidXRlTlMiLCJub2RlVmFsdWUiLCJfdHlwZUF0dHJzIiwiY2lyY2xlIiwiZWxsaXBzZSIsImxpbmUiLCJfYXR0clRvT2JqIiwiYXR0cnMiLCJwcm9wcyIsImNvbnZlcnRUb1BhdGgiLCJzd2FwIiwidGFnTmFtZSIsImNpcmMiLCJyeSIsInJjaXJjIiwicnljaXJjIiwidyIsImgiLCJ4MiIsIngzIiwieDQiLCJ4NSIsIng2IiwieTIiLCJ5MyIsInk0IiwieTUiLCJ5NiIsInJ4Iiwiam9pbiIsImN4IiwiY3kiLCJ4MSIsInkxIiwibWF0Y2giLCJzZXRBdHRyaWJ1dGUiLCJyYXdQYXRoVG9TdHJpbmciLCJfZ3NSYXdQYXRoIiwiaW5zZXJ0QmVmb3JlIiwiZ2V0Um90YXRpb25BdFByb2dyZXNzIiwiZ2V0UHJvZ3Jlc3NEYXRhIiwiZ2V0Um90YXRpb25BdEJlemllclQiLCJzbGljZVJhd1BhdGgiLCJsb29wcyIsImNhY2hlUmF3UGF0aE1lYXN1cmVtZW50cyIsIndyYXAiLCJzIiwiZVNlZyIsInNTZWciLCJlU2VnSW5kZXgiLCJzU2VnSW5kZXgiLCJlaSIsInNpIiwic2FtZVNlZ21lbnQiLCJzYW1lQmV6aWVyIiwid3JhcHNCZWhpbmQiLCJzU2hpZnQiLCJlU2hpZnQiLCJ0b3RhbFNlZ21lbnRzIiwiaiIsImFuZ2xlIiwibWVhc3VyZVNlZ21lbnQiLCJzdGFydEluZGV4IiwiYmV6aWVyUXR5IiwiaW5jIiwiZW5kSW5kZXgiLCJzYW1wbGVzSW5kZXgiLCJwcmV2TGVuZ3RoIiwieGQiLCJ4ZDEiLCJ5ZCIsInlkMSIsImludiIsImxlbmd0aEluZGV4Iiwic2VnTGVuZ3RoIiwicGF0aExlbmd0aCIsImF4IiwiYXkiLCJjcDF4IiwiY3AxeSIsImNwMngiLCJjcDJ5IiwiYngiLCJieSIsIngxYSIsInkxYSIsIngyYSIsInkyYSIsImRlY29yYXRlZSIsInB1c2hUb05leHRJZkF0RW5kIiwiZ2V0UG9zaXRpb25PblBhdGgiLCJpbmNsdWRlQW5nbGUiLCJ0cmFuc2Zvcm1SYXdQYXRoIiwidHgiLCJ0eSIsImFyY1RvU2VnbWVudCIsImxhc3RYIiwibGFzdFkiLCJsYXJnZUFyY0ZsYWciLCJzd2VlcEZsYWciLCJhbmdsZVJhZCIsImNvc0FuZ2xlIiwic2luQW5nbGUiLCJUV09QSSIsImR4MiIsImR5MiIsIngxX3NxIiwieTFfc3EiLCJyYWRpaUNoZWNrIiwicnhfc3EiLCJyeV9zcSIsInNxIiwiY29lZiIsImN4MSIsImN5MSIsInN4MiIsInN5MiIsInV4IiwidXkiLCJ2eCIsInZ5IiwiYW5nbGVTdGFydCIsImFjb3MiLCJhbmdsZUV4dGVudCIsInNlZ21lbnRzIiwiY2VpbCIsImFuZ2xlSW5jcmVtZW50IiwiY29udHJvbExlbmd0aCIsIm1hIiwibWIiLCJtYyIsIm1kIiwicmVsYXRpdmVYIiwicmVsYXRpdmVZIiwidHdvVGhpcmRzIiwiZXJyb3JNZXNzYWdlIiwiY29tbWFuZCIsImlzUmVsYXRpdmUiLCJkaWZYIiwiZGlmWSIsImJlemllcnMiLCJwcmV2Q29tbWFuZCIsImZsYWcxIiwiZmxhZzIiLCJzeCIsInN5IiwiZXgiLCJleSIsImxvZyIsInRvVXBwZXJDYXNlIiwiY2xvc2VkIiwic3Vic3RyIiwiY2hhckF0IiwicG9wIiwiYmV6aWVyVG9Qb2ludHMiLCJ4MTIiLCJ5MTIiLCJ4MjMiLCJ5MjMiLCJ4MzQiLCJ5MzQiLCJ4MTIzIiwieTEyMyIsIngyMzQiLCJ5MjM0IiwieDEyMzQiLCJ5MTIzNCIsImQyIiwiZDMiLCJmbGF0UG9pbnRzVG9TZWdtZW50IiwiY3VydmluZXNzIiwicG9pbnRzVG9TZWdtZW50IiwibmV4dFgiLCJuZXh0WSIsImR4MSIsImR5MSIsInIzIiwidGwiLCJteDEiLCJteDIiLCJteG0iLCJteTEiLCJteTIiLCJteW0iLCJ1bnNoaWZ0IiwicG93IiwicG9pbnRUb1NlZ0Rpc3QiLCJzaW1wbGlmeVN0ZXAiLCJmaXJzdCIsImxhc3QiLCJ0b2xlcmFuY2UiLCJzaW1wbGlmaWVkIiwibWF4U3FEaXN0IiwiZmlyc3RYIiwiZmlyc3RZIiwic2ltcGxpZnlQb2ludHMiLCJnZXRDbG9zZXN0UHJvZ3Jlc3NPbkJlemllciIsIml0ZXJhdGlvbnMiLCJweCIsInB5Iiwic2xpY2VzIiwieDAiLCJ5MCIsImJlc3QiLCJnZXRDbG9zZXN0RGF0YSIsImJlc3REaXN0YW5jZSIsInN1YmRpdmlkZVNlZ21lbnROZWFyIiwiYmVzdFQiLCJiZXN0U2VnbWVudEluZGV4Iiwic2wiLCJfY29udmVydFRvUGF0aCIsIl94UHJvcHMiLCJfeVByb3BzIiwiUHJvcFR3ZWVuIiwiX2dldFVuaXQiLCJfcG9wdWxhdGVTZWdtZW50RnJvbUFycmF5IiwidmFsdWVzIiwidiIsIl9nZXRQcm9wTnVtIiwicHJvcCIsIl9yZWxhdGl2aXplIiwiX3NlZ21lbnRUb1Jhd1BhdGgiLCJwbHVnaW4iLCJzbGljZXIiLCJ1bml0WCIsInVuaXRZIiwiZnJvbUN1cnJlbnQiLCJyZWxhdGl2ZSIsInBvaW50RnVuYyIsIl9hbGlnbiIsIl9hZGREaW1lbnNpb25hbFByb3BUd2VlbiIsIl9udW1FeHAiLCJfb3JpZ2luVG9Qb2ludCIsIm9yaWdpbiIsInBhcmVudE1hdHJpeCIsInN2ZyIsIm9mZnNldFdpZHRoIiwiX2dldEFsaWduTWF0cml4IiwiZnJvbUVsZW1lbnQiLCJ0b0VsZW1lbnQiLCJmcm9tT3JpZ2luIiwidG9PcmlnaW4iLCJjbG9uZSIsImZyb21Qb2ludCIsIl9vcmlnaW5Ub1BvaW50MiIsImdldFRvdGFsTGVuZ3RoIiwiX3JlZiIsImFsaWduT3JpZ2luIiwiY3VyWCIsImN1clkiLCJhbGlnblRhcmdldCIsInRyYW5zZm9ybU9yaWdpbiIsInBhdGhQcm9wZXJ0eSIsImZvcmNlVW5pdCIsImNhY2hlIiwiaGFybmVzcyIsImFsaWFzIiwiYWxpYXNlcyIsInB0IiwiX3B0IiwidSIsInBwIiwiX3Byb3BzIiwiX3NsaWNlTW9kaWZpZXIiLCJNb3Rpb25QYXRoUGx1Z2luIiwiUGx1Z2luIiwicHJvcFR3ZWVuIiwiZ2V0VW5pdCIsImluaXQiLCJyYXdQYXRocyIsIl92YXJzIiwiYXV0b1JvdGF0ZSIsImZpcnN0T2JqIiwicm90YXRlIiwick9mZnNldCIsInJhZGlhbnMiLCJ1c2VSYWRpYW5zIiwiclByb3AiLCJyU2V0IiwicnUiLCJfbmV4dCIsImdldExlbmd0aCIsImNvbnZlcnRDb29yZGluYXRlcyIsImdldEFsaWduTWF0cml4IiwiZ2V0UmVsYXRpdmVQb3NpdGlvbiIsImFycmF5VG9SYXdQYXRoIiwiX2RlZmluZVByb3BlcnRpZXMiLCJkZXNjcmlwdG9yIiwiZW51bWVyYWJsZSIsImNvbmZpZ3VyYWJsZSIsIndyaXRhYmxlIiwia2V5IiwiX2NyZWF0ZUNsYXNzIiwiQ29uc3RydWN0b3IiLCJwcm90b1Byb3BzIiwic3RhdGljUHJvcHMiLCJfY2xhbXAiLCJfZG9jRWwiLCJfaXNUb3VjaCIsIl9wb2ludGVyVHlwZSIsIlNjcm9sbFRyaWdnZXIiLCJfcm9vdCIsIl9ub3JtYWxpemVyIiwiX2V2ZW50VHlwZXMiLCJfcGFzc1Rocm91Z2giLCJfc3RhcnR1cCIsIl9vYnNlcnZlcnMiLCJfc2Nyb2xsZXJzIiwiX3Byb3hpZXMiLCJfYnJpZGdlIiwiX2ludGVncmF0ZSIsImJyaWRnZSIsInNjcm9sbGVycyIsInByb3hpZXMiLCJfZ2V0UHJveHlQcm9wIiwiX2lzVmlld3BvcnQiLCJlbCIsIm5vblBhc3NpdmUiLCJfc2Nyb2xsTGVmdCIsIl9zY3JvbGxUb3AiLCJfb25TY3JvbGwiLCJfc2Nyb2xsQ2FjaGVGdW5jIiwiZG9Ob3RDYWNoZSIsImNhY2hpbmdGdW5jIiwiaGlzdG9yeSIsInNjcm9sbFJlc3RvcmF0aW9uIiwiaXNOb3JtYWxpemluZyIsImlPUyIsImNhY2hlSUQiLCJfaG9yaXpvbnRhbCIsIm9zIiwib3MyIiwic2MiLCJfdmVydGljYWwiLCJvcCIsIl9nZXRUYXJnZXQiLCJjb25maWciLCJudWxsVGFyZ2V0V2FybiIsIl9nZXRTY3JvbGxGdW5jIiwiX2dldFZlbG9jaXR5UHJvcCIsIm1pblRpbWVSZWZyZXNoIiwidXNlRGVsdGEiLCJ2MSIsInYyIiwidDEiLCJ0MiIsImRyb3BUb1plcm9UaW1lIiwicmVzZXQiLCJsYXRlc3RWYWx1ZSIsInRPbGQiLCJ2T2xkIiwiX2dldEV2ZW50IiwiX2dzYXBBbGxvdyIsIl9nZXRBYnNvbHV0ZU1heCIsIl9zZXRTY3JvbGxUcmlnZ2VyIiwiZ2xvYmFscyIsImNsYW1wIiwiT2JzZXJ2ZXIiLCJpc1RvdWNoIiwibWF0Y2hNZWRpYSIsIm1hdGNoZXMiLCJtYXhUb3VjaFBvaW50cyIsImV2ZW50VHlwZXMiLCJzZXRUaW1lb3V0IiwiZHJhZ01pbmltdW0iLCJsaW5lSGVpZ2h0IiwiZGVib3VuY2UiLCJvblN0b3AiLCJvblN0b3BEZWxheSIsIndoZWVsU3BlZWQiLCJvbkRyYWdTdGFydCIsIm9uRHJhZ0VuZCIsIm9uUmlnaHQiLCJvbkxlZnQiLCJvblVwIiwib25Eb3duIiwib25DaGFuZ2VYIiwib25DaGFuZ2VZIiwib25DaGFuZ2UiLCJvblRvZ2dsZVgiLCJvblRvZ2dsZVkiLCJvbkhvdmVyIiwib25Ib3ZlckVuZCIsImlnbm9yZUNoZWNrIiwiaXNOb3JtYWxpemVyIiwib25HZXN0dXJlU3RhcnQiLCJvbkdlc3R1cmVFbmQiLCJvbldoZWVsIiwib25FbmFibGUiLCJvbkRpc2FibGUiLCJzY3JvbGxTcGVlZCIsImFsbG93Q2xpY2tzIiwib25TdG9wRGVsYXllZENhbGwiLCJkcmFnZ2VkIiwibW92ZWQiLCJ3aGVlbGVkIiwibG9ja2VkIiwicHJldkRlbHRhWCIsInByZXZEZWx0YVkiLCJzY3JvbGxGdW5jWCIsInNjcm9sbEZ1bmNZIiwic2Nyb2xsWCIsInNjcm9sbFkiLCJsaW1pdFRvVG91Y2giLCJpc1ZpZXdwb3J0Iiwib25DbGlja1RpbWUiLCJjbGlja0NhcHR1cmUiLCJfaWdub3JlQ2hlY2siLCJpc1BvaW50ZXJPclRvdWNoIiwicG9pbnRlclR5cGUiLCJvblN0b3BGdW5jIiwiX3Z4IiwiX3Z5IiwicGF1c2UiLCJjaGFuZ2VkWCIsImNoYW5nZWRZIiwib25EZWx0YSIsInJlcXVlc3RBbmltYXRpb25GcmFtZSIsIm9uVG91Y2hPclBvaW50ZXJEZWx0YSIsIl9vbkRyYWciLCJjbGllbnRYIiwiY2xpZW50WSIsIl9vblByZXNzIiwiX29uUmVsZWFzZSIsImV2ZW50RGF0YSIsImlzR2VzdHVyaW5nIiwicmVzdGFydCIsIl9vbkdlc3R1cmVTdGFydCIsIl9vbkdlc3R1cmVFbmQiLCJvblNjcm9sbCIsIl9vbldoZWVsIiwibXVsdGlwbGllciIsImRlbHRhTW9kZSIsIl9vbk1vdmUiLCJfb25Ib3ZlciIsIl9vbkhvdmVyRW5kIiwiX29uQ2xpY2siLCJfZGMiLCJpc0VuYWJsZWQiLCJmaWx0ZXIiLCJvIiwiZ2V0QWxsIiwiZ2V0QnlJZCIsIl9yZXNpemVEZWxheSIsIl90aW1lMiIsIl9zeW5jSW50ZXJ2YWwiLCJfcmVmcmVzaGluZyIsIl9wb2ludGVySXNEb3duIiwiX2kiLCJfcHJldldpZHRoIiwiX3ByZXZIZWlnaHQiLCJfYXV0b1JlZnJlc2giLCJfc29ydCIsIl9zdXBwcmVzc092ZXJ3cml0ZXMiLCJfaWdub3JlUmVzaXplIiwiX2lnbm9yZU1vYmlsZVJlc2l6ZSIsIl9iYXNlU2NyZWVuSGVpZ2h0IiwiX2Jhc2VTY3JlZW5XaWR0aCIsIl9maXhJT1NCdWciLCJfbGltaXRDYWxsYmFja3MiLCJfdGltZTEiLCJfbGFzdFNjcm9sbFRpbWUiLCJfZW5hYmxlZCIsIl9wb2ludGVyRG93bkhhbmRsZXIiLCJfcG9pbnRlclVwSGFuZGxlciIsIl9nZXRCb3VuZHNGdW5jIiwiX3dpbk9mZnNldHMiLCJfZ2V0U2l6ZUZ1bmMiLCJzY3JvbGxlciIsIl9nZXRPZmZzZXRzRnVuYyIsIl9tYXhTY3JvbGwiLCJfcmVmMiIsIl9pdGVyYXRlQXV0b1JlZnJlc2giLCJldmVudHMiLCJfY2FsbElmRnVuYyIsIl9jb21iaW5lRnVuYyIsImYxIiwiZjIiLCJyZXN1bHQxIiwicmVzdWx0MiIsIl9lbmRBbmltYXRpb24iLCJhbmltYXRpb24iLCJfY2FsbGJhY2siLCJ0b3RhbFRpbWUiLCJjYWxsYmFja0FuaW1hdGlvbiIsIl9sZWZ0IiwiX3RvcCIsIl9yaWdodCIsIl9ib3R0b20iLCJfd2lkdGgiLCJfaGVpZ2h0IiwiX1JpZ2h0IiwiX0xlZnQiLCJfVG9wIiwiX0JvdHRvbSIsIl9wYWRkaW5nIiwiX21hcmdpbiIsIl9XaWR0aCIsIl9IZWlnaHQiLCJfcHgiLCJfbWFrZVBvc2l0aW9uYWJsZSIsIndpdGhvdXRUcmFuc2Zvcm1zIiwieFBlcmNlbnQiLCJ5UGVyY2VudCIsInJvdGF0aW9uWCIsInJvdGF0aW9uWSIsInNjYWxlIiwic2tld1giLCJza2V3WSIsIl9nZXRTaXplIiwiX3JlZjMiLCJfZ2V0TGFiZWxSYXRpb0FycmF5IiwidGltZWxpbmUiLCJsYWJlbHMiLCJfZ2V0Q2xvc2VzdExhYmVsIiwiX3NuYXBEaXJlY3Rpb25hbCIsInNuYXBJbmNyZW1lbnRPckFycmF5Iiwic29ydCIsInNuYXBwZWQiLCJfZ2V0TGFiZWxBdERpcmVjdGlvbiIsInN0IiwiX211bHRpTGlzdGVuZXIiLCJfd2hlZWxMaXN0ZW5lciIsInNjcm9sbEZ1bmMiLCJ3aGVlbEhhbmRsZXIiLCJfbWFya2VyRGVmYXVsdHMiLCJzdGFydENvbG9yIiwiZW5kQ29sb3IiLCJpbmRlbnQiLCJmb250U2l6ZSIsImZvbnRXZWlnaHQiLCJfZGVmYXVsdHMiLCJ0b2dnbGVBY3Rpb25zIiwiYW50aWNpcGF0ZVBpbiIsIl9rZXl3b3JkcyIsImNlbnRlciIsIl9vZmZzZXRUb1B4Iiwic2l6ZSIsImVxSW5kZXgiLCJfY3JlYXRlTWFya2VyIiwiY29udGFpbmVyIiwiX3JlZjQiLCJtYXRjaFdpZHRoRWwiLCJjb250YWluZXJBbmltYXRpb24iLCJ1c2VGaXhlZFBvc2l0aW9uIiwiaXNTY3JvbGxlciIsImlzU3RhcnQiLCJjb2xvciIsImNzcyIsIl9pc1N0YXJ0IiwiaW5uZXJUZXh0IiwiX29mZnNldCIsIl9wb3NpdGlvbk1hcmtlciIsIm1hcmtlciIsImZsaXBwZWQiLCJzaWRlIiwib3Bwb3NpdGVTaWRlIiwiX2lzRmxpcHBlZCIsIl90cmlnZ2VycyIsIl9pZHMiLCJfcmFmSUQiLCJfc3luYyIsIl91cGRhdGVBbGwiLCJfZGlzcGF0Y2giLCJfc2V0QmFzZURpbWVuc2lvbnMiLCJfb25SZXNpemUiLCJmdWxsc2NyZWVuRWxlbWVudCIsIndlYmtpdEZ1bGxzY3JlZW5FbGVtZW50IiwiX2VtcHR5QXJyYXkiLCJfbWVkaWEiLCJfY3JlYXRpbmdNZWRpYSIsIl9sYXN0TWVkaWFUaWNrIiwiX29uTWVkaWFDaGFuZ2UiLCJ0aWNrIiwiZnJhbWUiLCJfcmV2ZXJ0QWxsIiwiX3JldmVydFJlY29yZGVkIiwiX3JlZnJlc2hBbGwiLCJfc29mdFJlZnJlc2giLCJfc2F2ZWRTdHlsZXMiLCJtZWRpYSIsInJldmVydCIsIl9jbGVhclNjcm9sbE1lbW9yeSIsInJlYyIsIl9yZWZyZXNoaW5nQWxsIiwiX3JlZnJlc2hJRCIsInNraXBSZXZlcnQiLCJyZWZyZXNoSW5pdHMiLCJyZWZyZXNoIiwic2V0UG9zaXRpb25zIiwiX2RpciIsIl9sYXN0U2Nyb2xsIiwiX2RpcmVjdGlvbiIsIl9wcmltYXJ5IiwiaXNVcGRhdGluZyIsInJlY29yZFZlbG9jaXR5IiwiX3Byb3BOYW1lc1RvQ29weSIsIl9zdGF0ZVByb3BzIiwiX3N3YXBQaW5PdXQiLCJwaW4iLCJzcGFjZXIiLCJzdGF0ZSIsIl9zZXRTdGF0ZSIsInNwYWNlcklzTmF0aXZlIiwic3BhY2VyU3RhdGUiLCJfc3dhcFBpbkluIiwic3BhY2VyU3R5bGUiLCJwaW5TdHlsZSIsImZsZXhCYXNpcyIsIl9jYXBzRXhwIiwiX2dldFN0YXRlIiwiX2NvcHlTdGF0ZSIsIm92ZXJyaWRlIiwib21pdE9mZnNldHMiLCJfcGFyc2VQb3NpdGlvbiIsInNjcm9sbGVyU2l6ZSIsIm1hcmtlclNjcm9sbGVyIiwic2Nyb2xsZXJCb3VuZHMiLCJib3JkZXJXaWR0aCIsInNjcm9sbGVyTWF4Iiwic2VlayIsIm9mZnNldHMiLCJsb2NhbE9mZnNldCIsImdsb2JhbE9mZnNldCIsIl9jYVNjcm9sbERpc3QiLCJfcHJlZml4RXhwIiwiX3JlcGFyZW50IiwiX3N0T3JpZyIsIl9nZXRUd2VlbkNyZWF0b3IiLCJnZXRTY3JvbGwiLCJsYXN0U2Nyb2xsMSIsImxhc3RTY3JvbGwyIiwiZ2V0VHdlZW4iLCJpbml0aWFsVmFsdWUiLCJjaGFuZ2UxIiwiY2hhbmdlMiIsIm1vZGlmaWVycyIsInRvZ2dsZUNsYXNzIiwib25Ub2dnbGUiLCJvblJlZnJlc2giLCJzY3J1YiIsInBpblNwYWNpbmciLCJpbnZhbGlkYXRlT25SZWZyZXNoIiwib25TY3J1YkNvbXBsZXRlIiwib25TbmFwQ29tcGxldGUiLCJvbmNlIiwicGluUmVwYXJlbnQiLCJwaW5TcGFjZXIiLCJmYXN0U2Nyb2xsRW5kIiwicHJldmVudE92ZXJsYXBzIiwiaG9yaXpvbnRhbCIsImlzVG9nZ2xlIiwic2Nyb2xsZXJDYWNoZSIsInBpblR5cGUiLCJjYWxsYmFja3MiLCJvbkVudGVyIiwib25MZWF2ZSIsIm9uRW50ZXJCYWNrIiwib25MZWF2ZUJhY2siLCJtYXJrZXJzIiwib25SZWZyZXNoSW5pdCIsImdldFNjcm9sbGVyU2l6ZSIsImdldFNjcm9sbGVyT2Zmc2V0cyIsImxhc3RTbmFwIiwibGFzdFJlZnJlc2giLCJ0d2VlblRvIiwicGluQ2FjaGUiLCJzbmFwRnVuYyIsInNjcm9sbDEiLCJzY3JvbGwyIiwibWFya2VyU3RhcnQiLCJtYXJrZXJFbmQiLCJtYXJrZXJTdGFydFRyaWdnZXIiLCJtYXJrZXJFbmRUcmlnZ2VyIiwibWFya2VyVmFycyIsImNoYW5nZSIsInBpbk9yaWdpbmFsU3RhdGUiLCJwaW5BY3RpdmVTdGF0ZSIsInBpblN0YXRlIiwicGluR2V0dGVyIiwicGluU2V0dGVyIiwicGluU3RhcnQiLCJwaW5DaGFuZ2UiLCJzcGFjaW5nU3RhcnQiLCJtYXJrZXJTdGFydFNldHRlciIsIm1hcmtlckVuZFNldHRlciIsInNuYXAxIiwic25hcDIiLCJzY3J1YlR3ZWVuIiwic2NydWJTbW9vdGgiLCJzbmFwRHVyQ2xhbXAiLCJzbmFwRGVsYXllZENhbGwiLCJwcmV2UHJvZ3Jlc3MiLCJwcmV2U2Nyb2xsIiwicHJldkFuaW1Qcm9ncmVzcyIsImNhTWFya2VyU2V0dGVyIiwiY3VzdG9tUmV2ZXJ0UmV0dXJuIiwiYmluZCIsInJlZnJlc2hQcmlvcml0eSIsInR3ZWVuU2Nyb2xsIiwic2NydWJEdXJhdGlvbiIsImVhc2UiLCJ0b3RhbFByb2dyZXNzIiwicGF1c2VkIiwiX2luaXR0ZWQiLCJpbW1lZGlhdGVSZW5kZXIiLCJzY3JvbGxUcmlnZ2VyIiwic25hcFRvIiwic2Nyb2xsQmVoYXZpb3IiLCJkaXJlY3Rpb25hbCIsInJlZnJlc2hlZFJlY2VudGx5IiwibmF0dXJhbEVuZCIsImVuZFZhbHVlIiwiZW5kU2Nyb2xsIiwiX3NuYXAiLCJvblN0YXJ0IiwiX29uSW50ZXJydXB0IiwiX29uQ29tcGxldGUiLCJzdFJldmVydCIsImNsYXNzTmFtZSIsImN1cnJlbnQiLCJuYXRpdmVFbGVtZW50IiwiY2xhc3NMaXN0IiwicXVpY2tTZXR0ZXIiLCJvbGRPblVwZGF0ZSIsIm9sZFBhcmFtcyIsImV2ZW50Q2FsbGJhY2siLCJwcmV2aW91cyIsIm5leHQiLCJwcmV2UmVmcmVzaGluZyIsImlzUmV2ZXJ0ZWQiLCJzb2Z0IiwiaW52YWxpZGF0ZSIsIm90aGVyUGluT2Zmc2V0IiwicGFyc2VkRW5kIiwicGFyc2VkRW5kVHJpZ2dlciIsImVuZFRyaWdnZXIiLCJwYXJzZWRTdGFydCIsInBpbm5lZENvbnRhaW5lciIsInRyaWdnZXJJbmRleCIsImlzVmVydGljYWwiLCJjdXJUcmlnZ2VyIiwiY3VyUGluIiwib3Bwb3NpdGVTY3JvbGwiLCJpbml0dGVkIiwicmV2ZXJ0ZWRQaW5zIiwiX3BpblB1c2giLCJfcGluT2Zmc2V0IiwiZW5kQW5pbWF0aW9uIiwibGFiZWxUb1Njcm9sbCIsImxhYmVsIiwiZ2V0VHJhaWxpbmciLCJmb3JjZUZha2UiLCJjbGlwcGVkIiwid2FzQWN0aXZlIiwidG9nZ2xlU3RhdGUiLCJhY3Rpb24iLCJzdGF0ZUNoYW5nZWQiLCJ0b2dnbGVkIiwiaXNBdE1heCIsImlzVGFraW5nQWN0aW9uIiwiX2RwIiwiX3RpbWUiLCJfc3RhcnQiLCJyZXNldFRvIiwiX3RUaW1lIiwiX3REdXIiLCJuZXdTdGFydCIsIm5ld0VuZCIsImFsbG93QW5pbWF0aW9uIiwiY2xlYXJJbnRlcnZhbCIsInN1cHByZXNzT3ZlcndyaXRlcyIsIm9yaWVudGF0aW9uUG9ydHJhaXQiLCJib2R5U3R5bGUiLCJib3JkZXIiLCJib3JkZXJUb3BTdHlsZSIsInNldEludGVydmFsIiwiaGlkZGVuIiwibGltaXRDYWxsYmFja3MiLCJtcyIsInN5bmNJbnRlcnZhbCIsImlnbm9yZU1vYmlsZVJlc2l6ZSIsImF1dG9SZWZyZXNoRXZlbnRzIiwic2Nyb2xsZXJQcm94eSIsIm1xIiwiYWRkTGlzdGVuZXIiLCJjbGVhck1hdGNoTWVkaWEiLCJxdWVyeSIsImlzSW5WaWV3cG9ydCIsInBvc2l0aW9uSW5WaWV3cG9ydCIsInJlZmVyZW5jZVBvaW50Iiwic2F2ZVN0eWxlcyIsInNhZmUiLCJjbGVhclNjcm9sbE1lbW9yeSIsIm1heFNjcm9sbCIsImdldFNjcm9sbEZ1bmMiLCJpc1Njcm9sbGluZyIsInNuYXBEaXJlY3Rpb25hbCIsImJhdGNoIiwidmFyc0NvcHkiLCJpbnRlcnZhbCIsImJhdGNoTWF4IiwicHJveHlDYWxsYmFjayIsIl9jbGFtcFNjcm9sbEFuZEdldER1cmF0aW9uTXVsdGlwbGllciIsIl9hbGxvd05hdGl2ZVBhbm5pbmciLCJfb3ZlcmZsb3ciLCJhdXRvIiwiX25lc3RlZFNjcm9sbCIsIl9yZWY1IiwiX2lzU2Nyb2xsVCIsIl9pc1Njcm9sbCIsIl9pbnB1dE9ic2VydmVyIiwiaW5wdXRzIiwibmVzdGVkIiwiX2NhcHR1cmVJbnB1dHMiLCJfaW5wdXRFeHAiLCJfaW5wdXRJc0ZvY3VzZWQiLCJpc0lucHV0IiwiX2dldFNjcm9sbE5vcm1hbGl6ZXIiLCJfdmFyczIiLCJub3JtYWxpemVTY3JvbGxYIiwibW9tZW50dW0iLCJhbGxvd05lc3RlZFNjcm9sbCIsInNtb290aGVyIiwiU2Nyb2xsU21vb3RoZXIiLCJpbml0aWFsU2NhbGUiLCJ2aXN1YWxWaWV3cG9ydCIsIm91dGVyV2lkdGgiLCJ3aGVlbFJlZnJlc2giLCJyZXNvbHZlTW9tZW50dW1EdXJhdGlvbiIsInNraXBUb3VjaE1vdmUiLCJsYXN0UmVmcmVzaElEIiwiaW5wdXRPYnNlcnZlciIsInJlc3VtZVRvdWNoTW92ZSIsInNjcm9sbENsYW1wWCIsInNjcm9sbENsYW1wWSIsInVwZGF0ZUNsYW1wcyIsImlnbm9yZURyYWciLCJ0cmFuc2Zvcm0iLCJzdGFydFNjcm9sbFgiLCJzdGFydFNjcm9sbFkiLCJvblJlc2l6ZSIsInByZXZTY2FsZSIsImR1ciIsImN1cnJlbnRTY3JvbGwiLCJ2ZWxvY2l0eVgiLCJ2ZWxvY2l0eVkiLCJfdHMiLCJ4QXJyYXkiLCJ5QXJyYXkiLCJvYnNlcnZlIiwibm9ybWFsaXplU2Nyb2xsIiwibm9ybWFsaXplciIsInNzIiwicmVmIiwiX2NvbmZpZyIsImF1dG9TbGVlcCIsInVuaXRzIiwiX3RpbnlOdW0iLCJfMlBJIiwiX0hBTEZfUEkiLCJfZ3NJRCIsIl9pc05vdEZhbHNlIiwiX2lzRnVuY09yU3RyaW5nIiwiX2lzVHlwZWRBcnJheSIsIkFycmF5QnVmZmVyIiwiaXNWaWV3IiwiX3N0cmljdE51bUV4cCIsIl9udW1XaXRoVW5pdEV4cCIsIl9jb21wbGV4U3RyaW5nTnVtRXhwIiwiX3JlbEV4cCIsIl9kZWxpbWl0ZWRWYWx1ZUV4cCIsIl91bml0RXhwIiwiX2dsb2JhbFRpbWVsaW5lIiwiX2dsb2JhbHMiLCJfaW5zdGFsbFNjb3BlIiwiX2NvcmVSZWFkeSIsIl9pbnN0YWxsIiwic2NvcGUiLCJfbWVyZ2UiLCJfbWlzc2luZ1BsdWdpbiIsIl93YXJuIiwibWVzc2FnZSIsInN1cHByZXNzIiwiX2FkZEdsb2JhbCIsIl9yZXNlcnZlZFByb3BzIiwiX2xhenlUd2VlbnMiLCJfbGF6eUxvb2t1cCIsIl9sYXN0UmVuZGVyZWRGcmFtZSIsIl9wbHVnaW5zIiwiX2VmZmVjdHMiLCJfbmV4dEdDRnJhbWUiLCJfaGFybmVzc1BsdWdpbnMiLCJfY2FsbGJhY2tOYW1lcyIsIl9oYXJuZXNzIiwiaGFybmVzc1BsdWdpbiIsInRhcmdldFRlc3QiLCJHU0NhY2hlIiwiX2dldENhY2hlIiwiX2dldFByb3BlcnR5IiwiX2ZvckVhY2hOYW1lIiwibmFtZXMiLCJfcGFyc2VSZWxhdGl2ZSIsIm9wZXJhdG9yIiwiX2FycmF5Q29udGFpbnNBbnkiLCJ0b1NlYXJjaCIsInRvRmluZCIsIl9sYXp5UmVuZGVyIiwiX2xhenkiLCJfbGF6eVNhZmVSZW5kZXIiLCJfbnVtZXJpY0lmUG9zc2libGUiLCJ0cmltIiwiX3NldEtleWZyYW1lRGVmYXVsdHMiLCJleGNsdWRlRHVyYXRpb24iLCJiYXNlIiwidG9NZXJnZSIsIl9tZXJnZURlZXAiLCJfY29weUV4Y2x1ZGluZyIsImV4Y2x1ZGluZyIsIl9pbmhlcml0RGVmYXVsdHMiLCJrZXlmcmFtZXMiLCJpbmhlcml0IiwiX2FycmF5c01hdGNoIiwiYTEiLCJhMiIsIl9hZGRMaW5rZWRMaXN0SXRlbSIsImZpcnN0UHJvcCIsImxhc3RQcm9wIiwic29ydEJ5IiwicHJldiIsIl9wcmV2IiwiX3JlbW92ZUxpbmtlZExpc3RJdGVtIiwiX3JlbW92ZUZyb21QYXJlbnQiLCJvbmx5SWZQYXJlbnRIYXNBdXRvUmVtb3ZlIiwiYXV0b1JlbW92ZUNoaWxkcmVuIiwiX2FjdCIsIl91bmNhY2hlIiwiX2VuZCIsIl9kdXIiLCJfcmVjYWNoZUFuY2VzdG9ycyIsInRvdGFsRHVyYXRpb24iLCJfaGFzTm9QYXVzZWRBbmNlc3RvcnMiLCJfZWxhcHNlZEN5Y2xlRHVyYXRpb24iLCJfcmVwZWF0IiwiX2FuaW1hdGlvbkN5Y2xlIiwiX3JEZWxheSIsInRUaW1lIiwiY3ljbGVEdXJhdGlvbiIsIndob2xlIiwiZmxvb3IiLCJfcGFyZW50VG9DaGlsZFRvdGFsVGltZSIsInBhcmVudFRpbWUiLCJfc2V0RW5kIiwiX3J0cyIsIl9hbGlnblBsYXloZWFkIiwic21vb3RoQ2hpbGRUaW1pbmciLCJfcG9zdEFkZENoZWNrcyIsInJhd1RpbWUiLCJfelRpbWUiLCJfYWRkVG9UaW1lbGluZSIsInNraXBDaGVja3MiLCJfZGVsYXkiLCJ0aW1lU2NhbGUiLCJfaXNGcm9tT3JGcm9tU3RhcnQiLCJfcmVjZW50IiwiX3Njcm9sbFRyaWdnZXIiLCJfYXR0ZW1wdEluaXRUd2VlbiIsIl9pbml0VHdlZW4iLCJfdGlja2VyIiwiX3BhcmVudFBsYXloZWFkSXNCZWZvcmVTdGFydCIsIl9sb2NrIiwiX3JlbmRlclplcm9EdXJhdGlvblR3ZWVuIiwicHJldlJhdGlvIiwicmVwZWF0RGVsYXkiLCJpdGVyYXRpb24iLCJwcmV2SXRlcmF0aW9uIiwiX3lveW8iLCJyZXBlYXRSZWZyZXNoIiwiX2Zyb20iLCJfc3RhcnRBdCIsIl9vblVwZGF0ZSIsIl9wcm9tIiwiX2ZpbmROZXh0UGF1c2VUd2VlbiIsInByZXZUaW1lIiwiX2ZpcnN0IiwiX2xhc3QiLCJfc2V0RHVyYXRpb24iLCJza2lwVW5jYWNoZSIsImxlYXZlUGxheWhlYWQiLCJyZXBlYXQiLCJfb25VcGRhdGVUb3RhbER1cmF0aW9uIiwiVGltZWxpbmUiLCJfemVyb1Bvc2l0aW9uIiwiZW5kVGltZSIsInBlcmNlbnRBbmltYXRpb24iLCJyZWNlbnQiLCJjbGlwcGVkRHVyYXRpb24iLCJpc1BlcmNlbnQiLCJfY3JlYXRlVHdlZW5UeXBlIiwicGFyYW1zIiwiaXNMZWdhY3kiLCJ2YXJzSW5kZXgiLCJpclZhcnMiLCJydW5CYWNrd2FyZHMiLCJzdGFydEF0IiwiVHdlZW4iLCJfY29uZGl0aW9uYWxSZXR1cm4iLCJleGVjIiwiX3NsaWNlIiwiX2lzQXJyYXlMaWtlIiwibm9uRW1wdHkiLCJfZmxhdHRlbiIsImFyIiwibGVhdmVTdHJpbmdzIiwiYWNjdW11bGF0b3IiLCJfYWNjdW11bGF0b3IiLCJfd2FrZSIsInF1ZXJ5U2VsZWN0b3JBbGwiLCJzZWxlY3RvciIsInNodWZmbGUiLCJyYW5kb20iLCJkaXN0cmlidXRlIiwiZWFjaCIsIl9wYXJzZUVhc2UiLCJpc0RlY2ltYWwiLCJyYXRpb3MiLCJyYXRpb1giLCJyYXRpb1kiLCJlZGdlcyIsImRpc3RhbmNlcyIsIm9yaWdpblgiLCJvcmlnaW5ZIiwid3JhcEF0IiwiZ3JpZCIsImFtb3VudCIsIl9pbnZlcnRFYXNlIiwiX3JvdW5kTW9kaWZpZXIiLCJyYXciLCJpczJEIiwiaW5jcmVtZW50Iiwicm91bmRpbmdJbmNyZW1lbnQiLCJyZXR1cm5GdW5jdGlvbiIsInBpcGUiLCJfbGVuIiwiZnVuY3Rpb25zIiwiX2tleSIsInJlZHVjZSIsInVuaXRpemUiLCJub3JtYWxpemUiLCJtYXBSYW5nZSIsIl93cmFwQXJyYXkiLCJ3cmFwcGVyIiwicmFuZ2UiLCJ3cmFwWW95byIsInRvdGFsIiwiX3JlcGxhY2VSYW5kb20iLCJudW1zIiwiaW5NaW4iLCJpbk1heCIsIm91dE1pbiIsIm91dE1heCIsImluUmFuZ2UiLCJvdXRSYW5nZSIsImludGVycG9sYXRlIiwibXV0YXRlIiwiaXNTdHJpbmciLCJtYXN0ZXIiLCJpbnRlcnBvbGF0b3JzIiwiaWwiLCJfYWRkUHJvcFR3ZWVuIiwiX3JlbmRlclByb3BUd2VlbnMiLCJfZ2V0TGFiZWxJbkRpcmVjdGlvbiIsImZyb21UaW1lIiwiYmFja3dhcmQiLCJkaXN0YW5jZSIsImV4ZWN1dGVMYXp5Rmlyc3QiLCJfaW50ZXJydXB0IiwiX3F1aWNrVHdlZW4iLCJfY3JlYXRlUGx1Z2luIiwiaXNGdW5jIiwiaW5zdGFuY2VEZWZhdWx0cyIsIl9raWxsUHJvcFR3ZWVuc09mIiwibW9kaWZpZXIiLCJfYWRkUGx1Z2luTW9kaWZpZXIiLCJyYXdWYXJzIiwic3RhdGljcyIsImdldFNldHRlciIsIl9nZXRTZXR0ZXIiLCJfMjU1IiwiX2NvbG9yTG9va3VwIiwiYXF1YSIsImxpbWUiLCJzaWx2ZXIiLCJibGFjayIsIm1hcm9vbiIsInRlYWwiLCJibHVlIiwibmF2eSIsIndoaXRlIiwib2xpdmUiLCJ5ZWxsb3ciLCJvcmFuZ2UiLCJncmF5IiwicHVycGxlIiwiZ3JlZW4iLCJyZWQiLCJwaW5rIiwiY3lhbiIsInRyYW5zcGFyZW50IiwiX2h1ZSIsIm0xIiwic3BsaXRDb2xvciIsInRvSFNMIiwiZm9yY2VBbHBoYSIsImciLCJ3YXNIU0wiLCJwYXJzZUludCIsIk51bWJlciIsIl9jb2xvck9yZGVyRGF0YSIsIl9jb2xvckV4cCIsIl9mb3JtYXRDb2xvcnMiLCJvcmRlck1hdGNoRGF0YSIsImNvbG9ycyIsInNoZWxsIiwiUmVnRXhwIiwiX2hzbEV4cCIsIl9jb2xvclN0cmluZ0ZpbHRlciIsImNvbWJpbmVkIiwibGFzdEluZGV4IiwiX3RpY2tlckFjdGl2ZSIsIl9sYWdUaHJlc2hvbGQiLCJfYWRqdXN0ZWRMYWciLCJfc3RhcnRUaW1lIiwiX2xhc3RVcGRhdGUiLCJfZ2FwIiwiX25leHRUaW1lIiwiX2lkIiwiX3JlcSIsIl9yYWYiLCJfc2VsZiIsIl9kZWx0YSIsIl90aWNrIiwiZWxhcHNlZCIsIm1hbnVhbCIsImRpc3BhdGNoIiwiZGVsdGFSYXRpbyIsImZwcyIsIndha2UiLCJnc2FwVmVyc2lvbnMiLCJHcmVlblNvY2tHbG9iYWxzIiwic2xlZXAiLCJjYW5jZWxBbmltYXRpb25GcmFtZSIsImNsZWFyVGltZW91dCIsImxhZ1Ntb290aGluZyIsImFkanVzdGVkTGFnIiwiX2ZwcyIsInByaW9yaXRpemUiLCJfZWFzZU1hcCIsIl9jdXN0b21FYXNlRXhwIiwiX3F1b3Rlc0V4cCIsIl9wYXJzZU9iamVjdEluU3RyaW5nIiwicGFyc2VkVmFsIiwibGFzdEluZGV4T2YiLCJfdmFsdWVJblBhcmVudGhlc2VzIiwib3BlbiIsImNsb3NlIiwic3Vic3RyaW5nIiwiX2NvbmZpZ0Vhc2VGcm9tU3RyaW5nIiwiX0NFIiwiX3Byb3BhZ2F0ZVlveW9FYXNlIiwiaXNZb3lvIiwieW95b0Vhc2UiLCJfZWFzZSIsIl95RWFzZSIsImRlZmF1bHRFYXNlIiwiX2luc2VydEVhc2UiLCJlYXNlSW4iLCJlYXNlT3V0IiwiZWFzZUluT3V0IiwibG93ZXJjYXNlTmFtZSIsIl9lYXNlSW5PdXRGcm9tT3V0IiwiX2NvbmZpZ0VsYXN0aWMiLCJhbXBsaXR1ZGUiLCJwZXJpb2QiLCJhc2luIiwiX2NvbmZpZ0JhY2siLCJwb3dlciIsIkxpbmVhciIsImVhc2VOb25lIiwibm9uZSIsIm4xIiwibjIiLCJuMyIsIlN0ZXBwZWRFYXNlIiwic3RlcHMiLCJpbW1lZGlhdGVTdGFydCIsIkFuaW1hdGlvbiIsIkluZmluaXR5IiwieW95byIsInN0YXJ0VGltZSIsIl90b3RhbFRpbWUiLCJfcHRMb29rdXAiLCJfcFRpbWUiLCJfcHMiLCJpbmNsdWRlUmVwZWF0cyIsIndyYXBSZXBlYXRzIiwiZ2xvYmFsVGltZSIsImluY2x1ZGVEZWxheSIsImF0VGltZSIsInJlc3VtZSIsInRoZW4iLCJvbkZ1bGZpbGxlZCIsIlByb21pc2UiLCJyZXNvbHZlIiwiX3Jlc29sdmUiLCJfdGhlbiIsIl9BbmltYXRpb24iLCJzb3J0Q2hpbGRyZW4iLCJfcHJvdG8yIiwiZnJvbVRvIiwiZnJvbVZhcnMiLCJ0b1ZhcnMiLCJzdGFnZ2VyVG8iLCJzdGFnZ2VyIiwib25Db21wbGV0ZUFsbCIsIm9uQ29tcGxldGVBbGxQYXJhbXMiLCJvbkNvbXBsZXRlUGFyYW1zIiwic3RhZ2dlckZyb20iLCJzdGFnZ2VyRnJvbVRvIiwidER1ciIsImNyb3NzaW5nU3RhcnQiLCJwcmV2UGF1c2VkIiwicGF1c2VUd2VlbiIsInByZXZTdGFydCIsInJld2luZGluZyIsImRvZXNXcmFwIiwib25SZXBlYXQiLCJfaGFzUGF1c2UiLCJfZm9yY2luZyIsImFkanVzdGVkVGltZSIsImFkZExhYmVsIiwiZ2V0Q2hpbGRyZW4iLCJ0d2VlbnMiLCJ0aW1lbGluZXMiLCJpZ25vcmVCZWZvcmVUaW1lIiwiYW5pbWF0aW9ucyIsInJlbW92ZUxhYmVsIiwiX3RvdGFsVGltZTIiLCJhZGRQYXVzZSIsInJlbW92ZVBhdXNlIiwib25seUFjdGl2ZSIsImdldFR3ZWVuc09mIiwiX292ZXJ3cml0aW5nVHdlZW4iLCJwYXJzZWRUYXJnZXRzIiwiaXNHbG9iYWxUaW1lIiwiX3RhcmdldHMiLCJfb25TdGFydCIsIm9uU3RhcnRQYXJhbXMiLCJ0d2VlbkZyb21UbyIsImZyb21Qb3NpdGlvbiIsInRvUG9zaXRpb24iLCJuZXh0TGFiZWwiLCJhZnRlclRpbWUiLCJwcmV2aW91c0xhYmVsIiwiYmVmb3JlVGltZSIsImN1cnJlbnRMYWJlbCIsInNoaWZ0Q2hpbGRyZW4iLCJhZGp1c3RMYWJlbHMiLCJjbGVhciIsImluY2x1ZGVMYWJlbHMiLCJ1cGRhdGVSb290IiwiX2FkZENvbXBsZXhTdHJpbmdQcm9wVHdlZW4iLCJzZXR0ZXIiLCJzdHJpbmdGaWx0ZXIiLCJmdW5jUGFyYW0iLCJfcmVuZGVyQ29tcGxleFN0cmluZyIsIm1hdGNoSW5kZXgiLCJzdGFydE51bXMiLCJlbmROdW0iLCJjaHVuayIsInN0YXJ0TnVtIiwiaGFzUmFuZG9tIiwiZnAiLCJjdXJyZW50VmFsdWUiLCJfc2V0dGVyUGxhaW4iLCJfc2V0dGVyRnVuY1dpdGhQYXJhbSIsIl9zZXR0ZXJGdW5jIiwiX2ZvcmNlQWxsUHJvcFR3ZWVucyIsIl9yZW5kZXJCb29sZWFuIiwiX3JlbmRlclBsYWluIiwiX3Byb2Nlc3NWYXJzIiwiX3BhcnNlRnVuY09yU3RyaW5nIiwiX2NoZWNrUGx1Z2luIiwicHRMb29rdXAiLCJwcmlvcml0eSIsImF1dG9SZXZlcnQiLCJwcmV2U3RhcnRBdCIsImZ1bGxUYXJnZXRzIiwiYXV0b092ZXJ3cml0ZSIsIl9vdmVyd3JpdGUiLCJjbGVhblZhcnMiLCJoYXNQcmlvcml0eSIsImdzRGF0YSIsImhhcm5lc3NWYXJzIiwib3ZlcndyaXR0ZW4iLCJfcHRDYWNoZSIsIl9vcCIsIl9zb3J0UHJvcFR3ZWVuc0J5UHJpb3JpdHkiLCJfb25Jbml0IiwiX3VwZGF0ZVByb3BUd2VlbnMiLCJzdGFydElzUmVsYXRpdmUiLCJwdENhY2hlIiwiX2FkZEFsaWFzZXNUb1ZhcnMiLCJwcm9wZXJ0eUFsaWFzZXMiLCJfcGFyc2VLZXlmcmFtZSIsImFsbFByb3BzIiwiZWFzZUVhY2giLCJfc3RhZ2dlclR3ZWVuUHJvcHMiLCJfc3RhZ2dlclByb3BzVG9Ta2lwIiwiX0FuaW1hdGlvbjIiLCJza2lwSW5oZXJpdCIsIl90aGlzMyIsIl90aGlzMyR2YXJzIiwiY3VyVGFyZ2V0Iiwic3RhZ2dlckZ1bmMiLCJzdGFnZ2VyVmFyc1RvTWVyZ2UiLCJrZiIsIl9wcm90bzMiLCJraWxsaW5nVGFyZ2V0cyIsInByb3BUd2Vlbkxvb2t1cCIsImZpcnN0UFQiLCJvdmVyd3JpdHRlblByb3BzIiwiY3VyTG9va3VwIiwiY3VyT3ZlcndyaXRlUHJvcHMiLCJvblJldmVyc2VDb21wbGV0ZSIsIm9uUmV2ZXJzZUNvbXBsZXRlUGFyYW1zIiwiX3NldHRlckF0dHJpYnV0ZSIsImhhc05vbkRlcGVuZGVudFJlbWFpbmluZyIsImRlcCIsIl9zZXR0ZXJXaXRoTW9kaWZpZXIiLCJtU2V0IiwibXQiLCJwdDIiLCJwciIsInJlbmRlcmVyIiwiX3Byb3RvNCIsIlR3ZWVuTWF4IiwiVHdlZW5MaXRlIiwiVGltZWxpbmVMaXRlIiwiVGltZWxpbmVNYXgiLCJfbGVuMiIsImFyZ3MiLCJfa2V5MiIsImdldHRlciIsImZvcm1hdCIsInNldHRlcnMiLCJxdWlja1RvIiwiX21lcmdlMiIsInJlZ2lzdGVyRWZmZWN0IiwiZWZmZWN0IiwiZXh0ZW5kVGltZWxpbmUiLCJwbHVnaW5OYW1lIiwicmVnaXN0ZXJFYXNlIiwicGFyc2VFYXNlIiwiZXhwb3J0Um9vdCIsImluY2x1ZGVEZWxheWVkQ2FsbHMiLCJpbnN0YWxsIiwiZWZmZWN0cyIsImdsb2JhbFRpbWVsaW5lIiwiX2dldFBsdWdpblByb3BUd2VlbiIsIl9hZGRNb2RpZmllcnMiLCJfYnVpbGRNb2RpZmllclBsdWdpbiIsIlBvd2VyMCIsIlBvd2VyMSIsIlBvd2VyMiIsIlBvd2VyMyIsIlBvd2VyNCIsIlF1YWQiLCJDdWJpYyIsIlF1YXJ0IiwiUXVpbnQiLCJTdHJvbmciLCJFbGFzdGljIiwiQmFjayIsIkJvdW5jZSIsIlNpbmUiLCJFeHBvIiwiQ2lyYyIsIl9wbHVnaW5Jbml0dGVkIiwiX3RlbXBEaXZTdHlsZXIiLCJfcmVjZW50U2V0dGVyUGx1Z2luIiwiX3RyYW5zZm9ybVByb3BzIiwiX2hvcml6b250YWxFeHAiLCJfY29tcGxleEV4cCIsIl9wcm9wZXJ0eUFsaWFzZXMiLCJhdXRvQWxwaGEiLCJhbHBoYSIsIl9yZW5kZXJDU1NQcm9wIiwiX3JlbmRlclByb3BXaXRoRW5kIiwiX3JlbmRlckNTU1Byb3BXaXRoQmVnaW5uaW5nIiwiX3JlbmRlclJvdW5kZWRDU1NQcm9wIiwiX3JlbmRlck5vblR3ZWVuaW5nVmFsdWUiLCJfcmVuZGVyTm9uVHdlZW5pbmdWYWx1ZU9ubHlBdEVuZCIsIl9zZXR0ZXJDU1NTdHlsZSIsIl9zZXR0ZXJDU1NQcm9wIiwic2V0UHJvcGVydHkiLCJfc2V0dGVyVHJhbnNmb3JtIiwiX3NldHRlclNjYWxlIiwic2NhbGVYIiwic2NhbGVZIiwiX3NldHRlclNjYWxlV2l0aFJlbmRlciIsIl9zZXR0ZXJUcmFuc2Zvcm1XaXRoUmVuZGVyIiwiX2dldENvbXB1dGVkUHJvcGVydHkiLCJza2lwUHJlZml4RmFsbGJhY2siLCJnZXRQcm9wZXJ0eVZhbHVlIiwiX2NoZWNrUHJvcFByZWZpeCIsIl9wcmVmaXhlcyIsInByZWZlclByZWZpeCIsIl9nZXRCQm94SGFjayIsInN3YXBJZlBvc3NpYmxlIiwib2xkUGFyZW50Iiwib2xkU2libGluZyIsIm9sZENTUyIsIl9nc2FwQkJveCIsIl9nZXRBdHRyaWJ1dGVGYWxsYmFja3MiLCJhdHRyaWJ1dGVzQXJyYXkiLCJoYXNBdHRyaWJ1dGUiLCJfZ2V0QkJveCIsImVycm9yIiwiX2lzU1ZHIiwiZ2V0Q1RNIiwiX3JlbW92ZVByb3BlcnR5IiwicmVtb3ZlQXR0cmlidXRlIiwiX2FkZE5vblR3ZWVuaW5nUFQiLCJiZWdpbm5pbmciLCJvbmx5U2V0QXRFbmQiLCJfbm9uQ29udmVydGlibGVVbml0cyIsImRlZyIsInJhZCIsInR1cm4iLCJfY29udmVydFRvVW5pdCIsImN1clZhbHVlIiwiY3VyVW5pdCIsImlzUm9vdFNWRyIsIm1lYXN1cmVQcm9wZXJ0eSIsInRvUGl4ZWxzIiwidG9QZXJjZW50IiwiX2dldCIsIl9wYXJzZVRyYW5zZm9ybSIsIl9maXJzdFR3b09ubHkiLCJ6T3JpZ2luIiwiX3NwZWNpYWxQcm9wcyIsIl90d2VlbkNvbXBsZXhDU1NTdHJpbmciLCJzdGFydFZhbHVlcyIsInN0YXJ0VmFsdWUiLCJlbmRVbml0Iiwic3RhcnRVbml0IiwiZW5kVmFsdWVzIiwiX2tleXdvcmRUb1BlcmNlbnQiLCJfY29udmVydEtleXdvcmRzVG9QZXJjZW50YWdlcyIsIl9yZW5kZXJDbGVhclByb3BzIiwiY2xlYXJUcmFuc2Zvcm1zIiwiX2lkZW50aXR5MkRNYXRyaXgiLCJfcm90YXRpb25hbFByb3BlcnRpZXMiLCJfaXNOdWxsVHJhbnNmb3JtIiwiX2dldENvbXB1dGVkVHJhbnNmb3JtTWF0cml4QXNBcnJheSIsIm1hdHJpeFN0cmluZyIsIl9nZXRNYXRyaXgiLCJmb3JjZTJEIiwiYWRkZWRUb0RPTSIsImNvbnNvbGlkYXRlIiwib2Zmc2V0UGFyZW50IiwiX2FwcGx5U1ZHT3JpZ2luIiwib3JpZ2luSXNBYnNvbHV0ZSIsInNtb290aCIsIm1hdHJpeEFycmF5IiwicGx1Z2luVG9BZGRQcm9wVHdlZW5zVG8iLCJ4T3JpZ2luT2xkIiwieU9yaWdpbk9sZCIsInhPZmZzZXRPbGQiLCJ4T2Zmc2V0IiwieU9mZnNldE9sZCIsInlPZmZzZXQiLCJvcmlnaW5TcGxpdCIsImRldGVybWluYW50IiwiaW52ZXJ0ZWRTY2FsZVgiLCJ6IiwicGVyc3BlY3RpdmUiLCJhMTIiLCJhMjIiLCJ0MyIsImExMyIsImEyMyIsImEzMyIsImE0MiIsImE0MyIsImEzMiIsImZvcmNlQ1NTIiwidHJhbnNmb3JtUGVyc3BlY3RpdmUiLCJfcmVuZGVyU1ZHVHJhbnNmb3JtcyIsIl9yZW5kZXJDU1NUcmFuc2Zvcm1zIiwiX3JlbmRlck5vbjNEVHJhbnNmb3JtcyIsIl9hZGRQeFRyYW5zbGF0ZSIsIl96ZXJvRGVnIiwiX3plcm9QeCIsIl9lbmRQYXJlbnRoZXNpcyIsInRyYW5zZm9ybXMiLCJ1c2UzRCIsImExMSIsImEyMSIsInRhbiIsIl9hZGRSb3RhdGlvbmFsUHJvcFR3ZWVuIiwiY2FwIiwiZmluYWxWYWx1ZSIsIl9hc3NpZ24iLCJfYWRkUmF3VHJhbnNmb3JtUFRzIiwic3RhcnRDYWNoZSIsImV4Y2x1ZGUiLCJlbmRDYWNoZSIsIkNTU1BsdWdpbiIsInNwZWNpYWxQcm9wIiwiaXNUcmFuc2Zvcm1SZWxhdGVkIiwidHJhbnNmb3JtUHJvcFR3ZWVuIiwicGFyc2VUcmFuc2Zvcm0iLCJzbW9vdGhPcmlnaW4iLCJhdXRvUm91bmQiLCJwb3NpdGlvbkFuZFNjYWxlIiwib3RoZXJzIiwiYWxsIiwiZ3NhcFdpdGhDU1MiLCJUd2Vlbk1heFdpdGhDU1MiLCJfZGl2Q29udGFpbmVyIiwiX3N2Z0NvbnRhaW5lciIsIl9nRWwiLCJfaGFzT2Zmc2V0QnVnIiwiX3NldERvYyIsImQxIiwiX2ZvcmNlTm9uWmVyb1NjYWxlIiwiX3N2Z1RlbXBzIiwiX2RpdlRlbXBzIiwiX3N2Z093bmVyIiwiX2NyZWF0ZVNpYmxpbmciLCJfY29uc29saWRhdGUiLCJudW1iZXJPZkl0ZW1zIiwiZ2V0SXRlbSIsIl9nZXRDVE0iLCJfcGxhY2VTaWJsaW5ncyIsImFkanVzdEdPZmZzZXQiLCJzaWJsaW5ncyIsIl9zZXRNYXRyaXgiLCJiMiIsImMyIiwiZTIiLCJpbmNsdWRlU2Nyb2xsSW5GaXhlZCIsInplcm9TY2FsZXMiLCJ0ZW1wcyIsImIxIiwiYjMiLCJnbG9iYWwiLCJmYWN0b3J5IiwibW9kdWxlIiwiZXhwb3J0cyIsIkVycm9yIiwibm9HbG9iYWwiLCJhcnIiLCJnZXRQcm90byIsImdldFByb3RvdHlwZU9mIiwiZmxhdCIsImFycmF5IiwiY2xhc3MydHlwZSIsInRvU3RyaW5nIiwiaGFzT3duIiwiaGFzT3duUHJvcGVydHkiLCJmblRvU3RyaW5nIiwiT2JqZWN0RnVuY3Rpb25TdHJpbmciLCJzdXBwb3J0IiwiaXNGdW5jdGlvbiIsIml0ZW0iLCJpc1dpbmRvdyIsInByZXNlcnZlZFNjcmlwdEF0dHJpYnV0ZXMiLCJzcmMiLCJub25jZSIsIm5vTW9kdWxlIiwiRE9NRXZhbCIsImNvZGUiLCJzY3JpcHQiLCJ0ZXh0IiwiaGVhZCIsInRvVHlwZSIsImpRdWVyeSIsImZuIiwianF1ZXJ5IiwibnVtIiwicHVzaFN0YWNrIiwiZWxlbXMiLCJyZXQiLCJtZXJnZSIsInByZXZPYmplY3QiLCJlbGVtIiwiZXEiLCJldmVuIiwiZ3JlcCIsIl9lbGVtIiwib2RkIiwibGVuIiwiZXh0ZW5kIiwib3B0aW9ucyIsImNvcHlJc0FycmF5IiwiZGVlcCIsImlzUGxhaW5PYmplY3QiLCJ1bmRlZmluZWQiLCJleHBhbmRvIiwiaXNSZWFkeSIsIm1zZyIsIm5vb3AiLCJwcm90byIsIkN0b3IiLCJpc0VtcHR5T2JqZWN0IiwiZ2xvYmFsRXZhbCIsImlzQXJyYXlMaWtlIiwibWFrZUFycmF5IiwicmVzdWx0cyIsImluQXJyYXkiLCJzZWNvbmQiLCJpbnZlcnQiLCJjYWxsYmFja0ludmVyc2UiLCJjYWxsYmFja0V4cGVjdCIsImFyZyIsImd1aWQiLCJTeW1ib2wiLCJpdGVyYXRvciIsIlNpenpsZSIsIkV4cHIiLCJnZXRUZXh0IiwiaXNYTUwiLCJ0b2tlbml6ZSIsImNvbXBpbGUiLCJzZWxlY3QiLCJvdXRlcm1vc3RDb250ZXh0Iiwic29ydElucHV0IiwiaGFzRHVwbGljYXRlIiwic2V0RG9jdW1lbnQiLCJkb2NFbGVtIiwiZG9jdW1lbnRJc0hUTUwiLCJyYnVnZ3lRU0EiLCJyYnVnZ3lNYXRjaGVzIiwiY29udGFpbnMiLCJwcmVmZXJyZWREb2MiLCJkaXJydW5zIiwiZG9uZSIsImNsYXNzQ2FjaGUiLCJjcmVhdGVDYWNoZSIsInRva2VuQ2FjaGUiLCJjb21waWxlckNhY2hlIiwibm9ubmF0aXZlU2VsZWN0b3JDYWNoZSIsInNvcnRPcmRlciIsInB1c2hOYXRpdmUiLCJib29sZWFucyIsIndoaXRlc3BhY2UiLCJwc2V1ZG9zIiwicndoaXRlc3BhY2UiLCJydHJpbSIsInJjb21tYSIsInJjb21iaW5hdG9ycyIsInJkZXNjZW5kIiwicnBzZXVkbyIsInJpZGVudGlmaWVyIiwibWF0Y2hFeHByIiwicmh0bWwiLCJyaW5wdXRzIiwicmhlYWRlciIsInJuYXRpdmUiLCJycXVpY2tFeHByIiwicnNpYmxpbmciLCJydW5lc2NhcGUiLCJmdW5lc2NhcGUiLCJlc2NhcGUiLCJub25IZXgiLCJoaWdoIiwiU3RyaW5nIiwiZnJvbUNoYXJDb2RlIiwicmNzc2VzY2FwZSIsImZjc3Nlc2NhcGUiLCJjaCIsImFzQ29kZVBvaW50IiwiY2hhckNvZGVBdCIsInVubG9hZEhhbmRsZXIiLCJpbkRpc2FibGVkRmllbGRzZXQiLCJhZGRDb21iaW5hdG9yIiwiZGlzYWJsZWQiLCJkaXIiLCJjaGlsZE5vZGVzIiwiZWxzIiwic2VlZCIsIm5pZCIsImdyb3VwcyIsIm5ld1NlbGVjdG9yIiwibmV3Q29udGV4dCIsImdldEVsZW1lbnRCeUlkIiwiZ2V0RWxlbWVudHNCeVRhZ05hbWUiLCJnZXRFbGVtZW50c0J5Q2xhc3NOYW1lIiwicXNhIiwidGVzdENvbnRleHQiLCJ0b1NlbGVjdG9yIiwicXNhRXJyb3IiLCJrZXlzIiwiY2FjaGVMZW5ndGgiLCJtYXJrRnVuY3Rpb24iLCJhc3NlcnQiLCJhZGRIYW5kbGUiLCJoYW5kbGVyIiwiYXR0ckhhbmRsZSIsInNpYmxpbmdDaGVjayIsImN1ciIsImRpZmYiLCJzb3VyY2VJbmRleCIsImNyZWF0ZUlucHV0UHNldWRvIiwiY3JlYXRlQnV0dG9uUHNldWRvIiwiY3JlYXRlRGlzYWJsZWRQc2V1ZG8iLCJpc0Rpc2FibGVkIiwiY3JlYXRlUG9zaXRpb25hbFBzZXVkbyIsImFyZ3VtZW50IiwibWF0Y2hJbmRleGVzIiwibmFtZXNwYWNlIiwibmFtZXNwYWNlVVJJIiwiaGFzQ29tcGFyZSIsInN1YldpbmRvdyIsImRlZmF1bHRWaWV3IiwiYXR0YWNoRXZlbnQiLCJjcmVhdGVDb21tZW50IiwiZ2V0RWxlbWVudHNCeU5hbWUiLCJhdHRySWQiLCJmaW5kIiwiZ2V0QXR0cmlidXRlTm9kZSIsInRhZyIsInRtcCIsImlucHV0IiwibWF0Y2hlc1NlbGVjdG9yIiwid2Via2l0TWF0Y2hlc1NlbGVjdG9yIiwibW96TWF0Y2hlc1NlbGVjdG9yIiwib01hdGNoZXNTZWxlY3RvciIsIm1zTWF0Y2hlc1NlbGVjdG9yIiwiZGlzY29ubmVjdGVkTWF0Y2giLCJjb21wYXJlRG9jdW1lbnRQb3NpdGlvbiIsImFkb3duIiwiYnVwIiwiY29tcGFyZSIsInNvcnREZXRhY2hlZCIsImF1cCIsImFwIiwiYnAiLCJleHByIiwic3BlY2lmaWVkIiwic2VsIiwidW5pcXVlU29ydCIsImR1cGxpY2F0ZXMiLCJkZXRlY3REdXBsaWNhdGVzIiwic29ydFN0YWJsZSIsInRleHRDb250ZW50Iiwic2VsZWN0b3JzIiwiY3JlYXRlUHNldWRvIiwicHJlRmlsdGVyIiwiZXhjZXNzIiwidW5xdW90ZWQiLCJub2RlTmFtZVNlbGVjdG9yIiwicGF0dGVybiIsImNoZWNrIiwid2hhdCIsIl9hcmd1bWVudCIsInNpbXBsZSIsImZvcndhcmQiLCJvZlR5cGUiLCJfY29udGV4dCIsInhtbCIsInVuaXF1ZUNhY2hlIiwib3V0ZXJDYWNoZSIsIm5vZGVJbmRleCIsInVzZUNhY2hlIiwibGFzdENoaWxkIiwidW5pcXVlSUQiLCJwc2V1ZG8iLCJzZXRGaWx0ZXJzIiwiaWR4IiwibWF0Y2hlZCIsIm1hdGNoZXIiLCJ1bm1hdGNoZWQiLCJsYW5nIiwiZWxlbUxhbmciLCJoYXNoIiwibG9jYXRpb24iLCJhY3RpdmVFbGVtZW50IiwiaGFzRm9jdXMiLCJocmVmIiwidGFiSW5kZXgiLCJjaGVja2VkIiwic2VsZWN0ZWQiLCJzZWxlY3RlZEluZGV4IiwiX21hdGNoSW5kZXhlcyIsInJhZGlvIiwiY2hlY2tib3giLCJmaWxlIiwicGFzc3dvcmQiLCJpbWFnZSIsInN1Ym1pdCIsImZpbHRlcnMiLCJwYXJzZU9ubHkiLCJ0b2tlbnMiLCJzb0ZhciIsInByZUZpbHRlcnMiLCJjYWNoZWQiLCJjb21iaW5hdG9yIiwic2tpcCIsImNoZWNrTm9uRWxlbWVudHMiLCJkb25lTmFtZSIsIm9sZENhY2hlIiwibmV3Q2FjaGUiLCJlbGVtZW50TWF0Y2hlciIsIm1hdGNoZXJzIiwibXVsdGlwbGVDb250ZXh0cyIsImNvbnRleHRzIiwiY29uZGVuc2UiLCJuZXdVbm1hdGNoZWQiLCJtYXBwZWQiLCJzZXRNYXRjaGVyIiwicG9zdEZpbHRlciIsInBvc3RGaW5kZXIiLCJwb3N0U2VsZWN0b3IiLCJwcmVNYXAiLCJwb3N0TWFwIiwicHJlZXhpc3RpbmciLCJtYXRjaGVySW4iLCJtYXRjaGVyT3V0IiwibWF0Y2hlckZyb21Ub2tlbnMiLCJjaGVja0NvbnRleHQiLCJsZWFkaW5nUmVsYXRpdmUiLCJpbXBsaWNpdFJlbGF0aXZlIiwibWF0Y2hDb250ZXh0IiwibWF0Y2hBbnlDb250ZXh0IiwibWF0Y2hlckZyb21Hcm91cE1hdGNoZXJzIiwiZWxlbWVudE1hdGNoZXJzIiwic2V0TWF0Y2hlcnMiLCJieVNldCIsImJ5RWxlbWVudCIsInN1cGVyTWF0Y2hlciIsIm91dGVybW9zdCIsIm1hdGNoZWRDb3VudCIsInNldE1hdGNoZWQiLCJjb250ZXh0QmFja3VwIiwiZGlycnVuc1VuaXF1ZSIsInRva2VuIiwiY29tcGlsZWQiLCJfbmFtZSIsImRlZmF1bHRWYWx1ZSIsInVuaXF1ZSIsImlzWE1MRG9jIiwiZXNjYXBlU2VsZWN0b3IiLCJ1bnRpbCIsInRydW5jYXRlIiwiaXMiLCJybmVlZHNDb250ZXh0IiwibmVlZHNDb250ZXh0IiwicnNpbmdsZVRhZyIsIndpbm5vdyIsInF1YWxpZmllciIsIm5vdCIsInJvb3RqUXVlcnkiLCJyb290IiwicGFyc2VIVE1MIiwicmVhZHkiLCJycGFyZW50c3ByZXYiLCJndWFyYW50ZWVkVW5pcXVlIiwiY29udGVudHMiLCJoYXMiLCJwcmV2QWxsIiwiYWRkQmFjayIsInNpYmxpbmciLCJwYXJlbnRzIiwicGFyZW50c1VudGlsIiwibmV4dEFsbCIsIm5leHRVbnRpbCIsInByZXZVbnRpbCIsImNvbnRlbnREb2N1bWVudCIsInJub3RodG1sd2hpdGUiLCJjcmVhdGVPcHRpb25zIiwib2JqZWN0IiwiXyIsImZsYWciLCJDYWxsYmFja3MiLCJmaXJpbmciLCJtZW1vcnkiLCJmaXJlZCIsInF1ZXVlIiwiZmlyaW5nSW5kZXgiLCJmaXJlIiwic3RvcE9uRmFsc2UiLCJlbXB0eSIsImxvY2siLCJmaXJlV2l0aCIsIklkZW50aXR5IiwiVGhyb3dlciIsImFkb3B0VmFsdWUiLCJyZWplY3QiLCJub1ZhbHVlIiwibWV0aG9kIiwicHJvbWlzZSIsImZhaWwiLCJEZWZlcnJlZCIsInR1cGxlcyIsImFsd2F5cyIsImRlZmVycmVkIiwiZm5zIiwibmV3RGVmZXIiLCJ0dXBsZSIsInJldHVybmVkIiwibm90aWZ5Iiwib25SZWplY3RlZCIsIm9uUHJvZ3Jlc3MiLCJtYXhEZXB0aCIsImRlcHRoIiwic3BlY2lhbCIsInRoYXQiLCJtaWdodFRocm93IiwiVHlwZUVycm9yIiwibm90aWZ5V2l0aCIsInJlc29sdmVXaXRoIiwicHJvY2VzcyIsImV4Y2VwdGlvbkhvb2siLCJzdGFja1RyYWNlIiwicmVqZWN0V2l0aCIsImdldFN0YWNrSG9vayIsInN0YXRlU3RyaW5nIiwid2hlbiIsInNpbmdsZVZhbHVlIiwicmVtYWluaW5nIiwicmVzb2x2ZUNvbnRleHRzIiwicmVzb2x2ZVZhbHVlcyIsInByaW1hcnkiLCJ1cGRhdGVGdW5jIiwicmVycm9yTmFtZXMiLCJzdGFjayIsInJlYWR5RXhjZXB0aW9uIiwicmVhZHlMaXN0IiwicmVhZHlXYWl0Iiwid2FpdCIsImNvbXBsZXRlZCIsInJlYWR5U3RhdGUiLCJkb1Njcm9sbCIsImFjY2VzcyIsImNoYWluYWJsZSIsImVtcHR5R2V0IiwiYnVsayIsInJtc1ByZWZpeCIsInJkYXNoQWxwaGEiLCJmY2FtZWxDYXNlIiwiX2FsbCIsImxldHRlciIsImNhbWVsQ2FzZSIsInN0cmluZyIsImFjY2VwdERhdGEiLCJvd25lciIsIkRhdGEiLCJ1aWQiLCJoYXNEYXRhIiwiZGF0YVByaXYiLCJkYXRhVXNlciIsInJicmFjZSIsInJtdWx0aURhc2giLCJnZXREYXRhIiwiSlNPTiIsInBhcnNlIiwiZGF0YUF0dHIiLCJyZW1vdmVEYXRhIiwiX2RhdGEiLCJfcmVtb3ZlRGF0YSIsImRlcXVldWUiLCJzdGFydExlbmd0aCIsImhvb2tzIiwiX3F1ZXVlSG9va3MiLCJzdG9wIiwiY2xlYXJRdWV1ZSIsImNvdW50IiwiZGVmZXIiLCJwbnVtIiwicmNzc051bSIsImNzc0V4cGFuZCIsImlzQXR0YWNoZWQiLCJjb21wb3NlZCIsImdldFJvb3ROb2RlIiwiaXNIaWRkZW5XaXRoaW5UcmVlIiwiYWRqdXN0Q1NTIiwidmFsdWVQYXJ0cyIsImFkanVzdGVkIiwibWF4SXRlcmF0aW9ucyIsImluaXRpYWwiLCJjc3NOdW1iZXIiLCJpbml0aWFsSW5Vbml0IiwiZGVmYXVsdERpc3BsYXlNYXAiLCJnZXREZWZhdWx0RGlzcGxheSIsInNob3dIaWRlIiwic2hvdyIsImhpZGUiLCJ0b2dnbGUiLCJyY2hlY2thYmxlVHlwZSIsInJ0YWdOYW1lIiwicnNjcmlwdFR5cGUiLCJmcmFnbWVudCIsImNyZWF0ZURvY3VtZW50RnJhZ21lbnQiLCJjaGVja0Nsb25lIiwiY2xvbmVOb2RlIiwibm9DbG9uZUNoZWNrZWQiLCJvcHRpb24iLCJ3cmFwTWFwIiwidGhlYWQiLCJjb2wiLCJ0ciIsInRkIiwiX2RlZmF1bHQiLCJ0Ym9keSIsInRmb290IiwiY29sZ3JvdXAiLCJjYXB0aW9uIiwidGgiLCJvcHRncm91cCIsInNldEdsb2JhbEV2YWwiLCJyZWZFbGVtZW50cyIsImJ1aWxkRnJhZ21lbnQiLCJzY3JpcHRzIiwic2VsZWN0aW9uIiwiaWdub3JlZCIsImF0dGFjaGVkIiwibm9kZXMiLCJjcmVhdGVUZXh0Tm9kZSIsImh0bWxQcmVmaWx0ZXIiLCJydHlwZW5hbWVzcGFjZSIsInJldHVyblRydWUiLCJyZXR1cm5GYWxzZSIsImV4cGVjdFN5bmMiLCJzYWZlQWN0aXZlRWxlbWVudCIsImVyciIsIm9uIiwib25lIiwib3JpZ0ZuIiwib2ZmIiwiaGFuZGxlT2JqSW4iLCJldmVudEhhbmRsZSIsImhhbmRsZU9iaiIsImhhbmRsZXJzIiwibmFtZXNwYWNlcyIsIm9yaWdUeXBlIiwiZWxlbURhdGEiLCJ0cmlnZ2VyZWQiLCJkZWxlZ2F0ZVR5cGUiLCJiaW5kVHlwZSIsImRlbGVnYXRlQ291bnQiLCJzZXR1cCIsIm1hcHBlZFR5cGVzIiwib3JpZ0NvdW50IiwidGVhcmRvd24iLCJyZW1vdmVFdmVudCIsIm5hdGl2ZUV2ZW50IiwiaGFuZGxlclF1ZXVlIiwiZml4IiwiZGVsZWdhdGVUYXJnZXQiLCJwcmVEaXNwYXRjaCIsImlzUHJvcGFnYXRpb25TdG9wcGVkIiwiaXNJbW1lZGlhdGVQcm9wYWdhdGlvblN0b3BwZWQiLCJybmFtZXNwYWNlIiwic3RvcFByb3BhZ2F0aW9uIiwicG9zdERpc3BhdGNoIiwibWF0Y2hlZEhhbmRsZXJzIiwibWF0Y2hlZFNlbGVjdG9ycyIsImJ1dHRvbiIsImFkZFByb3AiLCJob29rIiwiRXZlbnQiLCJsb2FkIiwibm9CdWJibGUiLCJsZXZlcmFnZU5hdGl2ZSIsImJlZm9yZXVubG9hZCIsInJldHVyblZhbHVlIiwibm90QXN5bmMiLCJzYXZlZCIsImlzVHJpZ2dlciIsImlzRGVmYXVsdFByZXZlbnRlZCIsInJlbGF0ZWRUYXJnZXQiLCJ0aW1lU3RhbXAiLCJpc1NpbXVsYXRlZCIsImFsdEtleSIsImJ1YmJsZXMiLCJldmVudFBoYXNlIiwibWV0YUtleSIsInNoaWZ0S2V5IiwidmlldyIsImNoYXJDb2RlIiwia2V5Q29kZSIsImJ1dHRvbnMiLCJ0YXJnZXRUb3VjaGVzIiwiZm9jdXMiLCJibHVyIiwibW91c2VlbnRlciIsIm1vdXNlbGVhdmUiLCJwb2ludGVyZW50ZXIiLCJwb2ludGVybGVhdmUiLCJvcmlnIiwicmVsYXRlZCIsInJub0lubmVyaHRtbCIsInJjaGVja2VkIiwicmNsZWFuU2NyaXB0IiwibWFuaXB1bGF0aW9uVGFyZ2V0IiwiZGlzYWJsZVNjcmlwdCIsInJlc3RvcmVTY3JpcHQiLCJjbG9uZUNvcHlFdmVudCIsImRlc3QiLCJwZGF0YU9sZCIsInVkYXRhT2xkIiwidWRhdGFDdXIiLCJmaXhJbnB1dCIsImRvbU1hbmlwIiwiY29sbGVjdGlvbiIsImhhc1NjcmlwdHMiLCJpTm9DbG9uZSIsInZhbHVlSXNGdW5jdGlvbiIsImh0bWwiLCJfZXZhbFVybCIsImtlZXBEYXRhIiwiY2xlYW5EYXRhIiwiZGF0YUFuZEV2ZW50cyIsImRlZXBEYXRhQW5kRXZlbnRzIiwic3JjRWxlbWVudHMiLCJkZXN0RWxlbWVudHMiLCJpblBhZ2UiLCJkZXRhY2giLCJhcHBlbmQiLCJwcmVwZW5kIiwiYmVmb3JlIiwiYWZ0ZXIiLCJyZXBsYWNlV2l0aCIsInJlcGxhY2VDaGlsZCIsImFwcGVuZFRvIiwicHJlcGVuZFRvIiwiaW5zZXJ0QWZ0ZXIiLCJyZXBsYWNlQWxsIiwib3JpZ2luYWwiLCJpbnNlcnQiLCJybnVtbm9ucHgiLCJnZXRTdHlsZXMiLCJvcGVuZXIiLCJyYm94U3R5bGUiLCJjb21wdXRlU3R5bGVUZXN0cyIsImRpdlN0eWxlIiwicGl4ZWxQb3NpdGlvblZhbCIsInJlbGlhYmxlTWFyZ2luTGVmdFZhbCIsInJvdW5kUGl4ZWxNZWFzdXJlcyIsIm1hcmdpbkxlZnQiLCJwaXhlbEJveFN0eWxlc1ZhbCIsImJveFNpemluZ1JlbGlhYmxlVmFsIiwic2Nyb2xsYm94U2l6ZVZhbCIsIm1lYXN1cmUiLCJyZWxpYWJsZVRyRGltZW5zaW9uc1ZhbCIsImJhY2tncm91bmRDbGlwIiwiY2xlYXJDbG9uZVN0eWxlIiwiYm94U2l6aW5nUmVsaWFibGUiLCJwaXhlbEJveFN0eWxlcyIsInBpeGVsUG9zaXRpb24iLCJyZWxpYWJsZU1hcmdpbkxlZnQiLCJzY3JvbGxib3hTaXplIiwicmVsaWFibGVUckRpbWVuc2lvbnMiLCJ0YWJsZSIsInRyQ2hpbGQiLCJ0clN0eWxlIiwiY3VyQ1NTIiwiY29tcHV0ZWQiLCJtaW5XaWR0aCIsIm1heFdpZHRoIiwiYWRkR2V0SG9va0lmIiwiY29uZGl0aW9uRm4iLCJob29rRm4iLCJjc3NQcmVmaXhlcyIsImVtcHR5U3R5bGUiLCJ2ZW5kb3JQcm9wcyIsInZlbmRvclByb3BOYW1lIiwiY2FwTmFtZSIsImZpbmFsUHJvcE5hbWUiLCJmaW5hbCIsImNzc1Byb3BzIiwicmRpc3BsYXlzd2FwIiwicmN1c3RvbVByb3AiLCJjc3NTaG93IiwidmlzaWJpbGl0eSIsImNzc05vcm1hbFRyYW5zZm9ybSIsImxldHRlclNwYWNpbmciLCJzZXRQb3NpdGl2ZU51bWJlciIsInN1YnRyYWN0IiwiYm94TW9kZWxBZGp1c3RtZW50IiwiZGltZW5zaW9uIiwiYm94IiwiaXNCb3JkZXJCb3giLCJzdHlsZXMiLCJjb21wdXRlZFZhbCIsImV4dHJhIiwiZGVsdGEiLCJnZXRXaWR0aE9ySGVpZ2h0IiwiYm94U2l6aW5nTmVlZGVkIiwidmFsdWVJc0JvcmRlckJveCIsIm9mZnNldFByb3AiLCJnZXRDbGllbnRSZWN0cyIsImNzc0hvb2tzIiwib3BhY2l0eSIsIm9yaWdOYW1lIiwiaXNDdXN0b21Qcm9wIiwiaXNGaW5pdGUiLCJzY3JvbGxib3hTaXplQnVnZ3kiLCJtYXJnaW4iLCJwYWRkaW5nIiwicHJlZml4Iiwic3VmZml4IiwiZXhwYW5kIiwiZXhwYW5kZWQiLCJwYXJ0cyIsImVhc2luZyIsInByb3BIb29rcyIsInJ1biIsInBlcmNlbnQiLCJlYXNlZCIsInBvcyIsInN0ZXAiLCJmeCIsImxpbmVhciIsInN3aW5nIiwiZnhOb3ciLCJpblByb2dyZXNzIiwicmZ4dHlwZXMiLCJycnVuIiwic2NoZWR1bGUiLCJjcmVhdGVGeE5vdyIsImdlbkZ4IiwiaW5jbHVkZVdpZHRoIiwiY3JlYXRlVHdlZW4iLCJ0d2VlbmVycyIsImRlZmF1bHRQcmVmaWx0ZXIiLCJvcHRzIiwib2xkZmlyZSIsInJlc3RvcmVEaXNwbGF5IiwiaXNCb3giLCJhbmltIiwiZGF0YVNob3ciLCJ1bnF1ZXVlZCIsInByb3BGaWx0ZXIiLCJzcGVjaWFsRWFzaW5nIiwicHJvcGVydGllcyIsInN0b3BwZWQiLCJwcmVmaWx0ZXJzIiwiY3VycmVudFRpbWUiLCJvcmlnaW5hbFByb3BlcnRpZXMiLCJvcmlnaW5hbE9wdGlvbnMiLCJnb3RvRW5kIiwiY29tcGxldGUiLCJ0aW1lciIsInR3ZWVuZXIiLCJwcmVmaWx0ZXIiLCJzcGVlZCIsIm9wdCIsInNwZWVkcyIsImZhZGVUbyIsIm9wdGFsbCIsImRvQW5pbWF0aW9uIiwiZmluaXNoIiwic3RvcFF1ZXVlIiwidGltZXJzIiwiY3NzRm4iLCJzbGlkZURvd24iLCJzbGlkZVVwIiwic2xpZGVUb2dnbGUiLCJmYWRlSW4iLCJmYWRlT3V0IiwiZmFkZVRvZ2dsZSIsInNsb3ciLCJmYXN0IiwidGltZW91dCIsImNoZWNrT24iLCJvcHRTZWxlY3RlZCIsInJhZGlvVmFsdWUiLCJib29sSG9vayIsInJlbW92ZUF0dHIiLCJuVHlwZSIsImF0dHJIb29rcyIsImJvb2wiLCJhdHRyTmFtZXMiLCJyZm9jdXNhYmxlIiwicmNsaWNrYWJsZSIsInJlbW92ZVByb3AiLCJwcm9wRml4IiwidGFiaW5kZXgiLCJzdHJpcEFuZENvbGxhcHNlIiwiZ2V0Q2xhc3MiLCJjbGFzc2VzVG9BcnJheSIsImFkZENsYXNzIiwiY2xhc3NlcyIsImNsYXp6IiwicmVtb3ZlQ2xhc3MiLCJzdGF0ZVZhbCIsImlzVmFsaWRWYWx1ZSIsImNsYXNzTmFtZXMiLCJoYXNDbGFzcyIsInJyZXR1cm4iLCJ2YWxIb29rcyIsIm9wdGlvblNldCIsImZvY3VzaW4iLCJyZm9jdXNNb3JwaCIsInN0b3BQcm9wYWdhdGlvbkNhbGxiYWNrIiwib25seUhhbmRsZXJzIiwiYnViYmxlVHlwZSIsIm9udHlwZSIsImxhc3RFbGVtZW50IiwiZXZlbnRQYXRoIiwicGFyZW50V2luZG93Iiwic2ltdWxhdGUiLCJ0cmlnZ2VySGFuZGxlciIsImF0dGFjaGVzIiwicnF1ZXJ5IiwicGFyc2VYTUwiLCJwYXJzZXJFcnJvckVsZW0iLCJET01QYXJzZXIiLCJwYXJzZUZyb21TdHJpbmciLCJyYnJhY2tldCIsInJDUkxGIiwicnN1Ym1pdHRlclR5cGVzIiwicnN1Ym1pdHRhYmxlIiwiYnVpbGRQYXJhbXMiLCJ0cmFkaXRpb25hbCIsInBhcmFtIiwidmFsdWVPckZ1bmN0aW9uIiwiZW5jb2RlVVJJQ29tcG9uZW50Iiwic2VyaWFsaXplIiwic2VyaWFsaXplQXJyYXkiLCJyMjAiLCJyaGFzaCIsInJhbnRpQ2FjaGUiLCJyaGVhZGVycyIsInJsb2NhbFByb3RvY29sIiwicm5vQ29udGVudCIsInJwcm90b2NvbCIsInRyYW5zcG9ydHMiLCJhbGxUeXBlcyIsIm9yaWdpbkFuY2hvciIsImFkZFRvUHJlZmlsdGVyc09yVHJhbnNwb3J0cyIsInN0cnVjdHVyZSIsImRhdGFUeXBlRXhwcmVzc2lvbiIsImRhdGFUeXBlIiwiZGF0YVR5cGVzIiwiaW5zcGVjdFByZWZpbHRlcnNPclRyYW5zcG9ydHMiLCJqcVhIUiIsImluc3BlY3RlZCIsInNlZWtpbmdUcmFuc3BvcnQiLCJpbnNwZWN0IiwicHJlZmlsdGVyT3JGYWN0b3J5IiwiZGF0YVR5cGVPclRyYW5zcG9ydCIsImFqYXhFeHRlbmQiLCJmbGF0T3B0aW9ucyIsImFqYXhTZXR0aW5ncyIsImFqYXhIYW5kbGVSZXNwb25zZXMiLCJyZXNwb25zZXMiLCJjdCIsImZpbmFsRGF0YVR5cGUiLCJmaXJzdERhdGFUeXBlIiwibWltZVR5cGUiLCJnZXRSZXNwb25zZUhlYWRlciIsImNvbnZlcnRlcnMiLCJhamF4Q29udmVydCIsInJlc3BvbnNlIiwiaXNTdWNjZXNzIiwiY29udjIiLCJjb252IiwicmVzcG9uc2VGaWVsZHMiLCJkYXRhRmlsdGVyIiwiYWN0aXZlIiwibGFzdE1vZGlmaWVkIiwiZXRhZyIsInVybCIsImlzTG9jYWwiLCJwcm90b2NvbCIsInByb2Nlc3NEYXRhIiwiYXN5bmMiLCJjb250ZW50VHlwZSIsImFjY2VwdHMiLCJqc29uIiwiYWpheFNldHVwIiwic2V0dGluZ3MiLCJhamF4UHJlZmlsdGVyIiwiYWpheFRyYW5zcG9ydCIsImFqYXgiLCJ0cmFuc3BvcnQiLCJjYWNoZVVSTCIsInJlc3BvbnNlSGVhZGVyc1N0cmluZyIsInJlc3BvbnNlSGVhZGVycyIsInRpbWVvdXRUaW1lciIsInVybEFuY2hvciIsImZpcmVHbG9iYWxzIiwidW5jYWNoZWQiLCJjYWxsYmFja0NvbnRleHQiLCJnbG9iYWxFdmVudENvbnRleHQiLCJjb21wbGV0ZURlZmVycmVkIiwic3RhdHVzQ29kZSIsInJlcXVlc3RIZWFkZXJzIiwicmVxdWVzdEhlYWRlcnNOYW1lcyIsInN0ckFib3J0IiwiZ2V0QWxsUmVzcG9uc2VIZWFkZXJzIiwic2V0UmVxdWVzdEhlYWRlciIsIm92ZXJyaWRlTWltZVR5cGUiLCJzdGF0dXMiLCJhYm9ydCIsInN0YXR1c1RleHQiLCJmaW5hbFRleHQiLCJjcm9zc0RvbWFpbiIsImhhc0NvbnRlbnQiLCJpZk1vZGlmaWVkIiwiaGVhZGVycyIsImJlZm9yZVNlbmQiLCJzdWNjZXNzIiwic2VuZCIsIm5hdGl2ZVN0YXR1c1RleHQiLCJtb2RpZmllZCIsImdldEpTT04iLCJnZXRTY3JpcHQiLCJ3cmFwQWxsIiwiZmlyc3RFbGVtZW50Q2hpbGQiLCJ3cmFwSW5uZXIiLCJodG1sSXNGdW5jdGlvbiIsInVud3JhcCIsInZpc2libGUiLCJ4aHIiLCJYTUxIdHRwUmVxdWVzdCIsInhoclN1Y2Nlc3NTdGF0dXMiLCJ4aHJTdXBwb3J0ZWQiLCJjb3JzIiwiZXJyb3JDYWxsYmFjayIsInVzZXJuYW1lIiwieGhyRmllbGRzIiwib25sb2FkIiwib25lcnJvciIsIm9uYWJvcnQiLCJvbnRpbWVvdXQiLCJvbnJlYWR5c3RhdGVjaGFuZ2UiLCJyZXNwb25zZVR5cGUiLCJyZXNwb25zZVRleHQiLCJiaW5hcnkiLCJzY3JpcHRBdHRycyIsImNoYXJzZXQiLCJzY3JpcHRDaGFyc2V0IiwiZXZ0Iiwib2xkQ2FsbGJhY2tzIiwicmpzb25wIiwianNvbnAiLCJqc29ucENhbGxiYWNrIiwib3JpZ2luYWxTZXR0aW5ncyIsInJlc3BvbnNlQ29udGFpbmVyIiwianNvblByb3AiLCJjcmVhdGVIVE1MRG9jdW1lbnQiLCJpbXBsZW1lbnRhdGlvbiIsImtlZXBTY3JpcHRzIiwicGFyc2VkIiwiYW5pbWF0ZWQiLCJzZXRPZmZzZXQiLCJjdXJQb3NpdGlvbiIsImN1ckxlZnQiLCJjdXJDU1NUb3AiLCJjdXJUb3AiLCJjdXJPZmZzZXQiLCJjdXJDU1NMZWZ0IiwiY2FsY3VsYXRlUG9zaXRpb24iLCJjdXJFbGVtIiwidXNpbmciLCJ3aW4iLCJwYXJlbnRPZmZzZXQiLCJIZWlnaHQiLCJXaWR0aCIsImRlZmF1bHRFeHRyYSIsImZ1bmNOYW1lIiwidW5iaW5kIiwiZGVsZWdhdGUiLCJ1bmRlbGVnYXRlIiwiaG92ZXIiLCJmbk92ZXIiLCJmbk91dCIsInByb3h5IiwiaG9sZFJlYWR5IiwiaG9sZCIsInBhcnNlSlNPTiIsImlzTnVtZXJpYyIsImRlZmluZSIsImFtZCIsIl9qUXVlcnkiLCJfJCIsIiQiLCJub0NvbmZsaWN0IiwicmVxdWlyZSIsIlNsaWNrIiwiaW5zdGFuY2VVaWQiLCJkYXRhU2V0dGluZ3MiLCJhY2Nlc3NpYmlsaXR5IiwiYWRhcHRpdmVIZWlnaHQiLCJhcHBlbmRBcnJvd3MiLCJhcHBlbmREb3RzIiwiYXJyb3dzIiwiYXNOYXZGb3IiLCJwcmV2QXJyb3ciLCJuZXh0QXJyb3ciLCJhdXRvcGxheSIsImF1dG9wbGF5U3BlZWQiLCJjZW50ZXJNb2RlIiwiY2VudGVyUGFkZGluZyIsImNzc0Vhc2UiLCJjdXN0b21QYWdpbmciLCJzbGlkZXIiLCJkb3RzIiwiZG90c0NsYXNzIiwiZWRnZUZyaWN0aW9uIiwiZmFkZSIsImZvY3VzT25TZWxlY3QiLCJmb2N1c09uQ2hhbmdlIiwiaW5maW5pdGUiLCJpbml0aWFsU2xpZGUiLCJsYXp5TG9hZCIsIm1vYmlsZUZpcnN0IiwicGF1c2VPbkhvdmVyIiwicGF1c2VPbkZvY3VzIiwicGF1c2VPbkRvdHNIb3ZlciIsInJlc3BvbmRUbyIsInJlc3BvbnNpdmUiLCJyb3dzIiwicnRsIiwic2xpZGUiLCJzbGlkZXNQZXJSb3ciLCJzbGlkZXNUb1Nob3ciLCJzbGlkZXNUb1Njcm9sbCIsInN3aXBlIiwic3dpcGVUb1NsaWRlIiwidG91Y2hNb3ZlIiwidG91Y2hUaHJlc2hvbGQiLCJ1c2VDU1MiLCJ1c2VUcmFuc2Zvcm0iLCJ2YXJpYWJsZVdpZHRoIiwidmVydGljYWwiLCJ2ZXJ0aWNhbFN3aXBpbmciLCJ3YWl0Rm9yQW5pbWF0ZSIsImluaXRpYWxzIiwiYW5pbWF0aW5nIiwiYXV0b1BsYXlUaW1lciIsImN1cnJlbnREaXJlY3Rpb24iLCJjdXJyZW50TGVmdCIsImN1cnJlbnRTbGlkZSIsIiRkb3RzIiwibGlzdFdpZHRoIiwibGlzdEhlaWdodCIsImxvYWRJbmRleCIsIiRuZXh0QXJyb3ciLCIkcHJldkFycm93Iiwic2Nyb2xsaW5nIiwic2xpZGVDb3VudCIsInNsaWRlV2lkdGgiLCIkc2xpZGVUcmFjayIsIiRzbGlkZXMiLCJzbGlkaW5nIiwic2xpZGVPZmZzZXQiLCJzd2lwZUxlZnQiLCJzd2lwaW5nIiwiJGxpc3QiLCJ0b3VjaE9iamVjdCIsInRyYW5zZm9ybXNFbmFibGVkIiwidW5zbGlja2VkIiwiYWN0aXZlQnJlYWtwb2ludCIsImFuaW1UeXBlIiwiYW5pbVByb3AiLCJicmVha3BvaW50cyIsImJyZWFrcG9pbnRTZXR0aW5ncyIsImNzc1RyYW5zaXRpb25zIiwiZm9jdXNzZWQiLCJwb3NpdGlvblByb3AiLCJyb3dDb3VudCIsInNob3VsZENsaWNrIiwiJHNsaWRlciIsIiRzbGlkZXNDYWNoZSIsInRyYW5zZm9ybVR5cGUiLCJ0cmFuc2l0aW9uVHlwZSIsInZpc2liaWxpdHlDaGFuZ2UiLCJ3aW5kb3dXaWR0aCIsIndpbmRvd1RpbWVyIiwibW96SGlkZGVuIiwid2Via2l0SGlkZGVuIiwiYXV0b1BsYXkiLCJhdXRvUGxheUNsZWFyIiwiYXV0b1BsYXlJdGVyYXRvciIsImNoYW5nZVNsaWRlIiwiY2xpY2tIYW5kbGVyIiwic2VsZWN0SGFuZGxlciIsInNldFBvc2l0aW9uIiwic3dpcGVIYW5kbGVyIiwiZHJhZ0hhbmRsZXIiLCJrZXlIYW5kbGVyIiwiaHRtbEV4cHIiLCJyZWdpc3RlckJyZWFrcG9pbnRzIiwiYWN0aXZhdGVBREEiLCJhZGRTbGlkZSIsInNsaWNrQWRkIiwibWFya3VwIiwiYWRkQmVmb3JlIiwidW5sb2FkIiwicmVpbml0IiwiYW5pbWF0ZUhlaWdodCIsInRhcmdldEhlaWdodCIsIm91dGVySGVpZ2h0IiwiYW5pbWF0ZVNsaWRlIiwidGFyZ2V0TGVmdCIsImFuaW1Qcm9wcyIsImFuaW1TdGFydCIsImFwcGx5VHJhbnNpdGlvbiIsImRpc2FibGVUcmFuc2l0aW9uIiwiZ2V0TmF2VGFyZ2V0Iiwic2xpY2siLCJzbGlkZUhhbmRsZXIiLCJ0cmFuc2l0aW9uIiwic2xpZGVUbyIsImJ1aWxkQXJyb3dzIiwiYnVpbGREb3RzIiwiZG90IiwiZ2V0RG90Q291bnQiLCJidWlsZE91dCIsInNldHVwSW5maW5pdGUiLCJ1cGRhdGVEb3RzIiwic2V0U2xpZGVDbGFzc2VzIiwiYnVpbGRSb3dzIiwibmV3U2xpZGVzIiwibnVtT2ZTbGlkZXMiLCJvcmlnaW5hbFNsaWRlcyIsInNsaWRlc1BlclNlY3Rpb24iLCJyb3ciLCJjaGVja1Jlc3BvbnNpdmUiLCJmb3JjZVVwZGF0ZSIsImJyZWFrcG9pbnQiLCJ0YXJnZXRCcmVha3BvaW50IiwicmVzcG9uZFRvV2lkdGgiLCJ0cmlnZ2VyQnJlYWtwb2ludCIsInNsaWRlcldpZHRoIiwidW5zbGljayIsImRvbnRBbmltYXRlIiwiJHRhcmdldCIsImluZGV4T2Zmc2V0IiwidW5ldmVuT2Zmc2V0IiwiY2hlY2tOYXZpZ2FibGUiLCJuYXZpZ2FibGVzIiwicHJldk5hdmlnYWJsZSIsImdldE5hdmlnYWJsZUluZGV4ZXMiLCJjbGVhblVwRXZlbnRzIiwiaW50ZXJydXB0IiwiY2xlYW5VcFNsaWRlRXZlbnRzIiwib3JpZW50YXRpb25DaGFuZ2UiLCJyZXNpemUiLCJjbGVhblVwUm93cyIsImRlc3Ryb3kiLCJmYWRlU2xpZGUiLCJzbGlkZUluZGV4IiwiZmFkZVNsaWRlT3V0IiwiZmlsdGVyU2xpZGVzIiwic2xpY2tGaWx0ZXIiLCJmb2N1c0hhbmRsZXIiLCIkc2YiLCJnZXRDdXJyZW50Iiwic2xpY2tDdXJyZW50U2xpZGUiLCJicmVha1BvaW50IiwiY291bnRlciIsInBhZ2VyUXR5IiwiZ2V0TGVmdCIsInZlcnRpY2FsSGVpZ2h0IiwidmVydGljYWxPZmZzZXQiLCJ0YXJnZXRTbGlkZSIsImdldE9wdGlvbiIsInNsaWNrR2V0T3B0aW9uIiwiaW5kZXhlcyIsImdldFNsaWNrIiwiZ2V0U2xpZGVDb3VudCIsInNsaWRlc1RyYXZlcnNlZCIsInN3aXBlZFNsaWRlIiwiY2VudGVyT2Zmc2V0IiwiZ29UbyIsInNsaWNrR29UbyIsImNyZWF0aW9uIiwic2V0UHJvcHMiLCJzdGFydExvYWQiLCJsb2FkU2xpZGVyIiwiaW5pdGlhbGl6ZUV2ZW50cyIsInVwZGF0ZUFycm93cyIsImluaXRBREEiLCJudW1Eb3RHcm91cHMiLCJ0YWJDb250cm9sSW5kZXhlcyIsInNsaWRlQ29udHJvbEluZGV4IiwiYXJpYUJ1dHRvbkNvbnRyb2wiLCJtYXBwZWRTbGlkZUluZGV4IiwiaW5pdEFycm93RXZlbnRzIiwiaW5pdERvdEV2ZW50cyIsImluaXRTbGlkZUV2ZW50cyIsImluaXRVSSIsImxvYWRSYW5nZSIsImNsb25lUmFuZ2UiLCJyYW5nZVN0YXJ0IiwicmFuZ2VFbmQiLCJsb2FkSW1hZ2VzIiwiaW1hZ2VzU2NvcGUiLCJpbWFnZVNvdXJjZSIsImltYWdlU3JjU2V0IiwiaW1hZ2VTaXplcyIsImltYWdlVG9Mb2FkIiwicHJldlNsaWRlIiwibmV4dFNsaWRlIiwicHJvZ3Jlc3NpdmVMYXp5TG9hZCIsInNsaWNrTmV4dCIsInNsaWNrUGF1c2UiLCJzbGlja1BsYXkiLCJwb3N0U2xpZGUiLCIkY3VycmVudFNsaWRlIiwic2xpY2tQcmV2IiwidHJ5Q291bnQiLCIkaW1nc1RvTG9hZCIsImluaXRpYWxpemluZyIsImxhc3RWaXNpYmxlSW5kZXgiLCJjdXJyZW50QnJlYWtwb2ludCIsInJlc3BvbnNpdmVTZXR0aW5ncyIsIndpbmRvd0RlbGF5IiwicmVtb3ZlU2xpZGUiLCJzbGlja1JlbW92ZSIsInJlbW92ZUJlZm9yZSIsInJlbW92ZUFsbCIsInNldENTUyIsInBvc2l0aW9uUHJvcHMiLCJzZXREaW1lbnNpb25zIiwic2V0RmFkZSIsInNldEhlaWdodCIsInNldE9wdGlvbiIsInNsaWNrU2V0T3B0aW9uIiwiV2Via2l0VHJhbnNpdGlvbiIsIk1velRyYW5zaXRpb24iLCJtc1RyYW5zaXRpb24iLCJPVHJhbnNmb3JtIiwicGVyc3BlY3RpdmVQcm9wZXJ0eSIsIndlYmtpdFBlcnNwZWN0aXZlIiwiTW96VHJhbnNmb3JtIiwiTW96UGVyc3BlY3RpdmUiLCJ3ZWJraXRUcmFuc2Zvcm0iLCJtc1RyYW5zZm9ybSIsImFsbFNsaWRlcyIsInJlbWFpbmRlciIsImV2ZW5Db2VmIiwiaW5maW5pdGVDb3VudCIsInRhcmdldEVsZW1lbnQiLCJzeW5jIiwiYW5pbVNsaWRlIiwib2xkU2xpZGUiLCJzbGlkZUxlZnQiLCJuYXZUYXJnZXQiLCJzd2lwZURpcmVjdGlvbiIsInhEaXN0IiwieURpc3QiLCJzd2lwZUFuZ2xlIiwic3dpcGVFbmQiLCJzd2lwZUxlbmd0aCIsImVkZ2VIaXQiLCJtaW5Td2lwZSIsImZpbmdlckNvdW50Iiwic3dpcGVTdGFydCIsInN3aXBlTW92ZSIsImVkZ2VXYXNIaXQiLCJwb3NpdGlvbk9mZnNldCIsInZlcnRpY2FsU3dpcGVMZW5ndGgiLCJ1bmZpbHRlclNsaWRlcyIsInNsaWNrVW5maWx0ZXIiLCJmcm9tQnJlYWtwb2ludCJdLCJzb3VyY2VSb290IjoiIn0=